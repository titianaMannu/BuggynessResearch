{"sha":"d6c94da5751258c7868c7fd3232bafaf55090af9","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkNmM5NGRhNTc1MTI1OGM3ODY4YzdmZDMyMzJiYWZhZjU1MDkwYWY5","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-10-08T09:08:17Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2014-10-08T09:08:17Z"},"message":"BookKeeper 4.3.0 release.\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.3.0@1630038 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0444ea6874c3f1003e7c49d1c941cf908093e83f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0444ea6874c3f1003e7c49d1c941cf908093e83f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d6c94da5751258c7868c7fd3232bafaf55090af9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d6c94da5751258c7868c7fd3232bafaf55090af9","html_url":"https://github.com/apache/bookkeeper/commit/d6c94da5751258c7868c7fd3232bafaf55090af9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d6c94da5751258c7868c7fd3232bafaf55090af9/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"546bd57d4e80290815300868464acf9e9351702b","url":"https://api.github.com/repos/apache/bookkeeper/commits/546bd57d4e80290815300868464acf9e9351702b","html_url":"https://github.com/apache/bookkeeper/commit/546bd57d4e80290815300868464acf9e9351702b"}],"stats":{"total":189200,"additions":189200,"deletions":0},"files":[{"sha":"346d74b34b1a728f38b0a74e036fc88b1c0e8474","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.data;\n+\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+\n+/**\n+ * Wrapper class to store all of the data points needed to encapsulate Message\n+ * Consumption in the Subscribe flow for consuming a message sent from the\n+ * server for a given TopicSubscriber. This will be used as the Context in the\n+ * VoidCallback for the MessageHandlers once they've completed consuming the\n+ * message.\n+ *\n+ */\n+public class MessageConsumeData {\n+\n+    // Member variables\n+    public final TopicSubscriber topicSubscriber;\n+    // This is the Message sent from the server for Subscribes for consumption\n+    // by the client.\n+    public final Message msg;\n+\n+    // Constructor\n+    public MessageConsumeData(final TopicSubscriber topicSubscriber, final Message msg) {\n+        this.topicSubscriber = topicSubscriber;\n+        this.msg = msg;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        if (topicSubscriber != null) {\n+            sb.append(\"Subscription: \").append(topicSubscriber);\n+        }\n+        if (msg != null) {\n+            sb.append(PubSubData.COMMA).append(\"Message: \").append(msg);\n+        }\n+        return sb.toString();\n+    }\n+}"},{"sha":"63547a0fdafff58646fe83f713c16d9741aa0abd","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.data;\n+\n+import java.util.List;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Wrapper class to store all of the data points needed to encapsulate all\n+ * PubSub type of request operations the client will do. This includes knowing\n+ * all of the information needed if we need to redo the publish/subscribe\n+ * request in case of a server redirect. This will be used for all sync/async\n+ * calls, and for all the known types of request messages to send to the server\n+ * hubs: Publish, Subscribe, Unsubscribe, and Consume.\n+ *\n+ */\n+public class PubSubData {\n+    // Static string constants\n+    protected static final String COMMA = \", \";\n+\n+    // Member variables needed during object construction time.\n+    public final ByteString topic;\n+    public final Message msg;\n+    public final ByteString subscriberId;\n+    // Enum to indicate what type of operation this PubSub request data object\n+    // is for.\n+    public final OperationType operationType;\n+    // Options for the subscription\n+    public final SubscriptionOptions options;\n+\n+    // These two variables are not final since we might override them\n+    // in the case of a Subscribe reconnect.\n+    private Callback<PubSubProtocol.ResponseBody> callback;\n+\n+    public Object context;\n+\n+    // Member variables used after object has been constructed.\n+    // List of all servers we've sent the PubSubRequest to successfully.\n+    // This is to keep track of redirected servers that responded back to us.\n+    public List<ByteString> triedServers;\n+    // List of all servers that we've tried to connect or write to but\n+    // was unsuccessful. We'll retry sending the PubSubRequest but will\n+    // quit if we're trying to connect or write to a server that we've\n+    // attempted to previously.\n+    public List<ByteString> connectFailedServers;\n+    public List<ByteString> writeFailedServers;\n+    // Boolean to the hub server indicating if it should claim ownership\n+    // of the topic the PubSubRequest is for. This is mainly used after\n+    // a server redirect. Defaults to false.\n+    public boolean shouldClaim = false;\n+    // TxnID for the PubSubData if it was sent as a PubSubRequest to the hub\n+    // server. This is used in the WriteCallback in case of failure. We want\n+    // to remove it from the ResponseHandler.txn2PubSubData map since the\n+    // failed PubSubRequest will not get an ack response from the server.\n+    // This is set later in the PubSub flows only when we write the actual\n+    // request. Therefore it is not an argument in the constructor.\n+    public long txnId;\n+    // Time in milliseconds using the System.currentTimeMillis() call when the\n+    // PubSubRequest was written on the netty Channel to the server.\n+    public long requestWriteTime;\n+    // For synchronous calls, this variable is used to know when the background\n+    // async process for it has completed, set in the VoidCallback.\n+    public boolean isDone = false;\n+    // Record the original channel for a resubscribe request\n+    private HChannel origChannel = null;\n+\n+    // Constructor for all types of PubSub request data to send to the server\n+    public PubSubData(final ByteString topic, final Message msg, final ByteString subscriberId,\n+                      final OperationType operationType, final SubscriptionOptions options,\n+                      final Callback<PubSubProtocol.ResponseBody> callback,\n+                      final Object context) {\n+        this.topic = topic;\n+        this.msg = msg;\n+        this.subscriberId = subscriberId;\n+        this.operationType = operationType;\n+        this.options = options;\n+        this.callback = callback;\n+        this.context = context;\n+    }\n+\n+    public void setCallback(Callback<PubSubProtocol.ResponseBody> callback) {\n+        this.callback = callback;\n+    }\n+\n+    public Callback<PubSubProtocol.ResponseBody> getCallback() {\n+        return callback;\n+    }\n+\n+    public void operationFinishedToCallback(Object context, PubSubProtocol.ResponseBody response){\n+        callback.operationFinished(context, response);\n+    }\n+\n+    public boolean isResubscribeRequest() {\n+        return null != origChannel;\n+    }\n+\n+    public HChannel getOriginalChannelForResubscribe() {\n+        return origChannel;\n+    }\n+\n+    public void setOriginalChannelForResubscribe(HChannel channel) {\n+        this.origChannel = channel;\n+    }\n+\n+    // Clear all of the stored servers we've contacted or attempted to in this\n+    // request.\n+    public void clearServersList() {\n+        if (triedServers != null)\n+            triedServers.clear();\n+        if (connectFailedServers != null)\n+            connectFailedServers.clear();\n+        if (writeFailedServers != null)\n+            writeFailedServers.clear();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        if (topic != null)\n+            sb.append(\"Topic: \" + topic.toStringUtf8());\n+        if (msg != null)\n+            sb.append(COMMA).append(\"Message: \" + msg);\n+        if (subscriberId != null)\n+            sb.append(COMMA).append(\"SubscriberId: \" + subscriberId.toStringUtf8());\n+        if (operationType != null)\n+            sb.append(COMMA).append(\"Operation Type: \" + operationType.toString());\n+        if (options != null)\n+            sb.append(COMMA).append(\"Create Or Attach: \" + options.getCreateOrAttach().toString())\n+                .append(COMMA).append(\"Message Bound: \" + options.getMessageBound());\n+        if (triedServers != null && triedServers.size() > 0) {\n+            sb.append(COMMA).append(\"Tried Servers: \");\n+            for (ByteString triedServer : triedServers) {\n+                sb.append(triedServer.toStringUtf8()).append(COMMA);\n+            }\n+        }\n+        if (connectFailedServers != null && connectFailedServers.size() > 0) {\n+            sb.append(COMMA).append(\"Connect Failed Servers: \");\n+            for (ByteString connectFailedServer : connectFailedServers) {\n+                sb.append(connectFailedServer.toStringUtf8()).append(COMMA);\n+            }\n+        }\n+        if (writeFailedServers != null && writeFailedServers.size() > 0) {\n+            sb.append(COMMA).append(\"Write Failed Servers: \");\n+            for (ByteString writeFailedServer : writeFailedServers) {\n+                sb.append(writeFailedServer.toStringUtf8()).append(COMMA);\n+            }\n+        }\n+        sb.append(COMMA).append(\"Should Claim: \" + shouldClaim);\n+        if (txnId != 0)\n+            sb.append(COMMA).append(\"TxnID: \" + txnId);\n+        if (requestWriteTime != 0)\n+            sb.append(COMMA).append(\"Request Write Time: \" + requestWriteTime);\n+        sb.append(COMMA).append(\"Is Done: \" + isDone);\n+        return sb.toString();\n+    }\n+\n+}"},{"sha":"064cec12d379684adec3a4f33a46f22625919783","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/data/TopicSubscriber.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.data;\n+\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Wrapper class object for the Topic + SubscriberId combination. Since the\n+ * Subscribe flows always use the Topic + SubscriberId as the logical entity,\n+ * we'll create a simple class to encapsulate that.\n+ *\n+ */\n+public class TopicSubscriber {\n+    private final ByteString topic;\n+    private final ByteString subscriberId;\n+    private final int hashCode;\n+\n+    public TopicSubscriber(final ByteString topic, final ByteString subscriberId) {\n+        this.topic = topic;\n+        this.subscriberId = subscriberId;\n+        hashCode = new HashCodeBuilder().append(topic).append(subscriberId).toHashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (o == this)\n+            return true;\n+        if (!(o instanceof TopicSubscriber))\n+            return false;\n+        final TopicSubscriber obj = (TopicSubscriber) o;\n+        return topic.equals(obj.topic) && subscriberId.equals(obj.subscriberId);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        if (topic != null)\n+            sb.append(\"Topic: \" + topic.toStringUtf8());\n+        if (subscriberId != null)\n+            sb.append(PubSubData.COMMA).append(\"SubscriberId: \" + subscriberId.toStringUtf8());\n+        return sb.toString();\n+    }\n+\n+    public ByteString getTopic() {\n+        return topic;\n+    }\n+\n+    public ByteString getSubscriberId() {\n+        return subscriberId;\n+    }\n+\n+}"},{"sha":"5f468e6d3f5b05408946f3485861e8004d13f030","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when the local client wants to\n+ * startDelivery using another message handler before stopping previous one.\n+ */\n+public class AlreadyStartDeliveryException extends Exception {\n+\n+    private static final long serialVersionUID = 873259807218723524L;\n+\n+    public AlreadyStartDeliveryException(String message) {\n+        super(message);\n+    }\n+\n+    public AlreadyStartDeliveryException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"3e543569f09f1dab37b23542115faeb85c088e85","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/InvalidSubscriberIdException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when the local client wants to do\n+ * subscribe type of operations. Currently, to distinguish between local and hub\n+ * subscribers, the subscriberId will have a specific format.\n+ */\n+public class InvalidSubscriberIdException extends Exception {\n+\n+    private static final long serialVersionUID = 873259807218723523L;\n+\n+    public InvalidSubscriberIdException(String message) {\n+        super(message);\n+    }\n+\n+    public InvalidSubscriberIdException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"22b44b16f649b0efd93b9530164ae9aad9b962e5","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/NoResponseHandlerException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception thrown when it can't get the response\n+ * handler from the channel pipeline responsible for a PubSubRequest.\n+ */\n+public class NoResponseHandlerException extends Exception {\n+    private static final long serialVersionUID = 1L;\n+\n+    public NoResponseHandlerException(String message) {\n+        super(message);\n+    }\n+\n+    public NoResponseHandlerException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+}"},{"sha":"c9aeb385307340e75c03e24195d333ef0fbc5933","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ResubscribeException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when the client failed to resubscribe\n+ * when topic moved or subscription is closed.\n+ */\n+public class ResubscribeException extends Exception {\n+\n+    public ResubscribeException(String message) {\n+        super(message);\n+    }\n+\n+    public ResubscribeException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"da6d4e7d39ee0a1359a9f2dcb364697e3ae25384","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/ServerRedirectLoopException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,38 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when the PubSubRequest is being\n+ * redirected to a server where the request has already been sent to previously.\n+ * To avoid having a cyclical redirect loop, this condition is checked for\n+ * and this exception will be thrown to the client caller.\n+ */\n+public class ServerRedirectLoopException extends Exception {\n+\n+    private static final long serialVersionUID = 98723508723152897L;\n+\n+    public ServerRedirectLoopException(String message) {\n+        super(message);\n+    }\n+\n+    public ServerRedirectLoopException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"4a3c99f0f42beea2858fc203a824a1d93a2a3885","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/TooManyServerRedirectsException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.exceptions;\n+\n+/**\n+ * This is a Hedwig client side exception when there have been too many server\n+ * redirects during a publish/subscribe call. We only allow a certain number of\n+ * server redirects to find the topic master. If we have exceeded this\n+ * configured amount, the publish/subscribe will fail with this exception.\n+ *\n+ */\n+public class TooManyServerRedirectsException extends Exception {\n+\n+    private static final long serialVersionUID = 2341192937965635310L;\n+\n+    public TooManyServerRedirectsException(String message) {\n+        super(message);\n+    }\n+\n+    public TooManyServerRedirectsException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n+}"},{"sha":"bb2c0bb658b8bdef6f7b535df671a857a0b0df06","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.exceptions.ServerRedirectLoopException;\n+import org.apache.hedwig.client.exceptions.TooManyServerRedirectsException;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(AbstractResponseHandler.class);\n+\n+    protected final ClientConfiguration cfg;\n+    protected final HChannelManager channelManager;\n+\n+    protected AbstractResponseHandler(ClientConfiguration cfg,\n+                                      HChannelManager channelManager) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+    }\n+\n+    /**\n+     * Logic to handle received response.\n+     *\n+     * @param response\n+     *            PubSubResponse received from hub server.\n+     * @param pubSubData\n+     *            PubSubData for the pub/sub request.\n+     * @param channel\n+     *            Channel we used to make the request.\n+     */\n+    public abstract void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                                        Channel channel) throws Exception;\n+\n+    /**\n+     * Logic to repost a PubSubRequest when the server responds with a redirect\n+     * indicating they are not the topic master.\n+     *\n+     * @param response\n+     *            PubSubResponse from the server for the redirect\n+     * @param pubSubData\n+     *            PubSubData for the original PubSubRequest made\n+     * @param channel\n+     *            Channel Channel we used to make the original PubSubRequest\n+     * @throws Exception\n+     *             Throws an exception if there was an error in doing the\n+     *             redirect repost of the PubSubRequest\n+     */\n+    protected void handleRedirectResponse(PubSubResponse response, PubSubData pubSubData,\n+                                          Channel channel)\n+            throws Exception {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a redirect from host: {}, response: {}, pubSubData: {}\",\n+                         va(NetUtils.getHostFromChannel(channel), response, pubSubData));\n+        }\n+        // In this case, the PubSub request was done to a server that is not\n+        // responsible for the topic. First make sure that we haven't\n+        // exceeded the maximum number of server redirects.\n+        int curNumServerRedirects = (pubSubData.triedServers == null) ? 0 : pubSubData.triedServers.size();\n+        if (curNumServerRedirects >= cfg.getMaximumServerRedirects()) {\n+            // We've already exceeded the maximum number of server redirects\n+            // so consider this as an error condition for the client.\n+            // Invoke the operationFailed callback and just return.\n+            logger.debug(\"Exceeded the number of server redirects ({}) so error out.\",\n+                         curNumServerRedirects);\n+            PubSubException exception = new ServiceDownException(\n+                new TooManyServerRedirectsException(\"Already reached max number of redirects: \"\n+                                                    + curNumServerRedirects));\n+            pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            return;\n+        }\n+\n+        // We will redirect and try to connect to the correct server\n+        // stored in the StatusMsg of the response. First store the\n+        // server that we sent the PubSub request to for the topic.\n+        ByteString triedServer = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(\n+                                                         NetUtils.getHostFromChannel(channel)));\n+        if (pubSubData.triedServers == null) {\n+            pubSubData.triedServers = new LinkedList<ByteString>();\n+        }\n+        pubSubData.shouldClaim = true;\n+        pubSubData.triedServers.add(triedServer);\n+\n+        // Now get the redirected server host (expected format is\n+        // Hostname:Port:SSLPort) from the server's response message. If one is\n+        // not given for some reason, then redirect to the default server\n+        // host/VIP to repost the request.\n+        String statusMsg = response.getStatusMsg();\n+        InetSocketAddress redirectedHost;\n+        boolean redirectToDefaultServer;\n+        if (statusMsg != null && statusMsg.length() > 0) {\n+            if (cfg.isSSLEnabled()) {\n+                redirectedHost = new HedwigSocketAddress(statusMsg).getSSLSocketAddress();\n+            } else {\n+                redirectedHost = new HedwigSocketAddress(statusMsg).getSocketAddress();\n+            }\n+            redirectToDefaultServer = false;\n+        } else {\n+            redirectedHost = cfg.getDefaultServerHost();\n+            redirectToDefaultServer = true;\n+        }\n+\n+        // Make sure the redirected server is not one we've already attempted\n+        // already before in this PubSub request.\n+        if (pubSubData.triedServers.contains(ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(redirectedHost)))) {\n+            logger.error(\"We've already sent this PubSubRequest before to redirectedHost: {}, pubSubData: {}\",\n+                         va(redirectedHost, pubSubData));\n+            PubSubException exception = new ServiceDownException(\n+                new ServerRedirectLoopException(\"Already made the request before to redirected host: \"\n+                                                + redirectedHost));\n+            pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            return;\n+        }\n+\n+        // submit the pub/sub request to redirected host\n+        if (redirectToDefaultServer) {\n+            channelManager.submitOpToDefaultServer(pubSubData);\n+        } else {\n+            channelManager.redirectToHost(pubSubData, redirectedHost);\n+        }\n+    }\n+\n+}"},{"sha":"102dfb509a450fef90116e97982960b1f7dda258","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/CloseSubscriptionResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class CloseSubscriptionResponseHandler extends AbstractResponseHandler {\n+\n+    private static Logger logger =\n+        LoggerFactory.getLogger(CloseSubscriptionResponseHandler.class);\n+\n+    public CloseSubscriptionResponseHandler(ClientConfiguration cfg,\n+                                            HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    public void handleResponse(final PubSubResponse response, final PubSubData pubSubData,\n+                               final Channel channel)\n+            throws Exception {\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            break;\n+        case CLIENT_NOT_SUBSCRIBED:\n+            // For closesubscription requests, the server says that the client was\n+            // never subscribed to the topic.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientNotSubscribedException(\n+                                                    \"Client was never subscribed to topic: \" +\n+                                                        pubSubData.topic.toStringUtf8() + \", subscriberId: \" +\n+                                                        pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original\n+            // Unsubscribe Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a status code of: \" +\n+                                                        response.getStatusCode()));\n+            break;\n+        }\n+    }\n+\n+}"},{"sha":"436c14f85b5e65be42196f14d5160ecc4db652ee","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,117 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import java.util.TimerTask;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * This is the Callback used by the MessageHandlers on the client app when\n+ * they've finished consuming a subscription message sent from the server\n+ * asynchronously. This callback back to the client libs will be stateless so we\n+ * can use a singleton for the class. The object context used should be the\n+ * MessageConsumeData type. That will contain all of the information needed to\n+ * call the message consume logic in the client lib HChannelHandler.\n+ *\n+ */\n+public class MessageConsumeCallback implements Callback<Void> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(MessageConsumeCallback.class);\n+\n+    private final HChannelManager channelManager;\n+    private final long consumeRetryWaitTime;\n+\n+    public MessageConsumeCallback(ClientConfiguration cfg,\n+                                  HChannelManager channelManager) {\n+        this.channelManager = channelManager;\n+        this.consumeRetryWaitTime =\n+            cfg.getMessageConsumeRetryWaitTime();\n+    }\n+\n+    class MessageConsumeRetryTask extends TimerTask {\n+        private final MessageConsumeData messageConsumeData;\n+\n+        public MessageConsumeRetryTask(MessageConsumeData messageConsumeData) {\n+            this.messageConsumeData = messageConsumeData;\n+        }\n+\n+        @Override\n+        public void run() {\n+            // Try to consume the message again\n+            SubscribeResponseHandler subscribeHChannelHandler =\n+                channelManager.getSubscribeResponseHandler(messageConsumeData.topicSubscriber);\n+            if (null == subscribeHChannelHandler ||\n+                !subscribeHChannelHandler.hasSubscription(messageConsumeData.topicSubscriber)) {\n+                logger.warn(\"No subscription {} found to retry delivering message {}.\",\n+                            va(messageConsumeData.topicSubscriber,\n+                               MessageIdUtils.msgIdToReadableString(messageConsumeData.msg.getMsgId())));\n+                return;\n+            }\n+\n+            subscribeHChannelHandler.asyncMessageDeliver(messageConsumeData.topicSubscriber,\n+                                                         messageConsumeData.msg);\n+        }\n+    }\n+\n+    public void operationFinished(Object ctx, Void resultOfOperation) {\n+        MessageConsumeData messageConsumeData = (MessageConsumeData) ctx;\n+\n+        SubscribeResponseHandler subscribeHChannelHandler =\n+            channelManager.getSubscribeResponseHandler(messageConsumeData.topicSubscriber);\n+        if (null == subscribeHChannelHandler ||\n+            !subscribeHChannelHandler.hasSubscription(messageConsumeData.topicSubscriber)) {\n+            logger.warn(\"No subscription {} found to consume message {}.\",\n+                        va(messageConsumeData.topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(messageConsumeData.msg.getMsgId())));\n+            return;\n+        }\n+\n+        // Message has been successfully consumed by the client app so callback\n+        // to the HChannelHandler indicating that the message is consumed.\n+        subscribeHChannelHandler.messageConsumed(messageConsumeData.topicSubscriber,\n+                                                 messageConsumeData.msg);\n+    }\n+\n+    public void operationFailed(Object ctx, PubSubException exception) {\n+        // Message has NOT been successfully consumed by the client app so\n+        // callback to the HChannelHandler to try the async MessageHandler\n+        // Consume logic again.\n+        MessageConsumeData messageConsumeData = (MessageConsumeData) ctx;\n+        logger.error(\"Message was not consumed successfully by client MessageHandler: {}\",\n+                     messageConsumeData);\n+\n+        // Sleep a pre-configured amount of time (in milliseconds) before we\n+        // do the retry. In the future, we can have more dynamic logic on\n+        // what duration to sleep based on how many times we've retried, or\n+        // perhaps what the last amount of time we slept was. We could stick\n+        // some of this meta-data into the MessageConsumeData when we retry.\n+        channelManager.schedule(new MessageConsumeRetryTask(messageConsumeData),\n+                                consumeRetryWaitTime);\n+    }\n+\n+}"},{"sha":"dacaa7aa715e6099810d58d3831a2a9376d588b0","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PubSubCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,94 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * This class is used when we are doing synchronous type of operations. All\n+ * underlying client ops in Hedwig are async so this is just a way to make the\n+ * async calls synchronous.\n+ *\n+ */\n+public class PubSubCallback implements Callback<PubSubProtocol.ResponseBody> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(PubSubCallback.class);\n+\n+    // Private member variables\n+    private final PubSubData pubSubData;\n+    // Boolean indicator to see if the sync PubSub call was successful or not.\n+    private boolean isCallSuccessful;\n+    // For sync callbacks, we'd like to know what the PubSubException is thrown\n+    // on failure. This is so we can have a handle to the exception and rethrow\n+    // it later.\n+    private PubSubException failureException;\n+\n+    private PubSubProtocol.ResponseBody responseBody;\n+\n+    // Constructor\n+    public PubSubCallback(PubSubData pubSubData) {\n+        this.pubSubData = pubSubData;\n+    }\n+\n+    public void operationFinished(Object ctx, PubSubProtocol.ResponseBody resultOfOperation) {\n+        logger.debug(\"PubSub call succeeded for pubSubData: {}\", pubSubData);\n+        // Wake up the main sync PubSub thread that is waiting for us to\n+        // complete.\n+        synchronized (pubSubData) {\n+            this.responseBody = resultOfOperation;\n+            isCallSuccessful = true;\n+            pubSubData.isDone = true;\n+            pubSubData.notify();\n+        }\n+    }\n+\n+    public void operationFailed(Object ctx, PubSubException exception) {\n+        logger.debug(\"PubSub call failed with exception: {}, pubSubData: {}\", exception, pubSubData);\n+        // Wake up the main sync PubSub thread that is waiting for us to\n+        // complete.\n+        synchronized (pubSubData) {\n+            isCallSuccessful = false;\n+            failureException = exception;\n+            pubSubData.isDone = true;\n+            pubSubData.notify();\n+        }\n+    }\n+\n+    // Public getter to determine if the PubSub callback is successful or not\n+    // based on the PubSub ack response from the server.\n+    public boolean getIsCallSuccessful() {\n+        return isCallSuccessful;\n+    }\n+\n+    // Public getter to retrieve what the PubSubException was that occurred when\n+    // the operation failed.\n+    public PubSubException getFailureException() {\n+        return failureException;\n+    }\n+\n+\n+    public PubSubProtocol.ResponseBody getResponseBody() {\n+        return responseBody;\n+    }\n+}"},{"sha":"fc6a0251074488ef169090531dd8c7336e12681d","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,71 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+\n+public class PublishResponseHandler extends AbstractResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(PublishResponseHandler.class);\n+\n+    public PublishResponseHandler(ClientConfiguration cfg,\n+                                  HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            // Response was success so invoke the callback's operationFinished\n+            // method.\n+            pubSubData.operationFinishedToCallback(pubSubData.context,\n+                response.hasResponseBody() ? response.getResponseBody() : null);\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original Publish\n+            // Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a status code of: \" +\n+                                                        response.getStatusCode()));\n+            break;\n+        }\n+    }\n+}"},{"sha":"e2c685f91d687e8b709653af50b6fe3dcefa0231","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"added","additions":183,"deletions":0,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * An interface provided to manage all subscriptions on a channel.\n+ *\n+ * Its responsibility is to handle all subscribe responses received on that channel,\n+ * clear up subscriptions and retry reconnectin subscriptions when channel disconnected,\n+ * and handle delivering messages to {@link MessageHandler} and sent consume messages\n+ * back to hub servers.\n+ */\n+public abstract class SubscribeResponseHandler extends AbstractResponseHandler {\n+\n+    protected SubscribeResponseHandler(ClientConfiguration cfg,\n+                                       HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    /**\n+     * Handle Message delivered by the server.\n+     *\n+     * @param response\n+     *          Message received from the server.\n+     */\n+    public abstract void handleSubscribeMessage(PubSubResponse response);\n+\n+    /**\n+     * Handle a subscription event delivered by the server.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param event\n+     *          Subscription Event describes its status\n+     */\n+    public abstract void handleSubscriptionEvent(ByteString topic,\n+                                                 ByteString subscriberId,\n+                                                 SubscriptionEvent event);\n+\n+    /**\n+     * Method called when a message arrives for a subscribe Channel and we want\n+     * to deliver it asynchronously via the registered MessageHandler (should\n+     * not be null when called here).\n+     *\n+     * @param message\n+     *            Message from Subscribe Channel we want to consume.\n+     */\n+    protected abstract void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                                Message message);\n+\n+    /**\n+     * Method called when the client app's MessageHandler has asynchronously\n+     * completed consuming a subscribed message sent from the server. The\n+     * contract with the client app is that messages sent to the handler to be\n+     * consumed will have the callback response done in the same order. So if we\n+     * asynchronously call the MessageHandler to consume messages #1-5, that\n+     * should call the messageConsumed method here via the VoidCallback in the\n+     * same order. To make this thread safe, since multiple outstanding messages\n+     * could be consumed by the client app and then called back to here, make\n+     * this method synchronized.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param message\n+     *            Message sent from server for topic subscription that has been\n+     *            consumed by the client.\n+     */\n+    protected abstract void messageConsumed(TopicSubscriber topicSubscriber,\n+                                            Message message);\n+\n+    /**\n+     * Start delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param messageHandler\n+     *            MessageHandler to register for this ResponseHandler instance.\n+     * @throws ClientNotSubscribedException\n+     *            If the client is not currently subscribed to the topic\n+     * @throws AlreadyStartDeliveryException\n+     *            If someone started delivery a message handler before stopping existed one.\n+     */\n+    public abstract void startDelivery(TopicSubscriber topicSubscriber,\n+                                       MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n+\n+    /**\n+     * Stop delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @throws ClientNotSubscribedException\n+     *             If the client is not currently subscribed to the topic\n+     */\n+    public abstract void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException;\n+\n+    /**\n+     * Whether the given topic subscriber subscribed thru this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @return whether the given topic subscriber subscribed thru this handler.\n+     */\n+    public abstract boolean hasSubscription(TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Close subscription from this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param callback\n+     *            Callback when the subscription is closed. \n+     * @param context\n+     *            Callback context.\n+     */\n+    public abstract void asyncCloseSubscription(TopicSubscriber topicSubscriber,\n+                                                Callback<ResponseBody> callback,\n+                                                Object context);\n+\n+    /**\n+     * Consume a given message for given topic subscriber thru this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     */\n+    public abstract void consume(TopicSubscriber topicSubscriber,\n+                                 MessageSeqId messageSeqId);\n+\n+    /**\n+     * This method is called when the underlying channel is disconnected due to server failure.\n+     *\n+     * The implementation should take the responsibility to clear subscriptions and retry\n+     * reconnecting subscriptions to new hub servers.\n+     *\n+     * @param host\n+     *          Host that channel connected to has disconnected.\n+     * @param channel\n+     *          Channel connected to.\n+     */\n+    public abstract void onChannelDisconnected(InetSocketAddress host,\n+                                               Channel channel);\n+}"},{"sha":"3ddd5390553150162e9482d6e2125998cb12fde2","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class UnsubscribeResponseHandler extends AbstractResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(UnsubscribeResponseHandler.class);\n+\n+    public UnsubscribeResponseHandler(ClientConfiguration cfg,\n+                                      HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    public void handleResponse(final PubSubResponse response, final PubSubData pubSubData,\n+                               final Channel channel)\n+            throws Exception {\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            // since for unsubscribe request, we close subscription first\n+            // for now, we don't need to do anything now.\n+            pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            break;\n+        case CLIENT_NOT_SUBSCRIBED:\n+            // For Unsubscribe requests, the server says that the client was\n+            // never subscribed to the topic.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientNotSubscribedException(\n+                                                    \"Client was never subscribed to topic: \" +\n+                                                        pubSubData.topic.toStringUtf8() + \", subscriberId: \" +\n+                                                        pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original\n+            // Unsubscribe Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                    \"Server responded with a status code of: \" +\n+                                                        response.getStatusCode()));\n+            break;\n+        }\n+    }\n+\n+}"},{"sha":"0c676a13c909580f1aa85105fa54d1eb6469e273","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","status":"added","additions":183,"deletions":0,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CleanupChannelMap<T> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(CleanupChannelMap.class);\n+    \n+    private final ConcurrentHashMap<T, HChannel> channels;\n+\n+    // Boolean indicating if the channel map is closed or not.\n+    protected boolean closed = false;\n+    protected final ReentrantReadWriteLock closedLock =\n+        new ReentrantReadWriteLock();\n+\n+    public CleanupChannelMap() {\n+        channels = new ConcurrentHashMap<T, HChannel>();\n+    }\n+\n+    /**\n+     * Add channel to the map. If an old channel has been bound\n+     * to <code>key</code>, the <code>channel</code> would be\n+     * closed immediately and the old channel is returned. Otherwise,\n+     * the <code>channel</code> is put in the map for future usage.\n+     *\n+     * If the channel map has been closed, the channel would be closed\n+     * immediately.\n+     *\n+     * @param key\n+     *            Key\n+     * @param channel\n+     *            Channel\n+     * @return the channel instance to use.\n+     */\n+    public HChannel addChannel(T key, HChannel channel) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                channel.close();\n+                return channel;\n+            }\n+            HChannel oldChannel = channels.putIfAbsent(key, channel);\n+            if (null != oldChannel) {\n+                logger.info(\"Channel for {} already exists, so no need to store it.\", key);\n+                channel.close();\n+                return oldChannel;\n+            } else {\n+                logger.debug(\"Storing a new channel for {}.\", key);\n+                return channel;\n+            }\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Replace channel only if currently mapped to the given <code>oldChannel</code>.\n+     *\n+     * @param key\n+     *            Key\n+     * @param oldChannel\n+     *            Old Channel\n+     * @param newChannel\n+     *            New Channel\n+     * @return true if replaced successfully, otherwise false.\n+     */\n+    public boolean replaceChannel(T key, HChannel oldChannel, HChannel newChannel) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                if (null != oldChannel) oldChannel.close();\n+                if (null != newChannel) newChannel.close();\n+                return false;\n+            }\n+            if (null == oldChannel) {\n+                HChannel existedChannel = channels.putIfAbsent(key, newChannel);\n+                if (null != existedChannel) {\n+                    logger.info(\"Channel for {} already exists, so no need to replace it.\", key);\n+                    newChannel.close();\n+                    return false;\n+                } else {\n+                    logger.debug(\"Storing a new channel for {}.\", key);\n+                    return true;\n+                }\n+            } else {\n+                if (channels.replace(key, oldChannel, newChannel)) {\n+                    logger.debug(\"Replacd channel {} for {}.\", oldChannel, key);\n+                    oldChannel.close();\n+                    return true;\n+                } else {\n+                    newChannel.close();\n+                    return false;\n+                }\n+            }\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @return the channel bound with <code>key</code>.\n+     */\n+    public HChannel getChannel(T key) {\n+        return channels.get(key);\n+    }\n+\n+    /**\n+     * Remove the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @return the channel bound with <code>key</code>, null if no channel\n+     *         is bound with <code>key</code>.\n+     */\n+    public HChannel removeChannel(T key) {\n+        return channels.remove(key);\n+    }\n+\n+    /**\n+     * Remove the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @param channel The channel expected to be bound with <code>key</code>.\n+     * @return true if the channel is removed, false otherwise.\n+     */\n+    public boolean removeChannel(T key, HChannel channel) {\n+        return channels.remove(key, channel);\n+    }\n+\n+    /**\n+     * Return the channels in the map.\n+     *\n+     * @return the set of channels.\n+     */\n+    public Collection<HChannel> getChannels() {\n+        return channels.values();\n+    }\n+\n+    /**\n+     * Close the channels map.\n+     */\n+    public void close() {\n+        closedLock.writeLock().lock();\n+        try {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        } finally {\n+            closedLock.writeLock().unlock();\n+        }\n+        logger.debug(\"Closing channels map.\");\n+        for (HChannel channel : channels.values()) {\n+            channel.close(true);\n+        }\n+        channels.clear();\n+        logger.debug(\"Closed channels map.\");\n+    }\n+}"},{"sha":"94e0a808e7858020c4d0f3692126b7590bc169bb","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,70 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Handlers used by a subscription.\n+ */\n+public class FilterableMessageHandler implements MessageHandler {\n+\n+    MessageHandler msgHandler;\n+    ClientMessageFilter  msgFilter;\n+\n+    public FilterableMessageHandler(MessageHandler msgHandler,\n+                                    ClientMessageFilter msgFilter) {\n+        this.msgHandler = msgHandler;\n+        this.msgFilter = msgFilter;\n+    }\n+\n+    public boolean hasMessageHandler() {\n+        return null != msgHandler;\n+    }\n+\n+    public MessageHandler getMessageHandler() {\n+        return msgHandler;\n+    }\n+\n+    public boolean hasMessageFilter() {\n+        return null != msgFilter;\n+    }\n+\n+    public ClientMessageFilter getMessageFilter() {\n+        return msgFilter;\n+    }\n+\n+    @Override\n+    public void deliver(ByteString topic, ByteString subscriberId, Message msg,\n+                        Callback<Void> callback, Object context) {\n+        boolean deliver = true;\n+        if (hasMessageFilter()) {\n+            deliver = msgFilter.testMessage(msg);\n+        }\n+        if (deliver) {\n+            msgHandler.deliver(topic, subscriberId, msg, callback, context);\n+        } else {\n+            callback.operationFinished(context, null);\n+        }\n+    }\n+}"},{"sha":"340cec57553513c96524c12f7f2826648107581e","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import org.jboss.netty.channel.Channel;\n+import org.apache.hedwig.client.data.PubSubData;\n+\n+/**\n+ * A wrapper interface over netty {@link Channel} to submit hedwig's\n+ * {@link PubSubData} requests.\n+ */\n+public interface HChannel {\n+\n+    /**\n+     * Submit a pub/sub request.\n+     *\n+     * @param op\n+     *          Pub/Sub Request.\n+     */\n+    public void submitOp(PubSubData op);\n+\n+    /**\n+     * @return underlying netty channel\n+     */\n+    public Channel getChannel();\n+\n+    /**\n+     * Close the channel without waiting.\n+     */\n+    public void close();\n+\n+    /**\n+     * Close the channel\n+     *\n+     * @param wait\n+     *          Whether wait until the channel is closed.\n+     */\n+    public void close(boolean wait);\n+}"},{"sha":"6fae6bb2588d6d6b666df72793c3628c16fba38e","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.net.InetSocketAddress;\n+import java.util.TimerTask;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * A manager manages 1) all channels established to hub servers,\n+ * 2) the actions taken by the topic subscribers.\n+ */\n+public interface HChannelManager {\n+\n+    /**\n+     * Submit a pub/sub request after a given <code>delay</code>.\n+     *\n+     * @param op\n+     *          Pub/Sub Request.\n+     * @param delay\n+     *          Delay time in ms.\n+     */\n+    public void submitOpAfterDelay(PubSubData op, long delay);\n+\n+    /**\n+     * Submit a pub/sub request.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Request.\n+     */\n+    public void submitOp(PubSubData pubSubData);\n+\n+    /**\n+     * Submit a pub/sub request to default server.\n+     *\n+     * @param pubSubData\n+     *           Pub/Sub request.\n+     */\n+    public void submitOpToDefaultServer(PubSubData pubSubData);\n+\n+    /**\n+     * Submit a pub/sub request to a given host.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub request.\n+     * @param host\n+     *          Given host address.\n+     */\n+    public void redirectToHost(PubSubData pubSubData, InetSocketAddress host);\n+\n+    /**\n+     * Generate next transaction id for pub/sub request sending thru this manager.\n+     *\n+     * @return next transaction id.\n+     */\n+    public long nextTxnId();\n+\n+    /**\n+     * Schedule a timer task after a given <code>delay</code>.\n+     *\n+     * @param task\n+     *          A timer task\n+     * @param delay\n+     *          Delay time in ms.\n+     */\n+    public void schedule(TimerTask task, long delay);\n+\n+    /**\n+     * Get the subscribe response handler managed the given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @return subscribe response handler managed it, otherwise return null.\n+     */\n+    public SubscribeResponseHandler getSubscribeResponseHandler(\n+                                    TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Start delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param messageHandler\n+     *            MessageHandler to register for this ResponseHandler instance.\n+     * @throws ClientNotSubscribedException\n+     *            If the client is not currently subscribed to the topic\n+     * @throws AlreadyStartDeliveryException\n+     *            If someone started delivery a message handler before stopping existed one.\n+     */\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n+\n+    /**\n+     * Stop delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @throws ClientNotSubscribedException\n+     *             If the client is not currently subscribed to the topic\n+     */\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException;\n+\n+    /**\n+     * Close the subscription of the given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @param callback\n+     *          Callback\n+     * @param context\n+     *          Callback context\n+     */\n+    public void asyncCloseSubscription(TopicSubscriber topicSubscriber,\n+                                       Callback<ResponseBody> callback,\n+                                       Object context);\n+\n+    /**\n+     * Return the subscription event emitter to emit subscription events.\n+     *\n+     * @return subscription event emitter.\n+     */\n+    public SubscriptionEventEmitter getSubscriptionEventEmitter();\n+\n+    /**\n+     * Is the channel manager closed.\n+     *\n+     * @return true if the channel manager is closed, otherwise return false.\n+     */\n+    public boolean isClosed();\n+\n+    /**\n+     * Close the channel manager.\n+     */\n+    public void close();\n+}"},{"sha":"8ae0e8207e171f4d8b79ca9e605f573709884ca0","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"added","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,128 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.concurrent.Executors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hedwig.client.api.Client;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.netty.impl.simple.SimpleHChannelManager;\n+import org.apache.hedwig.client.netty.impl.multiplex.MultiplexHChannelManager;\n+\n+/**\n+ * This is a top level Hedwig Client class that encapsulates the common\n+ * functionality needed for both Publish and Subscribe operations.\n+ *\n+ */\n+public class HedwigClientImpl implements Client {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(HedwigClientImpl.class);\n+\n+    // The Netty socket factory for making connections to the server.\n+    protected final ChannelFactory socketFactory;\n+    // Whether the socket factory is one we created or is owned by whoever\n+    // instantiated us.\n+    protected boolean ownChannelFactory = false;\n+\n+    // channel manager manages all the channels established by the client\n+    protected final HChannelManager channelManager;\n+\n+    private HedwigSubscriber sub;\n+    private final HedwigPublisher pub;\n+    private final ClientConfiguration cfg;\n+\n+    public static Client create(ClientConfiguration cfg) {\n+        return new HedwigClientImpl(cfg);\n+    }\n+\n+    public static Client create(ClientConfiguration cfg, ChannelFactory socketFactory) {\n+        return new HedwigClientImpl(cfg, socketFactory);\n+    }\n+\n+    // Base constructor that takes in a Configuration object.\n+    // This will create its own client socket channel factory.\n+    protected HedwigClientImpl(ClientConfiguration cfg) {\n+        this(cfg, new NioClientSocketChannelFactory(\n+                Executors.newCachedThreadPool(new ThreadFactoryBuilder()\n+                        .setNameFormat(\"HedwigClient-NIOBoss-%d\").build()),\n+                Executors.newCachedThreadPool(new ThreadFactoryBuilder()\n+                        .setNameFormat(\"HedwigClient-NIOWorker-%d\").build())));\n+        ownChannelFactory = true;\n+    }\n+\n+    // Constructor that takes in a Configuration object and a ChannelFactory\n+    // that has already been instantiated by the caller.\n+    protected HedwigClientImpl(ClientConfiguration cfg, ChannelFactory socketFactory) {\n+        this.cfg = cfg;\n+        this.socketFactory = socketFactory;\n+        if (cfg.isSubscriptionChannelSharingEnabled()) {\n+            channelManager = new MultiplexHChannelManager(cfg, socketFactory);\n+        } else {\n+            channelManager = new SimpleHChannelManager(cfg, socketFactory);\n+        }\n+        pub = new HedwigPublisher(this);\n+        sub = new HedwigSubscriber(this);\n+    }\n+\n+    public ClientConfiguration getConfiguration() {\n+        return cfg;\n+    }\n+\n+    public HChannelManager getHChannelManager() {\n+        return channelManager;\n+    }\n+\n+    public HedwigSubscriber getSubscriber() {\n+        return sub;\n+    }\n+\n+    // Protected method to set the subscriber. This is needed currently for hub\n+    // versions of the client subscriber.\n+    protected void setSubscriber(HedwigSubscriber sub) {\n+        this.sub = sub;\n+    }\n+\n+    public HedwigPublisher getPublisher() {\n+        return pub;\n+    }\n+\n+    // When we are done with the client, this is a clean way to gracefully close\n+    // all channels/sockets created by the client and to also release all\n+    // resources used by netty.\n+    public void close() {\n+        logger.info(\"Stopping the client!\");\n+\n+        // close channel manager to release all channels\n+        channelManager.close(); \n+\n+        // Release resources used by the ChannelFactory on the client if we are\n+        // the owner that created it.\n+        if (ownChannelFactory) {\n+            socketFactory.releaseExternalResources();\n+        }\n+        logger.info(\"Completed stopping the client!\");\n+    }\n+\n+}"},{"sha":"5611bdd0c6e5f6871ec1fd6c751f6b16761aa2e6","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.handlers.PubSubCallback;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PublishResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * This is the Hedwig Netty specific implementation of the Publisher interface.\n+ *\n+ */\n+public class HedwigPublisher implements Publisher {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HedwigPublisher.class);\n+\n+    private final HChannelManager channelManager;\n+\n+    protected HedwigPublisher(HedwigClientImpl client) {\n+        this.channelManager = client.getHChannelManager();\n+    }\n+\n+    public PublishResponse publish(ByteString topic, Message msg)\n+        throws CouldNotConnectException, ServiceDownException {\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Calling a sync publish for topic: {}, msg: {}.\",\n+                         topic.toStringUtf8(), msg);\n+        }\n+        PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null, null, null);\n+        synchronized (pubSubData) {\n+            PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n+            asyncPublishWithResponseImpl(topic, msg, pubSubCallback, null);\n+            try {\n+                while (!pubSubData.isDone)\n+                    pubSubData.wait();\n+            } catch (InterruptedException e) {\n+                throw new ServiceDownException(\"Interrupted Exception while waiting for async publish call\");\n+            }\n+            // Check from the PubSubCallback if it was successful or not.\n+            if (!pubSubCallback.getIsCallSuccessful()) {\n+                // See what the exception was that was thrown when the operation\n+                // failed.\n+                PubSubException failureException = pubSubCallback.getFailureException();\n+                if (failureException == null) {\n+                    // This should not happen as the operation failed but a null\n+                    // PubSubException was passed. Log a warning message but\n+                    // throw a generic ServiceDownException.\n+                    logger.error(\"Sync Publish operation failed but no PubSubException was passed!\");\n+                    throw new ServiceDownException(\"Server ack response to publish request is not successful\");\n+                }\n+                // For the expected exceptions that could occur, just rethrow\n+                // them.\n+                else if (failureException instanceof CouldNotConnectException) {\n+                    throw (CouldNotConnectException) failureException;\n+                } else if (failureException instanceof ServiceDownException) {\n+                    throw (ServiceDownException) failureException;\n+                } else {\n+                    // For other types of PubSubExceptions, just throw a generic\n+                    // ServiceDownException but log a warning message.\n+                    logger.error(\"Unexpected exception type when a sync publish operation failed: \",\n+                                 failureException);\n+                    throw new ServiceDownException(\"Server ack response to publish request is not successful\");\n+                }\n+            }\n+\n+            ResponseBody respBody = pubSubCallback.getResponseBody();\n+            if (null == respBody) {\n+                return null;\n+            }\n+            return respBody.hasPublishResponse() ? respBody.getPublishResponse() : null;\n+        }\n+    }\n+\n+    public void asyncPublish(ByteString topic, Message msg,\n+                             final Callback<Void> callback, Object context) {\n+        asyncPublishWithResponseImpl(topic, msg,\n+                                     new VoidCallbackAdapter<ResponseBody>(callback), context);\n+    }\n+\n+    public void asyncPublishWithResponse(ByteString topic, Message msg,\n+                                         Callback<PublishResponse> callback,\n+                                         Object context) {\n+        // adapt the callback.\n+        asyncPublishWithResponseImpl(topic, msg,\n+                                     new PublishResponseCallbackAdapter(callback), context);\n+    }\n+\n+    private void asyncPublishWithResponseImpl(ByteString topic, Message msg,\n+                                              Callback<ResponseBody> callback,\n+                                              Object context) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Calling an async publish for topic: {}, msg: {}.\",\n+                         topic.toStringUtf8(), msg);\n+        }\n+        PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null,\n+                                               callback, context);\n+        channelManager.submitOp(pubSubData);\n+    }\n+\n+    private static class PublishResponseCallbackAdapter implements Callback<ResponseBody>{\n+\n+        private final Callback<PublishResponse> delegate;\n+\n+        private PublishResponseCallbackAdapter(Callback<PublishResponse> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n+            if (null == resultOfOperation) {\n+                delegate.operationFinished(ctx, null);\n+            } else {\n+                delegate.operationFinished(ctx, resultOfOperation.getPublishResponse());\n+            }\n+        }\n+\n+        @Override\n+        public void operationFailed(Object ctx, PubSubException exception) {\n+            delegate.operationFailed(ctx, exception);\n+        }\n+    }\n+}"},{"sha":"7d2453aa29d477dd823ec0bbeb5a183e3efce531","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"added","additions":422,"deletions":0,"changes":422,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.InvalidSubscriberIdException;\n+import org.apache.hedwig.client.handlers.PubSubCallback;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.SubscriptionListener;\n+\n+/**\n+ * This is the Hedwig Netty specific implementation of the Subscriber interface.\n+ *\n+ */\n+@SuppressWarnings(\"deprecation\") // so that we can implemented the Deprecated subscribe methods without a warning\n+public class HedwigSubscriber implements Subscriber {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HedwigSubscriber.class);\n+\n+    protected final ClientConfiguration cfg;\n+    protected final HChannelManager channelManager;\n+\n+    public HedwigSubscriber(HedwigClientImpl client) {\n+        this.cfg = client.getConfiguration();\n+        this.channelManager = client.getHChannelManager();\n+    }\n+\n+    public void addSubscriptionListener(SubscriptionListener listener) {\n+        channelManager.getSubscriptionEventEmitter()\n+                      .addSubscriptionListener(listener);\n+    }\n+\n+    public void removeSubscriptionListener(SubscriptionListener listener) {\n+        channelManager.getSubscriptionEventEmitter()\n+                      .removeSubscriptionListener(listener);\n+    }\n+\n+    // Private method that holds the common logic for doing synchronous\n+    // Subscribe or Unsubscribe requests. This is for code reuse since these\n+    // two flows are very similar. The assumption is that the input\n+    // OperationType is either SUBSCRIBE or UNSUBSCRIBE.\n+    private void subUnsub(ByteString topic, ByteString subscriberId, OperationType operationType,\n+                          SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException,\n+        ClientNotSubscribedException, ServiceDownException {\n+        if (logger.isDebugEnabled()) {\n+            StringBuilder debugMsg = new StringBuilder().append(\"Calling a sync subUnsub request for topic: \")\n+                                     .append(topic.toStringUtf8()).append(\", subscriberId: \")\n+                                     .append(subscriberId.toStringUtf8()).append(\", operationType: \")\n+                                     .append(operationType);\n+            if (null != options) {\n+                debugMsg.append(\", createOrAttach: \").append(options.getCreateOrAttach())\n+                        .append(\", messageBound: \").append(options.getMessageBound());\n+            }\n+            logger.debug(debugMsg.toString());\n+        }\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, options, null, null);\n+        synchronized (pubSubData) {\n+            PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n+            asyncSubUnsub(topic, subscriberId, pubSubCallback, null, operationType, options);\n+            try {\n+                while (!pubSubData.isDone)\n+                    pubSubData.wait();\n+            } catch (InterruptedException e) {\n+                throw new ServiceDownException(\"Interrupted Exception while waiting for async subUnsub call\");\n+            }\n+            // Check from the PubSubCallback if it was successful or not.\n+            if (!pubSubCallback.getIsCallSuccessful()) {\n+                // See what the exception was that was thrown when the operation\n+                // failed.\n+                PubSubException failureException = pubSubCallback.getFailureException();\n+                if (failureException == null) {\n+                    // This should not happen as the operation failed but a null\n+                    // PubSubException was passed. Log a warning message but\n+                    // throw a generic ServiceDownException.\n+                    logger.error(\"Sync SubUnsub operation failed but no PubSubException was passed!\");\n+                    throw new ServiceDownException(\"Server ack response to SubUnsub request is not successful\");\n+                }\n+                // For the expected exceptions that could occur, just rethrow\n+                // them.\n+                else if (failureException instanceof CouldNotConnectException)\n+                    throw (CouldNotConnectException) failureException;\n+                else if (failureException instanceof ClientAlreadySubscribedException)\n+                    throw (ClientAlreadySubscribedException) failureException;\n+                else if (failureException instanceof ClientNotSubscribedException)\n+                    throw (ClientNotSubscribedException) failureException;\n+                else if (failureException instanceof ServiceDownException)\n+                    throw (ServiceDownException) failureException;\n+                else {\n+                    logger.error(\"Unexpected PubSubException thrown: \", failureException);\n+                    // Throw a generic ServiceDownException but wrap the\n+                    // original PubSubException within it.\n+                    throw new ServiceDownException(failureException);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Private method that holds the common logic for doing asynchronous\n+    // Subscribe or Unsubscribe requests. This is for code reuse since these two\n+    // flows are very similar. The assumption is that the input OperationType is\n+    // either SUBSCRIBE or UNSUBSCRIBE.\n+    private void asyncSubUnsub(ByteString topic, ByteString subscriberId,\n+                               Callback<ResponseBody> callback, Object context,\n+                               OperationType operationType, SubscriptionOptions options) {\n+        if (logger.isDebugEnabled()) {\n+            StringBuilder debugMsg = new StringBuilder().append(\"Calling a async subUnsub request for topic: \")\n+                                     .append(topic.toStringUtf8()).append(\", subscriberId: \")\n+                                     .append(subscriberId.toStringUtf8()).append(\", operationType: \")\n+                                     .append(operationType);\n+            if (null != options) {\n+                debugMsg.append(\", createOrAttach: \").append(options.getCreateOrAttach())\n+                        .append(\", messageBound: \").append(options.getMessageBound());\n+            }\n+            logger.debug(debugMsg.toString());\n+        }\n+        if (OperationType.SUBSCRIBE.equals(operationType)) {\n+            if (options.getMessageBound() <= 0 &&\n+                cfg.getSubscriptionMessageBound() > 0) {\n+                SubscriptionOptions.Builder soBuilder =\n+                    SubscriptionOptions.newBuilder(options).setMessageBound(\n+                        cfg.getSubscriptionMessageBound());\n+                options = soBuilder.build();\n+            }\n+        }\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType,\n+                                               options, callback, context);\n+        channelManager.submitOp(pubSubData);\n+    }\n+\n+    public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+        InvalidSubscriberIdException {\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        subscribe(topic, subscriberId, options, false);\n+    }\n+\n+    public void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+         InvalidSubscriberIdException {\n+        subscribe(topic, subscriberId, options, false);\n+    }\n+\n+    protected void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options, boolean isHub)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+        InvalidSubscriberIdException {\n+        // Validate that the format of the subscriberId is valid either as a\n+        // local or hub subscriber.\n+        if (!isValidSubscriberId(subscriberId, isHub)) {\n+            throw new InvalidSubscriberIdException(\"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8()\n+                                                   + \", isHub: \" + isHub);\n+        }\n+        try {\n+            subUnsub(topic, subscriberId, OperationType.SUBSCRIBE, options);\n+        } catch (ClientNotSubscribedException e) {\n+            logger.error(\"Unexpected Exception thrown: \", e);\n+            // This exception should never be thrown here. But just in case,\n+            // throw a generic ServiceDownException but wrap the original\n+            // Exception within it.\n+            throw new ServiceDownException(e);\n+        }\n+    }\n+\n+    public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n+                               Object context) {\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        asyncSubscribe(topic, subscriberId, options, callback, context, false);\n+    }\n+\n+    public void asyncSubscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options,\n+                               Callback<Void> callback, Object context) {\n+        asyncSubscribe(topic, subscriberId, options, callback, context, false);\n+    }\n+\n+    protected void asyncSubscribe(ByteString topic, ByteString subscriberId,\n+                                  SubscriptionOptions options,\n+                                  Callback<Void> callback, Object context, boolean isHub) {\n+        // Validate that the format of the subscriberId is valid either as a\n+        // local or hub subscriber.\n+        if (!isValidSubscriberId(subscriberId, isHub)) {\n+            callback.operationFailed(context, new ServiceDownException(new InvalidSubscriberIdException(\n+                                         \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n+            return;\n+        }\n+        asyncSubUnsub(topic, subscriberId,\n+                      new VoidCallbackAdapter<ResponseBody>(callback), context,\n+                      OperationType.SUBSCRIBE, options);\n+    }\n+\n+    public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n+        ClientNotSubscribedException, ServiceDownException, InvalidSubscriberIdException {\n+        unsubscribe(topic, subscriberId, false);\n+    }\n+\n+    protected void unsubscribe(ByteString topic, ByteString subscriberId, boolean isHub)\n+            throws CouldNotConnectException, ClientNotSubscribedException, ServiceDownException,\n+        InvalidSubscriberIdException {\n+        // Validate that the format of the subscriberId is valid either as a\n+        // local or hub subscriber.\n+        if (!isValidSubscriberId(subscriberId, isHub)) {\n+            throw new InvalidSubscriberIdException(\"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8()\n+                                                   + \", isHub: \" + isHub);\n+        }\n+        // Synchronously close the subscription on the client side. Even\n+        // if the unsubscribe request to the server errors out, we won't be\n+        // delivering messages for this subscription to the client. The client\n+        // can later retry the unsubscribe request to the server so they are\n+        // \"fully\" unsubscribed from the given topic.\n+        closeSubscription(topic, subscriberId);\n+        try {\n+            subUnsub(topic, subscriberId, OperationType.UNSUBSCRIBE, null);\n+        } catch (ClientAlreadySubscribedException e) {\n+            logger.error(\"Unexpected Exception thrown: \", e);\n+            // This exception should never be thrown here. But just in case,\n+            // throw a generic ServiceDownException but wrap the original\n+            // Exception within it.\n+            throw new ServiceDownException(e);\n+        }\n+    }\n+\n+    public void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n+                                 final Callback<Void> callback, final Object context) {\n+        doAsyncUnsubscribe(topic, subscriberId,\n+                           new VoidCallbackAdapter<ResponseBody>(callback),\n+                           context, false);\n+    }\n+\n+    protected void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n+                                    final Callback<Void> callback, final Object context, boolean isHub) {\n+        doAsyncUnsubscribe(topic, subscriberId,\n+                           new VoidCallbackAdapter<ResponseBody>(callback),\n+                           context, isHub);\n+    }\n+\n+    private void doAsyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n+                                    final Callback<ResponseBody> callback,\n+                                    final Object context, boolean isHub) {\n+        // Validate that the format of the subscriberId is valid either as a\n+        // local or hub subscriber.\n+        if (!isValidSubscriberId(subscriberId, isHub)) {\n+            callback.operationFailed(context, new ServiceDownException(new InvalidSubscriberIdException(\n+                                         \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n+            return;\n+        }\n+        // Asynchronously close the subscription. On the callback to that\n+        // operation once it completes, post the async unsubscribe request.\n+        doAsyncCloseSubscription(topic, subscriberId, new Callback<ResponseBody>() {\n+            @Override\n+            public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n+                asyncSubUnsub(topic, subscriberId, callback, context, OperationType.UNSUBSCRIBE, null);\n+            }\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                callback.operationFailed(context, exception);\n+            }\n+        }, null);\n+    }\n+\n+    // This is a helper method to determine if a subscriberId is valid as either\n+    // a hub or local subscriber\n+    private boolean isValidSubscriberId(ByteString subscriberId, boolean isHub) {\n+        if ((isHub && !SubscriptionStateUtils.isHubSubscriber(subscriberId))\n+                || (!isHub && SubscriptionStateUtils.isHubSubscriber(subscriberId)))\n+            return false;\n+        else\n+            return true;\n+    }\n+\n+    public void consume(ByteString topic, ByteString subscriberId, MessageSeqId messageSeqId)\n+            throws ClientNotSubscribedException {\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Calling consume for {}, messageSeqId: {}.\",\n+                     topicSubscriber, messageSeqId);\n+\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            channelManager.getSubscribeResponseHandler(topicSubscriber);\n+        // Check that this topic subscription on the client side exists.\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            throw new ClientNotSubscribedException(\n+                \"Cannot send consume message since client is not subscribed to topic: \"\n+                + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+        }\n+        // Send the consume message to the server using the same subscribe\n+        // channel that the topic subscription uses.\n+        subscribeResponseHandler.consume(topicSubscriber, messageSeqId);\n+    }\n+\n+    public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n+        ServiceDownException {\n+        // The subscription type of info should be stored on the server end, not\n+        // the client side. Eventually, the server will have the Subscription\n+        // Manager part that ties into Zookeeper to manage this info.\n+        // Commenting out these type of API's related to that here for now until\n+        // this data is available on the server. Will figure out what the\n+        // correct way to contact the server to get this info is then.\n+        // The client side just has soft memory state for client subscription\n+        // information.\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            channelManager.getSubscribeResponseHandler(topicSubscriber);\n+        return !(null == subscribeResponseHandler ||\n+                 !subscribeResponseHandler.hasSubscription(topicSubscriber));\n+    }\n+\n+    public List<ByteString> getSubscriptionList(ByteString subscriberId) throws CouldNotConnectException,\n+        ServiceDownException {\n+        // Same as the previous hasSubscription method, this data should reside\n+        // on the server end, not the client side.\n+        return null;\n+    }\n+\n+    public void startDelivery(final ByteString topic, final ByteString subscriberId,\n+                              MessageHandler messageHandler)\n+            throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Starting delivery for {}.\", topicSubscriber);\n+        channelManager.startDelivery(topicSubscriber, messageHandler); \n+    }\n+\n+    public void startDeliveryWithFilter(final ByteString topic, final ByteString subscriberId,\n+                                        MessageHandler messageHandler,\n+                                        ClientMessageFilter messageFilter)\n+            throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        if (null == messageHandler || null == messageFilter) {\n+            throw new NullPointerException(\"Null message handler or message filter is       provided.\");\n+        }\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        messageHandler = new FilterableMessageHandler(messageHandler, messageFilter);\n+        logger.debug(\"Starting delivery with filter for {}.\", topicSubscriber);\n+        channelManager.startDelivery(topicSubscriber, messageHandler);\n+    }\n+\n+    public void stopDelivery(final ByteString topic, final ByteString subscriberId)\n+    throws ClientNotSubscribedException {\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Stopping delivery for {}.\", topicSubscriber);\n+        channelManager.stopDelivery(topicSubscriber); \n+    }\n+\n+    public void closeSubscription(ByteString topic, ByteString subscriberId) throws ServiceDownException {\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, null, null, null, null);\n+        synchronized (pubSubData) {\n+            PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n+            doAsyncCloseSubscription(topic, subscriberId, pubSubCallback, null);\n+            try {\n+                while (!pubSubData.isDone)\n+                    pubSubData.wait();\n+            } catch (InterruptedException e) {\n+                throw new ServiceDownException(\"Interrupted Exception while waiting for asyncCloseSubscription call\");\n+            }\n+            // Check from the PubSubCallback if it was successful or not.\n+            if (!pubSubCallback.getIsCallSuccessful()) {\n+                throw new ServiceDownException(\"Exception while trying to close the subscription for topic: \"\n+                                               + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n+            }\n+        }\n+    }\n+\n+    public void asyncCloseSubscription(final ByteString topic, final ByteString subscriberId,\n+                                       final Callback<Void> callback, final Object context) {\n+        doAsyncCloseSubscription(topic, subscriberId,\n+                                 new VoidCallbackAdapter<ResponseBody>(callback), context);\n+    }\n+\n+    private void doAsyncCloseSubscription(final ByteString topic, final ByteString subscriberId,\n+                                          final Callback<ResponseBody> callback, final Object context) {\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Stopping delivery for {} before closing subscription.\", topicSubscriber);\n+        // We only stop delivery here not in channel manager\n+        // Because channelManager#asyncCloseSubscription will called\n+        // when subscription channel disconnected to clear local subscription\n+        try {\n+            channelManager.stopDelivery(topicSubscriber); \n+        } catch (ClientNotSubscribedException cnse) {\n+            // it is OK to ignore the exception when closing subscription\n+        }\n+        logger.debug(\"Closing subscription asynchronously for {}.\", topicSubscriber);\n+        channelManager.asyncCloseSubscription(topicSubscriber, callback, context);\n+    }\n+}"},{"sha":"1d4f95555ac34c9ddff68e913c0b865b09de581c","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","status":"added","additions":221,"deletions":0,"changes":221,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ConsumeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PublishRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n+\n+/**\n+ * Utilities for network operations.\n+ */\n+public class NetUtils {\n+\n+    /**\n+     * Helper static method to get the String Hostname:Port from a netty\n+     * Channel. Assumption is that the netty Channel was originally created with\n+     * an InetSocketAddress. This is true with the Hedwig netty implementation.\n+     *\n+     * @param channel\n+     *            Netty channel to extract the hostname and port from.\n+     * @return String representation of the Hostname:Port from the Netty Channel\n+     */\n+    public static InetSocketAddress getHostFromChannel(Channel channel) {\n+        return (InetSocketAddress) channel.getRemoteAddress();\n+    }\n+\n+    /**\n+     * This is a helper method to build the actual pub/sub message.\n+     *\n+     * @param txnId\n+     *            Transaction Id.\n+     * @param pubSubData\n+     *            Publish call's data wrapper object.\n+     * @return pub sub request to send\n+     */\n+    public static PubSubRequest.Builder buildPubSubRequest(long txnId,\n+                                                           PubSubData pubSubData) {\n+        // Create a PubSubRequest\n+        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n+        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n+        pubsubRequestBuilder.setType(pubSubData.operationType);\n+        // for consume request, we don't need to care about tried servers list\n+        if (OperationType.CONSUME != pubSubData.operationType) {\n+            if (pubSubData.triedServers != null && pubSubData.triedServers.size() > 0) {\n+                pubsubRequestBuilder.addAllTriedServers(pubSubData.triedServers);\n+            }\n+        }\n+        pubsubRequestBuilder.setTxnId(txnId);\n+        pubsubRequestBuilder.setShouldClaim(pubSubData.shouldClaim);\n+        pubsubRequestBuilder.setTopic(pubSubData.topic);\n+\n+        switch (pubSubData.operationType) {\n+        case PUBLISH:\n+            // Set the PublishRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setPublishRequest(buildPublishRequest(pubSubData));\n+            break;\n+        case SUBSCRIBE:\n+            // Set the SubscribeRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setSubscribeRequest(buildSubscribeRequest(pubSubData));\n+            break;\n+        case UNSUBSCRIBE:\n+            // Set the UnsubscribeRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setUnsubscribeRequest(buildUnsubscribeRequest(pubSubData));\n+            break;\n+        case CLOSESUBSCRIPTION:\n+            // Set the CloseSubscriptionRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setCloseSubscriptionRequest(\n+                buildCloseSubscriptionRequest(pubSubData));\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"Unknown argument type \" + pubSubData.operationType);\n+        }\n+\n+        // Update the PubSubData with the txnId and the requestWriteTime\n+        pubSubData.txnId = txnId;\n+        pubSubData.requestWriteTime = System.currentTimeMillis();\n+\n+        return pubsubRequestBuilder;\n+    }\n+\n+    // build publish request\n+    private static PublishRequest.Builder buildPublishRequest(PubSubData pubSubData) {\n+        PublishRequest.Builder publishRequestBuilder = PublishRequest.newBuilder();\n+        publishRequestBuilder.setMsg(pubSubData.msg);\n+        return publishRequestBuilder;\n+    }\n+\n+    // build subscribe request\n+    private static SubscribeRequest.Builder buildSubscribeRequest(PubSubData pubSubData) { SubscribeRequest.Builder subscribeRequestBuilder = SubscribeRequest.newBuilder();\n+        subscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n+        subscribeRequestBuilder.setCreateOrAttach(pubSubData.options.getCreateOrAttach());\n+        subscribeRequestBuilder.setForceAttach(pubSubData.options.getForceAttach());\n+        // For now, all subscribes should wait for all cross-regional\n+        // subscriptions to be established before returning.\n+        subscribeRequestBuilder.setSynchronous(true);\n+        // set subscription preferences\n+        SubscriptionPreferences.Builder preferencesBuilder =\n+            options2Preferences(pubSubData.options);\n+        // backward compatable with 4.1.0\n+        if (preferencesBuilder.hasMessageBound()) {\n+            subscribeRequestBuilder.setMessageBound(preferencesBuilder.getMessageBound());\n+        } \n+        subscribeRequestBuilder.setPreferences(preferencesBuilder);\n+        return subscribeRequestBuilder;\n+    }\n+\n+    // build unsubscribe request\n+    private static UnsubscribeRequest.Builder buildUnsubscribeRequest(PubSubData pubSubData) {\n+        // Create the UnSubscribeRequest\n+        UnsubscribeRequest.Builder unsubscribeRequestBuilder = UnsubscribeRequest.newBuilder();\n+        unsubscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n+        return unsubscribeRequestBuilder;\n+    }\n+\n+    // build closesubscription request\n+    private static CloseSubscriptionRequest.Builder\n+        buildCloseSubscriptionRequest(PubSubData pubSubData) {\n+        // Create the CloseSubscriptionRequest\n+        CloseSubscriptionRequest.Builder closeSubscriptionRequestBuilder =\n+            CloseSubscriptionRequest.newBuilder();\n+        closeSubscriptionRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n+        return closeSubscriptionRequestBuilder;\n+    }\n+\n+    /**\n+     * Build consume request\n+     *\n+     * @param txnId\n+     *          Transaction Id.\n+     * @param topicSubscriber\n+     *          Topic Subscriber.\n+     * @param messageSeqId\n+     *          Message Seq Id.\n+     * @return pub/sub request.\n+     */\n+    public static PubSubRequest.Builder buildConsumeRequest(long txnId,\n+                                                            TopicSubscriber topicSubscriber,\n+                                                            MessageSeqId messageSeqId) {\n+        // Create a PubSubRequest\n+        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n+        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n+        pubsubRequestBuilder.setType(OperationType.CONSUME);\n+\n+        pubsubRequestBuilder.setTxnId(txnId);\n+        pubsubRequestBuilder.setTopic(topicSubscriber.getTopic());\n+\n+        // Create the ConsumeRequest\n+        ConsumeRequest.Builder consumeRequestBuilder = ConsumeRequest.newBuilder();\n+        consumeRequestBuilder.setSubscriberId(topicSubscriber.getSubscriberId());\n+        consumeRequestBuilder.setMsgId(messageSeqId);\n+\n+        pubsubRequestBuilder.setConsumeRequest(consumeRequestBuilder);\n+\n+        return pubsubRequestBuilder;\n+    }\n+\n+    /**\n+     * Convert client-side subscription options to subscription preferences\n+     *\n+     * @param options\n+     *          Client-Side subscription options\n+     * @return subscription preferences\n+     */\n+    private static SubscriptionPreferences.Builder options2Preferences(SubscriptionOptions options) {\n+        // prepare subscription preferences\n+        SubscriptionPreferences.Builder preferencesBuilder =\n+            SubscriptionPreferences.newBuilder();\n+\n+        // set message bound\n+        if (options.getMessageBound() > 0) {\n+            preferencesBuilder.setMessageBound(options.getMessageBound());\n+        }\n+\n+        // set message filter\n+        if (options.hasMessageFilter()) {\n+            preferencesBuilder.setMessageFilter(options.getMessageFilter());\n+        }\n+\n+        // set user options\n+        if (options.hasOptions()) {\n+            preferencesBuilder.setOptions(options.getOptions());\n+        }\n+\n+        // set message window size if set\n+        if (options.hasMessageWindowSize() && options.getMessageWindowSize() > 0) {\n+            preferencesBuilder.setMessageWindowSize(options.getMessageWindowSize());\n+        }\n+\n+        return preferencesBuilder;\n+    }\n+\n+}"},{"sha":"ffe866108ec54a3fbf082d91e198bf53ecaabf18","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.concurrent.CopyOnWriteArraySet;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.util.SubscriptionListener;\n+\n+public class SubscriptionEventEmitter {\n+\n+    private final CopyOnWriteArraySet<SubscriptionListener> listeners;\n+\n+    public SubscriptionEventEmitter() {\n+        listeners = new CopyOnWriteArraySet<SubscriptionListener>();\n+    }\n+\n+    public void addSubscriptionListener(SubscriptionListener listener) {\n+        listeners.add(listener); \n+    }\n+\n+    public void removeSubscriptionListener(SubscriptionListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    public void emitSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                      SubscriptionEvent event) {\n+        for (SubscriptionListener listener : listeners) {\n+            listener.processEvent(topic, subscriberId, event);\n+        }\n+    }\n+\n+}"},{"sha":"dc2cf8bc2007377fe4d57c39bf407a481c00bf39","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/VoidCallbackAdapter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Adapts from Callback&lt;T> to Callback&lt;Void>. (Ignores the &lt;T> parameter).\n+ */\n+public class VoidCallbackAdapter<T> implements Callback<T> {\n+    private final Callback<Void> delegate;\n+\n+    public VoidCallbackAdapter(Callback<Void> delegate){\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public void operationFinished(Object ctx, T resultOfOperation) {\n+        delegate.operationFinished(ctx, null);\n+    }\n+\n+    @Override\n+    public void operationFailed(Object ctx, PubSubException exception) {\n+        delegate.operationFailed(ctx, exception);\n+    }\n+}"},{"sha":"6fb89784bd34c894fee74a2804d5e26de5f823d4","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","status":"added","additions":624,"deletions":0,"changes":624,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,624 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.MessageConsumeCallback;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.SubscriptionEventEmitter;\n+import org.apache.hedwig.client.ssl.SslClientContextFactory;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageHeader;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * Basic HChannel Manager Implementation\n+ */\n+public abstract class AbstractHChannelManager implements HChannelManager {\n+\n+    private static Logger logger = LoggerFactory.getLogger(AbstractHChannelManager.class);\n+\n+    // Empty Topic List\n+    private final static Set<ByteString> EMPTY_TOPIC_SET =\n+        new HashSet<ByteString>();\n+\n+    // Boolean indicating if the channel manager is running or has been closed.\n+    // Once we stop the manager, we should sidestep all of the connect, write callback\n+    // and channel disconnected logic.\n+    protected boolean closed = false;\n+    protected final ReentrantReadWriteLock closedLock =\n+        new ReentrantReadWriteLock();\n+\n+    // Global counter used for generating unique transaction ID's for\n+    // publish and subscribe requests\n+    protected final AtomicLong globalCounter = new AtomicLong();\n+\n+    // Concurrent Map to store the mapping from the Topic to the Host.\n+    // This could change over time since servers can drop mastership of topics\n+    // for load balancing or failover. If a server host ever goes down, we'd\n+    // also want to remove all topic mappings the host was responsible for.\n+    // The second Map is used as the inverted version of the first one.\n+    protected final ConcurrentMap<ByteString, InetSocketAddress> topic2Host =\n+        new ConcurrentHashMap<ByteString, InetSocketAddress>();\n+    // The inverse mapping is used only when clearing all topics. For performance\n+    // consideration, we don't guarantee host2Topics to be consistent with\n+    // topic2Host. it would be better to not rely on this mapping for anything\n+    // significant.\n+    protected final ConcurrentMap<InetSocketAddress, Set<ByteString>> host2Topics =\n+        new ConcurrentHashMap<InetSocketAddress, Set<ByteString>>();\n+\n+    // This channels will be used for publish and unsubscribe requests\n+    protected final CleanupChannelMap<InetSocketAddress> host2NonSubscriptionChannels =\n+        new CleanupChannelMap<InetSocketAddress>();\n+\n+    private final ClientConfiguration cfg;\n+    // The Netty socket factory for making connections to the server.\n+    protected final ChannelFactory socketFactory;\n+    // PipelineFactory to create non-subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory nonSubscriptionChannelPipelineFactory;\n+    // ssl context factory\n+    private SslClientContextFactory sslFactory = null;\n+\n+    // default server channel\n+    private final HChannel defaultServerChannel;\n+\n+    // Each client instantiation will have a Timer for running recurring\n+    // threads. One such timer task thread to is to timeout long running\n+    // PubSubRequests that are waiting for an ack response from the server.\n+    private final Timer clientTimer = new Timer(true);\n+    // a common consume callback for all consume requests.\n+    private final MessageConsumeCallback consumeCb;\n+    // A event emitter to emit subscription events\n+    private final SubscriptionEventEmitter eventEmitter;\n+\n+    protected AbstractHChannelManager(ClientConfiguration cfg,\n+                                      ChannelFactory socketFactory) {\n+        this.cfg = cfg;\n+        this.socketFactory = socketFactory;\n+        this.nonSubscriptionChannelPipelineFactory =\n+            new NonSubscriptionChannelPipelineFactory(cfg, this);\n+\n+        // create a default server channel\n+        defaultServerChannel =\n+            new DefaultServerChannel(cfg.getDefaultServerHost(), this);\n+\n+        if (cfg.isSSLEnabled()) {\n+            sslFactory = new SslClientContextFactory(cfg);\n+        }\n+\n+        consumeCb = new MessageConsumeCallback(cfg, this);\n+        eventEmitter = new SubscriptionEventEmitter();\n+\n+        // Schedule Request Timeout task.\n+        clientTimer.schedule(new PubSubRequestTimeoutTask(), 0,\n+                             cfg.getTimeoutThreadRunInterval());\n+    }\n+\n+    @Override\n+    public SubscriptionEventEmitter getSubscriptionEventEmitter() {\n+        return eventEmitter;\n+    }\n+\n+    public MessageConsumeCallback getConsumeCallback() {\n+        return consumeCb;\n+    }\n+\n+    public SslClientContextFactory getSslFactory() {\n+        return sslFactory;\n+    }\n+\n+    protected ChannelFactory getChannelFactory() {\n+        return socketFactory;\n+    }\n+\n+    protected ClientChannelPipelineFactory getNonSubscriptionChannelPipelineFactory() {\n+        return this.nonSubscriptionChannelPipelineFactory;\n+    }\n+\n+    protected abstract ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory();\n+\n+    @Override\n+    public void schedule(final TimerTask task, final long delay) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                logger.warn(\"Task {} is not scheduled due to the channel manager is closed.\",\n+                            task);\n+                return;\n+            }\n+            clientTimer.schedule(task, delay);\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void submitOpAfterDelay(final PubSubData pubSubData, final long delay) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                pubSubData.getCallback().operationFailed(pubSubData.context,\n+                    new ServiceDownException(\"Client has been closed.\"));\n+                return;\n+            }\n+            clientTimer.schedule(new TimerTask() {\n+                @Override\n+                public void run() {\n+                    logger.debug(\"Submit request {} in {} ms later.\",\n+                                 va(pubSubData, delay));\n+                    submitOp(pubSubData);\n+                }\n+            }, delay);\n+        } finally {\n+            closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void submitOp(PubSubData pubSubData) {\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = getNonSubscriptionChannelByTopic(pubSubData.topic);\n+        } else {\n+            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n+                                                     pubSubData.subscriberId);\n+            hChannel = getSubscriptionChannelByTopicSubscriber(ts);\n+        }\n+        // no channel found to submit pubsub data\n+        // choose the default server\n+        if (null == hChannel) {\n+            hChannel = defaultServerChannel;\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    @Override\n+    public void redirectToHost(PubSubData pubSubData, InetSocketAddress host) {\n+        logger.debug(\"Submit operation {} to host {}.\",\n+                     va(pubSubData, host));\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = getNonSubscriptionChannel(host);\n+            if (null == hChannel) {\n+                // create a channel to connect to specified host\n+                hChannel = createAndStoreNonSubscriptionChannel(host);\n+            }\n+        } else {\n+            hChannel = getSubscriptionChannel(host);\n+            if (null == hChannel) {\n+                // create a subscription channel to specified host\n+                hChannel = createAndStoreSubscriptionChannel(host);\n+            }\n+        }\n+        // no channel found to submit pubsub data\n+        // choose the default server\n+        if (null == hChannel) {\n+            hChannel = defaultServerChannel;\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    void submitOpThruChannel(PubSubData pubSubData, Channel channel) {\n+        logger.debug(\"Submit operation {} to thru channel {}.\",\n+                     va(pubSubData, channel));\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = createAndStoreNonSubscriptionChannel(channel);\n+        } else {\n+            hChannel = createAndStoreSubscriptionChannel(channel);\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    @Override\n+    public void submitOpToDefaultServer(PubSubData pubSubData) {\n+        logger.debug(\"Submit operation {} to default server {}.\",\n+                     va(pubSubData, defaultServerChannel));\n+        defaultServerChannel.submitOp(pubSubData);\n+    }\n+\n+    // Synchronized method to store the host2Channel mapping (if it doesn't\n+    // exist yet). Retrieve the hostname info from the Channel created via the\n+    // RemoteAddress tied to it.\n+    private HChannel createAndStoreNonSubscriptionChannel(Channel channel) {\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getNonSubscriptionChannelPipelineFactory());\n+        return storeNonSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel createAndStoreNonSubscriptionChannel(InetSocketAddress host) {\n+        HChannel newHChannel = new HChannelImpl(host, this,\n+                                                getNonSubscriptionChannelPipelineFactory());\n+        return storeNonSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel storeNonSubscriptionChannel(InetSocketAddress host,\n+                                                 HChannel newHChannel) {\n+        return host2NonSubscriptionChannels.addChannel(host, newHChannel);\n+    }\n+\n+    /**\n+     * Is there a {@link HChannel} existed for a given host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    private HChannel getNonSubscriptionChannel(InetSocketAddress host) {\n+        return host2NonSubscriptionChannels.getChannel(host);\n+    }\n+\n+    /**\n+     * Get a non-subscription channel for a given <code>topic</code>.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @return if <code>topic</code>'s owner is unknown, return null.\n+     *         if <code>topic</code>'s owner is know and there is a channel\n+     *         existed before, return the existed channel, otherwise created\n+     *         a new one.\n+     */\n+    private HChannel getNonSubscriptionChannelByTopic(ByteString topic) {\n+        InetSocketAddress host = topic2Host.get(topic);\n+        if (null == host) {\n+            // we don't know where is the topic\n+            return null;\n+        } else {\n+            // we had know which server owned the topic\n+            HChannel channel = getNonSubscriptionChannel(host);\n+            if (null == channel) {\n+                // create a channel to connect to specified host\n+                channel = createAndStoreNonSubscriptionChannel(host);\n+            }\n+            return channel;\n+        }\n+    }\n+\n+    /**\n+     * Handle the disconnected event from a non-subscription {@link HChannel}.\n+     *\n+     * @param host\n+     *          Which host is disconnected.\n+     * @param channel\n+     *          The underlying established channel.\n+     */\n+    protected void onNonSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                        Channel channel) {\n+        // Only remove the Channel from the mapping if this current\n+        // disconnected channel is the same as the cached entry.\n+        // Due to race concurrency situations, it is possible to\n+        // create multiple channels to the same host for publish\n+        // and unsubscribe requests.\n+        HChannel hChannel = host2NonSubscriptionChannels.getChannel(host);\n+        if (null == hChannel) {\n+            return;\n+        }\n+        Channel underlyingChannel = hChannel.getChannel();\n+        if (null == underlyingChannel ||\n+            !underlyingChannel.equals(channel)) {\n+            return;\n+        }\n+        logger.info(\"NonSubscription Channel {} to {} disconnected.\",\n+                    va(channel, host));\n+        // remove existed channel\n+        if (host2NonSubscriptionChannels.removeChannel(host, hChannel)) {\n+            clearAllTopicsForHost(host);\n+        }\n+    }\n+\n+    /**\n+     * Create and store a subscription {@link HChannel} thru the underlying established\n+     * <code>channel</code>\n+     *\n+     * @param channel\n+     *          The underlying established subscription channel.\n+     */\n+    protected abstract HChannel createAndStoreSubscriptionChannel(Channel channel);\n+\n+    /**\n+     * Create and store a subscription {@link HChannel} to target host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    protected abstract HChannel createAndStoreSubscriptionChannel(InetSocketAddress host);\n+\n+    /**\n+     * Is there a subscription {@link HChannel} existed for a given host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    protected abstract HChannel getSubscriptionChannel(InetSocketAddress host);\n+\n+    /**\n+     * Get a subscription channel for a given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @return if <code>topic</code>'s owner is unknown, return null.\n+     *         if <code>topic</code>'s owner is know and there is a channel\n+     *         existed before, return the existed channel, otherwise created\n+     *         a new one for the <code>topicSubscriber</code>.\n+     */\n+    protected abstract HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Handle the disconnected event from a subscription {@link HChannel}.\n+     *\n+     * @param host\n+     *          Which host is disconnected.\n+     * @param channel\n+     *          The underlying established channel.\n+     */\n+    protected abstract void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                              Channel channel);\n+\n+    private void sendConsumeRequest(final TopicSubscriber topicSubscriber,\n+                                    final MessageSeqId messageSeqId,\n+                                    final Channel channel) {\n+        PubSubRequest.Builder pubsubRequestBuilder =\n+            NetUtils.buildConsumeRequest(nextTxnId(), topicSubscriber, messageSeqId);  \n+\n+        // For Consume requests, we will send them from the client in a fire and\n+        // forget manner. We are not expecting the server to send back an ack\n+        // response so no need to register this in the ResponseHandler. There\n+        // are no callbacks to invoke since this isn't a client initiated\n+        // action. Instead, just have a future listener that will log an error\n+        // message if there was a problem writing the consume request.\n+        logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                     va(NetUtils.getHostFromChannel(channel), messageSeqId, topicSubscriber));\n+        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                                 va(NetUtils.getHostFromChannel(channel),\n+                                    messageSeqId, topicSubscriber));\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Helper method to store the topic2Host mapping in the channel manager cache\n+     * map. This method is assumed to be called when we've done a successful\n+     * connection to the correct server topic master.\n+     *\n+     * @param topic\n+     *            Topic Name\n+     * @param host\n+     *            Host Address\n+     */\n+    protected void storeTopic2HostMapping(ByteString topic, InetSocketAddress host) {\n+        InetSocketAddress oldHost = topic2Host.putIfAbsent(topic, host);\n+        if (null != oldHost && oldHost.equals(host)) {\n+            // Entry in map exists for the topic but it is the same as the\n+            // current host. In this case there is nothing to do.\n+            return;\n+        }\n+\n+        if (null != oldHost) {\n+            if (topic2Host.replace(topic, oldHost, host)) {\n+                // Store the relevant mappings for this topic and host combination.\n+                logger.debug(\"Storing info for topic: {}, old host: {}, new host: {}.\",\n+                             va(topic.toStringUtf8(), oldHost, host));\n+                clearHostForTopic(topic, oldHost);\n+            } else {\n+                logger.warn(\"Ownership of topic: {} has been changed from {} to {} when storeing host: {}\",\n+                            va(topic.toStringUtf8(), oldHost, topic2Host.get(topic), host));\n+                return;\n+            }\n+        } else {\n+            logger.debug(\"Storing info for topic: {}, host: {}.\",\n+                         va(topic.toStringUtf8(), host));\n+        }\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null == topicsForHost) {\n+            Set<ByteString> newTopicsSet = new HashSet<ByteString>();\n+            topicsForHost = host2Topics.putIfAbsent(host, newTopicsSet);\n+            if (null == topicsForHost) {\n+              topicsForHost = newTopicsSet;\n+            }\n+        }\n+        synchronized (topicsForHost) {\n+            // check whether the ownership changed, since it might happened\n+            // after replace succeed\n+            if (host.equals(topic2Host.get(topic))) {\n+                topicsForHost.add(topic);\n+            }\n+        }\n+    }\n+\n+    // If a server host goes down or the channel to it gets disconnected,\n+    // we want to clear out all relevant cached information. We'll\n+    // need to remove all of the topic mappings that the host was\n+    // responsible for.\n+    protected void clearAllTopicsForHost(InetSocketAddress host) {\n+        logger.debug(\"Clearing all topics for host: {}\", host);\n+        // For each of the topics that the host was responsible for,\n+        // remove it from the topic2Host mapping.\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null != topicsForHost) {\n+            synchronized (topicsForHost) {\n+                for (ByteString topic : topicsForHost) {\n+                    logger.debug(\"Removing mapping for topic: {} from host: {}.\",\n+                                 va(topic.toStringUtf8(), host));\n+                    topic2Host.remove(topic, host);\n+                }\n+            }\n+            // Now it is safe to remove the host2Topics mapping entry.\n+            host2Topics.remove(host, topicsForHost);\n+        }\n+    }\n+\n+    // If a subscribe channel goes down, the topic might have moved.\n+    // We only clear out that topic for the host and not all cached information.\n+    public void clearHostForTopic(ByteString topic, InetSocketAddress host) {\n+        logger.debug(\"Clearing topic: {} from host: {}.\",\n+                     va(topic.toStringUtf8(), host));\n+        if (topic2Host.remove(topic, host)) {\n+            logger.debug(\"Removed topic to host mapping for topic: {} and host: {}.\",\n+                         va(topic.toStringUtf8(), host));\n+        }\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null != topicsForHost) {\n+            boolean removed;\n+            synchronized (topicsForHost) {\n+                removed = topicsForHost.remove(topic);\n+            }\n+            if (removed) {\n+                logger.debug(\"Removed topic: {} from host: {}.\",\n+                             topic.toStringUtf8(), host);\n+                if (topicsForHost.isEmpty()) {\n+                    // remove only topic list is empty\n+                    host2Topics.remove(host, EMPTY_TOPIC_SET);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long nextTxnId() {\n+        return globalCounter.incrementAndGet();\n+    }\n+\n+    // We need to deal with the possible problem of a PubSub request being\n+    // written to successfully to the server host but for some reason, the\n+    // ack message back never comes. What could happen is that the VoidCallback\n+    // stored in the ResponseHandler.txn2PublishData map will never be called.\n+    // We should have a configured timeout so if that passes from the time a\n+    // write was successfully done to the server, we can fail this async PubSub\n+    // transaction. The caller could possibly redo the transaction if needed at\n+    // a later time. Creating a timeout cleaner TimerTask to do this here.\n+    class PubSubRequestTimeoutTask extends TimerTask {\n+        /**\n+         * Implement the TimerTask's abstract run method.\n+         */\n+        @Override\n+        public void run() {\n+            if (isClosed()) {\n+                return;\n+            }\n+            logger.debug(\"Running the PubSubRequest Timeout Task\");\n+            // First check those non-subscription channels\n+            for (HChannel channel : host2NonSubscriptionChannels.getChannels()) {\n+                try {\n+                    HChannelHandler channelHandler =\n+                        HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                    channelHandler.checkTimeoutRequests();\n+                } catch (NoResponseHandlerException nrhe) {\n+                    continue;\n+                }\n+            }\n+            // Then check those subscription channels\n+            checkTimeoutRequestsOnSubscriptionChannels();\n+        }\n+    }\n+\n+    protected abstract void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n+\n+    /**\n+     * Chekout the pub/sub requests on subscription channels.\n+     */\n+    protected abstract void checkTimeoutRequestsOnSubscriptionChannels();\n+\n+    @Override\n+    public boolean isClosed() {\n+        closedLock.readLock().lock();\n+        try {\n+            return closed; \n+        } finally {\n+            closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Close all subscription channels when close channel manager.\n+     */\n+    protected abstract void closeSubscriptionChannels();\n+\n+    @Override\n+    public void close() {\n+        logger.info(\"Shutting down the channels manager.\");\n+        closedLock.writeLock().lock();\n+        try {\n+            // Not first time to close\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        } finally {\n+            closedLock.writeLock().unlock();\n+        }\n+        clientTimer.cancel();\n+        // Clear all existed channels\n+        host2NonSubscriptionChannels.close();\n+\n+        // clear all subscription channels\n+        closeSubscriptionChannels();\n+\n+        // Clear out all Maps\n+        topic2Host.clear();\n+        host2Topics.clear();\n+    }\n+\n+}"},{"sha":"ad5c2cd8f745800098faa3e564916bf34f27bcba","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","status":"added","additions":377,"deletions":0,"changes":377,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractSubscribeResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,377 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n+import org.apache.hedwig.util.SubscriptionListener;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public abstract class AbstractSubscribeResponseHandler extends SubscribeResponseHandler {\n+\n+    private static Logger logger =\n+        LoggerFactory.getLogger(AbstractSubscribeResponseHandler.class);\n+\n+    protected final ReentrantReadWriteLock disconnectLock =\n+        new ReentrantReadWriteLock();\n+\n+    protected final ConcurrentMap<TopicSubscriber, ActiveSubscriber> subscriptions\n+        = new ConcurrentHashMap<TopicSubscriber, ActiveSubscriber>();\n+    protected final AbstractHChannelManager aChannelManager;\n+\n+    protected AbstractSubscribeResponseHandler(ClientConfiguration cfg,\n+                                               HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        this.aChannelManager = (AbstractHChannelManager) channelManager;\n+    }\n+\n+    protected HChannelManager getHChannelManager() {\n+        return this.channelManager;\n+    }\n+\n+    protected ClientConfiguration getConfiguration() {\n+        return cfg;\n+    }\n+\n+    protected ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n+        return subscriptions.get(ts);\n+    }\n+\n+    protected ActiveSubscriber createActiveSubscriber(\n+        ClientConfiguration cfg, AbstractHChannelManager channelManager,\n+        TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n+        Channel channel, HChannel hChannel) {\n+        return new ActiveSubscriber(cfg, channelManager, ts, op, preferences, channel, hChannel);\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n+                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n+        }\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n+                                                     pubSubData.subscriberId);\n+            SubscriptionPreferences preferences = null;\n+            if (response.hasResponseBody()) {\n+                ResponseBody respBody = response.getResponseBody();\n+                if (respBody.hasSubscribeResponse()) {\n+                    SubscribeResponse resp = respBody.getSubscribeResponse();\n+                    if (resp.hasPreferences()) {\n+                        preferences = resp.getPreferences();\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Receive subscription preferences for {} : {}\",\n+                                         va(ts,\n+                                            SubscriptionStateUtils.toString(preferences)));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Either<StatusCode, HChannel> result;\n+            StatusCode statusCode;\n+            ActiveSubscriber ss = null;\n+            // Store the Subscribe state\n+            disconnectLock.readLock().lock();\n+            try {\n+                result = handleSuccessResponse(ts, pubSubData, channel);\n+                statusCode = result.left();\n+                if (StatusCode.SUCCESS == statusCode) {\n+                    ss = createActiveSubscriber(\n+                        cfg, aChannelManager, ts, pubSubData, preferences, channel, result.right());\n+                    statusCode = addSubscription(ts, ss);\n+                }\n+            } finally {\n+                disconnectLock.readLock().unlock();\n+            }\n+            if (StatusCode.SUCCESS == statusCode) {\n+                postHandleSuccessResponse(ts, ss);\n+                // Response was success so invoke the callback's operationFinished\n+                // method.\n+                pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            } else {\n+                PubSubException exception = PubSubException.create(statusCode,\n+                    \"Client is already subscribed for \" + ts);\n+                pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            }\n+            break;\n+        case CLIENT_ALREADY_SUBSCRIBED:\n+            // For Subscribe requests, the server says that the client is\n+            // already subscribed to it.\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                    new ClientAlreadySubscribedException(\"Client is already subscribed for topic: \"\n+                                                         + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                         + pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original Subscribe\n+            // Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                    new ServiceDownException(\"Server responded with a status code of: \"\n+                            + response.getStatusCode(),\n+                            PubSubException.create(response.getStatusCode(),\n+                                                   \"Original Exception\")));\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Handle success response for a specific TopicSubscriber <code>ts</code>. The method\n+     * is triggered after subscribed successfully.\n+     *\n+     * @param ts\n+     *          Topic Subscriber.\n+     * @param pubSubData\n+     *          Pub/Sub Request data for this subscribe request.\n+     * @param channel\n+     *          Subscription Channel.\n+     * @return status code to indicate what happened\n+     */\n+    protected abstract Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel);\n+\n+    protected void postHandleSuccessResponse(TopicSubscriber ts, ActiveSubscriber ss) {\n+        // do nothing now\n+    }\n+\n+    private StatusCode addSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n+        if (null != oldSS) {\n+            return StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+        } else {\n+            return StatusCode.SUCCESS;\n+        }\n+    }\n+\n+    @Override\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        Message message = response.getMessage();\n+        TopicSubscriber ts = new TopicSubscriber(response.getTopic(),\n+                                                 response.getSubscriberId());\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n+                         va(response, ts));\n+        }\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found receiving its message {}.\",\n+                         va(ts, MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.handleMessage(message);\n+    }\n+\n+    @Override\n+    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                       Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found delivering its message {}.\",\n+                         va(topicSubscriber,\n+                            MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.asyncMessageDeliver(message);\n+    }\n+\n+    @Override\n+    protected void messageConsumed(TopicSubscriber topicSubscriber,\n+                                   Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consumed its message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Message has been successfully consumed by the client app : {}, {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        ss.messageConsumed(message);\n+    }\n+\n+    @Override\n+    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                        SubscriptionEvent event) {\n+        TopicSubscriber ts = new TopicSubscriber(topic, subscriberId);\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.warn(\"No subscription {} found receiving subscription event {}.\",\n+                        va(ts, event));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Received subscription event {} for ({}).\",\n+                         va(event, ts));\n+        }\n+        processSubscriptionEvent(ss, event);\n+    }\n+\n+    protected void processSubscriptionEvent(ActiveSubscriber as, SubscriptionEvent event) {\n+        switch (event) {\n+        // for all cases we need to resubscribe for the subscription\n+        case TOPIC_MOVED:\n+        case SUBSCRIPTION_FORCED_CLOSED:\n+            resubscribeIfNecessary(as, event);\n+            break;\n+        default:\n+            logger.error(\"Receive unknown subscription event {} for {}.\",\n+                         va(event, as.getTopicSubscriber()));\n+        }\n+    }\n+\n+    @Override\n+    public void startDelivery(final TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Start delivering message for {} using message handler {}\",\n+                         va(topicSubscriber, messageHandler));\n+        }\n+        ss.startDelivery(messageHandler);\n+    }\n+\n+    @Override\n+    public void stopDelivery(final TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n+        }\n+        ss.stopDelivery();\n+    }\n+\n+    @Override\n+    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n+        return subscriptions.containsKey(topicSubscriber);\n+    }\n+\n+    @Override\n+    public void consume(final TopicSubscriber topicSubscriber,\n+                        final MessageSeqId messageSeqId) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consuming message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(messageSeqId)));\n+            return;\n+        }\n+        ss.consume(messageSeqId);\n+    }\n+\n+    @Override\n+    public void onChannelDisconnected(InetSocketAddress host, Channel channel) {\n+        disconnectLock.writeLock().lock();\n+        try {\n+            onDisconnect(host);\n+        } finally {\n+            disconnectLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private void onDisconnect(InetSocketAddress host) {\n+        for (ActiveSubscriber ss : subscriptions.values()) {\n+            onDisconnect(ss, host);\n+        }\n+    }\n+\n+    private void onDisconnect(ActiveSubscriber ss, InetSocketAddress host) {\n+        logger.info(\"Subscription channel for ({}) is disconnected.\", ss);\n+        resubscribeIfNecessary(ss, SubscriptionEvent.TOPIC_MOVED);\n+    }\n+\n+    protected boolean removeSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        return subscriptions.remove(ts, ss);\n+    }\n+\n+    protected void resubscribeIfNecessary(ActiveSubscriber ss, SubscriptionEvent event) {\n+        // if subscriber has been changed, we don't need to resubscribe\n+        if (!removeSubscription(ss.getTopicSubscriber(), ss)) {\n+            return;\n+        }\n+        ss.resubscribeIfNecessary(event);\n+    }\n+\n+}"},{"sha":"10506d821af6e15a71ec4ab531dc54ccf319e425","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","status":"added","additions":382,"deletions":0,"changes":382,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ActiveSubscriber.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,382 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * an active subscriber handles subscription actions in a channel.\n+ */\n+public class ActiveSubscriber {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ActiveSubscriber.class);\n+\n+    protected final ClientConfiguration cfg;\n+    protected final AbstractHChannelManager channelManager;\n+\n+    // Subscriber related variables\n+    protected final TopicSubscriber topicSubscriber;\n+    protected final PubSubData op;\n+    protected final SubscriptionPreferences preferences;\n+\n+    // the underlying netty channel to send request\n+    protected final Channel channel;\n+    protected final HChannel hChannel;\n+\n+    // Counter for the number of consumed messages so far to buffer up before we\n+    // send the Consume message back to the server along with the last/largest\n+    // message seq ID seen so far in that batch.\n+    private int numConsumedMessagesInBuffer = 0;\n+    private MessageSeqId lastMessageSeqId = null;\n+\n+    // Message Handler\n+    private MessageHandler msgHandler = null;\n+\n+    // Queue used for subscribes when the MessageHandler hasn't been registered\n+    // yet but we've already received subscription messages from the server.\n+    // This will be lazily created as needed.\n+    private final Queue<Message> msgQueue = new LinkedList<Message>();\n+\n+    /**\n+     * Construct an active subscriber instance.\n+     *\n+     * @param cfg\n+     *          Client configuration object.\n+     * @param channelManager\n+     *          Channel manager instance.\n+     * @param ts\n+     *          Topic subscriber.\n+     * @param op\n+     *          Pub/Sub request.\n+     * @param preferences\n+     *          Subscription preferences for the subscriber.\n+     * @param channel\n+     *          Netty channel the subscriber lived.\n+     */\n+    public ActiveSubscriber(ClientConfiguration cfg,\n+                            AbstractHChannelManager channelManager,\n+                            TopicSubscriber ts, PubSubData op,\n+                            SubscriptionPreferences preferences,\n+                            Channel channel,\n+                            HChannel hChannel) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+        this.topicSubscriber = ts;\n+        this.op = op;\n+        this.preferences = preferences;\n+        this.channel = channel;\n+        this.hChannel = hChannel;\n+    }\n+\n+    /**\n+     * @return pub/sub request for the subscription.\n+     */\n+    public PubSubData getPubSubData() {\n+        return this.op;\n+    }\n+\n+    /**\n+     * @return topic subscriber id for the active subscriber.\n+     */\n+    public TopicSubscriber getTopicSubscriber() {\n+        return this.topicSubscriber;\n+    }\n+\n+    /**\n+     * Start delivering messages using given message handler.\n+     *\n+     * @param messageHandler\n+     *          Message handler to deliver messages\n+     * @throws AlreadyStartDeliveryException if someone already started delivery.\n+     * @throws ClientNotSubscribedException when start delivery before subscribe.\n+     */\n+    public synchronized void startDelivery(MessageHandler messageHandler)\n+    throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n+        if (null != this.msgHandler) {\n+            throw new AlreadyStartDeliveryException(\"A message handler \" + msgHandler\n+                + \" has been started for \" + topicSubscriber);\n+        }\n+        if (null != messageHandler && messageHandler instanceof FilterableMessageHandler) {\n+            FilterableMessageHandler filterMsgHandler =\n+                (FilterableMessageHandler) messageHandler;\n+            if (filterMsgHandler.hasMessageFilter()) {\n+                if (null == preferences) {\n+                    // no preferences means talking to an old version hub server\n+                    logger.warn(\"Start delivering messages with filter but no subscription \"\n+                              + \"preferences found. It might due to talking to an old version\"\n+                              + \" hub server.\");\n+                    // use the original message handler.\n+                    messageHandler = filterMsgHandler.getMessageHandler();\n+                } else {\n+                    // pass subscription preferences to message filter\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n+                                     va(topicSubscriber,\n+                                        SubscriptionStateUtils.toString(preferences)));\n+                    }\n+                    ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n+                    msgFilter.setSubscriptionPreferences(topicSubscriber.getTopic(),\n+                                                         topicSubscriber.getSubscriberId(),\n+                                                         preferences);\n+                }\n+            }\n+        }\n+\n+        this.msgHandler = messageHandler;\n+        // Once the MessageHandler is registered, see if we have any queued up\n+        // subscription messages sent to us already from the server. If so,\n+        // consume those first. Do this only if the MessageHandler registered is\n+        // not null (since that would be the HedwigSubscriber.stopDelivery\n+        // call).\n+        if (null == msgHandler) {\n+            return;\n+        }\n+        if (msgQueue.size() > 0) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Consuming {} queued up messages for {}\",\n+                             va(msgQueue.size(), topicSubscriber));\n+            }\n+            for (Message message : msgQueue) {\n+                asyncMessageDeliver(message);\n+            }\n+            // Now we can remove the queued up messages since they are all\n+            // consumed.\n+            msgQueue.clear();\n+        }\n+    }\n+\n+    /**\n+     * Stop delivering messages to the subscriber.\n+     */\n+    public synchronized void stopDelivery() {\n+        this.msgHandler = null;\n+    }\n+\n+    /**\n+     * Handle received message.\n+     *\n+     * @param message\n+     *          Received message.\n+     */\n+    public synchronized void handleMessage(Message message) {\n+        if (null != msgHandler) {\n+            asyncMessageDeliver(message);\n+        } else {\n+            // MessageHandler has not yet been registered so queue up these\n+            // messages for the Topic Subscription. Make the initial lazy\n+            // creation of the message queue thread safe just so we don't\n+            // run into a race condition where two simultaneous threads process\n+            // a received message and both try to create a new instance of\n+            // the message queue. Performance overhead should be okay\n+            // because the delivery of the topic has not even started yet\n+            // so these messages are not consumed and just buffered up here.\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Message {} has arrived but no MessageHandler provided for {}\"\n+                             + \" yet so queueing up the message.\",\n+                             va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                                topicSubscriber));\n+            }\n+            msgQueue.add(message);\n+        }\n+    }\n+\n+    /**\n+     * Deliver message to the client.\n+     *\n+     * @param message\n+     *          Message to deliver.\n+     */\n+    public synchronized void asyncMessageDeliver(Message message) {\n+        if (null == msgHandler) {\n+            logger.error(\"No message handler found to deliver message {} to {}.\",\n+                         va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                            topicSubscriber));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        unsafeDeliverMessage(message);\n+    }\n+\n+    /**\n+     * Unsafe version to deliver message to a message handler.\n+     * Caller need to handle synchronization issue.\n+     *\n+     * @param message\n+     *          Message to deliver.\n+     */\n+    protected void unsafeDeliverMessage(Message message) {\n+        MessageConsumeData messageConsumeData =\n+            new MessageConsumeData(topicSubscriber, message);\n+        msgHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                           message, channelManager.getConsumeCallback(),\n+                           messageConsumeData);\n+    }\n+\n+    private synchronized boolean updateLastMessageSeqId(MessageSeqId seqId) {\n+        if (null != lastMessageSeqId &&\n+            seqId.getLocalComponent() <= lastMessageSeqId.getLocalComponent()) {\n+            return false;\n+        }\n+        ++numConsumedMessagesInBuffer;\n+        lastMessageSeqId = seqId;\n+        if (numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n+            numConsumedMessagesInBuffer = 0;\n+            lastMessageSeqId = null;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Consume a specific message.\n+     *\n+     * @param messageSeqId\n+     *          Message seq id.\n+     */\n+    public void consume(final MessageSeqId messageSeqId) {\n+        PubSubRequest.Builder pubsubRequestBuilder =\n+            NetUtils.buildConsumeRequest(channelManager.nextTxnId(),\n+                                         topicSubscriber, messageSeqId);\n+\n+        // For Consume requests, we will send them from the client in a fire and\n+        // forget manner. We are not expecting the server to send back an ack\n+        // response so no need to register this in the ResponseHandler. There\n+        // are no callbacks to invoke since this isn't a client initiated\n+        // action. Instead, just have a future listener that will log an error\n+        // message if there was a problem writing the consume request.\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Writing a Consume request to channel: {} with messageSeqId: {} for {}\",\n+                         va(channel, messageSeqId, topicSubscriber));\n+        }\n+        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error writing a Consume request to channel: {} with messageSeqId: {} for {}\",\n+                                 va(channel, messageSeqId, topicSubscriber));\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Application acked to consume message.\n+     *\n+     * @param message\n+     *          Message consumed by application.\n+     */\n+    public void messageConsumed(Message message) {\n+        // For consume response to server, there is a config param on how many\n+        // messages to consume and buffer up before sending the consume request.\n+        // We just need to keep a count of the number of messages consumed\n+        // and the largest/latest msg ID seen so far in this batch. Messages\n+        // should be delivered in order and without gaps. Do this only if\n+        // auto-sending of consume messages is enabled.\n+        if (cfg.isAutoSendConsumeMessageEnabled()) {\n+            // Update these variables only if we are auto-sending consume\n+            // messages to the server. Otherwise the onus is on the client app\n+            // to call the Subscriber consume API to let the server know which\n+            // messages it has successfully consumed.\n+            if (updateLastMessageSeqId(message.getMsgId())) {\n+                // Send the consume request and reset the consumed messages buffer\n+                // variables. We will use the same Channel created from the\n+                // subscribe request for the TopicSubscriber.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Consume message {} when reaching consumed message buffer limit.\",\n+                                 message.getMsgId());\n+                }\n+                consume(message.getMsgId());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Resubscribe a subscriber if necessary.\n+     *\n+     * @param event\n+     *          Subscription Event.\n+     */\n+    public void resubscribeIfNecessary(SubscriptionEvent event) {\n+        // clear topic ownership\n+        if (SubscriptionEvent.TOPIC_MOVED == event) {\n+            channelManager.clearHostForTopic(topicSubscriber.getTopic(),\n+                                             NetUtils.getHostFromChannel(channel));\n+        }\n+        if (!op.options.getEnableResubscribe()) {\n+            channelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n+                topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(), event);\n+            return;\n+        }\n+        // Since the connection to the server host that was responsible\n+        // for the topic died, we are not sure about the state of that\n+        // server. Resend the original subscribe request data to the default\n+        // server host/VIP. Also clear out all of the servers we've\n+        // contacted or attempted to from this request as we are starting a\n+        // \"fresh\" subscribe request.\n+        op.clearServersList();\n+        // Set a new type of VoidCallback for this async call. We need this\n+        // hook so after the resubscribe has completed, delivery for\n+        // that topic subscriber should also be restarted (if it was that\n+        // case before the channel disconnect).\n+        final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n+        ResubscribeCallback resubscribeCb =\n+            new ResubscribeCallback(topicSubscriber, op,\n+                                    channelManager, retryWaitTime);\n+        op.setCallback(resubscribeCb);\n+        op.shouldClaim = false;\n+        op.context = null;\n+        op.setOriginalChannelForResubscribe(hChannel);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Resubscribe {} with origSubData {}\",\n+                         va(topicSubscriber, op));\n+        }\n+        // resubmit the request\n+        channelManager.submitOp(op);\n+    }\n+}"},{"sha":"ab86f236091e4a2db5364bd392cc2ad537e3cedb","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.util.Map;\n+\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.channel.ChannelPipelineFactory;\n+import org.jboss.netty.channel.Channels;\n+import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n+import org.jboss.netty.handler.codec.protobuf.ProtobufDecoder;\n+import org.jboss.netty.handler.codec.protobuf.ProtobufEncoder;\n+import org.jboss.netty.handler.ssl.SslHandler;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public abstract class ClientChannelPipelineFactory implements ChannelPipelineFactory {\n+\n+    protected ClientConfiguration cfg;\n+    protected AbstractHChannelManager channelManager;\n+\n+    public ClientChannelPipelineFactory(ClientConfiguration cfg,\n+                                        AbstractHChannelManager channelManager) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+    }\n+\n+    protected abstract Map<OperationType, AbstractResponseHandler> createResponseHandlers();\n+\n+    private HChannelHandler createHChannelHandler() {\n+        return new HChannelHandler(cfg, channelManager, createResponseHandlers());\n+    }\n+\n+    // Retrieve a ChannelPipeline from the factory.\n+    public ChannelPipeline getPipeline() throws Exception {\n+        // Create a new ChannelPipline using the factory method from the\n+        // Channels helper class.\n+        ChannelPipeline pipeline = Channels.pipeline();\n+        if (channelManager.getSslFactory() != null) {\n+            pipeline.addLast(\"ssl\", new SslHandler(channelManager.getSslFactory().getEngine()));\n+        }\n+        pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(\n+                         cfg.getMaximumMessageSize(), 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+\n+        pipeline.addLast(\"protobufdecoder\", new ProtobufDecoder(PubSubProtocol.PubSubResponse.getDefaultInstance()));\n+        pipeline.addLast(\"protobufencoder\", new ProtobufEncoder());\n+\n+        pipeline.addLast(\"responsehandler\", createHChannelHandler());\n+        return pipeline;\n+    }\n+\n+}"},{"sha":"10c05ef666e6eb3cc706ee54eb509f30f2910622","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,92 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handle requests sent to default hub server. <b>DefaultServerChannel</b> would not\n+ * be used as a channel to send requests directly. It just takes the responsibility to\n+ * connect to the default server. After the underlying netty channel is established,\n+ * it would call {@link HChannelManager#submitOpThruChannel()} to send requests thru\n+ * the underlying netty channel.\n+ */\n+class DefaultServerChannel extends HChannelImpl {\n+\n+    private static Logger logger = LoggerFactory.getLogger(DefaultServerChannel.class);\n+\n+    DefaultServerChannel(InetSocketAddress host, AbstractHChannelManager channelManager) {\n+        super(host, channelManager);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[DefaultServer: \").append(host).append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void submitOp(final PubSubData pubSubData) {\n+        // for each pub/sub request sent to default hub server\n+        // we would establish a fresh connection for it\n+        ClientChannelPipelineFactory pipelineFactory;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            pipelineFactory = channelManager.getNonSubscriptionChannelPipelineFactory();\n+        } else {\n+            pipelineFactory = channelManager.getSubscriptionChannelPipelineFactory();\n+        }\n+        ChannelFuture future = connect(host, pipelineFactory);\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                // If the channel has been closed, there is no need to proceed with any callback\n+                // logic here.\n+                if (closed) {\n+                    future.getChannel().close();\n+                    return;\n+                }\n+\n+                // Check if the connection to the server was done successfully.\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error connecting to host {}.\", host);\n+                    future.getChannel().close();\n+\n+                    retryOrFailOp(pubSubData);\n+                    // Finished with failure logic so just return.\n+                    return;\n+                }\n+                logger.debug(\"Connected to host {} for pubSubData: {}\",\n+                             va(host, pubSubData));\n+                channelManager.submitOpThruChannel(pubSubData, future.getChannel());\n+            }\n+        });\n+    }\n+\n+}"},{"sha":"8b751ae8f45c73df85abec03ec301354215f76b5","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","status":"added","additions":282,"deletions":0,"changes":282,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,282 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.ExceptionEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.handler.ssl.SslHandler;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.exceptions.PubSubException.UncertainStateException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class HChannelHandler extends SimpleChannelHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HChannelHandler.class);\n+\n+    // Concurrent Map to store for each async PubSub request, the txn ID\n+    // and the corresponding PubSub call's data which stores the VoidCallback to\n+    // invoke when we receive a PubSub ack response from the server.\n+    // This is specific to this instance of the HChannelHandler which is\n+    // tied to a specific netty Channel Pipeline.\n+    private final ConcurrentMap<Long, PubSubData> txn2PubSubData =\n+        new ConcurrentHashMap<Long, PubSubData>();\n+\n+    // Boolean indicating if we closed the channel this HChannelHandler is\n+    // attached to explicitly or not. If so, we do not need to do the\n+    // channel disconnected logic here.\n+    private volatile boolean channelClosedExplicitly = false;\n+\n+    private final AbstractHChannelManager channelManager;\n+    private final ClientConfiguration cfg;\n+\n+    private final Map<OperationType, AbstractResponseHandler> handlers;\n+    private final SubscribeResponseHandler subHandler;\n+\n+    public HChannelHandler(ClientConfiguration cfg,\n+                           AbstractHChannelManager channelManager,\n+                           Map<OperationType, AbstractResponseHandler> handlers) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+        this.handlers = handlers;\n+        subHandler = (SubscribeResponseHandler) handlers.get(OperationType.SUBSCRIBE);\n+    }\n+\n+    public SubscribeResponseHandler getSubscribeResponseHandler() {\n+        return subHandler;\n+    }\n+\n+    public void removeTxn(long txnId) {\n+        txn2PubSubData.remove(txnId);\n+    }\n+\n+    public void addTxn(long txnId, PubSubData pubSubData) {\n+        txn2PubSubData.put(txnId, pubSubData);\n+    }\n+\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+        // If the Message is not a PubSubResponse, just send it upstream and let\n+        // something else handle it.\n+        if (!(e.getMessage() instanceof PubSubResponse)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+        // Retrieve the PubSubResponse from the Message that was sent by the\n+        // server.\n+        PubSubResponse response = (PubSubResponse) e.getMessage();\n+        logger.debug(\"Response received from host: {}, response: {}.\",\n+                     va(NetUtils.getHostFromChannel(ctx.getChannel()), response));\n+\n+        // Determine if this PubSubResponse is an ack response for a PubSub\n+        // Request or if it is a message being pushed to the client subscriber.\n+        if (response.hasMessage()) {\n+            // Subscribed messages being pushed to the client so handle/consume\n+            // it and return.\n+            if (null == subHandler) {\n+                logger.error(\"Received message from a non-subscription channel : {}\",\n+                             response);\n+            } else {\n+                subHandler.handleSubscribeMessage(response);\n+            }\n+            return;\n+        }\n+\n+        // Process Subscription Events\n+        if (response.hasResponseBody()) {\n+            ResponseBody resp = response.getResponseBody();\n+            // A special subscription event indicates the state of a subscriber\n+            if (resp.hasSubscriptionEvent()) {\n+                if (null == subHandler) {\n+                    logger.error(\"Received subscription event from a non-subscription channel : {}\",\n+                                 response); \n+                } else {\n+                    SubscriptionEventResponse eventResp = resp.getSubscriptionEvent();\n+                    logger.debug(\"Received subscription event {} for (topic:{}, subscriber:{}).\",\n+                                 va(eventResp.getEvent(), response.getTopic(),\n+                                    response.getSubscriberId()));\n+                    subHandler.handleSubscriptionEvent(response.getTopic(),\n+                                                       response.getSubscriberId(),\n+                                                       eventResp.getEvent());\n+                }\n+                return;\n+            }\n+        }\n+\n+        // Response is an ack to a prior PubSubRequest so first retrieve the\n+        // PubSub data for this txn.\n+        PubSubData pubSubData = txn2PubSubData.remove(response.getTxnId());\n+\n+        // Validate that the PubSub data for this txn is stored. If not, just\n+        // log an error message and return since we don't know how to handle\n+        // this.\n+        if (pubSubData == null) {\n+            logger.error(\"PubSub Data was not found for PubSubResponse: {}\", response);\n+            return;\n+        }\n+\n+        // Store the topic2Host mapping if this wasn't a server redirect. We'll\n+        // assume that if the server was able to have an open Channel connection\n+        // to the client, and responded with an ack message other than the\n+        // NOT_RESPONSIBLE_FOR_TOPIC one, it is the correct topic master.\n+        if (!response.getStatusCode().equals(StatusCode.NOT_RESPONSIBLE_FOR_TOPIC)) {\n+            // Retrieve the server host that we've connected to and store the\n+            // mapping from the topic to this host. For all other non-redirected\n+            // server statuses, we consider that as a successful connection to the\n+            // correct topic master.\n+            InetSocketAddress host = NetUtils.getHostFromChannel(ctx.getChannel());\n+            channelManager.storeTopic2HostMapping(pubSubData.topic, host);\n+        }\n+\n+        // Depending on the operation type, call the appropriate handler.\n+        logger.debug(\"Handling a {} response: {}, pubSubData: {}, host: {}.\",\n+                     va(pubSubData.operationType, response, pubSubData, ctx.getChannel()));\n+        AbstractResponseHandler respHandler = handlers.get(pubSubData.operationType);\n+        if (null == respHandler) {\n+            // The above are the only expected PubSubResponse messages received\n+            // from the server for the various client side requests made.\n+            logger.error(\"Response received from server is for an unhandled operation {}, txnId: {}.\",\n+                         va(pubSubData.operationType, response.getTxnId()));\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new UnexpectedConditionException(\"Can't find response handler for operation \"\n+                                                 + pubSubData.operationType));\n+            return;\n+        }\n+        respHandler.handleResponse(response, pubSubData, ctx.getChannel());\n+    }\n+\n+    public void checkTimeoutRequests() {\n+        long curTime = System.currentTimeMillis();\n+        long timeoutInterval = cfg.getServerAckResponseTimeout();\n+        for (PubSubData pubSubData : txn2PubSubData.values()) {\n+            checkTimeoutRequest(pubSubData, curTime, timeoutInterval);\n+        }\n+    }\n+\n+    private void checkTimeoutRequest(PubSubData pubSubData,\n+                                     long curTime, long timeoutInterval) {\n+        if (curTime > pubSubData.requestWriteTime + timeoutInterval) {\n+            // Current PubSubRequest has timed out so remove it from the\n+            // ResponseHandler's map and invoke the VoidCallback's\n+            // operationFailed method.\n+            logger.error(\"Current PubSubRequest has timed out for pubSubData: \" + pubSubData);\n+            txn2PubSubData.remove(pubSubData.txnId);\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new UncertainStateException(\"Server ack response never received so PubSubRequest has timed out!\"));\n+        }\n+    }\n+\n+    // Logic to deal with what happens when a Channel to a server host is\n+    // disconnected.\n+    @Override\n+    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        // If this channel was closed explicitly by the client code,\n+        // we do not need to do any of this logic. This could happen\n+        // for redundant Publish channels created or redirected subscribe\n+        // channels that are not used anymore or when we shutdown the\n+        // client and manually close all of the open channels.\n+        // Also don't do any of the disconnect logic if the client has stopped.\n+        if (channelClosedExplicitly || channelManager.isClosed()) {\n+            return;\n+        }\n+\n+        // Make sure the host retrieved is not null as there could be some weird\n+        // channel disconnect events happening during a client shutdown.\n+        // If it is, just return as there shouldn't be anything we need to do.\n+        InetSocketAddress host = NetUtils.getHostFromChannel(ctx.getChannel());\n+        if (host == null) {\n+            return;\n+        }\n+\n+        logger.info(\"Channel {} was disconnected to host {}.\",\n+                    va(ctx.getChannel(), host));\n+\n+        // If this Channel was used for Publish and Unsubscribe flows, just\n+        // remove it from the HewdigPublisher's host2Channel map. We will\n+        // re-establish a Channel connection to that server when the next\n+        // publish/unsubscribe request to a topic that the server owns occurs.\n+\n+        // Now determine what type of operation this channel was used for.\n+        if (null == subHandler) {\n+            channelManager.onNonSubscriptionChannelDisconnected(host, ctx.getChannel());\n+        } else {\n+            channelManager.onSubscriptionChannelDisconnected(host, ctx.getChannel());\n+        }\n+\n+        // Finally, all of the PubSubRequests that are still waiting for an ack\n+        // response from the server need to be removed and timed out. Invoke the\n+        // operationFailed callbacks on all of them. Use the\n+        // UncertainStateException since the server did receive the request but\n+        // we're not sure of the state of the request since the ack response was\n+        // never received.\n+        for (PubSubData pubSubData : txn2PubSubData.values()) {\n+            logger.debug(\"Channel disconnected so invoking the operationFailed callback for pubSubData: {}\",\n+                         pubSubData);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new UncertainStateException(\n+                                                     \"Server ack response never received before server connection disconnected!\"));\n+        }\n+        txn2PubSubData.clear();\n+    }\n+\n+    // Logic to deal with what happens when a Channel to a server host is\n+    // connected. This is needed if the client is using an SSL port to\n+    // communicate with the server. If so, we need to do the SSL handshake here\n+    // when the channel is first connected.\n+    @Override\n+    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        // No need to initiate the SSL handshake if we are closing this channel\n+        // explicitly or the client has been stopped.\n+        if (cfg.isSSLEnabled() && !channelClosedExplicitly && !channelManager.isClosed()) {\n+            logger.debug(\"Initiating the SSL handshake\");\n+            ctx.getPipeline().get(SslHandler.class).handshake();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {\n+        logger.error(\"Exception caught on client channel\", e.getCause());\n+        e.getChannel().close();\n+    }\n+\n+    public void closeExplicitly() {\n+        // TODO: BOOKKEEPER-350 : Handle consume buffering, etc here - in a different patch\n+        channelClosedExplicitly = true;\n+    }\n+}"},{"sha":"fd58747b87182b2df95e3a5d25ddfd609e3bb0a5","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","status":"added","additions":371,"deletions":0,"changes":371,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,371 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.jboss.netty.bootstrap.ClientBootstrap;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide a wrapper over netty channel for Hedwig operations.\n+ */\n+public class HChannelImpl implements HChannel {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HChannelImpl.class);\n+\n+    enum State {\n+        DISCONNECTED,\n+        CONNECTING,\n+        CONNECTED,\n+    };\n+\n+    InetSocketAddress host;\n+    final AbstractHChannelManager channelManager;\n+    final ClientChannelPipelineFactory pipelineFactory;\n+    volatile Channel channel;\n+    volatile State state;\n+\n+    // Indicates whether the channel is closed or not.\n+    volatile boolean closed = false;\n+    // Queue the pubsub requests when the channel is not connected.\n+    Queue<PubSubData> pendingOps = new ArrayDeque<PubSubData>();\n+\n+    /**\n+     * Create a un-established channel with provided target <code>host</code>.\n+     *\n+     * @param host\n+     *          Target host address.\n+     * @param channelManager\n+     *          Channel manager manages the channels.\n+     */\n+    protected HChannelImpl(InetSocketAddress host, AbstractHChannelManager channelManager) {\n+        this(host, channelManager, null);\n+    }\n+\n+    public HChannelImpl(InetSocketAddress host, AbstractHChannelManager channelManager,\n+                        ClientChannelPipelineFactory pipelineFactory) {\n+        this(host, null, channelManager, pipelineFactory);\n+        state = State.DISCONNECTED;\n+    }\n+\n+    /**\n+     * Create a <code>HChannel</code> with an established netty channel.\n+     *\n+     * @param host\n+     *          Target host address.\n+     * @param channel\n+     *          Established Netty channel.\n+     * @param channelManager\n+     *          Channel manager manages the channels.\n+     */\n+    public HChannelImpl(InetSocketAddress host, Channel channel,\n+                        AbstractHChannelManager channelManager,\n+                        ClientChannelPipelineFactory pipelineFactory) {\n+        this.host = host;\n+        this.channel = channel;\n+        this.channelManager = channelManager;\n+        this.pipelineFactory = pipelineFactory;\n+        state = State.CONNECTED;\n+    }\n+\n+    @Override\n+    public void submitOp(PubSubData pubSubData) {\n+        boolean doOpNow = false;\n+\n+        // common case without lock first\n+        if (null != channel && State.CONNECTED == state) {\n+            doOpNow = true;\n+        } else {\n+            synchronized (this) {\n+                // check channel & state again under lock\n+                if (null != channel && State.CONNECTED == state) {\n+                    doOpNow = true;\n+                } else {\n+                    // if reached here, channel is either null (first connection attempt),\n+                    // or the channel is disconnected. Connection attempt is still in progress,\n+                    // queue up this op. Op will be executed when connection attempt either\n+                    // fails or succeeds\n+                    pendingOps.add(pubSubData);\n+                }\n+            }\n+            if (!doOpNow) {\n+                // start connection attempt to server\n+                connect();\n+            }\n+        }\n+        if (doOpNow) {\n+            executeOpAfterConnected(pubSubData); \n+        }\n+    }\n+\n+    /**\n+     * Execute pub/sub operation after the underlying channel is connected.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Operation\n+     */\n+    private void executeOpAfterConnected(PubSubData pubSubData) {\n+        PubSubRequest.Builder reqBuilder =\n+            NetUtils.buildPubSubRequest(channelManager.nextTxnId(), pubSubData);\n+        writePubSubRequest(pubSubData, reqBuilder.build());\n+    }\n+\n+    @Override\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    private void writePubSubRequest(PubSubData pubSubData, PubSubRequest pubSubRequest) {\n+        if (closed || null == channel || State.CONNECTED != state) {\n+            retryOrFailOp(pubSubData);\n+            return;\n+        }\n+\n+        // Before we do the write, store this information into the\n+        // ResponseHandler so when the server responds, we know what\n+        // appropriate Callback Data to invoke for the given txn ID.\n+        try {\n+            getHChannelHandlerFromChannel(channel)\n+                .addTxn(pubSubData.txnId, pubSubData);\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {} when writing request.\"\n+                        + \" It might already disconnect.\", channel);\n+            return;\n+        }\n+\n+        // Finally, write the pub/sub request through the Channel.\n+        logger.debug(\"Writing a {} request to host: {} for pubSubData: {}.\",\n+                     va(pubSubData.operationType, host, pubSubData));\n+        ChannelFuture future = channel.write(pubSubRequest);\n+        future.addListener(new WriteCallback(pubSubData, channelManager));\n+    }\n+\n+    /**\n+     * Re-submit operation to default server or fail it.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Operation\n+     */\n+    protected void retryOrFailOp(PubSubData pubSubData) {\n+        // if we were not able to connect to the host, it could be down\n+        ByteString hostString = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(host));\n+        if (pubSubData.connectFailedServers != null &&\n+            pubSubData.connectFailedServers.contains(hostString)) {\n+            // We've already tried to connect to this host before so just\n+            // invoke the operationFailed callback.\n+            logger.error(\"Error connecting to host {} more than once so fail the request: {}\",\n+                         va(host, pubSubData));\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new CouldNotConnectException(\"Could not connect to host: \" + host));\n+        } else {\n+            logger.error(\"Retry to connect to default hub server again for pubSubData: {}\",\n+                         pubSubData);\n+            // Keep track of this current server that we failed to connect\n+            // to but retry the request on the default server host/VIP.\n+            if (pubSubData.connectFailedServers == null) {\n+                pubSubData.connectFailedServers = new LinkedList<ByteString>();\n+            }\n+            pubSubData.connectFailedServers.add(hostString);\n+            channelManager.submitOpToDefaultServer(pubSubData);\n+        }\n+    }\n+\n+    private void onChannelConnected(ChannelFuture future) {\n+        Queue<PubSubData> oldPendingOps;\n+        synchronized (this) {\n+            // if the channel is closed by client, do nothing\n+            if (closed) {\n+                future.getChannel().close();\n+                return;\n+            }\n+            state = State.CONNECTED;\n+            channel = future.getChannel();\n+            host = NetUtils.getHostFromChannel(channel);\n+            oldPendingOps = pendingOps;\n+            pendingOps = new ArrayDeque<PubSubData>();\n+        }\n+        for (PubSubData op : oldPendingOps) {\n+            executeOpAfterConnected(op);\n+        }\n+    }\n+\n+    private void onChannelConnectFailure() {\n+        Queue<PubSubData> oldPendingOps;\n+        synchronized (this) {\n+            state = State.DISCONNECTED;\n+            channel = null;\n+            oldPendingOps = pendingOps;\n+            pendingOps = new ArrayDeque<PubSubData>();\n+        }\n+        for (PubSubData op : oldPendingOps) {\n+            retryOrFailOp(op);\n+        }\n+    }\n+\n+    private void connect() {\n+        synchronized (this) {\n+            if (State.CONNECTING == state ||\n+                State.CONNECTED == state) {\n+                return;\n+            }\n+            state = State.CONNECTING;\n+        }\n+        // Start the connection attempt to the input server host.\n+        ChannelFuture future = connect(host, pipelineFactory);\n+        future.addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                // If the channel has been closed, there is no need to proceed with any\n+                // callback logic here.\n+                if (closed) {\n+                    future.getChannel().close();\n+                    return;\n+                }\n+\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error connecting to host {}.\", host);\n+                    future.getChannel().close();\n+\n+                    // if we were not able to connect to the host, it could be down.\n+                    onChannelConnectFailure();\n+                    return;\n+                }\n+                logger.debug(\"Connected to server {}.\", host);\n+                // Now that we have connected successfully to the server, execute all queueing\n+                // requests.\n+                onChannelConnected(future);\n+            }\n+\n+        });\n+    }\n+\n+    /**\n+     * This is a helper method to do the connect attempt to the server given the\n+     * inputted host/port. This can be used to connect to the default server\n+     * host/port which is the VIP. That will pick a server in the cluster at\n+     * random to connect to for the initial PubSub attempt (with redirect logic\n+     * being done at the server side). Additionally, this could be called after\n+     * the client makes an initial PubSub attempt at a server, and is redirected\n+     * to the one that is responsible for the topic. Once the connect to the\n+     * server is done, we will perform the corresponding PubSub write on that\n+     * channel.\n+     *\n+     * @param serverHost\n+     *            Input server host to connect to of type InetSocketAddress\n+     * @param pipelineFactory\n+     *            PipelineFactory to create response handler to handle responses from\n+     *            underlying channel.\n+     */\n+    protected ChannelFuture connect(InetSocketAddress serverHost,\n+                                    ClientChannelPipelineFactory pipelineFactory) {\n+        logger.debug(\"Connecting to host {} ...\", serverHost);\n+        // Set up the ClientBootStrap so we can create a new Channel connection\n+        // to the server.\n+        ClientBootstrap bootstrap = new ClientBootstrap(channelManager.getChannelFactory());\n+        bootstrap.setPipelineFactory(pipelineFactory);\n+        bootstrap.setOption(\"tcpNoDelay\", true);\n+        bootstrap.setOption(\"keepAlive\", true);\n+\n+        // Start the connection attempt to the input server host.\n+        return bootstrap.connect(serverHost);\n+    }\n+\n+    @Override\n+    public void close(boolean wait) {\n+        synchronized (this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        }\n+        if (null == channel) {\n+            return;\n+        }\n+        try {\n+            getHChannelHandlerFromChannel(channel).closeExplicitly();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No channel handler found for channel {} when closing it.\",\n+                        channel);\n+        }\n+        if (wait) {\n+            channel.close().awaitUninterruptibly();\n+        } else {\n+            channel.close();\n+        }\n+        channel = null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[HChannel: host - \").append(host)\n+          .append(\", channel - \").append(channel)\n+          .append(\", pending reqs - \").append(pendingOps.size())\n+          .append(\", closed - \").append(closed).append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void close() {\n+        close(false);\n+    }\n+\n+    /**\n+     * Helper static method to get the ResponseHandler instance from a Channel\n+     * via the ChannelPipeline it is associated with. The assumption is that the\n+     * last ChannelHandler tied to the ChannelPipeline is the ResponseHandler.\n+     *\n+     * @param channel\n+     *            Channel we are retrieving the ResponseHandler instance for\n+     * @return ResponseHandler Instance tied to the Channel's Pipeline\n+     */\n+    public static HChannelHandler getHChannelHandlerFromChannel(Channel channel)\n+    throws NoResponseHandlerException {\n+        if (null == channel) {\n+            throw new NoResponseHandlerException(\"Received a null value for the channel. Cannot retrieve the response handler\");\n+        }\n+\n+        HChannelHandler handler = (HChannelHandler) channel.getPipeline().getLast();\n+        if (null == handler) {\n+            throw new NoResponseHandlerException(\"Could not retrieve the response handler from the channel's pipeline.\");\n+        }\n+        return handler;\n+    }\n+\n+}"},{"sha":"a91bbf8dbb7bb64edbb884522c09f666959c2fe6","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.PublishResponseHandler;\n+import org.apache.hedwig.client.handlers.UnsubscribeResponseHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class NonSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public NonSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                 AbstractHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.PUBLISH,\n+                     new PublishResponseHandler(cfg, channelManager));\n+        handlers.put(OperationType.UNSUBSCRIBE,\n+                     new UnsubscribeResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"4774d4110869f78d886fa24ac5005e5229d07af4","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ResubscribeCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,108 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ResubscribeException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * This class is used when a Subscribe channel gets disconnected and we attempt\n+ * to resubmit subscribe requests existed in that channel. Once the resubscribe\n+ * the topic is completed, we need to restart delivery for that topic.\n+ */\n+class ResubscribeCallback implements Callback<ResponseBody> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(ResubscribeCallback.class);\n+\n+    // Private member variables\n+    private final TopicSubscriber origTopicSubscriber;\n+    private final PubSubData origSubData;\n+    private final AbstractHChannelManager channelManager;\n+    private final long retryWaitTime;\n+\n+    // Constructor\n+    ResubscribeCallback(TopicSubscriber origTopicSubscriber,\n+                        PubSubData origSubData,\n+                        AbstractHChannelManager channelManager,\n+                        long retryWaitTime) {\n+        this.origTopicSubscriber = origTopicSubscriber;\n+        this.origSubData = origSubData;\n+        this.channelManager = channelManager;\n+        this.retryWaitTime = retryWaitTime;\n+    }\n+\n+    @Override\n+    public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n+        if (logger.isDebugEnabled())\n+            logger.debug(\"Resubscribe succeeded for origSubData: \" + origSubData);\n+        // Now we want to restart delivery for the subscription channel only\n+        // if delivery was started at the time the original subscribe channel\n+        // was disconnected.\n+        try {\n+            channelManager.restartDelivery(origTopicSubscriber);\n+        } catch (ClientNotSubscribedException e) {\n+            // This exception should never be thrown here but just in case,\n+            // log an error and just keep retrying the subscribe request.\n+            logger.error(\"Subscribe was successful but error starting delivery for {} : {}\",\n+                         va(origTopicSubscriber, e.getMessage()));\n+            retrySubscribeRequest();\n+        } catch (AlreadyStartDeliveryException asde) {\n+            // should not reach here\n+        }\n+    }\n+\n+    @Override\n+    public void operationFailed(Object ctx, PubSubException exception) {\n+        if (exception instanceof ResubscribeException) {\n+            // it might be caused by closesub when resubscribing.\n+            // so we don't need to retry resubscribe again\n+            logger.warn(\"Failed to resubscribe {} : but it is caused by closesub when resubscribing. \"\n+                        + \"so we don't need to retry subscribe again.\", origSubData);\n+        }\n+        // If the resubscribe fails, just keep retrying the subscribe\n+        // request. There isn't a way to flag to the application layer that\n+        // a topic subscription has failed. So instead, we'll just keep\n+        // retrying in the background until success.\n+        logger.error(\"Resubscribe failed with error: \" + exception.getMessage());\n+        // we don't retry subscribe request is channel manager is closing\n+        // otherwise it might overflow the stack.\n+        if (!channelManager.isClosed()) {\n+            retrySubscribeRequest();\n+        }\n+    }\n+\n+    private void retrySubscribeRequest() {\n+        if (channelManager.isClosed()) {\n+            return;\n+        }\n+        origSubData.clearServersList();\n+        logger.debug(\"Resubmit subscribe request for {} in {} ms later.\",\n+                     va(origTopicSubscriber, retryWaitTime));\n+        channelManager.submitOpAfterDelay(origSubData, retryWaitTime);\n+    }\n+}"},{"sha":"26dd15308fe645afeeaf01d011be2a1f775bf080","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,111 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+\n+public class WriteCallback implements ChannelFutureListener {\n+\n+    private static Logger logger = LoggerFactory.getLogger(WriteCallback.class);\n+\n+    // Private member variables\n+    private PubSubData pubSubData;\n+    private final HChannelManager channelManager;\n+\n+    // Constructor\n+    public WriteCallback(PubSubData pubSubData,\n+                         HChannelManager channelManager) {\n+        super();\n+        this.pubSubData = pubSubData;\n+        this.channelManager = channelManager;\n+    }\n+\n+    public void operationComplete(ChannelFuture future) throws Exception {\n+        // If the client has stopped, there is no need to proceed\n+        // with any callback logic here.\n+        if (channelManager.isClosed()) {\n+            future.getChannel().close();\n+            return;\n+        }\n+\n+        // When the write operation to the server is done, we just need to check\n+        // if it was successful or not.\n+        InetSocketAddress host = NetUtils.getHostFromChannel(future.getChannel());\n+        if (!future.isSuccess()) {\n+            logger.error(\"Error writing on channel to host: {}\", host);\n+            // On a write failure for a PubSubRequest, we also want to remove\n+            // the saved txnId to PubSubData in the ResponseHandler. These\n+            // requests will not receive an ack response from the server\n+            // so there is no point storing that information there anymore.\n+            try {\n+                HChannelHandler channelHandler = \n+                    HChannelImpl.getHChannelHandlerFromChannel(future.getChannel());\n+                channelHandler.removeTxn(pubSubData.txnId);\n+                channelHandler.closeExplicitly();\n+            } catch (NoResponseHandlerException e) {\n+                // We just couldn't remove the transaction ID's mapping.\n+                // The handler was null, so this has been reset anyway.\n+                logger.warn(\"Could not find response handler to remove txnId mapping to pubsub data. Ignoring.\");\n+            }\n+\n+            future.getChannel().close();\n+\n+            // If we were not able to write on the channel to the server host,\n+            // the host could have died or something is wrong with the channel\n+            // connection where we can connect to the host, but not write to it.\n+            ByteString hostString = (host == null) ? null : ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(host));\n+            if (pubSubData.writeFailedServers != null && pubSubData.writeFailedServers.contains(hostString)) {\n+                // We've already tried to write to this server previously and\n+                // failed, so invoke the operationFailed callback.\n+                logger.error(\"Error writing to host more than once so just invoke the operationFailed callback!\");\n+                pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                        \"Error while writing message to server: \" + hostString));\n+            } else {\n+                logger.debug(\"Try to send the PubSubRequest again to the default server host/VIP for pubSubData: {}\",\n+                    pubSubData);\n+                // Keep track of this current server that we failed to write to\n+                // but retry the request on the default server host/VIP.\n+                if (pubSubData.writeFailedServers == null)\n+                    pubSubData.writeFailedServers = new LinkedList<ByteString>();\n+                pubSubData.writeFailedServers.add(hostString);\n+                channelManager.submitOpToDefaultServer(pubSubData);\n+            }\n+        } else {\n+            // Now that the write to the server is done, we have to wait for it\n+            // to respond. The ResponseHandler will take care of the ack\n+            // response from the server before we can determine if the async\n+            // PubSub call has really completed successfully or not.\n+            logger.debug(\"Successfully wrote to host: {} for pubSubData: {}\", host, pubSubData);\n+        }\n+    }\n+\n+}"},{"sha":"f28a6b27fd21ccf9fb12fd665761c4be2ee02138","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","status":"added","additions":319,"deletions":0,"changes":319,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+\n+/**\n+ * Multiplex HChannel Manager which establish a connection for multi subscriptions.\n+ */\n+public class MultiplexHChannelManager extends AbstractHChannelManager {\n+\n+    static final Logger logger = LoggerFactory.getLogger(MultiplexHChannelManager.class);\n+\n+    // Find which HChannel that a given TopicSubscriber used.\n+    protected final CleanupChannelMap<InetSocketAddress> subscriptionChannels;\n+\n+    // A index map for each topic subscriber is served by which subscription channel\n+    protected final CleanupChannelMap<TopicSubscriber> sub2Channels;\n+\n+    // Concurrent Map to store Message handler for each topic + sub id combination.\n+    // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n+    // user set when connection is recovered\n+    protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler\n+        = new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n+\n+    // PipelineFactory to create subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory subscriptionChannelPipelineFactory;\n+\n+    public MultiplexHChannelManager(ClientConfiguration cfg,\n+                                    ChannelFactory socketFactory) {\n+        super(cfg, socketFactory);\n+        subscriptionChannels = new CleanupChannelMap<InetSocketAddress>();\n+        sub2Channels = new CleanupChannelMap<TopicSubscriber>();\n+        subscriptionChannelPipelineFactory =\n+            new MultiplexSubscriptionChannelPipelineFactory(cfg, this);\n+    }\n+\n+    @Override\n+    protected ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory() {\n+        return subscriptionChannelPipelineFactory;\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(Channel channel) {\n+        // store the channel connected to target host for future usage\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        return storeSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(InetSocketAddress host) {\n+        HChannel newHChannel = new HChannelImpl(host, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        return storeSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel storeSubscriptionChannel(InetSocketAddress host,\n+                                              HChannel newHChannel) {\n+        // here, we guarantee there is only one channel used to communicate with target\n+        // host.\n+        return subscriptionChannels.addChannel(host, newHChannel);\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannel(InetSocketAddress host) {\n+        return subscriptionChannels.getChannel(host);\n+    }\n+\n+    protected HChannel getSubscriptionChannel(TopicSubscriber subscriber) {\n+        InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+        if (null == host) {\n+            // we don't know where is the owner of the topic\n+            return null;\n+        } else {\n+            return getSubscriptionChannel(host);\n+        }\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber subscriber) {\n+        InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+        if (null == host) {\n+            // we don't know where is the topic\n+            return null;\n+        } else {\n+            // we had know which server owned the topic\n+            HChannel channel = getSubscriptionChannel(host);\n+            if (null == channel) {\n+                // create a channel to connect to sepcified host\n+                channel = createAndStoreSubscriptionChannel(host);\n+            }\n+            return channel;\n+        }\n+    }\n+\n+    @Override\n+    protected void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                     Channel channel) {\n+        HChannel hChannel = subscriptionChannels.getChannel(host);\n+        if (null == hChannel) {\n+            return;\n+        }\n+        Channel underlyingChannel = hChannel.getChannel();\n+        if (null == underlyingChannel ||\n+            !underlyingChannel.equals(channel)) {\n+            return;\n+        }\n+        logger.info(\"Subscription Channel {} disconnected from {}.\",\n+                    va(channel, host));\n+        // remove existed channel\n+        if (subscriptionChannels.removeChannel(host, hChannel)) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel);\n+                channelHandler.getSubscribeResponseHandler()\n+                              .onChannelDisconnected(host, channel);\n+            } catch (NoResponseHandlerException nrhe) {\n+                logger.warn(\"No Channel Handler found for channel {} when it disconnected.\",\n+                            channel);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SubscribeResponseHandler getSubscribeResponseHandler(TopicSubscriber topicSubscriber) {\n+        HChannel hChannel = getSubscriptionChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            return null;\n+        }\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            return null;\n+        }\n+        try {\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            return channelHandler.getSubscribeResponseHandler();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {}, topic subscriber {}.\",\n+                        channel, topicSubscriber);\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, messageHandler, false);\n+    }\n+\n+    @Override\n+    protected void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, null, true);\n+    }\n+\n+    private void startDelivery(TopicSubscriber topicSubscriber,\n+                               MessageHandler messageHandler,\n+                               boolean restart)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        // Make sure we know about this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n+        if (restart) {\n+            // restart using existing msg handler \n+            messageHandler = existedMsgHandler;\n+        } else {\n+            // some has started delivery but not stop it\n+            if (null != existedMsgHandler) {\n+                throw new AlreadyStartDeliveryException(\"A message handler has been started for topic subscriber \" + topicSubscriber);\n+            }\n+            if (messageHandler != null) {\n+                if (null != topicSubscriber2MessageHandler.putIfAbsent(topicSubscriber, messageHandler)) {\n+                    throw new AlreadyStartDeliveryException(\"Someone is also starting delivery for topic subscriber \" + topicSubscriber);\n+                }\n+            }\n+        }\n+\n+        // tell subscribe response handler to start delivering messages for topicSubscriber\n+        subscribeResponseHandler.startDelivery(topicSubscriber, messageHandler);\n+    }\n+\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        // Make sure we know that this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        // tell subscribe response handler to stop delivering messages for a given topic subscriber\n+        topicSubscriber2MessageHandler.remove(topicSubscriber);\n+        subscribeResponseHandler.stopDelivery(topicSubscriber);\n+    }\n+                            \n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.warn(\"Trying to close a subscription when we don't have a subscription channel cached for {}\",\n+                        topicSubscriber);\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+        subscribeResponseHandler.asyncCloseSubscription(topicSubscriber, callback, context);\n+    }\n+\n+    @Override\n+    protected void checkTimeoutRequestsOnSubscriptionChannels() {\n+        // timeout task may be started before constructing subscriptionChannels\n+        if (null == subscriptionChannels) {\n+            return;\n+        }\n+        for (HChannel channel : subscriptionChannels.getChannels()) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                channelHandler.checkTimeoutRequests();\n+            } catch (NoResponseHandlerException nrhe) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void closeSubscriptionChannels() {\n+        subscriptionChannels.close();\n+    }\n+\n+    protected Either<Boolean, HChannel> storeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, PubSubData txn, HChannel channel) {\n+        boolean replaced = sub2Channels.replaceChannel(\n+            topicSubscriber, txn.getOriginalChannelForResubscribe(), channel);\n+        if (replaced) {\n+            return Either.of(replaced, channel);\n+        } else {\n+            return Either.of(replaced, null);\n+        }\n+    }\n+\n+    protected boolean removeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, HChannel channel) {\n+        return sub2Channels.removeChannel(topicSubscriber, channel);\n+    }\n+}"},{"sha":"ec111da1fa33b01fe0a1ed3cfda951899f2eb2c8","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,129 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.impl.AbstractSubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.impl.ActiveSubscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class MultiplexSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n+\n+    private static Logger logger =\n+        LoggerFactory.getLogger(MultiplexSubscribeResponseHandler.class);\n+\n+    // the underlying subscription channel\n+    volatile HChannel hChannel;\n+    private final MultiplexHChannelManager sChannelManager;\n+\n+    protected MultiplexSubscribeResponseHandler(ClientConfiguration cfg,\n+                                                HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        sChannelManager = (MultiplexHChannelManager) channelManager;\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        if (null == hChannel) {\n+            InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+            hChannel = sChannelManager.getSubscriptionChannel(host);\n+            if (null == hChannel ||\n+                !channel.equals(hChannel.getChannel())) {\n+                PubSubException pse =\n+                    new UnexpectedConditionException(\"Failed to get subscription channel of \" + host);\n+                pubSubData.getCallback().operationFailed(pubSubData.context, pse);\n+                return;\n+            }\n+        }\n+        super.handleResponse(response, pubSubData, channel);\n+    }\n+\n+    @Override\n+    protected Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel) {\n+        // Store the mapping for the TopicSubscriber to the Channel.\n+        // This is so we can control the starting and stopping of\n+        // message deliveries from the server on that Channel. Store\n+        // this only on a successful ack response from the server.\n+        Either<Boolean, HChannel> result =\n+            sChannelManager.storeSubscriptionChannel(ts, pubSubData, hChannel);\n+        if (result.left()) {\n+            return Either.of(StatusCode.SUCCESS, result.right());\n+        } else {\n+            StatusCode code;\n+            if (pubSubData.isResubscribeRequest()) {\n+                code = StatusCode.RESUBSCRIBE_EXCEPTION;\n+            } else {\n+                code = StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+            }\n+            return Either.of(code, null);\n+        }\n+    }\n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        final ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss || null == hChannel) {\n+            logger.debug(\"No subscription {} found when closing its subscription from {}.\",\n+                         va(topicSubscriber, hChannel));\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+        Callback<ResponseBody> closeCb = new Callback<ResponseBody>() {\n+            @Override\n+            public void operationFinished(Object ctx, ResponseBody respBody) {\n+                removeSubscription(topicSubscriber, ss);\n+                sChannelManager.removeSubscriptionChannel(topicSubscriber, hChannel);\n+                callback.operationFinished(context, null);\n+            }\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                callback.operationFailed(context, exception);\n+            }\n+        };\n+        PubSubData closeOp = new PubSubData(topicSubscriber.getTopic(), null,\n+                                            topicSubscriber.getSubscriberId(),\n+                                            OperationType.CLOSESUBSCRIPTION,\n+                                            null, closeCb, context);\n+        hChannel.submitOp(closeOp);\n+    }\n+\n+}"},{"sha":"c43108a90f140d7a4eb5ef9c6ecf46d4140b6608","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.CloseSubscriptionResponseHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class MultiplexSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public MultiplexSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                       MultiplexHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new MultiplexSubscribeResponseHandler(cfg, channelManager));\n+        handlers.put(OperationType.CLOSESUBSCRIPTION,\n+                     new CloseSubscriptionResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"36a6925361a7e3db804d74d772c58f6fb9d5f61f","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","status":"added","additions":358,"deletions":0,"changes":358,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,358 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.exceptions.PubSubException.TopicBusyException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * Simple HChannel Manager which establish a connection for each subscription.\n+ */\n+public class SimpleHChannelManager extends AbstractHChannelManager {\n+\n+    private static Logger logger = LoggerFactory.getLogger(SimpleHChannelManager.class);\n+\n+    // Concurrent Map to store the cached Channel connections on the client side\n+    // to a server host for a given Topic + SubscriberId combination. For each\n+    // TopicSubscriber, we want a unique Channel connection to the server for\n+    // it. We can also get the ResponseHandler tied to the Channel via the\n+    // Channel Pipeline.\n+    protected final CleanupChannelMap<TopicSubscriber> topicSubscriber2Channel;\n+\n+    // Concurrent Map to store Message handler for each topic + sub id combination.\n+    // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n+    // user set when connection is recovered\n+    protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler\n+        = new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n+\n+    // PipelineFactory to create subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory subscriptionChannelPipelineFactory;\n+\n+    public SimpleHChannelManager(ClientConfiguration cfg,\n+                                 ChannelFactory socketFactory) {\n+        super(cfg, socketFactory);\n+        topicSubscriber2Channel = new CleanupChannelMap<TopicSubscriber>();\n+        this.subscriptionChannelPipelineFactory =\n+            new SimpleSubscriptionChannelPipelineFactory(cfg, this);\n+    }\n+\n+    @Override\n+    public void submitOp(final PubSubData pubSubData) {\n+        /**\n+         * In the simple hchannel implementation that if a client closes a subscription\n+         * and tries to attach to it immediately, it could get a TOPIC_BUSY response. This\n+         * is because, a subscription is closed simply by closing the channel, and the hub\n+         * side may not have been notified of the channel disconnection event by the time\n+         * the new subscription request comes in. To solve this, retry up to 5 times.\n+         * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-513}\n+         */\n+        if (OperationType.SUBSCRIBE.equals(pubSubData.operationType)) {\n+            final Callback<ResponseBody> origCb = pubSubData.getCallback();\n+            final AtomicInteger retries = new AtomicInteger(5);\n+            final Callback<ResponseBody> wrapperCb\n+                = new Callback<ResponseBody>() {\n+                @Override\n+                public void operationFinished(Object ctx,\n+                                              ResponseBody resultOfOperation) {\n+                    origCb.operationFinished(ctx, resultOfOperation);\n+                }\n+\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    if (exception instanceof ServiceDownException\n+                        && exception.getCause() instanceof TopicBusyException\n+                        && retries.decrementAndGet() > 0) {\n+                        logger.warn(\"TOPIC_DOWN from server using simple channel scheme.\"\n+                                    + \"This could be due to the channel disconnection from a close\"\n+                                    + \" not having been triggered on the server side. Retrying\");\n+                        SimpleHChannelManager.super.submitOp(pubSubData);\n+                        return;\n+                    }\n+                    origCb.operationFailed(ctx, exception);\n+                }\n+            };\n+            pubSubData.setCallback(wrapperCb);\n+        }\n+        super.submitOp(pubSubData);\n+    }\n+\n+    @Override\n+    protected ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory() {\n+        return subscriptionChannelPipelineFactory;\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(Channel channel) {\n+        // for simple channel, we don't store subscription channel now\n+        // we store it until we received success response\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        return new HChannelImpl(host, channel, this,\n+                                getSubscriptionChannelPipelineFactory());\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(InetSocketAddress host) {\n+        // for simple channel, we don't store subscription channel now\n+        // we store it until we received success response\n+        return new HChannelImpl(host, this,\n+                                getSubscriptionChannelPipelineFactory());\n+    }\n+\n+    protected Either<Boolean, HChannel> storeSubscriptionChannel(\n+        TopicSubscriber topicSubscriber, PubSubData txn, Channel channel) {\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        boolean replaced = topicSubscriber2Channel.replaceChannel(\n+            topicSubscriber, txn.getOriginalChannelForResubscribe(), newHChannel);\n+        if (replaced) {\n+            return Either.of(replaced, newHChannel);\n+        } else {\n+            return Either.of(replaced, null);\n+        }\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannel(InetSocketAddress host) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber subscriber) {\n+        HChannel channel = topicSubscriber2Channel.getChannel(subscriber);\n+        if (null != channel) {\n+            // there is no channel established for this subscription\n+            return channel;\n+        } else {\n+            InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+            if (null == host) {\n+                return null;\n+            } else {\n+                channel = getSubscriptionChannel(host);\n+                if (null == channel) {\n+                    channel = createAndStoreSubscriptionChannel(host);\n+                }\n+                return channel;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                     Channel channel) {\n+        logger.info(\"Subscription Channel {} disconnected from {}.\",\n+                    va(channel, host));\n+        try {\n+            // get hchannel handler\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            channelHandler.getSubscribeResponseHandler()\n+                          .onChannelDisconnected(host, channel);\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {} when it disconnected.\",\n+                        channel);\n+        }\n+    }\n+\n+    @Override\n+    public SubscribeResponseHandler getSubscribeResponseHandler(TopicSubscriber topicSubscriber) {\n+        HChannel hChannel = topicSubscriber2Channel.getChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            return null;\n+        }\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            return null;\n+        }\n+        try {\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            return channelHandler.getSubscribeResponseHandler();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {}, topic subscriber {}.\",\n+                        channel, topicSubscriber);\n+            return null;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, messageHandler, false);\n+    }\n+\n+    @Override\n+    protected void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, null, true);\n+    }\n+\n+    private void startDelivery(TopicSubscriber topicSubscriber,\n+                               MessageHandler messageHandler, boolean restart)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        // Make sure we know about this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n+        if (restart) {\n+            // restart using existing msg handler \n+            messageHandler = existedMsgHandler;\n+        } else {\n+            // some has started delivery but not stop it\n+            if (null != existedMsgHandler) {\n+                throw new AlreadyStartDeliveryException(\"A message handler has been started for topic subscriber \" + topicSubscriber);\n+            }\n+            if (messageHandler != null) {\n+                if (null != topicSubscriber2MessageHandler.putIfAbsent(topicSubscriber, messageHandler)) {\n+                    throw new AlreadyStartDeliveryException(\"Someone is also starting delivery for topic subscriber \" + topicSubscriber);\n+                }\n+            }\n+        }\n+\n+        // tell subscribe response handler to start delivering messages for topicSubscriber\n+        subscribeResponseHandler.startDelivery(topicSubscriber, messageHandler);\n+    }\n+\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        // Make sure we know that this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        // tell subscribe response handler to stop delivering messages for a given topic subscriber\n+        topicSubscriber2MessageHandler.remove(topicSubscriber);\n+        subscribeResponseHandler.stopDelivery(topicSubscriber);\n+    }\n+                            \n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        HChannel hChannel = topicSubscriber2Channel.removeChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            logger.warn(\"Trying to close a subscription when we don't have a subscribe channel cached for {}\",\n+                        topicSubscriber);\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+\n+        try {\n+            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found when closing {}'s channel {}.\",\n+                        channel, topicSubscriber);\n+        }\n+        ChannelFuture future = channel.close();\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Failed to close the subscription channel for {}\",\n+                                 topicSubscriber);\n+                    callback.operationFailed(context, new ServiceDownException(\n+                        \"Failed to close the subscription channel for \" + topicSubscriber));\n+                } else {\n+                    callback.operationFinished(context, (ResponseBody)null);\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void checkTimeoutRequestsOnSubscriptionChannels() {\n+        // timeout task may be started before constructing topicSubscriber2Channel\n+        if (null == topicSubscriber2Channel) {\n+            return;\n+        }\n+        for (HChannel channel : topicSubscriber2Channel.getChannels()) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                channelHandler.checkTimeoutRequests();\n+            } catch (NoResponseHandlerException nrhe) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void closeSubscriptionChannels() {\n+        topicSubscriber2Channel.close();\n+    }\n+}"},{"sha":"7dd320ced43b6e28e54ca1ccd7d2d247cf04affe","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"added","additions":277,"deletions":0,"changes":277,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,277 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Set;\n+import java.util.Collections;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.AbstractSubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.impl.ActiveSubscriber;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.Either;\n+\n+public class SimpleSubscribeResponseHandler extends AbstractSubscribeResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(SimpleSubscribeResponseHandler.class);\n+\n+    /**\n+     * Simple Active Subscriber enabling client-side throttling.\n+     */\n+    static class SimpleActiveSubscriber extends ActiveSubscriber {\n+\n+        // Set to store all of the outstanding subscribed messages that are pending\n+        // to be consumed by the client app's MessageHandler. If this ever grows too\n+        // big (e.g. problem at the client end for message consumption), we can\n+        // throttle things by temporarily setting the Subscribe Netty Channel\n+        // to not be readable. When the Set has shrunk sufficiently, we can turn the\n+        // channel back on to read new messages.\n+        private final Set<Message> outstandingMsgSet;\n+\n+        public SimpleActiveSubscriber(ClientConfiguration cfg,\n+                                      AbstractHChannelManager channelManager,\n+                                      TopicSubscriber ts, PubSubData op,\n+                                      SubscriptionPreferences preferences,\n+                                      Channel channel,\n+                                      HChannel hChannel) {\n+            super(cfg, channelManager, ts, op, preferences, channel, hChannel);\n+            outstandingMsgSet = Collections.newSetFromMap(\n+                    new ConcurrentHashMap<Message, Boolean>(\n+                            cfg.getMaximumOutstandingMessages(), 1.0f));\n+        }\n+\n+        @Override\n+        protected void unsafeDeliverMessage(Message message) {\n+            // Add this \"pending to be consumed\" message to the outstandingMsgSet.\n+            outstandingMsgSet.add(message);\n+            // Check if we've exceeded the max size for the outstanding message set.\n+            if (outstandingMsgSet.size() >= cfg.getMaximumOutstandingMessages() &&\n+                channel.isReadable()) {\n+                // Too many outstanding messages so throttle it by setting the Netty\n+                // Channel to not be readable.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Too many outstanding messages ({}) so throttling the subscribe netty Channel\",\n+                                 outstandingMsgSet.size());\n+                }\n+                channel.setReadable(false);\n+            }\n+            super.unsafeDeliverMessage(message);\n+        }\n+\n+        @Override\n+        public synchronized void messageConsumed(Message message) {\n+            super.messageConsumed(message);\n+            // Remove this consumed message from the outstanding Message Set.\n+            outstandingMsgSet.remove(message);\n+            // Check if we throttled message consumption previously when the\n+            // outstanding message limit was reached. For now, only turn the\n+            // delivery back on if there are no more outstanding messages to\n+            // consume. We could make this a configurable parameter if needed.\n+            if (!channel.isReadable() && outstandingMsgSet.size() == 0) {\n+                if (logger.isDebugEnabled())\n+                    logger.debug(\"Message consumption has caught up so okay to turn off\"\n+                                 + \" throttling of messages on the subscribe channel for {}\",\n+                                 topicSubscriber);\n+                channel.setReadable(true);\n+            }\n+        }\n+\n+        @Override\n+        public synchronized void startDelivery(MessageHandler messageHandler)\n+        throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n+            super.startDelivery(messageHandler);\n+            // Now make the TopicSubscriber Channel readable (it is set to not be\n+            // readable when the initial subscription is done). Note that this is an\n+            // asynchronous call. If this fails (not likely), the futureListener\n+            // will just log an error message for now.\n+            ChannelFuture future = channel.setReadable(true);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                        logger.error(\"Unable to make subscriber Channel readable in startDelivery call for {}\",\n+                                     topicSubscriber);\n+                    }\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public synchronized void stopDelivery() {\n+            super.stopDelivery();\n+            // Now make the TopicSubscriber channel not-readable. This will buffer\n+            // up messages if any are sent from the server. Note that this is an\n+            // asynchronous call. If this fails (not likely), the futureListener\n+            // will just log an error message for now.\n+            ChannelFuture future = channel.setReadable(false);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                        logger.error(\"Unable to make subscriber Channel not readable in stopDelivery call for {}\",\n+                                     topicSubscriber);\n+                    }\n+                }\n+            });\n+        }\n+\n+    }\n+\n+    // Track which subscriber is alive in this response handler\n+    // Which is used for backward compat, since old version hub\n+    // server doesn't carry (topic, subscriberid) in each message.\n+    private volatile TopicSubscriber origTopicSubscriber;\n+    private volatile ActiveSubscriber origActiveSubscriber;\n+\n+    private SimpleHChannelManager sChannelManager;\n+\n+    protected SimpleSubscribeResponseHandler(ClientConfiguration cfg,\n+                                             HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        sChannelManager = (SimpleHChannelManager) channelManager;\n+    }\n+\n+    @Override\n+    protected ActiveSubscriber createActiveSubscriber(\n+        ClientConfiguration cfg, AbstractHChannelManager channelManager,\n+        TopicSubscriber ts, PubSubData op, SubscriptionPreferences preferences,\n+        Channel channel, HChannel hChannel) {\n+        return new SimpleActiveSubscriber(cfg, channelManager, ts, op, preferences, channel, hChannel);\n+    }\n+\n+    @Override\n+    protected synchronized ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n+        if (null == origTopicSubscriber || !origTopicSubscriber.equals(ts)) {\n+            return null;\n+        }\n+        return origActiveSubscriber;\n+    }\n+\n+    private synchronized ActiveSubscriber getActiveSubscriber() {\n+        return origActiveSubscriber;\n+    }\n+\n+    @Override\n+    public synchronized boolean hasSubscription(TopicSubscriber ts) {\n+        if (null == origTopicSubscriber) {\n+            return false;\n+        }\n+        return origTopicSubscriber.equals(ts);\n+    }\n+\n+    @Override\n+    protected synchronized boolean removeSubscription(TopicSubscriber ts, ActiveSubscriber ss) {\n+        if (null != origTopicSubscriber && !origTopicSubscriber.equals(ts)) {\n+            return false;\n+        }\n+        origTopicSubscriber = null;\n+        origActiveSubscriber = null;\n+        return super.removeSubscription(ts, ss);\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        // If this was not a successful response to the Subscribe request, we\n+        // won't be using the Netty Channel created so just close it.\n+        if (!response.getStatusCode().equals(StatusCode.SUCCESS)) {\n+            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n+            channel.close();\n+        }\n+        super.handleResponse(response, pubSubData, channel);\n+    }\n+\n+    @Override\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        Message message = response.getMessage();\n+        ActiveSubscriber ss = getActiveSubscriber();\n+        if (null == ss) {\n+            logger.error(\"No Subscriber is alive receiving its message {}.\",\n+                         MessageIdUtils.msgIdToReadableString(message.getMsgId()));\n+            return;\n+        }\n+        ss.handleMessage(message);\n+    }\n+\n+    @Override\n+    protected Either<StatusCode, HChannel> handleSuccessResponse(\n+        TopicSubscriber ts, PubSubData pubSubData, Channel channel) {\n+        // Store the mapping for the TopicSubscriber to the Channel.\n+        // This is so we can control the starting and stopping of\n+        // message deliveries from the server on that Channel. Store\n+        // this only on a successful ack response from the server.\n+        Either<Boolean, HChannel> result =\n+            sChannelManager.storeSubscriptionChannel(ts, pubSubData, channel);\n+        if (result.left()) {\n+            return Either.of(StatusCode.SUCCESS, result.right());\n+        } else {\n+            StatusCode code;\n+            if (pubSubData.isResubscribeRequest()) {\n+                code = StatusCode.RESUBSCRIBE_EXCEPTION;\n+            } else {\n+                code = StatusCode.CLIENT_ALREADY_SUBSCRIBED;\n+            }\n+            return Either.of(code, null);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void postHandleSuccessResponse(\n+        TopicSubscriber ts, ActiveSubscriber as) {\n+        origTopicSubscriber = ts;\n+        origActiveSubscriber = as;\n+    }\n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        // nothing to do just clear status\n+        // channel manager takes the responsibility to close the channel\n+        callback.operationFinished(context, (ResponseBody)null);\n+    }\n+\n+}"},{"sha":"4c9230923ac19fdefac6d2997014fd2db960d725","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.CloseSubscriptionResponseHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class SimpleSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public SimpleSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                    SimpleHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new SimpleSubscribeResponseHandler(cfg, channelManager));\n+        handlers.put(OperationType.CLOSESUBSCRIPTION,\n+                     new CloseSubscriptionResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"07236a5e816319e6cb1f3b63828bf3e23ac9e2a8","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A Netty based Hedwig client implementation.\n+ *\n+ * <h3>Components</h3>\n+ *\n+ * The netty based implementation contains following components:\n+ * <ul>\n+ *   <li>{@link HChannel}: A interface wrapper of netty {@link org.jboss.netty.channel.Channel}\n+ *       to submit hedwig's {@link org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest}s\n+ *       to target host.</li>\n+ *   <li>{@link HChanneHandler}: A wrapper of netty {@link org.jboss.netty.channel.ChannelHandler}\n+ *       to handle events of its underlying netty channel, such as responses received, channel\n+ *       disconnected, etc. A {@link HChannelHandler} is bound with a {@link HChannel}.</li>\n+ *   <li>{@link HChannelManager}: A manager manages all established {@link HChannel}s.\n+ *       It provides a clean interface for publisher/subscriber to send\n+ *       {@link org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest}s</li>\n+ * </ul>\n+ *\n+ * <h3>Main Flow</h3>\n+ *\n+ * <ul>\n+ *   <li>{@link HedwigPublisher}/{@link HedwigSubscriber} delegates {@link HChannelManager}\n+ *       to submit pub/sub requests.</li>\n+ *   <li>{@link HChannelManager} find the owner hubs, establish a {@link HChannel} to hub servers\n+ *       and send the requests to them.</li>\n+ *   <li>{@link HChannelHandler} dispatches responses to target\n+ *       {@link org.apache.hedwig.client.handlers.AbstractResponseHandler} to process.</li>\n+ *   <li>{@link HChannelHandler} detects an underlying netty {@link org.jboss.netty.channel.Channel}\n+ *       disconnected. It calles {@link HChannelManager} to clear cached {@link HChannel} that\n+ *       it bound with. For non-subscritpion channels, it would fail all pending requests;\n+ *       For subscription channels, it would fail all pending requests and retry to reconnect\n+ *       those successful subscriptions.</li>\n+ * </ul>\n+ *\n+ * <h3>HChannel</h3>\n+ *\n+ * Two kinds of {@link HChannel}s provided in current implementation. {@link HChannelImpl}\n+ * provides the ability to multiplex pub/sub requests in an underlying netty\n+ * {@link org.jboss.netty.channel.Channel}, while {@link DefaultServerChannel} provides the\n+ * ability to establish a netty channel {@link org.jboss.netty.channel.Channel} for a pub/sub\n+ * request. After the underlying netty channel is estabilished, it would be converted into\n+ * a {@link HChannelImpl} by {@link HChannelManager#submitOpThruChannel(pubSubData, channel)}.\n+ *\n+ * Although {@link HChannelImpl} provides multiplexing ability, it still could be used for\n+ * one-channel-per-subscription case, which just sent only one subscribe request thru the\n+ * underlying channel.\n+ *\n+ * <h3>HChannelHandler</h3>\n+ *\n+ * {@link HChannelHandler} is generic netty {@link org.jboss.netty.channel.ChannelHandler},\n+ * which handles events from the underlying channel. A <i>HChannelHandler</i> is bound with\n+ * a {@link HChannel} as channel pipeplien when the underlying channel is established. It\n+ * takes the responsibility of dispatching response to target response handler. For a\n+ * non-subscription channel, it just handles <b>PUBLISH</b> and <b>UNSUBSCRIBE</b> responses.\n+ * For a subscription channel, it handles <b>SUBSCRIBE</b> response. For consume requests,\n+ * we treated them in a fire-and-forget way, so they are not need to be handled by any response\n+ * handler.\n+ *\n+ * <h3>HChannelManager</h3>\n+ *\n+ * {@link HChannelManager} manages all outstanding connections to target hub servers for a client.\n+ * Since a subscription channel acts quite different from a non-subscription channel, the basic\n+ * implementation {@link AbstractHChannelManager} manages non-subscription channels and\n+ * subscription channels in different channel sets. Currently hedwig client provides\n+ * {@link SimpleHChannelManager} which manages subscription channels in one-channel-per-subscription\n+ * way. In future, if we want to multiplex multiple subscriptions in one channel, we just need\n+ * to provide an multiplexing version of {@link AbstractHChannelManager} which manages channels\n+ * in multiplexing way, and a multiplexing version of {@link org.apache.hedwig.client.handlers.SubscribeResponseHandler}\n+ * which handles multiple subscriptions in one channel.\n+ */\n+package org.apache.hedwig.client.netty;"},{"sha":"ee488ba56f882a3194753fa02de54dc2aaf2cf36","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslClientContextFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.ssl;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+\n+public class SslClientContextFactory extends SslContextFactory {\n+\n+    public SslClientContextFactory(ClientConfiguration cfg) {\n+        try {\n+            // Create the SSL context.\n+            ctx = SSLContext.getInstance(\"TLS\");\n+            ctx.init(null, getTrustManagers(), null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean isClient() {\n+        return true;\n+    }\n+\n+}"},{"sha":"33c5a53bd3afa6888ecb13690dd0967d0bf5e0a8","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/client/ssl/SslContextFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.ssl;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+public abstract class SslContextFactory {\n+\n+    protected SSLContext ctx;\n+\n+    public SSLContext getContext() {\n+        return ctx;\n+    }\n+\n+    protected abstract boolean isClient();\n+\n+    public SSLEngine getEngine() {\n+        SSLEngine engine = ctx.createSSLEngine();\n+        engine.setUseClientMode(isClient());\n+        return engine;\n+    }\n+\n+    protected TrustManager[] getTrustManagers() {\n+        return new TrustManager[] { new X509TrustManager() {\n+                // Always trust, even if invalid.\n+\n+                @Override\n+                public X509Certificate[] getAcceptedIssuers() {\n+                    return new X509Certificate[0];\n+                }\n+\n+                @Override\n+                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n+                    // Always trust.\n+                }\n+\n+                @Override\n+                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n+                    // Always trust.\n+                }\n+            }\n+        };\n+    }\n+\n+}"},{"sha":"57232ba375d47db6d15dece98d6cd50dc77f0cad","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.conf;\n+\n+import java.net.URL;\n+\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+\n+public abstract class AbstractConfiguration {\n+    protected CompositeConfiguration conf;\n+\n+    protected AbstractConfiguration() {\n+        conf = new CompositeConfiguration();\n+    }\n+\n+    /**\n+     * Return real configuration object\n+     *\n+     * @return configuration\n+     */\n+    public Configuration getConf() {\n+        return conf;\n+    }\n+\n+    /**\n+     * You can load configurations in precedence order. The first one takes\n+     * precedence over any loaded later.\n+     *\n+     * @param confURL\n+     */\n+    public void loadConf(URL confURL) throws ConfigurationException {\n+        Configuration loadedConf = new PropertiesConfiguration(confURL);\n+        conf.addConfiguration(loadedConf);\n+\n+    }\n+\n+    /**\n+     * Add configuration object.\n+     *\n+     * @param conf configuration object\n+     */\n+    public void addConf(Configuration otherConf) throws ConfigurationException {\n+        conf.addConfiguration(otherConf);\n+    }\n+}"},{"sha":"96ef0d97d9ed34287e33f534878e9b583848d412","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","status":"added","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ClientMessageFilter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,24 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.filter;\n+\n+/**\n+ * Message Filter running in client-side.\n+ */\n+public interface ClientMessageFilter extends MessageFilterBase {\n+}"},{"sha":"e654038b4498c85cd21b438053265aea58856ad0","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/MessageFilterBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.filter;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+\n+public interface MessageFilterBase {\n+\n+    /**\n+     * Set subscription preferences.\n+     *\n+     * <code>preferences</code> of the subscriber will be passed to message filter when\n+     * the message filter attaches to its subscription either in server-side or client-side.\n+     *\n+     * @param topic\n+     *          Topic Name.\n+     * @param subscriberId\n+     *          Subscriber Id.\n+     * @param preferences\n+     *          Subscription Preferences.\n+     * @return message filter\n+     */\n+    public MessageFilterBase setSubscriptionPreferences(ByteString topic, ByteString subscriberId,\n+                                                        SubscriptionPreferences preferences);\n+\n+    /**\n+     * Tests whether a particular message passes the filter or not\n+     *\n+     * @param message\n+     * @return\n+     */\n+    public boolean testMessage(Message message);\n+}"},{"sha":"6b473ad6e7642df67a472daa417f990fbcd6b770","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/PipelineFilter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.filter;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.LinkedList;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+\n+/**\n+ * A filter filters messages in pipeline.\n+ */\n+public class PipelineFilter extends LinkedList<ServerMessageFilter>\n+implements ServerMessageFilter {\n+\n+    @Override\n+    public ServerMessageFilter initialize(Configuration conf)\n+    throws ConfigurationException, IOException {\n+        for (ServerMessageFilter filter : this) {\n+            filter.initialize(conf);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitialize() {\n+        while (!isEmpty()) {\n+            ServerMessageFilter filter = removeLast();\n+            filter.uninitialize();\n+        }\n+    }\n+\n+    @Override\n+    public MessageFilterBase setSubscriptionPreferences(ByteString topic, ByteString subscriberId,\n+                                                        SubscriptionPreferences preferences) {\n+        for (ServerMessageFilter filter : this) {\n+            filter.setSubscriptionPreferences(topic, subscriberId, preferences);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean testMessage(Message message) {\n+        for (ServerMessageFilter filter : this) {\n+            if (!filter.testMessage(message)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}"},{"sha":"f4c22488675a95fc1d0a9b54f5f710fb7696860c","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/filter/ServerMessageFilter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.filter;\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.commons.configuration.ConfigurationException;\n+\n+/**\n+ * Message Filter running in server-side. Hub server uses reflection to\n+ * instantiate a message filter to filter messages.\n+ */\n+public interface ServerMessageFilter extends MessageFilterBase {\n+\n+    /**\n+     * Initialize the message filter.\n+     *\n+     * @param conf\n+     *          Configuration Object. An <i>MessageFilter</i> might read settings from it.\n+     * @return message filter\n+     * @throws IOException when failed to initialize message filter\n+     */\n+    public ServerMessageFilter initialize(Configuration conf)\n+    throws ConfigurationException, IOException;\n+\n+    /**\n+     * Uninitialize the message filter.\n+     */\n+    public void uninitialize();\n+\n+}"},{"sha":"78deef1de2f2ecb8853a5cf4b3ae7717d70b2b01","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Callback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+\n+/**\n+ * This class is used for callbacks for asynchronous operations\n+ *\n+ */\n+public interface Callback<T> {\n+\n+    /**\n+     * This method is called when the asynchronous operation finishes\n+     *\n+     * @param ctx\n+     * @param resultOfOperation\n+     */\n+    public abstract void operationFinished(Object ctx, T resultOfOperation);\n+\n+    /**\n+     * This method is called when the operation failed due to some reason. The\n+     * reason for failure is passed in.\n+     *\n+     * @param ctx\n+     *            The context for the callback\n+     * @param exception\n+     *            The reason for the failure of the scan\n+     */\n+    public abstract void operationFailed(Object ctx, PubSubException exception);\n+\n+}"},{"sha":"8f0fda8166f21c507e3a9088f1e1e0e4cf1f3cb4","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","status":"added","additions":183,"deletions":0,"changes":183,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/CallbackUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.CompositeException;\n+\n+public class CallbackUtils {\n+\n+    /**\n+     * A callback that waits for all of a number of events to fire. If any fail,\n+     * then fail the final callback with a composite exception.\n+     *\n+     * TODO: change this to use any Exception and make CompositeException\n+     * generic, not a PubSubException.\n+     *\n+     * @param expected\n+     *            Number of expected callbacks.\n+     * @param cb\n+     *            The final callback to call.\n+     * @param ctx\n+     * @param logger\n+     *            May be null.\n+     * @param successMsg\n+     *            If not null, then this is logged on success.\n+     * @param failureMsg\n+     *            If not null, then this is logged on failure.\n+     * @param eagerErrorHandler\n+     *            If not null, then this will be executed after the first\n+     *            failure (but before the final failure callback). Useful for\n+     *            releasing resources, etc. as soon as we know the composite\n+     *            operation is doomed.\n+     * @return the generated callback\n+     */\n+    public static Callback<Void> multiCallback(final int expected, final Callback<Void> cb, final Object ctx,\n+            final Logger logger, final String successMsg, final String failureMsg,\n+            Runnable eagerErrorHandler) {\n+        if (expected == 0) {\n+            cb.operationFinished(ctx, null);\n+            return null;\n+        } else {\n+            return new Callback<Void>() {\n+\n+                final AtomicInteger done = new AtomicInteger();\n+                final LinkedBlockingQueue<PubSubException> exceptions = new LinkedBlockingQueue<PubSubException>();\n+\n+                private void tick() {\n+                    if (done.incrementAndGet() == expected) {\n+                        if (exceptions.isEmpty()) {\n+                            cb.operationFinished(ctx, null);\n+                        } else {\n+                            cb.operationFailed(ctx, new CompositeException(exceptions));\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    if (logger != null && failureMsg != null)\n+                        logger.error(failureMsg, exception);\n+                    exceptions.add(exception);\n+                    tick();\n+                }\n+\n+                @Override\n+                public void operationFinished(Object ctx, Void resultOfOperation) {\n+                    if (logger != null && successMsg != null)\n+                        logger.info(successMsg);\n+                    tick();\n+                }\n+\n+            };\n+        }\n+    }\n+\n+    /**\n+     * A callback that waits for all of a number of events to fire. If any fail,\n+     * then fail the final callback with a composite exception.\n+     */\n+    public static Callback<Void> multiCallback(int expected, Callback<Void> cb, Object ctx) {\n+        return multiCallback(expected, cb, ctx, null, null, null, null);\n+    }\n+\n+    /**\n+     * A callback that waits for all of a number of events to fire. If any fail,\n+     * then fail the final callback with a composite exception.\n+     */\n+    public static Callback<Void> multinCallback(int expected, Callback<Void> cb, Object ctx, Runnable eagerErrorHandler) {\n+        return multiCallback(expected, cb, ctx, null, null, null, eagerErrorHandler);\n+    }\n+\n+    private static Callback<Void> nop = new Callback<Void>() {\n+\n+        @Override\n+        public void operationFailed(Object ctx, PubSubException exception) {\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, Void resultOfOperation) {\n+        }\n+\n+    };\n+\n+    /**\n+     * A do-nothing callback.\n+     */\n+    public static Callback<Void> nop() {\n+        return nop;\n+    }\n+\n+    /**\n+     * Logs what happened before continuing the callback chain.\n+     */\n+    public static <T> Callback<T> logger(final Logger logger, final String successMsg,\n+                                         final String failureMsg, final Callback<T> cont) {\n+        return new Callback<T>() {\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                logger.error(failureMsg, exception);\n+                if (cont != null)\n+                    cont.operationFailed(ctx, exception);\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, T resultOfOperation) {\n+                logger.info(successMsg);\n+                if (cont != null)\n+                    cont.operationFinished(ctx, resultOfOperation);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Logs what happened (no continuation).\n+     */\n+    public static Callback<Void> logger(Logger logger, String successMsg, String failureMsg) {\n+        return logger(logger, successMsg, failureMsg, nop());\n+    }\n+\n+    /**\n+     * Return a Callback<Void> that just calls the given Callback cb with the\n+     * bound result.\n+     */\n+    public static <T> Callback<Void> curry(final Callback<T> cb, final T result) {\n+        return new Callback<Void>() {\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                cb.operationFailed(ctx, exception);\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, Void resultOfOperation) {\n+                cb.operationFinished(ctx, result);\n+            }\n+\n+        };\n+    }\n+\n+}"},{"sha":"8f5f1cae9c5788524b1fb1bb57922f63a652737a","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/ConcurrencyUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CyclicBarrier;\n+\n+public class ConcurrencyUtils {\n+\n+    public static <T, U extends T, V extends BlockingQueue<T>> void put(V queue, U value) {\n+        try {\n+            queue.put(value);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public static <T> T take(BlockingQueue<T> queue) {\n+        try {\n+            return queue.take();\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public static void await(CyclicBarrier barrier) {\n+        try {\n+            barrier.await();\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+}"},{"sha":"b8ae82ffbb99899a109396cb19b747d1e1652092","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Either.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+public class Either<T, U> {\n+\n+    private T x;\n+    private U y;\n+\n+    private Either(T x, U y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public static <T, U> Either<T, U> of(T x, U y) {\n+        return new Either<T, U>(x, y);\n+    }\n+\n+    public static <T, U> Either<T, U> left(T x) {\n+        return new Either<T, U>(x, null);\n+    }\n+\n+    public static <T, U> Either<T, U> right(U y) {\n+        return new Either<T, U>(null, y);\n+    }\n+\n+    public T left() {\n+        return x;\n+    }\n+\n+    public U right() {\n+        return y;\n+    }\n+\n+}"},{"sha":"ad79b468154c54d4171b68c54877eca4b2148592","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/FileUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,98 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FileUtils {\n+\n+    static DirDeleterThred dirDeleterThread;\n+    static Logger log = LoggerFactory.getLogger(FileUtils.class);\n+\n+    static {\n+        dirDeleterThread = new DirDeleterThred();\n+        Runtime.getRuntime().addShutdownHook(dirDeleterThread);\n+    }\n+\n+    public static File createTempDirectory(String prefix) throws IOException {\n+        return createTempDirectory(prefix, null);\n+    }\n+\n+    public static File createTempDirectory(String prefix, String suffix) throws IOException {\n+        File tempDir = File.createTempFile(prefix, suffix);\n+        if (!tempDir.delete()) {\n+            throw new IOException(\"Could not delete temp file: \" + tempDir.getAbsolutePath());\n+        }\n+\n+        if (!tempDir.mkdir()) {\n+            throw new IOException(\"Could not create temp directory: \" + tempDir.getAbsolutePath());\n+        }\n+\n+        dirDeleterThread.addDirToDelete(tempDir);\n+        return tempDir;\n+\n+    }\n+\n+    static class DirDeleterThred extends Thread {\n+        List<File> dirsToDelete = new LinkedList<File>();\n+\n+        public synchronized void addDirToDelete(File dir) {\n+            dirsToDelete.add(dir);\n+        }\n+\n+        @Override\n+        public void run() {\n+            synchronized (this) {\n+                for (File dir : dirsToDelete) {\n+                    deleteDirectory(dir);\n+                }\n+            }\n+        }\n+\n+        protected void deleteDirectory(File dir) {\n+            if (dir.isFile()) {\n+                if (!dir.delete()) {\n+                    log.error(\"Could not delete \" + dir.getAbsolutePath());\n+                }\n+                return;\n+            }\n+\n+            File[] files = dir.listFiles();\n+            if (files == null) {\n+                return;\n+            }\n+\n+            for (File f : files) {\n+                deleteDirectory(f);\n+            }\n+\n+            if (!dir.delete()) {\n+                log.error(\"Could not delete directory: \" + dir.getAbsolutePath());\n+            }\n+\n+        }\n+\n+    }\n+\n+}"},{"sha":"8bfdadaa97d0d22154906af16a9aefa47b375530","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * This is a data wrapper class that is basically an InetSocketAddress with one\n+ * extra piece of information for the SSL port (optional). This is used by\n+ * Hedwig so we can encapsulate both regular and SSL port information in one\n+ * data structure. Hedwig hub servers can be configured to listen on the\n+ * standard regular port and additionally on an optional SSL port. The String\n+ * representation of a HedwigSocketAddress is: <hostname>:<port>:<SSL\n+ * port(optional)>\n+ */\n+public class HedwigSocketAddress {\n+\n+    // Member fields that make up this class.\n+    private final String hostname;\n+    private final int port;\n+    private final int sslPort;\n+\n+    private final InetSocketAddress socketAddress;\n+    private final InetSocketAddress sslSocketAddress;\n+\n+    // Constants used by this class.\n+    public static final String COLON = \":\";\n+    private static final int NO_SSL_PORT = -1;\n+\n+    // Constructor that takes in both a regular and SSL port.\n+    public HedwigSocketAddress(String hostname, int port, int sslPort) {\n+        this.hostname = hostname;\n+        this.port = port;\n+        this.sslPort = sslPort;\n+        socketAddress = new InetSocketAddress(hostname, port);\n+        if (sslPort != NO_SSL_PORT)\n+            sslSocketAddress = new InetSocketAddress(hostname, sslPort);\n+        else\n+            sslSocketAddress = null;\n+    }\n+\n+    // Constructor that only takes in a regular port.\n+    public HedwigSocketAddress(String hostname, int port) {\n+        this(hostname, port, NO_SSL_PORT);\n+    }\n+\n+    // Constructor from a String \"serialized\" version of this class.\n+    public HedwigSocketAddress(String addr) {\n+        String[] parts = addr.split(COLON);\n+        this.hostname = parts[0];\n+        this.port = Integer.parseInt(parts[1]);\n+        if (parts.length > 2)\n+            this.sslPort = Integer.parseInt(parts[2]);\n+        else\n+            this.sslPort = NO_SSL_PORT;\n+        socketAddress = new InetSocketAddress(hostname, port);\n+        if (sslPort != NO_SSL_PORT)\n+            sslSocketAddress = new InetSocketAddress(hostname, sslPort);\n+        else\n+            sslSocketAddress = null;\n+    }\n+\n+    // Public getters\n+    public String getHostname() {\n+        return hostname;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public int getSSLPort() {\n+        return sslPort;\n+    }\n+\n+    // Method to return an InetSocketAddress for the regular port.\n+    public InetSocketAddress getSocketAddress() {\n+        return socketAddress;\n+    }\n+\n+    // Method to return an InetSocketAddress for the SSL port.\n+    // Note that if no SSL port (or an invalid value) was passed\n+    // during object creation, this call will throw an IllegalArgumentException\n+    // (runtime exception).\n+    public InetSocketAddress getSSLSocketAddress() {\n+        return sslSocketAddress;\n+    }\n+\n+    // Method to determine if this object instance is SSL enabled or not\n+    // (contains a valid SSL port).\n+    public boolean isSSLEnabled() {\n+        return sslPort != NO_SSL_PORT;\n+    }\n+\n+    // Return the String \"serialized\" version of this object.\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(hostname).append(COLON).append(port).append(COLON).append(sslPort);\n+        return sb.toString();\n+    }\n+\n+    // Implement an equals method comparing two HedwigSocketAddress objects.\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof HedwigSocketAddress))\n+            return false;\n+        HedwigSocketAddress that = (HedwigSocketAddress) obj;\n+        return (this.hostname.equals(that.hostname) && (this.port == that.port) && (this.sslPort == that.sslPort));\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (this.hostname + this.port + this.sslPort).hashCode();\n+    }\n+\n+    // Static helper method to return the string representation for an\n+    // InetSocketAddress. The HedwigClient can only operate in SSL or non-SSL\n+    // mode. So the server hosts it connects to will just be an\n+    // InetSocketAddress instead of a HedwigSocketAddress. This utility method\n+    // can be used so we can store these server hosts as strings (ByteStrings)\n+    // in various places (e.g. list of server hosts we've connected to\n+    // or wrote to unsuccessfully).\n+    public static String sockAddrStr(InetSocketAddress addr) {\n+        return addr.getAddress().getHostAddress() + \":\" + addr.getPort();\n+    }\n+\n+}"},{"sha":"6a347823f2c73f85c4efce37ca48864c434fbf17","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Option.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,43 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+public class Option<T> {\n+\n+    private T x;\n+\n+    public static <T> Option<T> of(T x) {\n+        return new Option<T>(x);\n+    }\n+\n+    public static <T> Option<T> of() {\n+        return new Option<T>();\n+    }\n+\n+    public Option() {\n+    }\n+\n+    public Option(T x) {\n+        this.x = x;\n+    }\n+\n+    public T get() {\n+        return x;\n+    }\n+\n+}"},{"sha":"f0582b5e0210c4a05ee4c6ec65dc6c33d8377cd0","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/Pair.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+public class Pair<T, U> {\n+\n+    private T x;\n+    private U y;\n+\n+    public Pair(T x, U y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public static <T, U> Pair<T, U> of(T x, U y) {\n+        return new Pair<T, U>(x, y);\n+    }\n+\n+    public T first() {\n+        return x;\n+    }\n+\n+    public U second() {\n+        return y;\n+    }\n+\n+}"},{"sha":"269286caf9057204a4f9431843461812e60cbb8d","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PathUtils {\n+\n+    /** Generate all prefixes for a path. \"/a/b/c\" -> [\"/a\",\"/a/b\",\"/a/b/c\"] */\n+    public static List<String> prefixes(String path) {\n+        List<String> prefixes = new ArrayList<String>();\n+        StringBuilder prefix = new StringBuilder();\n+        for (String comp : path.split(\"/+\")) {\n+            // Skip the first (empty) path component.\n+            if (!comp.equals(\"\")) {\n+                prefix.append(\"/\").append(comp);\n+                prefixes.add(prefix.toString());\n+            }\n+        }\n+        return prefixes;\n+    }\n+\n+    /** Return true iff prefix is a prefix of path. */\n+    public static boolean isPrefix(String prefix, String path) {\n+        String[] as = prefix.split(\"/+\"), bs = path.split(\"/+\");\n+        if (as.length > bs.length)\n+            return false;\n+        for (int i = 0; i < as.length; i++)\n+            if (!as[i].equals(bs[i]))\n+                return false;\n+        return true;\n+    }\n+\n+    /** Like File.getParent but always uses the / separator. */\n+    public static String parent(String path) {\n+        return new File(path).getParent().replace(\"\\\\\", \"/\");\n+    }\n+\n+}"},{"sha":"508519665fe147db074b3302c6cf45a018aa79e0","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/SubscriptionListener.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+\n+/**\n+ * This class is used for subscriber to listen on subscription event.\n+ */\n+public interface SubscriptionListener {\n+\n+    /**\n+     * Process an event from a subscription.\n+     * <p>\n+     * NOTE: It would be better to not run blocking operations in a\n+     *       listener implementation.\n+     * </p>\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param event\n+     *          Event tell what happened to the subscription.\n+     */\n+    public void processEvent(ByteString topic, ByteString subscriberId,\n+                             SubscriptionEvent event);\n+}"},{"sha":"b8d22dac7943dee562e9a8eb6469659dc31493e4","filename":"branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,26 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+public class VarArgs {\n+\n+    public static Object[] va(Object...args) {\n+        return args;\n+    }\n+\n+}"},{"sha":"53e99b36ecc3f815a4b8ae31d94f9e038161d203","filename":"branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestFileUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.io.File;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class TestFileUtils {\n+\n+    @Test(timeout=60000)\n+    public void testCreateTmpDirectory() throws Exception {\n+        String prefix = \"abc\";\n+        String suffix = \"def\";\n+        File dir = FileUtils.createTempDirectory(prefix, suffix);\n+        assertTrue(dir.isDirectory());\n+        assertTrue(dir.getName().startsWith(prefix));\n+        assertTrue(dir.getName().endsWith(suffix));\n+        FileUtils.dirDeleterThread.start();\n+        FileUtils.dirDeleterThread.join();\n+        assertFalse(dir.exists());\n+    }\n+\n+}"},{"sha":"b6bb78a5ae44b5ccadc2bf229928d6ad4fa5956b","filename":"branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestHedwigSocketAddress.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class TestHedwigSocketAddress {\n+\n+    // Common values used by tests\n+    private String hostname = \"localhost\";\n+    private int port = 4080;\n+    private int sslPort = 9876;\n+    private int invalidPort = -9999;\n+    private String COLON = \":\";\n+\n+    @Test(timeout=60000)\n+    public void testCreateWithSSLPort() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port, sslPort);\n+        assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n+        assertTrue(addr.getSSLSocketAddress().equals(new InetSocketAddress(hostname, sslPort)));\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testCreateWithNoSSLPort() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port);\n+        assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n+        assertTrue(addr.getSSLSocketAddress() == null);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testCreateFromStringWithSSLPort() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname+COLON+port+COLON+sslPort);\n+        assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n+        assertTrue(addr.getSSLSocketAddress().equals(new InetSocketAddress(hostname, sslPort)));\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testCreateFromStringWithNoSSLPort() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname+COLON+port);\n+        assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname, port)));\n+        assertTrue(addr.getSSLSocketAddress() == null);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testCreateWithInvalidRegularPort() throws Exception {\n+        boolean success = false;\n+        try {\n+            new HedwigSocketAddress(hostname+COLON+invalidPort);\n+        }\n+        catch (IllegalArgumentException e) {\n+            success = true;\n+        }\n+        assertTrue(success);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testCreateWithInvalidSSLPort() throws Exception {\n+        boolean success = false;\n+        try {\n+            new HedwigSocketAddress(hostname, port, invalidPort);\n+        }\n+        catch (IllegalArgumentException e) {\n+            success = true;\n+        }\n+        assertTrue(success);\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testToStringConversion() throws Exception {\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port, sslPort);\n+        HedwigSocketAddress addr2 = new HedwigSocketAddress(addr.toString());\n+        assertTrue(addr.getSocketAddress().equals(addr2.getSocketAddress()));\n+        assertTrue(addr.getSSLSocketAddress().equals(addr2.getSSLSocketAddress()));\n+        addr.toString().equals(addr2.toString());\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testIsSSLEnabledFlag() throws Exception {\n+        HedwigSocketAddress sslAddr = new HedwigSocketAddress(hostname, port, sslPort);\n+        assertTrue(sslAddr.isSSLEnabled());\n+        HedwigSocketAddress addr = new HedwigSocketAddress(hostname, port);\n+        assertFalse(addr.isSSLEnabled());\n+    }\n+\n+}"},{"sha":"a596841eecd44f82c0b237d1b1205a06aa59d451","filename":"branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-client/src/test/java/org/apache/hedwig/util/TestPathUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class TestPathUtils {\n+\n+    @Test(timeout=60000)\n+    public void testPrefixes() {\n+        assertEquals(Arrays.asList(new String[] { \"/a\", \"/a/b\", \"/a/b/c\" }), PathUtils.prefixes(\"/a/b/c\"));\n+        assertEquals(Arrays.asList(new String[] { \"/a\", \"/a/b\", \"/a/b/c\" }), PathUtils.prefixes(\"///a///b///c\"));\n+\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testIsPrefix() {\n+        String[] paths = new String[] { \"/\", \"/a\", \"/a/b\" };\n+        for (int i = 0; i < paths.length; i++) {\n+            for (int j = 0; j <= i; j++) {\n+                assertTrue(PathUtils.isPrefix(paths[j], paths[i]));\n+                assertTrue(PathUtils.isPrefix(paths[j], paths[i] + \"/\"));\n+                assertTrue(PathUtils.isPrefix(paths[j] + \"/\", paths[i]));\n+                assertTrue(PathUtils.isPrefix(paths[j] + \"/\", paths[i] + \"/\"));\n+            }\n+            for (int j = i + 1; j < paths.length; j++) {\n+                assertFalse(PathUtils.isPrefix(paths[j], paths[i]));\n+                assertFalse(PathUtils.isPrefix(paths[j], paths[i] + \"/\"));\n+                assertFalse(PathUtils.isPrefix(paths[j] + \"/\", paths[i]));\n+                assertFalse(PathUtils.isPrefix(paths[j] + \"/\", paths[i] + \"/\"));\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"f4093f891c0d5fd7648ce9a300dcd97efa51a794","filename":"branch-4.3/hedwig-protocol/pom.xml","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/pom.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,116 @@\n+<?xml version=\"1.0\"?>\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <parent>\n+    <groupId>org.apache.bookkeeper</groupId>\n+    <artifactId>bookkeeper</artifactId>\n+    <version>4.3.0</version>\n+  </parent>\n+  <artifactId>hedwig-protocol</artifactId>\n+  <packaging>jar</packaging>\n+  <name>hedwig-protocol</name>\n+  <url>http://maven.apache.org</url>\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.google.protobuf</groupId>\n+      <artifactId>protobuf-java</artifactId>\n+      <version>${protobuf.version}</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-log4j12</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n+  </dependencies>\n+  <repositories>\n+  </repositories>\n+  <build>\n+    <defaultGoal>install</defaultGoal>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-assembly-plugin</artifactId>\n+        <version>2.2.1</version>\n+        <configuration>\n+\t  <skipAssembly>true</skipAssembly>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+\t<groupId>org.apache.rat</groupId>\n+\t<artifactId>apache-rat-plugin</artifactId>\n+\t<version>0.7</version>\n+\t<configuration>\n+\t  <excludes>\n+\t    <!-- exclude generated file //-->\n+\t    <exclude>**/PubSubProtocol.java</exclude>\n+\t  </excludes>\n+\t</configuration>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.codehaus.mojo</groupId>\n+        <artifactId>findbugs-maven-plugin</artifactId>\n+        <configuration>\n+          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+  <profiles>\n+    <profile>\n+      <id>protobuf</id>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <artifactId>maven-antrun-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <phase>generate-sources</phase>\n+                <id>default-cli</id>\n+                <configuration>\n+                  <target>\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/main/java\" />\n+                      <arg value=\"src/main/protobuf/PubSubProtocol.proto\" />\n+                    </exec>\n+                  </target>\n+                </configuration>\n+                <goals>\n+                  <goal>run</goal>\n+                </goals>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n+  </profiles>\n+</project>"},{"sha":"2e8dc0909ae31d579f61c57aa2b05e65ffd72d4b","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","status":"added","additions":254,"deletions":0,"changes":254,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/exceptions/PubSubException.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,254 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.exceptions;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+\n+@SuppressWarnings(\"serial\")\n+public abstract class PubSubException extends Exception {\n+    protected StatusCode code;\n+\n+    protected PubSubException(StatusCode code, String msg) {\n+        super(msg);\n+        this.code = code;\n+    }\n+\n+    protected PubSubException(StatusCode code, Throwable t) {\n+        super(t);\n+        this.code = code;\n+    }\n+\n+    protected PubSubException(StatusCode code, String msg, Throwable t) {\n+        super(msg, t);\n+        this.code = code;\n+    }\n+\n+    public static PubSubException create(StatusCode code, String msg) {\n+        if (code == StatusCode.CLIENT_ALREADY_SUBSCRIBED) {\n+            return new ClientAlreadySubscribedException(msg);\n+        } else if (code == StatusCode.CLIENT_NOT_SUBSCRIBED) {\n+            return new ClientNotSubscribedException(msg);\n+        } else if (code == StatusCode.MALFORMED_REQUEST) {\n+            return new MalformedRequestException(msg);\n+        } else if (code == StatusCode.NO_SUCH_TOPIC) {\n+            return new NoSuchTopicException(msg);\n+        } else if (code == StatusCode.NOT_RESPONSIBLE_FOR_TOPIC) {\n+            return new ServerNotResponsibleForTopicException(msg);\n+        } else if (code == StatusCode.SERVICE_DOWN) {\n+            return new ServiceDownException(msg);\n+        } else if (code == StatusCode.COULD_NOT_CONNECT) {\n+            return new CouldNotConnectException(msg);\n+        } else if (code == StatusCode.TOPIC_BUSY) {\n+            return new TopicBusyException(msg);\n+        } else if (code == StatusCode.BAD_VERSION) {\n+            return new BadVersionException(msg);\n+        } else if (code == StatusCode.NO_TOPIC_PERSISTENCE_INFO) {\n+            return new NoTopicPersistenceInfoException(msg);\n+        } else if (code == StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS) {\n+            return new TopicPersistenceInfoExistsException(msg);\n+        } else if (code == StatusCode.NO_SUBSCRIPTION_STATE) {\n+            return new NoSubscriptionStateException(msg);\n+        } else if (code == StatusCode.SUBSCRIPTION_STATE_EXISTS) {\n+            return new SubscriptionStateExistsException(msg);\n+        } else if (code == StatusCode.NO_TOPIC_OWNER_INFO) {\n+            return new NoTopicOwnerInfoException(msg);\n+        } else if (code == StatusCode.TOPIC_OWNER_INFO_EXISTS) {\n+            return new TopicOwnerInfoExistsException(msg);\n+        } else if (code == StatusCode.INVALID_MESSAGE_FILTER) {\n+            return new InvalidMessageFilterException(msg);\n+        } else if (code == StatusCode.RESUBSCRIBE_EXCEPTION) {\n+            return new ResubscribeException(msg);\n+        }\n+        /*\n+         * Insert new ones here\n+         */\n+        else if (code == StatusCode.UNCERTAIN_STATE) {\n+            return new UncertainStateException(msg);\n+        }\n+        // Finally the catch all exception (for unexpected error conditions)\n+        else {\n+            return new UnexpectedConditionException(\"Unknow status code:\" + code.getNumber() + \", msg: \" + msg);\n+        }\n+    }\n+\n+    public StatusCode getCode() {\n+        return code;\n+    }\n+\n+    public static class ClientAlreadySubscribedException extends PubSubException {\n+        public ClientAlreadySubscribedException(String msg) {\n+            super(StatusCode.CLIENT_ALREADY_SUBSCRIBED, msg);\n+        }\n+    }\n+\n+    public static class ClientNotSubscribedException extends PubSubException {\n+        public ClientNotSubscribedException(String msg) {\n+            super(StatusCode.CLIENT_NOT_SUBSCRIBED, msg);\n+        }\n+    }\n+\n+    public static class ResubscribeException extends PubSubException {\n+        public ResubscribeException(String msg) {\n+            super(StatusCode.RESUBSCRIBE_EXCEPTION, msg);\n+        }\n+    }\n+\n+    public static class MalformedRequestException extends PubSubException {\n+        public MalformedRequestException(String msg) {\n+            super(StatusCode.MALFORMED_REQUEST, msg);\n+        }\n+    }\n+\n+    public static class NoSuchTopicException extends PubSubException {\n+        public NoSuchTopicException(String msg) {\n+            super(StatusCode.NO_SUCH_TOPIC, msg);\n+        }\n+    }\n+\n+    public static class ServerNotResponsibleForTopicException extends PubSubException {\n+        // Note the exception message serves as the name of the responsible host\n+        public ServerNotResponsibleForTopicException(String responsibleHost) {\n+            super(StatusCode.NOT_RESPONSIBLE_FOR_TOPIC, responsibleHost);\n+        }\n+    }\n+\n+    public static class TopicBusyException extends PubSubException {\n+        public TopicBusyException(String msg) {\n+            super(StatusCode.TOPIC_BUSY, msg);\n+        }\n+    }\n+\n+    public static class ServiceDownException extends PubSubException {\n+        public ServiceDownException(String msg) {\n+            super(StatusCode.SERVICE_DOWN, msg);\n+        }\n+\n+        public ServiceDownException(Exception e) {\n+            super(StatusCode.SERVICE_DOWN, e);\n+        }\n+\n+        public ServiceDownException(String msg, Throwable t) {\n+            super(StatusCode.SERVICE_DOWN, msg, t);\n+        }\n+    }\n+\n+    public static class CouldNotConnectException extends PubSubException {\n+        public CouldNotConnectException(String msg) {\n+            super(StatusCode.COULD_NOT_CONNECT, msg);\n+        }\n+    }\n+\n+    public static class BadVersionException extends PubSubException {\n+        public BadVersionException(String msg) {\n+            super(StatusCode.BAD_VERSION, msg);\n+        }\n+    }\n+\n+    public static class NoTopicPersistenceInfoException extends PubSubException {\n+        public NoTopicPersistenceInfoException(String msg) {\n+            super(StatusCode.NO_TOPIC_PERSISTENCE_INFO, msg);\n+        }\n+    }\n+\n+    public static class TopicPersistenceInfoExistsException extends PubSubException {\n+        public TopicPersistenceInfoExistsException(String msg) {\n+            super(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS, msg);\n+        }\n+    }\n+\n+    public static class NoSubscriptionStateException extends PubSubException {\n+        public NoSubscriptionStateException(String msg) {\n+            super(StatusCode.NO_SUBSCRIPTION_STATE, msg);\n+        }\n+    }\n+\n+    public static class SubscriptionStateExistsException extends PubSubException {\n+        public SubscriptionStateExistsException(String msg) {\n+            super(StatusCode.SUBSCRIPTION_STATE_EXISTS, msg);\n+        }\n+    }\n+\n+    public static class NoTopicOwnerInfoException extends PubSubException {\n+        public NoTopicOwnerInfoException(String msg) {\n+            super(StatusCode.NO_TOPIC_OWNER_INFO, msg);\n+        }\n+    }\n+\n+    public static class TopicOwnerInfoExistsException extends PubSubException {\n+        public TopicOwnerInfoExistsException(String msg) {\n+            super(StatusCode.TOPIC_OWNER_INFO_EXISTS, msg);\n+        }\n+    }\n+\n+    public static class InvalidMessageFilterException extends PubSubException {\n+        public InvalidMessageFilterException(String msg) {\n+            super(StatusCode.INVALID_MESSAGE_FILTER, msg);\n+        }\n+\n+        public InvalidMessageFilterException(String msg, Throwable t) {\n+            super(StatusCode.INVALID_MESSAGE_FILTER, msg, t);\n+        }\n+    }\n+\n+    public static class UncertainStateException extends PubSubException {\n+        public UncertainStateException(String msg) {\n+            super(StatusCode.UNCERTAIN_STATE, msg);\n+        }\n+    }\n+\n+    // The catch all exception (for unexpected error conditions)\n+    public static class UnexpectedConditionException extends PubSubException {\n+        public UnexpectedConditionException(String msg) {\n+            super(StatusCode.UNEXPECTED_CONDITION, msg);\n+        }\n+        public UnexpectedConditionException(String msg, Throwable t) {\n+            super(StatusCode.UNEXPECTED_CONDITION, msg, t);\n+        }\n+    }\n+\n+    // The composite exception (for concurrent operations).\n+    public static class CompositeException extends PubSubException {\n+        private final Collection<PubSubException> exceptions;\n+        public CompositeException(Collection<PubSubException> exceptions) {\n+            super(StatusCode.COMPOSITE, compositeMessage(exceptions));\n+            this.exceptions = exceptions;\n+        }\n+\n+        public Collection<PubSubException> getExceptions() {\n+            return exceptions;\n+        }\n+\n+        /** Merges the message fields of the given Exceptions into a one line string. */\n+        private static String compositeMessage(Collection<PubSubException> exceptions) {\n+            StringBuilder builder = new StringBuilder(\"Composite exception: [\");\n+            Iterator<PubSubException> iter = exceptions.iterator();\n+            if (iter.hasNext())\n+                builder.append(iter.next().getMessage());\n+            while (iter.hasNext())\n+                builder.append(\" :: \").append(iter.next().getMessage());\n+            return builder.append(\"]\").toString();\n+        }\n+    }\n+\n+    public static class ClientNotSubscribedRuntimeException extends RuntimeException {\n+    }\n+\n+}"},{"sha":"4bba8cc849c1e10354c7e022f94b23e6a2e88d4f","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"added","additions":16883,"deletions":0,"changes":16883,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"898e8b12f65b705a987cb75d82231d8a923b44c5","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MapUtils.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MapUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MapUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MapUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.protoextensions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class MapUtils {\n+\n+    static final Logger logger = LoggerFactory.getLogger(MapUtils.class);\n+\n+    public static String toString(PubSubProtocol.Map map) {\n+        StringBuilder sb = new StringBuilder();\n+        int numEntries = map.getEntriesCount();\n+        for (int i=0; i<numEntries; i++) {\n+            PubSubProtocol.Map.Entry entry = map.getEntries(i);\n+            String key = entry.getKey();\n+            ByteString value = entry.getValue();\n+            sb.append(key).append('=').append(value.toStringUtf8());\n+            if (i != (numEntries - 1)) {\n+                sb.append(',');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static Map<String, ByteString> buildMap(PubSubProtocol.Map protoMap) {\n+        Map<String, ByteString> javaMap = new HashMap<String, ByteString>();\n+\n+        int numEntries = protoMap.getEntriesCount();\n+        for (int i=0; i<numEntries; i++) {\n+            PubSubProtocol.Map.Entry entry = protoMap.getEntries(i);\n+            String key = entry.getKey();\n+            if (javaMap.containsKey(key)) {\n+                ByteString preValue = javaMap.get(key);\n+                logger.warn(\"Key \" + key + \" has already been defined as value : \" + preValue.toStringUtf8());\n+            } else {\n+                javaMap.put(key, entry.getValue());\n+            }\n+        }\n+        return javaMap;\n+    }\n+\n+    public static PubSubProtocol.Map.Builder buildMapBuilder(Map<String, ByteString> javaMap) {\n+        PubSubProtocol.Map.Builder mapBuilder = PubSubProtocol.Map.newBuilder();\n+\n+        for (Map.Entry<String, ByteString> entry : javaMap.entrySet()) {\n+            mapBuilder.addEntries(PubSubProtocol.Map.Entry.newBuilder().setKey(entry.getKey())\n+                                                .setValue(entry.getValue()));\n+        }\n+        return mapBuilder;\n+    }\n+}"},{"sha":"9ceec26e1cdda6b5c876d8f05e37ef52031f5a4f","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/MessageIdUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,153 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.protoextensions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.RegionSpecificSeqId;\n+\n+public class MessageIdUtils {\n+\n+    public static String msgIdToReadableString(MessageSeqId seqId) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"local:\");\n+        sb.append(seqId.getLocalComponent());\n+\n+        String separator = \";\";\n+        for (RegionSpecificSeqId regionId : seqId.getRemoteComponentsList()) {\n+            sb.append(separator);\n+            sb.append(regionId.getRegion().toStringUtf8());\n+            sb.append(':');\n+            sb.append(regionId.getSeqId());\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static Map<ByteString, RegionSpecificSeqId> inMapForm(MessageSeqId msi) {\n+        Map<ByteString, RegionSpecificSeqId> map = new HashMap<ByteString, RegionSpecificSeqId>();\n+\n+        for (RegionSpecificSeqId lmsid : msi.getRemoteComponentsList()) {\n+            map.put(lmsid.getRegion(), lmsid);\n+        }\n+\n+        return map;\n+    }\n+\n+    public static boolean areEqual(MessageSeqId m1, MessageSeqId m2) {\n+\n+        if (m1.getLocalComponent() != m2.getLocalComponent()) {\n+            return false;\n+        }\n+\n+        if (m1.getRemoteComponentsCount() != m2.getRemoteComponentsCount()) {\n+            return false;\n+        }\n+\n+        Map<ByteString, RegionSpecificSeqId> m2map = inMapForm(m2);\n+\n+        for (RegionSpecificSeqId lmsid1 : m1.getRemoteComponentsList()) {\n+            RegionSpecificSeqId lmsid2 = m2map.get(lmsid1.getRegion());\n+            if (lmsid2 == null) {\n+                return false;\n+            }\n+            if (lmsid1.getSeqId() != lmsid2.getSeqId()) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+\n+    }\n+\n+    public static Message mergeLocalSeqId(Message.Builder messageBuilder, long localSeqId) {\n+        MessageSeqId.Builder msidBuilder = MessageSeqId.newBuilder(messageBuilder.getMsgId());\n+        msidBuilder.setLocalComponent(localSeqId);\n+        messageBuilder.setMsgId(msidBuilder);\n+        return messageBuilder.build();\n+    }\n+\n+    public static Message mergeLocalSeqId(Message orginalMessage, long localSeqId) {\n+        return mergeLocalSeqId(Message.newBuilder(orginalMessage), localSeqId);\n+    }\n+\n+    /**\n+     * Compares two seq numbers represented as lists of longs.\n+     *\n+     * @param l1\n+     * @param l2\n+     * @return 1 if the l1 is greater, 0 if they are equal, -1 if l2 is greater\n+     * @throws UnexpectedConditionException\n+     *             If the lists are of unequal length\n+     */\n+    public static int compare(List<Long> l1, List<Long> l2) throws UnexpectedConditionException {\n+        if (l1.size() != l2.size()) {\n+            throw new UnexpectedConditionException(\"Seq-ids being compared have different sizes: \" + l1.size()\n+                                                   + \" and \" + l2.size());\n+        }\n+\n+        for (int i = 0; i < l1.size(); i++) {\n+            long v1 = l1.get(i);\n+            long v2 = l2.get(i);\n+\n+            if (v1 == v2) {\n+                continue;\n+            }\n+\n+            return v1 > v2 ? 1 : -1;\n+        }\n+\n+        // All components equal\n+        return 0;\n+    }\n+\n+    /**\n+     * Returns the element-wise vector maximum of the two vectors id1 and id2,\n+     * if we imagine them to be sparse representations of vectors.\n+     */\n+    public static void takeRegionMaximum(MessageSeqId.Builder newIdBuilder, MessageSeqId id1, MessageSeqId id2) {\n+        Map<ByteString, RegionSpecificSeqId> id2Map = MessageIdUtils.inMapForm(id2);\n+\n+        for (RegionSpecificSeqId rrsid1 : id1.getRemoteComponentsList()) {\n+            ByteString region = rrsid1.getRegion();\n+\n+            RegionSpecificSeqId rssid2 = id2Map.get(region);\n+\n+            if (rssid2 == null) {\n+                newIdBuilder.addRemoteComponents(rrsid1);\n+                continue;\n+            }\n+\n+            newIdBuilder.addRemoteComponents((rrsid1.getSeqId() > rssid2.getSeqId()) ? rrsid1 : rssid2);\n+\n+            // remove from map\n+            id2Map.remove(region);\n+        }\n+\n+        // now take the remaining components in the map and add them\n+        for (RegionSpecificSeqId rssid2 : id2Map.values()) {\n+            newIdBuilder.addRemoteComponents(rssid2);\n+        }\n+\n+    }\n+}"},{"sha":"5a9cdf78f10ab893e547c206b555855d121e2e6c","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,68 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.protoextensions;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse;\n+\n+public class PubSubResponseUtils {\n+\n+    /**\n+     * Change here if bumping up the version number that the server sends back\n+     */\n+    public final static ProtocolVersion serverVersion = ProtocolVersion.VERSION_ONE;\n+\n+    static PubSubResponse.Builder getBasicBuilder(StatusCode status) {\n+        return PubSubResponse.newBuilder().setProtocolVersion(serverVersion).setStatusCode(status);\n+    }\n+\n+    public static PubSubResponse getSuccessResponse(long txnId) {\n+        return getBasicBuilder(StatusCode.SUCCESS).setTxnId(txnId).build();\n+    }\n+\n+    public static PubSubResponse getSuccessResponse(long txnId, ResponseBody respBody) {\n+        return getBasicBuilder(StatusCode.SUCCESS).setTxnId(txnId)\n+               .setResponseBody(respBody).build();\n+    }\n+\n+    public static PubSubResponse getResponseForException(PubSubException e, long txnId) {\n+        return getBasicBuilder(e.getCode()).setStatusMsg(e.getMessage()).setTxnId(txnId).build();\n+    }\n+\n+    public static PubSubResponse getResponseForSubscriptionEvent(ByteString topic,\n+                                                                 ByteString subscriberId,\n+                                                                 SubscriptionEvent event) {\n+        SubscriptionEventResponse.Builder eventBuilder =\n+            SubscriptionEventResponse.newBuilder().setEvent(event);\n+        ResponseBody.Builder respBuilder =\n+            ResponseBody.newBuilder().setSubscriptionEvent(eventBuilder);\n+        PubSubResponse response = PubSubResponse.newBuilder()\n+                                  .setProtocolVersion(ProtocolVersion.VERSION_ONE)\n+                                  .setStatusCode(StatusCode.SUCCESS).setTxnId(0)\n+                                  .setTopic(topic).setSubscriberId(subscriberId)\n+                                  .setResponseBody(respBuilder).build();\n+        return response;\n+    }\n+}"},{"sha":"e195ace85d9605717798fdcc8aeddb1d3c238917","filename":"branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/SubscriptionStateUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,100 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.protoextensions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SubscriptionStateUtils {\n+\n+    static final Logger logger = LoggerFactory.getLogger(SubscriptionStateUtils.class);\n+\n+    // For now, to differentiate hub subscribers from local ones, the\n+    // subscriberId will be prepended with a hard-coded prefix. Local\n+    // subscribers will validate that the subscriberId used cannot start with\n+    // this prefix. This is only used internally by the hub subscribers.\n+    public static final String HUB_SUBSCRIBER_PREFIX = \"__\";\n+\n+    public static SubscriptionData parseSubscriptionData(byte[] data)\n+    throws InvalidProtocolBufferException {\n+        try {\n+            return SubscriptionData.parseFrom(data);\n+        } catch (InvalidProtocolBufferException ex) {\n+            logger.info(\"Failed to parse data as SubscriptionData. Fall backward to parse it as SubscriptionState for backward compatability.\");\n+            // backward compability\n+            SubscriptionState state = SubscriptionState.parseFrom(data);\n+            return SubscriptionData.newBuilder().setState(state).build();\n+        }\n+    }\n+\n+    public static String toString(SubscriptionData data) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data.hasState()) {\n+            sb.append(\"State : { \").append(toString(data.getState())).append(\" };\");\n+        }\n+        if (data.hasPreferences()) {\n+            sb.append(\"Preferences : { \").append(toString(data.getPreferences())).append(\" };\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static String toString(SubscriptionState state) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"consumeSeqId: \" + MessageIdUtils.msgIdToReadableString(state.getMsgId()));\n+        return sb.toString();\n+    }\n+\n+    public static String toString(SubscriptionPreferences preferences) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"System Preferences : [\");\n+        if (preferences.hasMessageBound()) {\n+            sb.append(\"(messageBound=\").append(preferences.getMessageBound())\n+              .append(\")\");\n+        }\n+        sb.append(\"]\");\n+        if (preferences.hasOptions()) {\n+            sb.append(\", Customized Preferences : [\");\n+            sb.append(MapUtils.toString(preferences.getOptions()));\n+            sb.append(\"]\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static boolean isHubSubscriber(ByteString subscriberId) {\n+        return subscriberId.toStringUtf8().startsWith(HUB_SUBSCRIBER_PREFIX);\n+    }\n+\n+    public static Map<String, ByteString> buildUserOptions(SubscriptionPreferences preferences) {\n+        if (preferences.hasOptions()) {\n+            return MapUtils.buildMap(preferences.getOptions());\n+        } else {\n+            return new HashMap<String, ByteString>();\n+        }\n+    }\n+\n+}"},{"sha":"c31f0a6986d0a7c93ceecf249f461c0d115fcd70","filename":"branch-4.3/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"added","additions":313,"deletions":0,"changes":313,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,313 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+option java_package = \"org.apache.hedwig.protocol\";\n+option optimize_for = SPEED;\n+package Hedwig; \n+\n+enum ProtocolVersion{\n+    VERSION_ONE = 1;\n+}\n+\n+// common structure to store header or properties\n+message Map {\n+    message Entry {\n+        optional string key  = 1;\n+        optional bytes value = 2;\n+    }\n+    repeated Entry entries = 1;\n+}\n+\n+// message header\n+message MessageHeader {\n+    // user customized fields used for message filter\n+    optional Map properties = 1;\n+    // following are system properties in message header\n+    optional string messageType = 2;\n+}\n+\n+/*\n+ * this is the structure that will be serialized\n+ */\n+message Message {\n+    required bytes body = 1;\n+    optional bytes srcRegion = 2;\n+    optional MessageSeqId msgId = 3;\n+    // message header\n+    optional MessageHeader header = 4;\n+}\n+\n+message RegionSpecificSeqId {\n+    required bytes region = 1;\n+    required uint64 seqId = 2;\n+}\n+    \n+message MessageSeqId{\n+    optional uint64 localComponent = 1;\n+    repeated RegionSpecificSeqId remoteComponents = 2;    \n+}\n+\n+enum OperationType{\n+    PUBLISH = 0;\n+    SUBSCRIBE = 1;\n+    CONSUME = 2;\n+    UNSUBSCRIBE = 3;\n+    \n+    //the following two are only used for the hedwig proxy\n+    START_DELIVERY = 4;\n+    STOP_DELIVERY = 5;\n+    // end for requests only used for hedwig proxy\n+\n+    CLOSESUBSCRIPTION = 6;\n+}\n+\n+/* A PubSubRequest is just a union of the various request types, with\n+ * an enum telling us which type it is. The same can also be done through \n+ * extensions. We need one request type that we will deserialize into on \n+ * the server side.\n+ */\n+message PubSubRequest{\n+    \n+    required ProtocolVersion protocolVersion = 1;\n+    required OperationType type = 2;\n+    repeated bytes triedServers = 3;\n+    required uint64 txnId = 4;\n+    optional bool shouldClaim = 5;\n+    required bytes topic = 6;\n+    //any authentication stuff and other general stuff here\n+    \n+    \n+    /* one entry for each type of request */\n+    optional PublishRequest publishRequest = 52; \n+    optional SubscribeRequest subscribeRequest = 53;\n+    optional ConsumeRequest consumeRequest = 54;\n+    optional UnsubscribeRequest unsubscribeRequest = 55;\n+    optional StopDeliveryRequest stopDeliveryRequest = 56;\n+    optional StartDeliveryRequest startDeliveryRequest = 57;\n+    optional CloseSubscriptionRequest closeSubscriptionRequest = 58;\n+}\n+\n+\n+\n+message PublishRequest{\n+    required Message msg = 2;\n+}\n+\n+// record all preferences for a subscription,\n+// would be serialized to be stored in meta store\n+message SubscriptionPreferences {\n+    // user customized subscription options\n+    optional Map options = 1;\n+\n+    ///\n+    /// system defined options\n+    ///\n+\n+    // message bound\n+    optional uint32 messageBound = 2;\n+    // server-side message filter\n+    optional string messageFilter = 3;\n+    // message window size, this is the maximum number of messages \n+    // which will be delivered without being consumed\n+    optional uint32 messageWindowSize = 4;\n+}\n+\n+message SubscribeRequest{\n+    required bytes subscriberId = 2;\n+\n+    enum CreateOrAttach{\n+        CREATE = 0;\n+        ATTACH = 1;\n+        CREATE_OR_ATTACH = 2;\n+    };\n+    optional CreateOrAttach createOrAttach = 3 [default = CREATE_OR_ATTACH];\n+\n+    // wait for cross-regional subscriptions to be established before returning\n+    optional bool synchronous = 4 [default = false];\n+    // @Deprecated. set message bound in SubscriptionPreferences\n+    optional uint32 messageBound = 5;\n+\n+    // subscription options\n+    optional SubscriptionPreferences preferences = 6;\n+\n+    // force attach subscription which would kill existed channel\n+    // this option doesn't need to be persisted\n+    optional bool forceAttach = 7 [default = false];\n+}\n+\n+// used in client only\n+// options are stored in SubscriptionPreferences structure\n+message SubscriptionOptions {\n+    // force attach subscription which would kill existed channel\n+    // this option doesn't need to be persisted\n+    optional bool forceAttach = 1 [default = false];\n+    optional SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n+    optional uint32 messageBound = 3 [default = 0];\n+    // user customized subscription options\n+    optional Map options = 4;\n+    // server-side message filter\n+    optional string messageFilter = 5;\n+    // message window size, this is the maximum number of messages \n+    // which will be delivered without being consumed\n+    optional uint32 messageWindowSize = 6;\n+    // enable resubscribe\n+    optional bool enableResubscribe = 7 [default = true];\n+}\n+\n+message ConsumeRequest{\n+    required bytes subscriberId = 2;    \n+    required MessageSeqId msgId = 3;\n+    //the msgId is cumulative: all messages up to this id are marked as consumed\n+}\n+\n+message UnsubscribeRequest{\n+    required bytes subscriberId = 2;\n+}\n+\n+message CloseSubscriptionRequest {\n+    required bytes subscriberId = 2;\n+}\n+\n+message StopDeliveryRequest{\n+    required bytes subscriberId = 2;\n+}\n+\n+message StartDeliveryRequest{\n+    required bytes subscriberId = 2;\n+}\n+\n+// Identify an event happened for a subscription\n+enum SubscriptionEvent {\n+    // topic has changed ownership (hub server down or topic released)\n+    TOPIC_MOVED = 1;\n+    // subscription is force closed by other subscribers\n+    SUBSCRIPTION_FORCED_CLOSED = 2;\n+}\n+\n+// a response carries an event for a subscription sent to client\n+message SubscriptionEventResponse {\n+    optional SubscriptionEvent event = 1;\n+}\n+\n+message PubSubResponse{\n+    required ProtocolVersion protocolVersion = 1;\n+    required StatusCode statusCode = 2;\n+    required uint64 txnId = 3;\n+\n+    optional string statusMsg = 4;\n+    //in case of a status code of NOT_RESPONSIBLE_FOR_TOPIC, the status\n+    //message will contain the name of the host actually responsible \n+    //for the topic\n+    \n+    //the following fields are sent in delivered messages\n+    optional Message message = 5;\n+    optional bytes topic = 6;\n+    optional bytes subscriberId = 7;\n+\n+    // the following fields are sent by other requests\n+    optional ResponseBody responseBody = 8;\n+}\n+\n+message PublishResponse {\n+    // If the request was a publish request, this was the message Id of the published message.\n+    required MessageSeqId publishedMsgId = 1;\n+}\n+\n+message SubscribeResponse {\n+    optional SubscriptionPreferences preferences = 2;\n+}\n+\n+message ResponseBody {\n+    optional PublishResponse publishResponse = 1;\n+    optional SubscribeResponse subscribeResponse = 2;\n+    optional SubscriptionEventResponse subscriptionEvent = 3;\n+}\n+\n+\n+enum StatusCode{\n+    SUCCESS = 0;\n+    \n+    //client-side errors (4xx)\n+    MALFORMED_REQUEST = 401;\n+    NO_SUCH_TOPIC = 402;\n+    CLIENT_ALREADY_SUBSCRIBED = 403;\n+    CLIENT_NOT_SUBSCRIBED = 404;\n+    COULD_NOT_CONNECT = 405;\n+    TOPIC_BUSY = 406;\n+    RESUBSCRIBE_EXCEPTION = 407;\n+    \n+    //server-side errors (5xx)\n+    NOT_RESPONSIBLE_FOR_TOPIC = 501;\n+    SERVICE_DOWN = 502;\n+    UNCERTAIN_STATE = 503;\n+    INVALID_MESSAGE_FILTER = 504;\n+\n+    //server-side meta manager errors (52x)\n+    BAD_VERSION = 520;\n+    NO_TOPIC_PERSISTENCE_INFO = 521;\n+    TOPIC_PERSISTENCE_INFO_EXISTS = 522;\n+    NO_SUBSCRIPTION_STATE = 523;\n+    SUBSCRIPTION_STATE_EXISTS = 524;\n+    NO_TOPIC_OWNER_INFO = 525;\n+    TOPIC_OWNER_INFO_EXISTS = 526;\n+\n+    //For all unexpected error conditions\n+    UNEXPECTED_CONDITION = 600;\n+    \n+    COMPOSITE = 700;\n+}\n+  \n+//What follows is not the server client protocol, but server-internal structures that are serialized in ZK  \n+//They should eventually be moved into the server \n+    \n+message SubscriptionState {\n+    required MessageSeqId msgId = 1;\n+    // @Deprecated.\n+    // It is a bad idea to put fields that don't change frequently\n+    // together with fields that change frequently\n+    // so move it to subscription preferences structure\n+    optional uint32 messageBound = 2;\n+}\n+\n+message SubscriptionData {\n+    optional SubscriptionState state = 1;\n+    optional SubscriptionPreferences preferences = 2;\n+}\n+\n+message LedgerRange{\n+    required uint64 ledgerId = 1;\n+    optional MessageSeqId endSeqIdIncluded = 2;\n+    optional uint64 startSeqIdIncluded = 3;\n+}\n+\n+message LedgerRanges{\n+    repeated LedgerRange ranges = 1;\n+}\n+\n+message ManagerMeta {\n+    required string managerImpl = 2;\n+    required uint32 managerVersion = 3;\n+}\n+\n+message HubInfoData {\n+    required string hostname = 2;\n+    required uint64 czxid = 3;\n+}\n+\n+message HubLoadData {\n+    required uint64 numTopics = 2;\n+}"},{"sha":"27cd3398f4cbd7bec9dd911c92afa12ed2eee4db","filename":"branch-4.3/hedwig-protocol/src/main/resources/findbugsExclude.xml","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-protocol/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-protocol/src/main/resources/findbugsExclude.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,23 @@\n+<!--\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+//-->\n+<FindBugsFilter>\n+  <Match>\n+    <!-- generated code, we can't be held responsible for findbugs in it //-->\n+    <Class name=\"~org\\.apache\\.hedwig\\.protocol\\.PubSubProtocol.*\" />\n+  </Match>\n+</FindBugsFilter>"},{"sha":"a2ff83b839f95130eaf3d6a57561b929c3bccd62","filename":"branch-4.3/hedwig-server/bin/hedwig","status":"added","additions":205,"deletions":0,"changes":205,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/bin/hedwig","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/bin/hedwig","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/bin/hedwig?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,205 @@\n+#!/usr/bin/env bash\n+#\n+#/**\n+# * Copyright 2007 The Apache Software Foundation\n+# *\n+# * Licensed to the Apache Software Foundation (ASF) under one\n+# * or more contributor license agreements.  See the NOTICE file\n+# * distributed with this work for additional information\n+# * regarding copyright ownership.  The ASF licenses this file\n+# * to you under the Apache License, Version 2.0 (the\n+# * \"License\"); you may not use this file except in compliance\n+# * with the License.  You may obtain a copy of the License at\n+# *\n+# *     http://www.apache.org/licenses/LICENSE-2.0\n+# *\n+# * Unless required by applicable law or agreed to in writing, software\n+# * distributed under the License is distributed on an \"AS IS\" BASIS,\n+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# * See the License for the specific language governing permissions and\n+# * limitations under the License.\n+# */\n+\n+# check if net.ipv6.bindv6only is set to 1\n+bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n+if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n+then\n+  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n+  echo \"For more info (the following page also applies to hedwig): http://wiki.apache.org/hadoop/HadoopIPv6\"\n+  exit 1\n+fi\n+\n+# See the following page for extensive details on setting\n+# up the JVM to accept JMX remote management:\n+# http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html\n+# by default we allow local JMX connections\n+if [ \"x$JMXLOCALONLY\" = \"x\" ]\n+then\n+    JMXLOCALONLY=false\n+fi\n+\n+if [ \"x$JMXDISABLE\" = \"x\" ]\n+then\n+    echo \"JMX enabled by default\" >&2\n+    # for some reason these two options are necessary on jdk6 on Ubuntu\n+    #   accord to the docs they are not necessary, but otw jconsole cannot\n+    #   do a local attach\n+    JMX_ARGS=\"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY\"\n+else\n+    echo \"JMX disabled by user request\" >&2\n+fi\n+\n+BINDIR=`dirname \"$0\"`\n+HW_HOME=`cd $BINDIR/..;pwd`\n+\n+DEFAULT_CONF=$HW_HOME/conf/hw_server.conf\n+DEFAULT_REGION_CLIENT_CONF=$HW_HOME/conf/hw_region_client.conf\n+DEFAULT_LOG_CONF=$HW_HOME/conf/log4j.properties\n+\n+. $HW_HOME/conf/hwenv.sh\n+\n+# Check for the java to use\n+if [[ -z $JAVA_HOME ]]; then\n+    JAVA=$(which java)\n+    if [ $? = 0 ]; then\n+        echo \"JAVA_HOME not set, using java from PATH. ($JAVA)\"\n+    else\n+        echo \"Error: JAVA_HOME not set, and no java executable found in $PATH.\" 1>&2\n+        exit 1\n+    fi\n+else\n+    JAVA=$JAVA_HOME/bin/java\n+fi\n+\n+RELEASE_JAR=`ls $HW_HOME/hedwig-server-*.jar 2> /dev/null | grep -v tests | tail -1`\n+\n+if [ $? == 0 ]; then\n+    HEDWIG_JAR=$RELEASE_JAR\n+fi\n+\n+BUILT_JAR=`ls $HW_HOME/target/hedwig-server-*.jar 2> /dev/null | grep -v tests | tail -1`\n+if [ $? != 0 ] && [ ! -e \"$HEDWIG_JAR\" ]; then \n+    echo \"\\nCouldn't find hedwig jar.\";\n+    echo \"Make sure you've run 'mvn package'\\n\";\n+    exit 1;\n+elif [ -e \"$BUILT_JAR\" ]; then\n+    HEDWIG_JAR=$BUILT_JAR\n+fi\n+\n+add_maven_deps_to_classpath() {\n+    MVN=\"mvn\"\n+    if [ \"$MAVEN_HOME\" != \"\" ]; then\n+\tMVN=${MAVEN_HOME}/bin/mvn\n+    fi\n+    \n+    # Need to generate classpath from maven pom. This is costly so generate it\n+    # and cache it. Save the file into our target dir so a mvn clean will get\n+    # clean it up and force us create a new one.\n+    f=\"${HW_HOME}/target/cached_classpath.txt\"\n+    if [ ! -f \"${f}\" ]\n+    then\n+\t${MVN} -f \"${HW_HOME}/pom.xml\" dependency:build-classpath -Dmdep.outputFile=\"${f}\" &> /dev/null\n+    fi\n+    HEDWIG_CLASSPATH=${CLASSPATH}:`cat \"${f}\"`\n+}\n+\n+if [ -d \"$HW_HOME/lib\" ]; then\n+    for i in $HW_HOME/lib/*.jar; do\n+\tHEDWIG_CLASSPATH=$HEDWIG_CLASSPATH:$i\n+    done\n+else\n+    add_maven_deps_to_classpath\n+fi\n+\n+hedwig_help() {\n+    cat <<EOF\n+Usage: hedwig <command>\n+where command is one of:\n+    server           Run the hedwig server\n+    console          Run the hedwig admin console\n+    help             This help message\n+\n+or command is the full name of a class with a defined main() method.\n+\n+Environment variables:\n+   HEDWIG_SERVER_CONF           Hedwig server configuration file (default $DEFAULT_CONF)\n+   HEDWIG_REGION_CLIENT_CONF           Configuration file for the hedwig client used by the\n+                                region manager (default $DEFAULT_REGION_CLIENT_CONF)\n+   HEDWIG_CONSOLE_SERVER_CONF   Server part configuration for hedwig console,\n+                                used for metadata management (defaults to HEDWIG_SERVER_CONF)\n+   HEDWIG_CONSOLE_CLIENT_CONF   Client part configuration for hedwig console,\n+                                used for interacting with hub server.\n+   HEDWIG_LOG_CONF              Log4j configuration file (default $DEFAULT_LOG_CONF)\n+   HEDWIG_ROOT_LOGGER           Root logger for hedwig\n+   HEDWIG_LOG_DIR               Log directory to store log files for hedwig server\n+   HEDWIG_LOG_FILE              Log file name\n+   HEDWIG_EXTRA_OPTS            Extra options to be passed to the jvm\n+\n+These variable can also be set in conf/hwenv.sh\n+EOF\n+}\n+\n+# if no args specified, show usage\n+if [ $# = 0 ]; then\n+    hedwig_help;\n+    exit 1;\n+fi\n+\n+# get arguments\n+COMMAND=$1\n+shift\n+\n+if [ -z \"$HEDWIG_SERVER_CONF\" ]; then\n+    HEDWIG_SERVER_CONF=$DEFAULT_CONF;\n+fi\n+\n+if [ -z \"$HEDWIG_REGION_CLIENT_CONF\" ]; then\n+    HEDWIG_REGION_CLIENT_CONF=$DEFAULT_REGION_CLIENT_CONF;\n+fi\n+\n+if [ -z \"$HEDWIG_LOG_CONF\" ]; then\n+    HEDWIG_LOG_CONF=$DEFAULT_LOG_CONF\n+fi\n+\n+HEDWIG_CLASSPATH=\"$HEDWIG_JAR:$HEDWIG_CLASSPATH\"\n+\n+if [ \"$HEDWIG_LOG_CONF\" != \"\" ]; then\n+    HEDWIG_CLASSPATH=\"`dirname $HEDWIG_LOG_CONF`:$HEDWIG_CLASSPATH\"\n+    OPTS=\"$OPTS -Dlog4j.configuration=`basename $HEDWIG_LOG_CONF`\"\n+fi\n+OPTS=\"-cp $HEDWIG_CLASSPATH $OPTS $HEDWIG_EXTRA_OPTS\"\n+\n+# Disable ipv6 as it can cause issues\n+OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n+\n+# log directory & file\n+HEDWIG_ROOT_LOGGER=${HEDWIG_ROOT_LOGGER:-\"INFO,CONSOLE\"}\n+HEDWIG_LOG_DIR=${HEDWIG_LOG_DIR:-\"$HW_HOME/logs\"}\n+HEDWIG_LOG_FILE=${HEDWIG_LOG_FILE:-\"hedwig-server.log\"}\n+\n+# Configure log configuration system properties\n+OPTS=\"$OPTS -Dhedwig.root.logger=$HEDWIG_ROOT_LOGGER\"\n+OPTS=\"$OPTS -Dhedwig.log.dir=$HEDWIG_LOG_DIR\"\n+OPTS=\"$OPTS -Dhedwig.log.file=$HEDWIG_LOG_FILE\"\n+\n+# Change to HW_HOME to support relative paths\n+cd \"$BK_HOME\"\n+if [ $COMMAND == \"server\" ]; then\n+    exec $JAVA $OPTS $JMX_ARGS org.apache.hedwig.server.netty.PubSubServer $HEDWIG_SERVER_CONF $HEDWIG_REGION_CLIENT_CONF $@\n+elif [ $COMMAND == \"console\" ]; then\n+    # hedwig console configuration server part\n+    if [ -z \"$HEDWIG_CONSOLE_SERVER_CONF\" ]; then\n+        HEDWIG_CONSOLE_SERVER_CONF=$HEDWIG_SERVER_CONF\n+    fi\n+    # hedwig console configuration client part\n+    if [ -n \"$HEDWIG_CONSOLE_CLIENT_CONF\" ]; then\n+        HEDWIG_CONSOLE_CLIENT_OPTIONS=\"-client-cfg $HEDWIG_CONSOLE_CLIENT_CONF\"\n+    fi\n+    exec $JAVA $OPTS org.apache.hedwig.admin.console.HedwigConsole -server-cfg $HEDWIG_CONSOLE_SERVER_CONF $HEDWIG_CONSOLE_CLIENT_OPTIONS $@\n+elif [ $COMMAND == \"help\" ]; then\n+    hedwig_help;\n+else\n+    exec $JAVA $OPTS $COMMAND $@\n+fi\n+\n+"},{"sha":"73eac6f8236645e72826fef21716c92c75836096","filename":"branch-4.3/hedwig-server/bin/hedwig-daemon.sh","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/bin/hedwig-daemon.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/bin/hedwig-daemon.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/bin/hedwig-daemon.sh?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,163 @@\n+#!/usr/bin/env bash\n+#\n+#/**\n+# * Licensed to the Apache Software Foundation (ASF) under one\n+# * or more contributor license agreements.  See the NOTICE file\n+# * distributed with this work for additional information\n+# * regarding copyright ownership.  The ASF licenses this file\n+# * to you under the Apache License, Version 2.0 (the\n+# * \"License\"); you may not use this file except in compliance\n+# * with the License.  You may obtain a copy of the License at\n+# *\n+# *     http://www.apache.org/licenses/LICENSE-2.0\n+# *\n+# * Unless required by applicable law or agreed to in writing, software\n+# * distributed under the License is distributed on an \"AS IS\" BASIS,\n+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# * See the License for the specific language governing permissions and\n+# * limitations under the License.\n+# */\n+\n+usage() {\n+    cat <<EOF\n+Usage: hedwig-daemon.sh (start|stop) <command> <args...>\n+where command is one of:\n+    server           Run the hedwig server\n+EOF\n+}\n+\n+\n+BINDIR=`dirname \"$0\"`\n+HEDWIG_HOME=`cd $BINDIR/..;pwd`\n+\n+if [ -f $HEDWIG_HOME/conf/hwenv.sh ]\n+then\n+ . $HEDWIG_HOME/conf/hwenv.sh\n+fi\n+\n+HEDWIG_LOG_DIR=${HEDWIG_LOG_DIR:-\"$HEDWIG_HOME/logs\"}\n+\n+HEDWIG_ROOT_LOGGER=${HEDWIG_ROOT_LOGGER:-'INFO,ROLLINGFILE'}\n+\n+HEDWIG_STOP_TIMEOUT=${HEDWIG_STOP_TIMEOUT:-30}\n+\n+HEDWIG_PID_DIR=${HEDWIG_PID_DIR:-$HEDWIG_HOME/bin}\n+\n+if [ $# -lt 2 ]\n+then\n+    echo \"Error: no enough arguments provided.\"\n+    usage\n+    exit 1\n+fi\n+\n+startStop=$1\n+shift\n+command=$1\n+shift\n+\n+case $command in\n+    (server)\n+        echo \"doing $startStop $command ...\"\n+        ;;\n+    (*)\n+        echo \"Error: unknown service name $command\"\n+        usage\n+        exit 1\n+        ;;\n+esac\n+\n+export HEDWIG_LOG_DIR=$HEDWIG_LOG_DIR\n+export HEDWIG_ROOT_LOGGER=$HEDWIG_ROOT_LOGGER\n+export HEDWIG_LOG_FILE=hedwig-$command-$HOSTNAME.log\n+\n+pid=$HEDWIG_PID_DIR/hedwig-$command.pid\n+out=$HEDWIG_LOG_DIR/hedwig-$command-$HOSTNAME.out\n+logfile=$HEDWIG_LOG_DIR/$HEDWIG_LOG_FILE\n+\n+rotate_out_log ()\n+{\n+    log=$1;\n+    num=5;\n+    if [ -n \"$2\" ]; then\n+       num=$2\n+    fi\n+    if [ -f \"$log\" ]; then # rotate logs\n+        while [ $num -gt 1 ]; do\n+            prev=`expr $num - 1`\n+            [ -f \"$log.$prev\" ] && mv \"$log.$prev\" \"$log.$num\"\n+            num=$prev\n+        done\n+        mv \"$log\" \"$log.$num\";\n+    fi\n+}\n+\n+mkdir -p \"$HEDWIG_LOG_DIR\"\n+\n+case $startStop in\n+  (start)\n+    if [ -f $pid ]; then\n+      if kill -0 `cat $pid` > /dev/null 2>&1; then\n+        echo $command running as process `cat $pid`.  Stop it first.\n+        exit 1\n+      fi\n+    fi\n+\n+    rotate_out_log $out\n+    echo starting $command, logging to $logfile\n+    hedwig=$HEDWIG_HOME/bin/hedwig\n+    nohup $hedwig $command \"$@\" > \"$out\" 2>&1 < /dev/null &\n+    echo $! > $pid\n+    sleep 1; head $out\n+    sleep 2;\n+    if ! ps -p $! > /dev/null ; then\n+      exit 1\n+    fi\n+    ;;\n+\n+  (stop)\n+    if [ -f $pid ]; then\n+      TARGET_PID=`cat $pid`\n+      if kill -0 $TARGET_PID > /dev/null 2>&1; then\n+        echo stopping $command\n+        kill $TARGET_PID\n+\n+        count=0\n+        location=$HEDWIG_LOG_DIR\n+        while ps -p $TARGET_PID > /dev/null;\n+         do\n+          echo \"Shutdown is in progress... Please wait...\"\n+          sleep 1\n+          count=`expr $count + 1`\n+         \n+          if [ \"$count\" = \"$HEDWIG_STOP_TIMEOUT\" ]; then\n+                break\n+          fi\n+         done\n+        \n+        if [ \"$count\" != \"$HEDWIG_STOP_TIMEOUT\" ]; then\n+                 echo \"Shutdown completed.\"\n+                exit 0\n+        fi\n+                 \n+        if kill -0 $TARGET_PID > /dev/null 2>&1; then\n+              fileName=$location/$command.out\n+              $JAVA_HOME/bin/jstack $TARGET_PID > $fileName\n+              echo Thread dumps are taken for analysis at $fileName\n+              echo forcefully stopping $command\n+              kill -9 $TARGET_PID >/dev/null 2>&1\n+              echo Successfully stopped the process\n+        fi\n+      else\n+        echo no $command to stop\n+      fi\n+      rm $pid\n+    else\n+      echo no $command to stop\n+    fi\n+    ;;\n+\n+  (*)\n+    usage\n+    exit 1\n+    ;;\n+esac"},{"sha":"9a5592ee56bb294bc1f3dfd7c4a1c7ad7a4e3e24","filename":"branch-4.3/hedwig-server/conf/hw_region_client.conf","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hw_region_client.conf","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hw_region_client.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/conf/hw_region_client.conf?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,42 @@\n+#   Licensed to the Apache Software Foundation (ASF) under one or more\n+#   contributor license agreements.  See the NOTICE file distributed with\n+#   this work for additional information regarding copyright ownership.\n+#   The ASF licenses this file to You under the Apache License, Version 2.0\n+#   (the \"License\"); you may not use this file except in compliance with\n+#   the License.  You may obtain a copy of the License at\n+#\n+#       http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#   Unless required by applicable law or agreed to in writing, software\n+#   distributed under the License is distributed on an \"AS IS\" BASIS,\n+#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#   See the License for the specific language governing permissions and\n+#   limitations under the License.\n+\n+# This is the configuration file for the hedwig client used by the region manager\n+\n+# This parameter is a boolean flag indicating if communication with the\n+# server should be done via SSL for encryption. The Hedwig server hubs also\n+# need to be SSL enabled for this to work.\n+# ssl_enabled=false\n+\n+# The maximum message size in bytes\n+# max_message_size=2097152\n+\n+# The maximum number of redirects we permit before signalling an error\n+# max_server_redirects=2\n+\n+# A flag indicating whether the client library should automatically send\n+# consume messages to the server\n+# auto_send_consume_message_enabled=true\n+\n+# The number of messages we buffer before sending a consume message\n+# to the server\n+# consumed_messages_buffer_size=5\n+\n+# Support for client side throttling.\n+# max_outstanding_messages=10\n+\n+# The timeout in milliseconds before we error out any existing\n+# requests\n+# server_ack_response_timeout=30000"},{"sha":"2ca2d5462a9dbdcaaf4b0bfaa4f63f5709256cdd","filename":"branch-4.3/hedwig-server/conf/hw_server.conf","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hw_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hw_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/conf/hw_server.conf?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,168 @@\n+#   Licensed to the Apache Software Foundation (ASF) under one or more\n+#   contributor license agreements.  See the NOTICE file distributed with\n+#   this work for additional information regarding copyright ownership.\n+#   The ASF licenses this file to You under the Apache License, Version 2.0\n+#   (the \"License\"); you may not use this file except in compliance with\n+#   the License.  You may obtain a copy of the License at\n+#\n+#       http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#   Unless required by applicable law or agreed to in writing, software\n+#   distributed under the License is distributed on an \"AS IS\" BASIS,\n+#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#   See the License for the specific language governing permissions and\n+#   limitations under the License.\n+\n+################################\n+# ZooKeeper Settings\n+################################\n+\n+# The ZooKeeper server host(s) for the Hedwig Server to use.\n+zk_host=localhost:2181\n+\n+# The number of milliseconds of each tick in ZooKeeper.\n+zk_timeout=2000\n+\n+################################\n+# Hub Server Settings\n+################################\n+\n+# Is the hub server running in standalone mode?\n+# Default is false.\n+standalone=false\n+\n+# The port at which the clients will connect.\n+server_port=4080\n+\n+# The SSL port at which the clients will connect (only if SSL is enabled).\n+ssl_server_port=9876\n+\n+# Flag indicating if the server should also operate in SSL mode.\n+ssl_enabled=false\n+\n+# Name of the SSL certificate if available as a resource.\n+# The certificate should be in pkcs12 format.\n+# cert_name=\n+\n+# Path to the SSL certificate if available as a file.\n+# The certificate should be in pkcs12 format.\n+# cert_path=\n+\n+# Password used for pkcs12 certificate.\n+# password=\n+\n+#######################################\n+# Publish and subscription parameters\n+#######################################\n+# Max Message Size that a hub server could accept\n+# max_message_size=1258291 \n+\n+# Message Sequence Interval to update subscription state to metadata store.\n+# Default is 50.\n+# consume_interval=50\n+\n+# Time interval (in seconds) to release topic ownership. If the time interval\n+# is less than zero, the ownership will never be released automatically.\n+# Default is 0.\n+# retention_secs=0\n+\n+# Time interval (in milliseconds) to run messages consumed timer task to\n+# delete those consumed ledgers in BookKeeper.\n+# messages_consumed_thread_run_interval=60000\n+\n+# Default maximum number of messages which can be delivered to a subscriber\n+# without being consumed. We pause messages delivery to a subscriber when\n+# reaching the window size. Default is 0, which means we never pause messages\n+# delivery even a subscriber consumes nothing and it doesn't set any subscriber\n+# specified message window size.\n+# default_message_window_size=0\n+\n+# The maximum number of entries stored in a ledger. When the number of entries\n+# reaches this threshold, hub server will open a new ledger to write. Default is 0.\n+# If it was set to 0, hub server will keep using same ledger to write entries unless\n+# the topic ownership changed.\n+# max_entries_per_ledger=0\n+\n+################################\n+# Region Related Settings\n+################################\n+\n+# Region name that the hub server belongs to.\n+# region=standalone\n+\n+# Regions list of a Hedwig instance.\n+# The expected format for the regions parameter is Hostname:Port:SSLPort\n+# with spaces in between each of regions.\n+# regions=\n+\n+# Enabled ssl connections between regions or not.\n+# (@Deprecated here. It is recommended to set in conf/hw_region_client.conf)\n+# Default is false.\n+# inter_region_ssl_enabled=false\n+\n+# Time interval (in milliseconds) to run thread to retry those failed\n+# remote subscriptions in asynchronous mode. Default is 120000.\n+# retry_remote_subscribe_thread_run_interval=120000\n+\n+################################\n+# ReadAhead Settings\n+################################\n+\n+# Enable read ahead cache or not. If disabled, read requests\n+# would access BookKeeper directly.\n+# Default is true.\n+# readahead_enabled=true\n+\n+# Number of entries to read ahead. Default value is 10.\n+# readahead_count=10\n+\n+# Max size of entries to read ahead. Default value is 4M.\n+# readahead_size=4194304\n+\n+# Max memory used for ReadAhead Cache.\n+# Default value is minimum value of 2G or half of JVM max memory.\n+# cache_size=\n+\n+# The backoff time (in milliseconds) to retry scans after failures.\n+# Default value is 1000.\n+# scan_backoff_ms=1000\n+\n+# Sets the number of threads to be used for the read-ahead mechanism.\n+# Default is the number of cores as returned with a call to \n+# <code>Runtime.getRuntime().availableProcessors()</code>.\n+# num_readahead_cache_threads=\n+\n+# Set TTL for cache entries. Each time adding new entry into the cache,\n+# those expired cache entries would be discarded. If the value is set\n+# to zero or less than zero, cache entry will not be evicted until the\n+# cache is fullfilled or the messages are already consumed. By default\n+# the value is zero.\n+# cache_entry_ttl=\n+\n+################################\n+# Metadata Settings\n+################################\n+\n+# zookeeper prefix to store metadata if using zookeeper as metadata store.\n+# Default value is \"/hedwig\".\n+# zk_prefix=/hedwig\n+\n+# Enable metadata manager based topic manager. Default is false.\n+# metadata_manager_based_topic_manager_enabled=false\n+\n+# Class name of metadata manager factory used to store metadata.\n+# Default is null.\n+# metadata_manager_factory_class=\n+\n+################################\n+# BookKeeper Settings\n+################################\n+\n+# Ensemble size of a ledger in BookKeeper. Default is 3.\n+# bk_ensemble_size=3\n+\n+# Write quorum size for a ledger in BookKeeper. Default is 2.\n+# bk_write_quorum_size=2\n+\n+# Ack quorum size for a ledger in BookKeeper. Default is 2.\n+# bk_ack_quorum_size=2"},{"sha":"8d379b6a11d5ba580f21e7a73fa7d0c54ae5d36a","filename":"branch-4.3/hedwig-server/conf/hwenv.sh","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hwenv.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/hwenv.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/conf/hwenv.sh?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,56 @@\n+#!/bin/sh\n+#\n+#/**\n+# * Copyright 2007 The Apache Software Foundation\n+# *\n+# * Licensed to the Apache Software Foundation (ASF) under one\n+# * or more contributor license agreements.  See the NOTICE file\n+# * distributed with this work for additional information\n+# * regarding copyright ownership.  The ASF licenses this file\n+# * to you under the Apache License, Version 2.0 (the\n+# * \"License\"); you may not use this file except in compliance\n+# * with the License.  You may obtain a copy of the License at\n+# *\n+# *     http://www.apache.org/licenses/LICENSE-2.0\n+# *\n+# * Unless required by applicable law or agreed to in writing, software\n+# * distributed under the License is distributed on an \"AS IS\" BASIS,\n+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# * See the License for the specific language governing permissions and\n+# * limitations under the License.\n+# */\n+\n+# Set JAVA_HOME here to override the environment setting\n+# JAVA_HOME=\n+\n+# default settings for starting hedwig\n+# HEDWIG_SERVER_CONF=\n+\n+# default settings for the region manager's hedwig client\n+# HEDWIG_REGION_CLIENT_CONF=\n+\n+# default settings for the region manager's hedwig client\n+# HEDWIG_CLIENT_CONF=\n+\n+# Server part configuration for hedwig console,\n+# used for metadata management\n+# HEDWIG_CONSOLE_SERVER_CONF=\n+\n+# Client part configuration for hedwig console,\n+# used for interacting with hub server.\n+# HEDWIG_CONSOLE_CLIENT_CONF=\n+\n+# Log4j configuration file\n+# HEDWIG_LOG_CONF=\n+\n+# Logs location\n+# HEDWIG_LOG_DIR=\n+\n+# Extra options to be passed to the jvm\n+# HEDWIG_EXTRA_OPTS=\n+\n+#Folder where the hedwig server PID file should be stored\n+#HEDWIG_PID_DIR=\n+\n+#Wait time before forcefully kill the hedwig server instance, if the stop is not successful\n+#HEDWIG_STOP_TIMEOUT="},{"sha":"c0f1c49f1c4dca8270bd3cf9e686c1a3c6cf627c","filename":"branch-4.3/hedwig-server/conf/log4j.properties","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/conf/log4j.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,78 @@\n+#\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+#\n+\n+#\n+# Hedwig Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+# Define some default values that can be overridden by system properties\n+hedwig.root.logger=WARN,CONSOLE\n+hedwig.log.dir=.\n+hedwig.log.file=hedwig-server.log\n+hedwig.trace.file=hedwig-trace.log\n+\n+log4j.rootLogger=${hedwig.root.logger}\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=INFO\n+log4j.appender.ROLLINGFILE.File=${hedwig.log.dir}/${hedwig.log.file}\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+#log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=${hedwig.log.dir}/${hedwig.trace.file}\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"1bf5e45bd3bad05cd0e35a570269517e99615f7f","filename":"branch-4.3/hedwig-server/pom.xml","status":"added","additions":294,"deletions":0,"changes":294,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/pom.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,294 @@\n+<?xml version=\"1.0\"?>\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <parent>\n+    <groupId>org.apache.bookkeeper</groupId>\n+    <artifactId>bookkeeper</artifactId>\n+    <version>4.3.0</version>\n+  </parent>\n+  <properties>\n+      <mainclass>org.apache.hedwig.server.netty.PubSubServer</mainclass>\n+      <project.libdir>${basedir}/lib</project.libdir>\n+  </properties>\n+  <artifactId>hedwig-server</artifactId>\n+  <packaging>jar</packaging>\n+  <name>hedwig-server</name>\n+  <url>http://maven.apache.org</url>\n+  <dependencies>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-log4j12</artifactId>\n+      <version>1.6.4</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-client</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>compile</scope>\n+      <type>jar</type>\n+    </dependency>\n+    <dependency>\n+        <groupId>org.apache.derby</groupId>\n+        <artifactId>derby</artifactId>\n+        <version>10.8.2.2</version>\n+        <scope>runtime</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.zookeeper</groupId>\n+      <artifactId>zookeeper</artifactId>\n+      <version>${zookeeper.version}</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.zookeeper</groupId>\n+      <artifactId>zookeeper</artifactId>\n+      <version>${zookeeper.version}</version>\n+      <type>test-jar</type>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>bookkeeper-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>compile</scope>\n+      <type>jar</type>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>bookkeeper-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>test</scope>\n+      <type>test-jar</type>\n+    </dependency>\n+    <!--\n+        Annoying dependency we need to include because\n+        zookeeper uses log4j and so we transatively do, but\n+        log4j has some dependencies which aren't in the \n+        default maven repositories\n+    //-->\n+    <dependency>\n+      <groupId>log4j</groupId>\n+      <artifactId>log4j</artifactId>\n+      <version>1.2.15</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>javax.mail</groupId>\n+          <artifactId>mail</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>javax.jms</groupId>\n+          <artifactId>jms</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jdmk</groupId>\n+          <artifactId>jmxtools</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jmx</groupId>\n+          <artifactId>jmxri</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+    <dependency>\n+      <groupId>jline</groupId>\n+      <artifactId>jline</artifactId>\n+      <version>0.9.94</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server-compat420</artifactId>\n+      <version>4.2.0</version>\n+      <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>bookkeeper-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-protocol</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-client</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server-compat410</artifactId>\n+      <version>4.1.0</version>\n+      <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>bookkeeper-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-protocol</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-client</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server-compat400</artifactId>\n+      <version>4.0.0</version>\n+      <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>bookkeeper-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-server</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-protocol</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.apache.bookkeeper</groupId>\n+          <artifactId>hedwig-client</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+  </dependencies>\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-jar-plugin</artifactId>\n+        <executions>\n+          <execution>\n+            <phase>package</phase>\n+            <goals>\n+              <goal>test-jar</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.apache.rat</groupId>\n+        <artifactId>apache-rat-plugin</artifactId>\n+        <version>0.7</version>\n+        <configuration>\n+          <excludes>\n+            <exclude>**/p12.pass</exclude>\n+          </excludes>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-assembly-plugin</artifactId>\n+        <version>2.2.1</version>\n+        <configuration>\n+          <descriptors>\n+            <descriptor>../src/assemble/bin.xml</descriptor>\n+          </descriptors>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.codehaus.mojo</groupId>\n+        <artifactId>findbugs-maven-plugin</artifactId>\n+        <configuration>\n+          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-antrun-plugin</artifactId>\n+        <executions>\n+          <execution>\n+            <id>createbuilddir</id>\n+            <phase>generate-test-resources</phase>\n+            <configuration>\n+              <target>\n+                <mkdir dir=\"target/zk_clientbase_build\" />\n+              </target>\n+            </configuration>\n+            <goals>\n+              <goal>run</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-dependency-plugin</artifactId>\n+        <executions>\n+          <execution>\n+            <phase>package</phase>\n+            <goals>\n+              <goal>copy-dependencies</goal>\n+            </goals>\n+            <configuration>\n+              <outputDirectory>${project.libdir}</outputDirectory>\n+            </configuration>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <configuration>\n+          <systemPropertyVariables>\n+            <derby.stream.error.file>target/derby.log</derby.stream.error.file>\n+            <build.test.dir>target/zk_clientbase_build</build.test.dir>\n+          </systemPropertyVariables>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-clean-plugin</artifactId>\n+        <version>2.5</version>\n+\t<configuration>\n+\t  <filesets>\n+            <fileset>\n+              <directory>${project.libdir}</directory>\n+              <followSymlinks>false</followSymlinks>\n+            </fileset>\n+\t  </filesets>\n+\t</configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>"},{"sha":"7e084ec074ab4eb58b70c8cad825dd96ba449b8c","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"added","additions":550,"deletions":0,"changes":550,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,550 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.FactoryLayout;\n+import org.apache.hedwig.server.meta.SubscriptionDataManager;\n+import org.apache.hedwig.server.meta.TopicOwnershipManager;\n+import org.apache.hedwig.server.meta.TopicPersistenceManager;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.server.topics.HubLoad;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+/**\n+ * Hedwig Admin\n+ */\n+public class HedwigAdmin {\n+    static final Logger LOG = LoggerFactory.getLogger(HedwigAdmin.class);\n+\n+    // NOTE: now it is fixed passwd used in hedwig\n+    static byte[] passwd = \"sillysecret\".getBytes(UTF_8);\n+\n+    protected final ZooKeeper zk;\n+    protected final BookKeeper bk;\n+    protected final MetadataManagerFactory mmFactory;\n+    protected final SubscriptionDataManager sdm;\n+    protected final TopicOwnershipManager tom;\n+    protected final TopicPersistenceManager tpm;\n+\n+    // hub configurations\n+    protected final ServerConfiguration serverConf;\n+    // bookkeeper configurations\n+    protected final ClientConfiguration bkClientConf;\n+\n+    protected final CountDownLatch zkReadyLatch = new CountDownLatch(1);\n+\n+    // Empty watcher\n+    private class MyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+            if (Event.KeeperState.SyncConnected.equals(event.getState())) {\n+                zkReadyLatch.countDown();\n+            }\n+        }\n+    }\n+\n+    static class SyncObj<T> {\n+        boolean finished = false;\n+        boolean success = false;\n+        T value = null;\n+        PubSubException exception = null;\n+\n+        synchronized void success(T v) {\n+            finished = true;\n+            success = true;\n+            value = v;\n+            notify();\n+        }\n+\n+        synchronized void fail(PubSubException pse) {\n+            finished = true;\n+            success = false;\n+            exception = pse;\n+            notify();\n+        }\n+\n+        synchronized void block() {\n+            try {\n+                while (!finished) {\n+                    wait();\n+                }\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+\n+        synchronized boolean isSuccess() {\n+            return success;\n+        }\n+    }\n+\n+    /**\n+     * Stats of a hub\n+     */\n+    public static class HubStats {\n+        HubInfo hubInfo;\n+        HubLoad hubLoad;\n+\n+        public HubStats(HubInfo info, HubLoad load) {\n+            this.hubInfo = info;\n+            this.hubLoad = load;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"info : [\").append(hubInfo.toString().trim().replaceAll(\"\\n\", \", \"))\n+              .append(\"], load : [\").append(hubLoad.toString().trim().replaceAll(\"\\n\", \", \"))\n+              .append(\"]\");\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * Hedwig Admin Constructor\n+     *\n+     * @param bkConf\n+     *          BookKeeper Client Configuration.\n+     * @param hubConf\n+     *          Hub Server Configuration.\n+     * @throws Exception\n+     */\n+    public HedwigAdmin(ClientConfiguration bkConf, ServerConfiguration hubConf) throws Exception {\n+        this.serverConf = hubConf;\n+        this.bkClientConf = bkConf;\n+\n+        // connect to zookeeper\n+        zk = new ZooKeeper(hubConf.getZkHost(), hubConf.getZkTimeout(), new MyWatcher());\n+        LOG.debug(\"Connecting to zookeeper {}, timeout = {}\",\n+                hubConf.getZkHost(), hubConf.getZkTimeout());\n+        // wait until connection is ready\n+        if (!zkReadyLatch.await(hubConf.getZkTimeout() * 2, TimeUnit.MILLISECONDS)) {\n+            throw new Exception(\"Count not establish connection with ZooKeeper after \" + hubConf.getZkTimeout() * 2 + \" ms.\");\n+        }\n+\n+        // construct the metadata manager factory\n+        mmFactory = MetadataManagerFactory.newMetadataManagerFactory(hubConf, zk);\n+        tpm = mmFactory.newTopicPersistenceManager();\n+        tom = mmFactory.newTopicOwnershipManager();\n+        sdm = mmFactory.newSubscriptionDataManager();\n+\n+        // connect to bookkeeper\n+        bk = new BookKeeper(bkClientConf, zk);\n+        LOG.debug(\"Connecting to bookkeeper\");\n+    }\n+\n+    /**\n+     * Close the hedwig admin.\n+     *\n+     * @throws Exception\n+     */\n+    public void close() throws Exception {\n+        tpm.close();\n+        tom.close();\n+        sdm.close();\n+        mmFactory.shutdown();\n+        bk.close();\n+        zk.close();\n+    }\n+\n+    /**\n+     * Return zookeeper handle used in hedwig admin.\n+     *\n+     * @return zookeeper handle\n+     */\n+    public ZooKeeper getZkHandle() {\n+        return zk;\n+    }\n+\n+    /**\n+     * Return bookkeeper handle used in hedwig admin.\n+     *\n+     * @return bookkeeper handle\n+     */\n+    public BookKeeper getBkHandle() {\n+        return bk;\n+    }\n+\n+    /**\n+     * Return hub server configuration used in hedwig admin\n+     *\n+     * @return hub server configuration\n+     */\n+    public ServerConfiguration getHubServerConf() {\n+        return serverConf;\n+    }\n+\n+    /**\n+     * Return metadata manager factory.\n+     *\n+     * @return metadata manager factory instance.\n+     */\n+    public MetadataManagerFactory getMetadataManagerFactory() {\n+        return mmFactory;\n+    }\n+\n+    /**\n+     * Return bookeeper passwd used in hedwig admin\n+     *\n+     * @return bookeeper passwd\n+     */\n+    public byte[] getBkPasswd() {\n+        return Arrays.copyOf(passwd, passwd.length);\n+    }\n+\n+    /**\n+     * Return digest type used in hedwig admin\n+     *\n+     * @return bookeeper digest type\n+     */\n+    public DigestType getBkDigestType() {\n+        return DigestType.CRC32;\n+    }\n+\n+    /**\n+     * Dose topic exist?\n+     *\n+     * @param topic\n+     *            Topic name\n+     * @return whether topic exists or not?\n+     * @throws Exception\n+     */\n+    public boolean hasTopic(ByteString topic) throws Exception {\n+        // current persistence info is bound with a topic, so if there is persistence info\n+        // there is topic.\n+        final SyncObj<Boolean> syncObj = new SyncObj<Boolean>();\n+        tpm.readTopicPersistenceInfo(topic, new Callback<Versioned<LedgerRanges>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<LedgerRanges> result) {\n+                if (null == result) {\n+                    syncObj.success(false);\n+                } else {\n+                    syncObj.success(true);\n+                }\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                syncObj.fail(pse);\n+            }\n+        }, syncObj);\n+\n+        syncObj.block();\n+\n+        if (!syncObj.isSuccess()) {\n+            throw syncObj.exception;\n+        }\n+\n+        return syncObj.value;\n+    }\n+\n+    /**\n+     * Get available hubs.\n+     *\n+     * @return available hubs and their loads\n+     * @throws Exception\n+     */\n+    public Map<HedwigSocketAddress, HubStats> getAvailableHubs() throws Exception {\n+        String zkHubsPath = serverConf.getZkHostsPrefix(new StringBuilder()).toString();\n+        Map<HedwigSocketAddress, HubStats> hubs =\n+            new HashMap<HedwigSocketAddress, HubStats>();\n+        List<String> hosts = zk.getChildren(zkHubsPath, false);\n+        for (String host : hosts) {\n+            String zkHubPath = serverConf.getZkHostsPrefix(new StringBuilder())\n+                                         .append(\"/\").append(host).toString();\n+            HedwigSocketAddress addr = new HedwigSocketAddress(host);\n+            try {\n+                Stat stat = new Stat();\n+                byte[] data = zk.getData(zkHubPath, false, stat);\n+                if (data == null) {\n+                    continue;\n+                }\n+                HubLoad load = HubLoad.parse(new String(data, UTF_8));\n+                HubInfo info = new HubInfo(addr, stat.getCzxid());\n+                hubs.put(addr, new HubStats(info, load));\n+            } catch (KeeperException ke) {\n+                LOG.warn(\"Couldn't read hub data from ZooKeeper\", ke);\n+            } catch (InterruptedException ie) {\n+                LOG.warn(\"Interrupted during read\", ie);\n+            }\n+        }\n+        return hubs;\n+    }\n+\n+    /**\n+     * Get list of topics\n+     *\n+     * @return list of topics\n+     * @throws Exception\n+     */\n+    public Iterator<ByteString> getTopics() throws Exception {\n+        return mmFactory.getTopics();\n+    }\n+\n+    /**\n+     * Return the topic owner of a topic\n+     *\n+     * @param topic\n+     *            Topic name\n+     * @return the address of the owner of a topic\n+     * @throws Exception\n+     */\n+    public HubInfo getTopicOwner(ByteString topic) throws Exception {\n+        final SyncObj<HubInfo> syncObj = new SyncObj<HubInfo>();\n+        tom.readOwnerInfo(topic, new Callback<Versioned<HubInfo>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<HubInfo> result) {\n+                if (null == result) {\n+                    syncObj.success(null);\n+                } else {\n+                    syncObj.success(result.getValue());\n+                }\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                syncObj.fail(pse);\n+            }\n+        }, syncObj);\n+\n+        syncObj.block();\n+\n+        if (!syncObj.isSuccess()) {\n+            throw syncObj.exception;\n+        }\n+\n+        return syncObj.value;\n+    }\n+\n+    private static LedgerRange buildLedgerRange(long ledgerId, long startOfLedger, MessageSeqId endOfLedger) {\n+        LedgerRange.Builder builder =\n+            LedgerRange.newBuilder().setLedgerId(ledgerId).setStartSeqIdIncluded(startOfLedger)\n+                       .setEndSeqIdIncluded(endOfLedger);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Return the ledger range forming the topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @return ledger ranges forming the topic\n+     * @throws Exception\n+     */\n+    public List<LedgerRange> getTopicLedgers(ByteString topic) throws Exception {\n+        final SyncObj<LedgerRanges> syncObj = new SyncObj<LedgerRanges>();\n+        tpm.readTopicPersistenceInfo(topic, new Callback<Versioned<LedgerRanges>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<LedgerRanges> result) {\n+                if (null == result) {\n+                    syncObj.success(null);\n+                } else {\n+                    syncObj.success(result.getValue());\n+                }\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                syncObj.fail(pse);\n+            }\n+        }, syncObj);\n+\n+        syncObj.block();\n+\n+        if (!syncObj.isSuccess()) {\n+            throw syncObj.exception;\n+        }\n+\n+        LedgerRanges ranges = syncObj.value;\n+        if (null == ranges) {\n+            return null;\n+        }\n+        List<LedgerRange> results = new ArrayList<LedgerRange>();\n+        List<LedgerRange> lrs = ranges.getRangesList();\n+        long startSeqId = 1L;\n+        if (!lrs.isEmpty()) {\n+            LedgerRange range = lrs.get(0);\n+            if (!range.hasStartSeqIdIncluded() && range.hasEndSeqIdIncluded()) {\n+                long ledgerId = range.getLedgerId();\n+                try {\n+                    LedgerHandle lh = bk.openLedgerNoRecovery(ledgerId, DigestType.CRC32, passwd);\n+                    long numEntries = lh.readLastConfirmed() + 1;\n+                    long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                    startSeqId = endOfLedger - numEntries + 1;\n+                } catch (BKException.BKNoSuchLedgerExistsException be) {\n+                    // ignore it\n+                }\n+            }\n+        }\n+        Iterator<LedgerRange> lrIter = lrs.iterator();\n+        while (lrIter.hasNext()) {\n+            LedgerRange range = lrIter.next();\n+            if (range.hasEndSeqIdIncluded()) {\n+                long endOfLedger = range.getEndSeqIdIncluded().getLocalComponent();\n+                if (range.hasStartSeqIdIncluded()) {\n+                    startSeqId = range.getStartSeqIdIncluded();\n+                } else {\n+                    range = buildLedgerRange(range.getLedgerId(), startSeqId, range.getEndSeqIdIncluded());\n+                }\n+                results.add(range);\n+                if (startSeqId < endOfLedger + 1) {\n+                    startSeqId = endOfLedger + 1;\n+                }\n+                continue;\n+            }\n+            if (lrIter.hasNext()) {\n+                throw new IllegalStateException(\"Ledger \" + range.getLedgerId() + \" for topic \" + topic.toString()\n+                                                + \" is not the last one but still does not have an end seq-id\");\n+            }\n+\n+            if (range.hasStartSeqIdIncluded()) {\n+                startSeqId = range.getStartSeqIdIncluded();\n+            }\n+\n+            LedgerHandle lh = bk.openLedgerNoRecovery(range.getLedgerId(), DigestType.CRC32, passwd);\n+            long endOfLedger = startSeqId + lh.readLastConfirmed();\n+            MessageSeqId endSeqId = MessageSeqId.newBuilder().setLocalComponent(endOfLedger).build();\n+            results.add(buildLedgerRange(range.getLedgerId(), startSeqId, endSeqId));\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Return subscriptions of a topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @return subscriptions of a topic\n+     * @throws Exception\n+     */\n+    public Map<ByteString, SubscriptionData> getTopicSubscriptions(ByteString topic)\n+        throws Exception {\n+\n+        final SyncObj<Map<ByteString, SubscriptionData>> syncObj =\n+            new SyncObj<Map<ByteString, SubscriptionData>>();\n+        sdm.readSubscriptions(topic, new Callback<Map<ByteString, Versioned<SubscriptionData>>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Map<ByteString, Versioned<SubscriptionData>> result) {\n+                // It was just used to console tool to print some information, so don't need to return version for it\n+                // just keep the getTopicSubscriptions interface as before\n+                Map<ByteString, SubscriptionData> subs = new ConcurrentHashMap<ByteString, SubscriptionData>();\n+                for (Map.Entry<ByteString, Versioned<SubscriptionData>> subEntry : result.entrySet()) {\n+                    subs.put(subEntry.getKey(), subEntry.getValue().getValue());\n+                }\n+                syncObj.success(subs);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                syncObj.fail(pse);\n+            }\n+        }, syncObj);\n+\n+        syncObj.block();\n+\n+        if (!syncObj.isSuccess()) {\n+            throw syncObj.exception;\n+        }\n+\n+        return syncObj.value;\n+    }\n+\n+    /**\n+     * Return subscription state of a subscriber of topic\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriber\n+     *          Subscriber name\n+     * @return subscription state\n+     * @throws Exception\n+     */\n+    public SubscriptionData getSubscription(ByteString topic, ByteString subscriber) throws Exception {\n+        final SyncObj<SubscriptionData> syncObj = new SyncObj<SubscriptionData>();\n+        sdm.readSubscriptionData(topic, subscriber, new Callback<Versioned<SubscriptionData>>() {\n+            @Override\n+            public void operationFinished(Object ctx, Versioned<SubscriptionData> result) {\n+                if (null == result) {\n+                    syncObj.success(null);\n+                } else {\n+                    syncObj.success(result.getValue());\n+                }\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException pse) {\n+                syncObj.fail(pse);\n+            }\n+        }, syncObj);\n+\n+        syncObj.block();\n+\n+        if (!syncObj.isSuccess()) {\n+            throw syncObj.exception;\n+        }\n+\n+        return syncObj.value;\n+    }\n+\n+    /**\n+     * Format metadata for Hedwig.\n+     */\n+    public void format() throws Exception {\n+        // format metadata first\n+        mmFactory.format(serverConf, zk);\n+        LOG.info(\"Formatted Hedwig metadata successfully.\");\n+        // remove metadata layout\n+        FactoryLayout.deleteLayout(zk, serverConf);\n+        LOG.info(\"Removed old factory layout.\");\n+        // create new metadata manager factory and write new metadata layout\n+        MetadataManagerFactory.createMetadataManagerFactory(serverConf, zk,\n+            serverConf.getMetadataManagerFactoryClass());\n+        LOG.info(\"Created new factory layout.\");\n+    }\n+}"},{"sha":"407769bdd71d2ce5114b555416306fe8d7df56d8","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","status":"added","additions":437,"deletions":0,"changes":437,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,437 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.util.Map;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * List all the available commands\n+ */\n+public final class HedwigCommands {\n+\n+    static final String[] EMPTY_ARRAY = new String[0];\n+\n+    //\n+    // List all commands used to play with hedwig\n+    //\n+\n+    /* PUB : publish a message to hedwig */\n+    static final String PUB = \"pub\";\n+    static final String PUB_DESC = \"Publish a message to a topic in Hedwig\";\n+    static final String[] PUB_USAGE = new String[] {\n+        \"usage: pub {topic} {message}\",\n+        \"\",\n+        \"  {topic}   : topic name.\",\n+        \"              any printable string without spaces.\",\n+        \"  {message} : message body.\",\n+        \"              remaining arguments are used as message body to publish.\",\n+    };\n+\n+    /* SUB : subscriber a topic in hedwig for a specified subscriber */\n+    static final String SUB = \"sub\";\n+    static final String SUB_DESC = \"Subscribe a topic for a specified subscriber\";\n+    static final String[] SUB_USAGE = new String[] {\n+        \"usage: sub {topic} {subscriber} [mode]\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  [mode]       : mode to create subscription.\",\n+        \"  [receive]    : bool. whether to start delivery to receive messages.\",\n+        \"\",\n+        \"  available modes: (default value is 1)\",\n+        \"    0 = CREATE: create subscription.\",\n+        \"                if the subscription is exsited, it will fail.\",\n+        \"    1 = ATTACH: attach to exsited subscription.\",\n+        \"                if the subscription is not existed, it will faile.\",\n+        \"    2 = CREATE_OR_ATTACH:\",\n+        \"                attach to subscription, if not existed create one.\"\n+    };\n+\n+    /* CLOSESUB : close the subscription of a subscriber for a topic */\n+    static final String CLOSESUB = \"closesub\";\n+    static final String CLOSESUB_DESC = \"Close subscription of a subscriber to a specified topic\";\n+    static final String[] CLOSESUB_USAGE = new String[] {\n+        \"usage: closesub {topic} {subscriber}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"\",\n+        \" NOTE: this command just cleanup subscription states on client side.\",\n+        \"       You can try UNSUB to clean subscription states on server side.\",\n+    };\n+\n+    /* UNSUB: unsubscribe of a subscriber to a topic */\n+    static final String UNSUB = \"unsub\";\n+    static final String UNSUB_DESC = \"Unsubscribe a topic for a subscriber\";\n+    static final String[] UNSUB_USAGE = new String[] {\n+        \"usage: unsub {topic} {subscriber}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"\",\n+        \" NOTE: this command will cleanup subscription states on server side.\",\n+        \"       You can try CLOSESUB to just clean subscription states on client side.\",\n+    };\n+\n+    static final String RMSUB = \"rmsub\";\n+    static final String RMSUB_DESC = \"Remove subscriptions for topics\";\n+    static final String[] RMSUB_USAGE = new String[] {\n+        \"usage: rmsub {topic_prefix} {start_topic} {end_topic} {subscriber_prefix} {start_sub} {end_sub}\",\n+        \"\",\n+        \"  {topic_prefix}       : topic prefix.\",\n+        \"  {start_topic}        : start topic id.\",\n+        \"  {end_topic}          : end topic id.\",\n+        \"  {subscriber_prefix}  : subscriber prefix.\",\n+        \"  {start_sub}          : start subscriber id.\",\n+        \"  {end_sub}            : end subscriber id.\",\n+    };\n+\n+    /* CONSUME: move consume ptr of a subscription with specified steps */\n+    static final String CONSUME = \"consume\";\n+    static final String CONSUME_DESC = \"Move consume ptr of a subscription with sepcified steps\";\n+    static final String[] CONSUME_USAGE = new String[] {\n+        \"usage: consume {topic} {subscriber} {nmsgs}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {nmsgs}      : how many messages to move consume ptr.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  suppose, from zk we know subscriber B consumed topic T to message 10\",\n+        \"  [hedwig: (standalone) 1] consume T B 2\",\n+        \"  after executed above command, a consume(10+2) request will be sent to hedwig.\",\n+        \"\",\n+        \"  NOTE:\",\n+        \"  since Hedwig updates subscription consume ptr lazily, so you need to know that\",\n+        \"    1) the consumption ptr read from zookeeper may be stable; \",\n+        \"    2) after sent the consume request, hedwig may just move ptr in its memory and lazily update it to zookeeper. you may not see the ptr changed when DESCRIBE the topic.\",\n+    };\n+\n+    /* CONSUMETO: move consume ptr of a subscription to a specified pos */\n+    static final String CONSUMETO = \"consumeto\";\n+    static final String CONSUMETO_DESC = \"Move consume ptr of a subscription to a specified message id\";\n+    static final String[] CONSUMETO_USAGE = new String[] {\n+        \"usage: consumeto {topic} {subscriber} {msg_id}\",\n+        \"\",\n+        \"  {topic}      : topic name.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {subscriber} : subscriber id.\",\n+        \"                 any printable string without spaces.\",\n+        \"  {msg_id}     : message id that consume ptr will be moved to.\",\n+        \"                 if the message id is less than current consume ptr,\",\n+        \"                 hedwig will do nothing.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  suppose, from zk we know subscriber B consumed topic T to message 10\",\n+        \"  [hedwig: (standalone) 1] consumeto T B 12\",\n+        \"  after executed above command, a consume(12) request will be sent to hedwig.\",\n+        \"\",\n+        \"  NOTE:\",\n+        \"  since Hedwig updates subscription consume ptr lazily, so you need to know that\",\n+        \"    1) the consumption ptr read from zookeeper may be stable; \",\n+        \"    2) after sent the consume request, hedwig may just move ptr in its memory and lazily update it to zookeeper. you may not see the ptr changed when DESCRIBE the topic.\",\n+    };\n+\n+    /* PUBSUB: a healthy checking command to ensure cluster is running */\n+    static final String PUBSUB = \"pubsub\";\n+    static final String PUBSUB_DESC = \"A healthy checking command to ensure hedwig is in running state\";\n+    static final String[] PUBSUB_USAGE = new String[] {\n+        \"usage: pubsub {topic} {subscriber} {timeout_secs} {message}\",\n+        \"\",\n+        \"  {topic}        : topic name.\",\n+        \"                   any printable string without spaces.\",\n+        \"  {subscriber}   : subscriber id.\",\n+        \"                   any printable string without spaces.\",\n+        \"  {timeout_secs} : how long will the subscriber wait for published message.\",\n+        \"  {message}      : message body.\",\n+        \"                   remaining arguments are used as message body to publish.\",\n+        \"\",\n+        \"  Example:\",\n+        \"  [hedwig: (standalone) 1] pubsub TOPIC SUBID 10 TEST_MESSAGS\",\n+        \"\",\n+        \"  1) hw will subscribe topic TOPIC as subscriber SUBID;\",\n+        \"  2) subscriber SUBID will wait a message until 10 seconds;\",\n+        \"  3) hw publishes TEST_MESSAGES to topic TOPIC;\",\n+        \"  4) if subscriber recevied message in 10 secs, it checked that whether the message is published message.\",\n+        \"     if true, it will return SUCCESS, otherwise return FAILED.\",\n+    };\n+\n+    //\n+    // List all commands used to admin hedwig\n+    //\n+\n+    /* SHOW: list all available hub servers or topics */\n+    static final String SHOW = \"show\";\n+    static final String SHOW_DESC = \"list all available hub servers or topics\";\n+    static final String[] SHOW_USAGE = new String[] {\n+        \"usage: show [topics | hubs]\",\n+        \"\",\n+        \"  show topics :\",\n+        \"    listing all available topics in hedwig.\",\n+        \"\",\n+        \"  show hubs :\",\n+        \"    listing all available hubs in hedwig.\",\n+        \"\",\n+        \"  NOTES:\",\n+        \"  'show topics' will not works when there are millions of topics in hedwig, since we have packetLen limitation fetching data from zookeeper.\",\n+    };\n+\n+    static final String SHOW_TOPICS = \"topics\";\n+    static final String SHOW_HUBS   = \"hubs\";\n+\n+    /* DESCRIBE: show the metadata of a topic */\n+    static final String DESCRIBE = \"describe\";\n+    static final String DESCRIBE_DESC = \"show metadata of a topic, including topic owner, persistence info, subscriptions info\";\n+    static final String[] DESCRIBE_USAGE = new String[] {\n+        \"usage: describe topic {topic}\",\n+        \"\",\n+        \"  {topic} : topic name.\",\n+        \"            any printable string without spaces.\",\n+        \"\",\n+        \"  Example: describe topic ttttt\",\n+        \"\",\n+        \"  Output:\",\n+        \"  ===== Topic Information : ttttt =====\",\n+        \"\",\n+        \"  Owner : 98.137.99.27:9875:9876\",\n+        \"\",\n+        \"  >>> Persistence Info <<<\",\n+        \"  Ledger 54729 [ 1 ~ 59 ]\",\n+        \"  Ledger 54731 [ 60 ~ 60 ]\",\n+        \"  Ledger 54733 [ 61 ~ 61 ]\",\n+        \"\",\n+        \"  >>> Subscription Info <<<\",\n+        \"  Subscriber mysub : consumeSeqId: local:50\",\n+    };\n+\n+    static final String DESCRIBE_TOPIC = \"topic\";\n+\n+    /* READTOPIC: read messages of a specified topic */\n+    static final String READTOPIC = \"readtopic\";\n+    static final String READTOPIC_DESC = \"read messages of a specified topic\";\n+    static final String[] READTOPIC_USAGE = new String[] {\n+        \"usage: readtopic {topic} [start_msg_id]\",\n+        \"\",\n+        \"  {topic}        : topic name.\",\n+        \"                   any printable string without spaces.\",\n+        \"  [start_msg_id] : message id that start to read from.\",\n+        \"\",\n+        \"  no start_msg_id provided:\",\n+        \"    it will start from least_consumed_message_id + 1.\",\n+        \"    least_consume_message_id is computed from all its subscribers.\",\n+        \"\",\n+        \"  start_msg_id provided:\",\n+        \"    it will start from MAX(start_msg_id, least_consumed_message_id).\",\n+        \"\",\n+        \"  MESSAGE FORMAT:\",\n+        \"\",\n+        \"  ---------- MSGID=LOCAL(51) ----------\",\n+        \"  MsgId:     LOCAL(51)\",\n+        \"  SrcRegion: standalone\",\n+        \"  Message:\",\n+        \"\",\n+        \"  hello\",\n+    };\n+\n+    /* FORMAT: format metadata for Hedwig */\n+    static final String FORMAT = \"format\";\n+    static final String FORMAT_DESC = \"format metadata for Hedwig\";\n+    static final String[] FORMAT_USAGE = new String[] {\n+        \"usage: format [-force]\",\n+        \"\",\n+        \"  [-force] : Format metadata for Hedwig w/o confirmation.\",\n+    };\n+\n+\n+    //\n+    // List other useful commands\n+    //\n+\n+    /* SET: set whether printing zk watches or not */\n+    static final String SET = \"set\";\n+    static final String SET_DESC = \"set whether printing zk watches or not\";\n+    static final String[] SET_USAGE = EMPTY_ARRAY;\n+\n+    /* HISTORY: list history commands */\n+    static final String HISTORY = \"history\";\n+    static final String HISTORY_DESC = \"list history commands\";\n+    static final String[] HISTORY_USAGE = EMPTY_ARRAY;\n+\n+    /* REDO: redo previous command */\n+    static final String REDO = \"redo\";\n+    static final String REDO_DESC = \"redo history command\";\n+    static final String[] REDO_USAGE = new String[] {\n+        \"usage: redo [{cmdno} | !]\",\n+        \"\",\n+        \"  {cmdno} : history command no.\",\n+        \"  !       : last command.\",\n+    };\n+\n+    /* HELP: print usage information of a specified command */\n+    static final String HELP = \"help\";\n+    static final String HELP_DESC = \"print usage information of a specified command\";\n+    static final String[] HELP_USAGE = new String[] {\n+        \"usage: help {command}\",\n+        \"\",\n+        \"  {command} : command name\",\n+    };\n+\n+    static final String QUIT = \"quit\";\n+    static final String QUIT_DESC = \"exit console\";\n+    static final String[] QUIT_USAGE = EMPTY_ARRAY;\n+\n+    static final String EXIT = \"exit\";\n+    static final String EXIT_DESC = QUIT_DESC;\n+    static final String[] EXIT_USAGE = EMPTY_ARRAY;\n+\n+    public static enum COMMAND {\n+\n+        CMD_PUB (PUB, PUB_DESC, PUB_USAGE),\n+        CMD_SUB (SUB, SUB_DESC, SUB_USAGE),\n+        CMD_CLOSESUB (CLOSESUB, CLOSESUB_DESC, CLOSESUB_USAGE),\n+        CMD_UNSUB (UNSUB, UNSUB_DESC, UNSUB_USAGE),\n+        CMD_RMSUB (RMSUB, RMSUB_DESC, RMSUB_USAGE),\n+        CMD_CONSUME (CONSUME, CONSUME_DESC, CONSUME_USAGE),\n+        CMD_CONSUMETO (CONSUMETO, CONSUMETO_DESC, CONSUMETO_USAGE),\n+        CMD_PUBSUB (PUBSUB, PUBSUB_DESC, PUBSUB_USAGE),\n+        CMD_SHOW (SHOW, SHOW_DESC, SHOW_USAGE),\n+        CMD_DESCRIBE (DESCRIBE, DESCRIBE_DESC, DESCRIBE_USAGE),\n+        CMD_READTOPIC (READTOPIC, READTOPIC_DESC, READTOPIC_USAGE),\n+        CMD_FORMAT (FORMAT, FORMAT_DESC, FORMAT_USAGE),\n+        CMD_SET (SET, SET_DESC, SET_USAGE),\n+        CMD_HISTORY (HISTORY, HISTORY_DESC, HISTORY_USAGE),\n+        CMD_REDO (REDO, REDO_DESC, REDO_USAGE),\n+        CMD_HELP (HELP, HELP_DESC, HELP_USAGE),\n+        CMD_QUIT (QUIT, QUIT_DESC, QUIT_USAGE),\n+        CMD_EXIT (EXIT, EXIT_DESC, EXIT_USAGE),\n+        // sub commands\n+        CMD_SHOW_TOPICS (SHOW_TOPICS, \"\", EMPTY_ARRAY),\n+        CMD_SHOW_HUBS (SHOW_HUBS, \"\", EMPTY_ARRAY),\n+        CMD_DESCRIBE_TOPIC (DESCRIBE_TOPIC, \"\", EMPTY_ARRAY);\n+\n+        COMMAND(String name, String desc, String[] usage) {\n+            this.name = name;\n+            this.desc = desc;\n+            this.usage = usage;\n+            this.subCmds = new LinkedHashMap<String, COMMAND>();\n+        }\n+\n+        public String getName() { return name; }\n+\n+        public String getDescription() { return desc; }\n+\n+        public Map<String, COMMAND> getSubCommands() { return subCmds; }\n+\n+        public void addSubCommand(COMMAND c) {\n+            this.subCmds.put(c.name, c);\n+        };\n+\n+        public void printUsage() {\n+            System.err.println(name + \": \" + desc);\n+            for(String line : usage) {\n+                System.err.println(line);\n+            }\n+            System.err.println();\n+        }\n+\n+        protected String name;\n+        protected String desc;\n+        protected String[] usage;\n+        protected Map<String, COMMAND> subCmds;\n+    }\n+\n+    static Map<String, COMMAND> commands = null;\n+\n+    private static void addCommand(COMMAND c) {\n+        commands.put(c.getName(), c);\n+    }\n+\n+    static synchronized void init() {\n+        if (commands != null) {\n+            return;\n+        }\n+        commands = new LinkedHashMap<String, COMMAND>();\n+\n+        addCommand(COMMAND.CMD_PUB);\n+        addCommand(COMMAND.CMD_SUB);\n+        addCommand(COMMAND.CMD_CLOSESUB);\n+        addCommand(COMMAND.CMD_UNSUB);\n+        addCommand(COMMAND.CMD_RMSUB);\n+        addCommand(COMMAND.CMD_CONSUME);\n+        addCommand(COMMAND.CMD_CONSUMETO);\n+        addCommand(COMMAND.CMD_PUBSUB);\n+\n+        // show\n+        COMMAND.CMD_SHOW.addSubCommand(COMMAND.CMD_SHOW_TOPICS);\n+        COMMAND.CMD_SHOW.addSubCommand(COMMAND.CMD_SHOW_HUBS);\n+        addCommand(COMMAND.CMD_SHOW);\n+\n+        // describe\n+        COMMAND.CMD_DESCRIBE.addSubCommand(COMMAND.CMD_DESCRIBE_TOPIC);\n+        addCommand(COMMAND.CMD_DESCRIBE);\n+\n+        addCommand(COMMAND.CMD_READTOPIC);\n+        addCommand(COMMAND.CMD_FORMAT);\n+        addCommand(COMMAND.CMD_SET);\n+        addCommand(COMMAND.CMD_HISTORY);\n+        addCommand(COMMAND.CMD_REDO);\n+        addCommand(COMMAND.CMD_HELP);\n+        addCommand(COMMAND.CMD_QUIT);\n+        addCommand(COMMAND.CMD_EXIT);\n+    }\n+\n+    public static Map<String, COMMAND> getHedwigCommands() {\n+        return commands;\n+    }\n+\n+    /**\n+     * Find candidate commands by the specified token list\n+     *\n+     * @param token token list\n+     *\n+     * @return list of candidate commands\n+     */\n+    public static List<String> findCandidateCommands(String[] tokens) {\n+        List<String> cmds = new LinkedList<String>();\n+\n+        Map<String, COMMAND> cmdMap = commands;\n+        for (int i=0; i<(tokens.length - 1); i++) {\n+            COMMAND c = cmdMap.get(tokens[i]);\n+            // no commands\n+            if (c == null || c.getSubCommands().size() <= 0) {\n+                return cmds;\n+            } else {\n+                cmdMap = c.getSubCommands();\n+            }\n+        }\n+        cmds.addAll(cmdMap.keySet());\n+        return cmds;\n+    }\n+}"},{"sha":"3a5ef5a5bd4920eebb34e5fbbf8297519a3cdf82","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"added","additions":1038,"deletions":0,"changes":1038,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,1038 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import jline.ConsoleReader;\n+import jline.History;\n+import jline.Terminal;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import org.apache.hedwig.util.SubscriptionListener;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+import static org.apache.hedwig.admin.console.HedwigCommands.*;\n+import static org.apache.hedwig.admin.console.HedwigCommands.COMMAND.*;\n+\n+/**\n+ * Console Client to Hedwig\n+ */\n+public class HedwigConsole {\n+    private static final Logger LOG = LoggerFactory.getLogger(HedwigConsole.class);\n+    // NOTE: now it is fixed passwd in bookkeeper\n+    static byte[] passwd = \"sillysecret\".getBytes(UTF_8);\n+\n+    // history file name\n+    static final String HW_HISTORY_FILE = \".hw_history\";\n+\n+    static final char[] CONTINUE_OR_QUIT = new char[] { 'Q', 'q', '\\n' };\n+\n+    protected MyCommandOptions cl = new MyCommandOptions();\n+    protected HashMap<Integer, String> history = new LinkedHashMap<Integer, String>();\n+    protected int commandCount = 0;\n+    protected boolean printWatches = true;\n+    protected Map<String, MyCommand> myCommands;\n+\n+    protected boolean inConsole = true;\n+    protected ConsoleReader console = null;\n+\n+    protected HedwigAdmin admin;\n+    protected HedwigClient hubClient;\n+    protected Publisher publisher;\n+    protected Subscriber subscriber;\n+    protected ConsoleMessageHandler consoleHandler =\n+            new ConsoleMessageHandler();\n+    protected Terminal terminal;\n+\n+    protected String myRegion;\n+\n+    interface MyCommand {\n+        boolean runCmd(String[] args) throws Exception;\n+    }\n+\n+    static class HelpCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            boolean printUsage = true;\n+            if (args.length >= 2) {\n+                String command = args[1];\n+                COMMAND c = getHedwigCommands().get(command);\n+                if (c != null) {\n+                    c.printUsage();\n+                    printUsage = false;\n+                }\n+            }\n+            if (printUsage) {\n+                usage();\n+            }\n+            return true;\n+        }\n+    }\n+\n+    class ExitCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            printMessage(\"Quitting ...\");\n+            hubClient.close();\n+            admin.close();\n+            Runtime.getRuntime().exit(0);\n+            return true;\n+        }\n+    }\n+\n+    class RedoCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+\n+            int index;\n+            if (\"!\".equals(args[1])) {\n+                index = commandCount - 1;\n+            } else {\n+                index = Integer.decode(args[1]);\n+                if (commandCount <= index) {\n+                    System.err.println(\"Command index out of range\");\n+                    return false;\n+                }\n+            }\n+            cl.parseCommand(history.get(index));\n+            if (cl.getCommand().equals(\"redo\")) {\n+                System.err.println(\"No redoing redos\");\n+                return false;\n+            }\n+            history.put(commandCount, history.get(index));\n+            processCmd(cl);\n+            return true;\n+        }\n+        \n+    }\n+\n+    class HistoryCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            for (int i=commandCount - 10; i<=commandCount; ++i) {\n+                if (i < 0) {\n+                    continue;\n+                }\n+                System.out.println(i + \" - \" + history.get(i));\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class SetCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3 || !\"printwatches\".equals(args[1])) {\n+                return false;\n+            } else if (args.length == 2) {\n+                System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n+            } else {\n+                printWatches = args[2].equals(\"on\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class PubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=2; i<args.length; i++) {\n+                sb.append(args[i]);\n+                if (i != args.length - 1) {\n+                    sb.append(' ');\n+                }\n+            }\n+            ByteString msgBody = ByteString.copyFromUtf8(sb.toString());\n+            Message msg = Message.newBuilder().setBody(msgBody).build();\n+            try {\n+                publisher.publish(topic, msg);\n+                System.out.println(\"PUB DONE\");\n+            } catch (Exception e) {\n+                System.err.println(\"PUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    static class ConsoleMessageHandler implements MessageHandler {\n+\n+        @Override\n+        public void deliver(ByteString topic, ByteString subscriberId,\n+                Message msg, Callback<Void> callback, Object context) {\n+            System.out.println(\"Received message from topic \" + topic.toStringUtf8() + \n+                    \" for subscriber \" + subscriberId.toStringUtf8() + \" : \"\n+                    + msg.getBody().toStringUtf8());\n+            callback.operationFinished(context, null);\n+        }\n+        \n+    }\n+\n+    static class ConsoleSubscriptionListener implements SubscriptionListener {\n+\n+        @Override\n+        public void processEvent(ByteString t, ByteString s, SubscriptionEvent event) {\n+            System.out.println(\"Subscription Channel for (topic:\" + t.toStringUtf8() + \", subscriber:\"\n+                                + s.toStringUtf8() + \") received event : \" + event);\n+        }\n+    }\n+\n+    class SubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            CreateOrAttach mode;\n+            boolean receive = true;\n+            if (args.length < 3) {\n+                return false;\n+            } else if (args.length == 3) {\n+                mode = CreateOrAttach.ATTACH;\n+                receive = true;\n+            } else {\n+                try {\n+                    mode = CreateOrAttach.valueOf(Integer.parseInt(args[3]));\n+                } catch (Exception e) {\n+                    System.err.println(\"Unknow mode : \" + args[3]);\n+                    return false;\n+                }\n+                if (args.length >= 5) {\n+                    try {\n+                        receive = Boolean.parseBoolean(args[4]);\n+                    } catch (Exception e) {\n+                        receive = false;\n+                    }\n+                }\n+            }\n+            if (mode == null) {\n+                System.err.println(\"Unknow mode : \" + args[3]);\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                SubscriptionOptions options =\n+                    SubscriptionOptions.newBuilder().setCreateOrAttach(mode)\n+                                       .setForceAttach(false).build();\n+                subscriber.subscribe(topic, subId, options);\n+                if (receive) {\n+                    subscriber.startDelivery(topic, subId, consoleHandler);\n+                    System.out.println(\"SUB DONE AND RECEIVE\");\n+                } else {\n+                    System.out.println(\"SUB DONE BUT NOT RECEIVE\");\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"SUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+    }\n+\n+    class UnsubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                subscriber.stopDelivery(topic, subId);\n+                subscriber.unsubscribe(topic, subId);\n+                System.out.println(\"UNSUB DONE\");\n+            } catch (Exception e) {\n+                System.err.println(\"UNSUB FAILED\");\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class RmsubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 7) {\n+                return false;\n+            }\n+            String topicPrefix = args[1];\n+            int startTopic = Integer.parseInt(args[2]);\n+            int endTopic = Integer.parseInt(args[3]);\n+            String subPrefix = args[4];\n+            int startSub = Integer.parseInt(args[5]);\n+            int endSub = Integer.parseInt(args[6]);\n+            if (startTopic > endTopic || endSub < startSub) {\n+                return false;\n+            }\n+            for (int i=startTopic; i<=endTopic; i++) {\n+                ByteString topic = ByteString.copyFromUtf8(topicPrefix + i);\n+                try {\n+                    for (int j=startSub; j<=endSub; j++) {\n+                        ByteString sub = ByteString.copyFromUtf8(subPrefix + j);\n+                        SubscriptionOptions opts = SubscriptionOptions.newBuilder()\n+                            .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();\n+                        subscriber.subscribe(topic, sub, opts);\n+                        subscriber.unsubscribe(topic, sub);\n+                    }\n+                    System.out.println(\"RMSUB \" + topic.toStringUtf8() + \" DONE\");\n+                } catch (Exception e) {\n+                    System.err.println(\"RMSUB \" + topic.toStringUtf8() + \" FAILED\");\n+                    e.printStackTrace();\n+                }\n+            }\n+            return true;\n+        }\n+\n+    }\n+    \n+    class CloseSubscriptionCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString sudId = ByteString.copyFromUtf8(args[2]);\n+            \n+            try {\n+                subscriber.stopDelivery(topic, sudId);\n+                subscriber.closeSubscription(topic, sudId);\n+            } catch (Exception e) {\n+                System.err.println(\"CLOSESUB FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+    \n+    class ConsumeToCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 4) {\n+                return false;\n+            }\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            long msgId = Long.parseLong(args[3]);\n+            MessageSeqId consumeId = MessageSeqId.newBuilder().setLocalComponent(msgId).build();\n+            try {\n+                subscriber.consume(topic, subId, consumeId);\n+            } catch (Exception e) {\n+                System.err.println(\"CONSUMETO FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+    \n+    class ConsumeCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 4) {\n+                return false;\n+            }\n+            long lastConsumedId = 0;\n+            SubscriptionData subData = admin.getSubscription(ByteString.copyFromUtf8(args[1]),\n+                                                             ByteString.copyFromUtf8(args[2]));\n+            if (null == subData) {\n+                System.err.println(\"Failed to read subscription for topic: \" + args[1]\n+                                 + \" subscriber: \" + args[2]);\n+                return true;\n+            }\n+            lastConsumedId = subData.getState().getMsgId().getLocalComponent();\n+            long numMessagesToConsume = Long.parseLong(args[3]);\n+            long idToConsumed = lastConsumedId + numMessagesToConsume;\n+            System.out.println(\"Try to move subscriber(\" + args[2] + \") consume ptr of topic(\" + args[1]\n+                             + \") from \" + lastConsumedId + \" to \" + idToConsumed);\n+            MessageSeqId consumeId = MessageSeqId.newBuilder().setLocalComponent(idToConsumed).build();\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            ByteString subId = ByteString.copyFromUtf8(args[2]);\n+            try {\n+                subscriber.consume(topic, subId, consumeId);\n+            } catch (Exception e) {\n+                System.err.println(\"CONSUME FAILED\");\n+            }\n+            return true;\n+        }\n+        \n+    }\n+\n+    class PubSubCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 5) {\n+                return false;\n+            }\n+            final long startTime = MathUtils.now();\n+\n+            final ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            final ByteString subId = ByteString.copyFromUtf8(args[2] + \"-\" + startTime);\n+            int timeoutSecs = 60;\n+            try {\n+                timeoutSecs = Integer.parseInt(args[3]);\n+            } catch (NumberFormatException nfe) {\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=4; i<args.length; i++) {\n+                sb.append(args[i]);\n+                if (i != args.length - 1) {\n+                    sb.append(' ');\n+                }\n+            }\n+            // append a timestamp tag\n+            ByteString msgBody = ByteString.copyFromUtf8(sb.toString() + \"-\" + startTime);\n+            final Message msg = Message.newBuilder().setBody(msgBody).build();\n+\n+            boolean subscribed = false;\n+            boolean success = false;\n+            final CountDownLatch isDone = new CountDownLatch(1);\n+            long elapsedTime = 0L;\n+\n+            System.out.println(\"Starting PUBSUB test ...\");\n+            try {\n+                // sub the topic\n+                SubscriptionOptions opts = SubscriptionOptions.newBuilder()\n+                    .setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();\n+                subscriber.subscribe(topic, subId, opts);\n+                subscribed = true;\n+\n+                System.out.println(\"Sub topic \" + topic.toStringUtf8() + \", subscriber id \" + subId.toStringUtf8());\n+\n+                \n+\n+                // pub topic\n+                publisher.publish(topic, msg);\n+                System.out.println(\"Pub topic \" + topic.toStringUtf8() + \" : \" + msg.getBody().toStringUtf8());\n+\n+                // ensure subscriber first, publish next, then we start delivery to receive message\n+                // if start delivery first before publish, isDone may notify before wait\n+                subscriber.startDelivery(topic, subId, new MessageHandler() {\n+\n+                    @Override\n+                    public void deliver(ByteString thisTopic, ByteString subscriberId,\n+                            Message message, Callback<Void> callback, Object context) {\n+                        if (thisTopic.equals(topic) && subscriberId.equals(subId) &&\n+                            msg.getBody().equals(message.getBody())) {\n+                            System.out.println(\"Received message : \" + message.getBody().toStringUtf8());\n+                            isDone.countDown();\n+                        }\n+                        callback.operationFinished(context, null);\n+                    }\n+\n+                });\n+\n+                // wait for the message\n+                success = isDone.await(timeoutSecs, TimeUnit.SECONDS);\n+                elapsedTime = MathUtils.now() - startTime;\n+            } finally {\n+                try {\n+                    if (subscribed) {\n+                        subscriber.stopDelivery(topic, subId);\n+                        subscriber.unsubscribe(topic, subId);\n+                    }\n+                } finally {\n+                    if (success) {\n+                        System.out.println(\"PUBSUB SUCCESS. TIME: \" + elapsedTime + \" MS\");\n+                    } else {\n+                        System.out.println(\"PUBSUB FAILED. \");\n+                    }\n+                    return success;\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    class ReadTopicCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+            ReadTopic rt;\n+            ByteString topic = ByteString.copyFromUtf8(args[1]);\n+            if (args.length == 2) {\n+                rt = new ReadTopic(admin, topic, inConsole);\n+            } else {\n+                rt = new ReadTopic(admin, topic, Long.parseLong(args[2]), inConsole);\n+            }\n+            rt.readTopic();\n+            return true;\n+        }\n+        \n+    }\n+\n+    class ShowCmd implements MyCommand {\n+\n+        static final int MAX_TOPICS_PER_SHOW = 100;\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 2) {\n+                return false;\n+            }\n+            String errorMsg = null;\n+            try {\n+                if (HedwigCommands.SHOW_HUBS.equals(args[1])) {\n+                    errorMsg = \"Unable to fetch the list of hub servers\";\n+                    showHubs();\n+                } else if (HedwigCommands.SHOW_TOPICS.equals(args[1])) {\n+                    errorMsg = \"Unable to fetch the list of topics\";\n+                    showTopics();\n+                } else {\n+                    System.err.println(\"ERROR: Unknown show command '\" + args[1] + \"'\");\n+                    return false;\n+                }\n+            } catch (Exception e) {\n+                if (null != errorMsg) {\n+                    System.err.println(errorMsg);\n+                }\n+                e.printStackTrace();\n+            }\n+            return true;\n+        }\n+\n+        protected void showHubs() throws Exception {\n+            Map<HedwigSocketAddress, HedwigAdmin.HubStats> hubs = admin.getAvailableHubs();\n+            System.out.println(\"Available Hub Servers:\");\n+            for (Map.Entry<HedwigSocketAddress, HedwigAdmin.HubStats> entry : hubs.entrySet()) {\n+                System.out.println(\"\\t\" + entry.getKey() + \" :\\t\" + entry.getValue());\n+            }\n+        }\n+\n+        protected void showTopics() throws Exception {\n+            List<String> topics = new ArrayList<String>();\n+            Iterator<ByteString> iter = admin.getTopics();\n+\n+            System.out.println(\"Topic List:\");\n+            boolean stop = false;\n+            while (iter.hasNext()) {\n+                if (topics.size() >= MAX_TOPICS_PER_SHOW) {\n+                    System.out.println(topics);\n+                    topics.clear();\n+                    stop = !continueOrQuit();\n+                    if (stop) {\n+                        break;\n+                    }\n+                }\n+                ByteString t = iter.next();\n+                topics.add(t.toStringUtf8());\n+            }\n+            if (!stop) {\n+                System.out.println(topics);\n+            }\n+        }\n+\n+        \n+        \n+    }\n+\n+    class DescribeCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            if (args.length < 3) {\n+                return false;\n+            }\n+            if (HedwigCommands.DESCRIBE_TOPIC.equals(args[1])) {\n+                return describeTopic(args[2]);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        protected boolean describeTopic(String topic) throws Exception {\n+            ByteString btopic = ByteString.copyFromUtf8(topic);\n+            HubInfo owner = admin.getTopicOwner(btopic);\n+            List<LedgerRange> ranges = admin.getTopicLedgers(btopic);\n+            Map<ByteString, SubscriptionData> states = admin.getTopicSubscriptions(btopic);\n+\n+            System.out.println(\"===== Topic Information : \" + topic + \" =====\");\n+            System.out.println();\n+            System.out.println(\"Owner : \" + (owner == null ? \"NULL\" :\n+                               owner.toString().trim().replaceAll(\"\\n\", \", \")));\n+            System.out.println();\n+\n+            // print ledgers\n+            printTopicLedgers(ranges);\n+            // print subscriptions\n+            printTopicSubscriptions(states);\n+\n+            return true;\n+        }\n+\n+        private void printTopicLedgers(List<LedgerRange> ranges) {\n+            System.out.println(\">>> Persistence Info <<<\");\n+            if (null == ranges) {\n+                System.out.println(\"N/A\");\n+                return;\n+            }\n+            if (ranges.isEmpty()) {\n+                System.out.println(\"No Ledger used.\");\n+                return;\n+            }\n+            for (LedgerRange range : ranges) {\n+                System.out.println(\"Ledger \" + range.getLedgerId() + \" [ \"\n+                                   + range.getStartSeqIdIncluded() + \" ~ \"\n+                                   + range.getEndSeqIdIncluded().getLocalComponent() + \" ]\");\n+            }\n+            System.out.println();\n+        }\n+\n+        private void printTopicSubscriptions(Map<ByteString, SubscriptionData> states) {\n+            System.out.println(\">>> Subscription Info <<<\");\n+            if (0 == states.size()) {\n+                System.out.println(\"No subscriber.\");\n+                return;\n+            }\n+            for (Map.Entry<ByteString, SubscriptionData> entry : states.entrySet()) {\n+                System.out.println(\"Subscriber \" + entry.getKey().toStringUtf8() + \" : \"\n+                                 + SubscriptionStateUtils.toString(entry.getValue()));\n+            }\n+            System.out.println();\n+        }\n+\n+    }\n+\n+    class FormatCmd implements MyCommand {\n+\n+        @Override\n+        public boolean runCmd(String[] args) throws Exception {\n+            boolean force = false;\n+            if (args.length >= 2 && \"-force\".equals(args[1])) {\n+                force = true;\n+            }\n+            boolean doFormat = true;\n+            System.out.println(\"You ask to format hedwig metadata stored in \"\n+                               + admin.getMetadataManagerFactory().getClass().getName() + \".\");\n+            if (!force) {\n+                doFormat = continueOrQuit();\n+            }\n+            if (doFormat) {\n+                admin.format();\n+                System.out.println(\"Formatted hedwig metadata successfully.\");\n+            } else {\n+                System.out.println(\"Given up formatting hedwig metadata.\");\n+            }\n+            return true;\n+        }\n+\n+    }\n+\n+    protected Map<String, MyCommand> buildMyCommands() {\n+        Map<String, MyCommand> cmds =\n+                new HashMap<String, MyCommand>();\n+\n+        ExitCmd exitCmd = new ExitCmd();\n+        cmds.put(EXIT, exitCmd);\n+        cmds.put(QUIT, exitCmd);\n+        cmds.put(HELP, new HelpCmd());\n+        cmds.put(HISTORY, new HistoryCmd());\n+        cmds.put(REDO, new RedoCmd());\n+        cmds.put(SET, new SetCmd());\n+        cmds.put(PUB, new PubCmd());\n+        cmds.put(SUB, new SubCmd());\n+        cmds.put(PUBSUB, new PubSubCmd());\n+        cmds.put(CLOSESUB, new CloseSubscriptionCmd());\n+        cmds.put(UNSUB, new UnsubCmd());\n+        cmds.put(RMSUB, new RmsubCmd());\n+        cmds.put(CONSUME, new ConsumeCmd());\n+        cmds.put(CONSUMETO, new ConsumeToCmd());\n+        cmds.put(SHOW, new ShowCmd());\n+        cmds.put(DESCRIBE, new DescribeCmd());\n+        cmds.put(READTOPIC, new ReadTopicCmd());\n+        cmds.put(FORMAT, new FormatCmd());\n+\n+        return cmds;\n+    }\n+\n+    static void usage() {\n+        System.err.println(\"HedwigConsole [options] [command] [args]\");\n+        System.err.println();\n+        System.err.println(\"Avaiable commands:\");\n+        for (String cmd : getHedwigCommands().keySet()) {\n+            System.err.println(\"\\t\" + cmd);\n+        }\n+        System.err.println();\n+    }\n+\n+    /**\n+     * A storage class for both command line options and shell commands.\n+     */\n+    static private class MyCommandOptions {\n+\n+        private Map<String,String> options = new HashMap<String,String>();\n+        private List<String> cmdArgs = null;\n+        private String command = null;\n+\n+        public MyCommandOptions() {\n+        }\n+\n+        public String getOption(String opt) {\n+            return options.get(opt);\n+        }\n+\n+        public String getCommand( ) {\n+            return command;\n+        }\n+\n+        public String getCmdArgument( int index ) {\n+            return cmdArgs.get(index);\n+        }\n+\n+        public int getNumArguments( ) {\n+            return cmdArgs.size();\n+        }\n+\n+        public String[] getArgArray() {\n+            return cmdArgs.toArray(new String[0]);\n+        }\n+\n+        /**\n+         * Parses a command line that may contain one or more flags\n+         * before an optional command string\n+         * @param args command line arguments\n+         * @return true if parsing succeeded, false otherwise.\n+         */\n+        public boolean parseOptions(String[] args) {\n+            List<String> argList = Arrays.asList(args);\n+            Iterator<String> it = argList.iterator();\n+\n+            while (it.hasNext()) {\n+                String opt = it.next();\n+                if (!opt.startsWith(\"-\")) {\n+                    command = opt;\n+                    cmdArgs = new ArrayList<String>( );\n+                    cmdArgs.add( command );\n+                    while (it.hasNext()) {\n+                        cmdArgs.add(it.next());\n+                    }\n+                    return true;\n+                } else {\n+                    try {\n+                        options.put(opt.substring(1), it.next());\n+                    } catch (NoSuchElementException e) {\n+                        System.err.println(\"Error: no argument found for option \"\n+                                + opt);\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+\n+        /**\n+         * Breaks a string into command + arguments.\n+         * @param cmdstring string of form \"cmd arg1 arg2..etc\"\n+         * @return true if parsing succeeded.\n+         */\n+        public boolean parseCommand( String cmdstring ) {\n+            String[] args = cmdstring.split(\" \");\n+            if (args.length == 0){\n+                return false;\n+            }\n+            command = args[0];\n+            cmdArgs = Arrays.asList(args);\n+            return true;\n+        }\n+    }\n+\n+    private class MyWatcher implements Watcher {\n+        public void process(WatchedEvent event) {\n+            if (getPrintWatches()) {\n+                printMessage(\"WATCHER::\");\n+                printMessage(event.toString());\n+            }\n+        }\n+    }\n+\n+    public void printMessage(String msg) {\n+        if (inConsole) {\n+            System.out.println(\"\\n\"+msg);\n+        }\n+    }\n+\n+    /**\n+     * Hedwig Console\n+     *\n+     * @param args arguments\n+     * @throws IOException\n+     * @throws InterruptedException \n+     */\n+    public HedwigConsole(String[] args) throws IOException, InterruptedException {\n+        // Setup Terminal\n+        terminal = Terminal.setupTerminal();\n+        HedwigCommands.init();\n+        cl.parseOptions(args);\n+\n+        if (cl.getCommand() == null) {\n+            inConsole = true;\n+        } else {\n+            inConsole = false;\n+        }\n+\n+        org.apache.bookkeeper.conf.ClientConfiguration bkClientConf =\n+            new org.apache.bookkeeper.conf.ClientConfiguration();\n+        ServerConfiguration hubServerConf = new ServerConfiguration();\n+        String serverCfgFile = cl.getOption(\"server-cfg\");\n+        if (serverCfgFile != null) {\n+            try {\n+                hubServerConf.loadConf(new File(serverCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+            try {\n+                bkClientConf.loadConf(new File(serverCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+        }\n+\n+        ClientConfiguration hubClientCfg = new ClientConfiguration();\n+        String clientCfgFile = cl.getOption(\"client-cfg\");\n+        if (clientCfgFile != null) {\n+            try {\n+                hubClientCfg.loadConf(new File(clientCfgFile).toURI().toURL());\n+            } catch (ConfigurationException e) {\n+                throw new IOException(e);\n+            }\n+        }\n+\n+        printMessage(\"Connecting to zookeeper/bookkeeper using HedwigAdmin\");\n+        try {\n+            admin = new HedwigAdmin(bkClientConf, hubServerConf);\n+            admin.getZkHandle().register(new MyWatcher());\n+        } catch (Exception e) {\n+            throw new IOException(e);\n+        }\n+        \n+        printMessage(\"Connecting to default hub server \" + hubClientCfg.getDefaultServerHost());\n+        hubClient = new HedwigClient(hubClientCfg);\n+        publisher = hubClient.getPublisher();\n+        subscriber = hubClient.getSubscriber();\n+        subscriber.addSubscriptionListener(new ConsoleSubscriptionListener());\n+        \n+        // other parameters\n+        myRegion = hubServerConf.getMyRegion();\n+    }\n+\n+    public boolean getPrintWatches() {\n+        return printWatches;\n+    }\n+\n+    protected String getPrompt() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[hedwig: (\").append(myRegion).append(\") \").append(commandCount).append(\"] \");\n+        return sb.toString();\n+    }\n+\n+    protected boolean continueOrQuit() throws IOException {\n+        System.out.println(\"Press <Return> to continue, or Q to cancel ...\");\n+        int ch;\n+        if (null != console) {\n+            ch = console.readCharacter(CONTINUE_OR_QUIT);\n+        } else {\n+            do {\n+                ch = terminal.readCharacter(System.in);\n+            } while (ch != 'q' && ch != 'Q' && ch != '\\n');\n+        }\n+        if (ch == 'q' ||\n+            ch == 'Q') {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected void addToHistory(int i, String cmd) {\n+        history.put(i, cmd);\n+    }\n+\n+    public void executeLine(String line) {\n+        if (!line.equals(\"\")) {\n+            cl.parseCommand(line);\n+            addToHistory(commandCount, line);\n+            processCmd(cl);\n+            commandCount++;\n+        }\n+    }\n+\n+    protected boolean processCmd(MyCommandOptions co) {\n+        String[] args = co.getArgArray();\n+        String cmd = co.getCommand();\n+        if (args.length < 1) {\n+            usage();\n+            return false;\n+        }\n+        if (!getHedwigCommands().containsKey(cmd)) {\n+            usage();\n+            return false;\n+        }\n+\n+        LOG.debug(\"Processing {}\", cmd);\n+\n+        MyCommand myCommand = myCommands.get(cmd);\n+        if (myCommand == null) {\n+            System.err.println(\"No Command Processor found for command \" + cmd);\n+            usage();\n+            return false;\n+        }\n+\n+        long startTime = MathUtils.now();\n+        boolean success = false;\n+        try {\n+            success = myCommand.runCmd(args);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            success = false;\n+        }\n+        long elapsedTime = MathUtils.now() - startTime;\n+        if (inConsole) {\n+            if (success) {\n+                System.out.println(\"Finished \" + ((double)elapsedTime / 1000) + \" s.\");\n+            } else {\n+                COMMAND c = getHedwigCommands().get(cmd);\n+                if (c != null) {\n+                    c.printUsage();\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    void run() throws IOException {\n+        inConsole = true;\n+        myCommands = buildMyCommands();\n+        if (cl.getCommand() == null) {\n+            System.out.println(\"Welcome to Hedwig!\");\n+            System.out.println(\"JLine support is enabled\");\n+\n+            console = new ConsoleReader();\n+            JLineHedwigCompletor completor = new JLineHedwigCompletor(admin);\n+            console.addCompletor(completor);\n+\n+            // load history file\n+            History history = new History();\n+            File file = new File(System.getProperty(\"hw.history\",\n+                                 new File(System.getProperty(\"user.home\"), HW_HISTORY_FILE).toString()));\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"History file is \" + file.toString());\n+            }\n+            history.setHistoryFile(file);\n+            // set history to console reader\n+            console.setHistory(history);\n+            // load history from history file\n+            history.moveToFirstEntry();\n+\n+            while (history.next()) {\n+                String entry = history.current();\n+                if (!entry.equals(\"\")) {\n+                    addToHistory(commandCount, entry);\n+                }\n+                commandCount++;\n+            }\n+            System.out.println(\"JLine history support is enabled\");\n+\n+            String line;\n+            while ((line = console.readLine(getPrompt())) != null) {\n+                executeLine(line);\n+                history.addToHistory(line);\n+            }\n+        }\n+\n+        inConsole = false;\n+        processCmd(cl);\n+        try {\n+            myCommands.get(EXIT).runCmd(new String[0]);\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        HedwigConsole console = new HedwigConsole(args);\n+        console.run();\n+    }\n+}"},{"sha":"cdc0c339a1917f6da3212bd40f2ead3161e8cce2","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+\n+import com.google.protobuf.ByteString;\n+\n+import jline.Completor;\n+\n+import static org.apache.hedwig.admin.console.HedwigCommands.*;\n+\n+/**\n+ * A jline completor for hedwig console\n+ */\n+public class JLineHedwigCompletor implements Completor {\n+    // for topic completion\n+    static final int MAX_TOPICS_TO_SEARCH = 1000;\n+\n+    private HedwigAdmin admin;\n+\n+    public JLineHedwigCompletor(HedwigAdmin admin) {\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    public int complete(String buffer, int cursor, List candidates) {\n+        // Guarantee that the final token is the one we're expanding\n+        buffer = buffer.substring(0,cursor);\n+        String[] tokens = buffer.split(\" \");\n+        if (buffer.endsWith(\" \")) {\n+            String[] newTokens = new String[tokens.length + 1];\n+            System.arraycopy(tokens, 0, newTokens, 0, tokens.length);\n+            newTokens[newTokens.length - 1] = \"\";\n+            tokens = newTokens;\n+        }\n+        \n+        if (tokens.length > 2 &&\n+            DESCRIBE.equalsIgnoreCase(tokens[0]) &&\n+            DESCRIBE_TOPIC.equalsIgnoreCase(tokens[1])) {\n+            return completeTopic(buffer, tokens[2], candidates);\n+        } else if (tokens.length > 1 &&\n+                   (SUB.equalsIgnoreCase(tokens[0]) ||\n+                    PUB.equalsIgnoreCase(tokens[0]) ||\n+                    CLOSESUB.equalsIgnoreCase(tokens[0]) ||\n+                    CONSUME.equalsIgnoreCase(tokens[0]) ||\n+                    CONSUMETO.equalsIgnoreCase(tokens[0]) ||\n+                    READTOPIC.equalsIgnoreCase(tokens[0]))) {\n+            return completeTopic(buffer, tokens[1], candidates);\n+        }\n+        List cmds = HedwigCommands.findCandidateCommands(tokens);\n+        return completeCommand(buffer, tokens[tokens.length - 1], cmds, candidates);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private int completeCommand(String buffer, String token,\n+            List commands, List candidates) {\n+        for (Object cmdo : commands) {\n+            assert (cmdo instanceof String);\n+            if (((String)cmdo).startsWith(token)) {\n+                candidates.add(cmdo);\n+            }\n+        }\n+        return buffer.lastIndexOf(\" \") + 1;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private int completeTopic(String buffer, String token, List candidates) {\n+        try {\n+            Iterator<ByteString> children = admin.getTopics();\n+            int i = 0;\n+            while (children.hasNext() && i <= MAX_TOPICS_TO_SEARCH) {\n+                String child = children.next().toStringUtf8();\n+                if (child.startsWith(token)) {\n+                    candidates.add(child);\n+                }\n+                ++i;\n+            }\n+        } catch (Exception e) {\n+            return buffer.length();\n+        }\n+        return candidates.size() == 0 ? buffer.length() : buffer.lastIndexOf(\" \") + 1;\n+    }\n+}"},{"sha":"edad190bd2860efa94e89f0b740255d28d9ec191","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","status":"added","additions":332,"deletions":0,"changes":332,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.admin.console;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.hedwig.admin.HedwigAdmin;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.RegionSpecificSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+/**\n+ * A tool to read topic messages.\n+ *\n+ * This tool :\n+ * 1) read persistence info from zookeeper: ledger ranges\n+ * 2) read subscription infor from zookeeper: we can know the least message id (ledger id) \n+ * 3) use bk client to read message starting from least message id\n+ */\n+public class ReadTopic {\n+    \n+    final HedwigAdmin admin;\n+    final ByteString topic;\n+    long startSeqId;\n+    long leastConsumedSeqId = Long.MAX_VALUE;\n+    final boolean inConsole;\n+\n+    static final int RC_OK = 0;\n+    static final int RC_ERROR = -1;\n+    static final int RC_NOTOPIC = -2;\n+    static final int RC_NOLEDGERS = -3;\n+    static final int RC_NOSUBSCRIBERS = -4;\n+    \n+    static final int NUM_MESSAGES_TO_PRINT = 15;\n+\n+    List<LedgerRange> ledgers = new ArrayList<LedgerRange>();\n+    \n+    /**\n+     * Constructor\n+     */\n+    public ReadTopic(HedwigAdmin admin, ByteString topic, boolean inConsole) {\n+        this(admin, topic, 1, inConsole);\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public ReadTopic(HedwigAdmin admin, ByteString topic, long msgSeqId, boolean inConsole) {\n+        this.admin = admin;\n+        this.topic = topic;\n+        this.startSeqId = msgSeqId;\n+        this.inConsole = inConsole;\n+    }\n+    \n+    /**\n+     * Check whether the topic existed or not\n+     *\n+     * @return RC_OK if topic is existed; RC_NOTOPIC if not.\n+     * @throws Exception\n+     */\n+    protected int checkTopic() throws Exception {\n+        return admin.hasTopic(topic) ? RC_OK : RC_NOTOPIC;\n+    }\n+    \n+    /**\n+     * Get the ledgers used by this topic to store messages\n+     *\n+     * @return RC_OK if topic has messages; RC_NOLEDGERS if not.\n+     * @throws Exception\n+     */\n+    protected int getTopicLedgers() throws Exception {\n+        List<LedgerRange> ranges = admin.getTopicLedgers(topic); \n+        if (null == ranges || ranges.isEmpty()) {\n+            return RC_NOLEDGERS;\n+        }\n+        ledgers.addAll(ranges);\n+        return RC_OK;\n+    }\n+    \n+    protected int getLeastSubscription() throws Exception {\n+        Map<ByteString, SubscriptionData> states = admin.getTopicSubscriptions(topic); \n+        if (states.isEmpty()) {\n+            return RC_NOSUBSCRIBERS;\n+        }\n+        for (Map.Entry<ByteString, SubscriptionData> entry : states.entrySet()) {\n+            SubscriptionData state = entry.getValue();\n+            long localMsgId = state.getState().getMsgId().getLocalComponent();\n+            if (localMsgId < leastConsumedSeqId) {\n+                leastConsumedSeqId = localMsgId;\n+            }\n+        }\n+        if (leastConsumedSeqId == Long.MAX_VALUE) {\n+            leastConsumedSeqId = 0;\n+        }\n+        return RC_OK;\n+    }\n+    \n+    public void readTopic() {\n+        try {\n+            int rc = _readTopic();\n+            switch (rc) {\n+            case RC_NOTOPIC:\n+                System.err.println(\"No topic \" + topic + \" found.\");\n+                break;\n+            case RC_NOLEDGERS:\n+                System.err.println(\"No message is published to topic \" + topic);\n+                break;\n+            default:\n+                break;\n+            }\n+        } catch (Exception e) {\n+            System.err.println(\"ERROR: read messages of topic \" + topic + \" failed.\");\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    protected int _readTopic() throws Exception {\n+        int rc;\n+        // check topic\n+        rc = checkTopic();\n+        if (RC_OK != rc) {\n+            return rc;\n+        }\n+        // get topic ledgers\n+        rc = getTopicLedgers();\n+        if (RC_OK != rc) {\n+            return rc;\n+        }\n+        // get topic subscription to find the least one\n+        rc = getLeastSubscription();\n+        if (RC_NOSUBSCRIBERS == rc) {\n+            startSeqId = 1;\n+        } else if (RC_OK == rc) {\n+            if (leastConsumedSeqId > startSeqId) {\n+                startSeqId = leastConsumedSeqId + 1;\n+            }\n+        } else {\n+            return rc;\n+        }\n+\n+        for (LedgerRange range : ledgers) {\n+            long endSeqId = range.getEndSeqIdIncluded().getLocalComponent();\n+            if (endSeqId < startSeqId) {\n+                continue;\n+            }\n+            boolean toContinue = readLedger(range);\n+            startSeqId = endSeqId + 1;\n+            if (!toContinue) {\n+                break;\n+            }\n+        }\n+        \n+        return RC_OK;\n+    }\n+    \n+    /**\n+     * Read a specific ledger\n+     *\n+     * @param ledger in memory ledger range\n+     * @param endSeqId end seq id\n+     * @return true if continue, otherwise false\n+     * @throws BKException\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    protected boolean readLedger(LedgerRange ledger)\n+    throws BKException, IOException, InterruptedException {\n+        long tEndSeqId = ledger.getEndSeqIdIncluded().getLocalComponent();\n+\n+        if (tEndSeqId < this.startSeqId) {\n+            return true;\n+        }\n+        // Open Ledger Handle\n+        long ledgerId = ledger.getLedgerId();\n+        System.out.println(\"\\n>>>>> \" + ledger + \" <<<<<\\n\");\n+        LedgerHandle lh = null;\n+        try {\n+            lh = admin.getBkHandle().openLedgerNoRecovery(ledgerId, admin.getBkDigestType(), admin.getBkPasswd());\n+        } catch (BKException e) {\n+            System.err.println(\"ERROR: No ledger \" + ledgerId + \" found. maybe garbage collected due to the messages are consumed.\");\n+        }\n+        if (null == lh) {\n+            return true;\n+        }\n+        long expectedEntryId = startSeqId - ledger.getStartSeqIdIncluded();\n+        \n+        long correctedEndSeqId = tEndSeqId;\n+        try {\n+            while (startSeqId <= tEndSeqId) {\n+                correctedEndSeqId = Math.min(startSeqId + NUM_MESSAGES_TO_PRINT - 1, tEndSeqId);\n+                \n+                try {\n+                    Enumeration<LedgerEntry> seq =\n+                        lh.readEntries(startSeqId - ledger.getStartSeqIdIncluded(),\n+                                       correctedEndSeqId - ledger.getStartSeqIdIncluded());\n+                    LedgerEntry entry = null;\n+                    while (seq.hasMoreElements()) {\n+                        entry = seq.nextElement();\n+                        Message message;\n+                        try {\n+                            message = Message.parseFrom(entry.getEntryInputStream());\n+                        } catch (IOException e) {\n+                            System.out.println(\"WARN: Unreadable message found\\n\");\n+                            expectedEntryId++;\n+                            continue;\n+                        }\n+                        if (expectedEntryId != entry.getEntryId()\n+                            || (message.getMsgId().getLocalComponent() - ledger.getStartSeqIdIncluded()) != expectedEntryId) {\n+                            throw new IOException(\"ERROR: Message ids are out of order : expected entry id \" + expectedEntryId\n+                                                + \", current entry id \" + entry.getEntryId() + \", msg seq id \" + message.getMsgId().getLocalComponent());\n+                        }\n+                        expectedEntryId++;\n+                        formatMessage(message);\n+\n+                    }\n+                    startSeqId = correctedEndSeqId + 1;\n+                    if (inConsole) {\n+                        if (!pressKeyToContinue()) {\n+                            return false;\n+                        }\n+                    }\n+                } catch (BKException.BKReadException be) {\n+                    throw be;\n+                }\n+            }\n+        } catch (BKException bke) {\n+            if (tEndSeqId != Long.MAX_VALUE) {\n+                System.err.println(\"ERROR: ledger \" + ledgerId + \" may be corrupted, since read messages [\"\n+                                 + startSeqId + \" ~ \" + correctedEndSeqId + \" ] failed :\");\n+                throw bke;\n+            }\n+        }\n+        System.out.println(\"\\n\");\n+        return true;\n+    }\n+    \n+    protected void formatMessage(Message message) {\n+        // print msg id\n+        String msgId;\n+        if (!message.hasMsgId()) {\n+            msgId = \"N/A\";\n+        } else {\n+            MessageSeqId seqId = message.getMsgId();\n+            StringBuilder idBuilder = new StringBuilder();\n+            if (seqId.hasLocalComponent()) {\n+                idBuilder.append(\"LOCAL(\").append(seqId.getLocalComponent()).append(\")\");\n+            } else {\n+                List<RegionSpecificSeqId> remoteIds = seqId.getRemoteComponentsList();\n+                int i = 0, numRegions = remoteIds.size();\n+                idBuilder.append(\"REMOTE(\");\n+                for (RegionSpecificSeqId rssid : remoteIds) {\n+                    idBuilder.append(rssid.getRegion().toStringUtf8());\n+                    idBuilder.append(\"[\");\n+                    idBuilder.append(rssid.getSeqId());\n+                    idBuilder.append(\"]\");\n+                    ++i;\n+                    if (i < numRegions) {\n+                        idBuilder.append(\",\");\n+                    }\n+                }\n+                idBuilder.append(\")\");\n+            }\n+            msgId = idBuilder.toString();\n+        }\n+        System.out.println(\"---------- MSGID=\" + msgId + \" ----------\");\n+        System.out.println(\"MsgId:     \" + msgId);\n+        // print source region\n+        if (message.hasSrcRegion()) {\n+            System.out.println(\"SrcRegion: \" + message.getSrcRegion().toStringUtf8());\n+        } else {\n+            System.out.println(\"SrcRegion: N/A\");\n+        }\n+        // print message body\n+        System.out.println(\"Message:\");\n+        System.out.println();\n+        if (message.hasBody()) {\n+            System.out.println(message.getBody().toStringUtf8());\n+        } else {\n+            System.out.println(\"N/A\");\n+        }\n+        System.out.println();\n+    }\n+    \n+    boolean pressKeyToContinue() throws IOException {\n+        System.out.println(\"Press Y to continue...\");\n+        BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in, UTF_8));\n+        int ch = stdin.read();\n+        if (ch == 'y' ||\n+            ch == 'Y') {\n+            return true;\n+        }\n+        return false;\n+    }\n+}"},{"sha":"8bd56032cb14132916d35eca7800ce7b07d1829e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/data/MessageFormatter.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/data/MessageFormatter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/data/MessageFormatter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/data/MessageFormatter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,123 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.hedwig.data;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.util.EntryFormatter;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.RegionSpecificSeqId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Format a pub sub message into a readable format.\n+ */\n+public class MessageFormatter extends EntryFormatter {\n+    static Logger logger = LoggerFactory.getLogger(MessageFormatter.class);\n+\n+    static final String MESSAGE_PAYLOAD_FORMATTER_CLASS = \"message_payload_formatter_class\";\n+\n+    EntryFormatter dataFormatter = EntryFormatter.STRING_FORMATTER;\n+\n+    @Override\n+    public void setConf(Configuration conf) {\n+        super.setConf(conf);\n+        dataFormatter = EntryFormatter.newEntryFormatter(conf, MESSAGE_PAYLOAD_FORMATTER_CLASS);\n+    }\n+\n+    @Override\n+    public void formatEntry(java.io.InputStream input) {\n+        Message message;\n+        try {\n+            message = Message.parseFrom(input);\n+        } catch (IOException e) {\n+            System.out.println(\"WARN: Unreadable message found\\n\");\n+            EntryFormatter.STRING_FORMATTER.formatEntry(input);\n+            return;\n+        }\n+        formatMessage(message);\n+    }\n+\n+    @Override\n+    public void formatEntry(byte[] data) {\n+        Message message;\n+        try {\n+            message = Message.parseFrom(data);\n+        } catch (IOException e) {\n+            System.out.println(\"WARN: Unreadable message found\\n\");\n+            EntryFormatter.STRING_FORMATTER.formatEntry(data);\n+            return;\n+        }\n+        formatMessage(message);\n+    }\n+\n+    void formatMessage(Message message) {\n+        // print msg id\n+        String msgId;\n+        if (!message.hasMsgId()) {\n+            msgId = \"N/A\";\n+        } else {\n+            MessageSeqId seqId = message.getMsgId();\n+            StringBuilder idBuilder = new StringBuilder();\n+            if (seqId.hasLocalComponent()) {\n+                idBuilder.append(\"LOCAL(\").append(seqId.getLocalComponent()).append(\")\");\n+            } else {\n+                List<RegionSpecificSeqId> remoteIds = seqId.getRemoteComponentsList();\n+                int i = 0, numRegions = remoteIds.size();\n+                idBuilder.append(\"REMOTE(\");\n+                for (RegionSpecificSeqId rssid : remoteIds) {\n+                    idBuilder.append(rssid.getRegion().toStringUtf8());\n+                    idBuilder.append(\"[\");\n+                    idBuilder.append(rssid.getSeqId());\n+                    idBuilder.append(\"]\");\n+                    ++i;\n+                    if (i < numRegions) {\n+                        idBuilder.append(\",\");\n+                    }\n+                }\n+                idBuilder.append(\")\");\n+            }\n+            msgId = idBuilder.toString();\n+        }\n+        System.out.println(\"****** MSGID=\" + msgId + \" ******\");\n+        System.out.println(\"MessageId:      \" + msgId);\n+        // print source region\n+        if (message.hasSrcRegion()) {\n+            System.out.println(\"SrcRegion:      \" + message.getSrcRegion().toStringUtf8());\n+        } else {\n+            System.out.println(\"SrcRegion:      N/A\");\n+        }\n+        // print message body\n+        if (message.hasBody()) {\n+            System.out.println(\"Body:\");\n+            dataFormatter.formatEntry(message.getBody().toByteArray());\n+        } else {\n+            System.out.println(\"Body:           N/A\");\n+        }\n+        System.out.println();\n+    }\n+}"},{"sha":"7f32036f067b31a1fc594018b18bdbc3b37f3073","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","status":"added","additions":106,"deletions":0,"changes":106,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/AbstractBenchmark.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.benchmark;\n+\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+\n+public abstract class AbstractBenchmark {\n+\n+    static final Logger logger = LoggerFactory.getLogger(AbstractBenchmark.class);\n+\n+    AtomicLong totalLatency = new AtomicLong();\n+    LinkedBlockingQueue<Boolean> doneSignalQueue = new LinkedBlockingQueue<Boolean>();\n+\n+    abstract void doOps(int numOps) throws Exception;\n+    abstract void tearDown() throws Exception;\n+\n+    protected class AbstractCallback {\n+        AtomicInteger numDone = new AtomicInteger(0);\n+        Semaphore outstanding;\n+        int numOps;\n+        boolean logging;\n+\n+        public AbstractCallback(Semaphore outstanding, int numOps) {\n+            this.outstanding = outstanding;\n+            this.numOps = numOps;\n+            logging = Boolean.getBoolean(\"progress\");\n+        }\n+\n+        public void handle(boolean success, Object ctx) {\n+            outstanding.release();\n+\n+            if (!success) {\n+                ConcurrencyUtils.put(doneSignalQueue, false);\n+                return;\n+            }\n+\n+            totalLatency.addAndGet(MathUtils.now() - (Long)ctx);\n+            int numDoneInt = numDone.incrementAndGet();\n+\n+            if (logging && numDoneInt % 10000 == 0) {\n+                logger.info(\"Finished \" + numDoneInt + \" ops\");\n+            }\n+\n+            if (numOps == numDoneInt) {\n+                ConcurrencyUtils.put(doneSignalQueue, true);\n+            }\n+        }\n+    }\n+\n+    public void runPhase(String phase, int numOps) throws Exception {\n+        long startTime = MathUtils.now();\n+\n+        doOps(numOps);\n+\n+        if (!doneSignalQueue.take()) {\n+            logger.error(\"One or more operations failed in phase: \" + phase);\n+            throw new RuntimeException();\n+        } else {\n+            logger.info(\"Phase: \" + phase + \" Avg latency : \" + totalLatency.get() / numOps + \", tput = \" + (numOps * 1000/ (MathUtils.now() - startTime)));\n+        }\n+    }\n+\n+\n+\n+\n+\n+    public void run() throws Exception {\n+\n+        int numWarmup = Integer.getInteger(\"nWarmup\", 50000);\n+        runPhase(\"warmup\", numWarmup);\n+\n+        logger.info(\"Sleeping for 10 seconds\");\n+        Thread.sleep(10000);\n+        //reset latency\n+        totalLatency.set(0);\n+\n+        int numOps = Integer.getInteger(\"nOps\", 400000);\n+        runPhase(\"real\", numOps);\n+\n+        tearDown();\n+    }\n+}"},{"sha":"8f47c2f59573d50b397bb7d5bc2eeb5e79b72b07","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","status":"added","additions":105,"deletions":0,"changes":105,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookieBenchmark.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,105 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.benchmark;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+public class BookieBenchmark extends AbstractBenchmark {\n+\n+    static final Logger logger = LoggerFactory.getLogger(BookkeeperBenchmark.class);\n+\n+    BookieClient bkc;\n+    BookieSocketAddress addr;\n+    ClientSocketChannelFactory channelFactory;\n+    OrderedSafeExecutor executor = new OrderedSafeExecutor(1, \"BookieBenchmarkScheduler\");\n+\n+\n+    public BookieBenchmark(String bookieHostPort)  throws Exception {\n+        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n+        bkc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+        String[] hostPort = bookieHostPort.split(\":\");\n+        addr = new BookieSocketAddress(hostPort[0], Integer.parseInt(hostPort[1]));\n+    }\n+\n+\n+    @Override\n+    void doOps(final int numOps) throws Exception {\n+        int numOutstanding = Integer.getInteger(\"nPars\",1000);\n+        final Semaphore outstanding = new Semaphore(numOutstanding);\n+\n+\n+        WriteCallback callback = new WriteCallback() {\n+            AbstractCallback handler = new AbstractCallback(outstanding, numOps);\n+\n+            @Override\n+            public void writeComplete(int rc, long ledgerId, long entryId,\n+            BookieSocketAddress addr, Object ctx) {\n+                handler.handle(rc == BKException.Code.OK, ctx);\n+            }\n+        };\n+\n+        byte[] passwd = new byte[20];\n+        int size = Integer.getInteger(\"size\", 1024);\n+        byte[] data = new byte[size];\n+\n+        for (int i=0; i<numOps; i++) {\n+            outstanding.acquire();\n+\n+            ByteBuffer buffer = ByteBuffer.allocate(44);\n+            long ledgerId = 1000;\n+            buffer.putLong(ledgerId);\n+            buffer.putLong(i);\n+            buffer.putLong(0);\n+            buffer.put(passwd);\n+            buffer.rewind();\n+            ChannelBuffer toSend = ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer.slice()), ChannelBuffers.wrappedBuffer(data));\n+            bkc.addEntry(addr, ledgerId, passwd, i, toSend, callback, MathUtils.now(), 0);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void tearDown() {\n+        bkc.close();\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        BookieBenchmark benchmark = new BookieBenchmark(args[0]);\n+        benchmark.run();\n+    }\n+\n+\n+}"},{"sha":"1b6a4a3239dcfdcc1979add1d4ef4e9e0e5c9ae3","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/BookkeeperBenchmark.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,94 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.benchmark;\n+\n+import java.util.Random;\n+import java.util.concurrent.Semaphore;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.util.MathUtils;\n+import static com.google.common.base.Charsets.UTF_8;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookkeeperBenchmark extends AbstractBenchmark {\n+\n+    static final Logger logger = LoggerFactory.getLogger(BookkeeperBenchmark.class);\n+\n+    BookKeeper bk;\n+    LedgerHandle[] lh;\n+\n+    public BookkeeperBenchmark(String zkHostPort) throws Exception {\n+        bk = new BookKeeper(zkHostPort);\n+        int numLedgers = Integer.getInteger(\"nLedgers\",5);\n+        lh = new LedgerHandle[numLedgers];\n+        int quorumSize = Integer.getInteger(\"quorum\", 2);\n+        int ensembleSize = Integer.getInteger(\"ensemble\", 4);\n+        DigestType digestType = DigestType.valueOf(System.getProperty(\"digestType\", \"CRC32\"));\n+        for (int i=0; i< numLedgers; i++) {\n+            lh[i] = bk.createLedger(ensembleSize, quorumSize, digestType, \"blah\".getBytes(UTF_8));\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    void doOps(final int numOps) throws Exception {\n+        int size = Integer.getInteger(\"size\", 1024);\n+        byte[] msg = new byte[size];\n+\n+        int numOutstanding = Integer.getInteger(\"nPars\",1000);\n+        final Semaphore outstanding = new Semaphore(numOutstanding);\n+\n+        AddCallback callback = new AddCallback() {\n+            AbstractCallback handler = new AbstractCallback(outstanding, numOps);\n+\n+\n+            @Override\n+            public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                handler.handle(rc == BKException.Code.OK, ctx);\n+            }\n+\n+        };\n+\n+\n+\n+        Random rand = new Random();\n+\n+        for (int i=0; i<numOps; i++) {\n+            outstanding.acquire();\n+            lh[rand.nextInt(lh.length)].asyncAddEntry(msg, callback, MathUtils.now());\n+        }\n+\n+\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        bk.close();\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        BookkeeperBenchmark benchmark = new BookkeeperBenchmark(args[0]);\n+        benchmark.run();\n+    }\n+}"},{"sha":"0261dc9e8f27534a0f333864af6246636cbce7b0","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/benchmark/FakeBookie.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,101 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.benchmark;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.Executors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.bootstrap.ServerBootstrap;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.channel.ChannelHandler.Sharable;\n+import org.jboss.netty.channel.ChannelPipelineFactory;\n+import org.jboss.netty.channel.Channels;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.channel.socket.ServerSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\n+import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n+import org.jboss.netty.logging.InternalLoggerFactory;\n+import org.jboss.netty.logging.Log4JLoggerFactory;\n+\n+@Sharable\n+public class FakeBookie extends SimpleChannelHandler implements\n+    ChannelPipelineFactory {\n+    static final Logger logger = LoggerFactory.getLogger(FakeBookie.class);\n+    ServerSocketChannelFactory serverChannelFactory = new NioServerSocketChannelFactory(\n+        Executors.newCachedThreadPool(), Executors.newCachedThreadPool());\n+\n+    public FakeBookie(int port) {\n+        InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n+        ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n+\n+        bootstrap.setPipelineFactory(this);\n+        bootstrap.setOption(\"child.tcpNoDelay\", true);\n+        bootstrap.setOption(\"child.keepAlive\", true);\n+        bootstrap.setOption(\"reuseAddress\", true);\n+\n+        logger.info(\"Going into receive loop\");\n+        // Bind and start to accept incoming connections.\n+        bootstrap.bind(new InetSocketAddress(port));\n+    }\n+\n+    @Override\n+    public ChannelPipeline getPipeline() throws Exception {\n+        ChannelPipeline pipeline = Channels.pipeline();\n+        pipeline.addLast(\"lengthbaseddecoder\",\n+                         new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+        pipeline.addLast(\"main\", this);\n+        return pipeline;\n+    }\n+\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)\n+            throws Exception {\n+        if (!(e.getMessage() instanceof ChannelBuffer)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+\n+        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n+\n+        int type = buffer.readInt();\n+        buffer.readerIndex(24);\n+        long ledgerId = buffer.readLong();\n+        long entryId = buffer.readLong();\n+\n+        ChannelBuffer outBuf = ctx.getChannel().getConfig().getBufferFactory()\n+                               .getBuffer(24);\n+        outBuf.writeInt(type);\n+        outBuf.writeInt(0); // rc\n+        outBuf.writeLong(ledgerId);\n+        outBuf.writeLong(entryId);\n+        e.getChannel().write(outBuf);\n+\n+    }\n+\n+\n+    public static void main(String args[]) {\n+        new FakeBookie(Integer.parseInt(args[0]));\n+    }\n+}"},{"sha":"2611bc0ffe85ca3ea7ae6e7993f576b2f2f835ed","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ByteStringInterner.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,38 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.common;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import com.google.protobuf.ByteString;\n+\n+public class ByteStringInterner {\n+    // TODO: how to release references when strings are no longer used. weak\n+    // references?\n+\n+    private static final ConcurrentMap<ByteString, ByteString> map = new ConcurrentHashMap<ByteString, ByteString>();\n+\n+    public static ByteString intern(ByteString in) {\n+        ByteString presentValueInMap = map.putIfAbsent(in, in);\n+        if (presentValueInMap != null) {\n+            return presentValueInMap;\n+        }\n+        return in;\n+    }\n+}"},{"sha":"237c7dec646a12202b15e56607836f4fce82acab","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"added","additions":666,"deletions":0,"changes":666,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,666 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.common;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.hedwig.conf.AbstractConfiguration;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.topics.HubLoad;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+\n+import com.google.protobuf.ByteString;\n+\n+public class ServerConfiguration extends AbstractConfiguration {\n+    public final static String REGION = \"region\";\n+    protected final static String MAX_MESSAGE_SIZE = \"max_message_size\";\n+    protected final static String READAHEAD_COUNT = \"readahead_count\";\n+    protected final static String READAHEAD_SIZE = \"readahead_size\";\n+    protected final static String CACHE_SIZE = \"cache_size\";\n+    protected final static String CACHE_ENTRY_TTL = \"cache_entry_ttl\";\n+    protected final static String SCAN_BACKOFF_MSEC = \"scan_backoff_ms\";\n+    protected final static String SERVER_PORT = \"server_port\";\n+    protected final static String SSL_SERVER_PORT = \"ssl_server_port\";\n+    protected final static String ZK_PREFIX = \"zk_prefix\";\n+    protected final static String ZK_HOST = \"zk_host\";\n+    protected final static String ZK_TIMEOUT = \"zk_timeout\";\n+    protected final static String READAHEAD_ENABLED = \"readahead_enabled\";\n+    protected final static String STANDALONE = \"standalone\";\n+    protected final static String REGIONS = \"regions\";\n+    protected final static String CERT_NAME = \"cert_name\";\n+    protected final static String CERT_PATH = \"cert_path\";\n+    protected final static String PASSWORD = \"password\";\n+    protected final static String SSL_ENABLED = \"ssl_enabled\";\n+    protected final static String CONSUME_INTERVAL = \"consume_interval\";\n+    protected final static String INIT_NUM_TOPICS = \"init_num_topics\";\n+    protected final static String MAX_NUM_TOPICS = \"max_num_topics\";\n+    protected final static String RETENTION_SECS = \"retention_secs\";\n+    protected final static String RETENTION_SECS_AFTER_ACCESS = \"retention_secs_after_access\";\n+    protected final static String INTER_REGION_SSL_ENABLED = \"inter_region_ssl_enabled\";\n+    protected final static String MESSAGES_CONSUMED_THREAD_RUN_INTERVAL = \"messages_consumed_thread_run_interval\";\n+    protected final static String BK_ENSEMBLE_SIZE = \"bk_ensemble_size\";\n+    @Deprecated\n+    protected final static String BK_QUORUM_SIZE = \"bk_quorum_size\";\n+    protected final static String BK_WRITE_QUORUM_SIZE = \"bk_write_quorum_size\";\n+    protected final static String BK_ACK_QUORUM_SIZE = \"bk_ack_quorum_size\";\n+    protected final static String RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL = \"retry_remote_subscribe_thread_run_interval\";\n+    protected final static String DEFAULT_MESSAGE_WINDOW_SIZE =\n+        \"default_message_window_size\";\n+    protected final static String NUM_READAHEAD_CACHE_THREADS = \"num_readahead_cache_threads\";\n+    protected final static String NUM_DELIVERY_THREADS = \"num_delivery_threads\";\n+\n+    protected final static String MAX_ENTRIES_PER_LEDGER = \"max_entries_per_ledger\";\n+    protected final static String REBALANCE_TOLERANCE_PERCENTAGE = \"rebalance_tolerance\";\n+    protected final static String REBALANCE_MAX_SHED = \"rebalance_max_shed\";\n+    protected final static String REBALANCE_INTERVAL_SEC = \"rebalance_interval_sec\";\n+\n+    // manager related settings\n+    protected final static String METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED = \"metadata_manager_based_topic_manager_enabled\";\n+    protected final static String METADATA_MANAGER_FACTORY_CLASS = \"metadata_manager_factory_class\";\n+\n+    // metastore settings, only being used when METADATA_MANAGER_FACTORY_CLASS is MsMetadataManagerFactory\n+    protected final static String METASTORE_IMPL_CLASS = \"metastore_impl_class\";\n+    protected final static String METASTORE_MAX_ENTRIES_PER_SCAN = \"metastoreMaxEntriesPerScan\";\n+\n+    private static ClassLoader defaultLoader;\n+    static {\n+        defaultLoader = Thread.currentThread().getContextClassLoader();\n+        if (null == defaultLoader) {\n+            defaultLoader = ServerConfiguration.class.getClassLoader();\n+        }\n+    }\n+\n+    // these are the derived attributes\n+    protected ByteString myRegionByteString = null;\n+    protected HedwigSocketAddress myServerAddress = null;\n+    protected List<String> regionList = null;\n+\n+    // Although this method is not currently used, currently maintaining it like\n+    // this so that we can support on-the-fly changes in configuration\n+    protected void refreshDerivedAttributes() {\n+        refreshMyRegionByteString();\n+        refreshMyServerAddress();\n+        refreshRegionList();\n+    }\n+\n+    @Override\n+    public void loadConf(URL confURL) throws ConfigurationException {\n+        super.loadConf(confURL);\n+        refreshDerivedAttributes();\n+    }\n+\n+    public int getMaximumMessageSize() {\n+        return conf.getInt(MAX_MESSAGE_SIZE, 1258291); /* 1.2M */\n+    }\n+\n+    public String getMyRegion() {\n+        return conf.getString(REGION, \"standalone\");\n+    }\n+\n+    protected void refreshMyRegionByteString() {\n+        myRegionByteString = ByteString.copyFromUtf8(getMyRegion());\n+    }\n+\n+    protected void refreshMyServerAddress() {\n+        try {\n+            // Use the raw IP address as the hostname\n+            myServerAddress = new HedwigSocketAddress(InetAddress.getLocalHost().getHostAddress(), getServerPort(),\n+                    getSSLServerPort());\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    // The expected format for the regions parameter is Hostname:Port:SSLPort\n+    // with spaces in between each of the regions.\n+    protected void refreshRegionList() {\n+        String regions = conf.getString(REGIONS, \"\");\n+        if (regions.isEmpty()) {\n+            regionList = new LinkedList<String>();\n+        } else {\n+            regionList = Arrays.asList(regions.split(\" \"));\n+        }\n+    }\n+\n+    public ByteString getMyRegionByteString() {\n+        if (myRegionByteString == null) {\n+            refreshMyRegionByteString();\n+        }\n+        return myRegionByteString;\n+    }\n+\n+    /**\n+     * Maximum number of messages to read ahead. Default is 10.\n+     *\n+     * @return int\n+     */\n+    public int getReadAheadCount() {\n+        return conf.getInt(READAHEAD_COUNT, 10);\n+    }\n+\n+    /**\n+     * Maximum number of bytes to read ahead. Default is 4MB.\n+     *\n+     * @return long\n+     */\n+    public long getReadAheadSizeBytes() {\n+        return conf.getLong(READAHEAD_SIZE, 4 * 1024 * 1024); // 4M\n+    }\n+\n+    /**\n+     * Maximum cache size. By default is the smallest of 2G or\n+     * half the heap size.\n+     *\n+     * @return long\n+     */\n+    public long getMaximumCacheSize() {\n+        // 2G or half of the maximum amount of memory the JVM uses\n+        return conf.getLong(CACHE_SIZE, Math.min(2 * 1024L * 1024L * 1024L, Runtime.getRuntime().maxMemory() / 2));\n+    }\n+\n+    /**\n+     * Cache Entry TTL. By default is 0, cache entry will not be evicted\n+     * until the cache is fullfilled or the messages are already consumed.\n+     * The TTL is only checked when trying adding a new entry into the cache.\n+     *\n+     * @return cache entry ttl.\n+     */\n+    public long getCacheEntryTTL() {\n+        return conf.getLong(CACHE_ENTRY_TTL, 0L);\n+    }\n+\n+    /**\n+     * After a scan of a log fails, how long before we retry (in msec)\n+     *\n+     * @return long\n+     */\n+    public long getScanBackoffPeriodMs() {\n+        return conf.getLong(SCAN_BACKOFF_MSEC, 1000);\n+    }\n+\n+    /**\n+     * Returns server port.\n+     *\n+     * @return int\n+     */\n+    public int getServerPort() {\n+        return conf.getInt(SERVER_PORT, 4080);\n+    }\n+\n+    /**\n+     * Returns SSL server port.\n+     *\n+     * @return int\n+     */\n+    public int getSSLServerPort() {\n+        return conf.getInt(SSL_SERVER_PORT, 9876);\n+    }\n+\n+    /**\n+     * Returns ZooKeeper path prefix.\n+     *\n+     * @return string\n+     */\n+    public String getZkPrefix() {\n+        return conf.getString(ZK_PREFIX, \"/hedwig\");\n+    }\n+\n+    public StringBuilder getZkRegionPrefix(StringBuilder sb) {\n+        return sb.append(getZkPrefix()).append(\"/\").append(getMyRegion());\n+    }\n+\n+    /**\n+     * Get znode path to store manager layouts.\n+     *\n+     * @param sb\n+     *          StringBuilder to store znode path to store manager layouts.\n+     * @return znode path to store manager layouts.\n+     */\n+    public StringBuilder getZkManagersPrefix(StringBuilder sb) {\n+        return getZkRegionPrefix(sb).append(\"/managers\");\n+    }\n+\n+    public StringBuilder getZkTopicsPrefix(StringBuilder sb) {\n+        return getZkRegionPrefix(sb).append(\"/topics\");\n+    }\n+\n+    public StringBuilder getZkTopicPath(StringBuilder sb, ByteString topic) {\n+        return getZkTopicsPrefix(sb).append(\"/\").append(topic.toStringUtf8());\n+    }\n+\n+    public StringBuilder getZkHostsPrefix(StringBuilder sb) {\n+        return getZkRegionPrefix(sb).append(\"/hosts\");\n+    }\n+\n+    public HedwigSocketAddress getServerAddr() {\n+        if (myServerAddress == null) {\n+            refreshMyServerAddress();\n+        }\n+        return myServerAddress;\n+    }\n+\n+    /**\n+     * Return ZooKeeper list of servers. Default is localhost.\n+     *\n+     * @return String\n+     */\n+    public String getZkHost() {\n+        List servers = conf.getList(ZK_HOST, null);\n+        if (null == servers || 0 == servers.size()) {\n+            return \"localhost\";\n+        }\n+        return StringUtils.join(servers, \",\");\n+    }\n+\n+    /**\n+     * Return ZooKeeper session timeout. Default is 2s.\n+     *\n+     * @return int\n+     */\n+    public int getZkTimeout() {\n+        return conf.getInt(ZK_TIMEOUT, 2000);\n+    }\n+\n+    /**\n+     * Returns true if read-ahead enabled. Default is true.\n+     *\n+     * @return boolean\n+     */\n+    public boolean getReadAheadEnabled() {\n+        return conf.getBoolean(READAHEAD_ENABLED, true)\n+            || conf.getBoolean(\"readhead_enabled\");\n+        // the key was misspelt in a previous version, so compensate here\n+    }\n+\n+    /**\n+     * Returns true if standalone. Default is false.\n+     *\n+     * @return boolean\n+     */\n+    public boolean isStandalone() {\n+        return conf.getBoolean(STANDALONE, false);\n+    }\n+\n+    /**\n+     * Returns list of regions.\n+     *\n+     * @return List<String>\n+     */\n+    public List<String> getRegions() {\n+        if (regionList == null) {\n+            refreshRegionList();\n+        }\n+        return regionList;\n+    }\n+\n+    /**\n+     *  Returns the name of the SSL certificate if available as a resource.\n+     *\n+     * @return String\n+     */\n+    public String getCertName() {\n+        return conf.getString(CERT_NAME, \"\");\n+    }\n+\n+    /**\n+     * This is the path to the SSL certificate if it is available as a file.\n+     *\n+     * @return String\n+     */\n+    public String getCertPath() {\n+        return conf.getString(CERT_PATH, \"\");\n+    }\n+\n+    // This method return the SSL certificate as an InputStream based on if it\n+    // is configured to be available as a resource or as a file. If nothing is\n+    // configured correctly, then a ConfigurationException will be thrown as\n+    // we do not know how to obtain the SSL certificate stream.\n+    public InputStream getCertStream() throws FileNotFoundException, ConfigurationException {\n+        String certName = getCertName();\n+        String certPath = getCertPath();\n+        if (certName != null && !certName.isEmpty()) {\n+            return getClass().getResourceAsStream(certName);\n+        } else if (certPath != null && !certPath.isEmpty()) {\n+            return new FileInputStream(certPath);\n+        } else\n+            throw new ConfigurationException(\"SSL Certificate configuration does not have resource name or path set!\");\n+    }\n+\n+    /**\n+     * Returns the password used for BookKeeper ledgers. Default\n+     * is the empty string.\n+     *\n+     * @return\n+     */\n+    public String getPassword() {\n+        return conf.getString(PASSWORD, \"\");\n+    }\n+\n+    /**\n+     * Returns true if SSL is enabled. Default is false.\n+     *\n+     * @return boolean\n+     */\n+    public boolean isSSLEnabled() {\n+        return conf.getBoolean(SSL_ENABLED, false);\n+    }\n+\n+    /**\n+     * Gets the number of messages consumed before persisting\n+     * information about consumed messages. A value greater than\n+     * one avoids persisting information about consumed messages\n+     * upon every consumed message. Default is 50.\n+     *\n+     * @return int\n+     */\n+    public int getConsumeInterval() {\n+        return conf.getInt(CONSUME_INTERVAL, 50);\n+    }\n+\n+    /**\n+     * Returns the interval to release a topic. If this\n+     * parameter is greater than zero, then schedule a\n+     * task to release an owned topic. Default is 0 (never released).\n+     *\n+     * @return int\n+     */\n+    public int getRetentionSecs() {\n+        return conf.getInt(RETENTION_SECS, 0);\n+    }\n+\n+    /**\n+     * Specifies that the topic should be automatically released\n+     * once a fixed duration after the topic is owned, a message is\n+     * published, or a message is delivered.\n+     *\n+     * @return the length of time after an entry is last accessed that\n+     *         it should be automatically removed.\n+     */\n+    public int getRetentionSecsAfterAccess() {\n+        return conf.getInt(RETENTION_SECS_AFTER_ACCESS, 0);\n+    }\n+\n+    /**\n+     * Max number of topics for a hub server to serve.\n+     *\n+     * @return max number of topics for a hub server to serve.\n+     */\n+    public int getMaxNumTopics() {\n+        return conf.getInt(MAX_NUM_TOPICS, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Minimum size of internal structure to store topics.\n+     *\n+     * @return init number of topics for a hub server.\n+     */\n+    public int getInitNumTopics() {\n+        return conf.getInt(INIT_NUM_TOPICS, 128);\n+    }\n+\n+    /**\n+     * True if SSL is enabled across regions.\n+     *\n+     * @return boolean\n+     */\n+    public boolean isInterRegionSSLEnabled() {\n+        return conf.getBoolean(INTER_REGION_SSL_ENABLED, false);\n+    }\n+\n+    /**\n+     * This parameter is used to determine how often we run the\n+     * SubscriptionManager's Messages Consumed timer task thread\n+     * (in milliseconds).\n+     *\n+     * @return int\n+     */\n+    public int getMessagesConsumedThreadRunInterval() {\n+        return conf.getInt(MESSAGES_CONSUMED_THREAD_RUN_INTERVAL, 60000);\n+    }\n+\n+    /**\n+     * This parameter is used to determine how often we run a thread\n+     * to retry those failed remote subscriptions in asynchronous mode\n+     * (in milliseconds).\n+     *\n+     * @return int\n+     */\n+    public int getRetryRemoteSubscribeThreadRunInterval() {\n+        return conf.getInt(RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL, 120000);\n+    }\n+\n+    /**\n+     * This parameter is for setting the default maximum number of messages which\n+     * can be delivered to a subscriber without being consumed.\n+     * we pause messages delivery to a subscriber when reaching the window size\n+     *\n+     * @return int\n+     */\n+    public int getDefaultMessageWindowSize() {\n+        return conf.getInt(DEFAULT_MESSAGE_WINDOW_SIZE, 0);\n+    }\n+\n+    /**\n+     * This parameter is used when Bookkeeper is the persistence\n+     * store and indicates what the ensemble size is (i.e. how\n+     * many bookie servers to stripe the ledger entries across).\n+     *\n+     * @return int\n+     */\n+    public int getBkEnsembleSize() {\n+        return conf.getInt(BK_ENSEMBLE_SIZE, 3);\n+    }\n+\n+\n+    /**\n+     * This parameter is used when Bookkeeper is the persistence store\n+     * and indicates what the quorum size is (i.e. how many redundant\n+     * copies of each ledger entry is written).\n+     *\n+     * @return int\n+     * @deprecated please use #getBkWriteQuorumSize() and #getBkAckQuorumSize()\n+     */\n+    @Deprecated\n+    protected int getBkQuorumSize() {\n+        return conf.getInt(BK_QUORUM_SIZE, 2);\n+    }\n+\n+    /**\n+     * Get the write quorum size for BookKeeper client, which is used to\n+     * indicate how many redundant copies of each ledger entry is written.\n+     *\n+     * @return write quorum size for BookKeeper client.\n+     */\n+    public int getBkWriteQuorumSize() {\n+        if (conf.containsKey(BK_WRITE_QUORUM_SIZE)) {\n+            return conf.getInt(BK_WRITE_QUORUM_SIZE, 2);\n+        } else {\n+            return getBkQuorumSize();\n+        }\n+    }\n+\n+    /**\n+     * Get the ack quorum size for BookKeeper client.\n+     *\n+     * @return ack quorum size for BookKeeper client.\n+     */\n+    public int getBkAckQuorumSize() {\n+        if (conf.containsKey(BK_ACK_QUORUM_SIZE)) {\n+            return conf.getInt(BK_ACK_QUORUM_SIZE, 2);\n+        } else {\n+            return getBkQuorumSize();\n+        }\n+    }\n+\n+    /**\n+     * This parameter is used when BookKeeper is the persistence storage,\n+     * and indicates when the number of entries stored in a ledger reach\n+     * the threshold, hub server will open a new ledger to write.\n+     *\n+     * @return max entries per ledger\n+     */\n+    public long getMaxEntriesPerLedger() {\n+        return conf.getLong(MAX_ENTRIES_PER_LEDGER, 0L);\n+    }\n+\n+    /**\n+     * Get the tolerance percentage for the rebalancer. The rebalancer will not\n+     * shed load if it's current load is less than average + average*tolerancePercentage/100.0\n+     *\n+     * @return the tolerance percentage for the rebalancer.\n+     */\n+    public double getRebalanceTolerance() {\n+        return conf.getDouble(REBALANCE_TOLERANCE_PERCENTAGE, 10.0);\n+    }\n+\n+    /**\n+     * Get the maximum load the rebalancer can shed at once. Default is 50.\n+     * @return\n+     */\n+    public HubLoad getRebalanceMaxShed() {\n+        return new HubLoad(conf.getLong(REBALANCE_MAX_SHED, 50));\n+    }\n+\n+    /**\n+     * Get the interval(in seconds) between rebalancing attempts. The default is\n+     * 5 minutes.\n+     * @return\n+     */\n+    public long getRebalanceInterval() {\n+        return conf.getLong(REBALANCE_INTERVAL_SEC, 300);\n+    }\n+\n+    /*\n+     * Is this a valid configuration that we can run with? This code might grow\n+     * over time.\n+     */\n+    public void validate() throws ConfigurationException {\n+        if (!getZkPrefix().startsWith(\"/\")) {\n+            throw new ConfigurationException(ZK_PREFIX + \" must start with a /\");\n+        }\n+        // Validate that if Regions exist and inter-region communication is SSL\n+        // enabled, that the Regions correspond to valid HedwigSocketAddresses,\n+        // namely that SSL ports are present.\n+        if (isInterRegionSSLEnabled() && getRegions().size() > 0) {\n+            for (String hubString : getRegions()) {\n+                HedwigSocketAddress hub = new HedwigSocketAddress(hubString);\n+                if (hub.getSSLSocketAddress() == null)\n+                    throw new ConfigurationException(\"Region defined does not have required SSL port: \" + hubString);\n+            }\n+        }\n+        // Validate that the Bookkeeper ensemble size >= quorum size.\n+        if (getBkEnsembleSize() < getBkWriteQuorumSize()) {\n+            throw new ConfigurationException(\"BK ensemble size (\" + getBkEnsembleSize()\n+                                             + \") is less than the write quorum size (\" + getBkWriteQuorumSize() + \")\");\n+        }\n+\n+        if (getBkWriteQuorumSize() < getBkAckQuorumSize()) {\n+            throw new ConfigurationException(\"BK write quorum size (\" + getBkWriteQuorumSize()\n+                                             + \") is less than the ack quorum size (\" + getBkAckQuorumSize() + \")\");\n+        }\n+        // Validate that the rebalance tolerance percentage is not negative.\n+        if (getRebalanceTolerance() < 0.0) {\n+            throw new ConfigurationException(\"The rebalance tolerance percentage cannot be negative.\");\n+        }\n+        // Validate that the maximum load to shed during a rebalance is not negative.\n+        if (getRebalanceMaxShed().getNumTopics() < 0L) {\n+            throw new ConfigurationException(\"The maximum load to shed during a rebalance cannot be negative.\");\n+        }\n+        // add other checks here\n+    }\n+\n+    /**\n+     * Get number of read ahead cache threads.\n+     *\n+     * @return number of read ahead cache threads.\n+     */\n+    public int getNumReadAheadCacheThreads() {\n+        return conf.getInt(NUM_READAHEAD_CACHE_THREADS, Runtime.getRuntime().availableProcessors());\n+    }\n+\n+    /**\n+     * Get number of delivery threads\n+     *\n+     * @return number of delivery threads.\n+     */\n+    public int getNumDeliveryThreads() {\n+        return conf.getInt(NUM_DELIVERY_THREADS, Runtime.getRuntime().availableProcessors());\n+    }\n+\n+    /**\n+     * Whether enable metadata manager based topic manager.\n+     *\n+     * @return true if enabled metadata manager based topic manager.\n+     */\n+    public boolean isMetadataManagerBasedTopicManagerEnabled() {\n+        return conf.getBoolean(METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED, false);\n+    }\n+\n+    /**\n+     * Get metadata manager factory class.\n+     *\n+     * @return manager class\n+     */\n+    public Class<? extends MetadataManagerFactory> getMetadataManagerFactoryClass()\n+    throws ConfigurationException {\n+        return ReflectionUtils.getClass(conf, METADATA_MANAGER_FACTORY_CLASS,\n+                                        null, MetadataManagerFactory.class,\n+                                        defaultLoader);\n+    }\n+\n+    /**\n+     * Set metadata manager factory class name\n+     *\n+     * @param managerClsName\n+     *          Manager Class Name\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMetadataManagerFactoryName(String managerClsName) {\n+        conf.setProperty(METADATA_MANAGER_FACTORY_CLASS, managerClsName);\n+        return this;\n+    }\n+\n+    /**\n+     * Get metastore implementation class.\n+     *\n+     * @return metastore implementation class name.\n+     */\n+    public String getMetastoreImplClass() {\n+        return conf.getString(METASTORE_IMPL_CLASS);\n+    }\n+\n+    /**\n+     * Get max entries per scan in metastore.\n+     *\n+     * @return max entries per scan in metastore.\n+     */\n+    public int getMetastoreMaxEntriesPerScan() {\n+        return conf.getInt(METASTORE_MAX_ENTRIES_PER_SCAN, 50);\n+    }\n+}"},{"sha":"3751092896f67dbf46e2daba6d9b49b458d4d70e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,32 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.common;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TerminateJVMExceptionHandler implements Thread.UncaughtExceptionHandler {\n+    static Logger logger = LoggerFactory.getLogger(TerminateJVMExceptionHandler.class);\n+\n+    @Override\n+    public void uncaughtException(Thread t, Throwable e) {\n+        logger.error(\"Uncaught exception in thread \" + t.getName(), e);\n+        Runtime.getRuntime().exit(1);\n+    }\n+\n+}"},{"sha":"3c4a56286f76bdc08602177c004da5de5f4ed990","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/TopicOpQueuer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,111 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.common;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.util.Callback;\n+\n+public class TopicOpQueuer {\n+    /**\n+     * Map from topic to the queue of operations for that topic.\n+     */\n+    protected HashMap<ByteString, Queue<Runnable>> topic2ops = new HashMap<ByteString, Queue<Runnable>>();\n+\n+    protected final ScheduledExecutorService scheduler;\n+\n+    public TopicOpQueuer(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public interface Op extends Runnable {\n+    }\n+\n+    public abstract class AsynchronousOp<T> implements Op {\n+        final public ByteString topic;\n+        final public Callback<T> cb;\n+        final public Object ctx;\n+\n+        public AsynchronousOp(final ByteString topic, final Callback<T> cb, Object ctx) {\n+            this.topic = topic;\n+            this.cb = new Callback<T>() {\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    cb.operationFailed(ctx, exception);\n+                    popAndRunNext(topic);\n+                }\n+\n+                @Override\n+                public void operationFinished(Object ctx, T resultOfOperation) {\n+                    cb.operationFinished(ctx, resultOfOperation);\n+                    popAndRunNext(topic);\n+                }\n+            };\n+            this.ctx = ctx;\n+        }\n+    }\n+\n+    public abstract class SynchronousOp implements Op {\n+        final public ByteString topic;\n+\n+        public SynchronousOp(ByteString topic) {\n+            this.topic = topic;\n+        }\n+\n+        @Override\n+        public final void run() {\n+            runInternal();\n+            popAndRunNext(topic);\n+        }\n+\n+        protected abstract void runInternal();\n+\n+    }\n+\n+    protected synchronized void popAndRunNext(ByteString topic) {\n+        Queue<Runnable> ops = topic2ops.get(topic);\n+        if (!ops.isEmpty())\n+            ops.remove();\n+        if (!ops.isEmpty())\n+            scheduler.submit(ops.peek());\n+    }\n+\n+    public void pushAndMaybeRun(ByteString topic, Op op) {\n+        int size;\n+        synchronized (this) {\n+            Queue<Runnable> ops = topic2ops.get(topic);\n+            if (ops == null) {\n+                ops = new LinkedList<Runnable>();\n+                topic2ops.put(topic, ops);\n+            }\n+            ops.add(op);\n+            size = ops.size();\n+        }\n+        if (size == 1)\n+            op.run();\n+    }\n+\n+    public Runnable peek(ByteString topic) {\n+        return topic2ops.get(topic).peek();\n+    }\n+}"},{"sha":"364ffdc766ed00abde16c049e35613ac7c48c1da","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/common/UnexpectedError.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,35 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.common;\n+\n+public class UnexpectedError extends Error {\n+\n+    /**\n+     *\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    public UnexpectedError(String msg) {\n+        super(msg);\n+    }\n+\n+    public UnexpectedError(Throwable cause) {\n+        super(cause);\n+    }\n+\n+}"},{"sha":"e7dc1fa0b70e19536aaaef8d23d4b6e64e77295e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,90 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.server.common.UnexpectedError;\n+\n+public class ChannelEndPoint implements DeliveryEndPoint, ChannelFutureListener {\n+\n+    Channel channel;\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    Map<ChannelFuture, DeliveryCallback> callbacks = new HashMap<ChannelFuture, DeliveryCallback>();\n+\n+    public ChannelEndPoint(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public void close() {\n+        channel.close();\n+    }\n+\n+    public void send(PubSubResponse response, DeliveryCallback callback) {\n+        ChannelFuture future = channel.write(response);\n+        callbacks.put(future, callback);\n+        future.addListener(this);\n+    }\n+\n+    public void operationComplete(ChannelFuture future) throws Exception {\n+        DeliveryCallback callback = callbacks.get(future);\n+        callbacks.remove(future);\n+\n+        if (callback == null) {\n+            throw new UnexpectedError(\"Could not locate callback for channel future\");\n+        }\n+\n+        if (future.isSuccess()) {\n+            callback.sendingFinished();\n+        } else {\n+            // treat all channel errors as permanent\n+            callback.permanentErrorOnSend();\n+        }\n+\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof ChannelEndPoint) {\n+            ChannelEndPoint channelEndPoint = (ChannelEndPoint) obj;\n+            return channel.equals(channelEndPoint.channel);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return channel.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return channel.toString();\n+    }\n+}"},{"sha":"9ee63f154f94cef14e71a6fb400ac7d6b4d3bcce","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+public interface DeliveryCallback {\n+\n+    public void sendingFinished();\n+\n+    public void transientErrorOnSend();\n+\n+    public void permanentErrorOnSend();\n+}"},{"sha":"077480122194b7e28d326084585d890a69f77a4a","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryEndPoint.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,28 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+\n+public interface DeliveryEndPoint {\n+\n+    public void send(PubSubResponse response, DeliveryCallback callback);\n+\n+    public void close();\n+\n+}"},{"sha":"af3d15061eb7cb3b77281688888449505b410ae2","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,92 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.filter.ServerMessageFilter;\n+import org.apache.hedwig.util.Callback;\n+\n+public interface DeliveryManager {\n+    public void start();\n+\n+    /**\n+     * Start serving a given subscription.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param preferences\n+     *          Subscription Preferences\n+     * @param seqIdToStartFrom\n+     *          Message sequence id starting delivery from.\n+     * @param endPoint\n+     *          End point to deliver messages to.\n+     * @param filter\n+     *          Message filter used to filter messages before delivery.\n+     * @param callback\n+     *          Callback instance.\n+     * @param ctx\n+     *          Callback context.\n+     */\n+    public void startServingSubscription(ByteString topic, ByteString subscriberId,\n+                                         SubscriptionPreferences preferences,\n+                                         MessageSeqId seqIdToStartFrom,\n+                                         DeliveryEndPoint endPoint,\n+                                         ServerMessageFilter filter,\n+                                         Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Stop serving a given subscription.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param event\n+     *          Subscription event indicating the reason to stop the subscriber.\n+     * @param callback\n+     *          Callback instance.\n+     * @param ctx\n+     *          Callback context.\n+     */\n+    public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n+                                      SubscriptionEvent event,\n+                                      Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Tell the delivery manager where that a subscriber has consumed\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param consumedSeqId\n+     *          Max consumed seq id.\n+     */\n+    public void messageConsumed(ByteString topic, ByteString subscriberId,\n+                                MessageSeqId consumedSeqId);\n+\n+    /**\n+     * Stop delivery manager\n+     */\n+    public void stop();\n+}"},{"sha":"282b3b8e877643a88b69ec14b9e14a284b71c621","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"added","additions":979,"deletions":0,"changes":979,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,979 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.delivery;\n+\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.PriorityBlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.filter.ServerMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.common.UnexpectedError;\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager.SubChannelDisconnectedListener;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.persistence.CancelScanRequest;\n+import org.apache.hedwig.server.persistence.Factory;\n+import org.apache.hedwig.server.persistence.MapMethods;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.persistence.ReadAheadCache;\n+import org.apache.hedwig.server.persistence.ScanCallback;\n+import org.apache.hedwig.server.persistence.ScanRequest;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class FIFODeliveryManager implements DeliveryManager, SubChannelDisconnectedListener {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(FIFODeliveryManager.class);\n+\n+    private static Callback<Void> NOP_CALLBACK = new Callback<Void>() {\n+        @Override\n+        public void operationFinished(Object ctx, Void result) {\n+        }\n+        @Override\n+        public void operationFailed(Object ctx, PubSubException exception) {\n+        }\n+    };\n+\n+    protected interface DeliveryManagerRequest {\n+        public void performRequest();\n+    }\n+\n+    /**\n+     * Stores a mapping from topic to the delivery pointers on the topic. The\n+     * delivery pointers are stored in a sorted map from seq-id to the set of\n+     * subscribers at that seq-id\n+     */\n+    ConcurrentMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>> perTopicDeliveryPtrs;\n+\n+    /**\n+     * Mapping from delivery end point to the subscriber state that we are\n+     * serving at that end point. This prevents us e.g., from serving two\n+     * subscriptions to the same endpoint\n+     */\n+    ConcurrentMap<TopicSubscriber, ActiveSubscriberState> subscriberStates;\n+\n+    private final ReadAheadCache cache;\n+    private final PersistenceManager persistenceMgr;\n+    private TopicManager tm;\n+    private ServerConfiguration cfg;\n+\n+    private final int numDeliveryWorkers;\n+    private final DeliveryWorker[] deliveryWorkers;\n+\n+    private class DeliveryWorker implements Runnable {\n+\n+        BlockingQueue<DeliveryManagerRequest> requestQueue =\n+            new LinkedBlockingQueue<DeliveryManagerRequest>();;\n+\n+        /**\n+         * The queue of all subscriptions that are facing a transient error either\n+         * in scanning from the persistence manager, or in sending to the consumer\n+         */\n+        Queue<ActiveSubscriberState> retryQueue =\n+            new PriorityBlockingQueue<ActiveSubscriberState>(32, new Comparator<ActiveSubscriberState>() {\n+                @Override\n+                public int compare(ActiveSubscriberState as1, ActiveSubscriberState as2) {\n+                    long s = as1.lastScanErrorTime - as2.lastScanErrorTime;\n+                    return s > 0 ? 1 : (s < 0 ? -1 : 0);\n+                }\n+            });\n+\n+        // Boolean indicating if this thread should continue running. This is used\n+        // when we want to stop the thread during a PubSubServer shutdown.\n+        protected volatile boolean keepRunning = true;\n+        private final Thread workerThread;\n+        private final int idx;\n+\n+        private final Object suspensionLock = new Object();\n+        private boolean suspended = false;\n+\n+        DeliveryWorker(int index) {\n+            this.idx = index;\n+            workerThread = new Thread(this, \"DeliveryManagerThread-\" + index);\n+        }\n+\n+        void start() {\n+            workerThread.start();\n+        }\n+\n+        /**\n+         * Stop method which will enqueue a ShutdownDeliveryManagerRequest.\n+         */\n+        void stop() {\n+            enqueueWithoutFailure(new ShutdownDeliveryManagerRequest());\n+        }\n+\n+        /**\n+         * Stop FIFO delivery worker from processing requests. (for testing)\n+         */\n+        void suspendProcessing() {\n+            synchronized(suspensionLock) {\n+                suspended = true;\n+            }\n+        }\n+\n+        /**\n+         * Resume FIFO delivery worker. (for testing)\n+         */\n+        void resumeProcessing() {\n+            synchronized(suspensionLock) {\n+                suspended = false;\n+                suspensionLock.notify();\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (keepRunning) {\n+                DeliveryManagerRequest request = null;\n+\n+                try {\n+                    // We use a timeout of 1 second, so that we can wake up once in\n+                    // a while to check if there is something in the retry queue.\n+                    request = requestQueue.poll(1, TimeUnit.SECONDS);\n+                    synchronized(suspensionLock) {\n+                        while (suspended) {\n+                            suspensionLock.wait();\n+                        }\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+\n+                // First retry any subscriptions that had failed and need a retry\n+                retryErroredSubscribers();\n+\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                request.performRequest();\n+\n+            }\n+        }\n+\n+        protected void enqueueWithoutFailure(DeliveryManagerRequest request) {\n+            if (!requestQueue.offer(request)) {\n+                throw new UnexpectedError(\"Could not enqueue object: \" + request\n+                    + \" to request queue for delivery worker .\" + idx);\n+            }\n+        }\n+\n+        public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n+            subscriber.setLastScanErrorTime(MathUtils.now());\n+\n+            if (!retryQueue.offer(subscriber)) {\n+                throw new UnexpectedError(\"Could not enqueue to retry queue for delivery worker \" + idx);\n+            }\n+        }\n+\n+        public void clearRetryDelayForSubscriber(ActiveSubscriberState subscriber) {\n+            subscriber.clearLastScanErrorTime();\n+            if (!retryQueue.offer(subscriber)) {\n+                throw new UnexpectedError(\"Could not enqueue to delivery manager retry queue\");\n+            }\n+            // no request in request queue now\n+            // issue a empty delivery request to not waiting for polling requests queue\n+            if (requestQueue.isEmpty()) {\n+                enqueueWithoutFailure(new DeliveryManagerRequest() {\n+                        @Override\n+                        public void performRequest() {\n+                        // do nothing\n+                        }\n+                        });\n+            }\n+        }\n+\n+        protected void retryErroredSubscribers() {\n+            long lastInterestingFailureTime = MathUtils.now() - cfg.getScanBackoffPeriodMs();\n+            ActiveSubscriberState subscriber;\n+\n+            while ((subscriber = retryQueue.peek()) != null) {\n+                if (subscriber.getLastScanErrorTime() > lastInterestingFailureTime) {\n+                    // Not enough time has elapsed yet, will retry later\n+                    // Since the queue is fifo, no need to check later items\n+                    return;\n+                }\n+\n+                // retry now\n+                subscriber.deliverNextMessage();\n+                retryQueue.poll();\n+            }\n+        }\n+\n+        protected class ShutdownDeliveryManagerRequest implements DeliveryManagerRequest {\n+            // This is a simple type of Request we will enqueue when the\n+            // PubSubServer is shut down and we want to stop the DeliveryManager\n+            // thread.\n+            @Override\n+            public void performRequest() {\n+                keepRunning = false;\n+            }\n+        }\n+\n+    }\n+\n+\n+\n+    public FIFODeliveryManager(TopicManager tm, PersistenceManager persistenceMgr,\n+                               ServerConfiguration cfg) {\n+        this.tm = tm;\n+        this.persistenceMgr = persistenceMgr;\n+        if (persistenceMgr instanceof ReadAheadCache) {\n+            this.cache = (ReadAheadCache) persistenceMgr;\n+        } else {\n+            this.cache = null;\n+        }\n+        perTopicDeliveryPtrs =\n+            new ConcurrentHashMap<ByteString, SortedMap<Long, Set<ActiveSubscriberState>>>();\n+        subscriberStates =\n+            new ConcurrentHashMap<TopicSubscriber, ActiveSubscriberState>();\n+        this.cfg = cfg;\n+        // initialize the delivery workers\n+        this.numDeliveryWorkers = cfg.getNumDeliveryThreads();\n+        this.deliveryWorkers = new DeliveryWorker[numDeliveryWorkers];\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i] = new DeliveryWorker(i);\n+        }\n+    }\n+\n+    @Override\n+    public void start() {\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].start();\n+        }\n+    }\n+\n+    /**\n+     * Stop FIFO delivery manager from processing requests. (for testing)\n+     */\n+    @VisibleForTesting\n+    public void suspendProcessing() {\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].suspendProcessing();\n+        }\n+    }\n+\n+    /**\n+     * Resume FIFO delivery manager. (for testing)\n+     */\n+    @VisibleForTesting\n+    public void resumeProcessing() {\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].resumeProcessing();\n+        }\n+    }\n+\n+    /**\n+     * Stop the FIFO delivery manager.\n+     */\n+    @Override\n+    public void stop() {\n+        for (int i=0; i<numDeliveryWorkers; i++) {\n+            deliveryWorkers[i].stop();\n+        }\n+    }\n+\n+    private DeliveryWorker getDeliveryWorker(ByteString topic) {\n+        return deliveryWorkers[MathUtils.signSafeMod(topic.hashCode(), numDeliveryWorkers)];\n+    }\n+\n+    /**\n+     * ===================================================================== Our\n+     * usual enqueue function, stop if error because of unbounded queue, should\n+     * never happen\n+     *\n+     */\n+    protected void enqueueWithoutFailure(ByteString topic, DeliveryManagerRequest request) {\n+        getDeliveryWorker(topic).enqueueWithoutFailure(request);\n+    }\n+\n+    /**\n+     * Tells the delivery manager to start sending out messages for a particular\n+     * subscription\n+     *\n+     * @param topic\n+     * @param subscriberId\n+     * @param seqIdToStartFrom\n+     *            Message sequence-id from where delivery should be started\n+     * @param endPoint\n+     *            The delivery end point to which send messages to\n+     * @param filter\n+     *            Only messages passing this filter should be sent to this\n+     *            subscriber\n+     * @param callback\n+     *            Callback instance\n+     * @param ctx\n+     *            Callback context\n+     */\n+    @Override\n+    public void startServingSubscription(ByteString topic, ByteString subscriberId,\n+                                         SubscriptionPreferences preferences,\n+                                         MessageSeqId seqIdToStartFrom,\n+                                         DeliveryEndPoint endPoint, ServerMessageFilter filter,\n+                                         Callback<Void> callback, Object ctx) {\n+        ActiveSubscriberState subscriber =\n+            new ActiveSubscriberState(topic, subscriberId,\n+                                      preferences,\n+                                      seqIdToStartFrom.getLocalComponent() - 1,\n+                                      endPoint, filter, callback, ctx);\n+\n+        enqueueWithoutFailure(topic, subscriber);\n+    }\n+\n+    public void stopServingSubscriber(ByteString topic, ByteString subscriberId,\n+                                      SubscriptionEvent event,\n+                                      Callback<Void> cb, Object ctx) {\n+        enqueueWithoutFailure(topic, new StopServingSubscriber(topic, subscriberId, event, cb, ctx));\n+    }\n+\n+    /**\n+     * Instructs the delivery manager to backoff on the given subscriber and\n+     * retry sending after some time\n+     *\n+     * @param subscriber\n+     */\n+    public void retryErroredSubscriberAfterDelay(ActiveSubscriberState subscriber) {\n+        getDeliveryWorker(subscriber.getTopic()).retryErroredSubscriberAfterDelay(subscriber);\n+    }\n+\n+    public void clearRetryDelayForSubscriber(ActiveSubscriberState subscriber) {\n+        getDeliveryWorker(subscriber.getTopic()).clearRetryDelayForSubscriber(subscriber);\n+    }\n+\n+    // TODO: for now, I don't move messageConsumed request to delivery manager thread,\n+    //       which is supposed to be fixed in {@link https://issues.apache.org/jira/browse/BOOKKEEPER-503}\n+    @Override\n+    public void messageConsumed(ByteString topic, ByteString subscriberId,\n+                                MessageSeqId consumedSeqId) {\n+        ActiveSubscriberState subState =\n+            subscriberStates.get(new TopicSubscriber(topic, subscriberId));\n+        if (null == subState) {\n+            return;\n+        }\n+        subState.messageConsumed(consumedSeqId.getLocalComponent());\n+    }\n+\n+    /**\n+     * Instructs the delivery manager to move the delivery pointer for a given\n+     * subscriber\n+     *\n+     * @param subscriber\n+     * @param prevSeqId\n+     * @param newSeqId\n+     */\n+    public void moveDeliveryPtrForward(ActiveSubscriberState subscriber, long prevSeqId, long newSeqId) {\n+        enqueueWithoutFailure(subscriber.getTopic(),\n+            new DeliveryPtrMove(subscriber, prevSeqId, newSeqId));\n+    }\n+\n+    protected void removeDeliveryPtr(ActiveSubscriberState subscriber, Long seqId, boolean isAbsenceOk,\n+                                     boolean pruneTopic) {\n+\n+        assert seqId != null;\n+\n+        // remove this subscriber from the delivery pointers data structure\n+        ByteString topic = subscriber.getTopic();\n+        SortedMap<Long, Set<ActiveSubscriberState>> deliveryPtrs = perTopicDeliveryPtrs.get(topic);\n+\n+        if (deliveryPtrs == null && !isAbsenceOk) {\n+            throw new UnexpectedError(\"No delivery pointers found while disconnecting \" + \"channel for topic:\" + topic);\n+        }\n+\n+        if(null == deliveryPtrs) {\n+            return;\n+        }\n+\n+        if (!MapMethods.removeFromMultiMap(deliveryPtrs, seqId, subscriber) && !isAbsenceOk) {\n+\n+            throw new UnexpectedError(\"Could not find subscriber:\" + subscriber + \" at the expected delivery pointer\");\n+        }\n+\n+        if (pruneTopic && deliveryPtrs.isEmpty()) {\n+            perTopicDeliveryPtrs.remove(topic);\n+        }\n+\n+    }\n+\n+    protected long getMinimumSeqId(ByteString topic) {\n+        SortedMap<Long, Set<ActiveSubscriberState>> deliveryPtrs = perTopicDeliveryPtrs.get(topic);\n+\n+        if (deliveryPtrs == null || deliveryPtrs.isEmpty()) {\n+            return Long.MAX_VALUE - 1;\n+        }\n+        return deliveryPtrs.firstKey();\n+    }\n+\n+    protected void addDeliveryPtr(ActiveSubscriberState subscriber, Long seqId) {\n+\n+        // If this topic doesn't exist in the per-topic delivery pointers table,\n+        // create an entry for it\n+        SortedMap<Long, Set<ActiveSubscriberState>> deliveryPtrs = MapMethods.getAfterInsertingIfAbsent(\n+                    perTopicDeliveryPtrs, subscriber.getTopic(), TreeMapLongToSetSubscriberFactory.instance);\n+\n+        MapMethods.addToMultiMap(deliveryPtrs, seqId, subscriber, HashMapSubscriberFactory.instance);\n+    }\n+\n+    public class ActiveSubscriberState\n+        implements ScanCallback, DeliveryCallback, DeliveryManagerRequest, CancelScanRequest {\n+\n+        static final int UNLIMITED = 0;\n+\n+        ByteString topic;\n+        ByteString subscriberId;\n+        long lastLocalSeqIdDelivered;\n+        boolean connected = true;\n+        ReentrantReadWriteLock connectedLock = new ReentrantReadWriteLock();\n+        DeliveryEndPoint deliveryEndPoint;\n+        long lastScanErrorTime = -1;\n+        long localSeqIdDeliveringNow;\n+        long lastSeqIdCommunicatedExternally;\n+        long lastSeqIdConsumedUtil;\n+        boolean isThrottled = false;\n+        final int messageWindowSize;\n+        ServerMessageFilter filter;\n+        Callback<Void> cb;\n+        Object ctx;\n+\n+        // track the outstanding scan request\n+        // so we could cancel it\n+        ScanRequest outstandingScanRequest;\n+\n+        final static int SEQ_ID_SLACK = 10;\n+\n+        public ActiveSubscriberState(ByteString topic, ByteString subscriberId,\n+                                     SubscriptionPreferences preferences,\n+                                     long lastLocalSeqIdDelivered,\n+                                     DeliveryEndPoint deliveryEndPoint,\n+                                     ServerMessageFilter filter,\n+                                     Callback<Void> cb, Object ctx) {\n+            this.topic = topic;\n+            this.subscriberId = subscriberId;\n+            this.lastLocalSeqIdDelivered = lastLocalSeqIdDelivered;\n+            this.lastSeqIdConsumedUtil = lastLocalSeqIdDelivered;\n+            this.deliveryEndPoint = deliveryEndPoint;\n+            this.filter = filter;\n+            if (preferences.hasMessageWindowSize()) {\n+                messageWindowSize = preferences.getMessageWindowSize();\n+            } else {\n+                if (FIFODeliveryManager.this.cfg.getDefaultMessageWindowSize() > 0) {\n+                    messageWindowSize =\n+                        FIFODeliveryManager.this.cfg.getDefaultMessageWindowSize();\n+                } else {\n+                    messageWindowSize = UNLIMITED;\n+                }\n+            }\n+            this.cb = cb;\n+            this.ctx = ctx;\n+        }\n+\n+        public void setNotConnected(SubscriptionEvent event) {\n+            this.connectedLock.writeLock().lock();\n+            try {\n+                // have closed it.\n+                if (!connected) {\n+                    return;\n+                }\n+                this.connected = false;\n+                // put itself in ReadAhead queue to cancel outstanding scan request\n+                // if outstanding scan request callback before cancel op executed,\n+                // nothing it would cancel.\n+                if (null != cache && null != outstandingScanRequest) {\n+                    cache.cancelScanRequest(topic, this);\n+                }\n+            } finally {\n+                this.connectedLock.writeLock().unlock();\n+            }\n+\n+            if (null != event &&\n+                (SubscriptionEvent.TOPIC_MOVED == event ||\n+                 SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED == event)) {\n+                // we should not close the channel now after enabling multiplexing\n+                PubSubResponse response = PubSubResponseUtils.getResponseForSubscriptionEvent(\n+                    topic, subscriberId, event\n+                );\n+                deliveryEndPoint.send(response, new DeliveryCallback() {\n+                    @Override\n+                    public void sendingFinished() {\n+                        // do nothing now\n+                    }\n+                    @Override\n+                    public void transientErrorOnSend() {\n+                        // do nothing now\n+                    }\n+                    @Override\n+                    public void permanentErrorOnSend() {\n+                        // if channel is broken, close the channel\n+                        deliveryEndPoint.close();\n+                    }\n+                });\n+            }\n+            // uninitialize filter\n+            this.filter.uninitialize();\n+        }\n+\n+        public ByteString getTopic() {\n+            return topic;\n+        }\n+\n+        public synchronized long getLastScanErrorTime() {\n+            return lastScanErrorTime;\n+        }\n+\n+        public synchronized void setLastScanErrorTime(long lastScanErrorTime) {\n+            this.lastScanErrorTime = lastScanErrorTime;\n+        }\n+\n+        /**\n+         * Clear the last scan error time so it could be retry immediately.\n+         */\n+        protected synchronized void clearLastScanErrorTime() {\n+            this.lastScanErrorTime = -1;\n+        }\n+\n+        protected boolean isConnected() {\n+            connectedLock.readLock().lock();\n+            try {\n+                return connected;\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n+        }\n+\n+        protected synchronized void messageConsumed(long newSeqIdConsumed) {\n+            if (newSeqIdConsumed <= lastSeqIdConsumedUtil) {\n+                return;\n+            }\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Subscriber ({}) moved consumed ptr from {} to {}.\",\n+                             va(this, lastSeqIdConsumedUtil, newSeqIdConsumed));\n+            }\n+            lastSeqIdConsumedUtil = newSeqIdConsumed;\n+            // after updated seq id check whether it still exceed msg limitation\n+            if (msgLimitExceeded()) {\n+                return;\n+            }\n+            if (isThrottled) {\n+                isThrottled = false;\n+                logger.info(\"Try to wake up subscriber ({}) to deliver messages again : last delivered {}, last consumed {}.\",\n+                            va(this, lastLocalSeqIdDelivered, lastSeqIdConsumedUtil));\n+\n+                enqueueWithoutFailure(topic, new DeliveryManagerRequest() {\n+                    @Override\n+                    public void performRequest() {\n+                        // enqueue\n+                        clearRetryDelayForSubscriber(ActiveSubscriberState.this);\n+                    }\n+                });\n+            }\n+        }\n+\n+        protected boolean msgLimitExceeded() {\n+            if (messageWindowSize == UNLIMITED) {\n+                return false;\n+            }\n+            if (lastLocalSeqIdDelivered - lastSeqIdConsumedUtil >= messageWindowSize) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        public void deliverNextMessage() {\n+            connectedLock.readLock().lock();\n+            try {\n+                doDeliverNextMessage();\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n+        }\n+\n+        private void doDeliverNextMessage() {\n+            if (!connected) {\n+                return;\n+            }\n+\n+            synchronized (this) {\n+                // check whether we have delivered enough messages without receiving their consumes\n+                if (msgLimitExceeded()) {\n+                    logger.info(\"Subscriber ({}) is throttled : last delivered {}, last consumed {}.\",\n+                                va(this, lastLocalSeqIdDelivered, lastSeqIdConsumedUtil));\n+                    isThrottled = true;\n+                    // do nothing, since the delivery process would be throttled.\n+                    // After message consumed, it would be added back to retry queue.\n+                    return;\n+                }\n+\n+                localSeqIdDeliveringNow = persistenceMgr.getSeqIdAfterSkipping(topic, lastLocalSeqIdDelivered, 1);\n+\n+                outstandingScanRequest = new ScanRequest(topic, localSeqIdDeliveringNow,\n+                        /* callback= */this, /* ctx= */null);\n+            }\n+\n+            persistenceMgr.scanSingleMessage(outstandingScanRequest);\n+        }\n+\n+        /**\n+         * ===============================================================\n+         * {@link CancelScanRequest} methods\n+         *\n+         * This method runs ins same threads with ScanCallback. When it runs,\n+         * it checked whether it is outstanding scan request. if there is one,\n+         * cancel it.\n+         */\n+        @Override\n+        public ScanRequest getScanRequest() {\n+            // no race between cancel request and scan callback\n+            // the only race is between stopServing and deliverNextMessage\n+            // deliverNextMessage would be executed in netty callback which is in netty thread\n+            // stopServing is run in delivery thread. if stopServing runs before deliverNextMessage\n+            // deliverNextMessage would have chance to put a stub in ReadAheadCache\n+            // then we don't have any chance to cancel it.\n+            // use connectedLock to avoid such race.\n+            return outstandingScanRequest;\n+        }\n+\n+        private boolean checkConnected() {\n+            connectedLock.readLock().lock();\n+            try {\n+                // message scanned means the outstanding request is executed\n+                outstandingScanRequest = null;\n+                return connected;\n+            } finally {\n+                connectedLock.readLock().unlock();\n+            }\n+        }\n+\n+        /**\n+         * ===============================================================\n+         * {@link ScanCallback} methods\n+         */\n+\n+        public void messageScanned(Object ctx, Message message) {\n+            if (!checkConnected()) {\n+                return;\n+            }\n+\n+            // only increment topic access times when tried to deliver a message\n+            // for those subscribers just waiting for a published for a long time\n+            // we don't increment topic access times, so the topic would be evicted\n+            // in future.\n+            tm.incrementTopicAccessTimes(topic);\n+\n+            if (!filter.testMessage(message)) {\n+                // for filtered out messages, we don't deliver the message to client, so we would not\n+                // receive its consume request which moves the <i>lastSeqIdConsumedUtil</i> pointer.\n+                // we move the <i>lastSeqIdConsumedUtil</i> here for filtered out messages, which would\n+                // avoid a subscriber being throttled due to the message gap introduced by filtering.\n+                //\n+                // it is OK to move <i>lastSeqIdConsumedUtil</i> here, since this pointer is subscriber's\n+                // delivery state which to trottling deliver. changing <i>lastSeqIdConsumedUtil</i> would\n+                // not affect the subscriber's consume pointer in zookeeper which is managed in subscription\n+                // manager.\n+                //\n+                // And marking message consumed before calling sending finished, would avoid the subscriber\n+                // being throttled first and released from throttled state laster.\n+                messageConsumed(message.getMsgId().getLocalComponent());\n+                sendingFinished();\n+                return;\n+            }\n+\n+            /**\n+             * The method below will invoke our sendingFinished() method when\n+             * done\n+             */\n+            PubSubResponse response = PubSubResponse.newBuilder()\n+                                      .setProtocolVersion(ProtocolVersion.VERSION_ONE)\n+                                      .setStatusCode(StatusCode.SUCCESS).setTxnId(0)\n+                                      .setMessage(message).setTopic(topic)\n+                                      .setSubscriberId(subscriberId).build();\n+\n+            deliveryEndPoint.send(response, //\n+                                  // callback =\n+                                  this);\n+\n+        }\n+\n+        @Override\n+        public void scanFailed(Object ctx, Exception exception) {\n+            if (!checkConnected()) {\n+                return;\n+            }\n+\n+            // wait for some time and then retry\n+            retryErroredSubscriberAfterDelay(this);\n+        }\n+\n+        @Override\n+        public void scanFinished(Object ctx, ReasonForFinish reason) {\n+            checkConnected();\n+        }\n+\n+        /**\n+         * ===============================================================\n+         * {@link DeliveryCallback} methods\n+         */\n+        @Override\n+        public void sendingFinished() {\n+            if (!isConnected()) {\n+                return;\n+            }\n+\n+            synchronized (this) {\n+                lastLocalSeqIdDelivered = localSeqIdDeliveringNow;\n+\n+                if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK) {\n+                    // Note: The order of the next 2 statements is important. We should\n+                    // submit a request to change our delivery pointer only *after* we\n+                    // have actually changed it. Otherwise, there is a race condition\n+                    // with removal of this channel, w.r.t, maintaining the deliveryPtrs\n+                    // tree map.\n+                    long prevId = lastSeqIdCommunicatedExternally;\n+                    lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n+                    moveDeliveryPtrForward(this, prevId, lastLocalSeqIdDelivered);\n+                }\n+            }\n+            // increment deliveried message\n+            ServerStats.getInstance().incrementMessagesDelivered();\n+            deliverNextMessage();\n+        }\n+\n+        public synchronized long getLastSeqIdCommunicatedExternally() {\n+            return lastSeqIdCommunicatedExternally;\n+        }\n+\n+\n+        @Override\n+        public void permanentErrorOnSend() {\n+            // the underlying channel is broken, the channel will\n+            // be closed in UmbrellaHandler when exception happened.\n+            // so we don't need to close the channel again\n+            stopServingSubscriber(topic, subscriberId, null,\n+                                  NOP_CALLBACK, null);\n+        }\n+\n+        @Override\n+        public void transientErrorOnSend() {\n+            retryErroredSubscriberAfterDelay(this);\n+        }\n+\n+        /**\n+         * ===============================================================\n+         * {@link DeliveryManagerRequest} methods\n+         */\n+        @Override\n+        public void performRequest() {\n+            // Put this subscriber in the channel to subscriber mapping\n+            ActiveSubscriberState prevSubscriber =\n+                subscriberStates.put(new TopicSubscriber(topic, subscriberId), this);\n+\n+            // after put the active subscriber in subscriber states mapping\n+            // trigger the callback to tell it started to deliver the message\n+            // should let subscriber response go first before first delivered message.\n+            cb.operationFinished(ctx, (Void)null);\n+\n+            if (prevSubscriber != null) {\n+                // we already in the delivery thread, we don't need to equeue a stop request\n+                // just stop it now, since stop is not blocking operation.\n+                // and also it cleans the old state of the active subscriber immediately.\n+                SubscriptionEvent se;\n+                if (deliveryEndPoint.equals(prevSubscriber.deliveryEndPoint)) {\n+                    logger.debug(\"Subscriber {} replaced a duplicated subscriber {} at same delivery point {}.\",\n+                                 va(this, prevSubscriber, deliveryEndPoint));\n+                    se = null;\n+                } else {\n+                    logger.debug(\"Subscriber {} from delivery point {} forcelly closed delivery point {}.\",\n+                                 va(this, deliveryEndPoint, prevSubscriber.deliveryEndPoint));\n+                    se = SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED;\n+                }\n+                doStopServingSubscriber(prevSubscriber, se);\n+            }\n+\n+            synchronized (this) {\n+                lastSeqIdCommunicatedExternally = lastLocalSeqIdDelivered;\n+                addDeliveryPtr(this, lastLocalSeqIdDelivered);\n+            }\n+\n+            deliverNextMessage();\n+        };\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Topic: \");\n+            sb.append(topic.toStringUtf8());\n+            sb.append(\"Subscriber: \");\n+            sb.append(subscriberId.toStringUtf8());\n+            sb.append(\", DeliveryPtr: \");\n+            sb.append(lastLocalSeqIdDelivered);\n+            return sb.toString();\n+\n+        }\n+    }\n+\n+    protected class StopServingSubscriber implements DeliveryManagerRequest {\n+        TopicSubscriber ts;\n+        SubscriptionEvent event;\n+        final Callback<Void> cb;\n+        final Object ctx;\n+\n+        public StopServingSubscriber(ByteString topic, ByteString subscriberId,\n+                                     SubscriptionEvent event,\n+                                     Callback<Void> callback, Object ctx) {\n+            this.ts = new TopicSubscriber(topic, subscriberId);\n+            this.event = event;\n+            this.cb = callback;\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void performRequest() {\n+            ActiveSubscriberState subscriber = subscriberStates.remove(ts);\n+            if (null != subscriber) {\n+                doStopServingSubscriber(subscriber, event);\n+            }\n+            cb.operationFinished(ctx, null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Stop serving a subscriber. This method should be called in a\n+     * {@link DeliveryManagerRequest}.\n+     *\n+     * @param subscriber\n+     *          Active Subscriber to stop\n+     * @param event\n+     *          Subscription Event for the stop reason\n+     */\n+    private void doStopServingSubscriber(ActiveSubscriberState subscriber, SubscriptionEvent event) {\n+        // This will automatically stop delivery, and disconnect the channel\n+        subscriber.setNotConnected(event);\n+\n+        // if the subscriber has moved on, a move request for its delivery\n+        // pointer must be pending in the request queue. Note that the\n+        // subscriber first changes its delivery pointer and then submits a\n+        // request to move so this works.\n+        removeDeliveryPtr(subscriber, subscriber.getLastSeqIdCommunicatedExternally(), //\n+                          // isAbsenceOk=\n+                          true,\n+                          // pruneTopic=\n+                          true);\n+    }\n+\n+    protected class DeliveryPtrMove implements DeliveryManagerRequest {\n+\n+        ActiveSubscriberState subscriber;\n+        Long oldSeqId;\n+        Long newSeqId;\n+\n+        public DeliveryPtrMove(ActiveSubscriberState subscriber, Long oldSeqId, Long newSeqId) {\n+            this.subscriber = subscriber;\n+            this.oldSeqId = oldSeqId;\n+            this.newSeqId = newSeqId;\n+        }\n+\n+        @Override\n+        public void performRequest() {\n+            ByteString topic = subscriber.getTopic();\n+            long prevMinSeqId = getMinimumSeqId(topic);\n+\n+            if (subscriber.isConnected()) {\n+                removeDeliveryPtr(subscriber, oldSeqId, //\n+                                  // isAbsenceOk=\n+                                  false,\n+                                  // pruneTopic=\n+                                  false);\n+\n+                addDeliveryPtr(subscriber, newSeqId);\n+            } else {\n+                removeDeliveryPtr(subscriber, oldSeqId, //\n+                                  // isAbsenceOk=\n+                                  true,\n+                                  // pruneTopic=\n+                                  true);\n+            }\n+\n+            long nowMinSeqId = getMinimumSeqId(topic);\n+\n+            if (nowMinSeqId > prevMinSeqId) {\n+                persistenceMgr.deliveredUntil(topic, nowMinSeqId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * ====================================================================\n+     *\n+     * Dumb factories for our map methods\n+     */\n+    protected static class TreeMapLongToSetSubscriberFactory implements\n+        Factory<SortedMap<Long, Set<ActiveSubscriberState>>> {\n+        static TreeMapLongToSetSubscriberFactory instance = new TreeMapLongToSetSubscriberFactory();\n+\n+        @Override\n+        public SortedMap<Long, Set<ActiveSubscriberState>> newInstance() {\n+            return new TreeMap<Long, Set<ActiveSubscriberState>>();\n+        }\n+    }\n+\n+    protected static class HashMapSubscriberFactory implements Factory<Set<ActiveSubscriberState>> {\n+        static HashMapSubscriberFactory instance = new HashMapSubscriberFactory();\n+\n+        @Override\n+        public Set<ActiveSubscriberState> newInstance() {\n+            return new HashSet<ActiveSubscriberState>();\n+        }\n+    }\n+\n+    @Override\n+    public void onSubChannelDisconnected(TopicSubscriber topicSubscriber) {\n+        stopServingSubscriber(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                null, NOP_CALLBACK, null);\n+    }\n+\n+}"},{"sha":"4189eb66e11887c207a4b9b1ff30285f8f244ae9","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,67 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ServerNotResponsibleForTopicException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+\n+public abstract class BaseHandler implements Handler {\n+\n+    protected TopicManager topicMgr;\n+    protected ServerConfiguration cfg;\n+\n+    protected BaseHandler(TopicManager tm, ServerConfiguration cfg) {\n+        this.topicMgr = tm;\n+        this.cfg = cfg;\n+    }\n+\n+\n+    public void handleRequest(final PubSubRequest request, final Channel channel) {\n+        topicMgr.getOwner(request.getTopic(), request.getShouldClaim(),\n+        new Callback<HedwigSocketAddress>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                ServerStats.getInstance().getOpStats(request.getType()).incrementFailedOps();\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, HedwigSocketAddress owner) {\n+                if (!owner.equals(cfg.getServerAddr())) {\n+                    channel.write(PubSubResponseUtils.getResponseForException(\n+                                      new ServerNotResponsibleForTopicException(owner.toString()), request.getTxnId()));\n+                    ServerStats.getInstance().incrementRequestsRedirect();\n+                    return;\n+                }\n+                handleRequestAtOwner(request, channel);\n+            }\n+        }, null);\n+    }\n+\n+    public abstract void handleRequestAtOwner(PubSubRequest request, Channel channel);\n+\n+}"},{"sha":"458d301fd2f4edce4cf6373979e1e4e149cc5184","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ChannelDisconnectListener.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,29 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+public interface ChannelDisconnectListener {\n+\n+    /**\n+     * Act on a particular channel being disconnected\n+     * @param channel\n+     */\n+    public void channelDisconnected(Channel channel);\n+}"},{"sha":"a6ccb7ebbff4fed6a5136e97397ec691203723a5","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/CloseSubscriptionHandler.java","status":"added","additions":105,"deletions":0,"changes":105,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/CloseSubscriptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/CloseSubscriptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/CloseSubscriptionHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,105 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.netty.ServerStats.OpStats;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+\n+public class CloseSubscriptionHandler extends BaseHandler {\n+    SubscriptionManager subMgr;\n+    DeliveryManager deliveryMgr;\n+    SubscriptionChannelManager subChannelMgr;\n+    // op stats\n+    final OpStats closesubStats;\n+\n+    public CloseSubscriptionHandler(ServerConfiguration cfg, TopicManager tm,\n+                                    SubscriptionManager subMgr,\n+                                    DeliveryManager deliveryMgr,\n+                                    SubscriptionChannelManager subChannelMgr) {\n+        super(tm, cfg);\n+        this.subMgr = subMgr;\n+        this.deliveryMgr = deliveryMgr;\n+        this.subChannelMgr = subChannelMgr;\n+        closesubStats = ServerStats.getInstance().getOpStats(OperationType.CLOSESUBSCRIPTION);\n+    }\n+\n+    @Override\n+    public void handleRequestAtOwner(final PubSubRequest request, final Channel channel) {\n+        if (!request.hasCloseSubscriptionRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing closesubscription request data\");\n+            closesubStats.incrementFailedOps();\n+            return;\n+        }\n+\n+        final CloseSubscriptionRequest closesubRequest =\n+                request.getCloseSubscriptionRequest();\n+        final ByteString topic = request.getTopic();\n+        final ByteString subscriberId = closesubRequest.getSubscriberId();\n+\n+        final long requestTime = System.currentTimeMillis();\n+\n+        subMgr.closeSubscription(topic, subscriberId, new Callback<Void>() {\n+            @Override\n+            public void operationFinished(Object ctx, Void result) {\n+                // we should not close the channel in delivery manager\n+                // since client waits the response for closeSubscription request\n+                // client side would close the channel\n+                deliveryMgr.stopServingSubscriber(topic, subscriberId, null,\n+                new Callback<Void>() {\n+                    @Override\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                        closesubStats.incrementFailedOps();\n+                    }\n+                    @Override\n+                    public void operationFinished(Object ctx, Void resultOfOperation) {\n+                        // remove the topic subscription from subscription channels\n+                        subChannelMgr.remove(new TopicSubscriber(topic, subscriberId),\n+                                             channel);\n+                        channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId()));\n+                        closesubStats.updateLatency(System.currentTimeMillis() - requestTime);\n+                    }\n+                }, null);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                closesubStats.incrementFailedOps();\n+            }\n+        }, null);\n+    }\n+}"},{"sha":"5042a37eea8cbba676750750cda1cdad2e62194e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ConsumeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.server.netty.ServerStats.OpStats;\n+import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+\n+public class ConsumeHandler extends BaseHandler {\n+\n+    SubscriptionManager sm;\n+    Callback<Void> noopCallback = new NoopCallback<Void>();\n+    final OpStats consumeStats = ServerStats.getInstance().getOpStats(OperationType.CONSUME);\n+\n+    class NoopCallback<T> implements Callback<T> {\n+        @Override\n+        public void operationFailed(Object ctx, PubSubException exception) {\n+            consumeStats.incrementFailedOps();\n+        }\n+\n+        public void operationFinished(Object ctx, T resultOfOperation) {\n+            // we don't collect consume process time\n+            consumeStats.updateLatency(0);\n+        };\n+    }\n+\n+    @Override\n+    public void handleRequestAtOwner(PubSubRequest request, Channel channel) {\n+        if (!request.hasConsumeRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing consume request data\");\n+            consumeStats.incrementFailedOps();\n+            return;\n+        }\n+\n+        ConsumeRequest consumeRequest = request.getConsumeRequest();\n+\n+        sm.setConsumeSeqIdForSubscriber(request.getTopic(), consumeRequest.getSubscriberId(),\n+                                        consumeRequest.getMsgId(), noopCallback, null);\n+\n+    }\n+\n+    public ConsumeHandler(TopicManager tm, SubscriptionManager sm, ServerConfiguration cfg) {\n+        super(tm, cfg);\n+        this.sm = sm;\n+    }\n+}"},{"sha":"c391f5c1c24f9115e96214a7cf4b13c342bd4ace","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/Handler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+\n+public interface Handler {\n+\n+    /**\n+     * Handle a request synchronously or asynchronously. After handling the\n+     * request, the appropriate response should be written on the given channel\n+     *\n+     * @param request\n+     *            The request to handle\n+     *\n+     * @param channel\n+     *            The channel on which to write the response\n+     */\n+    public void handleRequest(final PubSubRequest request, final Channel channel);\n+}"},{"sha":"e0f14873640e8af0eca4e274ee49d806537c79c8","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.handlers;\n+\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager;\n+import org.apache.hedwig.server.jmx.HedwigMBeanInfo;\n+\n+public class NettyHandlerBean implements NettyHandlerMXBean, HedwigMBeanInfo {\n+\n+    SubscriptionChannelManager subChannelMgr;\n+\n+   public NettyHandlerBean(SubscriptionChannelManager subChannelMgr) {\n+       this.subChannelMgr = subChannelMgr;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"NettyHandlers\";\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getNumSubscriptionChannels() {\n+        return subChannelMgr.getNumSubscriptionChannels();\n+    }\n+\n+}"},{"sha":"ab8af29648879b66d0bd2f939dfe02dface4a630","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,31 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.handlers;\n+\n+/**\n+ * Netty Handler MBean\n+ */\n+public interface NettyHandlerMXBean {\n+\n+    /**\n+     * @return number of subscription channels\n+     */\n+    public int getNumSubscriptionChannels();\n+\n+}"},{"sha":"587f904f1d00375b73fe1b22fc1b395cb44f017a","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,90 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.jboss.netty.channel.Channel;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.netty.ServerStats.OpStats;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.server.persistence.PersistRequest;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+\n+public class PublishHandler extends BaseHandler {\n+\n+    private PersistenceManager persistenceMgr;\n+    private final OpStats pubStats;\n+\n+    public PublishHandler(TopicManager topicMgr, PersistenceManager persistenceMgr, ServerConfiguration cfg) {\n+        super(topicMgr, cfg);\n+        this.persistenceMgr = persistenceMgr;\n+        this.pubStats = ServerStats.getInstance().getOpStats(OperationType.PUBLISH);\n+    }\n+\n+    @Override\n+    public void handleRequestAtOwner(final PubSubRequest request, final Channel channel) {\n+        if (!request.hasPublishRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing publish request data\");\n+            pubStats.incrementFailedOps();\n+            return;\n+        }\n+\n+        Message msgToSerialize = Message.newBuilder(request.getPublishRequest().getMsg()).setSrcRegion(\n+                                     cfg.getMyRegionByteString()).build();\n+\n+        final long requestTime = MathUtils.now();\n+        PersistRequest persistRequest = new PersistRequest(request.getTopic(), msgToSerialize,\n+        new Callback<PubSubProtocol.MessageSeqId>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                pubStats.incrementFailedOps();\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, PubSubProtocol.MessageSeqId resultOfOperation) {\n+                channel.write(getSuccessResponse(request.getTxnId(), resultOfOperation));\n+                pubStats.updateLatency(MathUtils.now() - requestTime);\n+            }\n+        }, null);\n+\n+        persistenceMgr.persistMessage(persistRequest);\n+    }\n+\n+    private static PubSubProtocol.PubSubResponse getSuccessResponse(long txnId, PubSubProtocol.MessageSeqId publishedMessageSeqId) {\n+        if (null == publishedMessageSeqId) {\n+            return PubSubResponseUtils.getSuccessResponse(txnId);\n+        }\n+        PubSubProtocol.PublishResponse publishResponse = PubSubProtocol.PublishResponse.newBuilder().setPublishedMsgId(publishedMessageSeqId).build();\n+        PubSubProtocol.ResponseBody responseBody = PubSubProtocol.ResponseBody.newBuilder().setPublishResponse(publishResponse).build();\n+        return PubSubProtocol.PubSubResponse.newBuilder().\n+            setProtocolVersion(PubSubResponseUtils.serverVersion).\n+            setStatusCode(PubSubProtocol.StatusCode.SUCCESS).setTxnId(txnId).\n+            setResponseBody(responseBody).build();\n+    }\n+}"},{"sha":"d10dbf757c49ccf7dbd4ae4002efc30a6c838e80","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"added","additions":223,"deletions":0,"changes":223,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,223 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ServerNotResponsibleForTopicException;\n+import org.apache.hedwig.filter.PipelineFilter;\n+import org.apache.hedwig.filter.ServerMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.ChannelEndPoint;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.netty.ServerStats.OpStats;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n+import org.apache.hedwig.server.subscriptions.AllToAllTopologyFilter;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class SubscribeHandler extends BaseHandler {\n+    static Logger logger = LoggerFactory.getLogger(SubscribeHandler.class);\n+\n+    private final DeliveryManager deliveryMgr;\n+    private final PersistenceManager persistenceMgr;\n+    private final SubscriptionManager subMgr;\n+    private final SubscriptionChannelManager subChannelMgr;\n+\n+    // op stats\n+    private final OpStats subStats;\n+\n+    public SubscribeHandler(ServerConfiguration cfg, TopicManager topicMgr,\n+                            DeliveryManager deliveryManager,\n+                            PersistenceManager persistenceMgr,\n+                            SubscriptionManager subMgr,\n+                            SubscriptionChannelManager subChannelMgr) {\n+        super(topicMgr, cfg);\n+        this.deliveryMgr = deliveryManager;\n+        this.persistenceMgr = persistenceMgr;\n+        this.subMgr = subMgr;\n+        this.subChannelMgr = subChannelMgr;\n+        subStats = ServerStats.getInstance().getOpStats(OperationType.SUBSCRIBE);\n+    }\n+\n+    @Override\n+    public void handleRequestAtOwner(final PubSubRequest request, final Channel channel) {\n+\n+        if (!request.hasSubscribeRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing subscribe request data\");\n+            subStats.incrementFailedOps();\n+            return;\n+        }\n+\n+        final ByteString topic = request.getTopic();\n+\n+        MessageSeqId seqId;\n+        try {\n+            seqId = persistenceMgr.getCurrentSeqIdForTopic(topic);\n+        } catch (ServerNotResponsibleForTopicException e) {\n+            channel.write(PubSubResponseUtils.getResponseForException(e, request.getTxnId())).addListener(\n+                ChannelFutureListener.CLOSE);\n+            logger.error(\"Error getting current seq id for topic \" + topic.toStringUtf8()\n+                       + \" when processing subscribe request (txnid:\" + request.getTxnId() + \") :\", e);\n+            subStats.incrementFailedOps();\n+            ServerStats.getInstance().incrementRequestsRedirect();\n+            return;\n+        }\n+\n+        final SubscribeRequest subRequest = request.getSubscribeRequest();\n+        final ByteString subscriberId = subRequest.getSubscriberId();\n+\n+        MessageSeqId lastSeqIdPublished = MessageSeqId.newBuilder(seqId).setLocalComponent(seqId.getLocalComponent()).build();\n+\n+        final long requestTime = MathUtils.now();\n+        subMgr.serveSubscribeRequest(topic, subRequest, lastSeqIdPublished, new Callback<SubscriptionData>() {\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId())).addListener(\n+                    ChannelFutureListener.CLOSE);\n+                logger.error(\"Error serving subscribe request (\" + request.getTxnId() + \") for (topic: \"\n+                           + topic.toStringUtf8() + \" , subscriber: \" + subscriberId.toStringUtf8() + \")\", exception);\n+                subStats.incrementFailedOps();\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, final SubscriptionData subData) {\n+\n+                TopicSubscriber topicSub = new TopicSubscriber(topic, subscriberId);\n+                synchronized (channel) {\n+                    if (!channel.isConnected()) {\n+                        // channel got disconnected while we were processing the\n+                        // subscribe request,\n+                        // nothing much we can do in this case\n+                        subStats.incrementFailedOps();\n+                        return;\n+                    }\n+                }\n+                // initialize the message filter\n+                PipelineFilter filter = new PipelineFilter();\n+                try {\n+                    // the filter pipeline should be\n+                    // 1) AllToAllTopologyFilter to filter cross-region messages\n+                    filter.addLast(new AllToAllTopologyFilter());\n+                    // 2) User-Customized MessageFilter\n+                    if (subData.hasPreferences() &&\n+                        subData.getPreferences().hasMessageFilter()) {\n+                        String messageFilterName = subData.getPreferences().getMessageFilter();\n+                        filter.addLast(ReflectionUtils.newInstance(messageFilterName, ServerMessageFilter.class));\n+                    }\n+                    // initialize the filter\n+                    filter.initialize(cfg.getConf());\n+                    filter.setSubscriptionPreferences(topic, subscriberId,\n+                                                      subData.getPreferences());\n+                } catch (RuntimeException re) {\n+                    String errMsg = \"RuntimeException caught when instantiating message filter for (topic:\"\n+                                  + topic.toStringUtf8() + \", subscriber:\" + subscriberId.toStringUtf8() + \").\"\n+                                  + \"It might be introduced by programming error in message filter.\";\n+                    logger.error(errMsg, re);\n+                    PubSubException pse = new PubSubException.InvalidMessageFilterException(errMsg, re);\n+                    subStats.incrementFailedOps();\n+                    // we should not close the subscription channel, just response error\n+                    // client decide to close it or not.\n+                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()));\n+                    return;\n+                } catch (Throwable t) {\n+                    String errMsg = \"Failed to instantiate message filter for (topic:\" + topic.toStringUtf8()\n+                                  + \", subscriber:\" + subscriberId.toStringUtf8() + \").\";\n+                    logger.error(errMsg, t);\n+                    PubSubException pse = new PubSubException.InvalidMessageFilterException(errMsg, t);\n+                    subStats.incrementFailedOps();\n+                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+                    return;\n+                }\n+                boolean forceAttach = false;\n+                if (subRequest.hasForceAttach()) {\n+                    forceAttach = subRequest.getForceAttach();\n+                }\n+                // Try to store the subscription channel for the topic subscriber\n+                Channel oldChannel = subChannelMgr.put(topicSub, channel, forceAttach);\n+                if (null != oldChannel) {\n+                    PubSubException pse = new PubSubException.TopicBusyException(\n+                        \"Subscriber \" + subscriberId.toStringUtf8() + \" for topic \" + topic.toStringUtf8()\n+                        + \" is already being served on a different channel \" + oldChannel + \".\");\n+                    subStats.incrementFailedOps();\n+                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n+                    .addListener(ChannelFutureListener.CLOSE);\n+                    return;\n+                }\n+\n+                // want to start 1 ahead of the consume ptr\n+                MessageSeqId lastConsumedSeqId = subData.getState().getMsgId();\n+                MessageSeqId seqIdToStartFrom = MessageSeqId.newBuilder(lastConsumedSeqId).setLocalComponent(\n+                                                    lastConsumedSeqId.getLocalComponent() + 1).build();\n+                deliveryMgr.startServingSubscription(topic, subscriberId,\n+                        subData.getPreferences(), seqIdToStartFrom, new ChannelEndPoint(channel), filter,\n+                        new Callback<Void>() {\n+                            @Override\n+                            public void operationFinished(Object ctx, Void result) {\n+                                // First write success and then tell the delivery manager,\n+                                // otherwise the first message might go out before the response\n+                                // to the subscribe\n+                                SubscribeResponse.Builder subRespBuilder = SubscribeResponse.newBuilder()\n+                                    .setPreferences(subData.getPreferences());\n+                                ResponseBody respBody = ResponseBody.newBuilder()\n+                                    .setSubscribeResponse(subRespBuilder).build();\n+                                channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId(), respBody));\n+                                logger.info(\"Subscribe request (\" + request.getTxnId() + \") for (topic:\"\n+                                            + topic.toStringUtf8() + \", subscriber:\" + subscriberId.toStringUtf8()\n+                                            + \") from channel \" + channel.getRemoteAddress()\n+                                            + \" succeed - its subscription data is \"\n+                                            + SubscriptionStateUtils.toString(subData));\n+                                subStats.updateLatency(MathUtils.now() - requestTime);\n+                            }\n+                            @Override\n+                            public void operationFailed(Object ctx, PubSubException exception) {\n+                                // would not happened\n+                            }\n+                        }, null);\n+            }\n+        }, null);\n+\n+    }\n+\n+}"},{"sha":"5b1d85d8bc3e3b8e000bb9e54b232fbdd4be42ce","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,214 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class SubscriptionChannelManager implements ChannelDisconnectListener {\n+\n+    static Logger logger = LoggerFactory.getLogger(SubscriptionChannelManager.class);\n+\n+    static class CloseSubscriptionListener implements ChannelFutureListener {\n+\n+        final TopicSubscriber ts;\n+\n+        CloseSubscriptionListener(TopicSubscriber topicSubscriber) {\n+            this.ts = topicSubscriber;\n+        }\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (!future.isSuccess()) {\n+                logger.warn(\"Failed to write response to close old subscription {}.\", ts);\n+            } else {\n+                logger.debug(\"Close old subscription {} succeed.\", ts);\n+            }\n+        }\n+    };\n+\n+    final List<SubChannelDisconnectedListener> listeners;\n+\n+    public interface SubChannelDisconnectedListener {\n+        /**\n+         * Act on a particular topicSubscriber being disconnected\n+         * @param topicSubscriber\n+         */\n+        public void onSubChannelDisconnected(TopicSubscriber topicSubscriber);\n+    }\n+\n+    final ConcurrentHashMap<TopicSubscriber, Channel> sub2Channel;\n+    final ConcurrentHashMap<Channel, Set<TopicSubscriber>> channel2sub;\n+\n+    public SubscriptionChannelManager() {\n+        sub2Channel = new ConcurrentHashMap<TopicSubscriber, Channel>();\n+        channel2sub = new ConcurrentHashMap<Channel, Set<TopicSubscriber>>();\n+        listeners = new ArrayList<SubChannelDisconnectedListener>();\n+    }\n+\n+    public void addSubChannelDisconnectedListener(SubChannelDisconnectedListener listener) {\n+        if (null != listener) {\n+            listeners.add(listener);\n+        }\n+    }\n+\n+    @Override\n+    public void channelDisconnected(Channel channel) {\n+        // Evils of synchronized programming: there is a race between a channel\n+        // getting disconnected, and us adding it to the maps when a subscribe\n+        // succeeds\n+        Set<TopicSubscriber> topicSubs;\n+        synchronized (channel) {\n+            topicSubs = channel2sub.remove(channel);\n+        }\n+        if (topicSubs != null) {\n+            for (TopicSubscriber topicSub : topicSubs) {\n+                logger.info(\"Subscription channel {} for {} is disconnected.\",\n+                            va(channel.getRemoteAddress(), topicSub));\n+                // remove entry only currently mapped to given value.\n+                sub2Channel.remove(topicSub, channel);\n+                for (SubChannelDisconnectedListener listener : listeners) {\n+                    listener.onSubChannelDisconnected(topicSub);\n+                }\n+            }\n+        }\n+    }\n+\n+    public int getNumSubscriptionChannels() {\n+        return channel2sub.size();\n+    }\n+\n+    public int getNumSubscriptions() {\n+        return sub2Channel.size();\n+    }\n+\n+    /**\n+     * Put <code>topicSub</code> on Channel <code>channel</code>.\n+     *\n+     * @param topicSub\n+     *          Topic Subscription\n+     * @param channel\n+     *          Netty channel\n+     * @param mode\n+     *          Create or Attach mode\n+     * @return null succeed, otherwise the old existed channel.\n+     */\n+    public Channel put(TopicSubscriber topicSub, Channel channel, boolean forceAttach) {\n+        // race with channel getting disconnected while we are adding it\n+        // to the 2 maps\n+        synchronized (channel) {\n+            Channel oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+            // if a subscribe request send from same channel,\n+            // we treated it a success action.\n+            if (null != oldChannel && !oldChannel.equals(channel)) {\n+                boolean subSuccess = false;\n+                if (forceAttach) {\n+                    // it is safe to close old subscription here since the new subscription\n+                    // has come from other channel succeed.\n+                    synchronized (oldChannel) {\n+                        Set<TopicSubscriber> oldTopicSubs = channel2sub.get(oldChannel);\n+                        if (null != oldTopicSubs) {\n+                            if (!oldTopicSubs.remove(topicSub)) {\n+                                logger.warn(\"Failed to remove old subscription ({}) due to it isn't on channel ({}).\",\n+                                            va(topicSub, oldChannel));\n+                            } else if (oldTopicSubs.isEmpty()) {\n+                                channel2sub.remove(oldChannel);\n+                            }\n+                        }\n+                    }\n+                    PubSubResponse resp = PubSubResponseUtils.getResponseForSubscriptionEvent(\n+                        topicSub.getTopic(), topicSub.getSubscriberId(),\n+                        SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED\n+                    );\n+                    oldChannel.write(resp).addListener(new CloseSubscriptionListener(topicSub));\n+                    logger.info(\"Subscribe request for ({}) from channel ({}) closes old subscripiton on channel ({}).\",\n+                                va(topicSub, channel, oldChannel));\n+                    // try replace the oldChannel\n+                    // if replace failure, it migth caused because channelDisconnect callback\n+                    // has removed the old channel.\n+                    if (!sub2Channel.replace(topicSub, oldChannel, channel)) {\n+                        // try to add it now.\n+                        // if add failure, it means other one has obtained the channel\n+                        oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n+                        if (null == oldChannel) {\n+                            subSuccess = true;\n+                        }\n+                    } else {\n+                        subSuccess = true;\n+                    }\n+                }\n+                if (!subSuccess) {\n+                    logger.error(\"Error serving subscribe request for ({}) from ({}) since it already served on ({}).\",\n+                                 va(topicSub, channel, oldChannel));\n+                    return oldChannel;\n+                }\n+            }\n+            // channel2sub is just a cache, so we can add to it\n+            // without synchronization\n+            Set<TopicSubscriber> topicSubs = channel2sub.get(channel);\n+            if (null == topicSubs) {\n+                topicSubs = new HashSet<TopicSubscriber>();\n+                channel2sub.put(channel, topicSubs); \n+            }\n+            topicSubs.add(topicSub);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Remove <code>topicSub</code> from Channel <code>channel</code>\n+     *\n+     * @param topicSub\n+     *          Topic Subscription\n+     * @param channel\n+     *          Netty channel\n+     */\n+    public void remove(TopicSubscriber topicSub, Channel channel) {\n+        synchronized (channel) {\n+            Set<TopicSubscriber> topicSubs = channel2sub.get(channel);\n+            if (null != topicSubs) {\n+                if (!topicSubs.remove(topicSub)) {\n+                    logger.warn(\"Failed to remove subscription ({}) due to it isn't on channel ({}).\",\n+                                va(topicSub, channel));\n+                } else if (topicSubs.isEmpty()) {\n+                    channel2sub.remove(channel);\n+                }\n+            }\n+            if (!sub2Channel.remove(topicSub, channel)) {\n+                logger.warn(\"Failed to remove channel ({}) due to it isn't ({})'s channel.\",\n+                            va(channel, topicSub));\n+            }\n+        }\n+    }\n+}"},{"sha":"e2a59c6b0eca0a11aa2e2dc14c43d7fa268bd8e3","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.handlers;\n+\n+import org.jboss.netty.channel.Channel;\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n+import org.apache.hedwig.server.netty.ServerStats;\n+import org.apache.hedwig.server.netty.ServerStats.OpStats;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class UnsubscribeHandler extends BaseHandler {\n+    SubscriptionManager subMgr;\n+    DeliveryManager deliveryMgr;\n+    SubscriptionChannelManager subChannelMgr;\n+    // op stats\n+    final OpStats unsubStats;\n+\n+    public UnsubscribeHandler(ServerConfiguration cfg,\n+                              TopicManager tm,\n+                              SubscriptionManager subMgr,\n+                              DeliveryManager deliveryMgr,\n+                              SubscriptionChannelManager subChannelMgr) {\n+        super(tm, cfg);\n+        this.subMgr = subMgr;\n+        this.deliveryMgr = deliveryMgr;\n+        this.subChannelMgr = subChannelMgr;\n+        unsubStats = ServerStats.getInstance().getOpStats(OperationType.UNSUBSCRIBE);\n+    }\n+\n+    @Override\n+    public void handleRequestAtOwner(final PubSubRequest request, final Channel channel) {\n+        if (!request.hasUnsubscribeRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing unsubscribe request data\");\n+            unsubStats.incrementFailedOps();\n+            return;\n+        }\n+\n+        final UnsubscribeRequest unsubRequest = request.getUnsubscribeRequest();\n+        final ByteString topic = request.getTopic();\n+        final ByteString subscriberId = unsubRequest.getSubscriberId();\n+\n+        final long requestTime = MathUtils.now();\n+        subMgr.unsubscribe(topic, subscriberId, new Callback<Void>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                unsubStats.incrementFailedOps();\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, Void resultOfOperation) {\n+                // we should not close the channel in delivery manager\n+                // since client waits the response for closeSubscription request\n+                // client side would close the channel\n+                deliveryMgr.stopServingSubscriber(topic, subscriberId, null,\n+                new Callback<Void>() {\n+                    @Override\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+                        unsubStats.incrementFailedOps();\n+                    }\n+                    @Override\n+                    public void operationFinished(Object ctx, Void resultOfOperation) {\n+                        // remove the topic subscription from subscription channels\n+                        subChannelMgr.remove(new TopicSubscriber(topic, subscriberId),\n+                                             channel);\n+                        channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId()));\n+                        unsubStats.updateLatency(System.currentTimeMillis() - requestTime);\n+                    }\n+                }, ctx);\n+            }\n+        }, null);\n+\n+    }\n+\n+}"},{"sha":"f0081d99b710564156532379508957019fb9854d","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,37 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.jmx;\n+\n+/**\n+ * An implementor of this interface is basiclly responsible for jmx beans.\n+ */\n+public interface HedwigJMXService {\n+    /**\n+     * register jmx\n+     *\n+     * @param parent\n+     *          Parent JMX Bean\n+     */\n+    public void registerJMX(HedwigMBeanInfo parent);\n+\n+    /**\n+     * unregister jmx\n+     */\n+    public void unregisterJMX();\n+}"},{"sha":"866a2173ac4a14db6f2e2a5202d4c45a13c7f3db","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.jmx;\n+\n+import org.apache.zookeeper.jmx.ZKMBeanInfo;\n+\n+/**\n+ * Hedwig MBean info interface.\n+ */\n+public interface HedwigMBeanInfo extends ZKMBeanInfo {\n+}"},{"sha":"563cae8e1b5d87028b380047ddb2ca5ad5695bbb","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,48 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.jmx;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class provides a unified interface for registering/unregistering of\n+ * Hedwig MBeans with the platform MBean server.\n+ */\n+public class HedwigMBeanRegistry extends BKMBeanRegistry {\n+\n+    static final String SERVICE = \"org.apache.HedwigServer\";\n+\n+    static HedwigMBeanRegistry instance = new HedwigMBeanRegistry();\n+\n+    public static HedwigMBeanRegistry getInstance(){\n+        return instance;\n+    }\n+\n+    @Override\n+    protected String getDomainName() {\n+        return SERVICE;\n+    }\n+\n+}"},{"sha":"6c61a2f9a05f11252d90a96a44163b9a63cfd8b2","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","status":"added","additions":167,"deletions":0,"changes":167,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/FactoryLayout.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,167 @@\n+package org.apache.hedwig.server.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.TextFormat;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+/**\n+ * This class encapsulates metadata manager layout information\n+ * that is persistently stored in zookeeper.\n+ * It provides parsing and serialization methods of such information.\n+ *\n+ */\n+public class FactoryLayout {\n+    static final Logger logger = LoggerFactory.getLogger(FactoryLayout.class);\n+\n+    // metadata manager name\n+    public static final String NAME = \"METADATA\";\n+    // Znode name to store layout information\n+    public static final String LAYOUT_ZNODE = \"LAYOUT\";\n+    public static final String LSEP = \"\\n\";\n+\n+    private ManagerMeta managerMeta;\n+\n+    /**\n+     * Construct metadata manager factory layout.\n+     *\n+     * @param meta\n+     *          Meta describes what kind of factory used.\n+     */\n+    public FactoryLayout(ManagerMeta meta) {\n+        this.managerMeta = meta;\n+    }\n+\n+    public static String getFactoryLayoutPath(StringBuilder sb, ServerConfiguration cfg) {\n+        return cfg.getZkManagersPrefix(sb).append(\"/\").append(NAME)\n+               .append(\"/\").append(LAYOUT_ZNODE).toString();\n+    }\n+\n+    public ManagerMeta getManagerMeta() {\n+        return managerMeta;\n+    }\n+\n+    /**\n+     * Store the factory layout into zookeeper\n+     *\n+     * @param zk\n+     *          ZooKeeper Handle\n+     * @param cfg\n+     *          Server Configuration Object\n+     * @throws KeeperException\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    public void store(ZooKeeper zk, ServerConfiguration cfg)\n+    throws KeeperException, IOException, InterruptedException {\n+        String factoryLayoutPath = getFactoryLayoutPath(new StringBuilder(), cfg);\n+\n+        byte[] layoutData = TextFormat.printToString(managerMeta).getBytes(UTF_8);\n+        ZkUtils.createFullPathOptimistic(zk, factoryLayoutPath, layoutData,\n+                                         Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return managerMeta.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (null == o ||\n+            !(o instanceof FactoryLayout)) {\n+            return false;\n+        }\n+        FactoryLayout other = (FactoryLayout)o;\n+        return managerMeta.equals(other.managerMeta);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return TextFormat.printToString(managerMeta);\n+    }\n+\n+    /**\n+     * Read factory layout from zookeeper\n+     *\n+     * @param zk\n+     *          ZooKeeper Client\n+     * @param cfg\n+     *          Server configuration object\n+     * @return Factory layout, or null if none set in zookeeper\n+     */\n+    public static FactoryLayout readLayout(final ZooKeeper zk,\n+                                           final ServerConfiguration cfg)\n+    throws IOException, KeeperException {\n+        String factoryLayoutPath = getFactoryLayoutPath(new StringBuilder(), cfg);\n+        byte[] layoutData;\n+        try {\n+            layoutData = zk.getData(factoryLayoutPath, false, null);\n+        } catch (KeeperException.NoNodeException nne) {\n+            return null;\n+        } catch (InterruptedException ie) {\n+            throw new IOException(ie);\n+        }\n+        ManagerMeta meta;\n+        try {\n+            BufferedReader reader = new BufferedReader(\n+                    new StringReader(new String(layoutData, UTF_8)));\n+            ManagerMeta.Builder metaBuilder = ManagerMeta.newBuilder();\n+            TextFormat.merge(reader, metaBuilder);\n+            meta = metaBuilder.build();\n+        } catch (InvalidProtocolBufferException ipbe) {\n+            throw new IOException(\"Corrupted factory layout : \", ipbe);\n+        }\n+\n+        return new FactoryLayout(meta);\n+    }\n+\n+    /**\n+     * Remove the factory layout from ZooKeeper.\n+     *\n+     * @param zk\n+     *          ZooKeeper instance\n+     * @param cfg\n+     *          Server configuration object\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     */\n+    public static void deleteLayout(ZooKeeper zk, ServerConfiguration cfg)\n+            throws KeeperException, InterruptedException {\n+        String factoryLayoutPath = getFactoryLayoutPath(new StringBuilder(), cfg);\n+        zk.delete(factoryLayoutPath, -1);\n+    }\n+\n+}"},{"sha":"b1591aa7c456de29de75c9a1721412615fab83fb","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","status":"added","additions":213,"deletions":0,"changes":213,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MetadataManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,213 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import com.google.protobuf.ByteString;\n+\n+/**\n+ * Metadata Manager used to manage metadata used by hedwig.\n+ */\n+public abstract class MetadataManagerFactory {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(MetadataManagerFactory.class);\n+\n+    /**\n+     * Return current factory version.\n+     *\n+     * @return current version used by factory.\n+     */\n+    public abstract int getCurrentVersion();\n+\n+    /**\n+     * Initialize the metadata manager factory with given\n+     * configuration and version.\n+     *\n+     * @param cfg\n+     *          Server configuration object\n+     * @param zk\n+     *          ZooKeeper handler\n+     * @param version\n+     *          Manager version\n+     * @return metadata manager factory\n+     * @throws IOException when fail to initialize the manager.\n+     */\n+    protected abstract MetadataManagerFactory initialize(\n+        ServerConfiguration cfg, ZooKeeper zk, int version)\n+    throws IOException;\n+\n+    /**\n+     * Uninitialize the factory.\n+     *\n+     * @throws IOException when fail to shutdown the factory.\n+     */\n+    public abstract void shutdown() throws IOException;\n+\n+    /**\n+     * Iterate over the topics list.\n+     * Used by HedwigConsole to list available topics.\n+     *\n+     * @return iterator of the topics list.\n+     * @throws IOException\n+     */\n+    public abstract Iterator<ByteString> getTopics() throws IOException;\n+\n+    /**\n+     * Create topic persistence manager.\n+     *\n+     * @return topic persistence manager\n+     */\n+    public abstract TopicPersistenceManager newTopicPersistenceManager();\n+\n+    /**\n+     * Create subscription data manager.\n+     *\n+     * @return subscription data manager.\n+     */\n+    public abstract SubscriptionDataManager newSubscriptionDataManager();\n+\n+    /**\n+     * Create topic ownership manager.\n+     *\n+     * @return topic ownership manager.\n+     */\n+    public abstract TopicOwnershipManager newTopicOwnershipManager();\n+\n+    /**\n+     * Format the metadata for Hedwig.\n+     *\n+     * @param cfg\n+     *          Configuration instance\n+     * @param zk\n+     *          ZooKeeper instance\n+     */\n+    public abstract void format(ServerConfiguration cfg, ZooKeeper zk) throws IOException;\n+\n+    /**\n+     * Create new Metadata Manager Factory.\n+     *\n+     * @param conf\n+     *          Configuration Object.\n+     * @param zk\n+     *          ZooKeeper Client Handle, talk to zk to know which manager factory is used.\n+     * @return new manager factory.\n+     * @throws IOException\n+     */\n+    public static MetadataManagerFactory newMetadataManagerFactory(\n+        final ServerConfiguration conf, final ZooKeeper zk)\n+    throws IOException, KeeperException, InterruptedException {\n+        Class<? extends MetadataManagerFactory> factoryClass;\n+        try {\n+            factoryClass = conf.getMetadataManagerFactoryClass();\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get metadata manager factory class from configuration : \", e);\n+        }\n+        // check that the configured manager is\n+        // compatible with the existing layout\n+        FactoryLayout layout = FactoryLayout.readLayout(zk, conf);\n+        if (layout == null) { // no existing layout\n+            return createMetadataManagerFactory(conf, zk, factoryClass);\n+        }\n+        LOG.debug(\"read meta layout {}\", layout);\n+\n+        if (factoryClass != null &&\n+            !layout.getManagerMeta().getManagerImpl().equals(factoryClass.getName())) {\n+            throw new IOException(\"Configured metadata manager factory \" + factoryClass.getName()\n+                                + \" does not match existing factory \"  + layout.getManagerMeta().getManagerImpl());\n+        }\n+        if (factoryClass == null) {\n+            // no factory specified in configuration\n+            String factoryClsName = layout.getManagerMeta().getManagerImpl();\n+            try {\n+                Class<?> theCls = Class.forName(factoryClsName);\n+                if (!MetadataManagerFactory.class.isAssignableFrom(theCls)) {\n+                    throw new IOException(\"Wrong metadata manager factory \" + factoryClsName);\n+                }\n+                factoryClass = theCls.asSubclass(MetadataManagerFactory.class);\n+            } catch (ClassNotFoundException cnfe) {\n+                throw new IOException(\"No class found to instantiate metadata manager factory \" + factoryClsName);\n+            }\n+        }\n+        // instantiate the metadata manager factory\n+        MetadataManagerFactory managerFactory;\n+        try {\n+            managerFactory = ReflectionUtils.newInstance(factoryClass);\n+        } catch (Throwable t) {\n+            throw new IOException(\"Failed to instantiate metadata manager factory : \" + factoryClass, t);\n+        }\n+        return managerFactory.initialize(conf, zk, layout.getManagerMeta().getManagerVersion());\n+    }\n+\n+    /**\n+     * Create metadata manager factory and write factory layout to ZooKeeper.\n+     *\n+     * @param cfg\n+     *          Server Configuration object.\n+     * @param zk\n+     *          ZooKeeper instance.\n+     * @param factoryClass\n+     *          Metadata Manager Factory Class.\n+     * @return metadata manager factory instance.\n+     * @throws IOException\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     */\n+    public static MetadataManagerFactory createMetadataManagerFactory(\n+            ServerConfiguration cfg, ZooKeeper zk,\n+            Class<? extends MetadataManagerFactory> factoryClass)\n+            throws IOException, KeeperException, InterruptedException {\n+        // use default manager if no one provided\n+        if (factoryClass == null) {\n+            factoryClass = ZkMetadataManagerFactory.class;\n+        }\n+\n+        MetadataManagerFactory managerFactory;\n+        try {\n+            managerFactory = ReflectionUtils.newInstance(factoryClass);\n+        } catch (Throwable t) {\n+            throw new IOException(\"Fail to instantiate metadata manager factory : \" + factoryClass, t);\n+        }\n+        ManagerMeta managerMeta = ManagerMeta.newBuilder()\n+                                  .setManagerImpl(factoryClass.getName())\n+                                  .setManagerVersion(managerFactory.getCurrentVersion())\n+                                  .build();\n+        FactoryLayout layout = new FactoryLayout(managerMeta);\n+        try {\n+            layout.store(zk, cfg);\n+        } catch (KeeperException.NodeExistsException nee) {\n+            FactoryLayout layout2 = FactoryLayout.readLayout(zk, cfg);\n+            if (!layout2.equals(layout)) {\n+                throw new IOException(\"Contention writing to layout to zookeeper, \"\n+                        + \" other layout \" + layout2 + \" is incompatible with our \"\n+                        + \"layout \" + layout);\n+            }\n+        }\n+        return managerFactory.initialize(cfg, zk, layout.getManagerMeta().getManagerVersion());\n+    }\n+}"},{"sha":"b44ca91ce9e0f672281698e29635411c68e64c60","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","status":"added","additions":867,"deletions":0,"changes":867,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/MsMetadataManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,867 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.TextFormat;\n+import com.google.protobuf.TextFormat.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.metastore.MetaStore;\n+import org.apache.bookkeeper.metastore.MetastoreCallback;\n+import org.apache.bookkeeper.metastore.MetastoreCursor;\n+import org.apache.bookkeeper.metastore.MetastoreCursor.ReadEntriesCallback;\n+import org.apache.bookkeeper.metastore.MetastoreException;\n+import org.apache.bookkeeper.metastore.MetastoreFactory;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n+import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n+import org.apache.bookkeeper.metastore.MetastoreTable;\n+import org.apache.bookkeeper.metastore.MetastoreUtils;\n+\n+import static org.apache.bookkeeper.metastore.MetastoreTable.*;\n+import org.apache.bookkeeper.metastore.MetastoreTableItem;\n+import org.apache.bookkeeper.metastore.MSException;\n+import org.apache.bookkeeper.metastore.Value;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * MetadataManagerFactory for plug-in metadata storage.\n+ */\n+public class MsMetadataManagerFactory extends MetadataManagerFactory {\n+    protected final static Logger logger = LoggerFactory.getLogger(MsMetadataManagerFactory.class);\n+\n+    static final String UTF8 = \"UTF-8\";\n+\n+    static final int CUR_VERSION = 1;\n+\n+    static final String OWNER_TABLE_NAME = \"owner\";\n+    static final String PERSIST_TABLE_NAME = \"persist\";\n+    static final String SUB_TABLE_NAME = \"sub\";\n+\n+    static class SyncResult<T> {\n+        T value;\n+        int rc;\n+        boolean finished = false;\n+\n+        public synchronized void complete(int rc, T value) {\n+            this.rc = rc;\n+            this.value = value;\n+            finished = true;\n+\n+            notify();\n+        }\n+\n+        public synchronized void block() throws InterruptedException {\n+            while (!finished) {\n+                wait();\n+            }\n+        }\n+\n+        public int getReturnCode() {\n+            return rc;\n+        }\n+\n+        public T getValue() {\n+            return value;\n+        }\n+    }\n+\n+    MetaStore metastore;\n+    MetastoreTable ownerTable;\n+    MetastoreTable persistTable;\n+    MetastoreScannableTable subTable;\n+    ServerConfiguration cfg;\n+\n+    @Override\n+    public MetadataManagerFactory initialize(ServerConfiguration cfg, ZooKeeper zk, int version) throws IOException {\n+        if (CUR_VERSION != version) {\n+            throw new IOException(\"Incompatible MsMetadataManagerFactory version \" + version\n+                    + \" found, expected version \" + CUR_VERSION);\n+        }\n+        this.cfg = cfg;\n+        try {\n+            metastore = MetastoreFactory.createMetaStore(cfg.getMetastoreImplClass());\n+            // TODO: need to store metastore class and version in some place.\n+            metastore.init(cfg.getConf(), metastore.getVersion());\n+        } catch (Exception e) {\n+            throw new IOException(\"Load metastore failed : \", e);\n+        }\n+\n+        try {\n+            ownerTable = metastore.createTable(OWNER_TABLE_NAME);\n+            if (ownerTable == null) {\n+                throw new IOException(\"create owner table failed\");\n+            }\n+\n+            persistTable = metastore.createTable(PERSIST_TABLE_NAME);\n+            if (persistTable == null) {\n+                throw new IOException(\"create persistence table failed\");\n+            }\n+\n+            subTable = metastore.createScannableTable(SUB_TABLE_NAME);\n+            if (subTable == null) {\n+                throw new IOException(\"create subscription table failed\");\n+            }\n+        } catch (MetastoreException me) {\n+            throw new IOException(\"Failed to create tables : \", me);\n+        }\n+\n+        return this;\n+    }\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        if (metastore == null) {\n+            return;\n+        }\n+\n+        if (ownerTable != null) {\n+            ownerTable.close();\n+            ownerTable = null;\n+        }\n+\n+        if (persistTable != null) {\n+            persistTable.close();\n+            persistTable = null;\n+        }\n+\n+        if (subTable != null) {\n+            subTable.close();\n+            subTable = null;\n+        }\n+\n+        metastore.close();\n+        metastore = null;\n+    }\n+\n+    @Override\n+    public Iterator<ByteString> getTopics() throws IOException {\n+        SyncResult<MetastoreCursor> syn = new SyncResult<MetastoreCursor>();\n+        persistTable.openCursor(NON_FIELDS, new MetastoreCallback<MetastoreCursor>() {\n+            public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                @SuppressWarnings(\"unchecked\")\n+                SyncResult<MetastoreCursor> syn = (SyncResult<MetastoreCursor>) ctx;\n+                syn.complete(rc, cursor);\n+            }\n+        }, syn);\n+        try {\n+            syn.block();\n+        } catch (Exception e) {\n+            throw new IOException(\"Interrupted on getting topics list : \", e);\n+        }\n+\n+        if (syn.getReturnCode() != MSException.Code.OK.getCode()) {\n+            throw new IOException(\"Failed to get topics : \", MSException.create(\n+                    MSException.Code.get(syn.getReturnCode()), \"\"));\n+        }\n+\n+        final MetastoreCursor cursor = syn.getValue();\n+        return new Iterator<ByteString>() {\n+            Iterator<MetastoreTableItem> itemIter = null;\n+\n+            @Override\n+            public boolean hasNext() {\n+                while (null == itemIter || !itemIter.hasNext()) {\n+                    if (!cursor.hasMoreEntries()) {\n+                        return false;\n+                    }\n+\n+                    try {\n+                        itemIter = cursor.readEntries(cfg.getMetastoreMaxEntriesPerScan());\n+                    } catch (MSException mse) {\n+                        logger.warn(\"Interrupted when iterating the topics list : \", mse);\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public ByteString next() {\n+                MetastoreTableItem t = itemIter.next();\n+                return ByteString.copyFromUtf8(t.getKey());\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException(\"Doesn't support remove topic from topic iterator.\");\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public TopicOwnershipManager newTopicOwnershipManager() {\n+        return new MsTopicOwnershipManagerImpl(ownerTable);\n+    }\n+\n+    static class MsTopicOwnershipManagerImpl implements TopicOwnershipManager {\n+\n+        static final String OWNER_FIELD = \"owner\";\n+\n+        final MetastoreTable ownerTable;\n+\n+        MsTopicOwnershipManagerImpl(MetastoreTable ownerTable) {\n+            this.ownerTable = ownerTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void readOwnerInfo(final ByteString topic, final Callback<Versioned<HubInfo>> callback, Object ctx) {\n+            ownerTable.get(topic.toStringUtf8(), new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (MSException.Code.NoKey.getCode() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (MSException.Code.OK.getCode() != rc) {\n+                        logErrorAndFinishOperation(\"Could not read ownership for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+\n+                    HubInfo owner = null;\n+                    try {\n+                        byte[] data = value.getValue().getField(OWNER_FIELD);\n+                        if (data != null) {\n+                            owner = HubInfo.parse(new String(data, UTF_8));\n+                        }\n+                    } catch (HubInfo.InvalidHubInfoException ihie) {\n+                        logger.warn(\"Failed to parse hub info for topic \" + topic.toStringUtf8(), ihie);\n+                    }\n+                    Version version = value.getVersion();\n+                    callback.operationFinished(ctx, new Versioned<HubInfo>(owner, version));\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void writeOwnerInfo(final ByteString topic, final HubInfo owner, final Version version,\n+                final Callback<Version> callback, Object ctx) {\n+            Value value = new Value();\n+            value.setField(OWNER_FIELD, owner.toString().getBytes(UTF_8));\n+\n+            ownerTable.put(topic.toStringUtf8(), value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        callback.operationFinished(ctx, ver);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO, \"No owner info found for topic \"\n+                                        + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.KeyExists.getCode() == rc) {\n+                        // key exists\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.TOPIC_OWNER_INFO_EXISTS, \"Owner info of topic \"\n+                                        + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to update ownership of topic \" + topic.toStringUtf8()\n+                                + \" to \" + owner, callback, ctx, rc);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteOwnerInfo(final ByteString topic, Version version, final Callback<Void> callback,\n+                Object ctx) {\n+            ownerTable.remove(topic.toStringUtf8(), version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        logger.debug(\"Successfully deleted owner info for topic {}\", topic.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(\n+                                ctx,\n+                                PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO, \"No owner info found for topic \"\n+                                        + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete owner info for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public TopicPersistenceManager newTopicPersistenceManager() {\n+        return new MsTopicPersistenceManagerImpl(persistTable);\n+    }\n+\n+    static class MsTopicPersistenceManagerImpl implements TopicPersistenceManager {\n+\n+        static final String PERSIST_FIELD = \"prst\";\n+\n+        final MetastoreTable persistTable;\n+\n+        MsTopicPersistenceManagerImpl(MetastoreTable persistTable) {\n+            this.persistTable = persistTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void readTopicPersistenceInfo(final ByteString topic, final Callback<Versioned<LedgerRanges>> callback,\n+                Object ctx) {\n+            persistTable.get(topic.toStringUtf8(), new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        byte[] data = value.getValue().getField(PERSIST_FIELD);\n+                        if (data != null) {\n+                            parseAndReturnTopicLedgerRanges(topic, data, value.getVersion(), callback, ctx);\n+                        } else { // null data is same as NoKey\n+                            callback.operationFinished(ctx, null);\n+                        }\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                    } else {\n+                        logErrorAndFinishOperation(\"Could not read ledgers node for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        /**\n+         * Parse ledger ranges data and return it thru callback.\n+         *\n+         * @param topic\n+         *            Topic name\n+         * @param data\n+         *            Topic Ledger Ranges data\n+         * @param version\n+         *            Version of the topic ledger ranges data\n+         * @param callback\n+         *            Callback to return ledger ranges\n+         * @param ctx\n+         *            Context of the callback\n+         */\n+        private void parseAndReturnTopicLedgerRanges(ByteString topic, byte[] data, Version version,\n+                Callback<Versioned<LedgerRanges>> callback, Object ctx) {\n+            try {\n+                LedgerRanges.Builder rangesBuilder = LedgerRanges.newBuilder();\n+                TextFormat.merge(new String(data, UTF8), rangesBuilder);\n+                LedgerRanges lr = rangesBuilder.build();\n+                Versioned<LedgerRanges> ranges = new Versioned<LedgerRanges>(lr, version);\n+                callback.operationFinished(ctx, ranges);\n+            } catch (ParseException e) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Ledger ranges for topic \").append(topic.toStringUtf8())\n+                        .append(\" could not be deserialized.\");\n+                String msg = sb.toString();\n+                logger.error(msg, e);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+            } catch (UnsupportedEncodingException uee) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Ledger ranges for topic \").append(topic.toStringUtf8()).append(\" is not UTF-8 encoded.\");\n+                String msg = sb.toString();\n+                logger.error(msg, uee);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+            }\n+        }\n+\n+        @Override\n+        public void writeTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges, final Version version,\n+                final Callback<Version> callback, Object ctx) {\n+            Value value = new Value();\n+            value.setField(PERSIST_FIELD, TextFormat.printToString(ranges).getBytes(UTF_8));\n+\n+            persistTable.put(topic.toStringUtf8(), value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        callback.operationFinished(ctx, ver);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.KeyExists.getCode() == rc) {\n+                        // key exists\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS,\n+                                \"Persistence info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Could not write ledgers node for topic \" + topic.toStringUtf8(),\n+                                callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteTopicPersistenceInfo(final ByteString topic, final Version version,\n+                final Callback<Void> callback, Object ctx) {\n+            persistTable.remove(topic.toStringUtf8(), version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (MSException.Code.OK.getCode() == rc) {\n+                        logger.debug(\"Successfully deleted persistence info for topic {}.\", topic.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (MSException.Code.NoKey.getCode() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (MSException.Code.BadVersion.getCode() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete persistence info topic: \" + topic.toStringUtf8()\n+                                + \", version: \" + version, callback, ctx, rc, StatusCode.SERVICE_DOWN);\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public SubscriptionDataManager newSubscriptionDataManager() {\n+        return new MsSubscriptionDataManagerImpl(cfg, subTable);\n+    }\n+\n+    static class MsSubscriptionDataManagerImpl implements SubscriptionDataManager {\n+\n+        static final String SUB_STATE_FIELD = \"sub_state\";\n+        static final String SUB_PREFS_FIELD = \"sub_preferences\";\n+\n+        static final char TOPIC_SUB_FIRST_SEPARATOR = '\\001';\n+        static final char TOPIC_SUB_LAST_SEPARATOR = '\\002';\n+\n+        final ServerConfiguration cfg;\n+        final MetastoreScannableTable subTable;\n+\n+        MsSubscriptionDataManagerImpl(ServerConfiguration cfg, MetastoreScannableTable subTable) {\n+            this.cfg = cfg;\n+            this.subTable = subTable;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing\n+        }\n+\n+        private String getSubscriptionKey(ByteString topic, ByteString subscriberId) {\n+            return new StringBuilder(topic.toStringUtf8()).append(TOPIC_SUB_FIRST_SEPARATOR)\n+                    .append(subscriberId.toStringUtf8()).toString();\n+        }\n+\n+        private Value subscriptionData2Value(SubscriptionData subData) {\n+            Value value = new Value();\n+            if (subData.hasState()) {\n+                value.setField(SUB_STATE_FIELD, TextFormat.printToString(subData.getState()).getBytes(UTF_8));\n+            }\n+            if (subData.hasPreferences()) {\n+                value.setField(SUB_PREFS_FIELD, TextFormat.printToString(subData.getPreferences()).getBytes(UTF_8));\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public void createSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Callback<Version> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            Value value = subscriptionData2Value(subData);\n+\n+            subTable.put(key, value, Version.NEW, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version ver, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully create subscription for topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData));\n+                        }\n+                        callback.operationFinished(ctx, ver);\n+                    } else if (rc == MSException.Code.KeyExists.getCode()) {\n+                        callback.operationFailed(ctx, PubSubException.create(\n+                                StatusCode.SUBSCRIPTION_STATE_EXISTS,\n+                                \"Subscription data for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \") existed.\"));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to create topic: \" + topic.toStringUtf8()\n+                                + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                + SubscriptionStateUtils.toString(subData), callback, ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public boolean isPartialUpdateSupported() {\n+            // TODO: Here we assume Metastore support partial update, but this\n+            // maybe incorrect.\n+            return true;\n+        }\n+\n+        @Override\n+        public void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Version version, final Callback<Version> callback,\n+                final Object ctx) {\n+            updateSubscriptionData(topic, subscriberId, subData, version, callback, ctx);\n+        }\n+\n+        @Override\n+        public void updateSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final SubscriptionData subData, final Version version, final Callback<Version> callback,\n+                final Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            Value value = subscriptionData2Value(subData);\n+\n+            subTable.put(key, value, version, new MetastoreCallback<Version>() {\n+                @Override\n+                public void complete(int rc, Version version, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully updated subscription data for topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData) + \", version: \" + version);\n+                        }\n+                        callback.operationFinished(ctx, version);\n+                    } else if (rc == MSException.Code.NoKey.getCode()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                \"No subscription data found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc == MSException.Code.BadVersion.getCode()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to update subscription data of topic \" + topic.toStringUtf8()\n+                                        + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\n+                                \"Failed to update subscription data for topic: \" + topic.toStringUtf8()\n+                                        + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                        + SubscriptionStateUtils.toString(subData) + \", version: \" + version, callback,\n+                                ctx, rc);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId, Version version,\n+                final Callback<Void> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            subTable.remove(key, version, new MetastoreCallback<Void>() {\n+                @Override\n+                public void complete(int rc, Void value, Object ctx) {\n+                    if (rc == MSException.Code.OK.getCode()) {\n+                        logger.debug(\"Successfully delete subscription for topic: {}, subscriberId: {}.\",\n+                                topic.toStringUtf8(), subscriberId.toStringUtf8());\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (rc == MSException.Code.BadVersion.getCode()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                \"Bad version provided to delete subscriptoin data of topic \" + topic.toStringUtf8()\n+                                        + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else if (rc == MSException.Code.NoKey.getCode()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                \"No subscription data found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                        + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else {\n+                        logErrorAndFinishOperation(\"Failed to delete subscription topic: \" + topic.toStringUtf8()\n+                                + \", subscriberId: \" + subscriberId.toStringUtf8(), callback, ctx, rc,\n+                                StatusCode.SERVICE_DOWN);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        private SubscriptionData value2SubscriptionData(Value value) throws ParseException,\n+                UnsupportedEncodingException {\n+            SubscriptionData.Builder builder = SubscriptionData.newBuilder();\n+\n+            byte[] stateData = value.getField(SUB_STATE_FIELD);\n+            if (null != stateData) {\n+                SubscriptionState.Builder stateBuilder = SubscriptionState.newBuilder();\n+                TextFormat.merge(new String(stateData, UTF8), stateBuilder);\n+                SubscriptionState state = stateBuilder.build();\n+                builder.setState(state);\n+            }\n+\n+            byte[] prefsData = value.getField(SUB_PREFS_FIELD);\n+            if (null != prefsData) {\n+                SubscriptionPreferences.Builder preferencesBuilder = SubscriptionPreferences.newBuilder();\n+                TextFormat.merge(new String(prefsData, UTF8), preferencesBuilder);\n+                SubscriptionPreferences preferences = preferencesBuilder.build();\n+                builder.setPreferences(preferences);\n+            }\n+\n+            return builder.build();\n+        }\n+\n+        @Override\n+        public void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                final Callback<Versioned<SubscriptionData>> callback, Object ctx) {\n+            String key = getSubscriptionKey(topic, subscriberId);\n+            subTable.get(key, new MetastoreCallback<Versioned<Value>>() {\n+                @Override\n+                public void complete(int rc, Versioned<Value> value, Object ctx) {\n+                    if (rc == MSException.Code.NoKey.getCode()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (rc != MSException.Code.OK.getCode()) {\n+                        logErrorAndFinishOperation(\n+                                \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                        + \", subscriberId: \" + subscriberId.toStringUtf8(), callback, ctx, rc);\n+                        return;\n+                    }\n+\n+                    try {\n+                        Versioned<SubscriptionData> subData = new Versioned<SubscriptionData>(\n+                                value2SubscriptionData(value.getValue()), value.getVersion());\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                    + \", subscriberId: \" + subscriberId.toStringUtf8() + \", data: \"\n+                                    + SubscriptionStateUtils.toString(subData.getValue()) + \", version: \"\n+                                    + subData.getVersion());\n+                        }\n+                        callback.operationFinished(ctx, subData);\n+                    } catch (ParseException e) {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(\"Failed to deserialize subscription data for topic:\").append(topic.toStringUtf8())\n+                                .append(\", subscriberId: \").append(subscriberId.toStringUtf8());\n+                        String msg = sb.toString();\n+                        logger.error(msg, e);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                    } catch (UnsupportedEncodingException uee) {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(\"Subscription data for topic: \").append(topic.toStringUtf8())\n+                                .append(\", subscriberId: \").append(subscriberId.toStringUtf8())\n+                                .append(\" is not UFT-8 encoded\");\n+                        String msg = sb.toString();\n+                        logger.error(msg, uee);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        private String getSubscriptionPrefix(ByteString topic, char sep) {\n+            return new StringBuilder(topic.toStringUtf8()).append(sep).toString();\n+        }\n+\n+        private void readSubscriptions(final ByteString topic, final int keyLength, final MetastoreCursor cursor,\n+                final Map<ByteString, Versioned<SubscriptionData>> topicSubs,\n+                final Callback<Map<ByteString, Versioned<SubscriptionData>>> callback, Object ctx) {\n+            if (!cursor.hasMoreEntries()) {\n+                callback.operationFinished(ctx, topicSubs);\n+                return;\n+            }\n+            ReadEntriesCallback readCb = new ReadEntriesCallback() {\n+                @Override\n+                public void complete(int rc, Iterator<MetastoreTableItem> items, Object ctx) {\n+                    if (rc != MSException.Code.OK.getCode()) {\n+                        logErrorAndFinishOperation(\"Could not read subscribers for cursor \" + cursor,\n+                                callback, ctx, rc);\n+                        return;\n+                    }\n+                    while (items.hasNext()) {\n+                        MetastoreTableItem item = items.next();\n+                        final ByteString subscriberId = ByteString.copyFromUtf8(item.getKey().substring(keyLength));\n+                        try {\n+                            Versioned<Value> vv = item.getValue();\n+                            Versioned<SubscriptionData> subData = new Versioned<SubscriptionData>(\n+                                    value2SubscriptionData(vv.getValue()), vv.getVersion());\n+                            topicSubs.put(subscriberId, subData);\n+                        } catch (ParseException e) {\n+                            StringBuilder sb = new StringBuilder();\n+                            sb.append(\"Failed to deserialize subscription data for topic: \")\n+                                    .append(topic.toStringUtf8()).append(\", subscriberId: \")\n+                                    .append(subscriberId.toStringUtf8());\n+                            String msg = sb.toString();\n+                            logger.error(msg, e);\n+                            callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                            return;\n+                        } catch (UnsupportedEncodingException e) {\n+                            StringBuilder sb = new StringBuilder();\n+                            sb.append(\"Subscription data for topic: \").append(topic.toStringUtf8())\n+                                    .append(\", subscriberId: \").append(subscriberId.toStringUtf8())\n+                                    .append(\" is not UTF-8 encoded.\");\n+                            String msg = sb.toString();\n+                            logger.error(msg, e);\n+                            callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                            return;\n+                        }\n+                    }\n+                    readSubscriptions(topic, keyLength, cursor, topicSubs, callback, ctx);\n+                }\n+            };\n+            cursor.asyncReadEntries(cfg.getMetastoreMaxEntriesPerScan(), readCb, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptions(final ByteString topic,\n+                final Callback<Map<ByteString, Versioned<SubscriptionData>>> callback, Object ctx) {\n+            final String firstKey = getSubscriptionPrefix(topic, TOPIC_SUB_FIRST_SEPARATOR);\n+            String lastKey = getSubscriptionPrefix(topic, TOPIC_SUB_LAST_SEPARATOR);\n+            subTable.openCursor(firstKey, true, lastKey, true, Order.ASC, ALL_FIELDS,\n+                    new MetastoreCallback<MetastoreCursor>() {\n+                        @Override\n+                        public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n+                            if (rc != MSException.Code.OK.getCode()) {\n+                                logErrorAndFinishOperation(\n+                                        \"Could not read subscribers for topic \" + topic.toStringUtf8(), callback, ctx,\n+                                        rc);\n+                                return;\n+                            }\n+\n+                            final Map<ByteString, Versioned<SubscriptionData>> topicSubs =\n+                                    new ConcurrentHashMap<ByteString, Versioned<SubscriptionData>>();\n+                            readSubscriptions(topic, firstKey.length(), cursor, topicSubs, callback, ctx);\n+                        }\n+                    }, ctx);\n+        }\n+    }\n+\n+    /**\n+     * callback finish operation with exception specify by code, regardless of\n+     * the value of return code rc.\n+     */\n+    private static <T> void logErrorAndFinishOperation(String msg, Callback<T> callback, Object ctx, int rc,\n+            StatusCode code) {\n+        logger.error(msg, MSException.create(MSException.Code.get(rc), \"\"));\n+        callback.operationFailed(ctx, PubSubException.create(code, msg));\n+    }\n+\n+    /**\n+     * callback finish operation with corresponding PubSubException converted\n+     * from return code rc.\n+     */\n+    private static <T> void logErrorAndFinishOperation(String msg, Callback<T> callback, Object ctx, int rc) {\n+        StatusCode code;\n+\n+        if (rc == MSException.Code.NoKey.getCode()) {\n+            code = StatusCode.NO_SUCH_TOPIC;\n+        } else if (rc == MSException.Code.ServiceDown.getCode()) {\n+            code = StatusCode.SERVICE_DOWN;\n+        } else {\n+            code = StatusCode.UNEXPECTED_CONDITION;\n+        }\n+\n+        logErrorAndFinishOperation(msg, callback, ctx, rc, code);\n+    }\n+\n+    @Override\n+    public void format(ServerConfiguration cfg, ZooKeeper zk) throws IOException {\n+        try {\n+            int maxEntriesPerScan = cfg.getMetastoreMaxEntriesPerScan();\n+\n+            // clean topic ownership table.\n+            logger.info(\"Cleaning topic ownership table ...\");\n+            MetastoreUtils.cleanTable(ownerTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic ownership table successfully.\");\n+\n+            // clean topic subscription table.\n+            logger.info(\"Cleaning topic subscription table ...\");\n+            MetastoreUtils.cleanTable(subTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic subscription table successfully.\");\n+\n+            // clean topic persistence info table.\n+            logger.info(\"Cleaning topic persistence info table ...\");\n+            MetastoreUtils.cleanTable(persistTable, maxEntriesPerScan);\n+            logger.info(\"Cleaned topic persistence info table successfully.\");\n+        } catch (MSException mse) {\n+            throw new IOException(\"Exception when formatting hedwig metastore : \", mse);\n+        } catch (InterruptedException ie) {\n+            throw new IOException(\"Interrupted when formatting hedwig metastore : \", ie);\n+        }\n+    }\n+\n+}"},{"sha":"133356009cc9914e2867b342fa1a130e84546073","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","status":"added","additions":159,"deletions":0,"changes":159,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,159 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Manage subscription data.\n+ */\n+public interface SubscriptionDataManager extends Closeable {\n+\n+    /**\n+     * Create subscription data.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param data \n+     *          Subscription data\n+     * @param callback\n+     *          Callback when subscription state created. New version would be returned.\n+     *          {@link PubSubException.SubscriptionStateExistsException} is returned when subscription state\n+     *          existed before.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n+                                       Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Whether the metadata manager supports partial update.\n+     *\n+     * @return true if the metadata manager supports partial update.\n+     *         otherwise, return false.\n+     */\n+    public boolean isPartialUpdateSupported();\n+\n+    /**\n+     * Update subscription data.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param dataToUpdate\n+     *          Subscription data to update. So it is a partial data, which contains\n+     *          the part of data to update. The implementation should not replace\n+     *          existing subscription data with <i>dataToUpdate</i> directly.\n+     *          E.g. if there is only state in it, you should update state only.\n+     * @param version\n+     *          Current version of subscription data.\n+     * @param callback\n+     *          Callback when subscription state updated. New version would be returned.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToUpdate, \n+                                       Version version, Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Replace subscription data.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param dataToReplace\n+     *          Subscription data to replace.\n+     * @param version\n+     *          Current version of subscription data.\n+     * @param callback\n+     *          Callback when subscription state updated. New version would be returned.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToReplace,\n+                                        Version version, Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Remove subscription data.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param version\n+     *          Current version of subscription data.\n+     * @param callback\n+     *          Callback when subscription state deleted\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version,\n+                                       Callback<Void> callback, Object ctx);\n+\n+    /**\n+     * Read subscription data with version.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber id\n+     * @param callback\n+     *          Callback when subscription data read.\n+     *          Null is returned when no subscription data is found.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readSubscriptionData(ByteString topic, ByteString subscriberId,\n+                                     Callback<Versioned<SubscriptionData>> callback, Object ctx);\n+\n+    /**\n+     * Read all subscriptions of a topic.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param callback\n+     *          Callback to return subscriptions with version information\n+     * @param ctx\n+     *          Contxt of the callback\n+     */\n+    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, Versioned<SubscriptionData>>> cb,\n+                                  Object ctx);\n+}"},{"sha":"15484c5230fed7350e3a9d1933c659f8daefb36c","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicOwnershipManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,100 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * Manage topic ownership\n+ */\n+public interface TopicOwnershipManager extends Closeable {\n+\n+    /**\n+     * Read owner information of a topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param callback\n+     *          Callback to return hub info. If there is no owner info, return null;\n+     *          If there is data but not valid owner info, return a Versioned object with null hub info;\n+     *          If there is valid owner info, return versioned hub info.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readOwnerInfo(ByteString topic, Callback<Versioned<HubInfo>> callback, Object ctx);\n+\n+    /**\n+     * Write owner info for a specified topic.\n+     * A new owner info would be created if there is no one existed before.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param owner\n+     *          Owner hub info\n+     * @param version\n+     *          Current version of owner info\n+     *          If <code>version</code> is {@link Version.NEW}, create owner info.\n+     *          {@link PubSubException.TopicOwnerInfoExistsException} is returned when\n+     *          owner info existed before.\n+     *          Otherwise, the owner info is updated only when\n+     *          provided version equals to its current version.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoTopicOwnerInfoException} is returned when no owner info\n+     *          found to update.\n+     * @param callback\n+     *          Callback when owner info updated. New version would be returned if succeed to write.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void writeOwnerInfo(ByteString topic, HubInfo owner, Version version,\n+                               Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Delete owner info for a specified topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param version\n+     *          Current version of owner info\n+     *          If <code>version</code> is {@link Version.ANY}, delete owner info no matter its current version.\n+     *          Otherwise, the owner info is deleted only when\n+     *          provided version equals to its current version.\n+     * @param callback\n+     *          Callback when owner info deleted.\n+     *          {@link PubSubException.NoTopicOwnerInfoException} is returned when no owner info.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match.\n+     * @param ctx\n+     *          Context of the callback.\n+     */\n+    public void deleteOwnerInfo(ByteString topic, Version version,\n+                                Callback<Void> callback, Object ctx);\n+}"},{"sha":"69ee709c4dd2b484d2efe0b85838ba62142776f7","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/TopicPersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.Closeable;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * Manage topic persistence metadata.\n+ */\n+public interface TopicPersistenceManager extends Closeable {\n+\n+    /**\n+     * Read persistence info of a specified topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param callback\n+     *          Callback when read persistence info.\n+     *          If no persistence info found, return null.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void readTopicPersistenceInfo(ByteString topic,\n+                                         Callback<Versioned<LedgerRanges>> callback, Object ctx);\n+\n+    /**\n+     * Update persistence info of a specified topic.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param ranges\n+     *          Persistence info\n+     * @param version\n+     *          Current version of persistence info.\n+     *          If <code>version</code> is {@link Version.NEW}, create persistence info;\n+     *          {@link PubSubException.TopicPersistenceInfoExistsException} is returned when\n+     *          persistence info existed before.\n+     *          Otherwise, the persitence info is updated only when\n+     *          provided version equals to its current version.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoTopicPersistenceInfoException} is returned when no\n+     *          persistence info found to update.\n+     * @param callback\n+     *          Callback when persistence info updated. New version would be returned.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void writeTopicPersistenceInfo(ByteString topic, LedgerRanges ranges, Version version,\n+                                          Callback<Version> callback, Object ctx);\n+\n+    /**\n+     * Delete persistence info of a specified topic.\n+     * Currently used in test cases.\n+     *\n+     * @param topic\n+     *          Topic name\n+     * @param version\n+     *          Current version of persistence info\n+     *          If <code>version</code> is {@link Version.ANY}, delete persistence info no matter its current version.\n+     *          Otherwise, the persitence info is deleted only when\n+     *          provided version equals to its current version.\n+     * @param callback\n+     *          Callback return whether the deletion succeed.\n+     *          {@link PubSubException.NoTopicPersistenceInfoException} is returned when no persistence.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match.\n+     *          info found to delete.\n+     * @param ctx\n+     *          Context of the callback\n+     */\n+    public void deleteTopicPersistenceInfo(ByteString topic, Version version,\n+                                           Callback<Void> callback, Object ctx);\n+\n+}"},{"sha":"9b5fe08bd146bb937908c47d2a625f48f1916924","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","status":"added","additions":842,"deletions":0,"changes":842,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,842 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.meta;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZKUtil;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.data.Stat;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.meta.ZkVersion;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.topics.HubInfo;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.zookeeper.SafeAsyncZKCallback;\n+import org.apache.hedwig.zookeeper.ZkUtils;\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+/**\n+ * ZooKeeper-based Metadata Manager.\n+ */\n+public class ZkMetadataManagerFactory extends MetadataManagerFactory {\n+    protected final static Logger logger = LoggerFactory.getLogger(ZkMetadataManagerFactory.class);\n+\n+    static final int CUR_VERSION = 1;\n+\n+    ZooKeeper zk;\n+    ServerConfiguration cfg;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public MetadataManagerFactory initialize(ServerConfiguration cfg,\n+                                             ZooKeeper zk,\n+                                             int version)\n+    throws IOException {\n+        if (CUR_VERSION != version) {\n+            throw new IOException(\"Incompatible ZkMetadataManagerFactory version \" + version\n+                                + \" found, expected version \" + CUR_VERSION);\n+        }\n+        this.cfg = cfg;\n+        this.zk = zk;\n+        return this;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        // do nothing here, because zookeeper handle is passed from outside\n+        // we don't need to stop it.\n+    }\n+\n+    @Override\n+    public Iterator<ByteString> getTopics() throws IOException {\n+        List<String> topics;\n+        try {\n+            topics = zk.getChildren(cfg.getZkTopicsPrefix(new StringBuilder()).toString(), false);\n+        } catch (KeeperException ke) {\n+            throw new IOException(\"Failed to get topics list : \", ke);\n+        } catch (InterruptedException ie) {\n+            throw new IOException(\"Interrupted on getting topics list : \", ie);\n+        }\n+        final Iterator<String> iter = topics.iterator();\n+        return new Iterator<ByteString>() {\n+            @Override\n+            public boolean hasNext() {\n+                return iter.hasNext();\n+            }\n+            @Override\n+            public ByteString next() {\n+                String t = iter.next();\n+                return ByteString.copyFromUtf8(t);\n+            }\n+            @Override\n+            public void remove() {\n+                iter.remove();\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public TopicPersistenceManager newTopicPersistenceManager() {\n+        return new ZkTopicPersistenceManagerImpl(cfg, zk);\n+    }\n+\n+    @Override\n+    public SubscriptionDataManager newSubscriptionDataManager() {\n+        return new ZkSubscriptionDataManagerImpl(cfg, zk);\n+    }\n+\n+    @Override\n+    public TopicOwnershipManager newTopicOwnershipManager() {\n+        return new ZkTopicOwnershipManagerImpl(cfg, zk);\n+    }\n+\n+    /**\n+     * ZooKeeper based topic persistence manager.\n+     */\n+    static class ZkTopicPersistenceManagerImpl implements TopicPersistenceManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkTopicPersistenceManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Get znode path to store persistence info of a topic.\n+         *\n+         * @param topic\n+         *          Topic name\n+         * @return znode path to store persistence info.\n+         */\n+        private String ledgersPath(ByteString topic) {\n+            return cfg.getZkTopicPath(new StringBuilder(), topic).append(\"/ledgers\").toString();\n+        }\n+\n+        /**\n+         * Parse ledger ranges data and return it thru callback.\n+         *\n+         * @param topic\n+         *          Topic name\n+         * @param data\n+         *          Topic Ledger Ranges data\n+         * @param version\n+         *          Version of the topic ledger ranges data\n+         * @param callback\n+         *          Callback to return ledger ranges\n+         * @param ctx\n+         *          Context of the callback\n+         */\n+        private void parseAndReturnTopicLedgerRanges(ByteString topic, byte[] data, int version,\n+                                                     Callback<Versioned<LedgerRanges>> callback, Object ctx) {\n+            try {\n+                Versioned<LedgerRanges> ranges = new Versioned<LedgerRanges>(LedgerRanges.parseFrom(data),\n+                                                                             new ZkVersion(version));\n+                callback.operationFinished(ctx, ranges);\n+                return;\n+            } catch (InvalidProtocolBufferException e) {\n+                String msg = \"Ledger ranges for topic:\" + topic.toStringUtf8() + \" could not be deserialized\";\n+                logger.error(msg, e);\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                return;\n+            }\n+        }\n+\n+        @Override\n+        public void readTopicPersistenceInfo(final ByteString topic,\n+                                             final Callback<Versioned<LedgerRanges>> callback,\n+                                             Object ctx) {\n+            // read topic ledgers node data\n+            final String zNodePath = ledgersPath(topic);\n+\n+            zk.getData(zNodePath, false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (rc == Code.OK.intValue()) {\n+                        parseAndReturnTopicLedgerRanges(topic, data, stat.getVersion(), callback, ctx);\n+                        return;\n+                    }\n+\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // we don't create the znode until we first write it.\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    // otherwise some other error\n+                    KeeperException ke =\n+                        ZkUtils.logErrorAndCreateZKException(\"Could not read ledgers node for topic: \"\n+                                                             + topic.toStringUtf8(), path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                }\n+            }, ctx);\n+        }\n+\n+        private void createTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges,\n+                                                final Callback<Version> callback, Object ctx) {\n+            final String zNodePath = ledgersPath(topic);\n+            final byte[] data = ranges.toByteArray();\n+            // create it\n+            ZkUtils.createFullPathOptimistic(zk, zNodePath, data, Ids.OPEN_ACL_UNSAFE,\n+            CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                    if (rc == Code.NODEEXISTS.intValue()) {\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_PERSISTENCE_INFO_EXISTS,\n+                                                      \"Persistence info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    }\n+                    if (rc != Code.OK.intValue()) {\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                             \"Could not create ledgers node for topic: \" + topic.toStringUtf8(),\n+                                             path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                        return;\n+                    }\n+                    // initial version is version 0\n+                    callback.operationFinished(ctx, new ZkVersion(0));\n+                }\n+            }, ctx);\n+            return;\n+        }\n+\n+        @Override\n+        public void writeTopicPersistenceInfo(final ByteString topic, LedgerRanges ranges, final Version version,\n+                                              final Callback<Version> callback, Object ctx) {\n+            if (Version.NEW == version) {\n+                createTopicPersistenceInfo(topic, ranges, callback, ctx);\n+                return;\n+            }\n+\n+            final String zNodePath = ledgersPath(topic);\n+            final byte[] data = ranges.toByteArray();\n+\n+            if (!(version instanceof ZkVersion)) {\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                              \"Invalid version provided to update persistence info for topic \" + topic.toStringUtf8()));\n+                return;\n+            }\n+\n+            int znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+            zk.setData(zNodePath, data, znodeVersion, new SafeAsyncZKCallback.StatCallback() {\n+                    @Override\n+                    public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                        if (rc == Code.NONODE.intValue()) {\n+                            // no node\n+                            callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                                          \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                            return;\n+                        } else if (rc == Code.BADVERSION.intValue()) {\n+                            // bad version\n+                            callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                          \"Bad version provided to update persistence info of topic \" + topic.toStringUtf8()));\n+                            return;\n+                        } else if (rc == Code.OK.intValue()) {\n+                            callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n+                            return;\n+                        } else {\n+                            KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                    \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n+                            callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                            return;\n+                        }\n+                    }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteTopicPersistenceInfo(final ByteString topic, final Version version,\n+                                               final Callback<Void> callback, Object ctx) {\n+            final String zNodePath = ledgersPath(topic);\n+\n+            int znodeVersion = -1;\n+            if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete persistence info for topic \" + topic.toStringUtf8()));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            zk.delete(zNodePath, znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (rc == Code.OK.intValue()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_PERSISTENCE_INFO,\n+                                                      \"No persistence info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (rc == Code.BADVERSION.intValue()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete persistence info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    }\n+\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                        + \" failed to delete persistence info @version \" + version + \" : \", path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    /**\n+     * ZooKeeper based subscription data manager.\n+     */\n+    static class ZkSubscriptionDataManagerImpl implements SubscriptionDataManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkSubscriptionDataManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Get znode path to store subscription states.\n+         *\n+         * @param sb\n+         *          String builder to store the znode path.\n+         * @param topic\n+         *          Topic name.\n+         *\n+         * @return string builder to store znode path.\n+         */\n+        private StringBuilder topicSubscribersPath(StringBuilder sb, ByteString topic) {\n+            return cfg.getZkTopicPath(sb, topic).append(\"/subscribers\");\n+        }\n+\n+        /**\n+         * Get znode path to store subscription state for a specified subscriber.\n+         *\n+         * @param topic\n+         *          Topic name.\n+         * @param subscriber\n+         *          Subscriber id.\n+         * @return znode path to store subscription state.\n+         */\n+        private String topicSubscriberPath(ByteString topic, ByteString subscriber) {\n+            return topicSubscribersPath(new StringBuilder(), topic).append(\"/\").append(subscriber.toStringUtf8())\n+                   .toString();\n+        }\n+\n+        @Override\n+        public boolean isPartialUpdateSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void createSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n+                                           final Callback<Version> callback, final Object ctx) {\n+            ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), data.toByteArray(),\n+            Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+\n+                    if (rc == Code.NODEEXISTS.intValue()) {\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.SUBSCRIPTION_STATE_EXISTS,\n+                                                      \"Subscription state for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \") existed.\"));\n+                        return;\n+                    } else if (rc == Code.OK.intValue()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully recorded subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" data: \"\n+                                         + SubscriptionStateUtils.toString(data));\n+                        }\n+                        callback.operationFinished(ctx, new ZkVersion(0));\n+                    } else {\n+                        KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n+                                                 \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void updateSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n+                                           final Version version, final Callback<Version> callback, final Object ctx) {\n+            throw new UnsupportedOperationException(\"ZooKeeper based metadata manager doesn't support partial update!\");\n+        }\n+\n+        @Override\n+        public void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n+                                            final Version version, final Callback<Version> callback, final Object ctx) {\n+            int znodeVersion = -1;\n+            if (Version.NEW == version) {\n+                callback.operationFailed(ctx, \n+                        new PubSubException.BadVersionException(\"Can not replace Version.New subscription data\"));\n+                return;\n+            } else if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to replace subscription data for topic  \" \n+                                                  + topic.toStringUtf8() + \" subscribe id: \" + subscriberId));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            zk.setData(topicSubscriberPath(topic, subscriberId), data.toByteArray(), \n+                    znodeVersion, new SafeAsyncZKCallback.StatCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                                      \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc == Code.BADVERSION.intValue()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to replace subscription data of topic \" \n+                                                      + topic.toStringUtf8() + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else if (rc != Code.OK.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                            + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                            + \" could not set subscription data: \" + SubscriptionStateUtils.toString(data),\n+                                            path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    } else {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully updated subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8() + \" data: \"\n+                                         + SubscriptionStateUtils.toString(data));\n+                        }\n+\n+                        callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId, Version version,\n+                                           final Callback<Void> callback, Object ctx) {\n+            \n+            int znodeVersion = -1;\n+            if (Version.NEW == version) {\n+                callback.operationFailed(ctx, \n+                        new PubSubException.BadVersionException(\"Can not delete Version.New subscription data\"));\n+                return;\n+            } else if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete subscription data for topic  \" \n+                                                  + topic.toStringUtf8() + \" subscribe id: \" + subscriberId));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            \n+            zk.delete(topicSubscriberPath(topic, subscriberId), znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_SUBSCRIPTION_STATE,\n+                                                      \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n+                                                      + subscriberId.toStringUtf8() + \").\"));\n+                        return;\n+                    } else if (rc == Code.BADVERSION.intValue()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete subscription data of topic \" \n+                                                      + topic.toStringUtf8() + \" subscriberId \" + subscriberId));\n+                        return;\n+                    } else if (rc == Code.OK.intValue()) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully deleted subscription for topic: \" + topic.toStringUtf8()\n+                                         + \" subscriberId: \" + subscriberId.toStringUtf8());\n+                        }\n+\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n+                                        + \" subscriberId: \" + subscriberId.toStringUtf8() + \" failed to delete subscription\", path, rc);\n+                    callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                         final Callback<Versioned<SubscriptionData>> callback, final Object ctx) {\n+            zk.getData(topicSubscriberPath(topic, subscriberId), false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+                    if (rc != Code.OK.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                                + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                    \n+                    Versioned<SubscriptionData> subData;\n+                    try {\n+                        subData = new Versioned<SubscriptionData>(\n+                                        SubscriptionStateUtils.parseSubscriptionData(data), \n+                                        new ZkVersion(stat.getVersion()));\n+                    } catch (InvalidProtocolBufferException ex) {\n+                        String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8();\n+                        logger.error(msg, ex);\n+                        callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(msg));\n+                        return;\n+                    }\n+\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                     + \" subscriberId: \" + subscriberId.toStringUtf8()\n+                                     + \" data: \" + SubscriptionStateUtils.toString(subData.getValue()));\n+                    }\n+                    callback.operationFinished(ctx, subData);\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void readSubscriptions(final ByteString topic,\n+                                      final Callback<Map<ByteString, Versioned<SubscriptionData>>> cb, final Object ctx) {\n+            String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n+            zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, final Object ctx, final List<String> children) {\n+\n+                    if (rc != Code.OK.intValue() && rc != Code.NONODE.intValue()) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read subscribers for topic \"\n+                                            + topic.toStringUtf8(), path, rc);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+\n+                    final Map<ByteString, Versioned<SubscriptionData>> topicSubs = \n+                            new ConcurrentHashMap<ByteString, Versioned<SubscriptionData>>();\n+\n+                    if (rc == Code.NONODE.intValue() || children.size() == 0) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"No subscriptions found while acquiring topic: \" + topic.toStringUtf8());\n+                        }\n+                        cb.operationFinished(ctx, topicSubs);\n+                        return;\n+                    }\n+\n+                    final AtomicBoolean failed = new AtomicBoolean();\n+                    final AtomicInteger count = new AtomicInteger();\n+\n+                    for (final String child : children) {\n+\n+                        final ByteString subscriberId = ByteString.copyFromUtf8(child);\n+                        final String childPath = path + \"/\" + child;\n+\n+                        zk.getData(childPath, false, new SafeAsyncZKCallback.DataCallback() {\n+                            @Override\n+                            public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+\n+                                if (rc != Code.OK.intValue()) {\n+                                    KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                            \"Could not read subscription data for topic: \" + topic.toStringUtf8()\n+                                                            + \", subscriberId: \" + subscriberId.toStringUtf8(), path, rc);\n+                                    reportFailure(new PubSubException.ServiceDownException(e));\n+                                    return;\n+                                }\n+\n+                                if (failed.get()) {\n+                                    return;\n+                                }\n+\n+                                Versioned<SubscriptionData> subData;\n+                                try {\n+                                    subData = new Versioned<SubscriptionData>(\n+                                            SubscriptionStateUtils.parseSubscriptionData(data), \n+                                            new ZkVersion(stat.getVersion()));\n+                                } catch (InvalidProtocolBufferException ex) {\n+                                    String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + subscriberId.toStringUtf8();\n+                                    logger.error(msg, ex);\n+                                    reportFailure(new PubSubException.UnexpectedConditionException(msg));\n+                                    return;\n+                                }\n+\n+                                if (logger.isDebugEnabled()) {\n+                                    logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n+                                                 + \" subscriberId: \" + child + \"state: \"\n+                                                 + SubscriptionStateUtils.toString(subData.getValue()));\n+                                }\n+\n+                                topicSubs.put(subscriberId, subData);\n+                                if (count.incrementAndGet() == children.size()) {\n+                                    assert topicSubs.size() == count.get();\n+                                    cb.operationFinished(ctx, topicSubs);\n+                                }\n+                            }\n+\n+                            private void reportFailure(PubSubException e) {\n+                                if (failed.compareAndSet(false, true))\n+                                    cb.operationFailed(ctx, e);\n+                            }\n+                        }, ctx);\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    /**\n+     * ZooKeeper base topic ownership manager.\n+     */\n+    static class ZkTopicOwnershipManagerImpl implements TopicOwnershipManager {\n+\n+        ZooKeeper zk;\n+        ServerConfiguration cfg;\n+\n+        ZkTopicOwnershipManagerImpl(ServerConfiguration conf, ZooKeeper zk) {\n+            this.cfg = conf;\n+            this.zk = zk;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            // do nothing in zookeeper based impl\n+        }\n+\n+        /**\n+         * Return znode path to store topic owner.\n+         *\n+         * @param topic\n+         *          Topic Name\n+         * @return znode path to store topic owner.\n+         */\n+        String hubPath(ByteString topic) {\n+            return cfg.getZkTopicPath(new StringBuilder(), topic).append(\"/hub\").toString();\n+        }\n+\n+        @Override\n+        public void readOwnerInfo(final ByteString topic, final Callback<Versioned<HubInfo>> callback, Object ctx) {\n+            String ownerPath = hubPath(topic);\n+            zk.getData(ownerPath, false, new SafeAsyncZKCallback.DataCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+                    if (Code.NONODE.intValue() == rc) {\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    }\n+\n+                    if (Code.OK.intValue() != rc) {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Could not read ownership for topic: \"\n+                                            + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                    HubInfo owner = null;\n+                    try {\n+                        owner = HubInfo.parse(new String(data, UTF_8));\n+                    } catch (HubInfo.InvalidHubInfoException ihie) {\n+                        logger.warn(\"Failed to parse hub info for topic \" + topic.toStringUtf8() + \" : \", ihie);\n+                    }\n+                    int version = stat.getVersion();\n+                    callback.operationFinished(ctx, new Versioned<HubInfo>(owner, new ZkVersion(version)));\n+                    return;\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void writeOwnerInfo(final ByteString topic, final HubInfo owner, final Version version,\n+                                   final Callback<Version> callback, Object ctx) {\n+            if (Version.NEW == version) {\n+                createOwnerInfo(topic, owner, callback, ctx);\n+                return;\n+            }\n+\n+            if (!(version instanceof ZkVersion)) {\n+                callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                              \"Invalid version provided to update owner info for topic \" + topic.toStringUtf8()));\n+                return;\n+            }\n+\n+            int znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+            zk.setData(hubPath(topic), owner.toString().getBytes(UTF_8), znodeVersion,\n+                       new SafeAsyncZKCallback.StatCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n+                    if (rc == Code.NONODE.intValue()) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO,\n+                                                      \"No owner info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (rc == Code.BADVERSION.intValue()) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to update owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (Code.OK.intValue() == rc) {\n+                        callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                            \"Failed to update ownership of topic \" + topic.toStringUtf8() +\n+                            \" to \" + owner, path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        protected void createOwnerInfo(final ByteString topic, final HubInfo owner,\n+                                       final Callback<Version> callback, Object ctx) {\n+            String ownerPath = hubPath(topic);\n+            ZkUtils.createFullPathOptimistic(zk, ownerPath, owner.toString().getBytes(UTF_8), Ids.OPEN_ACL_UNSAFE,\n+                                             CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx, String name) {\n+                    if (Code.OK.intValue() == rc) {\n+                        // assume the initial version is 0\n+                        callback.operationFinished(ctx, new ZkVersion(0));\n+                        return;\n+                    } else if (Code.NODEEXISTS.intValue() == rc) {\n+                        // node existed\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.TOPIC_OWNER_INFO_EXISTS,\n+                                                      \"Owner info of topic \" + topic.toStringUtf8() + \" existed.\"));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Failed to create znode for ownership of topic: \"\n+                                                + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                        return;\n+                    }\n+                }\n+            }, ctx);\n+        }\n+\n+        @Override\n+        public void deleteOwnerInfo(final ByteString topic, final Version version,\n+                                    final Callback<Void> callback, Object ctx) {\n+            int znodeVersion = -1;\n+            if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete owner info for topic \" + topic.toStringUtf8()));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+\n+            zk.delete(hubPath(topic), znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n+                @Override\n+                public void safeProcessResult(int rc, String path, Object ctx) {\n+                    if (Code.OK.intValue() == rc) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Successfully deleted owner info for topic \" + topic.toStringUtf8() + \".\");\n+                        }\n+                        callback.operationFinished(ctx, null);\n+                        return;\n+                    } else if (Code.NONODE.intValue() == rc) {\n+                        // no node\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.NO_TOPIC_OWNER_INFO,\n+                                                      \"No owner info found for topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else if (Code.BADVERSION.intValue() == rc) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete owner info of topic \" + topic.toStringUtf8()));\n+                        return;\n+                    } else {\n+                        KeeperException e = ZkUtils.logErrorAndCreateZKException(\n+                                                \"Failed to delete owner info for topic \"\n+                                                + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+                    }\n+                }\n+            }, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public void format(ServerConfiguration cfg, ZooKeeper zk) throws IOException {\n+        try {\n+            ZKUtil.deleteRecursive(zk, cfg.getZkTopicsPrefix(new StringBuilder()).toString());\n+        } catch (KeeperException.NoNodeException e) {\n+            logger.debug(\"Hedwig root node doesn't exist in zookeeper to delete\");\n+        } catch (KeeperException ke) {\n+            throw new IOException(ke);\n+        } catch (InterruptedException ie) {\n+            throw new IOException(ie);\n+        }\n+    }\n+}"},{"sha":"94d61ad1bc52e98d0148b155363a09d6f3a09aab","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"added","additions":535,"deletions":0,"changes":535,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,535 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.netty;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.jboss.netty.bootstrap.ServerBootstrap;\n+import org.jboss.netty.channel.group.ChannelGroup;\n+import org.jboss.netty.channel.group.DefaultChannelGroup;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.ServerSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\n+import org.jboss.netty.logging.InternalLoggerFactory;\n+import org.jboss.netty.logging.Log4JLoggerFactory;\n+\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.server.common.TerminateJVMExceptionHandler;\n+import org.apache.hedwig.server.delivery.DeliveryManager;\n+import org.apache.hedwig.server.delivery.FIFODeliveryManager;\n+import org.apache.hedwig.server.handlers.CloseSubscriptionHandler;\n+import org.apache.hedwig.server.handlers.ConsumeHandler;\n+import org.apache.hedwig.server.handlers.Handler;\n+import org.apache.hedwig.server.handlers.NettyHandlerBean;\n+import org.apache.hedwig.server.handlers.PublishHandler;\n+import org.apache.hedwig.server.handlers.SubscribeHandler;\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager;\n+import org.apache.hedwig.server.handlers.SubscriptionChannelManager.SubChannelDisconnectedListener;\n+import org.apache.hedwig.server.handlers.UnsubscribeHandler;\n+import org.apache.hedwig.server.jmx.HedwigMBeanRegistry;\n+import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.server.meta.ZkMetadataManagerFactory;\n+import org.apache.hedwig.server.persistence.BookkeeperPersistenceManager;\n+import org.apache.hedwig.server.persistence.LocalDBPersistenceManager;\n+import org.apache.hedwig.server.persistence.PersistenceManager;\n+import org.apache.hedwig.server.persistence.PersistenceManagerWithRangeScan;\n+import org.apache.hedwig.server.persistence.ReadAheadCache;\n+import org.apache.hedwig.server.regions.HedwigHubClientFactory;\n+import org.apache.hedwig.server.regions.RegionManager;\n+import org.apache.hedwig.server.ssl.SslServerContextFactory;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionManager;\n+import org.apache.hedwig.server.subscriptions.SubscriptionManager;\n+import org.apache.hedwig.server.subscriptions.MMSubscriptionManager;\n+import org.apache.hedwig.server.topics.MMTopicManager;\n+import org.apache.hedwig.server.topics.TopicManager;\n+import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n+import org.apache.hedwig.server.topics.ZkTopicManager;\n+import org.apache.hedwig.util.ConcurrencyUtils;\n+import org.apache.hedwig.util.Either;\n+import org.apache.hedwig.zookeeper.SafeAsyncCallback;\n+\n+public class PubSubServer {\n+\n+    static Logger logger = LoggerFactory.getLogger(PubSubServer.class);\n+\n+    private static final String JMXNAME_PREFIX = \"PubSubServer_\";\n+\n+    // Netty related variables\n+    ServerSocketChannelFactory serverChannelFactory;\n+    ClientSocketChannelFactory clientChannelFactory;\n+    ServerConfiguration conf;\n+    org.apache.hedwig.client.conf.ClientConfiguration clientConfiguration;\n+    ChannelGroup allChannels;\n+\n+    // Manager components that make up the PubSubServer\n+    PersistenceManager pm;\n+    DeliveryManager dm;\n+    TopicManager tm;\n+    SubscriptionManager sm;\n+    RegionManager rm;\n+\n+    // Metadata Manager Factory\n+    MetadataManagerFactory mm;\n+\n+    ZooKeeper zk; // null if we are in standalone mode\n+    BookKeeper bk; // null if we are in standalone mode\n+\n+    // we use this to prevent long stack chains from building up in callbacks\n+    ScheduledExecutorService scheduler;\n+\n+    // JMX Beans\n+    NettyHandlerBean jmxNettyBean;\n+    PubSubServerBean jmxServerBean;\n+    final ThreadGroup tg;\n+\n+    protected PersistenceManager instantiatePersistenceManager(TopicManager topicMgr) throws IOException,\n+        InterruptedException {\n+\n+        PersistenceManagerWithRangeScan underlyingPM;\n+\n+        if (conf.isStandalone()) {\n+\n+            underlyingPM = LocalDBPersistenceManager.instance();\n+\n+        } else {\n+            try {\n+                ClientConfiguration bkConf = new ClientConfiguration();\n+                bkConf.addConfiguration(conf.getConf());\n+                bk = new BookKeeper(bkConf, zk, clientChannelFactory);\n+            } catch (KeeperException e) {\n+                logger.error(\"Could not instantiate bookkeeper client\", e);\n+                throw new IOException(e);\n+            }\n+            underlyingPM = new BookkeeperPersistenceManager(bk, mm, topicMgr, conf, scheduler);\n+\n+        }\n+\n+        PersistenceManager pm = underlyingPM;\n+\n+        if (conf.getReadAheadEnabled()) {\n+            pm = new ReadAheadCache(underlyingPM, conf).start();\n+        }\n+\n+        return pm;\n+    }\n+\n+    protected SubscriptionManager instantiateSubscriptionManager(TopicManager tm, PersistenceManager pm,\n+                                                                 DeliveryManager dm) {\n+        if (conf.isStandalone()) {\n+            return new InMemorySubscriptionManager(conf, tm, pm, dm, scheduler);\n+        } else {\n+            return new MMSubscriptionManager(conf, mm, tm, pm, dm, scheduler);\n+        }\n+\n+    }\n+\n+    protected RegionManager instantiateRegionManager(PersistenceManager pm, ScheduledExecutorService scheduler) {\n+        return new RegionManager(pm, conf, zk, scheduler, new HedwigHubClientFactory(conf, clientConfiguration,\n+                clientChannelFactory));\n+    }\n+\n+    protected void instantiateZookeeperClient() throws Exception {\n+        if (!conf.isStandalone()) {\n+            final CountDownLatch signalZkReady = new CountDownLatch(1);\n+\n+            zk = new ZooKeeper(conf.getZkHost(), conf.getZkTimeout(), new Watcher() {\n+                @Override\n+                public void process(WatchedEvent event) {\n+                    if(Event.KeeperState.SyncConnected.equals(event.getState())) {\n+                        signalZkReady.countDown();\n+                    }\n+                }\n+            });\n+            // wait until connection is effective\n+            if (!signalZkReady.await(conf.getZkTimeout()*2, TimeUnit.MILLISECONDS)) {\n+                logger.error(\"Could not establish connection with ZooKeeper after zk_timeout*2 = \" +\n+                             conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n+                throw new Exception(\"Could not establish connection with ZooKeeper after zk_timeout*2 = \" +\n+                                    conf.getZkTimeout()*2 + \" ms. (Default value for zk_timeout is 2000).\");\n+            }\n+        }\n+    }\n+\n+    protected void instantiateMetadataManagerFactory() throws Exception {\n+        if (conf.isStandalone()) {\n+            return;\n+        }\n+        mm = MetadataManagerFactory.newMetadataManagerFactory(conf, zk);\n+    }\n+\n+    protected TopicManager instantiateTopicManager() throws IOException {\n+        TopicManager tm;\n+\n+        if (conf.isStandalone()) {\n+            tm = new TrivialOwnAllTopicManager(conf, scheduler);\n+        } else {\n+            try {\n+                if (conf.isMetadataManagerBasedTopicManagerEnabled()) {\n+                    tm = new MMTopicManager(conf, zk, mm, scheduler);\n+                } else {\n+                    if (!(mm instanceof ZkMetadataManagerFactory)) {\n+                        throw new IOException(\"Uses \" + mm.getClass().getName() + \" to store hedwig metadata, \"\n+                                            + \"but uses zookeeper ephemeral znodes to store topic ownership. \"\n+                                            + \"Check your configuration as this could lead to scalability issues.\");\n+                    }\n+                    tm = new ZkTopicManager(zk, conf, scheduler);\n+                }\n+            } catch (PubSubException e) {\n+                logger.error(\"Could not instantiate TopicOwnershipManager based topic manager\", e);\n+                throw new IOException(e);\n+            }\n+        }\n+        return tm;\n+    }\n+\n+   protected Map<OperationType, Handler> initializeNettyHandlers(\n+           TopicManager tm, DeliveryManager dm,\n+           PersistenceManager pm, SubscriptionManager sm,\n+           SubscriptionChannelManager subChannelMgr) {\n+        Map<OperationType, Handler> handlers = new HashMap<OperationType, Handler>();\n+        handlers.put(OperationType.PUBLISH, new PublishHandler(tm, pm, conf));\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new SubscribeHandler(conf, tm, dm, pm, sm, subChannelMgr));\n+        handlers.put(OperationType.UNSUBSCRIBE,\n+                     new UnsubscribeHandler(conf, tm, sm, dm, subChannelMgr));\n+        handlers.put(OperationType.CONSUME, new ConsumeHandler(tm, sm, conf));\n+        handlers.put(OperationType.CLOSESUBSCRIPTION,\n+                     new CloseSubscriptionHandler(conf, tm, sm, dm, subChannelMgr));\n+        handlers = Collections.unmodifiableMap(handlers);\n+        return handlers;\n+    }\n+\n+    protected void initializeNetty(SslServerContextFactory sslFactory,\n+                                   Map<OperationType, Handler> handlers,\n+                                   SubscriptionChannelManager subChannelMgr) {\n+        boolean isSSLEnabled = (sslFactory != null) ? true : false;\n+        InternalLoggerFactory.setDefaultFactory(new Log4JLoggerFactory());\n+        ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n+        UmbrellaHandler umbrellaHandler =\n+            new UmbrellaHandler(allChannels, handlers, subChannelMgr, isSSLEnabled);\n+        PubSubServerPipelineFactory pipeline =\n+            new PubSubServerPipelineFactory(umbrellaHandler, sslFactory,\n+                                            conf.getMaximumMessageSize());\n+\n+        bootstrap.setPipelineFactory(pipeline);\n+        bootstrap.setOption(\"child.tcpNoDelay\", true);\n+        bootstrap.setOption(\"child.keepAlive\", true);\n+        bootstrap.setOption(\"reuseAddress\", true);\n+\n+        // Bind and start to accept incoming connections.\n+        allChannels.add(bootstrap.bind(isSSLEnabled ? new InetSocketAddress(conf.getSSLServerPort())\n+                                       : new InetSocketAddress(conf.getServerPort())));\n+        logger.info(\"Going into receive loop\");\n+    }\n+\n+    public void shutdown() {\n+        // TODO: tell bk to close logs\n+\n+        // Stop topic manager first since it is core of Hub server\n+        tm.stop();\n+\n+        // Stop the RegionManager.\n+        rm.stop();\n+\n+        // Stop the DeliveryManager and ReadAheadCache threads (if\n+        // applicable).\n+        dm.stop();\n+        pm.stop();\n+\n+        // Stop the SubscriptionManager if needed.\n+        sm.stop();\n+\n+        // Shutdown metadata manager if needed\n+        if (null != mm) {\n+            try {\n+                mm.shutdown();\n+            } catch (IOException ie) {\n+                logger.error(\"Error while shutdown metadata manager factory!\", ie);\n+            }\n+        }\n+\n+        // Shutdown the ZooKeeper and BookKeeper clients only if we are\n+        // not in stand-alone mode.\n+        try {\n+            if (bk != null)\n+                bk.close();\n+            if (zk != null)\n+                zk.close();\n+        } catch (InterruptedException e) {\n+            logger.error(\"Error while closing ZooKeeper client : \", e);\n+        } catch (BKException bke) {\n+            logger.error(\"Error while closing BookKeeper client : \", bke);\n+        }\n+\n+        // Close and release the Netty channels and resources\n+        allChannels.close().awaitUninterruptibly();\n+        serverChannelFactory.releaseExternalResources();\n+        clientChannelFactory.releaseExternalResources();\n+        scheduler.shutdown();\n+\n+        // unregister jmx\n+        unregisterJMX();\n+    }\n+\n+    protected void registerJMX(SubscriptionChannelManager subChannelMgr) {\n+        try {\n+            String jmxName = JMXNAME_PREFIX + conf.getServerPort() + \"_\"\n+                                            + conf.getSSLServerPort();\n+            jmxServerBean = new PubSubServerBean(jmxName);\n+            HedwigMBeanRegistry.getInstance().register(jmxServerBean, null);\n+            try {\n+                jmxNettyBean = new NettyHandlerBean(subChannelMgr);\n+                HedwigMBeanRegistry.getInstance().register(jmxNettyBean, jmxServerBean);\n+            } catch (Exception e) {\n+                logger.warn(\"Failed to register with JMX\", e);\n+                jmxNettyBean = null;\n+            }\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to register with JMX\", e);\n+            jmxServerBean = null;\n+        }\n+        if (pm instanceof ReadAheadCache) {\n+            ((ReadAheadCache)pm).registerJMX(jmxServerBean);\n+        }\n+    }\n+\n+    protected void unregisterJMX() {\n+        if (pm != null && pm instanceof ReadAheadCache) {\n+            ((ReadAheadCache)pm).unregisterJMX();\n+        }\n+        try {\n+            if (jmxNettyBean != null) {\n+                HedwigMBeanRegistry.getInstance().unregister(jmxNettyBean);\n+            }\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        try {\n+            if (jmxServerBean != null) {\n+                HedwigMBeanRegistry.getInstance().unregister(jmxServerBean);\n+            }\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        jmxNettyBean = null;\n+        jmxServerBean = null;\n+    }\n+\n+    /**\n+     * Starts the hedwig server on the given port\n+     *\n+     * @param port\n+     * @throws ConfigurationException\n+     *             if there is something wrong with the given configuration\n+     * @throws IOException\n+     * @throws InterruptedException\n+     * @throws ConfigurationException\n+     */\n+    public PubSubServer(final ServerConfiguration serverConfiguration,\n+                        final org.apache.hedwig.client.conf.ClientConfiguration clientConfiguration,\n+                        final Thread.UncaughtExceptionHandler exceptionHandler)\n+            throws ConfigurationException {\n+\n+        // First validate the serverConfiguration\n+        this.conf = serverConfiguration;\n+        serverConfiguration.validate();\n+\n+        // Validate the client configuration\n+        this.clientConfiguration = clientConfiguration;\n+        clientConfiguration.validate();\n+\n+        // We need a custom thread group, so that we can override the uncaught\n+        // exception method\n+        tg = new ThreadGroup(\"hedwig\") {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptionHandler.uncaughtException(t, e);\n+            }\n+        };\n+        // ZooKeeper threads register their own handler. But if some work that\n+        // we do in ZK threads throws an exception, we want our handler to be\n+        // called, not theirs.\n+        SafeAsyncCallback.setUncaughtExceptionHandler(exceptionHandler);\n+    }\n+\n+    public void start() throws Exception {\n+        final SynchronousQueue<Either<Object, Exception>> queue = new SynchronousQueue<Either<Object, Exception>>();\n+\n+        new Thread(tg, new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    // Since zk is needed by almost everyone,try to see if we\n+                    // need that first\n+                    ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n+                    scheduler = Executors.newSingleThreadScheduledExecutor(tfb\n+                            .setNameFormat(\"PubSubServerScheduler-%d\").build());\n+                    serverChannelFactory = new NioServerSocketChannelFactory(\n+                            Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                    \"PubSub-Server-NIOBoss-%d\").build()),\n+                            Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                    \"PubSub-Server-NIOWorker-%d\").build()));\n+                    clientChannelFactory = new NioClientSocketChannelFactory(\n+                            Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                    \"PubSub-Client-NIOBoss-%d\").build()),\n+                            Executors.newCachedThreadPool(tfb.setNameFormat(\n+                                    \"PubSub-Client-NIOWorker-%d\").build()));\n+\n+                    instantiateZookeeperClient();\n+                    instantiateMetadataManagerFactory();\n+                    tm = instantiateTopicManager();\n+                    pm = instantiatePersistenceManager(tm);\n+                    dm = new FIFODeliveryManager(tm, pm, conf);\n+                    dm.start();\n+\n+                    sm = instantiateSubscriptionManager(tm, pm, dm);\n+                    rm = instantiateRegionManager(pm, scheduler);\n+                    sm.addListener(rm);\n+\n+                    allChannels = new DefaultChannelGroup(\"hedwig\");\n+                    // Initialize the Netty Handlers (used by the\n+                    // UmbrellaHandler) once so they can be shared by\n+                    // both the SSL and non-SSL channels.\n+                    SubscriptionChannelManager subChannelMgr = new SubscriptionChannelManager();\n+                    subChannelMgr.addSubChannelDisconnectedListener((SubChannelDisconnectedListener) dm);\n+                    Map<OperationType, Handler> handlers =\n+                        initializeNettyHandlers(tm, dm, pm, sm, subChannelMgr);\n+                    // Initialize Netty for the regular non-SSL channels\n+                    initializeNetty(null, handlers, subChannelMgr);\n+                    if (conf.isSSLEnabled()) {\n+                        initializeNetty(new SslServerContextFactory(conf),\n+                                        handlers, subChannelMgr);\n+                    }\n+                    // register jmx\n+                    registerJMX(subChannelMgr);\n+                } catch (Exception e) {\n+                    ConcurrencyUtils.put(queue, Either.right(e));\n+                    return;\n+                }\n+\n+                ConcurrencyUtils.put(queue, Either.of(new Object(), (Exception) null));\n+            }\n+\n+        }).start();\n+\n+        Either<Object, Exception> either = ConcurrencyUtils.take(queue);\n+        if (either.left() == null) {\n+            throw either.right();\n+        }\n+    }\n+\n+    public PubSubServer(ServerConfiguration serverConfiguration,\n+                        org.apache.hedwig.client.conf.ClientConfiguration clientConfiguration) throws Exception {\n+        this(serverConfiguration, clientConfiguration, new TerminateJVMExceptionHandler());\n+    }\n+\n+    public PubSubServer(ServerConfiguration serverConfiguration) throws Exception {\n+        this(serverConfiguration, new org.apache.hedwig.client.conf.ClientConfiguration());\n+    }\n+\n+    @VisibleForTesting\n+    public DeliveryManager getDeliveryManager() {\n+        return dm;\n+    }\n+\n+    /**\n+     *\n+     * @param msg\n+     * @param rc\n+     *            : code to exit with\n+     */\n+    public static void errorMsgAndExit(String msg, Throwable t, int rc) {\n+        logger.error(msg, t);\n+        System.err.println(msg);\n+        System.exit(rc);\n+    }\n+\n+    public final static int RC_INVALID_CONF_FILE = 1;\n+    public final static int RC_MISCONFIGURED = 2;\n+    public final static int RC_OTHER = 3;\n+\n+    /**\n+     * @param args\n+     */\n+    public static void main(String[] args) {\n+\n+        logger.info(\"Attempting to start Hedwig\");\n+        ServerConfiguration serverConfiguration = new ServerConfiguration();\n+        // The client configuration for the hedwig client in the region manager.\n+        org.apache.hedwig.client.conf.ClientConfiguration regionMgrClientConfiguration\n+                = new org.apache.hedwig.client.conf.ClientConfiguration();\n+        if (args.length > 0) {\n+            String confFile = args[0];\n+            try {\n+                serverConfiguration.loadConf(new File(confFile).toURI().toURL());\n+            } catch (MalformedURLException e) {\n+                String msg = \"Could not open server configuration file: \" + confFile;\n+                errorMsgAndExit(msg, e, RC_INVALID_CONF_FILE);\n+            } catch (ConfigurationException e) {\n+                String msg = \"Malformed server configuration file: \" + confFile;\n+                errorMsgAndExit(msg, e, RC_MISCONFIGURED);\n+            }\n+            logger.info(\"Using configuration file \" + confFile);\n+        }\n+        if (args.length > 1) {\n+            // args[1] is the client configuration file.\n+            String confFile = args[1];\n+            try {\n+                regionMgrClientConfiguration.loadConf(new File(confFile).toURI().toURL());\n+            } catch (MalformedURLException e) {\n+                String msg = \"Could not open client configuration file: \" + confFile;\n+                errorMsgAndExit(msg, e, RC_INVALID_CONF_FILE);\n+            } catch (ConfigurationException e) {\n+                String msg = \"Malformed client configuration file: \" + confFile;\n+                errorMsgAndExit(msg, e, RC_MISCONFIGURED);\n+            }\n+        }\n+        try {\n+            new PubSubServer(serverConfiguration, regionMgrClientConfiguration).start();\n+        } catch (Throwable t) {\n+            errorMsgAndExit(\"Error during startup\", t, RC_OTHER);\n+        }\n+    }\n+}"},{"sha":"c1acbbc32782f7aec6f74f194533f45534eda8d6","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.netty;\n+\n+import org.apache.hedwig.server.jmx.HedwigMBeanInfo;\n+import org.apache.hedwig.server.netty.ServerStats.OpStatData;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+/**\n+ * PubSub Server Bean\n+ */\n+public class PubSubServerBean implements PubSubServerMXBean, HedwigMBeanInfo {\n+\n+    private final String name;\n+\n+    public PubSubServerBean(String jmxName) {\n+        this.name = jmxName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return false;\n+    }\n+\n+    @Override\n+    public OpStatData getPubStats() {\n+        return ServerStats.getInstance().getOpStats(OperationType.PUBLISH).toOpStatData();\n+    }\n+\n+    @Override\n+    public OpStatData getSubStats() {\n+        return ServerStats.getInstance().getOpStats(OperationType.SUBSCRIBE).toOpStatData();\n+    }\n+\n+    @Override\n+    public OpStatData getUnsubStats() {\n+        return ServerStats.getInstance().getOpStats(OperationType.UNSUBSCRIBE).toOpStatData();\n+    }\n+\n+    @Override\n+    public OpStatData getConsumeStats() {\n+        return ServerStats.getInstance().getOpStats(OperationType.CONSUME).toOpStatData();\n+    }\n+\n+    @Override\n+    public long getNumRequestsReceived() {\n+        return ServerStats.getInstance().getNumRequestsReceived();\n+    }\n+\n+    @Override\n+    public long getNumRequestsRedirect() {\n+        return ServerStats.getInstance().getNumRequestsRedirect();\n+    }\n+\n+    @Override\n+    public long getNumMessagesDelivered() {\n+        return ServerStats.getInstance().getNumMessagesDelivered();\n+    }\n+\n+\n+}"},{"sha":"15e860fb04812d5d290170eb638e306e5a032c8d","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.netty;\n+\n+import org.apache.hedwig.server.netty.ServerStats.OpStatData;\n+\n+/**\n+ * PubSub Server MBean\n+ */\n+public interface PubSubServerMXBean {\n+\n+    /**\n+     * @return publish stats\n+     */\n+    public OpStatData getPubStats();\n+\n+    /**\n+     * @return subscription stats\n+     */\n+    public OpStatData getSubStats();\n+\n+    /**\n+     * @return unsub stats\n+     */\n+    public OpStatData getUnsubStats();\n+\n+    /**\n+     * @return consume stats\n+     */\n+    public OpStatData getConsumeStats();\n+\n+    /**\n+     * @return number of requests received\n+     */\n+    public long getNumRequestsReceived();\n+\n+    /**\n+     * @return number of requests redirect\n+     */\n+    public long getNumRequestsRedirect();\n+\n+    /**\n+     * @return number of messages delivered\n+     */\n+    public long getNumMessagesDelivered();\n+\n+}"},{"sha":"c96f438e2d6d21182d671ecf558b578b8c333103","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerPipelineFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.netty;\n+\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.channel.ChannelPipelineFactory;\n+import org.jboss.netty.channel.Channels;\n+import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n+import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n+import org.jboss.netty.handler.codec.protobuf.ProtobufDecoder;\n+import org.jboss.netty.handler.codec.protobuf.ProtobufEncoder;\n+import org.jboss.netty.handler.ssl.SslHandler;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.server.ssl.SslServerContextFactory;\n+\n+public class PubSubServerPipelineFactory implements ChannelPipelineFactory {\n+\n+    // TODO: make these conf settings\n+    final static int MAX_WORKER_THREADS = 32;\n+    final static int MAX_CHANNEL_MEMORY_SIZE = 10 * 1024 * 1024;\n+    final static int MAX_TOTAL_MEMORY_SIZE = 100 * 1024 * 1024;\n+\n+    private UmbrellaHandler uh;\n+    private SslServerContextFactory sslFactory;\n+    private int maxMessageSize;\n+\n+    /**\n+     *\n+     * @param uh\n+     * @param sslFactory\n+     *            may be null if ssl is disabled\n+     * @param cfg\n+     */\n+    public PubSubServerPipelineFactory(UmbrellaHandler uh, SslServerContextFactory sslFactory, int maxMessageSize) {\n+        this.uh = uh;\n+        this.sslFactory = sslFactory;\n+        this.maxMessageSize = maxMessageSize;\n+    }\n+\n+    public ChannelPipeline getPipeline() throws Exception {\n+        ChannelPipeline pipeline = Channels.pipeline();\n+        if (sslFactory != null) {\n+            pipeline.addLast(\"ssl\", new SslHandler(sslFactory.getEngine()));\n+        }\n+        pipeline.addLast(\"lengthbaseddecoder\",\n+                         new LengthFieldBasedFrameDecoder(maxMessageSize, 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+\n+        pipeline.addLast(\"protobufdecoder\", new ProtobufDecoder(PubSubProtocol.PubSubRequest.getDefaultInstance()));\n+        pipeline.addLast(\"protobufencoder\", new ProtobufEncoder());\n+\n+        // pipeline.addLast(\"executor\", new ExecutionHandler(\n+        // new OrderedMemoryAwareThreadPoolExecutor(MAX_WORKER_THREADS,\n+        // MAX_CHANNEL_MEMORY_SIZE, MAX_TOTAL_MEMORY_SIZE)));\n+        //\n+        // Dependency injection.\n+        pipeline.addLast(\"umbrellahandler\", uh);\n+        return pipeline;\n+    }\n+}"},{"sha":"69ee6efd5eae294973becf03c1909a2c8f30ab0c","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,202 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.server.netty;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.beans.ConstructorProperties;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Server Stats\n+ */\n+public class ServerStats {\n+    private static final Logger LOG = LoggerFactory.getLogger(ServerStats.class);\n+    static ServerStats instance = new ServerStats();\n+\n+    /**\n+     * A read view of stats, also used in CompositeViewData to expose to JMX\n+     */\n+    public static class OpStatData {\n+        private final long maxLatency, minLatency;\n+        private final double avgLatency;\n+        private final long numSuccessOps, numFailedOps;\n+        private final String latencyHist;\n+\n+        @ConstructorProperties({\"maxLatency\", \"minLatency\", \"avgLatency\",\n+                                \"numSuccessOps\", \"numFailedOps\", \"latencyHist\"})\n+        public OpStatData(long maxLatency, long minLatency, double avgLatency,\n+                          long numSuccessOps, long numFailedOps, String latencyHist) {\n+            this.maxLatency = maxLatency;\n+            this.minLatency = minLatency == Long.MAX_VALUE ? 0 : minLatency;\n+            this.avgLatency = avgLatency;\n+            this.numSuccessOps = numSuccessOps;\n+            this.numFailedOps = numFailedOps;\n+            this.latencyHist = latencyHist;\n+        }\n+\n+        public long getMaxLatency() {\n+            return maxLatency;\n+        }\n+\n+        public long getMinLatency() {\n+            return minLatency;\n+        }\n+\n+        public double getAvgLatency() {\n+            return avgLatency;\n+        }\n+\n+        public long getNumSuccessOps() {\n+            return numSuccessOps;\n+        }\n+\n+        public long getNumFailedOps() {\n+            return numFailedOps;\n+        }\n+\n+        public String getLatencyHist() {\n+            return latencyHist;\n+        }\n+    }\n+\n+    /**\n+     * Operation Statistics\n+     */\n+    public static class OpStats {\n+        static final int NUM_BUCKETS = 3*9 + 2;\n+\n+        long maxLatency = 0;\n+        long minLatency = Long.MAX_VALUE;\n+        double totalLatency = 0.0f;\n+        long numSuccessOps = 0;\n+        long numFailedOps = 0;\n+        long[] latencyBuckets = new long[NUM_BUCKETS];\n+\n+        OpStats() {}\n+\n+        /**\n+         * Increment number of failed operations\n+         */\n+        synchronized public void incrementFailedOps() {\n+            ++numFailedOps;\n+        }\n+\n+        /**\n+         * Update Latency\n+         */\n+        synchronized public void updateLatency(long latency) {\n+            if (latency < 0) {\n+                // less than 0ms . Ideally this should not happen.\n+                // We have seen this latency negative in some cases due to the\n+                // behaviors of JVM. Ignoring the statistics updation for such\n+                // cases.\n+                LOG.warn(\"Latency time coming negative\");\n+                return;\n+            }\n+            totalLatency += latency;\n+            ++numSuccessOps;\n+            if (latency < minLatency) {\n+                minLatency = latency;\n+            }\n+            if (latency > maxLatency) {\n+                maxLatency = latency;\n+            }\n+            int bucket;\n+            if (latency <= 100) { // less than 100ms\n+                bucket = (int)(latency / 10);\n+            } else if (latency <= 1000) { // 100ms ~ 1000ms\n+                bucket = 1 * 9 + (int)(latency / 100);\n+            } else if (latency <= 10000) { // 1s ~ 10s\n+                bucket = 2 * 9 + (int)(latency / 1000);\n+            } else { // more than 10s\n+                bucket = 3 * 9 + 1;\n+            }\n+            ++latencyBuckets[bucket];\n+        }\n+\n+        synchronized public OpStatData toOpStatData() {\n+            double avgLatency = numSuccessOps > 0 ? totalLatency / numSuccessOps : 0.0f;\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=0; i<NUM_BUCKETS; i++) {\n+                sb.append(latencyBuckets[i]);\n+                if (i != NUM_BUCKETS - 1) {\n+                    sb.append(',');\n+                }\n+            }\n+\n+            return new OpStatData(maxLatency, minLatency, avgLatency,\n+                                  numSuccessOps, numFailedOps, sb.toString());\n+        }\n+\n+    }\n+\n+    public static ServerStats getInstance() {\n+        return instance;\n+    }\n+\n+    protected ServerStats() {\n+        stats = new HashMap<OperationType, OpStats>();\n+        for (OperationType type : OperationType.values()) {\n+            stats.put(type, new OpStats());\n+        }\n+    }\n+    Map<OperationType, OpStats> stats;\n+\n+\n+    AtomicLong numRequestsReceived = new AtomicLong(0);\n+    AtomicLong numRequestsRedirect = new AtomicLong(0);\n+    AtomicLong numMessagesDelivered = new AtomicLong(0);\n+\n+    /**\n+     * Stats of operations\n+     *\n+     * @param type\n+     *          Operation Type\n+     * @return op stats\n+     */\n+    public OpStats getOpStats(OperationType type) {\n+        return stats.get(type);\n+    }\n+\n+    public void incrementRequestsReceived() {\n+        numRequestsReceived.incrementAndGet();\n+    }\n+\n+    public void incrementRequestsRedirect() {\n+        numRequestsRedirect.incrementAndGet();\n+    }\n+\n+    public void incrementMessagesDelivered() {\n+        numMessagesDelivered.incrementAndGet();\n+    }\n+\n+    public long getNumRequestsReceived() {\n+        return numRequestsReceived.get();\n+    }\n+\n+    public long getNumRequestsRedirect() {\n+        return numRequestsRedirect.get();\n+    }\n+\n+    public long getNumMessagesDelivered() {\n+        return numMessagesDelivered.get();\n+    }\n+}"},{"sha":"a3be99a1d4add961fd794c3bdbed1988ef0c00ae","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9","patch":"@@ -0,0 +1,155 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.netty;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelHandler.Sharable;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.ExceptionEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.channel.group.ChannelGroup;\n+import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n+import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n+import org.jboss.netty.handler.ssl.SslHandler;\n+\n+import org.apache.hedwig.exceptions.PubSubException.MalformedRequestException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.handlers.ChannelDisconnectListener;\n+import org.apache.hedwig.server.handlers.Handler;\n+\n+@Sharable\n+public class UmbrellaHandler extends SimpleChannelHandler {\n+    static Logger logger = LoggerFactory.getLogger(UmbrellaHandler.class);\n+\n+    private final Map<OperationType, Handler> handlers;\n+    private final ChannelGroup allChannels;\n+    private final ChannelDisconnectListener channelDisconnectListener;\n+    private final boolean isSSLEnabled; \n+\n+    public UmbrellaHandler(ChannelGroup allChannels, Map<OperationType, Handler> handlers,\n+                           ChannelDisconnectListener channelDisconnectListener,\n+                           boolean isSSLEnabled) {\n+        this.allChannels = allChannels;\n+        this.isSSLEnabled = isSSLEnabled;\n+        this.handlers = handlers;\n+        this.channelDisconnectListener = channelDisconnectListener;\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n+        Throwable throwable = e.getCause();\n+\n+        // Add here if there are more exceptions we need to be able to tolerate.\n+        // 1. IOException may be thrown when a channel is forcefully closed by\n+        // the other end, or by the ProtobufDecoder when an invalid protobuf is\n+        // received\n+        // 2. TooLongFrameException is thrown by the LengthBasedDecoder if it\n+        // receives a packet that is too big\n+        // 3. CorruptedFramException is thrown by the LengthBasedDecoder when\n+        // the length is negative etc.\n+        if (throwable instanceof IOException || throwable instanceof TooLongFrameException\n+                || throwable instanceof CorruptedFrameException) {\n+            e.getChannel().close();\n+            logger.debug(\"Uncaught exception\", throwable);\n+        } else {\n+            // call our uncaught exception handler, which might decide to\n+            // shutdown the system\n+            Thread thread = Thread.currentThread();\n+            thread.getUncaughtExceptionHandler().uncaughtException(thread, throwable);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        // If SSL is NOT enabled, then we can add this channel to the\n+        // ChannelGroup. Otherwise, that is done when the channel is connected\n+        // and the SSL handshake has completed successfully.\n+        if (!isSSLEnabled) {\n+            allChannels.add(ctx.getChannel());\n+        }\n+    }\n+\n+    @Override\n+    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        if (isSSLEnabled) {\n+            ctx.getPipeline().get(SslHandler.class).handshake().addListener(new ChannelFutureListener() {\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        logger.debug(\"SSL handshake has completed successfully!\");\n+                        allChannels.add(future.getChannel());\n+                    } else {\n+                        future.getChannel().close();\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        Channel channel = ctx.getChannel();\n+        // subscribe handler needs to know about channel disconnects\n+        channelDisconnectListener.channelDisconnected(channel);\n+        channel.close();\n+    }\n+\n+    public static void sendErrorResponseToMalformedRequest(Channel channel, long txnId, String msg) {\n+        logger.debug(\"Malformed request from {}, msg = {}\", channel.getRemoteAddress(), msg);\n+        MalformedRequestException mre = new MalformedRequestException(msg);\n+        PubSubResponse response = PubSubResponseUtils.getResponseForException(mre, txnId);\n+        channel.write(response);\n+    }\n+\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+\n+        if (!(e.getMessage() instanceof PubSubProtocol.PubSubRequest)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+\n+        PubSubProtocol.PubSubRequest request = (PubSubProtocol.PubSubRequest) e.getMessage();\n+\n+        Handler handler = handlers.get(request.getType());\n+        Channel channel = ctx.getChannel();\n+        long txnId = request.getTxnId();\n+\n+        if (handler == null) {\n+            sendErrorResponseToMalformedRequest(channel, txnId, \"Request type \" + request.getType().getNumber()\n+                                                + \" unknown\");\n+            return;\n+        }\n+\n+        handler.handleRequest(request, channel);\n+        ServerStats.getInstance().incrementRequestsReceived();\n+    }\n+\n+}"},{"sha":"d0ea5b3229d407b805b913db527b36a599f154a8","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"26bdb942f8fe1982085f13ffa419290d5ac081e6","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheKey.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"942aecdd3108ac58ce90acbed7285c439dc027f2","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CacheValue.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c3b521433975277e16be35f50ef66f53cc2d5cf5","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/CancelScanRequest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c1ee24ccfcd1c440533183366fb9ab92005afe6b","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/Factory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6f474c823880db82dc714a73763883dcabcb5462","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"added","additions":491,"deletions":0,"changes":491,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f640723514d6b88839705a6e248d8bb5b35138cb","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/MapMethods.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d137fe6731c049d151b5142fbf94d44e1a3326a3","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistRequest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a295fc755d0a8d0af4d64776257d4a9925bc26ec","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f12174f098df09d97ccc36e0fdb4c04791df2bca","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManagerWithRangeScan.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3ac324df537fd37463b455c0823e5bd07f3fc815","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/RangeScanRequest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"09abf6714b542a94628e2e3742cd13e66bf88175","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"added","additions":863,"deletions":0,"changes":863,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1f43095e62b70872f006ddffd001dc25520159b1","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"eba77a074d349e27b186e47c6c0edc925980ecf4","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"42ebb93394b251258b23ea2eecd712b82279c44f","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a39a1974d9a97417faea79e91c22ff76bbe20940","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanCallbackWithContext.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c985840316db631aeeaa3b8bd0e1cfcbd64360da","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ScanRequest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"10f08890bb7a25d264aa1265169cd2688ca8192b","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b01f179688b80f6c1acfd89635cb54a633aa016b","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"added","additions":182,"deletions":0,"changes":182,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c1ef43538d09d3dc93d093312d104aebd156e2ca","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"051a7829022cfc2c78628cb1731e935f3371252e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c9bfb12fc58277f8e731ef1127506e790a4ae345","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConsumeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7ffdb92492be9d112a7081ddae6cf21a8ba280bb","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyPublishHander.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e77fbceb6c7473374a3d4d38c6c55ba92151910a","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4ac23e7023fb306b620c93bf8e0e2cc1d01970ee","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"69860048f54689da1995b2591674d5d13017313e","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxySubscribeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f6119056d871aa515e6e17755b15068014c34134","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyUnsubscribeHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"063a99c11a1ab2009fe550b2a50ae06367937950","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"68d317e10ab9a148c9a6a4916c414a8b122110d3","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubClientFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"70552516fab84719da35326ac8fe2381b0fb009a","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bae960b942bfe1f4c6202123db2eb24dc8c02cb3","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","status":"added","additions":355,"deletions":0,"changes":355,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"83d6961698d9289940b0477823b2e6efb98e54f5","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/ssl/SslServerContextFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0dcbe3925472444a0d3c77574a20dce878cfb35d","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"added","additions":804,"deletions":0,"changes":804,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"389ccc9d5ba972f6cf0b9c167f6baf2cc4cc95be","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AllToAllTopologyFilter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4fadc774295258c44f95cd4d29f83640c7d620fe","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"05c4a03029a034aecb801b6f6c0c827cd03c7c5f","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"added","additions":200,"deletions":0,"changes":200,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"126155845e250879cae1657dce291d4d5c4860e1","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6c6e626dd22c8e92d2203bb0c4b34eb933972b52","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionEventListener.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"eadebcb50bc5e2a1a895e9728124d02799b0d390","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2d9aba23e71a2ac9166f3706681d8f4961c64356","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","status":"added","additions":314,"deletions":0,"changes":314,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9a4cb3d6d32e77e5f22f9ff4b29e8c7efcd51b7a","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2f76020408120c289d8d3c7821e6a2acebbd6f2c","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubLoad.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"12524c924e2cda88f8a8280419681e0ef3bc8340","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/HubServerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"98b491b603272e7321d9eb3509783ef728f230b7","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/MMTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2a0dcc04b09f8694c86063b6427650ab72c8519c","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicBasedLoadShedder.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicBasedLoadShedder.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicBasedLoadShedder.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicBasedLoadShedder.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4ed2e59e04214200ab330ac40a6bb0323ac63782","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b0fe2c9f152726ae14f4961c9338e92f9a45dea5","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicOwnershipChangeListener.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6b3a417621c376ac245ec29f399093277bc9bcce","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9651058394eae394c3c7b1f5c62f96f1a3f3d8a4","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","status":"added","additions":470,"deletions":0,"changes":470,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkHubServerManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"12744fdd9a462fd243bac16638863d3dfe457540","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","status":"added","additions":347,"deletions":0,"changes":347,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b708ab9f8dd1d617b437be7404a17b1eadbea11f","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsynBKCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"11ca3ff1e4b60a27fab7f7003e38dbdf380e0f06","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4e519f3b75db24c95967990a32c39227264bd876","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncZKCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f11c4160540fa624fe4e0a52b591851cf80706ec","filename":"branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/ZkUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"129943423fb222d7a9fa659efe3007f3692d0a3b","filename":"branch-4.3/hedwig-server/src/main/resources/LICENSE.bin.txt","status":"added","additions":302,"deletions":0,"changes":302,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/LICENSE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/LICENSE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/resources/LICENSE.bin.txt?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"d76e00c41fe1ffa65ec2f3256c42b83eda78cce9","filename":"branch-4.3/hedwig-server/src/main/resources/NOTICE.bin.txt","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/NOTICE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/NOTICE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/resources/NOTICE.bin.txt?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"9d6d431bcd25133b2a5b034319d93d34df77a6df","filename":"branch-4.3/hedwig-server/src/main/resources/findbugsExclude.xml","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/resources/findbugsExclude.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e7a8bf7e7f6d23bcaacd69c4c4e54671712ac06f","filename":"branch-4.3/hedwig-server/src/main/resources/p12.pass","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/p12.pass","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/p12.pass","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/resources/p12.pass?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b7043b85630c8988c6b20bff335fb6f6589c7621","filename":"branch-4.3/hedwig-server/src/main/resources/server.p12","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/server.p12","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/main/resources/server.p12","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/main/resources/server.p12?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"972e145a8ec327a3b154bdca74ba96e059bc3c5e","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/HelperMethods.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"89790aab4e24530e499e676bfc0db5108ee449e1","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"776a7f50a79a4a1470b3f39634d93aefee5ea08b","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/StubScanCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"c206ce41f7603e7fab815d1703bd63717eae6b84","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"added","additions":708,"deletions":0,"changes":708,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6fa34076133dc90b3495637459cbffe4b18284ba","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestSubAfterCloseSub.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestSubAfterCloseSub.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestSubAfterCloseSub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/TestSubAfterCloseSub.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e93ecae64810a8dd79adaac3f22a1e8f92d56b28","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","status":"added","additions":439,"deletions":0,"changes":439,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"ecc444e1fe9984c931cbc344214b52d0eff8c3d4","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","status":"added","additions":192,"deletions":0,"changes":192,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"adb4ea9aa9924c2154e807870995468d793fa7c6","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"added","additions":282,"deletions":0,"changes":282,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5e599601efbb5ef176733b50b4d41c68ee073aff","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/LoggingExceptionHandler.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/LoggingExceptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/LoggingExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/LoggingExceptionHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"be5722bf30faaedc6829c7f10ce49bee74abcc55","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f4e806d67dce41ff6824eb0c09bbf25a68360f55","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","status":"added","additions":1320,"deletions":0,"changes":1320,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestBackwardCompat.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0893a3d8b09f70d9c058bc1f860e958109145d5c","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"978649a4597aa1fdd980f415f33ae6ed902d5412","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8388deae11087c2bba4590a059994331550b7ede","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","status":"added","additions":298,"deletions":0,"changes":298,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestFIFODeliveryManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"46c0c17758af78a9dd540af9baa96effbb8791c4","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","status":"added","additions":375,"deletions":0,"changes":375,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8e9b8f6689a235dc8c68f2b75fb13e400c2c84c7","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/filter/TestMessageFilter.java","status":"added","additions":415,"deletions":0,"changes":415,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/filter/TestMessageFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/filter/TestMessageFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/filter/TestMessageFilter.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4a5c63d4b35b6848c6cc90dd0ff6838482be2fd9","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestBaseHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"93f5c2e720cea96656117dedde47891f10f8ba17","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"1867f9c27d52dd309eadf5d0078e6b267686a25e","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","status":"added","additions":777,"deletions":0,"changes":777,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"64e5b4ed3690d6fdf14781eafb470e2e1578e0f6","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubProxy.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubProxy.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2e370c0136e69109eee0e47a857211c61ef3a94e","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubRegular.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubRegular.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubRegular.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubRegular.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"98d36b6e9b217d0be9b19fc246e285daf5a4b380","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubSSL.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubSSL.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubSSL.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHubSSL.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"bce41e57525dc593e9fe65a45e32004b99ee0cfc","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"added","additions":304,"deletions":0,"changes":304,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"fb543ef7d008f29ed1d0af73a71deef4d1eccaac","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/MetadataManagerFactoryTestCase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b11500f905847a9ad9a8b197ba9cb27f6f481201","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestFactoryLayout.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"7e395e944ca4b6d0c97f799cd070e2b4afab4b1e","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","status":"added","additions":365,"deletions":0,"changes":365,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f8167297e2a3a7c8ef943344e9b83c72b8e0ca9b","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","status":"added","additions":306,"deletions":0,"changes":306,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManagerFactory.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"241f45bbcb88e54f96be30c222ab1a9c6b65924b","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","status":"added","additions":265,"deletions":0,"changes":265,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"08f5ad88ea458673118a5bc7159e0e888959d64a","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestServerStats.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestServerStats.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"91cf2fe2054e2863c325e46024962a8ae122225c","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/netty/WriteRecordingChannel.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a932ffd7b8d7eec231a8922bf6f09957d5819152","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"added","additions":267,"deletions":0,"changes":267,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"8d78fc5c64fef3eeebfce7893c5fcad575a33f24","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","status":"added","additions":288,"deletions":0,"changes":288,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"827677f14094a13cb8a28bad559897e3e1adfbc0","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e9fbd0877559952f14a665127964fad6bdbb6aa0","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubScanCallback.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"045935912951da96ad42aad36a6ef9a4ba6fac9d","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","status":"added","additions":798,"deletions":0,"changes":798,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f7bcac89782cd0ee59b4ae8d41b85ba23d687966","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookKeeperPersistenceManagerBlackBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f9dde4fb86f2d8f613542bfb85a254820c8ec5aa","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"added","additions":355,"deletions":0,"changes":355,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6e81fc7d6c2e64f301f7f1b55aa4bc2719896a30","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","status":"added","additions":276,"deletions":0,"changes":276,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"6a872597ec273491793e2dc56e6425505f8ad84f","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestLocalDBPersistenceManagerBlackBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0133d10e0b4129a764632af48f5e4e0b76e219b9","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","status":"added","additions":305,"deletions":0,"changes":305,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestPersistenceManagerBlackBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2e59a8a2e43e37cca7768efb5f9061593ddf6a20","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheBlackBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2179030c6f6684723c9931caa776b1f0f9b6da38","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","status":"added","additions":303,"deletions":0,"changes":303,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestReadAheadCacheWhiteBox.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"26b2ce3417d5f35d5b82d42ab888287076c281cb","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/StubSubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0e0f670fdcd32dfba2587be95ca1467cf0229752","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestMMSubscriptionManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f185bb4ce11b6e22495afce584c2bdea0c2121f5","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","status":"added","additions":252,"deletions":0,"changes":252,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"b66196e69b56c9a2c0190dc0ebcdb2b0a2655053","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/StubTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"0d508caec618d70ca895722377c5b1ca91a18fd7","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestConcurrentTopicAcquisition.java","status":"added","additions":210,"deletions":0,"changes":210,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestConcurrentTopicAcquisition.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestConcurrentTopicAcquisition.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestConcurrentTopicAcquisition.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"77c6fad49e0d2195d2ef1a16c0b457a4fec21bd6","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubInfo.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"f14d6014e5221e67ec86b2255086c43eff7750f1","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestHubLoad.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4c54d39f3154b0ff907bec46f27b8420e7b96e92","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","status":"added","additions":357,"deletions":0,"changes":357,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestMMTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"a54d0d45629c505f84563d516638689e9f997dee","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestTopicBasedLoadShedder.java","status":"added","additions":194,"deletions":0,"changes":194,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestTopicBasedLoadShedder.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestTopicBasedLoadShedder.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestTopicBasedLoadShedder.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"2f016f5f9ba8267ecc9722049878d27c22839801","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","status":"added","additions":376,"deletions":0,"changes":376,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/server/topics/TestZkTopicManager.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"e025e769f688af8afb1c880ecfc1696fadbc3924","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/TestZkUtils.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"4213059af0fb2cfedc21b1cfe7d1684637735846","filename":"branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/java/org/apache/hedwig/zookeeper/ZooKeeperTestBase.java?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"5983f0b5c3e6cef951dcca084e24ea62711ed60f","filename":"branch-4.3/hedwig-server/src/test/resources/log4j.properties","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/hedwig-server/src/test/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/hedwig-server/src/test/resources/log4j.properties?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"3bb2629248a0c60d15b471b5e5ecdb3504ee0ff0","filename":"branch-4.3/pom.xml","status":"added","additions":208,"deletions":0,"changes":208,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/pom.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"47edf5c77e17fd4a6fdd577f26c2294c43400fd3","filename":"branch-4.3/src/assemble/bin.xml","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/src/assemble/bin.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/src/assemble/bin.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/src/assemble/bin.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"},{"sha":"395f2b3834aa5776877adf6f9a94e1760b9d2e14","filename":"branch-4.3/src/assemble/src.xml","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/src/assemble/src.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d6c94da5751258c7868c7fd3232bafaf55090af9/branch-4.3/src/assemble/src.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/branch-4.3/src/assemble/src.xml?ref=d6c94da5751258c7868c7fd3232bafaf55090af9"}]}

