{"sha":"d930b579a1e96757e1698bf91bc1c99ac1cb5f35","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkOTMwYjU3OWExZTk2NzU3ZTE2OThiZjkxYmMxYzk5YWMxY2I1ZjM1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-27T14:55:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-27T14:55:17Z"},"message":"BOOKKEEPER-304: Prepare bookie vs ledgers cache and will be used by the Auditor (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1377703 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e7b5d4441ccbbb880760b97ffca9c7d10f708522","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e7b5d4441ccbbb880760b97ffca9c7d10f708522"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d930b579a1e96757e1698bf91bc1c99ac1cb5f35","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d930b579a1e96757e1698bf91bc1c99ac1cb5f35","html_url":"https://github.com/apache/bookkeeper/commit/d930b579a1e96757e1698bf91bc1c99ac1cb5f35","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c59b3d2e495e4ab7483b161ab9c2ce59f0c1e013","url":"https://api.github.com/repos/apache/bookkeeper/commits/c59b3d2e495e4ab7483b161ab9c2ce59f0c1e013","html_url":"https://github.com/apache/bookkeeper/commit/c59b3d2e495e4ab7483b161ab9c2ce59f0c1e013"}],"stats":{"total":385,"additions":385,"deletions":0},"files":[{"sha":"04d32ca73574ec70d42d64be97353abd439d5904","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d930b579a1e96757e1698bf91bc1c99ac1cb5f35","patch":"@@ -102,6 +102,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-248: Rereplicating of under replicated data (umamahesh via ivank)\n \n+        BOOKKEEPER-304: Prepare bookie vs ledgers cache and will be used by the Auditor (rakeshr via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"3b4e2243b511c3cd86518d3e8ec77f929c90f175","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/BookieLedgerIndexer.java?ref=d930b579a1e96757e1698bf91bc1c99ac1cb5f35","patch":"@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Preparing bookie vs its corresponding ledgers. This will always look up the\n+ * ledgermanager for ledger metadata and will generate indexes.\n+ */\n+public class BookieLedgerIndexer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BookieLedgerIndexer.class);\n+    private final LedgerManager ledgerManager;\n+\n+    public BookieLedgerIndexer(LedgerManager ledgerManager) {\n+        this.ledgerManager = ledgerManager;\n+    }\n+\n+    /**\n+     * Generating bookie vs its ledgers map by reading all the ledgers in each\n+     * bookie and parsing its metadata.\n+     * \n+     * @return bookie2ledgersMap map of bookie vs ledgers\n+     * @throws BKAuditException\n+     *             exception while getting bookie-ledgers\n+     */\n+    public Map<String, Set<Long>> getBookieToLedgerIndex()\n+            throws BKAuditException {\n+        // bookie vs ledgers map\n+        final ConcurrentHashMap<String, Set<Long>> bookie2ledgersMap\n+            = new ConcurrentHashMap<String, Set<Long>>();\n+        final CountDownLatch ledgerCollectorLatch = new CountDownLatch(1);\n+\n+        Processor<Long> ledgerProcessor = new Processor<Long>() {\n+            @Override\n+            public void process(final Long ledgerId,\n+                    final AsyncCallback.VoidCallback iterCallback) {\n+                GenericCallback<LedgerMetadata> genericCallback = new GenericCallback<LedgerMetadata>() {\n+                    @Override\n+                    public void operationComplete(final int rc,\n+                            LedgerMetadata ledgerMetadata) {\n+                        if (rc == BKException.Code.OK) {\n+                            StringBuilder bookieAddr;\n+                            for (Map.Entry<Long, ArrayList<InetSocketAddress>> ensemble : ledgerMetadata\n+                                    .getEnsembles().entrySet()) {\n+                                for (InetSocketAddress bookie : ensemble\n+                                        .getValue()) {\n+                                    bookieAddr = new StringBuilder();\n+                                    StringUtils\n+                                            .addrToString(bookieAddr, bookie);\n+                                    putLedger(bookie2ledgersMap, bookieAddr\n+                                            .toString(), ledgerId);\n+                                }\n+                            }\n+                        } else {\n+                            LOG.warn(\"Unable to read the ledger:\" + ledgerId\n+                                    + \" information\");\n+                        }\n+                        iterCallback.processResult(rc, null, null);\n+                    }\n+                };\n+                ledgerManager.readLedgerMetadata(ledgerId, genericCallback);\n+            }\n+        };\n+        // Reading the result after processing all the ledgers\n+        final List<Integer> resultCode = new ArrayList<Integer>(1);\n+        ledgerManager.asyncProcessLedgers(ledgerProcessor,\n+                new AsyncCallback.VoidCallback() {\n+\n+                    @Override\n+                    public void processResult(int rc, String s, Object obj) {\n+                        resultCode.add(rc);\n+                        ledgerCollectorLatch.countDown();\n+                    }\n+                }, null, BKException.Code.OK, BKException.Code.ReadException);\n+        try {\n+            ledgerCollectorLatch.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new BKAuditException(\n+                    \"Exception while getting the bookie-ledgers\", e);\n+        }\n+        if (!resultCode.contains(BKException.Code.OK)) {\n+            throw new BKAuditException(\n+                    \"Exception while getting the bookie-ledgers\", BKException\n+                            .create(resultCode.get(0)));\n+        }\n+        return bookie2ledgersMap;\n+    }\n+\n+    private void putLedger(ConcurrentHashMap<String, Set<Long>> bookie2ledgersMap,\n+            String bookie, long ledgerId) {\n+        Set<Long> ledgers = bookie2ledgersMap.get(bookie);\n+        // creates an empty list and add to bookie for keeping its ledgers\n+        if (ledgers == null) {\n+            ledgers = Collections.synchronizedSet(new HashSet<Long>());\n+            Set<Long> oldLedgers = bookie2ledgersMap.putIfAbsent(bookie, ledgers);\n+            if (oldLedgers != null) {\n+                ledgers = oldLedgers;\n+            }\n+        }\n+        ledgers.add(ledgerId);\n+    }\n+}"},{"sha":"236c6654a1c7bb52a91b82c9a3c6915c3902fbe8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java?ref=d930b579a1e96757e1698bf91bc1c99ac1cb5f35","patch":"@@ -60,4 +60,15 @@ public CompatibilityException(String message) {\n             super(message);\n         }\n     }\n+\n+    /**\n+     * Exception while auditing bookie-ledgers\n+    */\n+    static class BKAuditException extends ReplicationException {\n+        private static final long serialVersionUID = 95551905L;\n+\n+        BKAuditException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n }"},{"sha":"874bc4c365b6406bf1cb83fcc03362752fe6b7eb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","status":"added","additions":233,"deletions":0,"changes":233,"blob_url":"https://github.com/apache/bookkeeper/blob/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d930b579a1e96757e1698bf91bc1c99ac1cb5f35/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieLedgerIndexTest.java?ref=d930b579a1e96757e1698bf91bc1c99ac1cb5f35","patch":"@@ -0,0 +1,233 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.replication;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n+import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests verifies bookie vs ledger mapping generating by the BookieLedgerIndexer\n+ */\n+public class BookieLedgerIndexTest extends MultiLedgerManagerTestCase {\n+\n+    // Depending on the taste, select the amount of logging\n+    // by decommenting one of the two lines below\n+    // static Logger LOG = Logger.getRootLogger();\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(BookieLedgerIndexTest.class);\n+\n+    private byte[] ledgerPassword = \"admin\".getBytes();\n+    private Random rng; // Random Number Generator\n+    private ArrayList<byte[]> entries; // generated entries\n+    private DigestType digestType;\n+\n+    public BookieLedgerIndexTest(String ledgerManagerFactory) {\n+        super(3);\n+        LOG.info(\"Running test case using ledger manager : \"\n+                + ledgerManagerFactory);\n+        this.digestType = DigestType.CRC32;\n+        // set ledger manager name\n+        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        rng = new Random(System.currentTimeMillis()); // Initialize the Random\n+        // Number Generator\n+        entries = new ArrayList<byte[]>(); // initialize the entries list\n+    }\n+\n+    /**\n+     * Verify the bookie-ledger mapping with minimum number of bookies and few\n+     * ledgers\n+     */\n+    @Test\n+    public void testSimpleBookieLedgerMapping() throws Exception {\n+        LedgerManagerFactory newLedgerManagerFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseConf, zkc);\n+        LedgerManager ledgerManager = newLedgerManagerFactory\n+                .newLedgerManager();\n+\n+        List<Long> ledgerList = new ArrayList<Long>(3);\n+        LedgerHandle lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        BookieLedgerIndexer bookieLedgerIndex = new BookieLedgerIndexer(\n+                ledgerManager);\n+\n+        Map<String, Set<Long>> bookieToLedgerIndex = bookieLedgerIndex\n+                .getBookieToLedgerIndex();\n+\n+        assertEquals(\"Missed few bookies in the bookie-ledger mapping!\", 3,\n+                bookieToLedgerIndex.size());\n+        Collection<Set<Long>> bk2ledgerEntry = bookieToLedgerIndex.values();\n+        for (Set<Long> ledgers : bk2ledgerEntry) {\n+            assertEquals(\"Missed few ledgers in the bookie-ledger mapping!\", 3,\n+                    ledgers.size());\n+            for (Long ledgerId : ledgers) {\n+                assertTrue(\"Unknown ledger-bookie mapping\", ledgerList\n+                        .contains(ledgerId));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verify ledger index with failed bookies and throws exception\n+     */\n+    @Test\n+    public void testWithoutZookeeper() throws Exception {\n+        LedgerManagerFactory newLedgerManagerFactory = LedgerManagerFactory\n+                .newLedgerManagerFactory(baseConf, zkc);\n+        LedgerManager ledgerManager = newLedgerManagerFactory\n+                .newLedgerManager();\n+\n+        List<Long> ledgerList = new ArrayList<Long>(3);\n+        LedgerHandle lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        lh = createAndAddEntriesToLedger();\n+        lh.close();\n+        ledgerList.add(lh.getId());\n+\n+        BookieLedgerIndexer bookieLedgerIndex = new BookieLedgerIndexer(\n+                ledgerManager);\n+        stopZKCluster();\n+        try {\n+            bookieLedgerIndex.getBookieToLedgerIndex();\n+            fail(\"Must throw exception as bookies are not running!\");\n+        } catch (BKAuditException bkAuditException) {\n+            // expected behaviour\n+        }\n+    }\n+\n+    /**\n+     * Verify indexing with multiple ensemble reformation\n+     */\n+    @Test\n+    public void testEnsembleReformation() throws Exception {\n+        try {\n+            LedgerManagerFactory newLedgerManagerFactory = LedgerManagerFactory\n+                    .newLedgerManagerFactory(baseConf, zkc);\n+            LedgerManager ledgerManager = newLedgerManagerFactory\n+                    .newLedgerManager();\n+\n+            List<Long> ledgerList = new ArrayList<Long>(3);\n+            LedgerHandle lh1 = createAndAddEntriesToLedger();\n+            ledgerList.add(lh1.getId());\n+            LedgerHandle lh2 = createAndAddEntriesToLedger();\n+            ledgerList.add(lh2.getId());\n+\n+            startNewBookie();\n+            shutdownBookie(bs.size() - 2);\n+\n+            // add few more entries after ensemble reformation\n+            for (int i = 0; i < 10; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(Integer.MAX_VALUE));\n+                entry.position(0);\n+\n+                entries.add(entry.array());\n+                lh1.addEntry(entry.array());\n+                lh2.addEntry(entry.array());\n+            }\n+\n+            BookieLedgerIndexer bookieLedgerIndex = new BookieLedgerIndexer(\n+                    ledgerManager);\n+\n+            Map<String, Set<Long>> bookieToLedgerIndex = bookieLedgerIndex\n+                    .getBookieToLedgerIndex();\n+            assertEquals(\"Missed few bookies in the bookie-ledger mapping!\", 4,\n+                    bookieToLedgerIndex.size());\n+            Collection<Set<Long>> bk2ledgerEntry = bookieToLedgerIndex.values();\n+            for (Set<Long> ledgers : bk2ledgerEntry) {\n+                assertEquals(\n+                        \"Missed few ledgers in the bookie-ledger mapping!\", 2,\n+                        ledgers.size());\n+                for (Long ledgerNode : ledgers) {\n+                    assertTrue(\"Unknown ledger-bookie mapping\", ledgerList\n+                            .contains(ledgerNode));\n+                }\n+            }\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        }\n+    }\n+\n+    private void shutdownBookie(int bkShutdownIndex) throws IOException {\n+        bs.remove(bkShutdownIndex).shutdown();\n+        File f = tmpDirs.remove(bkShutdownIndex);\n+        FileUtils.deleteDirectory(f);\n+    }\n+\n+    private LedgerHandle createAndAddEntriesToLedger() throws BKException,\n+            InterruptedException {\n+        int numEntriesToWrite = 20;\n+        // Create a ledger\n+        LedgerHandle lh = bkc.createLedger(digestType, ledgerPassword);\n+        LOG.info(\"Ledger ID: \" + lh.getId());\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(Integer.MAX_VALUE));\n+            entry.position(0);\n+\n+            entries.add(entry.array());\n+            lh.addEntry(entry.array());\n+        }\n+        return lh;\n+    }\n+}"}]}

