{"sha":"da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkYTFhMmZhNmIxOWRkY2RiYTY4ODM0MTQ3YmY2YWZiZTViZjkwY2Jm","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-04-21T08:02:38Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-04-21T08:02:38Z"},"message":"BOOKKEEPER-833: EntryLogId and EntryLogLimit should not be larger than Integer.MAX_VALUE (sijie)","tree":{"sha":"47de1d1b43d703f92fdeca563559ccfbec87ca80","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/47de1d1b43d703f92fdeca563559ccfbec87ca80"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","html_url":"https://github.com/apache/bookkeeper/commit/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"e0d331781ec7a0e415bc6f16c38686aab34cb0c5","url":"https://api.github.com/repos/apache/bookkeeper/commits/e0d331781ec7a0e415bc6f16c38686aab34cb0c5","html_url":"https://github.com/apache/bookkeeper/commit/e0d331781ec7a0e415bc6f16c38686aab34cb0c5"}],"stats":{"total":59,"additions":46,"deletions":13},"files":[{"sha":"060d8145d3b6012e36fe663ecf18f53ed524f624","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","patch":"@@ -85,6 +85,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-836: disable compaction when disk becomes full, otherwise compaction will fill up disk quickly (zhaijia via sijie)\n \n+        BOOKKEEPER-833: EntryLogId and EntryLogLimit should not be larger than Integer.MAX_VALUE (sijie)\n+\n Release 4.3.0 - 2014-10-03\n \n   Non-backward compatible changes:"},{"sha":"d083f5eb8c36e9719f7d243c09d6fb21393aadfb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":22,"deletions":12,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","patch":"@@ -22,6 +22,7 @@\n package org.apache.bookkeeper.bookie;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.bookkeeper.util.BookKeeperConstants.MAX_LOG_SIZE_LIMIT;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n@@ -167,7 +168,7 @@ public EntryLogger(ServerConfiguration conf,\n             addListener(listener);\n         }\n         // log size limit\n-        this.logSizeLimit = conf.getEntryLogSizeLimit();\n+        this.logSizeLimit = Math.min(conf.getEntryLogSizeLimit(), MAX_LOG_SIZE_LIMIT);\n         this.entryLogPreAllocationEnabled = conf.isEntryLogFilePreAllocationEnabled();\n \n         // Initialize the entry log header buffer. This cannot be a static object\n@@ -439,7 +440,12 @@ BufferedLogChannel allocateNewLog() throws IOException {\n             // It would better not to overwrite existing entry log files\n             File newLogFile = null;\n             do {\n-                String logFileName = Long.toHexString(++preallocatedLogId) + \".log\";\n+                if (preallocatedLogId >= Integer.MAX_VALUE) {\n+                    preallocatedLogId = 0;\n+                } else {\n+                    ++preallocatedLogId;\n+                }\n+                String logFileName = Long.toHexString(preallocatedLogId) + \".log\";\n                 for (File dir : list) {\n                     newLogFile = new File(dir, logFileName);\n                     currentDir = dir;\n@@ -622,15 +628,16 @@ long addEntry(long ledger, ByteBuffer entry) throws IOException {\n     }\n \n     synchronized long addEntry(long ledger, ByteBuffer entry, boolean rollLog) throws IOException {\n-        if (rollLog) {\n-            // Create new log if logSizeLimit reached or current disk is full\n-            boolean createNewLog = shouldCreateNewEntryLog.get();\n-            if (createNewLog || reachEntryLogLimit(entry.remaining() + 4)) {\n-                createNewLog();\n-                // Reset the flag\n-                if (createNewLog) {\n-                    shouldCreateNewEntryLog.set(false);\n-                }\n+        int entrySize = entry.remaining() + 4;\n+        boolean reachEntryLogLimit =\n+                rollLog ? reachEntryLogLimit(entrySize) : readEntryLogHardLimit(entrySize);\n+        // Create new log if logSizeLimit reached or current disk is full\n+        boolean createNewLog = shouldCreateNewEntryLog.get();\n+        if (createNewLog || reachEntryLogLimit) {\n+            createNewLog();\n+            // Reset the flag\n+            if (createNewLog) {\n+                shouldCreateNewEntryLog.set(false);\n             }\n         }\n         ByteBuffer buff = ByteBuffer.allocate(4);\n@@ -651,6 +658,10 @@ synchronized boolean reachEntryLogLimit(long size) {\n         return logChannel.position() + size > logSizeLimit;\n     }\n \n+    synchronized boolean readEntryLogHardLimit(long size) {\n+        return logChannel.position() + size > Integer.MAX_VALUE;\n+    }\n+\n     byte[] readEntry(long ledgerId, long entryId, long location) throws IOException, Bookie.NoEntryException {\n         long entryLogId = logIdForOffset(location);\n         long pos = location & 0xffffffffL;\n@@ -836,7 +847,6 @@ public void shutdown() {\n             logid2FileChannel.clear();\n             // close current writing log file\n             closeFileChannel(logChannel);\n-            logChannel = null;\n         } catch (IOException ie) {\n             // we have no idea how to avoid io exception during shutting down, so just ignore it\n             LOG.error(\"Error flush entry log during shutting down, which may cause entry log corrupted.\", ie);"},{"sha":"3e0ce5e0de342e212429c29bf36012f026e25849","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java?ref=da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","patch":"@@ -165,13 +165,22 @@ public void onSizeLimitReached() throws IOException {\n         // so we roll entry log files in SortedLedgerStorage itself.\n         // After that, we could make the process writing data to entry logger file not bound with checkpoint.\n         // otherwise, it hurts add performance.\n+        //\n+        // The only exception for the size limitation is if a file grows to be more than hard limit 2GB,\n+        // we have to force rolling log, which it might cause slight performance effects\n         scheduler.submit(new Runnable() {\n             @Override\n             public void run() {\n                 try {\n                     LOG.info(\"Started flushing mem table.\");\n+                    long logIdBeforeFlush = entryLogger.getCurrentLogId();\n                     memTable.flush(SortedLedgerStorage.this);\n-                    if (entryLogger.reachEntryLogLimit(0)) {\n+                    long logIdAfterFlush = entryLogger.getCurrentLogId();\n+                    // in any case that an entry log reaches the limit, we roll the log and start checkpointing.\n+                    // if a memory table is flushed spanning over two entry log files, we also roll log. this is\n+                    // for performance consideration: since we don't wanna checkpoint a new log file that ledger\n+                    // storage is writing to.\n+                    if (entryLogger.reachEntryLogLimit(0) || logIdAfterFlush != logIdBeforeFlush) {\n                         entryLogger.rollLog();\n                         LOG.info(\"Rolling entry logger since it reached size limitation\");\n                     }"},{"sha":"cc2dda60870b164da6120d474e3b514de5df0232","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","patch":"@@ -23,6 +23,7 @@\n import com.google.common.annotations.Beta;\n import org.apache.bookkeeper.stats.NullStatsProvider;\n import org.apache.bookkeeper.stats.StatsProvider;\n+import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n@@ -1477,6 +1478,10 @@ public void validate() throws ConfigurationException {\n         if (getJournalAlignmentSize() > getJournalPreAllocSizeMB() * 1024 * 1024) {\n             throw new ConfigurationException(\"Invalid preallocation size : \" + getJournalPreAllocSizeMB() + \" MB\");\n         }\n+        if (getEntryLogSizeLimit() > BookKeeperConstants.MAX_LOG_SIZE_LIMIT) {\n+            throw new ConfigurationException(\"Entry log file size should not be larger than \"\n+                    + BookKeeperConstants.MAX_LOG_SIZE_LIMIT);\n+        }\n     }\n \n }"},{"sha":"2c2ba38065dd0e7ef2a4cca99ecc47cbc943b8b8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","raw_url":"https://github.com/apache/bookkeeper/raw/da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java?ref=da1a2fa6b19ddcdba68834147bf6afbe5bf90cbf","patch":"@@ -42,4 +42,11 @@\n     public static final String DEFAULT_ZK_LEDGERS_ROOT_PATH = \"/ledgers\";\r\n     public static final String LAYOUT_ZNODE = \"LAYOUT\";\r\n     public static final String INSTANCEID = \"INSTANCEID\";\r\n+\r\n+    /**\r\n+     * Set the max log size limit to 1GB. It makes extra room for entry log file before\r\n+     * hitting hard limit '2GB'. So we don't need to force roll entry log file when flushing\r\n+     * memtable (for performance consideration)\r\n+     */\r\n+    public static final long MAX_LOG_SIZE_LIMIT = 1 * 1024 * 1024 * 1024;\r\n }\r"}]}

