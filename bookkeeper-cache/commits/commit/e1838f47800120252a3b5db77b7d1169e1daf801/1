{"sha":"e1838f47800120252a3b5db77b7d1169e1daf801","node_id":"MDY6Q29tbWl0MTU3NTk1NjplMTgzOGY0NzgwMDEyMDI1MmEzYjVkYjc3YjdkMTE2OWUxZGFmODAx","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-24T08:43:56Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2014-04-24T08:43:56Z"},"message":"BOOKKEEPER-742: Fix for empty ledgers losing quorum. (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1589636 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a3388554156e41450cafa0b8694a4fd9608b06c5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a3388554156e41450cafa0b8694a4fd9608b06c5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e1838f47800120252a3b5db77b7d1169e1daf801","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e1838f47800120252a3b5db77b7d1169e1daf801","html_url":"https://github.com/apache/bookkeeper/commit/e1838f47800120252a3b5db77b7d1169e1daf801","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e1838f47800120252a3b5db77b7d1169e1daf801/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"88533163987f328be1d36c9f6fc208667f2144a0","url":"https://api.github.com/repos/apache/bookkeeper/commits/88533163987f328be1d36c9f6fc208667f2144a0","html_url":"https://github.com/apache/bookkeeper/commit/88533163987f328be1d36c9f6fc208667f2144a0"}],"stats":{"total":224,"additions":178,"deletions":46},"files":[{"sha":"e99e8a739e32edd7f3326c6076b5650881cf2fff","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -178,6 +178,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-432: Improve performance of entry log range read per ledger entries (yixue, sijie via ivank)\n \n+        BOOKKEEPER-742: Fix for empty ledgers losing quorum. (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"21eca0725ffed8d4e8de74a29306dd758342683f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -879,4 +879,11 @@ public void remove()\n             }\n         };\n     }\n+\n+    /**\n+     * @return the metadata for the passed ledger handle\n+     */\n+    public LedgerMetadata getLedgerMetadata(LedgerHandle lh) {\n+        return lh.getLedgerMetadata();\n+    }\n }"},{"sha":"dbf796c305167214759d1c1a2ef83cd8ce2de81d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":40,"deletions":36,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -43,6 +43,8 @@\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.collections.CollectionUtils;\n import org.apache.zookeeper.AsyncCallback;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.SettableFuture;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n@@ -54,6 +56,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.Future;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n@@ -137,48 +140,49 @@ public void run() {\n         }\n     }\n \n-    private synchronized void submitAuditTask() {\n-        synchronized (this) {\n-            if (executor.isShutdown()) {\n-                return;\n-            }\n-            executor.submit(new Runnable() {\n-                    @SuppressWarnings(\"unchecked\")\n-                    public void run() {\n-                        try {\n-                            waitIfLedgerReplicationDisabled();\n+    @VisibleForTesting\n+    synchronized Future<?> submitAuditTask() {\n+        if (executor.isShutdown()) {\n+            SettableFuture<Void> f = SettableFuture.<Void>create();\n+            f.setException(new BKAuditException(\"Auditor shutting down\"));\n+            return f;\n+        }\n+        return executor.submit(new Runnable() {\n+                @SuppressWarnings(\"unchecked\")\n+                public void run() {\n+                    try {\n+                        waitIfLedgerReplicationDisabled();\n \n-                            List<String> availableBookies = getAvailableBookies();\n+                        List<String> availableBookies = getAvailableBookies();\n \n-                            // casting to String, as knownBookies and availableBookies\n-                            // contains only String values\n-                            // find new bookies(if any) and update the known bookie list\n-                            Collection<String> newBookies = CollectionUtils.subtract(\n-                                    availableBookies, knownBookies);\n-                            knownBookies.addAll(newBookies);\n+                        // casting to String, as knownBookies and availableBookies\n+                        // contains only String values\n+                        // find new bookies(if any) and update the known bookie list\n+                        Collection<String> newBookies = CollectionUtils.subtract(\n+                                availableBookies, knownBookies);\n+                        knownBookies.addAll(newBookies);\n \n-                            // find lost bookies(if any)\n-                            Collection<String> lostBookies = CollectionUtils.subtract(\n-                                    knownBookies, availableBookies);\n+                        // find lost bookies(if any)\n+                        Collection<String> lostBookies = CollectionUtils.subtract(\n+                                knownBookies, availableBookies);\n \n-                            if (lostBookies.size() > 0) {\n-                                knownBookies.removeAll(lostBookies);\n-                                Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n-                                handleLostBookies(lostBookies, ledgerDetails);\n-                            }\n-                        } catch (BKException bke) {\n-                            LOG.error(\"Exception getting bookie list\", bke);\n-                        } catch (InterruptedException ie) {\n-                            Thread.currentThread().interrupt();\n-                            LOG.error(\"Interrupted while watching available bookies \", ie);\n-                        } catch (BKAuditException bke) {\n-                            LOG.error(\"Exception while watching available bookies\", bke);\n-                        } catch (UnavailableException ue) {\n-                            LOG.error(\"Exception while watching available bookies\", ue);\n+                        if (lostBookies.size() > 0) {\n+                            knownBookies.removeAll(lostBookies);\n+                            Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n+                            handleLostBookies(lostBookies, ledgerDetails);\n                         }\n+                    } catch (BKException bke) {\n+                        LOG.error(\"Exception getting bookie list\", bke);\n+                    } catch (InterruptedException ie) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.error(\"Interrupted while watching available bookies \", ie);\n+                    } catch (BKAuditException bke) {\n+                        LOG.error(\"Exception while watching available bookies\", bke);\n+                    } catch (UnavailableException ue) {\n+                        LOG.error(\"Exception while watching available bookies\", ue);\n                     }\n-                });\n-        }\n+                }\n+            });\n     }\n \n     public void start() {"},{"sha":"908a2cd979d998780fc71bb92ecc3d457aa09c08","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -269,6 +269,11 @@ public void run() {\n         executor.submit(r);\n     }\n \n+    @VisibleForTesting\n+    Auditor getAuditor() {\n+        return auditor;\n+    }\n+\n     /**\n      * Shutting down AuditorElector\n      */"},{"sha":"80bff846d985a1c49901c9446035da747f21b119","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -24,6 +24,8 @@\n import java.io.IOException;\n import java.net.MalformedURLException;\n \n+import com.google.common.annotations.VisibleForTesting;\n+\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieCriticalThread;\n import org.apache.bookkeeper.bookie.ExitCode;\n@@ -144,6 +146,11 @@ private int getExitCode() {\n         return exitCode;\n     }\n \n+    @VisibleForTesting\n+    public Auditor getAuditor() {\n+        return auditorElector.getAuditor();\n+    }\n+\n     /** Is auto-recovery service running? */\n     public boolean isAutoRecoveryRunning() {\n         return running;"},{"sha":"32a03e224e78c44f4d69e3c18e4f1b96b2c21374","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -70,5 +70,9 @@ public CompatibilityException(String message) {\n         BKAuditException(String message, Throwable cause) {\n             super(message, cause);\n         }\n+\n+        BKAuditException(String message) {\n+            super(message);\n+        }\n     }\n }"},{"sha":"8b7248343716ca32c8aef2e1e69339501baf949f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":48,"deletions":1,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -24,6 +24,9 @@\n import java.util.Set;\n import java.util.Timer;\n import java.util.TimerTask;\n+import java.util.SortedMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.bookie.BookieThread;\n@@ -36,6 +39,7 @@\n import org.apache.bookkeeper.client.LedgerChecker;\n import org.apache.bookkeeper.client.LedgerFragment;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n@@ -197,7 +201,7 @@ private void rereplicate() throws InterruptedException, BKException,\n             }\n         }\n \n-        if (foundOpenFragments) {\n+        if (foundOpenFragments || isLastSegmentOpenAndMissingBookies(lh)) {\n             deferLedgerLockRelease(ledgerIdToReplicate);\n             return;\n         }\n@@ -215,6 +219,45 @@ private void rereplicate() throws InterruptedException, BKException,\n         }\n     }\n \n+    /**\n+     * When checking the fragments of a ledger, there is a corner case\n+     * where if the last segment/ensemble is open, but nothing has been written to\n+     * some of the quorums in the ensemble, bookies can fail without any action being\n+     * taken. This is fine, until enough bookies fail to cause a quorum to become\n+     * unavailable, by which time the ledger is unrecoverable.\n+     *\n+     * For example, if in a E3Q2, only 1 entry is written and the last bookie\n+     * in the ensemble fails, nothing has been written to it, so nothing needs to be\n+     * recovered. But if the second to last bookie fails, we've now lost quorum for\n+     * the second entry, so it's impossible to see if the second has been written or\n+     * not.\n+     *\n+     * To avoid this situation, we need to check if bookies in the final open ensemble\n+     * are unavailable, and take action if so. The action to take is to close the ledger,\n+     * after a grace period as the writting client may replace the faulty bookie on its\n+     * own.\n+     *\n+     * Missing bookies in closed ledgers are fine, as we know the last confirmed add, so\n+     * we can tell which entries are supposed to exist and rereplicate them if necessary.\n+     */\n+    private boolean isLastSegmentOpenAndMissingBookies(LedgerHandle lh) throws BKException {\n+        LedgerMetadata md = admin.getLedgerMetadata(lh);\n+        if (md.isClosed()) {\n+            return false;\n+        }\n+\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles\n+            = admin.getLedgerMetadata(lh).getEnsembles();\n+        ArrayList<BookieSocketAddress> finalEnsemble = ensembles.get(ensembles.lastKey());\n+        Collection<BookieSocketAddress> available = admin.getAvailableBookies();\n+        for (BookieSocketAddress b : finalEnsemble) {\n+            if (!available.contains(b)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /** Gets the under replicated fragments */\n     private Set<LedgerFragment> getUnderreplicatedFragments(LedgerHandle lh)\n             throws InterruptedException {\n@@ -237,6 +280,10 @@ public void run() {\n                 LedgerHandle lh = null;\n                 try {\n                     lh = admin.openLedgerNoRecovery(ledgerId);\n+                    if (isLastSegmentOpenAndMissingBookies(lh)) {\n+                        lh = admin.openLedger(ledgerId);\n+                    }\n+\n                     Set<LedgerFragment> fragments = getUnderreplicatedFragments(lh);\n                     for (LedgerFragment fragment : fragments) {\n                         if (!fragment.isClosed()) {"},{"sha":"1b96667426f31f7ff2edb0759fba57e6dd9e525b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"modified","additions":54,"deletions":9,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.SortedMap;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -37,7 +38,7 @@\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n-import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n@@ -52,8 +53,7 @@\n  * Auditor-rereplication process: Auditor will publish the bookie failures,\n  * consequently ReplicationWorker will get the notifications and act on it.\n  */\n-public class BookieAutoRecoveryTest extends\n-        MultiLedgerManagerTestCase {\n+public class BookieAutoRecoveryTest extends BookKeeperClusterTestCase {\n     private static final Logger LOG = LoggerFactory\n             .getLogger(BookieAutoRecoveryTest.class);\n     private static final byte[] PASSWD = \"admin\".getBytes();\n@@ -68,15 +68,15 @@\n     private final String UNDERREPLICATED_PATH = baseClientConf\n             .getZkLedgersRootPath() + \"/underreplication/ledgers\";\n \n-    public BookieAutoRecoveryTest(String ledgerManagerFactory) throws IOException, KeeperException,\n+    public BookieAutoRecoveryTest() throws IOException, KeeperException,\n             InterruptedException, UnavailableException, CompatibilityException {\n         super(3);\n-        LOG.info(\"Running test case using ledger manager : \"\n-                + ledgerManagerFactory);\n-        // set ledger manager name\n-        baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+\n+        baseConf.setLedgerManagerFactoryClassName(\n+                \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n         baseConf.setOpenLedgerRereplicationGracePeriod(openLedgerRereplicationGracePeriod);\n-        baseClientConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        baseClientConf.setLedgerManagerFactoryClassName(\n+                \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n         this.digestType = DigestType.MAC;\n         setAutoRecoveryEnabled(true);\n     }\n@@ -342,6 +342,51 @@ public void testNoSuchLedgerExists() throws Exception {\n         }\n     }\n \n+    /**\n+     * Test that if a empty ledger loses the bookie not in the quorum for entry 0, it will\n+     * still be openable when it loses enough bookies to lose a whole quorum.\n+     */\n+    @Test(timeout=10000)\n+    public void testEmptyLedgerLosesQuorumEventually() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 2, 2, DigestType.CRC32, PASSWD);\n+        CountDownLatch latch = new CountDownLatch(1);\n+        String urZNode = getUrLedgerZNode(lh);\n+        watchUrLedgerNode(urZNode, latch);\n+\n+        BookieSocketAddress replicaToKill = LedgerHandleAdapter\n+            .getLedgerMetadata(lh).getEnsembles().get(0L).get(2);\n+        LOG.info(\"Killing last bookie, {}, in ensemble {}\", replicaToKill,\n+                 LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));\n+        killBookie(replicaToKill);\n+\n+        getAuditor().submitAuditTask().get(); // ensure auditor runs\n+\n+        assertTrue(\"Should be marked as underreplicated\", latch.await(5, TimeUnit.SECONDS));\n+        latch = new CountDownLatch(1);\n+        Stat s = watchUrLedgerNode(urZNode, latch); // should be marked as replicated\n+        if (s != null) {\n+            assertTrue(\"Should be marked as replicated\", latch.await(10, TimeUnit.SECONDS));\n+        }\n+\n+        replicaToKill = LedgerHandleAdapter\n+            .getLedgerMetadata(lh).getEnsembles().get(0L).get(1);\n+        LOG.info(\"Killing second bookie, {}, in ensemble {}\", replicaToKill,\n+                 LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));\n+        killBookie(replicaToKill);\n+\n+        getAuditor().submitAuditTask().get(); // ensure auditor runs\n+\n+        assertTrue(\"Should be marked as underreplicated\", latch.await(5, TimeUnit.SECONDS));\n+        latch = new CountDownLatch(1);\n+        s = watchUrLedgerNode(urZNode, latch); // should be marked as replicated\n+        if (s != null) {\n+            assertTrue(\"Should be marked as replicated\", latch.await(5, TimeUnit.SECONDS));\n+        }\n+\n+        // should be able to open ledger without issue\n+        bkc.openLedger(lh.getId(), DigestType.CRC32, PASSWD);\n+    }\n+\n     private int getReplicaIndexInLedger(LedgerHandle lh,\n  BookieSocketAddress replicaToKill) {\n         SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = LedgerHandleAdapter"},{"sha":"29923fd6db594de9aa1ccc11aa0cec41b0e6891e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/e1838f47800120252a3b5db77b7d1169e1daf801/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=e1838f47800120252a3b5db77b7d1169e1daf801","patch":"@@ -44,6 +44,7 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.AutoRecoveryMain;\n+import org.apache.bookkeeper.replication.Auditor;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.commons.io.FileUtils;\n@@ -528,4 +529,14 @@ public void stopReplicationService() throws Exception{\n                     + autoRecoveryProcess.getKey().getLocalAddress());\n         }\n     }\n+\n+    public Auditor getAuditor() throws Exception {\n+        for (AutoRecoveryMain p : autoRecoveryProcesses.values()) {\n+            Auditor a = p.getAuditor();\n+            if (a != null) {\n+                return a;\n+            }\n+        }\n+        throw new Exception(\"No auditor found\");\n+    }\n }"}]}

