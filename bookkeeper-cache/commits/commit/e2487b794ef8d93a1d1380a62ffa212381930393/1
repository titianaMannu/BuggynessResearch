{"sha":"e2487b794ef8d93a1d1380a62ffa212381930393","node_id":"MDY6Q29tbWl0MTU3NTk1NjplMjQ4N2I3OTRlZjhkOTNhMWQxMzgwYTYyZmZhMjEyMzgxOTMwMzkz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-05T14:24:42Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-10-05T14:24:42Z"},"message":"BOOKKEEPER-315: Ledger entries should be replicated sequentially instead of parallel. (umamahesh via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1394542 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"63df30f445fcd49b34343d4eb51512b99704a167","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/63df30f445fcd49b34343d4eb51512b99704a167"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e2487b794ef8d93a1d1380a62ffa212381930393","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e2487b794ef8d93a1d1380a62ffa212381930393","html_url":"https://github.com/apache/bookkeeper/commit/e2487b794ef8d93a1d1380a62ffa212381930393","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e2487b794ef8d93a1d1380a62ffa212381930393/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"ba01aed276fc847926310376520d3ec513503c61","url":"https://api.github.com/repos/apache/bookkeeper/commits/ba01aed276fc847926310376520d3ec513503c61","html_url":"https://github.com/apache/bookkeeper/commit/ba01aed276fc847926310376520d3ec513503c61"}],"stats":{"total":439,"additions":336,"deletions":103},"files":[{"sha":"128138c5984e49a67a49459eaa351e189323244a","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -150,6 +150,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-319: Manage auditing and replication processes (Vinay via ivank)\n \n+        BOOKKEEPER-315: Ledger entries should be replicated sequentially instead of parallel. (umamahesh via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"cd0c3ef68d9b71e575bc84d2024f378e6d72e2ed","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -44,9 +44,9 @@\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZKUtil;\n-import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooDefs.Ids;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -633,7 +633,7 @@ public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n      */\n     private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n-            final LedgerFragmentReplicator.SingleFragmentCallback ledgerFragmentMcb,\n+            final AsyncCallback.VoidCallback ledgerFragmentMcb,\n             final InetSocketAddress newBookie) throws InterruptedException {\n         lfr.replicate(lh, ledgerFragment, ledgerFragmentMcb, newBookie);\n     }\n@@ -650,15 +650,15 @@ private void asyncRecoverLedgerFragment(final LedgerHandle lh,\n      */\n     public void replicateLedgerFragment(LedgerHandle lh,\n             final LedgerFragment ledgerFragment,\n-            InetSocketAddress targetBookieAddress) throws InterruptedException,\n-            BKException {\n-        final SyncCounter syncCounter = new SyncCounter();\n+            final InetSocketAddress targetBookieAddress)\n+            throws InterruptedException, BKException {\n+        SyncCounter syncCounter = new SyncCounter();\n         ResultCallBack resultCallBack = new ResultCallBack(syncCounter);\n-        SingleFragmentCallback sfcb = new SingleFragmentCallback(\n-                resultCallBack, lh, ledgerFragment.getFirstStoredEntryId(),\n-                ledgerFragment.getAddress(), targetBookieAddress);\n+        SingleFragmentCallback cb = new SingleFragmentCallback(resultCallBack,\n+                lh, ledgerFragment.getFirstEntryId(), ledgerFragment\n+                        .getAddress(), targetBookieAddress);\n         syncCounter.inc();\n-        lfr.replicate(lh, ledgerFragment, sfcb, targetBookieAddress);\n+        asyncRecoverLedgerFragment(lh, ledgerFragment, cb, targetBookieAddress);\n         syncCounter.block(0);\n         if (syncCounter.getrc() != BKException.Code.OK) {\n             throw BKException.create(syncCounter.getrc());"},{"sha":"9fa9e715be46103d49708beb4eff041a153f1fac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -85,6 +85,13 @@ long getLastKnownEntryId() {\n     public InetSocketAddress getAddress() {\n         return ensemble.get(bookieIndex);\n     }\n+    \n+    /**\n+     * Gets the failedBookie index\n+     */\n+    public int getBookiesIndex() {\n+        return bookieIndex;\n+    }\n \n     /**\n      * Gets the first stored entry id of the fragment in failed bookie."},{"sha":"0a4f045fc9e6dcab434c26456abdf2f1dc392251","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"modified","additions":198,"deletions":85,"changes":283,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -22,8 +22,11 @@\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n@@ -54,25 +57,10 @@ public LedgerFragmentReplicator(BookKeeper bkc) {\n     private static Logger LOG = LoggerFactory\n             .getLogger(LedgerFragmentReplicator.class);\n \n-    /**\n-     * This method replicate a ledger fragment which is a contiguous portion of\n-     * a ledger that was stored in an ensemble that included the failed bookie.\n-     * \n-     * @param lh\n-     *            LedgerHandle for the ledger\n-     * @param lf\n-     *            LedgerFragment to replicate\n-     * @param ledgerFragmentMcb\n-     *            MultiCallback to invoke once we've recovered the current\n-     *            ledger fragment.\n-     * @param newBookie\n-     *            New bookie we want to use to recover and replicate the ledger\n-     *            entries that were stored on the failed bookie.\n-     */\n-    void replicate(final LedgerHandle lh, final LedgerFragment lf,\n-                   final SingleFragmentCallback ledgerFragmentMcb,\n-                   final InetSocketAddress newBookie)\n-            throws InterruptedException {\n+    private void replicateFragmentInternal(final LedgerHandle lh,\n+            final LedgerFragment lf,\n+            final AsyncCallback.VoidCallback ledgerFragmentMcb,\n+            final InetSocketAddress newBookie) throws InterruptedException {\n         if (!lf.isClosed()) {\n             LOG.error(\"Trying to replicate an unclosed fragment;\"\n                       + \" This is not safe {}\", lf);\n@@ -123,6 +111,114 @@ void replicate(final LedgerHandle lh, final LedgerFragment lf,\n         }\n     }\n \n+    /**\n+     * This method replicate a ledger fragment which is a contiguous portion of\n+     * a ledger that was stored in an ensemble that included the failed bookie.\n+     * It will Splits the fragment into multiple sub fragments by keeping the\n+     * max entries up to the configured value of rereplicationEntryBatchSize and\n+     * then it re-replicates that batched entry fragments one by one. After\n+     * re-replication of all batched entry fragments, it will update the\n+     * ensemble info with new Bookie once\n+     * \n+     * @param lh\n+     *            LedgerHandle for the ledger\n+     * @param lf\n+     *            LedgerFragment to replicate\n+     * @param ledgerFragmentMcb\n+     *            MultiCallback to invoke once we've recovered the current\n+     *            ledger fragment.\n+     * @param targetBookieAddress\n+     *            New bookie we want to use to recover and replicate the ledger\n+     *            entries that were stored on the failed bookie.\n+     */\n+    void replicate(final LedgerHandle lh, final LedgerFragment lf,\n+            final AsyncCallback.VoidCallback ledgerFragmentMcb,\n+            final InetSocketAddress targetBookieAddress)\n+            throws InterruptedException {\n+        Set<LedgerFragment> partionedFragments = splitIntoSubFragments(lh, lf,\n+                bkc.getConf().getRereplicationEntryBatchSize());\n+        LOG.info(\"Fragment :\" + lf + \" is split into sub fragments :\"\n+                + partionedFragments);\n+        replicateNextBatch(lh, partionedFragments.iterator(),\n+                ledgerFragmentMcb, targetBookieAddress);\n+    }\n+\n+    /** Replicate the batched entry fragments one after other */\n+    private void replicateNextBatch(final LedgerHandle lh,\n+            final Iterator<LedgerFragment> fragments,\n+            final AsyncCallback.VoidCallback ledgerFragmentMcb,\n+            final InetSocketAddress targetBookieAddress) {\n+        if (fragments.hasNext()) {\n+            try {\n+                replicateFragmentInternal(lh, fragments.next(),\n+                        new AsyncCallback.VoidCallback() {\n+                            @Override\n+                            public void processResult(int rc, String v, Object ctx) {\n+                                if (rc != BKException.Code.OK) {\n+                                    ledgerFragmentMcb.processResult(rc, null,\n+                                            null);\n+                                } else {\n+                                    replicateNextBatch(lh, fragments,\n+                                            ledgerFragmentMcb,\n+                                            targetBookieAddress);\n+                                }\n+                            }\n+\n+                        }, targetBookieAddress);\n+            } catch (InterruptedException e) {\n+                ledgerFragmentMcb.processResult(\n+                        BKException.Code.InterruptedException, null, null);\n+                Thread.currentThread().interrupt();\n+            }\n+        } else {\n+            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);\n+        }\n+    }\n+\n+    /**\n+     * Split the full fragment into batched entry fragments by keeping\n+     * rereplicationEntryBatchSize of entries in each one and can treat them as\n+     * sub fragments\n+     */\n+    static Set<LedgerFragment> splitIntoSubFragments(LedgerHandle lh,\n+            LedgerFragment ledgerFragment, long rereplicationEntryBatchSize) {\n+        Set<LedgerFragment> fragments = new HashSet<LedgerFragment>();\n+        if (rereplicationEntryBatchSize <= 0) {\n+            // rereplicationEntryBatchSize can not be 0 or less than 0,\n+            // returning with the current fragment\n+            fragments.add(ledgerFragment);\n+            return fragments;\n+        }\n+\n+        long firstEntryId = ledgerFragment.getFirstStoredEntryId();\n+        long lastEntryId = ledgerFragment.getLastStoredEntryId();\n+        long numberOfEntriesToReplicate = (lastEntryId - firstEntryId) + 1;\n+        long splitsWithFullEntries = numberOfEntriesToReplicate\n+                / rereplicationEntryBatchSize;\n+\n+        if (splitsWithFullEntries == 0) {// only one fragment\n+            fragments.add(ledgerFragment);\n+            return fragments;\n+        }\n+\n+        long fragmentSplitLastEntry = 0;\n+        for (int i = 0; i < splitsWithFullEntries; i++) {\n+            fragmentSplitLastEntry = (firstEntryId + rereplicationEntryBatchSize) - 1;\n+            fragments.add(new LedgerFragment(lh, firstEntryId,\n+                    fragmentSplitLastEntry, ledgerFragment.getBookiesIndex()));\n+            firstEntryId = fragmentSplitLastEntry + 1;\n+        }\n+\n+        long lastSplitWithPartialEntries = numberOfEntriesToReplicate\n+                % rereplicationEntryBatchSize;\n+        if (lastSplitWithPartialEntries > 0) {\n+            fragments.add(new LedgerFragment(lh, firstEntryId, firstEntryId\n+                    + lastSplitWithPartialEntries - 1, ledgerFragment\n+                    .getBookiesIndex()));\n+        }\n+        return fragments;\n+    }\n+\n     /**\n      * This method asynchronously recovers a specific ledger entry by reading\n      * the values via the BookKeeper Client (which would read it from the other\n@@ -233,77 +329,94 @@ public void processResult(int rc, String path, Object ctx) {\n                 ledgerFragmentsMcb.processResult(rc, null, null);\n                 return;\n             }\n-            writeLedgerConfig();\n+            updateEnsembleInfo(ledgerFragmentsMcb, fragmentStartId, lh,\n+                                        oldBookie, newBookie);\n         }\n+    }\n \n-        protected void writeLedgerConfig() {\n-            /*\n-             * Update the ledger metadata's ensemble info to point to the new\n-             * bookie.\n-             */\n-            ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n-                    .getEnsembles().get(fragmentStartId);\n-            int deadBookieIndex = ensemble.indexOf(oldBookie);\n-            ensemble.remove(deadBookieIndex);\n-            ensemble.add(deadBookieIndex, newBookie);\n-            lh.writeLedgerConfig(new WriteCb());\n+    /** Updates the ensemble with newBookie and notify the ensembleUpdatedCb */\n+    private static void updateEnsembleInfo(\n+            AsyncCallback.VoidCallback ensembleUpdatedCb, long fragmentStartId,\n+            LedgerHandle lh, InetSocketAddress oldBookie,\n+            InetSocketAddress newBookie) {\n+        /*\n+         * Update the ledger metadata's ensemble info to point to the new\n+         * bookie.\n+         */\n+        ArrayList<InetSocketAddress> ensemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(fragmentStartId);\n+        int deadBookieIndex = ensemble.indexOf(oldBookie);\n+        ensemble.remove(deadBookieIndex);\n+        ensemble.add(deadBookieIndex, newBookie);\n+        lh.writeLedgerConfig(new UpdateEnsembleCb(ensembleUpdatedCb,\n+                fragmentStartId, lh, oldBookie, newBookie));\n+    }\n+\n+    /**\n+     * Update the ensemble data with newBookie. re-reads the metadata on\n+     * MetadataVersionException and update ensemble again. On successfull\n+     * updation, it will also notify to super call back\n+     */\n+    private static class UpdateEnsembleCb implements GenericCallback<Void> {\n+        final AsyncCallback.VoidCallback ensembleUpdatedCb;\n+        final LedgerHandle lh;\n+        final long fragmentStartId;\n+        final InetSocketAddress oldBookie;\n+        final InetSocketAddress newBookie;\n+\n+        public UpdateEnsembleCb(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n+                long fragmentStartId, LedgerHandle lh,\n+                InetSocketAddress oldBookie, InetSocketAddress newBookie) {\n+            this.ensembleUpdatedCb = ledgerFragmentsMcb;\n+            this.lh = lh;\n+            this.fragmentStartId = fragmentStartId;\n+            this.newBookie = newBookie;\n+            this.oldBookie = oldBookie;\n         }\n \n-        private class WriteCb implements GenericCallback<Void> {\n-            @Override\n-            public void operationComplete(int rc, Void result) {\n-                if (rc == BKException.Code.MetadataVersionException) {\n-                    LOG\n-                            .warn(\"Two fragments attempted update at once; ledger id: \"\n-                                    + lh.getId()\n-                                    + \" startid: \"\n-                                    + fragmentStartId);\n-                    // try again, the previous success (with which this has\n-                    // conflicted)\n-                    // will have updated the stat\n-                    // other operations such as (addEnsemble) would update it\n-                    // too.\n-                    lh.rereadMetadata(new OrderedSafeGenericCallback<LedgerMetadata>(lh.bk.mainWorkerPool,\n-                                                                                     lh.getId()) {\n-                        @Override\n-                        public void safeOperationComplete(int rc,\n-                                LedgerMetadata newMeta) {\n-                            if (rc != BKException.Code.OK) {\n-                                LOG\n-                                        .error(\"Error reading updated ledger metadata for ledger \"\n-                                                + lh.getId());\n-                                ledgerFragmentsMcb\n-                                        .processResult(rc, null, null);\n-                            } else {\n-                                lh.metadata = newMeta;\n-                                writeLedgerConfig();\n+        @Override\n+        public void operationComplete(int rc, Void result) {\n+            if (rc == BKException.Code.MetadataVersionException) {\n+                LOG.warn(\"Two fragments attempted update at once; ledger id: \"\n+                        + lh.getId() + \" startid: \" + fragmentStartId);\n+                // try again, the previous success (with which this has\n+                // conflicted) will have updated the stat other operations\n+                // such as (addEnsemble) would update it too.\n+                lh\n+                        .rereadMetadata(new OrderedSafeGenericCallback<LedgerMetadata>(\n+                                lh.bk.mainWorkerPool, lh.getId()) {\n+                            @Override\n+                            public void safeOperationComplete(int rc,\n+                                    LedgerMetadata newMeta) {\n+                                if (rc != BKException.Code.OK) {\n+                                    LOG\n+                                            .error(\"Error reading updated ledger metadata for ledger \"\n+                                                    + lh.getId());\n+                                    ensembleUpdatedCb.processResult(rc, null,\n+                                            null);\n+                                } else {\n+                                    lh.metadata = newMeta;\n+                                    updateEnsembleInfo(ensembleUpdatedCb,\n+                                            fragmentStartId, lh, oldBookie,\n+                                            newBookie);\n+                                }\n                             }\n-                        }\n-                    });\n-                    return;\n-                } else if (rc != BKException.Code.OK) {\n-                    LOG\n-                            .error(\"Error updating ledger config metadata for ledgerId \"\n-                                    + lh.getId()\n-                                    + \" : \"\n-                                    + BKException.getMessage(rc));\n-                } else {\n-                    LOG\n-                            .info(\"Updated ZK for ledgerId: (\"\n-                                    + lh.getId()\n-                                    + \" : \"\n-                                    + fragmentStartId\n-                                    + \") to point ledger fragments from old dead bookie: (\"\n-                                    + oldBookie + \") to new bookie: (\"\n-                                    + newBookie + \")\");\n-                }\n-                /*\n-                 * Pass the return code result up the chain with the parent\n-                 * callback.\n-                 */\n-                ledgerFragmentsMcb.processResult(rc, null, null);\n+                        });\n+                return;\n+            } else if (rc != BKException.Code.OK) {\n+                LOG.error(\"Error updating ledger config metadata for ledgerId \"\n+                        + lh.getId() + \" : \" + BKException.getMessage(rc));\n+            } else {\n+                LOG.info(\"Updated ZK for ledgerId: (\" + lh.getId() + \" : \"\n+                        + fragmentStartId\n+                        + \") to point ledger fragments from old dead bookie: (\"\n+                        + oldBookie + \") to new bookie: (\" + newBookie + \")\");\n             }\n-        };\n+            /*\n+             * Pass the return code result up the chain with the parent\n+             * callback.\n+             */\n+            ensembleUpdatedCb.processResult(rc, null, null);\n+        }\n     }\n-\n }"},{"sha":"2692fdef995494b7f47a559574af7d9a28aaa308","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -51,6 +51,8 @@\n     protected final static String LEDGER_MANAGER_FACTORY_CLASS = \"ledgerManagerFactoryClass\";\n     protected final static String ZK_LEDGERS_ROOT_PATH = \"zkLedgersRootPath\";\n     protected final static String AVAILABLE_NODE = \"available\";\n+    protected final static String REREPLICATION_ENTRY_BATCH_SIZE = \"rereplicationEntryBatchSize\";\n+\n     protected AbstractConfiguration() {\n         super();\n         // add configuration for system properties\n@@ -174,4 +176,22 @@ public String getZkLedgersRootPath() {\n     public String getZkAvailableBookiesPath() {\n         return getZkLedgersRootPath() + \"/\" + AVAILABLE_NODE;\n     }\n+    \n+    /**\n+     * Set the max entries to keep in fragment for re-replication. If fragment\n+     * has more entries than this count, then the original fragment will be\n+     * split into multiple small logical fragments by keeping max entries count\n+     * to rereplicationEntryBatchSize. So, re-replication will happen in batches\n+     * wise.\n+     */\n+    public void setRereplicationEntryBatchSize(long rereplicationEntryBatchSize) {\n+        setProperty(REREPLICATION_ENTRY_BATCH_SIZE, rereplicationEntryBatchSize);\n+    }\n+\n+    /**\n+     * Get the re-replication entry batch size\n+     */\n+    public long getRereplicationEntryBatchSize() {\n+        return getLong(REREPLICATION_ENTRY_BATCH_SIZE, 10);\n+    }\n }"},{"sha":"37c07a2cf7f32fd3479b61e439e1104f02a210a6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -36,7 +36,6 @@\n import org.apache.bookkeeper.client.BKException.BKBookieHandleNotAvailableException;\n import org.apache.bookkeeper.client.BKException.BKNoSuchLedgerExistsException;\n import org.apache.bookkeeper.client.BKException.BKReadException;\n-import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n@@ -57,7 +56,7 @@\n     private static Logger LOG = LoggerFactory\n             .getLogger(ReplicationWorker.class);\n     final private LedgerUnderreplicationManager underreplicationManager;\n-    private AbstractConfiguration conf;\n+    private ServerConfiguration conf;\n     private ZooKeeper zkc;\n     private volatile boolean workerRunning = false;\n     final private BookKeeperAdmin admin;"},{"sha":"eb4a2a0ccbf76b2b36cd2c2f506d1322809493cf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","status":"modified","additions":98,"deletions":7,"changes":105,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerFragmentReplication.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -28,6 +28,7 @@\n import java.util.Map.Entry;\n import java.util.concurrent.CountDownLatch;\n \n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.Test;\n@@ -40,6 +41,8 @@\n  */\n public class TestLedgerFragmentReplication extends BookKeeperClusterTestCase {\n \n+    private static final byte[] TEST_PSSWD = \"testpasswd\".getBytes();\n+    private static final DigestType TEST_DIGEST_TYPE = BookKeeper.DigestType.CRC32;\n     private static Logger LOG = LoggerFactory\n             .getLogger(TestLedgerFragmentReplication.class);\n \n@@ -72,8 +75,8 @@ public void operationComplete(int rc, Set<LedgerFragment> result) {\n     public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n             throws Exception {\n         byte[] data = \"TestLedgerFragmentReplication\".getBytes();\n-        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+        LedgerHandle lh = bkc.createLedger(3, 3, TEST_DIGEST_TYPE,\n+                TEST_PSSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -129,8 +132,8 @@ public void testReplicateLFShouldCopyFailedBookieFragmentsToTargetBookie()\n     public void testReplicateLFFailsOnlyOnLastUnClosedFragments()\n             throws Exception {\n         byte[] data = \"TestLedgerFragmentReplication\".getBytes();\n-        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+        LedgerHandle lh = bkc.createLedger(3, 3, TEST_DIGEST_TYPE,\n+                TEST_PSSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -187,8 +190,8 @@ public void testReplicateLFFailsOnlyOnLastUnClosedFragments()\n     public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n             throws Exception {\n         byte[] data = \"TestLedgerFragmentReplication\".getBytes();\n-        LedgerHandle lh = bkc.createLedger(2, 1, BookKeeper.DigestType.CRC32,\n-                \"testpasswd\".getBytes());\n+        LedgerHandle lh = bkc.createLedger(2, 1, TEST_DIGEST_TYPE,\n+                TEST_PSSWD);\n \n         for (int i = 0; i < 10; i++) {\n             lh.addEntry(data);\n@@ -222,6 +225,94 @@ public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n             }\n         }\n     }\n+    \n+    /**\n+     * Tests that splitIntoSubFragment should be able to split the original\n+     * passed fragment into sub fragments at correct boundaries\n+     */\n+    @Test(timeout = 30000)\n+    public void testSplitIntoSubFragmentsWithDifferentFragmentBoundaries()\n+            throws Exception {\n+        LedgerMetadata metadata = new LedgerMetadata(3, 3, 3, TEST_DIGEST_TYPE,\n+                TEST_PSSWD) {\n+            @Override\n+            ArrayList<InetSocketAddress> getEnsemble(long entryId) {\n+                return null;\n+            }\n+\n+            @Override\n+            public boolean isClosed() {\n+                return true;\n+            }\n+        };\n+        LedgerHandle lh = new LedgerHandle(bkc, 0, metadata, TEST_DIGEST_TYPE,\n+                TEST_PSSWD);\n+        testSplitIntoSubFragments(10, 21, -1, 1, lh);\n+        testSplitIntoSubFragments(10, 21, 20, 1, lh);\n+        testSplitIntoSubFragments(0, 0, 10, 1, lh);\n+        testSplitIntoSubFragments(0, 1, 1, 2, lh);\n+        testSplitIntoSubFragments(20, 24, 2, 3, lh);\n+        testSplitIntoSubFragments(21, 32, 3, 4, lh);\n+        testSplitIntoSubFragments(22, 103, 11, 8, lh);\n+        testSplitIntoSubFragments(49, 51, 1, 3, lh);\n+        testSplitIntoSubFragments(11, 101, 3, 31, lh);\n+    }\n+\n+    /** assert the sub-fragment boundaries */\n+    void testSplitIntoSubFragments(final long oriFragmentFirstEntry,\n+            final long oriFragmentLastEntry, long entriesPerSubFragment,\n+            long expectedSubFragments, LedgerHandle lh) {\n+        LedgerFragment fr = new LedgerFragment(lh, oriFragmentFirstEntry,\n+                oriFragmentLastEntry, 0) {\n+            @Override\n+            public long getLastStoredEntryId() {\n+                return oriFragmentLastEntry;\n+            }\n+\n+            @Override\n+            public long getFirstStoredEntryId() {\n+                return oriFragmentFirstEntry;\n+            }\n+        };\n+        Set<LedgerFragment> subFragments = LedgerFragmentReplicator\n+                .splitIntoSubFragments(lh, fr, entriesPerSubFragment);\n+        assertEquals(expectedSubFragments, subFragments.size());\n+        int fullSubFragment = 0;\n+        int partialSubFragment = 0;\n+        for (LedgerFragment ledgerFragment : subFragments) {\n+            if ((ledgerFragment.getLastKnownEntryId()\n+                    - ledgerFragment.getFirstEntryId() + 1) == entriesPerSubFragment) {\n+                fullSubFragment++;\n+            } else {\n+                long totalEntriesToReplicate = oriFragmentLastEntry\n+                        - oriFragmentFirstEntry + 1;\n+                if (entriesPerSubFragment <= 0\n+                        || totalEntriesToReplicate / entriesPerSubFragment == 0) {\n+                    assertEquals(\n+                            \"FirstEntryId should be same as original fragment's firstEntryId\",\n+                            fr.getFirstEntryId(), ledgerFragment\n+                                    .getFirstEntryId());\n+                    assertEquals(\n+                            \"LastEntryId should be same as original fragment's lastEntryId\",\n+                            fr.getLastKnownEntryId(), ledgerFragment\n+                                    .getLastKnownEntryId());\n+                } else {\n+                    long partialSplitEntries = totalEntriesToReplicate\n+                            % entriesPerSubFragment;\n+                    assertEquals(\n+                            \"Partial fragment with wrong entry boundaries\",\n+                            ledgerFragment.getLastKnownEntryId()\n+                                    - ledgerFragment.getFirstEntryId() + 1,\n+                            partialSplitEntries);\n+                }\n+                partialSubFragment++;\n+            }\n+        }\n+        assertEquals(\"Unexpected number of sub fargments\", fullSubFragment\n+                + partialSubFragment, expectedSubFragments);\n+        assertTrue(\"There should be only one or zero partial sub Fragment\",\n+                partialSubFragment == 0 || partialSubFragment == 1);\n+    }\n \n     private Set<LedgerFragment> getFragmentsToReplicate(LedgerHandle lh)\n             throws InterruptedException {\n@@ -235,7 +326,7 @@ public void testReplicateLFShouldReturnFalseIfTheReplicationFails()\n     private void verifyRecoveredLedgers(LedgerHandle lh, long startEntryId,\n             long endEntryId) throws BKException, InterruptedException {\n         LedgerHandle lhs = bkc.openLedgerNoRecovery(lh.getId(),\n-                BookKeeper.DigestType.CRC32, \"testpasswd\".getBytes());\n+                TEST_DIGEST_TYPE, TEST_PSSWD);\n         Enumeration<LedgerEntry> entries = lhs.readEntries(startEntryId,\n                 endEntryId);\n         assertTrue(\"Should have the elements\", entries.hasMoreElements());"},{"sha":"66cf3ad03d2739544eea1f29aae65a1b9ced839d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2487b794ef8d93a1d1380a62ffa212381930393/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=e2487b794ef8d93a1d1380a62ffa212381930393","patch":"@@ -69,6 +69,7 @@ public TestReplicationWorker(String ledgerManagerFactory) {\n         basePath = baseClientConf.getZkLedgersRootPath() + '/'\n                 + ZkLedgerUnderreplicationManager.UNDER_REPLICATION_NODE\n                 + \"/ledgers\";\n+        baseConf.setRereplicationEntryBatchSize(3);\n     }\n \n     @Override"}]}

