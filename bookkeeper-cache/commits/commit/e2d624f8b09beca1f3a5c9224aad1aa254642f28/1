{"sha":"e2d624f8b09beca1f3a5c9224aad1aa254642f28","node_id":"MDY6Q29tbWl0MTU3NTk1NjplMmQ2MjRmOGIwOWJlY2ExZjNhNWM5MjI0YWFkMWFhMjU0NjQyZjI4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-26T17:47:54Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-26T17:47:54Z"},"message":"BOOKKEEPER-440: Make Write/Delete SubscriptionData Restricted to Version (Fangmin Lv via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1413745 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a031dcdf92840bd13137ad7c5bebc195bf3ff8ee","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a031dcdf92840bd13137ad7c5bebc195bf3ff8ee"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e2d624f8b09beca1f3a5c9224aad1aa254642f28","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e2d624f8b09beca1f3a5c9224aad1aa254642f28","html_url":"https://github.com/apache/bookkeeper/commit/e2d624f8b09beca1f3a5c9224aad1aa254642f28","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e2d624f8b09beca1f3a5c9224aad1aa254642f28/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"967149c238389e96b760dbda4d4f722aee46b0b5","url":"https://api.github.com/repos/apache/bookkeeper/commits/967149c238389e96b760dbda4d4f722aee46b0b5","html_url":"https://github.com/apache/bookkeeper/commit/967149c238389e96b760dbda4d4f722aee46b0b5"}],"stats":{"total":427,"additions":324,"deletions":103},"files":[{"sha":"1cc0056983ccbd736ee99af34899e17b1bfe6b55","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -146,6 +146,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-439: No more messages delivered after deleted consumed ledgers. (sijie via ivank)\n \n+        BOOKKEEPER-440: Make Write/Delete SubscriptionData Restricted to Version (Fangmin Lv via ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-467: Allocate ports for testing dynamically (ivank)"},{"sha":"029c62157ebce02217cebaca0534f8791cf9e645","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"modified","additions":18,"deletions":6,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -24,6 +24,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n@@ -44,6 +45,7 @@\n import org.apache.hedwig.server.meta.SubscriptionDataManager;\n import org.apache.hedwig.server.meta.TopicOwnershipManager;\n import org.apache.hedwig.server.meta.TopicPersistenceManager;\n+import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n import org.apache.hedwig.server.topics.HubInfo;\n import org.apache.hedwig.server.topics.HubLoad;\n import org.apache.hedwig.util.Callback;\n@@ -457,10 +459,16 @@ public void operationFailed(Object ctx, PubSubException pse) {\n \n         final SyncObj<Map<ByteString, SubscriptionData>> syncObj =\n             new SyncObj<Map<ByteString, SubscriptionData>>();\n-        sdm.readSubscriptions(topic, new Callback<Map<ByteString, SubscriptionData>>() {\n+        sdm.readSubscriptions(topic, new Callback<Map<ByteString, Versioned<SubscriptionData>>>() {\n             @Override\n-            public void operationFinished(Object ctx, Map<ByteString, SubscriptionData> result) {\n-                syncObj.success(result);\n+            public void operationFinished(Object ctx, Map<ByteString, Versioned<SubscriptionData>> result) {\n+                // It was just used to console tool to print some information, so don't need to return version for it\n+                // just keep the getTopicSubscriptions interface as before\n+                Map<ByteString, SubscriptionData> subs = new ConcurrentHashMap<ByteString, SubscriptionData>();\n+                for (Map.Entry<ByteString, Versioned<SubscriptionData>> subEntry : result.entrySet()) {\n+                    subs.put(subEntry.getKey(), subEntry.getValue().getValue());\n+                }\n+                syncObj.success(subs);\n             }\n             @Override\n             public void operationFailed(Object ctx, PubSubException pse) {\n@@ -489,10 +497,14 @@ public void operationFailed(Object ctx, PubSubException pse) {\n      */\n     public SubscriptionData getSubscription(ByteString topic, ByteString subscriber) throws Exception {\n         final SyncObj<SubscriptionData> syncObj = new SyncObj<SubscriptionData>();\n-        sdm.readSubscriptionData(topic, subscriber, new Callback<SubscriptionData>() {\n+        sdm.readSubscriptionData(topic, subscriber, new Callback<Versioned<SubscriptionData>>() {\n             @Override\n-            public void operationFinished(Object ctx, SubscriptionData result) {\n-                syncObj.success(result);\n+            public void operationFinished(Object ctx, Versioned<SubscriptionData> result) {\n+                if (null == result) {\n+                    syncObj.success(null);\n+                } else {\n+                    syncObj.success(result.getValue());\n+                }\n             }\n             @Override\n             public void operationFailed(Object ctx, PubSubException pse) {"},{"sha":"133356009cc9914e2867b342fa1a130e84546073","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","status":"modified","additions":25,"deletions":12,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/SubscriptionDataManager.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -22,6 +22,8 @@\n \n import com.google.protobuf.ByteString;\n \n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.subscriptions.InMemorySubscriptionState;\n@@ -42,14 +44,14 @@\n      * @param data \n      *          Subscription data\n      * @param callback\n-     *          Callback when subscription state created.\n+     *          Callback when subscription state created. New version would be returned.\n      *          {@link PubSubException.SubscriptionStateExistsException} is returned when subscription state\n      *          existed before.\n      * @param ctx\n      *          Context of the callback\n      */\n     public void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-                                       Callback<Void> callback, Object ctx);\n+                                       Callback<Version> callback, Object ctx);\n \n     /**\n      * Whether the metadata manager supports partial update.\n@@ -71,15 +73,18 @@ public void createSubscriptionData(ByteString topic, ByteString subscriberId, Su\n      *          the part of data to update. The implementation should not replace\n      *          existing subscription data with <i>dataToUpdate</i> directly.\n      *          E.g. if there is only state in it, you should update state only.\n+     * @param version\n+     *          Current version of subscription data.\n      * @param callback\n-     *          Callback when subscription state updated.\n+     *          Callback when subscription state updated. New version would be returned.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n      *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n      *          is found.\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToUpdate,\n-                                       Callback<Void> callback, Object ctx);\n+    public void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToUpdate, \n+                                       Version version, Callback<Version> callback, Object ctx);\n \n     /**\n      * Replace subscription data.\n@@ -90,13 +95,18 @@ public void updateSubscriptionData(ByteString topic, ByteString subscriberId, Su\n      *          Subscriber id\n      * @param dataToReplace\n      *          Subscription data to replace.\n+     * @param version\n+     *          Current version of subscription data.\n      * @param callback\n-     *          Callback when subscription state updated.\n+     *          Callback when subscription state updated. New version would be returned.\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n+     *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n+     *          is found.\n      * @param ctx\n      *          Context of the callback\n      */\n     public void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData dataToReplace,\n-                                        Callback<Void> callback, Object ctx);\n+                                        Version version, Callback<Version> callback, Object ctx);\n \n     /**\n      * Remove subscription data.\n@@ -105,18 +115,21 @@ public void replaceSubscriptionData(ByteString topic, ByteString subscriberId, S\n      *          Topic name\n      * @param subscriberId\n      *          Subscriber id\n+     * @param version\n+     *          Current version of subscription data.\n      * @param callback\n      *          Callback when subscription state deleted\n+     *          {@link PubSubException.BadVersionException} is returned when version doesn't match,\n      *          {@link PubSubException.NoSubscriptionStateException} is returned when no subscription state\n      *          is found.\n      * @param ctx\n      *          Context of the callback\n      */\n-    public void deleteSubscriptionData(ByteString topic, ByteString subscriberId,\n+    public void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version,\n                                        Callback<Void> callback, Object ctx);\n \n     /**\n-     * Read subscription data.\n+     * Read subscription data with version.\n      *\n      * @param topic\n      *          Topic Name\n@@ -129,18 +142,18 @@ public void deleteSubscriptionData(ByteString topic, ByteString subscriberId,\n      *          Context of the callback\n      */\n     public void readSubscriptionData(ByteString topic, ByteString subscriberId,\n-                                     Callback<SubscriptionData> callback, Object ctx);\n+                                     Callback<Versioned<SubscriptionData>> callback, Object ctx);\n \n     /**\n      * Read all subscriptions of a topic.\n      *\n      * @param topic\n      *          Topic name\n      * @param callback\n-     *          Callback to return subscriptions\n+     *          Callback to return subscriptions with version information\n      * @param ctx\n      *          Contxt of the callback\n      */\n-    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, SubscriptionData>> cb,\n+    public void readSubscriptions(ByteString topic, Callback<Map<ByteString, Versioned<SubscriptionData>>> cb,\n                                   Object ctx);\n }"},{"sha":"ccbaf5082548069977c64637ce45ad3c0380455a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","status":"modified","additions":69,"deletions":19,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/meta/ZkMetadataManagerFactory.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -37,6 +37,7 @@\n import com.google.protobuf.InvalidProtocolBufferException;\n import org.apache.bookkeeper.versioning.Version;\n import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n@@ -383,7 +384,7 @@ public boolean isPartialUpdateSupported() {\n \n         @Override\n         public void createSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n-                                           final Callback<Void> callback, final Object ctx) {\n+                                           final Callback<Version> callback, final Object ctx) {\n             ZkUtils.createFullPathOptimistic(zk, topicSubscriberPath(topic, subscriberId), data.toByteArray(),\n             Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new SafeAsyncZKCallback.StringCallback() {\n \n@@ -401,7 +402,7 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n                                          + \" subscriberId: \" + subscriberId.toStringUtf8() + \" data: \"\n                                          + SubscriptionStateUtils.toString(data));\n                         }\n-                        callback.operationFinished(ctx, null);\n+                        callback.operationFinished(ctx, new ZkVersion(0));\n                     } else {\n                         KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n                                                  \"Could not record new subscription for topic: \" + topic.toStringUtf8()\n@@ -414,15 +415,30 @@ public void safeProcessResult(int rc, String path, Object ctx, String name) {\n \n         @Override\n         public void updateSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n-                                           final Callback<Void> callback, final Object ctx) {\n+                                           final Version version, final Callback<Version> callback, final Object ctx) {\n             throw new UnsupportedOperationException(\"ZooKeeper based metadata manager doesn't support partial update!\");\n         }\n \n         @Override\n         public void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData data,\n-                                            final Callback<Void> callback, final Object ctx) {\n-            zk.setData(topicSubscriberPath(topic, subscriberId), data.toByteArray(), -1,\n-            new SafeAsyncZKCallback.StatCallback() {\n+                                            final Version version, final Callback<Version> callback, final Object ctx) {\n+            int znodeVersion = -1;\n+            if (Version.NEW == version) {\n+                callback.operationFailed(ctx, \n+                        new PubSubException.BadVersionException(\"Can not replace Version.New subscription data\"));\n+                return;\n+            } else if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to replace subscription data for topic  \" \n+                                                  + topic.toStringUtf8() + \" subscribe id: \" + subscriberId));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            zk.setData(topicSubscriberPath(topic, subscriberId), data.toByteArray(), \n+                    znodeVersion, new SafeAsyncZKCallback.StatCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                     if (rc == Code.NONODE.intValue()) {\n@@ -431,6 +447,12 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                                                       \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n                                                       + subscriberId.toStringUtf8() + \").\"));\n                         return;\n+                    } else if (rc == Code.BadVersion) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to replace subscription data of topic \" \n+                                                      + topic.toStringUtf8() + \" subscriberId \" + subscriberId));\n+                        return;\n                     } else if (rc != Code.OK.intValue()) {\n                         KeeperException e = ZkUtils.logErrorAndCreateZKException(\"Topic: \" + topic.toStringUtf8()\n                                             + \" subscriberId: \" + subscriberId.toStringUtf8()\n@@ -444,16 +466,33 @@ public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                                          + SubscriptionStateUtils.toString(data));\n                         }\n \n-                        callback.operationFinished(ctx, null);\n+                        callback.operationFinished(ctx, new ZkVersion(stat.getVersion()));\n                     }\n                 }\n             }, ctx);\n         }\n \n         @Override\n-        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+        public void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId, Version version,\n                                            final Callback<Void> callback, Object ctx) {\n-            zk.delete(topicSubscriberPath(topic, subscriberId), -1, new SafeAsyncZKCallback.VoidCallback() {\n+            \n+            int znodeVersion = -1;\n+            if (Version.NEW == version) {\n+                callback.operationFailed(ctx, \n+                        new PubSubException.BadVersionException(\"Can not delete Version.New subscription data\"));\n+                return;\n+            } else if (Version.ANY != version) {\n+                if (!(version instanceof ZkVersion)) {\n+                    callback.operationFailed(ctx, new PubSubException.UnexpectedConditionException(\n+                                                  \"Invalid version provided to delete subscription data for topic  \" \n+                                                  + topic.toStringUtf8() + \" subscribe id: \" + subscriberId));\n+                    return;\n+                } else {\n+                    znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+                }\n+            }\n+            \n+            zk.delete(topicSubscriberPath(topic, subscriberId), znodeVersion, new SafeAsyncZKCallback.VoidCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx) {\n                     if (rc == Code.NONODE.intValue()) {\n@@ -462,6 +501,12 @@ public void safeProcessResult(int rc, String path, Object ctx) {\n                                                       \"No subscription state found for (topic:\" + topic.toStringUtf8() + \", subscriber:\"\n                                                       + subscriberId.toStringUtf8() + \").\"));\n                         return;\n+                    } else if (rc == Code.BadVersion) {\n+                        // bad version\n+                        callback.operationFailed(ctx, PubSubException.create(StatusCode.BAD_VERSION,\n+                                                      \"Bad version provided to delete subscription data of topic \" \n+                                                      + topic.toStringUtf8() + \" subscriberId \" + subscriberId));\n+                        return;\n                     } else if (rc == Code.OK.intValue()) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Successfully deleted subscription for topic: \" + topic.toStringUtf8()\n@@ -481,7 +526,7 @@ public void safeProcessResult(int rc, String path, Object ctx) {\n \n         @Override\n         public void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n-                                         final Callback<SubscriptionData> callback, final Object ctx) {\n+                                         final Callback<Versioned<SubscriptionData>> callback, final Object ctx) {\n             zk.getData(topicSubscriberPath(topic, subscriberId), false, new SafeAsyncZKCallback.DataCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n@@ -496,10 +541,12 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                         callback.operationFailed(ctx, new PubSubException.ServiceDownException(e));\n                         return;\n                     }\n-\n-                    SubscriptionData subData;\n+                    \n+                    Versioned<SubscriptionData> subData;\n                     try {\n-                        subData = SubscriptionStateUtils.parseSubscriptionData(data);\n+                        subData = new Versioned<SubscriptionData>(\n+                                        SubscriptionStateUtils.parseSubscriptionData(data), \n+                                        new ZkVersion(stat.getVersion()));\n                     } catch (InvalidProtocolBufferException ex) {\n                         String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n                                      + \" subscriberId: \" + subscriberId.toStringUtf8();\n@@ -511,7 +558,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n                                      + \" subscriberId: \" + subscriberId.toStringUtf8()\n-                                     + \" data: \" + SubscriptionStateUtils.toString(subData));\n+                                     + \" data: \" + SubscriptionStateUtils.toString(subData.getValue()));\n                     }\n                     callback.operationFinished(ctx, subData);\n                 }\n@@ -520,7 +567,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n \n         @Override\n         public void readSubscriptions(final ByteString topic,\n-                                      final Callback<Map<ByteString, SubscriptionData>> cb, final Object ctx) {\n+                                      final Callback<Map<ByteString, Versioned<SubscriptionData>>> cb, final Object ctx) {\n             String topicSubscribersPath = topicSubscribersPath(new StringBuilder(), topic).toString();\n             zk.getChildren(topicSubscribersPath, false, new SafeAsyncZKCallback.ChildrenCallback() {\n                 @Override\n@@ -533,7 +580,8 @@ public void safeProcessResult(int rc, String path, final Object ctx, final List<\n                         return;\n                     }\n \n-                    final Map<ByteString, SubscriptionData> topicSubs = new ConcurrentHashMap<ByteString, SubscriptionData>();\n+                    final Map<ByteString, Versioned<SubscriptionData>> topicSubs = \n+                            new ConcurrentHashMap<ByteString, Versioned<SubscriptionData>>();\n \n                     if (rc == Code.NONODE.intValue() || children.size() == 0) {\n                         if (logger.isDebugEnabled()) {\n@@ -567,9 +615,11 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                                     return;\n                                 }\n \n-                                SubscriptionData subData;\n+                                Versioned<SubscriptionData> subData;\n                                 try {\n-                                    subData = SubscriptionStateUtils.parseSubscriptionData(data);\n+                                    subData = new Versioned<SubscriptionData>(\n+                                            SubscriptionStateUtils.parseSubscriptionData(data), \n+                                            new ZkVersion(stat.getVersion()));\n                                 } catch (InvalidProtocolBufferException ex) {\n                                     String msg = \"Failed to deserialize subscription data for topic: \" + topic.toStringUtf8()\n                                                  + \" subscriberId: \" + subscriberId.toStringUtf8();\n@@ -581,7 +631,7 @@ public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat\n                                 if (logger.isDebugEnabled()) {\n                                     logger.debug(\"Found subscription while acquiring topic: \" + topic.toStringUtf8()\n                                                  + \" subscriberId: \" + child + \"state: \"\n-                                                 + SubscriptionStateUtils.toString(subData));\n+                                                 + SubscriptionStateUtils.toString(subData.getValue()));\n                                 }\n \n                                 topicSubs.put(subscriberId, subData);"},{"sha":"31bf5056e1861b6e561829606682859d56548071","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":86,"deletions":22,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -31,6 +31,10 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n@@ -323,7 +327,10 @@ private void notifyLastLocalUnsubscribe(ByteString topic) {\n \n     protected abstract void readSubscriptions(final ByteString topic,\n             final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx);\n-\n+    \n+    protected abstract void readSubscriptionData(final ByteString topic, final ByteString subscriberId, \n+            final Callback<InMemorySubscriptionState> cb, Object ctx);\n+    \n     private class SubscribeOp extends TopicOpQueuer.AsynchronousOp<SubscriptionData> {\n         SubscribeRequest subRequest;\n         MessageSeqId consumeSeqId;\n@@ -428,21 +435,21 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                 SubscriptionData.newBuilder().setState(stateBuilder).setPreferences(preferencesBuilder);\n             final SubscriptionData subData = subDataBuilder.build();\n \n-            createSubscriptionData(topic, subscriberId, subData, new Callback<Void>() {\n+            createSubscriptionData(topic, subscriberId, subData, new Callback<Version>() {\n                 @Override\n                 public void operationFailed(Object ctx, PubSubException exception) {\n                     cb.operationFailed(ctx, exception);\n                 }\n \n                 @Override\n-                public void operationFinished(Object ctx, Void resultOfOperation) {\n+                public void operationFinished(Object ctx, final Version version) {\n                     Callback<Void> cb2 = new Callback<Void>() {\n                         @Override\n                         public void operationFailed(final Object ctx, final PubSubException exception) {\n                             logger.error(\"subscription for subscriber \" + subscriberId.toStringUtf8() + \" to topic \"\n                                          + topic.toStringUtf8() + \" failed due to failed listener callback\", exception);\n                             // should remove subscription when synchronized cross-region subscription failed\n-                            deleteSubscriptionData(topic, subscriberId, new Callback<Void>() {\n+                            deleteSubscriptionData(topic, subscriberId, version, new Callback<Void>() {\n                                 @Override\n                                 public void operationFinished(Object context,\n                                         Void resultOfOperation) {\n@@ -463,7 +470,7 @@ private void finish() {\n \n                         @Override\n                         public void operationFinished(Object ctx, Void resultOfOperation) {\n-                            topicSubscriptions.put(subscriberId, new InMemorySubscriptionState(subData));\n+                            topicSubscriptions.put(subscriberId, new InMemorySubscriptionState(subData, version));\n \n                             updateMessageBound(topic);\n \n@@ -477,7 +484,7 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                         && !hasLocalSubscriptions(topicSubscriptions))\n                         notifyFirstLocalSubscribe(topic, subRequest.getSynchronous(), cb2, ctx);\n                     else\n-                        cb2.operationFinished(ctx, resultOfOperation);\n+                        cb2.operationFinished(ctx, null);\n                 }\n             }, ctx);\n         }\n@@ -613,8 +620,9 @@ public void run() {\n                 cb.operationFailed(ctx, new PubSubException.ClientNotSubscribedException(\"\"));\n                 return;\n             }\n-\n-            deleteSubscriptionData(topic, subscriberId, new Callback<Void>() {\n+            \n+            deleteSubscriptionData(topic, subscriberId, topicSubscriptions.get(subscriberId).getVersion(),\n+                    new Callback<Void>() {\n                 @Override\n                 public void operationFailed(Object ctx, PubSubException exception) {\n                     cb.operationFailed(ctx, exception);\n@@ -679,44 +687,100 @@ public void operationFailed(Object ctx,\n         }\n     }\n \n-    private void updateSubscriptionState(ByteString topic, ByteString subscriberId,\n-                                         InMemorySubscriptionState state,\n-                                         Callback<Void> callback, Object ctx) {\n+    private void updateSubscriptionState(final ByteString topic, final ByteString subscriberId,\n+                                         final InMemorySubscriptionState state,\n+                                         final Callback<Void> callback, Object ctx) {\n         SubscriptionData subData;\n+        Callback<Version> cb = new Callback<Version>() {\n+            @Override\n+            public void operationFinished(Object ctx, Version version) {\n+                state.setVersion(version);\n+                callback.operationFinished(ctx, null);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                if (exception instanceof PubSubException.BadVersionException) {\n+                    readSubscriptionData(topic, subscriberId, new Callback<InMemorySubscriptionState>() {\n+                        @Override\n+                        public void operationFinished(Object ctx,\n+                                InMemorySubscriptionState resultOfOperation) {\n+                            state.setVersion(resultOfOperation.getVersion());\n+                            updateSubscriptionState(topic, subscriberId, state, callback, ctx);\n+                        }\n+                        @Override\n+                        public void operationFailed(Object ctx,\n+                                PubSubException exception) {\n+                            callback.operationFailed(ctx, exception);\n+                        }\n+                    }, ctx);\n+                    \n+                    return;\n+                } \n+                callback.operationFailed(ctx, exception);\n+            }\n+        };\n         if (isPartialUpdateSupported()) {\n             subData = SubscriptionData.newBuilder().setState(state.getSubscriptionState()).build();\n-            updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+            updateSubscriptionData(topic, subscriberId, subData, state.getVersion(), cb, ctx);\n         } else {\n             subData = state.toSubscriptionData();\n-            replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+            replaceSubscriptionData(topic, subscriberId, subData, state.getVersion(), cb, ctx);\n         }\n     }\n \n-    private void updateSubscriptionPreferences(ByteString topic, ByteString subscriberId,\n-                                               InMemorySubscriptionState state,\n-                                               Callback<Void> callback, Object ctx) {\n+    private void updateSubscriptionPreferences(final ByteString topic, final ByteString subscriberId,\n+                                               final InMemorySubscriptionState state,\n+                                               final Callback<Void> callback, Object ctx) {\n         SubscriptionData subData;\n+        Callback<Version> cb = new Callback<Version>() {\n+            @Override\n+            public void operationFinished(Object ctx, Version version) {\n+                state.setVersion(version);\n+                callback.operationFinished(ctx, null);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                if (exception instanceof PubSubException.BadVersionException) {\n+                    readSubscriptionData(topic, subscriberId, new Callback<InMemorySubscriptionState>() {\n+                        @Override\n+                        public void operationFinished(Object ctx,\n+                                InMemorySubscriptionState resultOfOperation) {\n+                            state.setVersion(resultOfOperation.getVersion());\n+                            updateSubscriptionPreferences(topic, subscriberId, state, callback, ctx);\n+                        }\n+                        @Override\n+                        public void operationFailed(Object ctx,\n+                                PubSubException exception) {\n+                            callback.operationFailed(ctx, exception);\n+                        }\n+                    }, ctx);\n+                    \n+                    return;\n+                } \n+                callback.operationFailed(ctx, exception);\n+            }\n+        };\n         if (isPartialUpdateSupported()) {\n             subData = SubscriptionData.newBuilder().setPreferences(state.getSubscriptionPreferences()).build();\n-            updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+            updateSubscriptionData(topic, subscriberId, subData, state.getVersion(), cb, ctx);\n         } else {\n             subData = state.toSubscriptionData();\n-            replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+            replaceSubscriptionData(topic, subscriberId, subData, state.getVersion(), cb, ctx);\n         }\n     }\n \n     protected abstract boolean isPartialUpdateSupported();\n \n     protected abstract void createSubscriptionData(final ByteString topic, ByteString subscriberId,\n-            SubscriptionData data, Callback<Void> callback, Object ctx);\n+            SubscriptionData data, Callback<Version> callback, Object ctx);\n \n     protected abstract void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-            Callback<Void> callback, Object ctx);\n+            Version version, Callback<Version> callback, Object ctx);\n \n     protected abstract void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-            Callback<Void> callback, Object ctx);\n+            Version version, Callback<Version> callback, Object ctx);\n \n-    protected abstract void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n+    protected abstract void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version, Callback<Void> callback,\n             Object ctx);\n \n }"},{"sha":"1e0d205bc8031c71eed8db73fff63decceb4e01d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","status":"modified","additions":20,"deletions":4,"changes":24,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionManager.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -22,6 +22,8 @@\n import java.util.concurrent.ScheduledExecutorService;\n \n import com.google.protobuf.ByteString;\n+\n+import org.apache.bookkeeper.versioning.Version;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.delivery.DeliveryManager;\n@@ -43,13 +45,13 @@ public InMemorySubscriptionManager(ServerConfiguration conf,\n \n     @Override\n     protected void createSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData subData,\n-                                           Callback<Void> callback, Object ctx) {\n+                                           Callback<Version> callback, Object ctx) {\n         // nothing to do, in-memory info is already recorded by base class\n         callback.operationFinished(ctx, null);\n     }\n \n     @Override\n-    protected void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Callback<Void> callback,\n+    protected void deleteSubscriptionData(ByteString topic, ByteString subscriberId, Version version, Callback<Void> callback,\n                                           Object ctx) {\n         // nothing to do, in-memory info is already deleted by base class\n         callback.operationFinished(ctx, null);\n@@ -62,13 +64,13 @@ protected boolean isPartialUpdateSupported() {\n \n     @Override\n     protected void updateSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-                                          Callback<Void> callback, Object ctx) {\n+                                          Version version, Callback<Version> callback, Object ctx) {\n         throw new UnsupportedOperationException(\"Doesn't support partial update\");\n     }\n \n     @Override\n     protected void replaceSubscriptionData(ByteString topic, ByteString subscriberId, SubscriptionData data,\n-                                           Callback<Void> callback, Object ctx) {\n+                                           Version version, Callback<Version> callback, Object ctx) {\n         // nothing to do, in-memory info is already updated by base class\n         callback.operationFinished(ctx, null);\n     }\n@@ -100,4 +102,18 @@ protected void readSubscriptions(ByteString topic,\n \n     }\n \n+    @Override\n+    protected void readSubscriptionData(ByteString topic,\n+            ByteString subscriberId, Callback<InMemorySubscriptionState> cb, Object ctx) {\n+        // Since we backed up in-memory information on lostTopic, we can just return that back\n+        InMemorySubscriptionState subState = top2sub2seqBackup.get(topic).remove(subscriberId);\n+        \n+        if (subState != null) {\n+            cb.operationFinished(ctx, subState);\n+        } else {\n+            cb.operationFinished(ctx, new InMemorySubscriptionState(\n+                    SubscriptionData.getDefaultInstance(), Version.NEW));\n+        }\n+    }\n+\n }"},{"sha":"08994f0e3f178a1216831f074cefbcb24a4edd37","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"modified","additions":14,"deletions":3,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -22,6 +22,7 @@\n \n import com.google.protobuf.ByteString;\n \n+import org.apache.bookkeeper.versioning.Version;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n@@ -33,8 +34,9 @@\n     SubscriptionState subscriptionState;\n     SubscriptionPreferences subscriptionPreferences;\n     MessageSeqId lastConsumeSeqId;\n+\tVersion version;\n \n-    public InMemorySubscriptionState(SubscriptionData subscriptionData, MessageSeqId lastConsumeSeqId) {\n+    public InMemorySubscriptionState(SubscriptionData subscriptionData, Version version, MessageSeqId lastConsumeSeqId) {\n         this.subscriptionState = subscriptionData.getState();\n         if (subscriptionData.hasPreferences()) {\n             this.subscriptionPreferences = subscriptionData.getPreferences();\n@@ -47,10 +49,11 @@ public InMemorySubscriptionState(SubscriptionData subscriptionData, MessageSeqId\n \n         }\n         this.lastConsumeSeqId = lastConsumeSeqId;\n+        this.version = version;\n     }\n \n-    public InMemorySubscriptionState(SubscriptionData subscriptionData) {\n-        this(subscriptionData, subscriptionData.getState().getMsgId());\n+    public InMemorySubscriptionState(SubscriptionData subscriptionData, Version version) {\n+        this(subscriptionData, version, subscriptionData.getState().getMsgId());\n     }\n \n     public SubscriptionData toSubscriptionData() {\n@@ -72,6 +75,14 @@ public SubscriptionPreferences getSubscriptionPreferences() {\n     public MessageSeqId getLastConsumeSeqId() {\n         return lastConsumeSeqId;\n     }\n+     \n+    public Version getVersion() {\n+        return version;\n+    }\n+    \n+    public void setVersion(Version version) {\n+        this.version = version;\n+    }\n \n     /**\n      *"},{"sha":"126155845e250879cae1657dce291d4d5c4860e1","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","status":"modified","additions":38,"deletions":13,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/MMSubscriptionManager.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -32,6 +32,8 @@\n import org.apache.hedwig.server.persistence.PersistenceManager;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.util.Callback;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n \n /**\n  * MetaManager-based subscription manager.\n@@ -52,49 +54,72 @@ public MMSubscriptionManager(ServerConfiguration cfg,\n     @Override\n     protected void readSubscriptions(final ByteString topic,\n                                      final Callback<Map<ByteString, InMemorySubscriptionState>> cb, final Object ctx) {\n-        subManager.readSubscriptions(topic, new Callback<Map<ByteString, SubscriptionData>>() {\n+        subManager.readSubscriptions(topic, new Callback<Map<ByteString, Versioned<SubscriptionData>>>() {\n             @Override\n             public void operationFailed(Object ctx, PubSubException pse) {\n                 cb.operationFailed(ctx, pse);\n             }\n             @Override\n-            public void operationFinished(Object ctx, Map<ByteString, SubscriptionData> subs) {\n+            public void operationFinished(Object ctx, Map<ByteString, Versioned<SubscriptionData>> subs) {\n                 Map<ByteString, InMemorySubscriptionState> results = new ConcurrentHashMap<ByteString, InMemorySubscriptionState>();\n-                for (Map.Entry<ByteString, SubscriptionData> subEntry : subs.entrySet()) {\n-                    results.put(subEntry.getKey(), new InMemorySubscriptionState(subEntry.getValue()));\n+                for (Map.Entry<ByteString, Versioned<SubscriptionData>> subEntry : subs.entrySet()) {\n+                    Versioned<SubscriptionData> vv = subEntry.getValue();\n+                    results.put(subEntry.getKey(), new InMemorySubscriptionState(vv.getValue(), vv.getVersion()));\n                 }\n                 cb.operationFinished(ctx, results);\n             }\n         }, ctx);\n     }\n \n+    @Override\n+    protected void readSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+                                        final Callback<InMemorySubscriptionState> cb, final Object ctx) {\n+        subManager.readSubscriptionData(topic, subscriberId, new Callback<Versioned<SubscriptionData>>() {\n+            @Override\n+            public void operationFinished(Object ctx,\n+                    Versioned<SubscriptionData> subData) {\n+                if (null != subData) {\n+                    cb.operationFinished(ctx, \n+                            new InMemorySubscriptionState(subData.getValue(), subData.getVersion()));\n+                } else {\n+                    cb.operationFinished(ctx, new InMemorySubscriptionState(\n+                            SubscriptionData.getDefaultInstance(), Version.NEW));\n+                }\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                cb.operationFailed(ctx, exception);\n+            }\n+        }, ctx);\n+    }\n+\n     @Override\n     protected boolean isPartialUpdateSupported() {\n         return subManager.isPartialUpdateSupported();\n     }\n \n     @Override\n     protected void createSubscriptionData(final ByteString topic, final ByteString subscriberId,\n-                                          final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n+                                          final SubscriptionData subData, final Callback<Version> callback, final Object ctx) {\n         subManager.createSubscriptionData(topic, subscriberId, subData, callback, ctx);\n     }\n \n     @Override\n-    protected void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId,\n-                                           final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n-        subManager.replaceSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+    protected void replaceSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData subData, \n+                                           final Version version, final Callback<Version> callback, final Object ctx) {\n+        subManager.replaceSubscriptionData(topic, subscriberId, subData, version, callback, ctx);\n     }\n \n     @Override\n-    protected void updateSubscriptionData(final ByteString topic, final ByteString subscriberId,\n-                                          final SubscriptionData subData, final Callback<Void> callback, final Object ctx) {\n-        subManager.updateSubscriptionData(topic, subscriberId, subData, callback, ctx);\n+    protected void updateSubscriptionData(final ByteString topic, final ByteString subscriberId, final SubscriptionData subData, \n+                                          final Version version, final Callback<Version> callback, final Object ctx) {\n+        subManager.updateSubscriptionData(topic, subscriberId, subData, version, callback, ctx);\n     }\n \n     @Override\n-    protected void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId,\n+    protected void deleteSubscriptionData(final ByteString topic, final ByteString subscriberId, Version version,\n                                           final Callback<Void> callback, final Object ctx) {\n-        subManager.deleteSubscriptionData(topic, subscriberId, callback, ctx);\n+        subManager.deleteSubscriptionData(topic, subscriberId, version, callback, ctx);\n     }\n \n     @Override"},{"sha":"892ceca8c5e7b375e9cccc9c03d79af861964cb2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","status":"modified","additions":52,"deletions":24,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e2d624f8b09beca1f3a5c9224aad1aa254642f28/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/meta/TestMetadataManager.java?ref=e2d624f8b09beca1f3a5c9224aad1aa254642f28","patch":"@@ -21,7 +21,6 @@\n package org.apache.hedwig.server.meta;\n \n import java.util.Map;\n-import java.util.concurrent.SynchronousQueue;\n \n import com.google.protobuf.ByteString;\n \n@@ -35,7 +34,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState;\n import org.apache.hedwig.server.topics.HubInfo;\n-import org.apache.hedwig.server.meta.MetadataManagerFactory;\n+import org.apache.hedwig.util.Callback;\n import org.apache.hedwig.util.Either;\n import org.apache.hedwig.util.HedwigSocketAddress;\n \n@@ -234,35 +233,46 @@ public void testSubscriptionData() throws Exception {\n         ByteString topic = ByteString.copyFromUtf8(\"testSubscriptionData\");\n         ByteString subid = ByteString.copyFromUtf8(\"mysub\");\n \n-        StubCallback<Void> callback = new StubCallback<Void>();\n-        StubCallback<SubscriptionData> readCallback = new StubCallback<SubscriptionData>();\n-        StubCallback<Map<ByteString, SubscriptionData>> subsCallback\n-            = new StubCallback<Map<ByteString, SubscriptionData>>();\n+        final StubCallback<Version> callback = new StubCallback<Version>();\n+        StubCallback<Versioned<SubscriptionData>> readCallback = new StubCallback<Versioned<SubscriptionData>>();\n+        StubCallback<Map<ByteString, Versioned<SubscriptionData>>> subsCallback\n+            = new StubCallback<Map<ByteString, Versioned<SubscriptionData>>>();\n \n         subManager.readSubscriptionData(topic, subid, readCallback, null);\n-        Either<SubscriptionData, PubSubException> readRes = readCallback.queue.take();\n+        Either<Versioned<SubscriptionData>, PubSubException> readRes = readCallback.queue.take();\n         Assert.assertEquals(\"Found inconsistent subscription state\", null, readRes.left());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, readRes.right());\n \n         // read non-existed subscription state\n         subManager.readSubscriptions(topic, subsCallback, null);\n-        Either<Map<ByteString, SubscriptionData>, PubSubException> res = subsCallback.queue.take();\n+        Either<Map<ByteString, Versioned<SubscriptionData>>, PubSubException> res = subsCallback.queue.take();\n         Assert.assertEquals(\"Found more than 0 subscribers\", 0, res.left().size());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n \n         // update non-existed subscription state\n         if (subManager.isPartialUpdateSupported()) {\n-            subManager.updateSubscriptionData(topic, subid, SubscriptionData.getDefaultInstance(),\n-                                              callback, null);\n+            subManager.updateSubscriptionData(topic, subid, \n+                    SubscriptionData.getDefaultInstance(), Version.ANY, callback, null);\n         } else {\n-            subManager.replaceSubscriptionData(topic, subid, SubscriptionData.getDefaultInstance(),\n-                                               callback, null);\n+            subManager.replaceSubscriptionData(topic, subid, \n+                    SubscriptionData.getDefaultInstance(), Version.ANY, callback, null);\n         }\n         Assert.assertTrue(\"Should fail to update a non-existed subscriber with PubSubException\",\n                           callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n \n+        Callback<Void> voidCallback = new Callback<Void>() {\n+            @Override\n+            public void operationFinished(Object ctx, Void resultOfOperation) {\n+                callback.operationFinished(ctx, null);\n+            }\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                callback.operationFailed(ctx, exception);\n+            }\n+        }; \n+        \n         // delete non-existed subscription state\n-        subManager.deleteSubscriptionData(topic, subid, callback, null);\n+        subManager.deleteSubscriptionData(topic, subid, Version.ANY, voidCallback, null);\n         Assert.assertTrue(\"Should fail to delete a non-existed subscriber with PubSubException\",\n                           callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);\n \n@@ -276,15 +286,19 @@ public void testSubscriptionData() throws Exception {\n \n         // create a subscription state\n         subManager.createSubscriptionData(topic, subid, data, callback, null);\n+        Either<Version, PubSubException> cbResult = callback.queue.take();\n+        Version v1 = cbResult.left();\n         Assert.assertEquals(\"Should not fail with PubSubException\",\n-                            null, callback.queue.take().right());\n+                            null, cbResult.right());\n \n         // read subscriptions\n         subManager.readSubscriptions(topic, subsCallback, null);\n         res = subsCallback.queue.take();\n         Assert.assertEquals(\"Should find just 1 subscriber\", 1, res.left().size());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n-        SubscriptionData imss = res.left().get(subid);\n+        Versioned<SubscriptionData> versionedSubData = res.left().get(subid);\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v1.compare(versionedSubData.getVersion()));\n+        SubscriptionData imss = versionedSubData.getValue();\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n                             data, imss);\n         Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n@@ -298,32 +312,46 @@ public void testSubscriptionData() throws Exception {\n \n         stateBuilder = SubscriptionState.newBuilder(data.getState()).setMsgId(msgId);\n         data = SubscriptionData.newBuilder().setState(stateBuilder).build();\n-\n+        \n         // update subscription state\n         if (subManager.isPartialUpdateSupported()) {\n-            subManager.updateSubscriptionData(topic, subid, data, callback, null);\n+            subManager.updateSubscriptionData(topic, subid, data, versionedSubData.getVersion(), callback, null);\n         } else {\n-            subManager.replaceSubscriptionData(topic, subid, data, callback, null);\n+            subManager.replaceSubscriptionData(topic, subid, data, versionedSubData.getVersion(), callback, null);\n         }\n-        Assert.assertEquals(\"Fail to update a subscription state\", null, callback.queue.take().right());\n-\n+        cbResult = callback.queue.take();\n+        Assert.assertEquals(\"Fail to update a subscription state\", null, cbResult.right());\n+        Version v2 = cbResult.left();\n         // read subscription state\n         subManager.readSubscriptionData(topic, subid, readCallback, null);\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n-                            data, readCallback.queue.take().left());\n-\n+                            data, readCallback.queue.take().left().getValue());\n+        \n         // read subscriptions again\n         subManager.readSubscriptions(topic, subsCallback, null);\n         res = subsCallback.queue.take();\n         Assert.assertEquals(\"Should find just 1 subscriber\", 1, res.left().size());\n         Assert.assertEquals(\"Should not fail with PubSubException\", null, res.right());\n-        imss = res.left().get(subid);\n+        versionedSubData = res.left().get(subid);\n+        Assert.assertEquals(Version.Occurred.CONCURRENTLY, v2.compare(versionedSubData.getVersion()));\n+        imss = res.left().get(subid).getValue();\n         Assert.assertEquals(\"Found inconsistent subscription state\",\n                             data, imss);\n         Assert.assertEquals(\"Found inconsistent last consumed seq id\",\n                             seqId, imss.getState().getMsgId().getLocalComponent());\n \n-        subManager.deleteSubscriptionData(topic, subid, callback, null);\n+        // update or replace subscription data with bad version\n+        if (subManager.isPartialUpdateSupported()) {\n+            subManager.updateSubscriptionData(topic, subid, data, v1, callback, null);\n+        } else {\n+            subManager.replaceSubscriptionData(topic, subid, data, v1, callback, null);\n+        }\n+        Assert.assertTrue(callback.queue.take().right() instanceof PubSubException.BadVersionException);\n+        \n+        // delete with bad version\n+        subManager.deleteSubscriptionData(topic, subid, v1, voidCallback, null);\n+        Assert.assertTrue(callback.queue.take().right() instanceof PubSubException.BadVersionException);\n+        subManager.deleteSubscriptionData(topic, subid, res.left().get(subid).getVersion(), voidCallback, null);\n         Assert.assertEquals(\"Fail to delete an existed subscriber\", null, callback.queue.take().right());\n \n         // read subscription states again"}]}

