{"sha":"e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","node_id":"MDY6Q29tbWl0MTU3NTk1NjplMzUzYThmOTNhZDQ4ZDg3ODViYmFhNzE2MmE4YTllYmNhNDBhMTVm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-12T09:59:50Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-12T09:59:50Z"},"message":"BOOKKEEPER-208: Separate write quorum from ack quorum (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1383872 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d9e10280816286493d14ff84f5a4efa9ef0b1adc","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d9e10280816286493d14ff84f5a4efa9ef0b1adc"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","html_url":"https://github.com/apache/bookkeeper/commit/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"26671da549558c4b16da42f2eabfad65fa223831","url":"https://api.github.com/repos/apache/bookkeeper/commits/26671da549558c4b16da42f2eabfad65fa223831","html_url":"https://github.com/apache/bookkeeper/commit/26671da549558c4b16da42f2eabfad65fa223831"}],"stats":{"total":723,"additions":606,"deletions":117},"files":[{"sha":"a779212c338d9950cd784bc9ad7a58af65793cdd","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -132,6 +132,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-300: Create Bookie format command (Vinay via sijie)\n \n+        BOOKKEEPER-208: Separate write quorum from ack quorum (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"0d5ae0a6fc0911a7091c0ec43738199894aa579c","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"modified","additions":14,"deletions":7,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -78,7 +78,7 @@\n         }\n     }\n \n-    public BenchThroughputLatency(int ensemble, int qSize, byte[] passwd,\n+    public BenchThroughputLatency(int ensemble, int writeQuorumSize, int ackQuorumSize, byte[] passwd,\n             int numberOfLedgers, int sendLimit, ClientConfiguration conf)\n             throws KeeperException, IOException, InterruptedException {\n         this.sem = new Semaphore(conf.getThrottleValue());\n@@ -91,9 +91,11 @@ public BenchThroughputLatency(int ensemble, int qSize, byte[] passwd,\n             lh = new LedgerHandle[this.numberOfLedgers];\n \n             for(int i = 0; i < this.numberOfLedgers; i++) {\n-                lh[i] = bk.createLedger(ensemble, qSize, BookKeeper.DigestType.CRC32,\n+                lh[i] = bk.createLedger(ensemble, writeQuorumSize,\n+                                        ackQuorumSize,\n+                                        BookKeeper.DigestType.CRC32,\n                                         passwd);\n-                LOG.info(\"Ledger Handle: \" + lh[i].getId());\n+                LOG.debug(\"Ledger Handle: \" + lh[i].getId());\n             }\n         } catch (BKException e) {\n             e.printStackTrace();\n@@ -233,6 +235,7 @@ public static void main(String[] args)\n         options.addOption(\"entrysize\", true, \"Entry size (bytes), default 1024\");\n         options.addOption(\"ensemble\", true, \"Ensemble size, default 3\");\n         options.addOption(\"quorum\", true, \"Quorum size, default 2\");\n+        options.addOption(\"ackQuorum\", true, \"Ack quorum size, default is same as quorum\");\n         options.addOption(\"throttle\", true, \"Max outstanding requests, default 10000\");\n         options.addOption(\"ledgers\", true, \"Number of ledgers, default 1\");\n         options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n@@ -261,6 +264,10 @@ public static void main(String[] args)\n         int ledgers = Integer.valueOf(cmd.getOptionValue(\"ledgers\", \"1\"));\n         int ensemble = Integer.valueOf(cmd.getOptionValue(\"ensemble\", \"3\"));\n         int quorum = Integer.valueOf(cmd.getOptionValue(\"quorum\", \"2\"));\n+        int ackQuorum = quorum;\n+        if (cmd.hasOption(\"ackQuorum\")) {\n+            ackQuorum = Integer.valueOf(cmd.getOptionValue(\"ackQuorum\"));\n+        }\n         int throttle = Integer.valueOf(cmd.getOptionValue(\"throttle\", \"10000\"));\n         int sendLimit = Integer.valueOf(cmd.getOptionValue(\"sendlimit\", \"20000000\"));\n \n@@ -313,8 +320,8 @@ public void run() {\n \n \n         // Now do the benchmark\n-        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, passwd,\n-                                                                  ledgers, sendLimit, conf);\n+        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, ackQuorum,\n+                passwd, ledgers, sendLimit, conf);\n         bench.setEntryData(data);\n         thread = new Thread(bench);\n         ZooKeeper zk = null;\n@@ -439,8 +446,8 @@ public void process(WatchedEvent event) {\n             }\n         }\n \n-        BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, passwd,\n-                ledgers, 50000, conf);\n+        BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, bookies, passwd,\n+                                                                   ledgers, 10000, conf);\n         warmup.setEntryData(data);\n         Thread thread = new Thread(warmup);\n         thread.start();"},{"sha":"4d32a9b8af5766a30a86d6c7cfcd7fbb9023fc39","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":73,"deletions":7,"changes":80,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -256,9 +256,47 @@ BookieClient getBookieClient() {\n      * authenticate access to a ledger, but also to verify entries in ledgers.\n      *\n      * @param ensSize\n-     *          ensemble size\n-     * @param qSize\n-     *          quorum size\n+     *          number of bookies over which to stripe entries\n+     * @param writeQuorumSize\n+     *          number of bookies each entry will be written to. each of these bookies\n+     *          must acknowledge the entry before the call is completed.\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param cb\n+     *          createCallback implementation\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void asyncCreateLedger(final int ensSize,\n+                                  final int writeQuorumSize,\n+                                  final DigestType digestType,\n+                                  final byte[] passwd, final CreateCallback cb, final Object ctx)\n+    {\n+        asyncCreateLedger(ensSize, writeQuorumSize, writeQuorumSize, digestType, passwd, cb, ctx);\n+    }\n+\n+    /**\n+     * Creates a new ledger asynchronously. Ledgers created with this call have\n+     * a separate write quorum and ack quorum size. The write quorum must be larger than\n+     * the ack quorum.\n+     *\n+     * Separating the write and the ack quorum allows the BookKeeper client to continue\n+     * writing when a bookie has failed but the failure has not yet been detected. Detecting\n+     * a bookie has failed can take a number of seconds, as configured by the read timeout\n+     * {@link ClientConfiguration#getReadTimeout()}. Once the bookie failure is detected,\n+     * that bookie will be removed from the ensemble.\n+     *\n+     * The other parameters match those of {@link #asyncCreateLedger(int, int, DigestType, byte[],\n+     *                                      AsyncCallback.CreateCallback, Object)}\n+     *\n+     * @param ensSize\n+     *          number of bookies over which to stripe entries\n+     * @param writeQuorumSize\n+     *          number of bookies each entry will be written to\n+     * @param ackQuorumSize\n+     *          number of bookies which must acknowledge an entry before the call is completed\n      * @param digestType\n      *          digest type, either MAC or CRC32\n      * @param passwd\n@@ -268,9 +306,17 @@ BookieClient getBookieClient() {\n      * @param ctx\n      *          optional control object\n      */\n-    public void asyncCreateLedger(final int ensSize, final int qSize, final DigestType digestType,\n+\n+    public void asyncCreateLedger(final int ensSize,\n+                                  final int writeQuorumSize,\n+                                  final int ackQuorumSize,\n+                                  final DigestType digestType,\n                                   final byte[] passwd, final CreateCallback cb, final Object ctx) {\n-        new LedgerCreateOp(BookKeeper.this, ensSize, qSize, digestType, passwd, cb, ctx)\n+        if (writeQuorumSize < ackQuorumSize) {\n+            throw new IllegalArgumentException(\"Write quorum must be larger than ack quorum\");\n+        }\n+        new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n+                           ackQuorumSize, digestType, passwd, cb, ctx)\n             .initiate();\n     }\n \n@@ -305,14 +351,34 @@ public LedgerHandle createLedger(DigestType digestType, byte passwd[])\n      * @throws BKException\n      */\n     public LedgerHandle createLedger(int ensSize, int qSize,\n-                                     DigestType digestType, byte passwd[]) \n+                                     DigestType digestType, byte passwd[])\n+            throws InterruptedException, BKException {\n+        return createLedger(ensSize, qSize, qSize, digestType, passwd);\n+    }\n+\n+    /**\n+     * Synchronous call to create ledger. Parameters match those of\n+     * {@link #asyncCreateLedger(int, int, int, DigestType, byte[],\n+     *                           AsyncCallback.CreateCallback, Object)}\n+     *\n+     * @param ensSize\n+     * @param writeQuorumSize\n+     * @param ackQuorumSize\n+     * @param digestType\n+     * @param passwd\n+     * @return a handle to the newly created ledger\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize,\n+                                     DigestType digestType, byte passwd[])\n             throws InterruptedException, BKException {\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n         /*\n          * Calls asynchronous version\n          */\n-        asyncCreateLedger(ensSize, qSize, digestType, passwd, \n+        asyncCreateLedger(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd,\n                           new SyncCreateCallback(), counter);\n \n         /*"},{"sha":"6dba0ccc6b9adfc7aae9b022ed4684476eb206d2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":25,"deletions":11,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -17,6 +17,7 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import java.util.List;\n /**\n  * This interface determins how entries are distributed among bookies.\n  *\n@@ -30,21 +31,34 @@\n interface DistributionSchedule {\n \n     /**\n-     *\n-     * @param entryId\n-     * @param replicaIndex\n-     * @return index of bookie that should get this replica\n+     * return the set of bookie indices to send the message to\n      */\n-    public int getBookieIndex(long entryId, int replicaIndex);\n+    public List<Integer> getWriteSet(long entryId);\n \n     /**\n-     *\n-     * @param entryId\n-     * @param bookieIndex\n-     * @return -1 if the given bookie index is not a replica for the given\n-     *         entryId\n+     * An ack set represents the set of bookies from which\n+     * a response must be received so that an entry can be\n+     * considered to be replicated on a quorum.\n      */\n-    public int getReplicaIndex(long entryId, int bookieIndex);\n+    public interface AckSet {\n+        /**\n+         * Add a bookie response and check if quorum has been met\n+         * @return true if quorum has been met, false otherwise\n+         */\n+        public boolean addBookieAndCheck(int bookieIndexHeardFrom);\n+\n+        /**\n+         * Invalidate a previous bookie response.\n+         * Used for reissuing write requests.\n+         */\n+        public void removeBookie(int bookie);\n+    }\n+\n+    /**\n+     * Returns an ackset object, responses should be checked against this\n+     */\n+    public AckSet getAckSet();\n+\n \n     /**\n      * Interface to keep track of which bookies in an ensemble, an action"},{"sha":"b1ceb7a6d5f2db03d2130f96ce113e4b097eb193","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -222,7 +222,7 @@ public void checkLedger(LedgerHandle lh,\n                 final long entryToRead = curEntryId;\n \n                 EntryExistsCallback eecb\n-                    = new EntryExistsCallback(lh.getLedgerMetadata().getQuorumSize(),\n+                    = new EntryExistsCallback(lh.getLedgerMetadata().getWriteQuorumSize(),\n                                               new GenericCallback<Boolean>() {\n                                                   public void operationComplete(int rc, Boolean result) {\n                                                       if (result) {\n@@ -232,8 +232,7 @@ public void operationComplete(int rc, Boolean result) {\n                                                   }\n                                               });\n \n-                for (int i = 0; i < lh.getLedgerMetadata().getQuorumSize(); i++) {\n-                    int bi = lh.getDistributionSchedule().getBookieIndex(entryToRead, i);\n+                for (int bi : lh.getDistributionSchedule().getWriteSet(entryToRead)) {\n                     InetSocketAddress addr = curEnsemble.get(bi);\n                     bookieClient.readEntry(addr, lh.getId(),\n                                            entryToRead, eecb, null);"},{"sha":"9d288c8da2b43b386cb73f17f2cf7c96c43b843b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -68,9 +68,12 @@\n      *       optional control object\n      */\n \n-    LedgerCreateOp(BookKeeper bk, int ensembleSize, int quorumSize, DigestType digestType, byte[] passwd, CreateCallback cb, Object ctx) {\n+    LedgerCreateOp(BookKeeper bk, int ensembleSize,\n+                   int writeQuorumSize, int ackQuorumSize,\n+                   DigestType digestType,\n+                   byte[] passwd, CreateCallback cb, Object ctx) {\n         this.bk = bk;\n-        this.metadata = new LedgerMetadata(ensembleSize, quorumSize, digestType, passwd);\n+        this.metadata = new LedgerMetadata(ensembleSize, writeQuorumSize, ackQuorumSize, digestType, passwd);\n         this.digestType = digestType;\n         this.passwd = passwd;\n         this.cb = cb;"},{"sha":"18b8dd8275946279817922d8a1da3974a7f53487","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":10,"deletions":3,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -29,6 +29,7 @@\n import java.util.Enumeration;\n import java.util.Queue;\n import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException;\n@@ -74,6 +75,7 @@\n      */\n     final static public long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;\n \n+    final AtomicInteger blockAddCompletions = new AtomicInteger(0);\n     final Queue<PendingAddOp> pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n \n     LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n@@ -98,7 +100,7 @@\n         macManager = DigestManager.instantiate(ledgerId, password, digestType);\n         this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n         distributionSchedule = new RoundRobinDistributionSchedule(\n-                metadata.getQuorumSize(), metadata.getEnsembleSize());\n+                metadata.getWriteQuorumSize(), metadata.getAckQuorumSize(), metadata.getEnsembleSize());\n     }\n \n     /**\n@@ -641,8 +643,9 @@ void sendAddSuccessCallbacks() {\n         // Start from the head of the queue and proceed while there are\n         // entries that have had all their responses come back\n         PendingAddOp pendingAddOp;\n-        while ((pendingAddOp = pendingAddOps.peek()) != null) {\n-            if (pendingAddOp.numResponsesPending != 0) {\n+        while ((pendingAddOp = pendingAddOps.peek()) != null\n+               && blockAddCompletions.get() == 0) {\n+            if (!pendingAddOp.completed) {\n                 return;\n             }\n             pendingAddOps.remove();\n@@ -660,6 +663,7 @@ void handleBookieFailure(final InetSocketAddress addr, final int bookieIndex) {\n                       + bookieIndex);\n         }\n         final ArrayList<InetSocketAddress> newEnsemble = new ArrayList<InetSocketAddress>();\n+        blockAddCompletions.incrementAndGet();\n         final long newEnsembleStartEntry = lastAddConfirmed + 1;\n \n         // avoid parallel ensemble changes to same ensemble.\n@@ -735,6 +739,8 @@ public void safeRun() {\n                         handleUnrecoverableErrorDuringAdd(rc);\n                         return;\n                     }\n+                    blockAddCompletions.decrementAndGet();\n+\n                     // the failed bookie has been replaced\n                     unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n                 }\n@@ -815,6 +821,7 @@ private boolean resolveConflict(LedgerMetadata newMeta) {\n                 }\n             } else {\n                 // the failed bookie has been replaced\n+                blockAddCompletions.decrementAndGet();\n                 unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n             }\n             return true;"},{"sha":"4ee46c6dcee73a8918e12d4b2174ef12d75105e2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":25,"deletions":11,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -61,7 +61,8 @@\n     private int metadataFormatVersion = 0;\n \n     private int ensembleSize;\n-    private int quorumSize;\n+    private int writeQuorumSize;\n+    private int ackQuorumSize;\n     private long length;\n     private long lastEntryId;\n \n@@ -74,10 +75,11 @@\n     private LedgerMetadataFormat.DigestType digestType;\n     private byte[] password;\n \n-    public LedgerMetadata(int ensembleSize, int quorumSize,\n+    public LedgerMetadata(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n                           BookKeeper.DigestType digestType, byte[] password) {\n         this.ensembleSize = ensembleSize;\n-        this.quorumSize = quorumSize;\n+        this.writeQuorumSize = writeQuorumSize;\n+        this.ackQuorumSize = ackQuorumSize;\n \n         /*\n          * It is set in PendingReadOp.readEntryComplete, and\n@@ -95,7 +97,7 @@ public LedgerMetadata(int ensembleSize, int quorumSize,\n     }\n \n     private LedgerMetadata() {\n-        this(0, 0, BookKeeper.DigestType.MAC, new byte[] {});\n+        this(0, 0, 0, BookKeeper.DigestType.MAC, new byte[] {});\n         this.hasPassword = false;\n     }\n \n@@ -114,8 +116,12 @@ public int getEnsembleSize() {\n         return ensembleSize;\n     }\n \n-    public int getQuorumSize() {\n-        return quorumSize;\n+    public int getWriteQuorumSize() {\n+        return writeQuorumSize;\n+    }\n+\n+    public int getAckQuorumSize() {\n+        return ackQuorumSize;\n     }\n \n     /**\n@@ -217,7 +223,8 @@ long getNextEnsembleChange(long entryId) {\n             return serializeVersion1();\n         }\n         LedgerMetadataFormat.Builder builder = LedgerMetadataFormat.newBuilder();\n-        builder.setQuorumSize(quorumSize).setEnsembleSize(ensembleSize).setLength(length)\n+        builder.setQuorumSize(writeQuorumSize).setAckQuorumSize(ackQuorumSize)\n+            .setEnsembleSize(ensembleSize).setLength(length)\n             .setState(state).setLastEntryId(lastEntryId);\n \n         if (hasPassword) {\n@@ -245,7 +252,7 @@ long getNextEnsembleChange(long entryId) {\n     private byte[] serializeVersion1() {\n         StringBuilder s = new StringBuilder();\n         s.append(VERSION_KEY).append(tSplitter).append(metadataFormatVersion).append(lSplitter);\n-        s.append(quorumSize).append(lSplitter).append(ensembleSize).append(lSplitter).append(length);\n+        s.append(writeQuorumSize).append(lSplitter).append(ensembleSize).append(lSplitter).append(length);\n \n         for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n             s.append(lSplitter).append(entry.getKey());\n@@ -321,7 +328,13 @@ public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws I\n         LedgerMetadataFormat.Builder builder = LedgerMetadataFormat.newBuilder();\n         TextFormat.merge(reader, builder);\n         LedgerMetadataFormat data = builder.build();\n-        lc.quorumSize = data.getQuorumSize();\n+        lc.writeQuorumSize = data.getQuorumSize();\n+        if (data.hasAckQuorumSize()) {\n+            lc.ackQuorumSize = data.getAckQuorumSize();\n+        } else {\n+            lc.ackQuorumSize = lc.writeQuorumSize;\n+        }\n+\n         lc.ensembleSize = data.getEnsembleSize();\n         lc.length = data.getLength();\n         lc.state = data.getState();\n@@ -346,7 +359,7 @@ public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws I\n     static LedgerMetadata parseVersion1Config(LedgerMetadata lc,\n                                               BufferedReader reader) throws IOException {\n         try {\n-            lc.quorumSize = new Integer(reader.readLine());\n+            lc.writeQuorumSize = lc.ackQuorumSize = new Integer(reader.readLine());\n             lc.ensembleSize = new Integer(reader.readLine());\n             lc.length = new Long(reader.readLine());\n \n@@ -413,7 +426,8 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n \n         if (metadataFormatVersion != newMeta.metadataFormatVersion ||\n             ensembleSize != newMeta.ensembleSize ||\n-            quorumSize != newMeta.quorumSize ||\n+            writeQuorumSize != newMeta.writeQuorumSize ||\n+            ackQuorumSize != newMeta.ackQuorumSize ||\n             length != newMeta.length ||\n             state != newMeta.state ||\n             !digestType.equals(newMeta.digestType) ||"},{"sha":"acef474c45479213f1a8a13f9a174307fef7e704","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":17,"deletions":32,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -42,8 +42,10 @@\n     AddCallback cb;\n     Object ctx;\n     long entryId;\n-    boolean[] successesSoFar;\n-    int numResponsesPending;\n+\n+    DistributionSchedule.AckSet ackSet;\n+    boolean completed = false;\n+\n     LedgerHandle lh;\n     boolean isRecoveryAdd = false;\n \n@@ -53,11 +55,10 @@\n         this.ctx = ctx;\n         this.entryId = LedgerHandle.INVALID_ENTRY_ID;\n         \n-        successesSoFar = new boolean[lh.metadata.getQuorumSize()];\n-        numResponsesPending = successesSoFar.length;\n+        ackSet = lh.distributionSchedule.getAckSet();\n     }\n \n-    /** \n+    /**\n      * Enable the recovery add flag for this operation.\n      * @see LedgerHandle#asyncRecoveryAddEntry\n      */\n@@ -70,11 +71,11 @@ void setEntryId(long entryId) {\n         this.entryId = entryId;\n     }\n \n-    void sendWriteRequest(int bookieIndex, int arrayIndex) {\n+    void sendWriteRequest(int bookieIndex) {\n         int flags = isRecoveryAdd ? BookieProtocol.FLAG_RECOVERY_ADD : BookieProtocol.FLAG_NONE;\n \n         lh.bk.bookieClient.addEntry(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey, entryId, toSend,\n-                this, arrayIndex, flags);\n+                this, bookieIndex, flags);\n     }\n \n     void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n@@ -85,15 +86,6 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n             return;\n         }\n \n-        int replicaIndex = lh.distributionSchedule.getReplicaIndex(entryId, bookieIndex);\n-        if (replicaIndex < 0) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Leaving unchanged, ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n-                          + bookieIndex);\n-            }\n-            return;\n-        }\n-\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Unsetting success for ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n                       + bookieIndex);\n@@ -102,27 +94,22 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n         // if we had already heard a success from this array index, need to\n         // increment our number of responses that are pending, since we are\n         // going to unset this success\n-        if (successesSoFar[replicaIndex]) {\n-            successesSoFar[replicaIndex] = false;\n-            numResponsesPending++;\n-        }\n+        ackSet.removeBookie(bookieIndex);\n+        completed = false;\n \n-        sendWriteRequest(bookieIndex, replicaIndex);\n+        sendWriteRequest(bookieIndex);\n     }\n \n     void initiate(ChannelBuffer toSend) {\n         this.toSend = toSend;\n-        for (int i = 0; i < successesSoFar.length; i++) {\n-            int bookieIndex = lh.distributionSchedule.getBookieIndex(entryId, i);\n-            sendWriteRequest(bookieIndex, i);\n+        for (int bookieIndex : lh.distributionSchedule.getWriteSet(entryId)) {\n+            sendWriteRequest(bookieIndex);\n         }\n     }\n \n     @Override\n     public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n-\n-        Integer replicaIndex = (Integer) ctx;\n-        int bookieIndex = lh.distributionSchedule.getBookieIndex(entryId, replicaIndex);\n+        int bookieIndex = (Integer) ctx;\n \n         if (!lh.metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n             // ensemble has already changed, failure of this addr is immaterial\n@@ -148,14 +135,12 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             return;\n         }\n \n-\n-        if (!successesSoFar[replicaIndex]) {\n-            successesSoFar[replicaIndex] = true;\n-            numResponsesPending--;\n+        if (ackSet.addBookieAndCheck(bookieIndex) && !completed) {\n+            completed = true;\n \n             // do some quick checks to see if some adds may have finished. All\n             // this will be checked under locks again\n-            if (numResponsesPending == 0 && lh.pendingAddOps.peek() == this) {\n+            if (lh.pendingAddOps.peek() == this) {\n                 lh.sendAddSuccessCallbacks();\n             }\n         }"},{"sha":"98ba03774cc686c21695d52dbec19d9f1f497e9a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -94,23 +94,23 @@ public void initiate() throws InterruptedException {\n     }\n \n     void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int lastErrorCode) {\n-        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.getQuorumSize()) {\n+        if (entry.nextReplicaIndexToReadFrom >= lh.metadata.getWriteQuorumSize()) {\n             // we are done, the read has failed from all replicas, just fail the\n             // read\n             lh.opCounterSem.release();\n             submitCallback(lastErrorCode);\n             return;\n         }\n \n-        int bookieIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom);\n+        int bookieIndex = lh.distributionSchedule.getWriteSet(entry.entryId).get(entry.nextReplicaIndexToReadFrom);\n         entry.nextReplicaIndexToReadFrom++;\n         lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, \n                                      this, entry);\n     }\n \n     void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n         ArrayList<InetSocketAddress> ensemble = lh.metadata.getEnsemble(entry.entryId);\n-        int bookeIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom - 1);\n+        int bookeIndex = lh.distributionSchedule.getWriteSet(entry.entryId).get(entry.nextReplicaIndexToReadFrom - 1);\n         LOG.error(errMsg + \" while reading entry: \" + entry.entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n                   + ensemble.get(bookeIndex));\n         sendRead(ensemble, entry, rc);"},{"sha":"b34ff754f924fd989a9cea4cc0783cde5fbaff99","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":30,"deletions":15,"changes":45,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -19,6 +19,10 @@\n \n import org.apache.bookkeeper.util.MathUtils;\n \n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+\n /**\n  * A specific {@link DistributionSchedule} that places entries in round-robin\n  * fashion. For ensemble size 3, and quorum size 2, Entry 0 goes to bookie 0 and\n@@ -27,29 +31,39 @@\n  *\n  */\n class RoundRobinDistributionSchedule implements DistributionSchedule {\n-    int quorumSize;\n-    int ensembleSize;\n+    private int writeQuorumSize;\n+    private int ackQuorumSize;\n+    private int ensembleSize;\n \n \n-    public RoundRobinDistributionSchedule(int quorumSize, int ensembleSize) {\n-        this.quorumSize = quorumSize;\n+    public RoundRobinDistributionSchedule(int writeQuorumSize, int ackQuorumSize, int ensembleSize) {\n+        this.writeQuorumSize = writeQuorumSize;\n+        this.ackQuorumSize = ackQuorumSize;\n         this.ensembleSize = ensembleSize;\n     }\n \n     @Override\n-    public int getBookieIndex(long entryId, int replicaIndex) {\n-        return (int) ((entryId + replicaIndex) % ensembleSize);\n+    public List<Integer> getWriteSet(long entryId) {\n+        List<Integer> set = new ArrayList<Integer>();\n+        for (int i = 0; i < this.writeQuorumSize; i++) {\n+            set.add((int)((entryId + i) % ensembleSize));\n+        }\n+        return set;\n     }\n \n     @Override\n-    public int getReplicaIndex(long entryId, int bookieIndex) {\n-        // NOTE: Java's % operator returns the sign of the dividend and is hence\n-        // not always positive\n-\n-        int replicaIndex = MathUtils.signSafeMod(bookieIndex - entryId, ensembleSize);\n-\n-        return replicaIndex < quorumSize ? replicaIndex : -1;\n+    public AckSet getAckSet() {\n+        final HashSet<Integer> ackSet = new HashSet<Integer>();\n+        return new AckSet() {\n+            public boolean addBookieAndCheck(int bookieIndexHeardFrom) {\n+                ackSet.add(bookieIndexHeardFrom);\n+                return ackSet.size() >= ackQuorumSize;\n+            }\n \n+            public void removeBookie(int bookie) {\n+                ackSet.remove(bookie);\n+            }\n+        };\n     }\n \n     private class RRQuorumCoverageSet implements QuorumCoverageSet {\n@@ -68,7 +82,7 @@ public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n                 return true;\n             }\n \n-            for (int i = 0; i < quorumSize; i++) {\n+            for (int i = 0; i < ackQuorumSize; i++) {\n                 int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n                 if (!covered[quorumStartIndex]) {\n                     covered[quorumStartIndex] = true;\n@@ -83,12 +97,13 @@ public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n         }\n     }\n \n+    @Override\n     public QuorumCoverageSet getCoverageSet() {\n         return new RRQuorumCoverageSet();\n     }\n     \n     @Override\n     public boolean hasEntry(long entryId, int bookieIndex) {\n-        return getReplicaIndex(entryId, bookieIndex) != -1;\n+        return getWriteSet(entryId).contains(bookieIndex);\n     }\n }"},{"sha":"8443c27b681e8a122a805465e5f537d754be1952","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -230,6 +230,8 @@ public ClientConfiguration setZkTimeout(int zkTimeout) {\n      * seconds we wait without hearing a response from a bookie\n      * before we consider it failed.\n      *\n+     * The default is 5 seconds.\n+     *\n      * @return the current read timeout in seconds\n      */\n     public int getReadTimeout() {"},{"sha":"ff6a4065df6f3a484b2fb8e04692a3ba80ce63b3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","status":"modified","additions":70,"deletions":13,"changes":83,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -48,6 +48,10 @@ public static void registerAllExtensions(\n     // optional bytes password = 8;\n     boolean hasPassword();\n     com.google.protobuf.ByteString getPassword();\n+    \n+    // optional int32 ackQuorumSize = 9;\n+    boolean hasAckQuorumSize();\n+    int getAckQuorumSize();\n   }\n   public static final class LedgerMetadataFormat extends\n       com.google.protobuf.GeneratedMessage\n@@ -767,6 +771,16 @@ public boolean hasPassword() {\n       return password_;\n     }\n     \n+    // optional int32 ackQuorumSize = 9;\n+    public static final int ACKQUORUMSIZE_FIELD_NUMBER = 9;\n+    private int ackQuorumSize_;\n+    public boolean hasAckQuorumSize() {\n+      return ((bitField0_ & 0x00000080) == 0x00000080);\n+    }\n+    public int getAckQuorumSize() {\n+      return ackQuorumSize_;\n+    }\n+    \n     private void initFields() {\n       quorumSize_ = 0;\n       ensembleSize_ = 0;\n@@ -776,6 +790,7 @@ private void initFields() {\n       segment_ = java.util.Collections.emptyList();\n       digestType_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.CRC32;\n       password_ = com.google.protobuf.ByteString.EMPTY;\n+      ackQuorumSize_ = 0;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -835,6 +850,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000040) == 0x00000040)) {\n         output.writeBytes(8, password_);\n       }\n+      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n+        output.writeInt32(9, ackQuorumSize_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -876,6 +894,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeBytesSize(8, password_);\n       }\n+      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(9, ackQuorumSize_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -1021,6 +1043,8 @@ public Builder clear() {\n         bitField0_ = (bitField0_ & ~0x00000040);\n         password_ = com.google.protobuf.ByteString.EMPTY;\n         bitField0_ = (bitField0_ & ~0x00000080);\n+        ackQuorumSize_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000100);\n         return this;\n       }\n       \n@@ -1096,6 +1120,10 @@ public Builder clone() {\n           to_bitField0_ |= 0x00000040;\n         }\n         result.password_ = password_;\n+        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {\n+          to_bitField0_ |= 0x00000080;\n+        }\n+        result.ackQuorumSize_ = ackQuorumSize_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -1159,6 +1187,9 @@ public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataF\n         if (other.hasPassword()) {\n           setPassword(other.getPassword());\n         }\n+        if (other.hasAckQuorumSize()) {\n+          setAckQuorumSize(other.getAckQuorumSize());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -1265,6 +1296,11 @@ public Builder mergeFrom(\n               password_ = input.readBytes();\n               break;\n             }\n+            case 72: {\n+              bitField0_ |= 0x00000100;\n+              ackQuorumSize_ = input.readInt32();\n+              break;\n+            }\n           }\n         }\n       }\n@@ -1613,6 +1649,27 @@ public Builder clearPassword() {\n         return this;\n       }\n       \n+      // optional int32 ackQuorumSize = 9;\n+      private int ackQuorumSize_ ;\n+      public boolean hasAckQuorumSize() {\n+        return ((bitField0_ & 0x00000100) == 0x00000100);\n+      }\n+      public int getAckQuorumSize() {\n+        return ackQuorumSize_;\n+      }\n+      public Builder setAckQuorumSize(int value) {\n+        bitField0_ |= 0x00000100;\n+        ackQuorumSize_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearAckQuorumSize() {\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        ackQuorumSize_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:LedgerMetadataFormat)\n     }\n     \n@@ -3176,24 +3233,24 @@ void setInstanceId(com.google.protobuf.ByteString value) {\n       descriptor;\n   static {\n     java.lang.String[] descriptorData = {\n-      \"\\n src/main/proto/DataFormats.proto\\\"\\233\\003\\n\\024L\" +\n+      \"\\n src/main/proto/DataFormats.proto\\\"\\262\\003\\n\\024L\" +\n       \"edgerMetadataFormat\\022\\022\\n\\nquorumSize\\030\\001 \\002(\\005\\022\" +\n       \"\\024\\n\\014ensembleSize\\030\\002 \\002(\\005\\022\\016\\n\\006length\\030\\003 \\002(\\003\\022\\023\\n\" +\n       \"\\013lastEntryId\\030\\004 \\001(\\003\\0220\\n\\005state\\030\\005 \\002(\\0162\\033.Ledg\" +\n       \"erMetadataFormat.State:\\004OPEN\\022.\\n\\007segment\\030\" +\n       \"\\006 \\003(\\0132\\035.LedgerMetadataFormat.Segment\\0224\\n\\n\" +\n       \"digestType\\030\\007 \\001(\\0162 .LedgerMetadataFormat.\" +\n-      \"DigestType\\022\\020\\n\\010password\\030\\010 \\001(\\014\\0327\\n\\007Segment\\022\" +\n-      \"\\026\\n\\016ensembleMember\\030\\001 \\003(\\t\\022\\024\\n\\014firstEntryId\\030\" +\n-      \"\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\\004OPEN\\020\\001\\022\\017\\n\\013IN_RECOVERY\\020\",\n-      \"\\002\\022\\n\\n\\006CLOSED\\020\\003\\\"!\\n\\nDigestType\\022\\t\\n\\005CRC32\\020\\001\\022\\010\" +\n-      \"\\n\\004HMAC\\020\\002\\\"@\\n\\037LedgerRereplicationLayoutFor\" +\n-      \"mat\\022\\014\\n\\004type\\030\\001 \\002(\\t\\022\\017\\n\\007version\\030\\002 \\002(\\005\\\".\\n\\033Un\" +\n-      \"derreplicatedLedgerFormat\\022\\017\\n\\007replica\\030\\001 \\003\" +\n-      \"(\\t\\\"^\\n\\014CookieFormat\\022\\022\\n\\nbookieHost\\030\\001 \\002(\\t\\022\\022\" +\n-      \"\\n\\njournalDir\\030\\002 \\002(\\t\\022\\022\\n\\nledgerDirs\\030\\003 \\002(\\t\\022\\022\" +\n-      \"\\n\\ninstanceId\\030\\004 \\001(\\tB\\037\\n\\033org.apache.bookkee\" +\n-      \"per.protoH\\001\"\n+      \"DigestType\\022\\020\\n\\010password\\030\\010 \\001(\\014\\022\\025\\n\\rackQuoru\" +\n+      \"mSize\\030\\t \\001(\\005\\0327\\n\\007Segment\\022\\026\\n\\016ensembleMember\" +\n+      \"\\030\\001 \\003(\\t\\022\\024\\n\\014firstEntryId\\030\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\",\n+      \"\\004OPEN\\020\\001\\022\\017\\n\\013IN_RECOVERY\\020\\002\\022\\n\\n\\006CLOSED\\020\\003\\\"!\\n\\n\" +\n+      \"DigestType\\022\\t\\n\\005CRC32\\020\\001\\022\\010\\n\\004HMAC\\020\\002\\\"@\\n\\037Ledge\" +\n+      \"rRereplicationLayoutFormat\\022\\014\\n\\004type\\030\\001 \\002(\\t\" +\n+      \"\\022\\017\\n\\007version\\030\\002 \\002(\\005\\\".\\n\\033UnderreplicatedLedg\" +\n+      \"erFormat\\022\\017\\n\\007replica\\030\\001 \\003(\\t\\\"^\\n\\014CookieForma\" +\n+      \"t\\022\\022\\n\\nbookieHost\\030\\001 \\002(\\t\\022\\022\\n\\njournalDir\\030\\002 \\002(\" +\n+      \"\\t\\022\\022\\n\\nledgerDirs\\030\\003 \\002(\\t\\022\\022\\n\\ninstanceId\\030\\004 \\001(\" +\n+      \"\\tB\\037\\n\\033org.apache.bookkeeper.protoH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -3205,7 +3262,7 @@ void setInstanceId(com.google.protobuf.ByteString value) {\n           internal_static_LedgerMetadataFormat_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_LedgerMetadataFormat_descriptor,\n-              new java.lang.String[] { \"QuorumSize\", \"EnsembleSize\", \"Length\", \"LastEntryId\", \"State\", \"Segment\", \"DigestType\", \"Password\", },\n+              new java.lang.String[] { \"QuorumSize\", \"EnsembleSize\", \"Length\", \"LastEntryId\", \"State\", \"Segment\", \"DigestType\", \"Password\", \"AckQuorumSize\", },\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.class,\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Builder.class);\n           internal_static_LedgerMetadataFormat_Segment_descriptor ="},{"sha":"25e62233708a23d78dd8951f664ba0d9d57a7070","filename":"bookkeeper-server/src/main/proto/DataFormats.proto","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/proto/DataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/main/proto/DataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/DataFormats.proto?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -46,6 +46,8 @@ message LedgerMetadataFormat {\n     }\n     optional DigestType digestType = 7;\n     optional bytes password = 8;\n+\n+    optional int32 ackQuorumSize = 9;\n }\n \n message LedgerRereplicationLayoutFormat {"},{"sha":"16c0276e316884da0790fc2018b74a870e27e08c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -464,7 +464,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n         ranges.put(keyList.get(keyList.size()-1), untilEntry);\n \n         for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : ensembles.entrySet()) {\n-            int quorum = md.getQuorumSize();\n+            int quorum = md.getAckQuorumSize();\n             long startEntryId = e.getKey();\n             long endEntryId = ranges.get(startEntryId);\n             long expectedSuccess = quorum*(endEntryId-startEntryId);"},{"sha":"95b87cc0cb22d0cab9d9dcb63647d3bfddbb13eb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -0,0 +1,64 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.util.List;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import junit.framework.TestCase;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RoundRobinDistributionScheduleTest {\n+    static Logger LOG = LoggerFactory.getLogger(RoundRobinDistributionScheduleTest.class);\n+\n+    @Test\n+    public void testDistributionSchedule() throws Exception {\n+        RoundRobinDistributionSchedule schedule = new RoundRobinDistributionSchedule(3, 2, 5);\n+\n+        List<Integer> wSet = schedule.getWriteSet(1);\n+        assertEquals(\"Write set is wrong size\", wSet.size(), 3);\n+\n+        DistributionSchedule.AckSet ackSet = schedule.getAckSet();\n+        assertFalse(\"Shouldn't ack yet\", ackSet.addBookieAndCheck(wSet.get(0)));\n+        assertFalse(\"Shouldn't ack yet\", ackSet.addBookieAndCheck(wSet.get(0)));\n+        assertTrue(\"Should ack after 2 unique\", ackSet.addBookieAndCheck(wSet.get(2)));\n+        assertTrue(\"Should still be acking\", ackSet.addBookieAndCheck(wSet.get(1)));\n+\n+        DistributionSchedule.QuorumCoverageSet covSet = schedule.getCoverageSet();\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(2));\n+        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(3));\n+\n+        covSet = schedule.getCoverageSet();\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(1));\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(2));\n+        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(3));\n+\n+        covSet = schedule.getCoverageSet();\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(4));\n+        assertFalse(\"Shouldn't cover yet\", covSet.addBookieAndCheckCovered(0));\n+        assertTrue(\"Should cover now\", covSet.addBookieAndCheckCovered(2));\n+    }\n+}\n\\ No newline at end of file"},{"sha":"e48148c1900af5138068f48fc477b6b1b00e7bdf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"added","additions":208,"deletions":0,"changes":208,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -0,0 +1,208 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.util.Set;\n+import java.util.List;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.net.InetSocketAddress;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import junit.framework.TestCase;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+\n+public class SlowBookieTest extends BookKeeperClusterTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(SlowBookieTest.class);\n+\n+    public SlowBookieTest() {\n+        super(4);\n+    }\n+\n+    @Test\n+    public void testSlowBookie() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString()).setReadTimeout(360);\n+\n+        BookKeeper bkc = new BookKeeper(conf);\n+\n+        LedgerHandle lh = bkc.createLedger(4, 3, 2, BookKeeper.DigestType.CRC32, new byte[] {});\n+\n+        byte[] entry = \"Test Entry\".getBytes();\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(entry);\n+        }\n+        final CountDownLatch b0latch = new CountDownLatch(1);\n+        final CountDownLatch b1latch = new CountDownLatch(1);\n+        List<InetSocketAddress> curEns = lh.getLedgerMetadata().currentEnsemble;\n+        try {\n+            sleepBookie(curEns.get(0), b0latch);\n+            for (int i = 0; i < 10; i++) {\n+                lh.addEntry(entry);\n+            }\n+            sleepBookie(curEns.get(2), b1latch); // should cover all quorums\n+\n+            final AtomicInteger i = new AtomicInteger(0xdeadbeef);\n+            AsyncCallback.AddCallback cb = new AsyncCallback.AddCallback() {\n+                    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                        i.set(rc);\n+                    }\n+                };\n+            lh.asyncAddEntry(entry, cb, null);\n+\n+            Thread.sleep(1000); // sleep a second to allow time to complete\n+            assertEquals(i.get(), 0xdeadbeef);\n+            b0latch.countDown();\n+            b1latch.countDown();\n+            Thread.sleep(2000);\n+            assertEquals(i.get(), BKException.Code.OK);\n+        } finally {\n+            b0latch.countDown();\n+            b1latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void testBookieFailureWithSlowBookie() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString()).setReadTimeout(5);\n+\n+        BookKeeper bkc = new BookKeeper(conf);\n+\n+        byte[] pwd = new byte[] {};\n+        final LedgerHandle lh = bkc.createLedger(4, 3, 2, BookKeeper.DigestType.CRC32, pwd);\n+        long lid = lh.getId();\n+        final AtomicBoolean finished = new AtomicBoolean(false);\n+        final AtomicBoolean failTest = new AtomicBoolean(false);\n+        final byte[] entry = \"Test Entry\".getBytes();\n+        Thread t = new Thread() {\n+                public void run() {\n+                    try {\n+                        while (!finished.get()) {\n+                            lh.addEntry(entry);\n+                        }\n+                    } catch (Exception e) {\n+                        LOG.error(\"Exception in add entry thread\", e);\n+                        failTest.set(true);\n+                    }\n+                }\n+            };\n+        t.start();\n+        final CountDownLatch b0latch = new CountDownLatch(1);\n+        startNewBookie();\n+        sleepBookie(getBookie(0), b0latch);\n+        Thread.sleep(10000);\n+        b0latch.countDown();\n+        finished.set(true);\n+        t.join();\n+\n+        assertFalse(failTest.get());\n+\n+        lh.close();\n+\n+        LedgerHandle lh2 = bkc.openLedger(lh.getId(), BookKeeper.DigestType.CRC32, pwd);\n+        LedgerChecker lc = new LedgerChecker(bkc);\n+        final CountDownLatch checklatch = new CountDownLatch(1);\n+        final AtomicInteger numFragments = new AtomicInteger(-1);\n+        lc.checkLedger(lh2, new GenericCallback<Set<LedgerFragment>>() {\n+                public void operationComplete(int rc, Set<LedgerFragment> fragments) {\n+                    LOG.debug(\"Checked ledgers returned {} {}\", rc, fragments);\n+                    if (rc == BKException.Code.OK) {\n+                        numFragments.set(fragments.size());\n+                    }\n+                    checklatch.countDown();\n+                }\n+            });\n+        checklatch.await();\n+        assertEquals(\"There should be no missing fragments\", 0, numFragments.get());\n+    }\n+\n+    @Test\n+    public void testManyBookieFailureWithSlowBookies() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString()).setReadTimeout(5);\n+\n+        BookKeeper bkc = new BookKeeper(conf);\n+\n+        byte[] pwd = new byte[] {};\n+        final LedgerHandle lh = bkc.createLedger(4, 3, 1, BookKeeper.DigestType.CRC32, pwd);\n+        long lid = lh.getId();\n+        final AtomicBoolean finished = new AtomicBoolean(false);\n+        final AtomicBoolean failTest = new AtomicBoolean(false);\n+        final byte[] entry = \"Test Entry\".getBytes();\n+        Thread t = new Thread() {\n+                public void run() {\n+                    try {\n+                        while (!finished.get()) {\n+                            lh.addEntry(entry);\n+                        }\n+                    } catch (Exception e) {\n+                        LOG.error(\"Exception in add entry thread\", e);\n+                        failTest.set(true);\n+                    }\n+                }\n+            };\n+        t.start();\n+        final CountDownLatch b0latch = new CountDownLatch(1);\n+        final CountDownLatch b1latch = new CountDownLatch(1);\n+\n+        startNewBookie();\n+        startNewBookie();\n+\n+        sleepBookie(getBookie(0), b0latch);\n+        sleepBookie(getBookie(1), b1latch);\n+\n+        Thread.sleep(10000);\n+        b0latch.countDown();\n+        b1latch.countDown();\n+        finished.set(true);\n+        t.join();\n+\n+        assertFalse(failTest.get());\n+\n+        lh.close();\n+\n+        LedgerHandle lh2 = bkc.openLedger(lh.getId(), BookKeeper.DigestType.CRC32, pwd);\n+        LedgerChecker lc = new LedgerChecker(bkc);\n+        final CountDownLatch checklatch = new CountDownLatch(1);\n+        final AtomicInteger numFragments = new AtomicInteger(-1);\n+        lc.checkLedger(lh2, new GenericCallback<Set<LedgerFragment>>() {\n+                public void operationComplete(int rc, Set<LedgerFragment> fragments) {\n+                    LOG.debug(\"Checked ledgers returned {} {}\", rc, fragments);\n+                    if (rc == BKException.Code.OK) {\n+                        numFragments.set(fragments.size());\n+                    }\n+                    checklatch.countDown();\n+                }\n+            });\n+        checklatch.await();\n+        assertEquals(\"There should be no missing fragments\", 0, numFragments.get());\n+    }\n+}"},{"sha":"d9f85d3ec4dcbcaa347190a96b7a5aa2f9ab9717","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -329,7 +329,7 @@ public void testSingleEntryAfterEnsembleChange() throws Exception {\n         ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n                 .getEnsembles().get(0L);\n         InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(\n-                lh.getDistributionSchedule().getBookieIndex(lh.getLastAddPushed(), 0));\n+                lh.getDistributionSchedule().getWriteSet(lh.getLastAddPushed()).get(0));\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);\n@@ -338,7 +338,7 @@ public void testSingleEntryAfterEnsembleChange() throws Exception {\n         lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n \n         lastBookieFromEnsemble = firstEnsemble.get(\n-                lh.getDistributionSchedule().getBookieIndex(lh.getLastAddPushed(), 1));\n+                lh.getDistributionSchedule().getWriteSet(lh.getLastAddPushed()).get(1));\n         LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n                 + firstEnsemble);\n         killBookie(lastBookieFromEnsemble);"},{"sha":"b38d01a2d106a52ea5de1ba5242bf7a7da45ddf1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -77,8 +77,7 @@ public void testReadTimeout() throws Exception {\n         final InetSocketAddress bookieToSleep \n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         int sleeptime = baseClientConf.getReadTimeout()*3;\n-        CountDownLatch latch = new CountDownLatch(1);\n-        sleepBookie(bookieToSleep, sleeptime, latch);\n+        CountDownLatch latch = sleepBookie(bookieToSleep, sleeptime);\n         latch.await();\n \n         writelh.asyncAddEntry(tmp.getBytes(), "},{"sha":"7ecf9374c63d06462c45fa4320368651a99f9391","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -56,7 +56,7 @@ public GcLedgersTest(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n     private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n         final AtomicInteger expected = new AtomicInteger(numLedgers);\n         for (int i=0; i<numLedgers; i++) {\n-            getLedgerManager().createLedger(new LedgerMetadata(1, 1, DigestType.MAC, \"\".getBytes()),\n+            getLedgerManager().createLedger(new LedgerMetadata(1, 1, 1, DigestType.MAC, \"\".getBytes()),\n                 new GenericCallback<Long>() {\n                 @Override\n                 public void operationComplete(int rc, Long ledgerId) {"},{"sha":"2f395361c8fd838327d6ed5244421466a52d4a6b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":49,"deletions":4,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/e353a8f93ad48d8785bbaa7162a8a9ebca40a15f/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=e353a8f93ad48d8785bbaa7162a8a9ebca40a15f","patch":"@@ -164,6 +164,17 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         return conf;\n     }\n \n+    /**\n+     * Get bookie address for bookie at index\n+     */\n+    public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n+        if (bs.size() <= index || index < 0) {\n+            throw new IllegalArgumentException(\"Invalid index, there are only \" + bs.size()\n+                                               + \" bookies. Asked for \" + index);\n+        }\n+        return bs.get(index).getLocalAddress();\n+    }\n+\n     /**\n      * Kill a bookie by its socket address\n      *\n@@ -216,14 +227,13 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n      *          Socket Address\n      * @param seconds\n      *          Sleep seconds\n-     * @param l\n-     *          Count Down Latch\n+     * @return Count Down latch which will be counted down when sleep finishes\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public void sleepBookie(InetSocketAddress addr, final int seconds,\n-                            final CountDownLatch l)\n+    public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n             throws InterruptedException, IOException {\n+        final CountDownLatch l = new CountDownLatch(1);\n         final String name = \"BookieJournal-\" + addr.getPort();\n         Thread[] allthreads = new Thread[Thread.activeCount()];\n         Thread.enumerate(allthreads);\n@@ -243,6 +253,41 @@ public void run() {\n                     }\n                 };\n                 sleeper.start();\n+                return l;\n+            }\n+        }\n+        throw new IOException(\"Bookie thread not found\");\n+    }\n+\n+    /**\n+     * Sleep a bookie until I count down the latch\n+     *\n+     * @param addr\n+     *          Socket Address\n+     * @param latch\n+     *          Latch to wait on\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+    public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n+            throws InterruptedException, IOException {\n+        final String name = \"BookieJournal-\" + addr.getPort();\n+        Thread[] allthreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allthreads);\n+        for (final Thread t : allthreads) {\n+            if (t.getName().equals(name)) {\n+                Thread sleeper = new Thread() {\n+                    public void run() {\n+                        try {\n+                            t.suspend();\n+                            l.await();\n+                            t.resume();\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error suspending thread\", e);\n+                        }\n+                    }\n+                };\n+                sleeper.start();\n                 return;\n             }\n         }"}]}

