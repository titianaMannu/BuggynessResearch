{"sha":"e3b52e82ccccf4807100db0950609ec7ede8378c","node_id":"MDY6Q29tbWl0MTU3NTk1NjplM2I1MmU4MmNjY2NmNDgwNzEwMGRiMDk1MDYwOWVjN2VkZTgzNzhj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-29T22:29:42Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-29T22:29:42Z"},"message":"BOOKKEEPER-120: Review BookKeeper client documentation (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208111 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3f6e697abc77860728c6f470ae4801c19b0f01b8","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3f6e697abc77860728c6f470ae4801c19b0f01b8"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e3b52e82ccccf4807100db0950609ec7ede8378c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e3b52e82ccccf4807100db0950609ec7ede8378c","html_url":"https://github.com/apache/bookkeeper/commit/e3b52e82ccccf4807100db0950609ec7ede8378c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e3b52e82ccccf4807100db0950609ec7ede8378c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"aa1d8296672a1a29fdc3de630f5995c0d1a21429","url":"https://api.github.com/repos/apache/bookkeeper/commits/aa1d8296672a1a29fdc3de630f5995c0d1a21429","html_url":"https://github.com/apache/bookkeeper/commit/aa1d8296672a1a29fdc3de630f5995c0d1a21429"}],"stats":{"total":275,"additions":56,"deletions":219},"files":[{"sha":"8d4f6dd41614948b19f20c502a01d14f62d8d0f0","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e3b52e82ccccf4807100db0950609ec7ede8378c/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e3b52e82ccccf4807100db0950609ec7ede8378c/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e3b52e82ccccf4807100db0950609ec7ede8378c","patch":"@@ -14,6 +14,8 @@ BUGFIXES:\n  \n  BOOKKEEPER-127: Make poms use official zookeeper 3.4.0 (ivank)\n \n+ BOOKKEEPER-120: Review BookKeeper client documentation (ivank)\n+\n  bookkeeper-server/\n \n   BOOKKEEPER-1: Static variable makes tests fail (fpj via ivank)"},{"sha":"4a1b3c058a67280e523d6293ac665b1a5bfb53b5","filename":"doc/bookkeeperProgrammer.textile","status":"modified","additions":54,"deletions":219,"changes":273,"blob_url":"https://github.com/apache/bookkeeper/blob/e3b52e82ccccf4807100db0950609ec7ede8378c/doc/bookkeeperProgrammer.textile","raw_url":"https://github.com/apache/bookkeeper/raw/e3b52e82ccccf4807100db0950609ec7ede8378c/doc/bookkeeperProgrammer.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperProgrammer.textile?ref=e3b52e82ccccf4807100db0950609ec7ede8378c","patch":"@@ -12,253 +12,88 @@ Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n \n h1. Abstract\n \n-This guide contains detailed information about using BookKeeper for logging. It discusses the basic operations BookKeeper supports, and how to create logs and perform basic read and write operations on these logs.\n+This guide contains detailed information about using BookKeeper for write ahead logging. It discusses the basic operations BookKeeper supports, and how to create logs and perform basic read and write operations on these logs. The main classes used by BookKeeper client are \"BookKeeper\":./apidocs/org/apache/bookkeeper/client/BookKeeper.html and \"LedgerHandle\":./apidocs/org/apache/bookkeeper/client/LedgerHandle.html. \n \n-h1.  Instantiating BookKeeper.\n+BookKeeper is the main client used to create, open and delete ledgers. A ledger is a log file in BookKeeper, which contains a sequence of entries. Only the client which creates a ledger can write to it. A LedgerHandle represents the ledger to the client, and allows the client to read and write entries. When the client is finished writing they can close the LedgerHandle. Once a ledger has been closed, all client who read from it are guaranteed to read the exact same entries in the exact same order. All methods of BookKeeper and LedgerHandle have synchronous and asynchronous versions. Internally the synchronous versions are implemented using the asynchronous.\n \n-p. The first step to use BookKeeper is to instantiate a BookKeeper object: \n+h1.  Instantiating BookKeeper\n \n- @org.apache.bookkeeper.BookKeeper @ \n+To create a BookKeeper client, you need to create a configuration object and set the address of the ZooKeeper ensemble in use. For example, if you were using @zk1.example.com:2181,zk2.example.com:2181,zk3.example.com:2181@ as your ensemble, you would create the BookKeeper client as follows.\n \n-p. There are three BookKeeper constructors: \n+<pre><code>\n+ClientConfiguration conf = new ClientConfiguration();\n+conf.setZkServers(\"zk1.example.com:2181,zk2.example.com:2181,zk3.example.com:2181\"); \n \n- @public BookKeeper(String servers) throws KeeperException, IOException @ \n+BookKeeper client = new BookKeeper(conf);\n+</code></pre>\n \n-p. where: \n+It is important to close the client once you are finished working with it. The set calls on ClientConfiguration are chainable, so instead of putting a set* call on a new line as above, it is possible to make a number of calls on the one line. For example;\n \n-*  @servers@ is a comma-separated list of ZooKeeper servers. \n+<pre><code>\n+ClientConfiguration conf = new ClientConfiguration().setZkServers(\"localhost:2181\").setZkTimeout(5000);\n+</code></pre>\n \n+There is also a useful shortcut constructor which allows you to pass the zookeeper ensemble string directly to BookKeeper.\n+<pre><code>\n+BookKeeper client = new BookKeeper(\"localhost:2181\");\n+</code></pre>\n \n- @public BookKeeper(ZooKeeper zk) throws InterruptedException, KeeperException @ \n+See \"BookKeeper\":./apidocs/org/apache/bookkeeper/client/BookKeeper.html for the full api.\n \n-p. where: \n \n-*  @zk@ is a ZooKeeper object. This constructor is useful when the application also using ZooKeeper and wants to have a single instance of ZooKeeper. \n+h1.  Creating a ledger\n \n+p. Before writing entries to BookKeeper, it is necessary to create a ledger. Before creating the ledger you must decide the ensemble size and the quorum size. \n \n- @public BookKeeper(ZooKeeper zk, ClientSocketChannelFactory channelFactory) throws InterruptedException, KeeperException @ \n+p. The ensemble size is the number of Bookies over which entries will be striped. The quorum size is the number of bookies which an entry will be written to. Striping is done in a round robin fashion. For example, if you have an ensemble size of 3 (consisting of bk1, bk2 & bk3), and a quorum of 2, entry 1 will be written to bk1 & bk2, entry 2 will be written to bk2 & bk3, entry 3 will be written to bk3 & bk1 and so on.\n \n-p. where: \n+p. Ledgers are also created with a digest type and password. The digest type is used to generate a checksum so that when reading entries we can ensure that the content is the same as what was written. The password is used as an access control mechanism.\n \n-*  @zk@ is a ZooKeeper object. This constructor is useful when the application also using ZooKeeper and wants to have a single instance of ZooKeeper. \n-*  @channelFactory@ is a netty channel object ( @org.jboss.netty.channel.socket@ ). \n+p. To create a ledger, with ensemble size 3, quorum size 2, using a CRC to checksum and \"foobar\" as the password, do the following:\n \n+<pre><code>\n+LedgerHandle lh = client.createLedger(3, 2, DigestType.CRC32, \"foobar\");\n+</code></pre>\n \n-h1.  Creating a ledger. \n+You can now write to this ledger handle. As you probably plan to read the ledger at some stage, now is a good time to store the id of the ledger somewhere. The ledger id is a long, and can be obtained with @lh.getId()@.\n \n-p. Before writing entries to BookKeeper, it is necessary to create a ledger. With the current BookKeeper API, it is possible to create a ledger both synchronously or asynchronously. The following methods belong to @org.apache.bookkeeper.client.BookKeeper@ . \n+h1.  Adding entries to a ledger\n \n- _Synchronous call:_ \n+p. Once you have obtained a ledger handle, you can start adding entries to it. Entries are simply arrays of bytes. As such, adding entries to the ledger is rather simple.\n \n- @public LedgerHandle createLedger(int ensSize, int qSize, DigestType type,  byte passwd[]) throws KeeperException, InterruptedException, IOException, BKException @ \n+<pre><code>\n+lh.addEntry(\"Hello World!\".getBytes());\n+</code></pre>\n \n-p. where: \n+h1.  Closing a ledger\n \n-*  @ensSize@ is the number of bookies (ensemble size); \n-*  @qSize@ is the write quorum size; \n-*  @type@ is the type of digest used with entries: either MAC or CRC32. \n-*  @passwd@ is a password that authorizes the client to write to the ledger being created. \n+p. Once a client is done writing, it can closes the ledger. Closing the ledger is a very important step in BookKeeper, as once a ledger is closed, all reading clients are guaranteed to read the same sequence of entries in the same order. Closing takes no parameters. \n \n+<pre><code>\n+lh.close();\n+</code></pre>\n \n-p. All further operations on a ledger are invoked through the @LedgerHandle@ object returned. \n+h1.  Opening a ledger\n \n-p. As a convenience, we provide a @createLedger@ with default parameters (3,2,VERIFIABLE), and the only two input parameters it requires are a digest type and a password. \n+To read from a ledger, a client must open it first. To open a ledger you must know its ID, which digest type was used when creating it, and its password. To open the ledger we created above, assuming it has ID 1;\n \n- _Asynchronous call:_ \n+<pre><code>\n+LedgerHandle lh2 = client.openLedger(1, DigestType.CRC32, \"foobar\");\n+</code></pre>\n \n- @public void asyncCreateLedger(int ensSize, int qSize, DigestType type, byte passwd[], CreateCallback cb, Object ctx ) @ \n+You can now read entries from the ledger. Any attempt to write to this handle will throw an exception.\n \n-p. The parameters are the same of the synchronous version, with the exception of @cb@ and @ctx@ . @CreateCallback@ is an interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @createComplete@ that has the following signature: \n+bq. NOTE: Opening a ledger, which another client already has open for writing will prevent that client from writing any new entries to it. If you do not wish this to happen, you should use the openLedgerNoRecovery method. However, keep in mind that without recovery, you lose the guarantees of what entries are in the ledger. You should only use openLedgerNoRecovery if you know what you are doing.\n \n- @void createComplete(int rc, LedgerHandle lh, Object ctx); @ \n+h1. Reading entries from a ledger\n \n-p. where: \n+p. Now that you have an open ledger, you can read entries from it. You can use @getLastAddConfirmed@ to get the id of the last entry in the ledger.\n \n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKException@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @ctx@ is a control object for accountability purposes. It can be essentially any object the application is happy with. \n-\n-\n-p. The @ctx@ object passed as a parameter to the call to create a ledger is the one same returned in the callback. \n-\n-h1.  Adding entries to a ledger. \n-\n-p. Once we have a ledger handle @lh@ obtained through a call to create a ledger, we can start writing entries. As with creating ledgers, we can write both synchronously and asynchronously. The following methods belong to @org.apache.bookkeeper.client.LedgerHandle@ . \n-\n- _Synchronous call:_ \n-\n- @public long addEntry(byte[] data) throws InterruptedException @ \n-\n-p. where: \n-\n-*  @data@ is a byte array; \n-\n-\n-p. A call to @addEntry@ returns the status of the operation (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-\n- _Asynchronous call:_ \n-\n- @public void asyncAddEntry(byte[] data, AddCallback cb, Object ctx) @ \n-\n-p. It also takes a byte array as the sequence of bytes to be stored as an entry. Additionaly, it takes a callback object @cb@ and a control object @ctx@ . The callback object must implement the @AddCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @addComplete@ that has the following signature: \n-\n- @void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx); @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @entryId@ is the identifier of entry associated with this request; \n-*  @ctx@ is control object used for accountability purposes. It can be any object the application is happy with. \n-\n-\n-h1.  Closing a ledger. \n-\n-p. Once a client is done writing, it closes the ledger. The following methods belong to @org.apache.bookkeeper.client.LedgerHandle@ . \n-\n- _Synchronous close:_ \n-\n- @public void close() throws InterruptedException @ \n-\n-p. It takes no input parameters. \n-\n- _Asynchronous close:_ \n-\n- @public void asyncClose(CloseCallback cb, Object ctx) throws InterruptedException @ \n-\n-p. It takes a callback object @cb@ and a control object @ctx@ . The callback object must implement the @CloseCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @closeComplete@ that has the following signature: \n-\n- @void closeComplete(int rc, LedgerHandle lh, Object ctx) @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @ctx@ is control object used for accountability purposes. \n-\n-\n-h1.  Opening a ledger. \n-\n-p. To read from a ledger, a client must open it first. The following methods belong to @org.apache.bookkeeper.client.BookKeeper@ . \n-\n- _Synchronous open:_ \n-\n- @public LedgerHandle openLedger(long lId, DigestType type, byte passwd[]) throws InterruptedException, BKException @ \n-\n-*  @lId@ is the ledger identifier; \n-*  @type@ is the type of digest used with entries: either MAC or CRC32. \n-*  @passwd@ is a password to access the ledger (used only in the case of @VERIFIABLE@ ledgers); \n-\n-\n- _Asynchronous open:_ \n-\n- @public void asyncOpenLedger(long lId, DigestType type, byte passwd[], OpenCallback cb, Object ctx) @ \n-\n-p. It also takes a a ledger identifier and a password. Additionaly, it takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @OpenCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @openComplete@ that has the following signature: \n-\n- @public void openComplete(int rc, LedgerHandle lh, Object ctx) @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @ctx@ is control object used for accountability purposes. \n-\n-p. The two calls above to open a ledger recover the ledger if it has not been closed properly before it reads entries from it. It is also possible to open a ledger and read from it without triggering the recovery process with the following methods of @org.apache.bookkeeper.client.BookKeeper@ . \n-\n- _Synchronous open:_ \n-\n- @public LedgerHandle openLedgerNoRecovery(long lId, DigestType type, byte passwd[]) throws InterruptedException, BKException @ \n-\n-*  @lId@ is the ledger identifier; \n-*  @type@ is the type of digest used with entries: either MAC or CRC32. \n-*  @passwd@ is a password to access the ledger (used only in the case of @VERIFIABLE@ ledgers); \n-\n-\n- _Asynchronous open:_ \n-\n- @public void asyncOpenLedgerNoRecovery(long lId, DigestType type, byte passwd[], OpenCallback cb, Object ctx) @ \n-\n-p. It also takes a a ledger identifier and a password. Additionaly, it takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @OpenCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @openComplete@ that has the following signature: \n-\n- @public void openComplete(int rc, LedgerHandle lh, Object ctx) @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @ctx@ is control object used for accountability purposes. \n-\n-h1.  Reading from ledger \n-\n-p. Read calls may request one or more consecutive entries. The following methods belong to @org.apache.bookkeeper.client.LedgerHandle@ . \n-\n- _Synchronous read:_ \n-\n- @public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry) throws InterruptedException, BKException @ \n-\n-*  @firstEntry@ is the identifier of the first entry in the sequence of entries to read; \n-*  @lastEntry@ is the identifier of the last entry in the sequence of entries to read. \n-\n-\n- _Asynchronous read:_ \n-\n- @public void asyncReadEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) throws BKException, InterruptedException @ \n-\n-p. It also takes a first and a last entry identifiers. Additionaly, it takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @ReadCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @readComplete@ that has the following signature: \n-\n- @void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lh@ is a @LedgerHandle@ object to manipulate a ledger; \n-*  @seq@ is a @Enumeration<LedgerEntry>@ object to containing the list of entries requested; \n-*  @ctx@ is control object used for accountability purposes. \n-\n-\n-h1.  Deleting a ledger \n-\n-p. Once a client is done with a ledger and is sure that nobody will ever need to read from it again, they can delete the ledger. The following methods belong to @org.apache.bookkeeper.client.BookKeeper@ . \n-\n- _Synchronous delete:_ \n-\n- @public void deleteLedger(long lId) throws InterruptedException, BKException @ \n-\n-*  @lId@ is the ledger identifier; \n-\n-\n- _Asynchronous delete:_ \n-\n- @public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) @ \n-\n-p. It takes a ledger identifier. Additionally, it takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @DeleteCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @deleteComplete@ that has the following signature: \n-\n- @void deleteComplete(int rc, Object ctx) @ \n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @ctx@ is control object used for accountability purposes. \n-\n-h1.  Reading the last confirmed entry from a ledger \n-\n-p. When reading from an open ledger (opening without recovery enables it), it is often necessary to read the last confirmed hint that the writer client writes along with every entry. The general idea is to obtain the hint from a quorum and return the largest value. The following methods belong to @org.apache.bookkeeper.client.BookKeeper@ . \n-\n- _Synchronous read:_ \n-\n- @public long readLastConfirmed() @ \n-\n- _Asynchronous read:_ \n-\n- @public void asyncReadLastConfirmed(ReadLastConfirmedComplete cb, Object ctx) @ \n- \n-p. It takes a callback object  @cb@ and a control object @ctx@ . The callback object must implement the @ReadLastConfirmedCallback@ interface in @org.apache.bookkeeper.client.AsyncCallback@ , and a class implementing it has to implement a method called @readLastConfirmedComplete@ that has the following signature: \n-\n-@public void readLastConfirmedComplete (int rc, long lastConfirmed, Object ctx) @\n-\n-p. where: \n-\n-*  @rc@ is a return code (please refer to @org.apache.bookeeper.client.BKDefs@ for a list); \n-*  @lastConfirmed@ is the maximum last confirmed hint received among a quorum of bookies; \n-*  @ctx@ is control object used for accountability purposes. \n\\ No newline at end of file\n+<pre><code>\n+long lastEntry = lh2.getLastAddConfirmed();\n+Enumeration<LedgerEntry> entries = lh2.readEntries(0, 9);\n+while (entries.hasMoreElements()) {\n+\tbyte[] bytes = entries.nextElement().getEntry();\n+\tSystem.out.println(new String(bytes));\n+}\n+</code></pre>\n\\ No newline at end of file"}]}

