{"sha":"e5b0dd0d9e47394202f5a20cedf409f487d90beb","node_id":"MDY6Q29tbWl0MTU3NTk1NjplNWIwZGQwZDllNDczOTQyMDJmNWEyMGNlZGY0MDlmNDg3ZDkwYmVi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-18T11:00:49Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-12-18T11:00:49Z"},"message":"BOOKKEEPER-496: Ensure that the auditor and replication worker will shutdown if they lose their ZK session (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1423409 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e865bb161b39183058a19e9e6716fc86436526a9","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e865bb161b39183058a19e9e6716fc86436526a9"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e5b0dd0d9e47394202f5a20cedf409f487d90beb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e5b0dd0d9e47394202f5a20cedf409f487d90beb","html_url":"https://github.com/apache/bookkeeper/commit/e5b0dd0d9e47394202f5a20cedf409f487d90beb","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e5b0dd0d9e47394202f5a20cedf409f487d90beb/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a4d8a34fb0779551208ad003b950e0b9a9d86d42","url":"https://api.github.com/repos/apache/bookkeeper/commits/a4d8a34fb0779551208ad003b950e0b9a9d86d42","html_url":"https://github.com/apache/bookkeeper/commit/a4d8a34fb0779551208ad003b950e0b9a9d86d42"}],"stats":{"total":608,"additions":388,"deletions":220},"files":[{"sha":"6e4a91dc66b70542ff7f23e399a4e85e04d2ca48","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -146,6 +146,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-509: TestBookKeeperPersistenceManager failed on latest trunk (sijie via ivank)\n \n+        BOOKKEEPER-496: Ensure that the auditor and replication worker will shutdown if they lose their ZK session (ivank)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"e4be15250f6a5cd34592e4ad40a32a16599ba2a8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -191,7 +191,7 @@ private long getLedgerId(String path) throws NumberFormatException {\n         }\n     }\n \n-    private String getParentZnodePath(String base, long ledgerId) {\n+    public static String getParentZnodePath(String base, long ledgerId) {\n         String subdir1 = String.format(\"%04x\", ledgerId >> 48 & 0xffff);\n         String subdir2 = String.format(\"%04x\", ledgerId >> 32 & 0xffff);\n         String subdir3 = String.format(\"%04x\", ledgerId >> 16 & 0xffff);\n@@ -201,8 +201,12 @@ private String getParentZnodePath(String base, long ledgerId) {\n                              base, subdir1, subdir2, subdir3, subdir4);\n     }\n \n+    public static String getUrLedgerZnode(String base, long ledgerId) {\n+        return String.format(\"%s/urL%010d\", getParentZnodePath(base, ledgerId), ledgerId);\n+    }\n+\n     private String getUrLedgerZnode(long ledgerId) {\n-        return String.format(\"%s/urL%010d\", getParentZnodePath(urLedgerPath, ledgerId), ledgerId);\n+        return getUrLedgerZnode(urLedgerPath, ledgerId);\n     }\n \n \n@@ -376,7 +380,9 @@ public long getLedgerToRereplicate() throws ReplicationException.UnavailableExce\n                         public void process(WatchedEvent e) {\n                             if (e.getType() == Watcher.Event.EventType.NodeChildrenChanged\n                                 || e.getType() == Watcher.Event.EventType.NodeDeleted\n-                                || e.getType() == Watcher.Event.EventType.NodeCreated) {\n+                                || e.getType() == Watcher.Event.EventType.NodeCreated\n+                                || e.getState() == Watcher.Event.KeeperState.Expired\n+                                || e.getState() == Watcher.Event.KeeperState.Disconnected) {\n                                 changedLatch.countDown();\n                             }\n                         }"},{"sha":"30bbebe008f0c9ab70b1e3a1881f89280567bfd1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":115,"deletions":62,"changes":177,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -23,9 +23,13 @@\n import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n+import java.util.ArrayList;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n@@ -39,6 +43,7 @@\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -49,22 +54,30 @@\n  * re-replication activities by keeping all the corresponding ledgers of the\n  * failed bookie as underreplicated znode in zk.\n  */\n-public class Auditor extends Thread implements Watcher {\n+public class Auditor implements Watcher {\n     private static final Logger LOG = LoggerFactory.getLogger(Auditor.class);\n-    private final LinkedBlockingQueue<EventType> bookieNotifications = new LinkedBlockingQueue<EventType>();\n+\n     private final AbstractConfiguration conf;\n     private final ZooKeeper zkc;\n     private BookieLedgerIndexer bookieLedgerIndexer;\n     private LedgerUnderreplicationManager ledgerUnderreplicationManager;\n-    private volatile boolean running = true;\n+    private final ExecutorService executor;\n+    private List<String> knownBookies = new ArrayList<String>();\n \n-    public Auditor(String bookieIdentifier, AbstractConfiguration conf,\n+    public Auditor(final String bookieIdentifier, AbstractConfiguration conf,\n             ZooKeeper zkc) throws UnavailableException {\n-        setName(\"AuditorBookie-\" + bookieIdentifier);\n-        setDaemon(true);\n         this.conf = conf;\n         this.zkc = zkc;\n         initialize(conf, zkc);\n+\n+        executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    Thread t = new Thread(r, \"AuditorBookie-\" + bookieIdentifier);\n+                    t.setDaemon(true);\n+                    return t;\n+                }\n+            });\n     }\n \n     private void initialize(AbstractConfiguration conf, ZooKeeper zkc)\n@@ -94,53 +107,91 @@ private void initialize(AbstractConfiguration conf, ZooKeeper zkc)\n         }\n     }\n \n-    @Override\n-    public void run() {\n-        LOG.info(\"I'm starting as Auditor Bookie\");\n-        try {\n-            // on startup watching available bookie and based on the\n-            // available bookies determining the bookie failures.\n-            List<String> knownBookies = getAvailableBookies();\n-            auditingBookies(knownBookies);\n-\n-            while (true) {\n-                // wait for bookie join/failure notifications\n-                bookieNotifications.take();\n-\n-                // check whether ledger replication is enabled\n-                waitIfLedgerReplicationDisabled();\n-\n-                List<String> availableBookies = getAvailableBookies();\n-\n-                // casting to String, as knownBookies and availableBookies\n-                // contains only String values\n-                // find new bookies(if any) and update the known bookie list\n-                Collection<String> newBookies = CollectionUtils.subtract(\n-                        availableBookies, knownBookies);\n-                knownBookies.addAll(newBookies);\n-\n-                // find lost bookies(if any)\n-                Collection<String> lostBookies = CollectionUtils.subtract(\n-                        knownBookies, availableBookies);\n-\n-                if (lostBookies.size() > 0) {\n-                    knownBookies.removeAll(lostBookies);\n-                    Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n-                    handleLostBookies(lostBookies, ledgerDetails);\n-                }\n+    private void submitShutdownTask() {\n+        synchronized (this) {\n+            if (executor.isShutdown()) {\n+                return;\n             }\n-        } catch (KeeperException ke) {\n-            LOG.error(\"Exception while watching available bookies\", ke);\n-        } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt();\n-            LOG.error(\"Interrupted while watching available bookies \", ie);\n-        } catch (BKAuditException bke) {\n-            LOG.error(\"Exception while watching available bookies\", bke);\n-        } catch (UnavailableException ue) {\n-            LOG.error(\"Exception while watching available bookies\", ue);\n+            executor.submit(new Runnable() {\n+                    public void run() {\n+                        synchronized (Auditor.this) {\n+                            executor.shutdown();\n+                        }\n+                    }\n+                });\n+        }\n+    }\n+\n+    private synchronized void submitAuditTask() {\n+        synchronized (this) {\n+            if (executor.isShutdown()) {\n+                return;\n+            }\n+            executor.submit(new Runnable() {\n+                    public void run() {\n+                        try {\n+                            waitIfLedgerReplicationDisabled();\n+\n+                            List<String> availableBookies = getAvailableBookies();\n+\n+                            // casting to String, as knownBookies and availableBookies\n+                            // contains only String values\n+                            // find new bookies(if any) and update the known bookie list\n+                            Collection<String> newBookies = CollectionUtils.subtract(\n+                                    availableBookies, knownBookies);\n+                            knownBookies.addAll(newBookies);\n+\n+                            // find lost bookies(if any)\n+                            Collection<String> lostBookies = CollectionUtils.subtract(\n+                                    knownBookies, availableBookies);\n+\n+                            if (lostBookies.size() > 0) {\n+                                knownBookies.removeAll(lostBookies);\n+                                Map<String, Set<Long>> ledgerDetails = generateBookie2LedgersIndex();\n+                                handleLostBookies(lostBookies, ledgerDetails);\n+                            }\n+                        } catch (KeeperException ke) {\n+                            LOG.error(\"Exception while watching available bookies\", ke);\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();\n+                            LOG.error(\"Interrupted while watching available bookies \", ie);\n+                        } catch (BKAuditException bke) {\n+                            LOG.error(\"Exception while watching available bookies\", bke);\n+                        } catch (UnavailableException ue) {\n+                            LOG.error(\"Exception while watching available bookies\", ue);\n+                        }\n+                    }\n+                });\n         }\n+    }\n \n-        shutdown();\n+    public void start() {\n+        LOG.info(\"I'm starting as Auditor Bookie\");\n+        // on startup watching available bookie and based on the\n+        // available bookies determining the bookie failures.\n+        synchronized (this) {\n+            if (executor.isShutdown()) {\n+                return;\n+            }\n+            executor.submit(new Runnable() {\n+                    public void run() {\n+                        try {\n+                            knownBookies = getAvailableBookies();\n+                            auditingBookies(knownBookies);\n+                        } catch (KeeperException ke) {\n+                            LOG.error(\"Exception while watching available bookies\", ke);\n+                            submitShutdownTask();\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();\n+                            LOG.error(\"Interrupted while watching available bookies \", ie);\n+                            submitShutdownTask();\n+                        } catch (BKAuditException bke) {\n+                            LOG.error(\"Exception while watching available bookies\", bke);\n+                            submitShutdownTask();\n+                        }\n+                    }\n+                });\n+        }\n     }\n \n     private void waitIfLedgerReplicationDisabled() throws UnavailableException,\n@@ -214,24 +265,26 @@ private void publishSuspectedLedgers(String bookieIP, Set<Long> ledgers)\n     @Override\n     public void process(WatchedEvent event) {\n         // listen children changed event from ZooKeeper\n-        if (event.getType() == EventType.NodeChildrenChanged) {\n-            if (running)\n-                bookieNotifications.add(event.getType());\n+        if (event.getState() == KeeperState.Disconnected\n+                || event.getState() == KeeperState.Expired) {\n+            submitShutdownTask();\n+        } else if (event.getType() == EventType.NodeChildrenChanged) {\n+            submitAuditTask();\n         }\n     }\n \n     /**\n      * Shutdown the auditor\n      */\n     public void shutdown() {\n-        if (!running) {\n-            return;\n-        }\n-        running = false;\n-        LOG.info(\"Shutting down \" + getName());\n-        this.interrupt();\n+        LOG.info(\"Shutting down auditor\");\n+        submitShutdownTask();\n+\n         try {\n-            this.join();\n+            while (!executor.awaitTermination(30, TimeUnit.SECONDS)) {\n+                LOG.warn(\"Executor not shutting down, interrupting\");\n+                executor.shutdownNow();\n+            }\n         } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n             LOG.warn(\"Interrupted while shutting down auditor bookie\", ie);\n@@ -244,6 +297,6 @@ public void shutdown() {\n      * @return auditor status\n      */\n     public boolean isRunning() {\n-        return running;\n+        return !executor.isShutdown();\n     }\n }"},{"sha":"2b8fa3bd39cd242fa039f554bfa4ea9c980efbe8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","status":"modified","additions":127,"deletions":82,"changes":209,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -26,6 +26,12 @@\n import java.io.Serializable;\n \n import org.apache.bookkeeper.proto.DataFormats.AuditorVoteFormat;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n@@ -36,6 +42,7 @@\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.apache.zookeeper.ZooDefs.Ids;\n import com.google.protobuf.TextFormat;\n import static com.google.common.base.Charsets.UTF_8;\n@@ -69,10 +76,12 @@\n     private final String bookieId;\n     private final AbstractConfiguration conf;\n     private final ZooKeeper zkc;\n+    private final ExecutorService executor;\n \n     private String myVote;\n     Auditor auditor;\n-    private volatile boolean running = true;\n+    private AtomicBoolean running = new AtomicBoolean(false);\n+\n \n     /**\n      * AuditorElector for performing the auditor election\n@@ -86,74 +95,24 @@\n      * @throws UnavailableException\n      *             throws unavailable exception while initializing the elector\n      */\n-    public AuditorElector(String bookieId, AbstractConfiguration conf,\n-            ZooKeeper zkc) throws UnavailableException {\n+    public AuditorElector(final String bookieId, AbstractConfiguration conf,\n+                          ZooKeeper zkc) throws UnavailableException {\n         this.bookieId = bookieId;\n         this.conf = conf;\n         this.zkc = zkc;\n         basePath = conf.getZkLedgersRootPath() + '/'\n                 + BookKeeperConstants.UNDER_REPLICATION_NODE;\n         electionPath = basePath + \"/auditorelection\";\n         createElectorPath();\n+        executor = Executors.newSingleThreadExecutor(new ThreadFactory() {\n+                @Override\n+                public Thread newThread(Runnable r) {\n+                    return new Thread(r, \"AuditorElector-\"+bookieId);\n+                }\n+            });\n     }\n \n-    /**\n-     * Performing the auditor election using the ZooKeeper ephemeral sequential\n-     * znode. The bookie which has created the least sequential will be elect as\n-     * Auditor.\n-     * \n-     * @throws UnavailableException\n-     *             when performing auditor election\n-     * \n-     */\n-    public void doElection() throws UnavailableException {\n-        try {\n-            // creating my vote in zk. Vote format is 'V_numeric'\n-            createMyVote();\n-            List<String> children = zkc.getChildren(getVotePath(\"\"), false);\n-\n-            if (0 >= children.size()) {\n-                throw new IllegalArgumentException(\n-                        \"Atleast one bookie server should present to elect the Auditor!\");\n-            }\n-\n-            // sorting in ascending order of sequential number\n-            Collections.sort(children, new ElectionComparator());\n-            String voteNode = StringUtils.substringAfterLast(myVote,\n-                    PATH_SEPARATOR);\n \n-            // starting Auditing service\n-            if (children.get(AUDITOR_INDEX).equals(voteNode)) {\n-                // update the auditor bookie id in the election path. This is\n-                // done for debugging purpose\n-                AuditorVoteFormat.Builder builder = AuditorVoteFormat.newBuilder()\n-                    .setBookieId(bookieId);\n-\n-                zkc.setData(getVotePath(\"\"), TextFormat.printToString(builder.build()).getBytes(UTF_8), -1);\n-                auditor = new Auditor(bookieId, conf, zkc);\n-                auditor.start();\n-            } else {\n-                // If not an auditor, will be watching to my predecessor and\n-                // looking the previous node deletion.\n-                Watcher electionWatcher = new ElectionWatcher();\n-                int myIndex = children.indexOf(voteNode);\n-                int prevNodeIndex = myIndex - 1;\n-                if (null == zkc.exists(getVotePath(PATH_SEPARATOR)\n-                        + children.get(prevNodeIndex), electionWatcher)) {\n-                    // While adding, the previous znode doesn't exists.\n-                    // Again going to election.\n-                    doElection();\n-                }\n-            }\n-        } catch (KeeperException e) {\n-            throw new UnavailableException(\n-                    \"Exception while performing auditor election\", e);\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new UnavailableException(\n-                    \"Interrupted while performing auditor election\", e);\n-        }\n-    }\n \n     private void createMyVote() throws KeeperException, InterruptedException {\n         if (null == myVote || null == zkc.exists(myVote, false)) {\n@@ -202,38 +161,124 @@ private void createElectorPath() throws UnavailableException {\n      * deletion or expiration.\n      */\n     private class ElectionWatcher implements Watcher {\n-\n         @Override\n         public void process(WatchedEvent event) {\n-            if (event.getType() == EventType.NodeDeleted) {\n-                try {\n-                    doElection();\n-                } catch (UnavailableException e) {\n-                    LOG.error(\"Exception when performing Auditor re-election\",\n-                            e);\n-                    shutdown();\n-                }\n+            if (event.getState() == KeeperState.Disconnected\n+                || event.getState() == KeeperState.Expired) {\n+                LOG.error(\"Lost ZK connection, shutting down\");\n+                submitShutdownTask();\n+            } else if (event.getType() == EventType.NodeDeleted) {\n+                submitElectionTask();\n             }\n         }\n     }\n \n+    public void start() {\n+        running.set(true);\n+        submitElectionTask();\n+    }\n+\n+    /**\n+     * Run cleanup operations for the auditor elector.\n+     */\n+    private void submitShutdownTask() {\n+        executor.submit(new Runnable() {\n+                public void run() {\n+                    if (!running.compareAndSet(true, false)) {\n+                        return;\n+                    }\n+                    LOG.info(\"Shutting down AuditorElector\");\n+                    if (myVote != null) {\n+                        try {\n+                            zkc.delete(myVote, -1);\n+                        } catch (InterruptedException ie) {\n+                            LOG.warn(\"InterruptedException while deleting myVote: \" + myVote,\n+                                     ie);\n+                        } catch (KeeperException ke) {\n+                            LOG.error(\"Exception while deleting myVote:\" + myVote, ke);\n+                        }\n+                    }\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Performing the auditor election using the ZooKeeper ephemeral sequential\n+     * znode. The bookie which has created the least sequential will be elect as\n+     * Auditor.\n+     */\n+    @VisibleForTesting\n+    void submitElectionTask() {\n+\n+        Runnable r = new Runnable() {\n+                public void run() {\n+                    try {\n+                        // creating my vote in zk. Vote format is 'V_numeric'\n+                        createMyVote();\n+                        List<String> children = zkc.getChildren(getVotePath(\"\"), false);\n+\n+                        if (0 >= children.size()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Atleast one bookie server should present to elect the Auditor!\");\n+                        }\n+\n+                        // sorting in ascending order of sequential number\n+                        Collections.sort(children, new ElectionComparator());\n+                        String voteNode = StringUtils.substringAfterLast(myVote,\n+                                                                         PATH_SEPARATOR);\n+\n+                        // starting Auditing service\n+                        if (children.get(AUDITOR_INDEX).equals(voteNode)) {\n+                            // update the auditor bookie id in the election path. This is\n+                            // done for debugging purpose\n+                            AuditorVoteFormat.Builder builder = AuditorVoteFormat.newBuilder()\n+                                .setBookieId(bookieId);\n+\n+                            zkc.setData(getVotePath(\"\"),\n+                                        TextFormat.printToString(builder.build()).getBytes(UTF_8), -1);\n+                            auditor = new Auditor(bookieId, conf, zkc);\n+                            auditor.start();\n+                        } else {\n+                            // If not an auditor, will be watching to my predecessor and\n+                            // looking the previous node deletion.\n+                            Watcher electionWatcher = new ElectionWatcher();\n+                            int myIndex = children.indexOf(voteNode);\n+                            int prevNodeIndex = myIndex - 1;\n+                            if (null == zkc.exists(getVotePath(PATH_SEPARATOR)\n+                                                   + children.get(prevNodeIndex), electionWatcher)) {\n+                                // While adding, the previous znode doesn't exists.\n+                                // Again going to election.\n+                                submitElectionTask();\n+                            }\n+                        }\n+                    } catch (KeeperException e) {\n+                        LOG.error(\"Exception while performing auditor election\", e);\n+                        submitShutdownTask();\n+                    } catch (InterruptedException e) {\n+                        LOG.error(\"Interrupted while performing auditor election\", e);\n+                        Thread.currentThread().interrupt();\n+                        submitShutdownTask();\n+                    } catch (UnavailableException e) {\n+                        LOG.error(\"Ledger underreplication manager unavailable during election\", e);\n+                        submitShutdownTask();\n+                    }\n+                }\n+            };\n+        executor.submit(r);\n+    }\n+\n     /**\n      * Shutting down AuditorElector\n      */\n-    public void shutdown() {\n-        if (!running) {\n-            return;\n-        }\n-        running = false;\n-        LOG.info(\"Shutting down AuditorElector\");\n-        try {\n-            zkc.delete(myVote, -1);\n-        } catch (InterruptedException ie) {\n-            LOG.warn(\"InterruptedException while deleting myVote: \" + myVote,\n-                    ie);\n-        } catch (KeeperException ke) {\n-            LOG.warn(\"Exception while deleting myVote:\" + myVote, ke);\n+    public void shutdown() throws InterruptedException {\n+        synchronized (this) {\n+            if (executor.isShutdown()) {\n+                return;\n+            }\n+            submitShutdownTask();\n+            executor.shutdown();\n         }\n+\n         if (auditor != null) {\n             auditor.shutdown();\n             auditor = null;\n@@ -250,7 +295,7 @@ public boolean isRunning() {\n         if (auditor != null) {\n             return auditor.isRunning();\n         }\n-        return running;\n+        return running.get();\n     }\n \n     /**"},{"sha":"c962e4c6555ea7c3cfc730e4a8eadd85baed88cd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -89,7 +89,7 @@ public void process(WatchedEvent event) {\n      * Start daemons\n      */\n     public void start() throws UnavailableException {\n-        auditorElector.doElection();\n+        auditorElector.start();\n         replicationWorker.start();\n         deathWatcher.start();\n     }\n@@ -117,15 +117,19 @@ private void shutdown(int exitCode) {\n         try {\n             deathWatcher.interrupt();\n             deathWatcher.join();\n+\n+            auditorElector.shutdown();\n         } catch (InterruptedException e) {\n-            // Ignore\n+            Thread.currentThread().interrupt();\n+            LOG.warn(\"Interrupted shutting down auto recovery\", e);\n         }\n-        auditorElector.shutdown();\n+\n         replicationWorker.shutdown();\n         try {\n             zk.close();\n         } catch (InterruptedException e) {\n-            // Ignore\n+            Thread.currentThread().interrupt();\n+            LOG.warn(\"Interrupted shutting down auto recovery\", e);\n         }\n     }\n \n@@ -157,7 +161,7 @@ public void run() {\n                 }\n                 // If any one service not running, then shutdown peer.\n                 if (!autoRecoveryMain.auditorElector.isRunning()\n-                        || !autoRecoveryMain.replicationWorker.isRunning()) {\n+                    || !autoRecoveryMain.replicationWorker.isRunning()) {\n                     autoRecoveryMain.shutdown();\n                     break;\n                 }"},{"sha":"aa7a7a63243e4e909785227d6011e7f97dac6b71","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -283,10 +283,12 @@ public void run() {\n      * Stop the replication worker service\n      */\n     public void shutdown() {\n-        if (!workerRunning) {\n-            return;\n+        synchronized (this) {\n+            if (!workerRunning) {\n+                return;\n+            }\n+            workerRunning = false;\n         }\n-        workerRunning = false;\n         try {\n             underreplicationManager.close();\n         } catch (UnavailableException e) {"},{"sha":"d256fe7120dca3a8ea3ce7e03faca4c2d06c1d9c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"modified","additions":54,"deletions":16,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -28,10 +28,13 @@\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookieServer;\n-import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n+\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -48,6 +51,7 @@\n             .getLogger(AuditorBookieTest.class);\n     private String electionPath;\n     private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n+    private List<ZooKeeper> zkClients = new LinkedList<ZooKeeper>();\n \n     public AuditorBookieTest() {\n         super(6);\n@@ -64,6 +68,10 @@ public void setUp() throws Exception {\n     @Override\n     public void tearDown() throws Exception {\n         stopAuditorElectors();\n+        for (ZooKeeper zk : zkClients) {\n+            zk.close();\n+        }\n+        zkClients.clear();\n         super.tearDown();\n     }\n \n@@ -84,7 +92,7 @@ public void testEnsureOnlySingleAuditor() throws Exception {\n         } else {\n             bkIndexDownBookie = indexOf - 1;\n         }\n-        shudownBookie(bs.get(bkIndexDownBookie));\n+        shutdownBookie(bs.get(bkIndexDownBookie));\n \n         startNewBookie();\n         startNewBookie();\n@@ -102,12 +110,12 @@ public void testEnsureOnlySingleAuditor() throws Exception {\n     @Test\n     public void testSuccessiveAuditorCrashes() throws Exception {\n         BookieServer auditor = verifyAuditor();\n-        shudownBookie(auditor);\n+        shutdownBookie(auditor);\n \n         BookieServer newAuditor1 = waitForNewAuditor(auditor);\n         bs.remove(auditor);\n \n-        shudownBookie(newAuditor1);\n+        shutdownBookie(newAuditor1);\n         BookieServer newAuditor2 = waitForNewAuditor(newAuditor1);\n         Assert.assertNotSame(\n                 \"Auditor re-election is not happened for auditor failure!\",\n@@ -143,7 +151,7 @@ public void testBookieClusterRestart() throws Exception {\n     @Test\n     public void testShutdown() throws Exception {\n         BookieServer auditor = verifyAuditor();\n-        shudownBookie(auditor);\n+        shutdownBookie(auditor);\n \n         // waiting for new auditor\n         BookieServer newAuditor = waitForNewAuditor(auditor);\n@@ -172,7 +180,8 @@ public void testShutdown() throws Exception {\n     public void testRestartAuditorBookieAfterCrashing() throws Exception {\n         BookieServer auditor = verifyAuditor();\n \n-        shudownBookie(auditor);\n+        shutdownBookie(auditor);\n+        String addr = StringUtils.addrToString(auditor.getLocalAddress());\n \n         // restarting Bookie with same configurations.\n         int indexOfDownBookie = bs.indexOf(auditor);\n@@ -181,11 +190,12 @@ public void testRestartAuditorBookieAfterCrashing() throws Exception {\n         bs.remove(indexOfDownBookie);\n         bsConfs.remove(indexOfDownBookie);\n         tmpDirs.remove(indexOfDownBookie);\n+        auditorElectors.remove(addr);\n         startBookie(serverConfiguration);\n         // starting corresponding auditor elector\n-        String addr = StringUtils.addrToString(auditor.getLocalAddress());\n+\n         LOG.debug(\"Performing Auditor Election:\" + addr);\n-        auditorElectors.get(addr).doElection();\n+        startAuditorElector(addr);\n \n         // waiting for new auditor to come\n         BookieServer newAuditor = waitForNewAuditor(auditor);\n@@ -197,18 +207,46 @@ public void testRestartAuditorBookieAfterCrashing() throws Exception {\n                 .getPort());\n     }\n \n-    private void startAuditorElectors() throws UnavailableException {\n+    /**\n+     * Test that, if an auditor looses its ZK connection/session\n+     * it will shutdown.\n+     */\n+    @Test\n+    public void testAuditorZKSessionLoss() throws Exception {\n+        stopZKCluster();\n+        for (AuditorElector e : auditorElectors.values()) {\n+            for (int i = 0; i < 10; i++) { // give it 10 seconds to shutdown\n+                if (!e.isRunning()) {\n+                    break;\n+                }\n+\n+                Thread.sleep(1000);\n+            }\n+            assertFalse(\"AuditorElector should have shutdown\", e.isRunning());\n+        }\n+    }\n+\n+    private void startAuditorElector(String addr) throws Exception {\n+        ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n+        ZooKeeper zk = ZkUtils.createConnectedZookeeperClient(\n+                zkUtil.getZooKeeperConnectString(), w);\n+        zkClients.add(zk);\n+\n+        AuditorElector auditorElector = new AuditorElector(addr,\n+                                                           baseClientConf, zk);\n+        auditorElectors.put(addr, auditorElector);\n+        auditorElector.start();\n+        LOG.debug(\"Starting Auditor Elector\");\n+    }\n+\n+    private void startAuditorElectors() throws Exception {\n         for (BookieServer bserver : bs) {\n             String addr = StringUtils.addrToString(bserver.getLocalAddress());\n-            AuditorElector auditorElector = new AuditorElector(addr,\n-                    baseClientConf, zkc);\n-            auditorElectors.put(addr, auditorElector);\n-            auditorElector.doElection();\n-            LOG.debug(\"Starting Auditor Elector\");\n+            startAuditorElector(addr);\n         }\n     }\n \n-    private void stopAuditorElectors() {\n+    private void stopAuditorElectors() throws Exception {\n         for (AuditorElector auditorElector : auditorElectors.values()) {\n             auditorElector.shutdown();\n             LOG.debug(\"Stopping Auditor Elector!\");\n@@ -237,7 +275,7 @@ private BookieServer verifyAuditor() throws KeeperException,\n         return auditors;\n     }\n \n-    private void shudownBookie(BookieServer bkServer) {\n+    private void shutdownBookie(BookieServer bkServer) throws Exception {\n         String addr = StringUtils.addrToString(bkServer.getLocalAddress());\n         LOG.debug(\"Shutting down bookie:\" + addr);\n "},{"sha":"fa2bcc6ef60c0cefc4c39e5258348a55b21d3506","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":31,"deletions":36,"changes":67,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -23,6 +23,7 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n@@ -74,7 +75,7 @@\n     private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n     private LedgerUnderreplicationManager urLedgerMgr;\n     private Set<Long> urLedgerList;\n-    private Map<Long, String> urLedgerData;\n+\n     private List<Long> ledgerList;\n \n     public AuditorLedgerCheckerTest(String ledgerManagerFactoryClass)\n@@ -97,28 +98,27 @@ public void setUp() throws Exception {\n         startAuditorElectors();\n         rng = new Random(System.currentTimeMillis()); // Initialize the Random\n         urLedgerList = new HashSet<Long>();\n-        urLedgerData = new HashMap<Long, String>();\n         ledgerList = new ArrayList<Long>(2);\n     }\n \n     @Override\n     public void tearDown() throws Exception {\n-        super.tearDown();\n         stopAuditorElectors();\n+        super.tearDown();\n     }\n \n-    private void startAuditorElectors() throws UnavailableException {\n+    private void startAuditorElectors() throws Exception {\n         for (BookieServer bserver : bs) {\n             String addr = StringUtils.addrToString(bserver.getLocalAddress());\n             AuditorElector auditorElector = new AuditorElector(addr,\n                     baseClientConf, zkc);\n             auditorElectors.put(addr, auditorElector);\n-            auditorElector.doElection();\n+            auditorElector.start();\n             LOG.debug(\"Starting Auditor Elector\");\n         }\n     }\n \n-    private void stopAuditorElectors() {\n+    private void stopAuditorElectors() throws Exception {\n         for (AuditorElector auditorElector : auditorElectors.values()) {\n             auditorElector.shutdown();\n             LOG.debug(\"Stopping Auditor Elector!\");\n@@ -145,7 +145,7 @@ public void testSimpleLedger() throws Exception {\n         // grace period for publishing the bk-ledger\n         LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n         underReplicaLatch.await(5, TimeUnit.SECONDS);\n-\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n         assertEquals(\"Missed identifying under replicated ledgers\", 1,\n                 urLedgerList.size());\n \n@@ -191,6 +191,7 @@ public void testRestartBookie() throws Exception {\n         // grace period for publishing the bk-ledger\n         LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n         underReplicaLatch.await(5, TimeUnit.SECONDS);\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n \n         assertEquals(\"Missed identifying under replicated ledgers\", 2,\n                 urLedgerList.size());\n@@ -225,8 +226,7 @@ public void testMultipleBookieFailures() throws Exception {\n         // failing first bookie\n         shutdownBookie(bs.size() - 1);\n         // simulate re-replication\n-        doLedgerRereplication(lh1.getId());\n-        doLedgerRereplication(lh2.getId());\n+        doLedgerRereplication(lh1.getId(), lh2.getId());\n \n         // failing another bookie\n         CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n@@ -236,6 +236,7 @@ public void testMultipleBookieFailures() throws Exception {\n         // grace period for publishing the bk-ledger\n         LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n         underReplicaLatch.await(5, TimeUnit.SECONDS);\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n \n         assertEquals(\"Missed identifying under replicated ledgers\", 2,\n                 urLedgerList.size());\n@@ -275,7 +276,7 @@ public void testToggleLedgerReplication() throws Exception {\n \n         // enabling ledger replication\n         urLedgerMgr.enableLedgerReplication();\n-        assertTrue(\"Ledger replication is not disabled!\", urReplicaLatch.await(\n+        assertTrue(\"Ledger replication is not enabled!\", urReplicaLatch.await(\n                 5, TimeUnit.SECONDS));\n     }\n \n@@ -304,19 +305,21 @@ private CountDownLatch registerUrLedgerWatcher(int count)\n         final CountDownLatch underReplicaLatch = new CountDownLatch(count);\n         for (Long ledgerId : ledgerList) {\n             Watcher urLedgerWatcher = new ChildWatcher(underReplicaLatch);\n-            String znode = String.format(\"%s/urL%010d\", getParentZnodePath(\n-                    UNDERREPLICATED_PATH, ledgerId), ledgerId);\n+            String znode = ZkLedgerUnderreplicationManager.getUrLedgerZnode(UNDERREPLICATED_PATH,\n+                                                                            ledgerId);\n             zkc.exists(znode, urLedgerWatcher);\n         }\n         return underReplicaLatch;\n     }\n \n-    private void doLedgerRereplication(long ledgerId)\n+    private void doLedgerRereplication(Long... ledgerIds)\n             throws UnavailableException {\n-        urLedgerMgr.getLedgerToRereplicate();\n-        urLedgerMgr.markLedgerReplicated(ledgerId);\n-        urLedgerMgr.releaseUnderreplicatedLedger(ledgerId);\n-        urLedgerData.clear();\n+        for (int i = 0; i < ledgerIds.length; i++) {\n+            long lid = urLedgerMgr.getLedgerToRereplicate();\n+            assertTrue(\"Received unexpected ledgerid\", Arrays.asList(ledgerIds).contains(lid));\n+            urLedgerMgr.markLedgerReplicated(lid);\n+            urLedgerMgr.releaseUnderreplicatedLedger(lid);\n+        }\n     }\n \n     private String shutdownBookie(int bkShutdownIndex) throws IOException,\n@@ -350,14 +353,16 @@ private void addEntry(int numEntriesToWrite, LedgerHandle lh)\n         }\n     }\n \n-    private String getParentZnodePath(String base, long ledgerId) {\n-        String subdir1 = String.format(\"%04x\", ledgerId >> 48 & 0xffff);\n-        String subdir2 = String.format(\"%04x\", ledgerId >> 32 & 0xffff);\n-        String subdir3 = String.format(\"%04x\", ledgerId >> 16 & 0xffff);\n-        String subdir4 = String.format(\"%04x\", ledgerId & 0xffff);\n-\n-        return String.format(\"%s/%s/%s/%s/%s\", base, subdir1, subdir2, subdir3,\n-                subdir4);\n+    private Map<Long, String> getUrLedgerData(Set<Long> urLedgerList)\n+            throws KeeperException, InterruptedException {\n+        Map<Long, String> urLedgerData = new HashMap<Long, String>();\n+        for (Long ledgerId : urLedgerList) {\n+            String znode = ZkLedgerUnderreplicationManager.getUrLedgerZnode(UNDERREPLICATED_PATH,\n+                                                                            ledgerId);\n+            byte[] data = zkc.getData(znode, false, null);\n+            urLedgerData.put(ledgerId, new String(data));\n+        }\n+        return urLedgerData;\n     }\n \n     private class ChildWatcher implements Watcher {\n@@ -369,21 +374,11 @@ public ChildWatcher(CountDownLatch underReplicaLatch) {\n \n         @Override\n         public void process(WatchedEvent event) {\n-            LOG.debug(\"Recieved notification for the ledger path : \"\n+            LOG.info(\"Received notification for the ledger path : \"\n                     + event.getPath());\n             for (Long ledgerId : ledgerList) {\n                 if (event.getPath().contains(ledgerId + \"\")) {\n                     urLedgerList.add(Long.valueOf(ledgerId));\n-                    try {\n-                        byte[] data = zkc.getData(event.getPath(), this, null);\n-                        urLedgerData.put(ledgerId, new String(data));\n-                    } catch (KeeperException e) {\n-                        LOG.error(\"Exception while reading data from znode :\"\n-                                + event.getPath());\n-                    } catch (InterruptedException e) {\n-                        LOG.error(\"Exception while reading data from znode :\"\n-                                + event.getPath());\n-                    }\n                 }\n             }\n             LOG.debug(\"Count down and waiting for next notification\");"},{"sha":"5cae7c08f90768e0821bcd3ee26250a6bb32f5dc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","status":"modified","additions":2,"deletions":12,"changes":14,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestLedgerUnderreplicationManager.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -46,6 +46,7 @@\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n@@ -741,19 +742,8 @@ private String getData(String znode) {\n \n     }\n \n-    private String getParentZnodePath(String base, long ledgerId) {\n-        String subdir1 = String.format(\"%04x\", ledgerId >> 48 & 0xffff);\n-        String subdir2 = String.format(\"%04x\", ledgerId >> 32 & 0xffff);\n-        String subdir3 = String.format(\"%04x\", ledgerId >> 16 & 0xffff);\n-        String subdir4 = String.format(\"%04x\", ledgerId & 0xffff);\n-\n-        return String.format(\"%s/%s/%s/%s/%s\", base, subdir1, subdir2, subdir3,\n-                subdir4);\n-    }\n-\n     private String getUrLedgerZnode(long ledgerId) {\n-        return String.format(\"%s/urL%010d\", getParentZnodePath(urLedgerPath,\n-                ledgerId), ledgerId);\n+        return ZkLedgerUnderreplicationManager.getUrLedgerZnode(urLedgerPath, ledgerId);\n     }\n \n     private void takeLedgerAndRelease(final LedgerUnderreplicationManager m,"},{"sha":"4719953e59fbd988e48aceaf7eeee14d625019dd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -486,6 +486,39 @@ public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsNotUR()\n \n     }\n \n+    /**\n+     * Test that the replication worker will shutdown if it lose its zookeeper session\n+     */\n+    @Test(timeout=30000)\n+    public void testRWZKSessionLost() throws Exception {\n+        ZooKeeperWatcherBase w = new ZooKeeperWatcherBase(10000);\n+        ZooKeeper zk = ZkUtils.createConnectedZookeeperClient(\n+                zkUtil.getZooKeeperConnectString(), w);\n+\n+        try {\n+            ReplicationWorker rw = new ReplicationWorker(zk, baseConf, getBookie(0));\n+            rw.start();\n+            for (int i = 0; i < 10; i++) {\n+                if (rw.isRunning()) {\n+                    break;\n+                }\n+                Thread.sleep(1000);\n+            }\n+            assertTrue(\"Replication worker should be running\", rw.isRunning());\n+            stopZKCluster();\n+\n+            for (int i = 0; i < 10; i++) {\n+                if (!rw.isRunning()) {\n+                    break;\n+                }\n+                Thread.sleep(1000);\n+            }\n+            assertFalse(\"Replication worker should have shut down\", rw.isRunning());\n+        } finally {\n+            zk.close();\n+        }\n+    }\n+\n     private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n             throws InterruptedException {\n         // Killing all bookies except newly replicated bookie"},{"sha":"fcd169a10648ba55b8cd985c4267ce2af517ef15","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/e5b0dd0d9e47394202f5a20cedf409f487d90beb/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=e5b0dd0d9e47394202f5a20cedf409f487d90beb","patch":"@@ -152,7 +152,7 @@ protected void stopBKCluster() throws Exception {\n         for (BookieServer server : bs) {\n             server.shutdown();\n         }\n-\n+        bs.clear();\n         for (File f : tmpDirs) {\n             FileUtils.deleteDirectory(f);\n         }"}]}

