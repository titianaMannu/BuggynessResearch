{"sha":"e79f8736a7dfc2c7191455e4e88b85a85f0472bf","node_id":"MDY6Q29tbWl0MTU3NTk1NjplNzlmODczNmE3ZGZjMmM3MTkxNDU1ZTRlODhiODVhODVmMDQ3MmJm","commit":{"author":{"name":"Ivan Kelly","email":"ivan@bleurgh.com","date":"2014-12-09T18:57:43Z"},"committer":{"name":"Ivan Kelly","email":"ivan@bleurgh.com","date":"2014-12-09T18:57:43Z"},"message":"BOOKKEEPER-795: Race condition causes writes to hang if ledger is fenced (sijie via ivank)","tree":{"sha":"7c63196b4e43b7e553182be81be6ff5e13bf07bf","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7c63196b4e43b7e553182be81be6ff5e13bf07bf"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e79f8736a7dfc2c7191455e4e88b85a85f0472bf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e79f8736a7dfc2c7191455e4e88b85a85f0472bf","html_url":"https://github.com/apache/bookkeeper/commit/e79f8736a7dfc2c7191455e4e88b85a85f0472bf","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/comments","author":null,"committer":null,"parents":[{"sha":"24591f1514624e09a07ef2f34ba35116ea847266","url":"https://api.github.com/repos/apache/bookkeeper/commits/24591f1514624e09a07ef2f34ba35116ea847266","html_url":"https://github.com/apache/bookkeeper/commit/24591f1514624e09a07ef2f34ba35116ea847266"}],"stats":{"total":113,"additions":102,"deletions":11},"files":[{"sha":"2edba29dbb212be91fd9e348dffd7596c2c38084","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e79f8736a7dfc2c7191455e4e88b85a85f0472bf","patch":"@@ -24,6 +24,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-804: Client program is not terminated when using openLedgerNoRecovery (ivank via sijie)\n \n+      BOOKKEEPER-795: Race condition causes writes to hang if ledger is fenced (sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       BOOKKEEPER-800: Expose whether a ledger is closed or not (ivank)"},{"sha":"8cc00eb0d5dfca3bf0acf9dfb17f2bb41fb21eb0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":44,"deletions":10,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=e79f8736a7dfc2c7191455e4e88b85a85f0472bf","patch":"@@ -254,7 +254,7 @@ public void asyncClose(CloseCallback cb, Object ctx) {\n     /**\n      * Has the ledger been closed?\n      */\n-    public boolean isClosed() {\n+    public synchronized boolean isClosed() {\n         return metadata.isClosed();\n     }\n \n@@ -286,13 +286,32 @@ public void safeRun() {\n                 final State prevState;\n                 List<PendingAddOp> pendingAdds;\n \n-                synchronized(LedgerHandle.this) {\n-                    // if the metadata is already closed, we don't need to proceed the process\n-                    // otherwise, it might end up encountering bad version error log messages when updating metadata\n-                    if (metadata.isClosed()) {\n-                        cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n-                        return;\n+                if (isClosed()) {\n+                    // TODO: make ledger metadata immutable\n+                    // Although the metadata is already closed, we don't need to proceed zookeeper metadata update, but\n+                    // we still need to error out the pending add ops.\n+                    //\n+                    // There is a race condition a pending add op is enqueued, after a close op reset ledger metadata state\n+                    // to unclosed to resolve metadata conflicts. If we don't error out these pending add ops, they would be\n+                    // leak and never callback.\n+                    //\n+                    // The race condition happen in following sequence:\n+                    // a) ledger L is fenced\n+                    // b) write entry E encountered LedgerFencedException, trigger ledger close procedure\n+                    // c) ledger close encountered metadata version exception and set ledger metadata back to open\n+                    // d) writer tries to write entry E+1, since ledger metadata is still open (reset by c))\n+                    // e) the close procedure in c) resolved the metadata conflicts and set ledger metadata to closed\n+                    // f) writing entry E+1 encountered LedgerFencedException which will enter ledger close procedure\n+                    // g) it would find that ledger metadata is closed, then it callbacks immediately without erroring out any pendings\n+                    synchronized (LedgerHandle.this) {\n+                        pendingAdds = drainPendingAddsToErrorOut();\n                     }\n+                    errorOutPendingAdds(rc, pendingAdds);\n+                    cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n+                    return;\n+                }\n+\n+                synchronized(LedgerHandle.this) {\n                     prevState = metadata.getState();\n                     prevLastEntryId = metadata.getLastEntryId();\n                     prevLength = metadata.getLength();\n@@ -549,9 +568,24 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n         }\n \n         if (wasClosed) {\n-            LOG.warn(\"Attempt to add to closed ledger: {}\", ledgerId);\n-            cb.addComplete(BKException.Code.LedgerClosedException,\n-                           LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+            // make sure the callback is triggered in main worker pool\n+            try {\n+                bk.mainWorkerPool.submit(new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        LOG.warn(\"Attempt to add to closed ledger: {}\", ledgerId);\n+                        cb.addComplete(BKException.Code.LedgerClosedException,\n+                                LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return String.format(\"AsyncAddEntryToClosedLedger(lid=%d)\", ledgerId);\n+                    }\n+                });\n+            } catch (RejectedExecutionException e) {\n+                cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),\n+                        LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+            }\n             return;\n         }\n "},{"sha":"6655e9ee606c94e142974472192ec2039180d2ea","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","status":"modified","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCloseTest.java?ref=e79f8736a7dfc2c7191455e4e88b85a85f0472bf","patch":"@@ -19,9 +19,13 @@\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.bookie.Bookie;\n@@ -34,11 +38,13 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.test.TestCallbacks.AddCallbackFuture;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import static org.junit.Assert.*;\n+import static com.google.common.base.Charsets.UTF_8;\n \n /**\n  * This class tests the ledger close logic.\n@@ -226,4 +232,35 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n         bsConfs.add(conf);\n         bs.add(startBookie(conf, dBookie));\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testAllWritesAreCompletedOnClosedLedger() throws Exception {\n+        for (int i = 0; i < 100; i++) {\n+            LOG.info(\"Iteration {}\", i);\n+\n+            List<AddCallbackFuture> futures = new ArrayList<AddCallbackFuture>();\n+            LedgerHandle w = bkc.createLedger(DigestType.CRC32, new byte[0]);\n+            AddCallbackFuture f = new AddCallbackFuture(0L);\n+            w.asyncAddEntry(\"foobar\".getBytes(UTF_8), f, null);\n+            f.get();\n+\n+            LedgerHandle r = bkc.openLedger(w.getId(), DigestType.CRC32, new byte[0]);\n+            for (int j = 0; j < 100; j++) {\n+                AddCallbackFuture f1 = new AddCallbackFuture(1L + j);\n+                w.asyncAddEntry(\"foobar\".getBytes(), f1, null);\n+                futures.add(f1);\n+            }\n+\n+            for (AddCallbackFuture f2: futures) {\n+                try {\n+                    f2.get(10, TimeUnit.SECONDS);\n+                } catch (ExecutionException ee) {\n+                    // we don't care about errors\n+                } catch (TimeoutException te) {\n+                    LOG.error(\"Error on waiting completing entry {} : \", f2.getExpectedEntryId(), te);\n+                    fail(\"Should succeed on waiting completing entry \" + f2.getExpectedEntryId());\n+                }\n+            }\n+        }\n+    }\n }"},{"sha":"3e221b4d07463179e7ec6569620adec770363091","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorRollingRestartTest.java?ref=e79f8736a7dfc2c7191455e4e88b85a85f0472bf","patch":"@@ -55,7 +55,7 @@ public void testAuditingDuringRollingRestart() throws Exception {\n \n         LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, \"passwd\".getBytes());\n         for (int i = 0; i < 10; i++) {\n-            lh.asyncAddEntry(\"foobar\".getBytes(), new TestCallbacks.AddCallbackFuture(), null);\n+            lh.asyncAddEntry(\"foobar\".getBytes(), new TestCallbacks.AddCallbackFuture(i), null);\n         }\n         lh.addEntry(\"foobar\".getBytes());\n         lh.close();"},{"sha":"5d9f99b8141ef3e77c55f9f4f9f49680937e50e5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestCallbacks.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestCallbacks.java","raw_url":"https://github.com/apache/bookkeeper/raw/e79f8736a7dfc2c7191455e4e88b85a85f0472bf/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestCallbacks.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestCallbacks.java?ref=e79f8736a7dfc2c7191455e4e88b85a85f0472bf","patch":"@@ -25,11 +25,16 @@\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import com.google.common.util.concurrent.AbstractFuture;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Callbacks implemented with SettableFuture, to be used in tests\n  */\n public class TestCallbacks {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TestCallbacks.class);\n+\n     public static class GenericCallbackFuture<T>\n         extends AbstractFuture<T> implements GenericCallback<T> {\n         @Override\n@@ -44,8 +49,21 @@ public void operationComplete(int rc, T value) {\n \n     public static class AddCallbackFuture\n         extends AbstractFuture<Long> implements AddCallback {\n+\n+        private final long expectedEntryId;\n+\n+        public AddCallbackFuture(long entryId) {\n+            this.expectedEntryId = entryId;\n+        }\n+\n+        public long getExpectedEntryId() {\n+            return expectedEntryId;\n+        }\n+\n         @Override\n         public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+            logger.info(\"Add entry {} completed : entryId = {}, rc = {}\",\n+                    new Object[] { expectedEntryId, entryId, rc });\n             if (rc != BKException.Code.OK) {\n                 setException(BKException.create(rc));\n             } else {"}]}

