{"sha":"e8a34269cdeb42cbb979159c505b88f709ef4213","node_id":"MDY6Q29tbWl0MTU3NTk1NjplOGEzNDI2OWNkZWI0MmNiYjk3OTE1OWM1MDViODhmNzA5ZWY0MjEz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-28T15:59:22Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-06-28T15:59:22Z"},"message":"BOOKKEEPER-620: PerChannelBookieClient race during channel disconnect (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.2@1497824 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fbf148576163ce98b39c0047b7ebf221754730db","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/fbf148576163ce98b39c0047b7ebf221754730db"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e8a34269cdeb42cbb979159c505b88f709ef4213","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e8a34269cdeb42cbb979159c505b88f709ef4213","html_url":"https://github.com/apache/bookkeeper/commit/e8a34269cdeb42cbb979159c505b88f709ef4213","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e8a34269cdeb42cbb979159c505b88f709ef4213/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"323fa42313a3b889070725b6ff89fe02c4ddefa1","url":"https://api.github.com/repos/apache/bookkeeper/commits/323fa42313a3b889070725b6ff89fe02c4ddefa1","html_url":"https://github.com/apache/bookkeeper/commit/323fa42313a3b889070725b6ff89fe02c4ddefa1"}],"stats":{"total":168,"additions":141,"deletions":27},"files":[{"sha":"debe71c6281c50e0ca01be8b4a2a68202f8d980b","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e8a34269cdeb42cbb979159c505b88f709ef4213/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e8a34269cdeb42cbb979159c505b88f709ef4213/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e8a34269cdeb42cbb979159c505b88f709ef4213","patch":"@@ -32,6 +32,8 @@ Release 4.2.2 - Unreleased\n \n         BOOKKEEPER-623: LedgerChecker should avoid segments of closed ledger with higher start entryId than closed entry. (vinay via sijie)\n \n+        BOOKKEEPER-620: PerChannelBookieClient race during channel disconnect (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-579: TestSubAfterCloseSub was put in a wrong package (sijie via ivank)"},{"sha":"114cc5bf35b11a619db4800cbe9a6686e1bcac44","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":41,"deletions":25,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/e8a34269cdeb42cbb979159c505b88f709ef4213/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/e8a34269cdeb42cbb979159c505b88f709ef4213/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=e8a34269cdeb42cbb979159c505b88f709ef4213","patch":"@@ -20,11 +20,14 @@\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayDeque;\n+import java.util.Set;\n+import java.util.Collections;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import com.google.common.collect.ImmutableSet;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n@@ -78,7 +81,6 @@\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor;\n-    private Timer readTimeoutTimer;\n \n     ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n     ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n@@ -90,11 +92,11 @@\n     Queue<GenericCallback<Void>> pendingOps = new ArrayDeque<GenericCallback<Void>>();\n     volatile Channel channel = null;\n \n-    private enum ConnectionState {\n+    enum ConnectionState {\n         DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n             };\n \n-    private volatile ConnectionState state;\n+    volatile ConnectionState state;\n     private final ClientConfiguration conf;\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n@@ -110,7 +112,6 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.totalBytesOutstanding = totalBytesOutstanding;\n         this.channelFactory = channelFactory;\n         this.state = ConnectionState.DISCONNECTED;\n-        this.readTimeoutTimer = null;\n     }\n \n     private void connect() {\n@@ -124,29 +125,36 @@ private void connect() {\n         bootstrap.setOption(\"keepAlive\", true);\n \n         ChannelFuture future = bootstrap.connect(addr);\n-\n         future.addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) throws Exception {\n+                LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.getChannel());\n                 int rc;\n                 Queue<GenericCallback<Void>> oldPendingOps;\n \n                 synchronized (PerChannelBookieClient.this) {\n-\n                     if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n-                        LOG.info(\"Successfully connected to bookie: \" + addr);\n+                        LOG.info(\"Successfully connected to bookie: {}\", future.getChannel());\n                         rc = BKException.Code.OK;\n                         channel = future.getChannel();\n                         state = ConnectionState.CONNECTED;\n                     } else if (future.isSuccess() && (state == ConnectionState.CLOSED\n                                                       || state == ConnectionState.DISCONNECTED)) {\n-                        LOG.error(\"Closed before connection completed, clean up: \" + addr);\n-                        future.getChannel().close();\n+                        LOG.warn(\"Closed before connection completed, clean up: {}, current state {}\",\n+                                 future.getChannel(), state);\n+                        closeChannel(future.getChannel());\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n                         channel = null;\n+                    } else if (future.isSuccess() && state == ConnectionState.CONNECTED) {\n+                        LOG.debug(\"Already connected with another channel({}), so close the new channel({})\",\n+                                  channel, future.getChannel());\n+                        closeChannel(future.getChannel());\n+                        return; // pendingOps should have been completed when other channel connected\n                     } else {\n-                        LOG.error(\"Could not connect to bookie: \" + addr);\n+                        LOG.error(\"Could not connect to bookie: {}, current state {}\",\n+                                  future.getChannel(), state);\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n+                        closeChannel(future.getChannel());\n                         channel = null;\n                         if (state != ConnectionState.CLOSED) {\n                             state = ConnectionState.DISCONNECTED;\n@@ -359,20 +367,28 @@ public void close() {\n     }\n \n     private void closeInternal(boolean permanent) {\n+        Channel toClose = null;\n         synchronized (this) {\n             if (permanent) {\n                 state = ConnectionState.CLOSED;\n             } else if (state != ConnectionState.CLOSED) {\n                 state = ConnectionState.DISCONNECTED;\n             }\n+            toClose = channel;\n+            channel = null;\n         }\n-        if (channel != null) {\n-            channel.close().awaitUninterruptibly();\n+        if (toClose != null) {\n+            closeChannel(toClose).awaitUninterruptibly();\n         }\n-        if (readTimeoutTimer != null) {\n-            readTimeoutTimer.stop();\n-            readTimeoutTimer = null;\n+    }\n+\n+    private ChannelFuture closeChannel(Channel c) {\n+        LOG.debug(\"Closing channel {}\", c);\n+        ReadTimeoutHandler timeout = c.getPipeline().get(ReadTimeoutHandler.class);\n+        if (timeout != null) {\n+            timeout.releaseExternalResources();\n         }\n+        return c.close();\n     }\n \n     void errorOutReadKey(final CompletionKey key) {\n@@ -453,11 +469,7 @@ void errorOutOutstandingEntries() {\n     public ChannelPipeline getPipeline() throws Exception {\n         ChannelPipeline pipeline = Channels.pipeline();\n \n-        if (readTimeoutTimer == null) {\n-            readTimeoutTimer = new HashedWheelTimer();\n-        }\n-\n-        pipeline.addLast(\"readTimeout\", new ReadTimeoutHandler(readTimeoutTimer, \n+        pipeline.addLast(\"readTimeout\", new ReadTimeoutHandler(new HashedWheelTimer(),\n                                                                conf.getReadTimeout()));\n         pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n         pipeline.addLast(\"mainhandler\", this);\n@@ -469,14 +481,18 @@ public ChannelPipeline getPipeline() throws Exception {\n      */\n     @Override\n     public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-        LOG.info(\"Disconnected from bookie: \" + addr);\n-        errorOutOutstandingEntries();\n-        Channel c = this.channel;\n+        Channel c = ctx.getChannel();\n+        LOG.info(\"Disconnected from bookie channel {}\", c);\n         if (c != null) {\n-            c.close();\n+            closeChannel(c);\n         }\n+        if (this.channel == c) {\n+            errorOutOutstandingEntries();\n+        }\n+\n         synchronized (this) {\n-            if (state != ConnectionState.CLOSED) {\n+            if (this.channel == c\n+                && state != ConnectionState.CLOSED) {\n                 state = ConnectionState.DISCONNECTED;\n             }\n         }"},{"sha":"213dd7efbaebba7dedadd7b8713bb37a6adff018","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":98,"deletions":2,"changes":100,"blob_url":"https://github.com/apache/bookkeeper/blob/e8a34269cdeb42cbb979159c505b88f709ef4213/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/e8a34269cdeb42cbb979159c505b88f709ef4213/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=e8a34269cdeb42cbb979159c505b88f709ef4213","patch":"@@ -24,12 +24,16 @@\n import org.junit.*;\n import java.net.InetSocketAddress;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.PerChannelBookieClient.ConnectionState;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-\n+import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n@@ -111,4 +115,96 @@ public void operationComplete(int rc, Void result) {\n         channelFactory.releaseExternalResources();\n         executor.shutdown();\n     }\n-}\n\\ No newline at end of file\n+\n+    /**\n+     * Test that all resources are freed if connections and disconnections\n+     * are interleaved randomly.\n+     *\n+     * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-620}\n+     */\n+    @Test(timeout=60000)\n+    public void testDisconnectRace() throws Exception {\n+        final GenericCallback<Void> nullop = new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                // do nothing, we don't care about doing anything with the connection,\n+                // we just want to trigger it connecting.\n+            }\n+        };\n+        final int ITERATIONS = 100000;\n+        ClientSocketChannelFactory channelFactory\n+            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                                                Executors.newCachedThreadPool());\n+        OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n+        InetSocketAddress addr = getBookie(0);\n+\n+        AtomicLong bytesOutstanding = new AtomicLong(0);\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor,\n+                channelFactory, addr, bytesOutstanding);\n+        final AtomicBoolean shouldFail = new AtomicBoolean(false);\n+        final AtomicBoolean running = new AtomicBoolean(true);\n+        final CountDownLatch disconnectRunning = new CountDownLatch(1);\n+        Thread connectThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        if (!disconnectRunning.await(10, TimeUnit.SECONDS)) {\n+                            LOG.error(\"Disconnect thread never started\");\n+                            shouldFail.set(true);\n+                        }\n+                    } catch (InterruptedException ie) {\n+                        LOG.error(\"Connect thread interrupted\", ie);\n+                        Thread.currentThread().interrupt();\n+                        running.set(false);\n+                    }\n+                    for (int i = 0; i < ITERATIONS && running.get(); i++) {\n+                        client.connectIfNeededAndDoOp(nullop);\n+                    }\n+                    running.set(false);\n+                }\n+            };\n+        Thread disconnectThread = new Thread() {\n+                public void run() {\n+                    disconnectRunning.countDown();\n+                    while (running.get()) {\n+                        client.disconnect();\n+                    }\n+                }\n+            };\n+        Thread checkThread = new Thread() {\n+                public void run() {\n+                    ConnectionState state;\n+                    Channel channel;\n+                    while (running.get()) {\n+                        synchronized (client) {\n+                            state = client.state;\n+                            channel = client.channel;\n+\n+                            if ((state == ConnectionState.CONNECTED\n+                                 && (channel == null\n+                                     || !channel.isConnected()))\n+                                || (state != ConnectionState.CONNECTED\n+                                    && channel != null\n+                                    && channel.isConnected())) {\n+                                LOG.error(\"State({}) and channel({}) inconsistent \" + channel,\n+                                          state, channel == null ? null : channel.isConnected());\n+                                shouldFail.set(true);\n+                                running.set(false);\n+                            }\n+                        }\n+                    }\n+                }\n+            };\n+        connectThread.start();\n+        disconnectThread.start();\n+        checkThread.start();\n+\n+        connectThread.join();\n+        disconnectThread.join();\n+        checkThread.join();\n+        assertFalse(\"Failure in threads, check logs\", shouldFail.get());\n+\n+        client.close();\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+}"}]}

