{"sha":"e95b9392d4ba38c68617dff16de53e523d8ea51b","node_id":"MDY6Q29tbWl0MTU3NTk1NjplOTViOTM5MmQ0YmEzOGM2ODYxN2RmZjE2ZGU1M2U1MjNkOGVhNTFi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-31T18:32:57Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-01-31T18:32:57Z"},"message":"BOOKKEEPER-312: Implementation of JMS provider (mridul via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1441108 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"94a9d345c735e8f1583c80cd617eff4ca3a42240","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/94a9d345c735e8f1583c80cd617eff4ca3a42240"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e95b9392d4ba38c68617dff16de53e523d8ea51b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e95b9392d4ba38c68617dff16de53e523d8ea51b","html_url":"https://github.com/apache/bookkeeper/commit/e95b9392d4ba38c68617dff16de53e523d8ea51b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e95b9392d4ba38c68617dff16de53e523d8ea51b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"7bed2a74a98f49b31c1653a513944f60a359776c","url":"https://api.github.com/repos/apache/bookkeeper/commits/7bed2a74a98f49b31c1653a513944f60a359776c","html_url":"https://github.com/apache/bookkeeper/commit/7bed2a74a98f49b31c1653a513944f60a359776c"}],"stats":{"total":30504,"additions":30504,"deletions":0},"files":[{"sha":"10bf91cebea0f0960b552aa09f0dc4a407e1c6fb","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -14,6 +14,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-544: Modify hedwig server tests to allow client testcases to start/stop them as part of their tests (mridul via ivank)\n \n+      BOOKKEEPER-312: Implementation of JMS provider (mridul via ivank)\n+\n Release 4.2.0 - 2013-01-14\n \n   Non-backward compatible changes:"},{"sha":"984be8ab856cbb3a91f674b89276bd6d84bd2cc3","filename":"hedwig-client-jms/pom.xml","status":"added","additions":322,"deletions":0,"changes":322,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/pom.xml?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,322 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\n+         xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <parent>\n+    <groupId>org.apache.bookkeeper</groupId>\n+    <artifactId>bookkeeper</artifactId>\n+    <version>4.3.0-SNAPSHOT</version>\n+  </parent>\n+  <groupId>org.apache.bookkeeper</groupId>\n+  <artifactId>hedwig-client-jms</artifactId>\n+  <name>hedwig-client-jms</name>\n+  <url>http://maven.apache.org</url>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.google.protobuf</groupId>\n+      <artifactId>protobuf-java</artifactId>\n+      <version>2.4.1</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.8.1</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- As suggested by Matthieu - Using geronimo-spec-jms instead of ver=1.1, groupId=java.jms, artifcatId=jms -->\n+    <dependency>\n+      <groupId>geronimo-spec</groupId>\n+      <artifactId>geronimo-spec-jms</artifactId>\n+      <version>1.1-rc4</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-client</artifactId>\n+      <version>${project.parent.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-protocol</artifactId>\n+      <version>${project.parent.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>bookkeeper-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>test</scope>\n+      <type>test-jar</type>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>test</scope>\n+      <type>test-jar</type>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>hedwig-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>test</scope>\n+      <type>jar</type>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper</groupId>\n+      <artifactId>bookkeeper-server</artifactId>\n+      <version>${project.parent.version}</version>\n+      <scope>test</scope>\n+      <type>jar</type>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.zookeeper</groupId>\n+      <artifactId>zookeeper</artifactId>\n+      <version>3.4.3</version>\n+      <type>test-jar</type>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>log4j</groupId>\n+      <artifactId>log4j</artifactId>\n+      <version>1.2.15</version>\n+      <scope>provided</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>javax.mail</groupId>\n+          <artifactId>mail</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>javax.jms</groupId>\n+          <artifactId>jms</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jdmk</groupId>\n+          <artifactId>jmxtools</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>com.sun.jmx</groupId>\n+          <artifactId>jmxri</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <testResources>\n+      <testResource>\n+        <directory>src/test/resources</directory>\n+        <includes>\n+          <include>log4j.properties</include>\n+        </includes>\n+      </testResource>\n+    </testResources>\n+    <pluginManagement>\n+      <plugins>\n+        <plugin>\n+          <groupId>org.codehaus.mojo</groupId>\n+          <artifactId>findbugs-maven-plugin</artifactId>\n+          <version>2.4.0</version>\n+        </plugin>\n+      </plugins>\n+    </pluginManagement>\n+\n+    <plugins>\n+      <plugin>\n+        <groupId>org.codehaus.mojo</groupId>\n+        <artifactId>javacc-maven-plugin</artifactId>\n+        <version>2.6</version>\n+        <executions>\n+          <execution>\n+            <id>jjtree-javacc</id>\n+            <goals>\n+              <goal>jjtree-javacc</goal>\n+            </goals>\n+            <configuration>\n+              <sourceDirectory>${basedir}/src/main/grammar/javacc</sourceDirectory>\n+              <packageName>org.apache.hedwig.jms.selector</packageName>\n+            </configuration>\n+            <phase>generate-sources</phase>\n+          </execution>\n+        </executions>\n+      </plugin>\n+\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>2.9</version>\n+        <configuration>\n+          <!-- Skip the default running of this plug-in (or everything is run twice...see below) -->\n+          <skip>true</skip>\n+          <!-- Show 100% of the lines from the stack trace (doesn't work ?) -->\n+          <trimStackTrace>false</trimStackTrace>\n+          <systemProperties>\n+            <property>\n+              <name>log4j.configuration</name>\n+              <value>log4j.properties</value>\n+            </property>\n+            <property>\n+              <name>java.net.preferIPv4Stack</name>\n+              <value>true</value>\n+            </property>\n+            <property>\n+              <name>com.sun.management.jmxremote</name>\n+              <value>true</value>\n+            </property>\n+            <property>\n+              <name>com.sun.management.jmxremote.local.only</name>\n+              <value>true</value>\n+            </property>\n+            <property>\n+              <name>com.sun.management.jmxremote.ssl</name>\n+              <value>false</value>\n+            </property>\n+            <property>\n+              <name>com.sun.management.jmxremote.authenticate</name>\n+              <value>false</value>\n+            </property>\n+            <property>\n+              <name>java.rmi.server.hostname</name>\n+              <value>localhost</value>\n+            </property>\n+            <!--\n+                <property>\n+                <name>com.sun.management.jmxremote.port</name>\n+                <value>39999</value>\n+                </property>\n+            -->\n+          </systemProperties>\n+          <!-- <forkMode>always</forkMode> -->\n+          <forkMode>pertest</forkMode>\n+          <argLine>-Xmx1G</argLine>\n+        </configuration>\n+\n+        <executions>\n+          <execution>\n+            <id>unit-tests</id>\n+            <phase>test</phase>\n+            <goals>\n+              <goal>test</goal>\n+            </goals>\n+            <configuration>\n+              <skip>false</skip>\n+              <!-- run everything other than activemq testcases -->\n+              <excludes>\n+                <exclude>org/apache/activemq/**/Test*.java</exclude>\n+                <exclude>org/apache/activemq/**/*Test.java</exclude>\n+                <exclude>org/apache/activemq/**/*TestCase.java</exclude>\n+              </excludes>\n+            </configuration>\n+          </execution>\n+        </executions>\n+      </plugin>\n+\n+      <plugin>\n+        <groupId>org.codehaus.mojo</groupId>\n+        <artifactId>findbugs-maven-plugin</artifactId>\n+        <version>2.4.0</version>\n+        <executions>\n+          <execution>\n+            <id>findbugs</id>\n+            <goals>\n+              <goal>findbugs</goal>\n+            </goals>\n+            <configuration>\n+              <threshold>High</threshold>\n+              <effort>Default</effort>\n+            </configuration>\n+            <phase>none</phase>\n+          </execution>\n+        </executions>\n+      </plugin>\n+\n+      <plugin>\n+        <groupId>org.apache.rat</groupId>\n+        <artifactId>apache-rat-plugin</artifactId>\n+        <version>0.7</version>\n+        <configuration>\n+          <excludes>\n+            <!-- exclude generated file //-->\n+            <exclude>**/JmsHeader.java</exclude>\n+          </excludes>\n+        </configuration>\n+      </plugin>\n+\n+    </plugins>\n+  </build>\n+  <profiles>\n+    <profile>\n+      <id>protobuf</id>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <artifactId>maven-antrun-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <phase>generate-sources</phase>\n+                <id>default-cli</id>\n+                <configuration>\n+                  <target>\n+                    <exec executable=\"protoc\" failonerror=\"true\">\n+                      <arg value=\"--java_out=src/main/java\" />\n+                      <arg value=\"src/main/protobuf/JmsHeader.proto\" />\n+                    </exec>\n+                  </target>\n+                </configuration>\n+                <goals>\n+                  <goal>run</goal>\n+                </goals>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n+    <profile>\n+      <id>activemqtests</id>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <groupId>org.apache.maven.plugins</groupId>\n+            <artifactId>maven-surefire-plugin</artifactId>\n+            <version>2.9</version>\n+            <executions>\n+              <execution>\n+                <id>integration-tests</id>\n+                <phase>test</phase>\n+                <goals>\n+                  <goal>test</goal>\n+                </goals>\n+                <configuration>\n+                  <skip>false</skip>\n+                  <includes>\n+                    <!-- run the activemq testcases -->\n+                    <include>org/apache/activemq/**/Test*.java</include>\n+                    <include>org/apache/activemq/**/*Test.java</include>\n+                    <include>org/apache/activemq/**/*TestCase.java</include>\n+                  </includes>\n+                </configuration>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n+  </profiles>\n+</project>"},{"sha":"b118681733b0d7a33883b614d6687aae70802874","filename":"hedwig-client-jms/src/main/grammar/javacc/readme.html","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/grammar/javacc/readme.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/grammar/javacc/readme.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/grammar/javacc/readme.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,26 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+\n+Contains the grammar to define and support selectors in our JMS provider. <br/>\n+Maven handles generation of the code based on this, and the JMS provider code has rest of the\n+implementation which depends on this generated code to implement selectors in our provider.<br/>\n+Please refer to <a href=\"../../java/org/apache/hedwig/jms/selector/package-info.html\">\n+../../java/org/apache/hedwig/jms/selector/package-info.html</a> for more information. <br/>\n+\n+<p/>\n+Based loosely off java and sql grammar from javacc."},{"sha":"a141b8b51338f06569618c6b3b6bf27155c56b2c","filename":"hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","status":"added","additions":689,"deletions":0,"changes":689,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/grammar/javacc/selector_grammar.jjt?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,689 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/* This is based on the Java1.0.2.jj grammar */\n+\n+options {\n+  MULTI=true;\n+  // JAVA_UNICODE_ESCAPE = true;\n+  // LOOKAHEAD = 1;\n+  FORCE_LA_CHECK = false;\n+  NODE_EXTENDS=\"MyNode\";\n+  VISITOR = true;\n+  STATIC = false;\n+  VISITOR_DATA_TYPE = \"SelectorEvalState\";\n+  VISITOR_EXCEPTION = \"SelectorEvaluationException\";\n+\n+/*\n+  DEBUG_PARSER = true ;\n+  DEBUG_LOOKAHEAD = true ;\n+  DEBUG_TOKEN_MANAGER = true ;\n+  */\n+}\n+\n+PARSER_BEGIN(SelectorParser)\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.message.MessageImpl;\n+import org.apache.hedwig.jms.message.TextMessageImpl;\n+\n+import java.io.StringReader;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.LinkedHashMap;\n+\n+\n+public class SelectorParser {\n+\n+  // It contains no state (as of now).\n+  private static final InterpretSelectorParserVisitor interpreter = new InterpretSelectorParserVisitor();\n+  private static final TreeDumperSelectorParserVisitor treeDumper = new TreeDumperSelectorParserVisitor();\n+\n+  public static Boolean evaluateSelector(final Node ast, final MessageImpl message) {\n+  if (MyNode.logger.isTraceEnabled()) {\n+      MyNode.logger.trace(\"--- Dump AST START ---\");\n+      try {\n+        ast.jjtAccept(treeDumper, new SelectorEvalState(null));\n+      } catch (SelectorEvaluationException e) {\n+        MyNode.logger.trace(\"Unable to run debug visitor \" + message + \", exception : \" + e + \" ... ignoring.\", e);\n+      }\n+      MyNode.logger.trace(\"--- Dump AST DONE---\");\n+    }\n+    final SelectorEvalState data = new SelectorEvalState(message);\n+    try {\n+        ast.jjtAccept(interpreter, data);\n+        if (1 != data.getStack().size() ||\n+                SelectorConstant.SelectorDataType.BOOLEAN != data.getStack().peek().type){\n+            if (MyNode.logger.isDebugEnabled())\n+                MyNode.logger.debug(\"Expected only a single boolean in stack, obtained : \" + data.getStack());\n+            return null;\n+        }\n+        return data.getStack().peek().getBoolValue();\n+    } catch (SelectorEvaluationException e) {\n+        if (MyNode.logger.isDebugEnabled())\n+            MyNode.logger.debug(\"Unable to run interpreter on \" + message + \", exception : \"\n+                                + e + \" ... ignoring message\", e);\n+        return null;\n+    }\n+  }\n+\n+  private static final int CACHED_AST_SIZE = Integer.getInteger(\"CACHED_AST_SIZE\", 128);\n+  private static final LinkedHashMap<String, Node> parsedSelectorCache\n+       = new LinkedHashMap<String, Node>(CACHED_AST_SIZE, 0.75f, true){\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry<String, Node> eldest) {\n+      return size() > CACHED_AST_SIZE;\n+    }\n+  };\n+\n+  public static Node parseMessageSelector(String messageSelector) throws ParseException {\n+    if (MyNode.logger.isTraceEnabled()) {\n+      MyNode.logger.trace(\"Parse '\" + messageSelector + \"'\");\n+    }\n+    synchronized (parsedSelectorCache){\n+      if (parsedSelectorCache.containsKey(messageSelector)) return parsedSelectorCache.get(messageSelector);\n+    }\n+    Node retval = null;\n+    try {\n+      SelectorParser parser = new SelectorParser(new StringReader(messageSelector));\n+      parser.Expression();\n+      retval = parser.jjtree.rootNode();\n+      return retval;\n+    } catch (TokenMgrError rmErr){\n+      // It throws an error ! seriously ? ... sigh !\n+      if (MyNode.logger.isDebugEnabled()) {\n+        MyNode.logger.debug(\"Unable to parse selector expression - recieved error \", rmErr);\n+      }\n+      throw new ParseException(rmErr.toString());\n+    } finally {\n+        synchronized (parsedSelectorCache){\n+          parsedSelectorCache.put(messageSelector, retval);\n+        }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws ParseException, SelectorEvaluationException  {\n+      MessageImpl message = new TextMessageImpl(null, \"test\");\n+      SelectorEvalState data = new SelectorEvalState(message);\n+      SelectorParserVisitor visitor = new InterpretSelectorParserVisitor();\n+      for (String arg : args){\n+          Node node = parseMessageSelector(arg);\n+          node.jjtAccept(visitor, data);\n+\n+          if (1 != data.getStack().size()){\n+            throw new IllegalArgumentException(\"Invalid proposition '\" + arg\n+                                               + \"'. Unexpected result stack : \" + data.getStack());\n+          }\n+          else System.out.println(\"Result : \" + data.getStack().peek());\n+      }\n+  }\n+\n+  private String unescapeSingleQuotes(String str){\n+    final int len = str.length();\n+    final StringBuilder retval = new StringBuilder();\n+\n+    int offset = 0;\n+    while (true){\n+      int indx = str.indexOf('\\'', offset);\n+      if (-1 == indx) break;\n+      if (indx + 1 >= len) break;\n+\n+      retval.append(str.substring(offset, indx + 1));\n+      offset = indx + 1;\n+      if ('\\'' == str.charAt(indx + 1)) offset ++;\n+    }\n+    if (offset < len) retval.append(str.substring(offset));\n+    return retval.toString();\n+  }\n+\n+  public String parseString(final Token token, boolean canBeNull) throws ParseException{\n+    if (canBeNull && null == token) return null;\n+\n+    final String str = token.image;\n+    final int len = str.length();\n+    if (len >= 2 && '\\'' == str.charAt(0) && '\\'' == str.charAt(len - 1)){\n+      String tstr = str.substring(1, len - 1);\n+      tstr = unescapeSingleQuotes(tstr);\n+      return tstr;\n+    }\n+    if (!\"''\".equals(str)) throw new ParseException(\"Unexpected string : \" + str);\n+    return \"\";\n+  }\n+\n+  public String parseString(final Token token) throws ParseException{\n+    return parseString(token, false);\n+  }\n+\n+  public String parseIdentifier(Token identifier) throws ParseException{\n+    // nothing to parse actually ...\n+    final String identifierName = identifier.image;\n+    if (\"null\".equalsIgnoreCase(identifierName) ||\n+          \"true\".equalsIgnoreCase(identifierName) ||\n+          \"false\".equalsIgnoreCase(identifierName)){\n+      throw new ParseException(\"Invalid identifier name : \" + identifierName);\n+    }\n+\n+    if (\"NOT\".equalsIgnoreCase(identifierName) ||\n+          \"AND\".equalsIgnoreCase(identifierName) ||\n+          \"OR\".equalsIgnoreCase(identifierName) ||\n+          \"BETWEEN\".equalsIgnoreCase(identifierName) ||\n+          \"LIKE\".equalsIgnoreCase(identifierName) ||\n+          \"IN\".equalsIgnoreCase(identifierName) ||\n+          \"IS\".equalsIgnoreCase(identifierName) ||\n+          \"ESCAPE\".equalsIgnoreCase(identifierName)){\n+      throw new ParseException(\"Invalid identifier name : \" + identifierName);\n+    }\n+\n+    return identifierName;\n+  }\n+}\n+\n+\n+PARSER_END(SelectorParser)\n+\n+SKIP : /* WHITE SPACE */\n+{\n+  \" \"\n+| \"\\t\"\n+| \"\\n\"\n+| \"\\r\"\n+| \"\\f\"\n+}\n+\n+/*\n+SKIP :\n+{\n+  \" \"\n+| \"\\t\"\n+| \"\\f\"\n+}\n+*/\n+\n+// As per 3.8.1.3 Special Notes, I SHOULD NOT be supporting SQL comments ... but what the heck :-)\n+/* COMMENTS */\n+/*\n+SKIP:\n+{\n+  <SINGLE_LINE_COMMENT: \"--\" (~[\"\\n\",\"\\r\"])* (\"\\n\"|\"\\r\"|\"\\r\\n\")>\n+| <MULTI_LINE_COMMENT: \"/*\" (~[\"*\"])* \"*\" (\"*\" | (~[\"*\",\"/\"] (~[\"*\"])* \"*\"))* \"/\">\n+}\n+*/\n+\n+TOKEN : /* SEPARATORS */\n+{\n+  < LPAREN: \"(\" >\n+| < RPAREN: \")\" >\n+}\n+\n+TOKEN : /* OPERATORS */\n+{\n+  < EQ: \"=\" >\n+| < GT: \">\" >\n+| < LT: \"<\" >\n+| < LE: \"<=\" >\n+| < GE: \">=\" >\n+| < NE: \"<>\" >\n+\n+| < PLUS: \"+\" >\n+| < MINUS: \"-\" >\n+| < STAR: \"*\" >\n+| < SLASH: \"/\" >\n+| < COMMA: \",\" >\n+}\n+\n+TOKEN[IGNORE_CASE] :\n+{\n+\n+  < NULL : \"NULL\" >\n+\n+| < NOT : \"NOT\" >\n+| < AND : \"AND\" >\n+| < OR : \"OR\" >\n+\n+| < BETWEEN : \"BETWEEN\" >\n+| < LIKE : \"LIKE\" >\n+| < IN : \"IN\" >\n+| < IS : \"IS\" >\n+| < ESCAPE : \"ESCAPE\" >\n+}\n+\n+\n+\n+TOKEN[IGNORE_CASE] : /* Boolean literal - case-insensitive */\n+{\n+  < BOOLEAN_LITERAL: \"true\" | \"false\" >\n+}\n+\n+\n+TOKEN : /* IDENTIFIER */\n+{\n+  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >\n+|\n+  < #LETTER:\n+      [\n+       \"\\u0024\",\n+       \"\\u0041\"-\"\\u005a\",\n+       \"\\u005f\",\n+       \"\\u0061\"-\"\\u007a\",\n+       \"\\u00c0\"-\"\\u00d6\",\n+       \"\\u00d8\"-\"\\u00f6\",\n+       \"\\u00f8\"-\"\\u00ff\",\n+       \"\\u0100\"-\"\\u1fff\",\n+       \"\\u3040\"-\"\\u318f\",\n+       \"\\u3300\"-\"\\u337f\",\n+       \"\\u3400\"-\"\\u3d2d\",\n+       \"\\u4e00\"-\"\\u9fff\",\n+       \"\\uf900\"-\"\\ufaff\"\n+      ]\n+  >\n+|\n+  < #DIGIT:\n+      [\n+       \"\\u0030\"-\"\\u0039\",\n+       \"\\u0660\"-\"\\u0669\",\n+       \"\\u06f0\"-\"\\u06f9\",\n+       \"\\u0966\"-\"\\u096f\",\n+       \"\\u09e6\"-\"\\u09ef\",\n+       \"\\u0a66\"-\"\\u0a6f\",\n+       \"\\u0ae6\"-\"\\u0aef\",\n+       \"\\u0b66\"-\"\\u0b6f\",\n+       \"\\u0be7\"-\"\\u0bef\",\n+       \"\\u0c66\"-\"\\u0c6f\",\n+       \"\\u0ce6\"-\"\\u0cef\",\n+       \"\\u0d66\"-\"\\u0d6f\",\n+       \"\\u0e50\"-\"\\u0e59\",\n+       \"\\u0ed0\"-\"\\u0ed9\",\n+       \"\\u1040\"-\"\\u1049\"\n+      ]\n+  >\n+}\n+\n+\n+TOKEN : /* LITERALS */\n+{\n+  < FLOATING_POINT_LITERAL:\n+    // ([\"+\",\"-\"])?\n+      (\n+        ([\"0\"-\"9\"])+ \".\" ([\"0\"-\"9\"])* (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n+      | \".\" ([\"0\"-\"9\"])+ (<EXPONENT>)? ([\"f\",\"F\",\"d\",\"D\"])?\n+      | ([\"0\"-\"9\"])+ <EXPONENT> ([\"f\",\"F\",\"d\",\"D\"])?\n+      | ([\"0\"-\"9\"])+ (<EXPONENT>)? [\"f\",\"F\",\"d\",\"D\"]\n+      )\n+  >\n+|\n+  < #EXPONENT: [\"e\",\"E\"] ([\"+\",\"-\"])? ([\"0\"-\"9\"])+ >\n+|\n+  // Scrapping the earlier more complicated definition of string listern.\n+  // This is not required on second thoughts - a simpler definition will suffice.\n+   < STRING_LITERAL: \"'\" (~[\"'\"])* \"'\" (\"'\" (~[\"'\"])* \"'\")*>\n+  |\n+  < INTEGER_LITERAL: // ([\"+\",\"-\"])?\n+    [\"0\"-\"9\"] ([\"0\"-\"9\"])* >\n+}\n+\n+\n+\n+\n+void Expression () #void : {}\n+{\n+  ExpressionChoice()\n+  <EOF>\n+}\n+\n+void ExpressionChoice() #void : {}\n+{\n+  LOOKAHEAD(OrLogicalTerm())\n+  OrLogicalTerm() |\n+\n+  AndLogicalTermChoice()\n+}\n+\n+void OrLogicalTerm () #void : {}\n+{\n+  AndLogicalTermChoice() (\n+    ( ( <OR> AndLogicalTermChoice() )\n+      {\n+        jjtThis.setExprFunction(LogicalComparisonFunction.OR_FUNCTION);\n+      }\n+    ) #OrExpr(2)\n+  ) +\n+}\n+\n+void AndLogicalTermChoice() #void : {}\n+{\n+  LOOKAHEAD(AndLogicalTerm())\n+  AndLogicalTerm() |\n+\n+  NotLogicalTermChoice()\n+}\n+\n+void AndLogicalTerm () #void : {}\n+{\n+  NotLogicalTermChoice() (\n+    ( ( <AND> NotLogicalTermChoice() )\n+      {\n+        jjtThis.setExprFunction(LogicalComparisonFunction.AND_FUNCTION);\n+      }\n+    ) #AndExpr(2)\n+  ) +\n+}\n+\n+void NotLogicalTermChoice() #void : {}\n+{\n+  LOOKAHEAD(NotLogicalTerm())\n+  NotLogicalTerm() |\n+\n+  RelationTermChoice()\n+}\n+\n+void NotLogicalTerm () #void : {}\n+{\n+  ( ( <NOT> RelationTermChoice() )\n+    {\n+      jjtThis.setExprFunction(UnaryExprFunction.NOT_FUNCTION);\n+    }\n+  ) #NotExpr(1)\n+}\n+\n+void RelationTermChoice () #void : {}\n+{\n+  LOOKAHEAD(RelationTermOptions())\n+  RelationTermOptions() |\n+\n+  ArithmeticTermChoice()\n+}\n+\n+void RelationTermOptions() #void : {}\n+{\n+\n+  ArithmeticTermChoice()\n+\n+  (\n+    ( ( <GT> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.GREATER_THAN_FUNCTION);\n+      }\n+    ) #GreaterThan(2) |\n+\n+    ( ( <LT> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.LESS_THAN_FUNCTION);\n+      }\n+    ) #LessThan(2) |\n+\n+    ( ( <LE> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.LESS_THAN_EQUAL_TO_FUNCTION);\n+      }\n+    ) #LessThanEqualTo(2) |\n+\n+    ( ( <GE> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.GREATER_THAN_EQUAL_TO_FUNCTION);\n+      }\n+    ) #GreaterThanEqualTo(2) |\n+\n+    ( ( <EQ> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.EQUAL_TO_FUNCTION);\n+      }\n+    ) #EqualTo(2) |\n+\n+    ( ( <NE> ArithmeticTermChoice() )\n+      {\n+        jjtThis.setExprFunction(ValueComparisonFunction.NOT_EQUAL_TO_FUNCTION);\n+      }\n+    ) #NotEqualTo(2) |\n+\n+\n+    LOOKAHEAD(IsNullTerm())\n+    // LOOKAHEAD(2)\n+    IsNullTerm() |\n+\n+    LOOKAHEAD(BetweenTerm())\n+    // LOOKAHEAD(2)\n+    BetweenTerm() |\n+\n+    LOOKAHEAD(InTerm())\n+    // LOOKAHEAD(2)\n+    InTerm() |\n+\n+    LOOKAHEAD(LikeTerm())\n+    // LOOKAHEAD(2)\n+    LikeTerm()\n+  )\n+\n+}\n+\n+\n+\n+void IsNullTerm() #void : {\n+  Token notToken = null;\n+}\n+{\n+  ( ( <IS> ( notToken=<NOT> )? <NULL> )\n+    {\n+      jjtThis.setExprFunction(new PropertyExprFunction.IsNullExpr(null != notToken));\n+    } ) #IsNullExpr(1)\n+}\n+\n+\n+void BetweenTerm() #void : {\n+  Token notToken = null;\n+}\n+{\n+\n+  ( ( ( notToken=<NOT> )? <BETWEEN> ArithmeticTermChoice() <AND> ArithmeticTermChoice() )\n+  {\n+    jjtThis.setExprFunction(new PropertyExprFunction.BetweenExpr(null != notToken));\n+  } ) #BetweenExpr(3)\n+}\n+\n+\n+void InTerm() #void : {\n+  Token notToken = null;\n+}\n+{\n+  ( ( ( notToken=<NOT> )? <IN> <LPAREN> StringVarargParams() <RPAREN> )\n+  {\n+      jjtThis.setExprFunction(new PropertyExprFunction.InExpr(null != notToken));\n+  } ) #InExpr(2)\n+}\n+\n+void LikeTerm() #void : {\n+  Token notToken = null;\n+  Token likePattern = null;\n+  Token escapeCharacter = null;\n+}\n+{\n+  ( ( ( notToken=<NOT> )? <LIKE> likePattern=<STRING_LITERAL> ( <ESCAPE> escapeCharacter=<STRING_LITERAL> )? )\n+  {\n+    jjtThis.setExprFunction(new PropertyExprFunction.LikeExpr(\n+      parseString(likePattern),\n+      parseString(escapeCharacter, true),\n+      null != notToken));\n+  } ) #LikeExpr(1)\n+}\n+\n+\n+\n+\n+\n+void ArithmeticTermChoice () #void : {}\n+{\n+  LOOKAHEAD(AddTerm())\n+  AddTerm() |\n+\n+  MultTermChoice()\n+}\n+\n+void AddTerm () #void : {}\n+{\n+\n+  MultTermChoice() (\n+     ( (<PLUS> MultTermChoice() )\n+       {\n+         jjtThis.setExprFunction(BinaryArithmeticFunction.ADD_FUNCTION);\n+       }\n+     ) #AddExpr(2) |\n+\n+     ( (<MINUS> MultTermChoice() )\n+       {\n+         jjtThis.setExprFunction(BinaryArithmeticFunction.SUB_FUNCTION);\n+       }\n+     ) #SubExpr(2)\n+  ) +\n+}\n+\n+void MultTermChoice() #void : {}\n+{\n+  LOOKAHEAD(MultTerm())\n+  MultTerm() |\n+\n+  UnaryUnitChoice()\n+}\n+\n+void MultTerm() #void : {}\n+{\n+  UnaryUnitChoice() (\n+     ( ( <SLASH> UnaryUnitChoice() )\n+       {\n+         jjtThis.setExprFunction(BinaryArithmeticFunction.DIVIDE_FUNCTION);\n+       }\n+     ) #DivideExpr(2) |\n+\n+     ( ( <STAR> UnaryUnitChoice() )\n+     {\n+       jjtThis.setExprFunction(BinaryArithmeticFunction.MULTIPLY_FUNCTION);\n+     }\n+    ) #MultiplyExpr(2)\n+  ) +\n+}\n+\n+\n+void UnaryUnitChoice() #void : {}\n+{\n+  LOOKAHEAD(UnaryUnit())\n+  UnaryUnit() |\n+\n+  BasicUnit()\n+}\n+\n+void UnaryUnit() #void : {}\n+{\n+  LOOKAHEAD( <MINUS> BasicUnit() )\n+  ( ( <MINUS> BasicUnit() )\n+    {\n+      jjtThis.setExprFunction(UnaryArithmeticFunction.NEGATE_FUNCTION);\n+    }\n+  ) #NegateExpr(1) |\n+\n+  // Ignore if + value.\n+  LOOKAHEAD( <PLUS> BasicUnit() )\n+  ( ( <PLUS> BasicUnit() )\n+    {\n+      // noop\n+    }\n+  )\n+}\n+\n+void BasicUnit() #void :  {\n+  Token identifier = null;\n+}\n+{\n+  // An expression within braces for grouping\n+\n+  // LOOKAHEAD(<LPAREN> ExpressionChoice() <RPAREN>)\n+  (<LPAREN> ExpressionChoice() <RPAREN>) |\n+\n+  // LOOKAHEAD(Constant())\n+  Constant() |\n+\n+  // LOOKAHEAD(<IDENTIFIER>)\n+  ( ( identifier=<IDENTIFIER> )\n+  {\n+    jjtThis.setExprFunction(new PropertyExprFunction.LookupExpr(parseIdentifier(identifier)));\n+  } ) #LookupExpr(0)\n+}\n+\n+\n+\n+void Constant() : {\n+  Token bt, it, ft;\n+  Token st;\n+}\n+{\n+  bt=<BOOLEAN_LITERAL>\n+  {\n+    jjtThis.setConstantValue(new SelectorConstant(Boolean.parseBoolean(bt.image.toLowerCase())));\n+  } |\n+  ft=<FLOATING_POINT_LITERAL>\n+  {\n+    jjtThis.setConstantValue(new SelectorConstant(Double.parseDouble(ft.image)));\n+  }\n+  |\n+  st=<STRING_LITERAL>\n+  {\n+    jjtThis.setConstantValue(new SelectorConstant(parseString(st)));\n+  } |\n+  it=<INTEGER_LITERAL>\n+  {\n+    jjtThis.setConstantValue(new SelectorConstant(Integer.parseInt(it.image)));\n+  }\n+}\n+\n+\n+void StringVarargParams() : {\n+  Token st;\n+}\n+{\n+  st=<STRING_LITERAL>\n+  {\n+    Set<String> set = new HashSet<String>(4);\n+    set.add(parseString(st));\n+    jjtThis.setConstantValue(new SelectorConstant(set));\n+  }\n+\n+  ( ( <COMMA> st=<STRING_LITERAL> )\n+  {\n+    jjtThis.addToStringSet(parseString(st));\n+  }\n+  )*\n+\n+}"},{"sha":"1a77fcfeec29a5780c758a7e49a1440070b15cfd","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","status":"added","additions":476,"deletions":0,"changes":476,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,476 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionConsumer;\n+import javax.jms.ConnectionMetaData;\n+import javax.jms.Destination;\n+import javax.jms.ExceptionListener;\n+import javax.jms.InvalidClientIDException;\n+import javax.jms.JMSException;\n+import javax.jms.Queue;\n+import javax.jms.QueueConnection;\n+import javax.jms.ServerSessionPool;\n+import javax.jms.Topic;\n+import javax.jms.TopicConnection;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Implementation of jmx Connection\n+ * MUST be MT-safe (2.8)\n+ */\n+public abstract class ConnectionImpl implements Connection, TopicConnection, QueueConnection {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ConnectionImpl.class);\n+\n+    // Copied from old HedwigConnectoin\n+    // TODO move to a constants class?\n+    public static final String HEDWIG_CLIENT_CONFIG_FILE = \"hedwig.client.config.file\";\n+    private static final Set<String> globalClientIdSet = new HashSet<String>(16);\n+\n+    private final String user;\n+    private final String password;\n+\n+    // Will be set to a random string if unspecified - we do not have a way (currently) for admin\n+    // specified value ...\n+    // Note, using the system property means\n+    // private String clientID = System.getProperty(\"HEDWIG_CLIENT_ID\", null);\n+    private volatile String clientID = null;\n+\n+    // I do not like locking on 'this' inspite of the perf diff - allows 'others' to lock on our\n+    // lock object (client code for example) : leaks MT-safety.\n+    private final Object lockObject = new Object();\n+\n+    // Call this when there are issues (primarily connection issues imo).\n+    // There are two issues with supporting this :\n+    // a) we do not follow jms model of connection -> multiple sessions; for us, connection does not\n+    // represent underlying connection to\n+    // hedwig, but session does. So the basic model does not fit.\n+    // b) from what I see, hedwig-client does not expose the ability to do this. (it automatically reconnects)\n+    // hence we do not support this yet.\n+    private volatile ExceptionListener exceptionListener;\n+\n+    // connection 'starts' in stopped mode.\n+    // Until it is started, NO messages MUST be delivered - 4.3.3\n+    private StateManager connectionState = new StateManager(StateManager.State.STOPPED, lockObject);\n+\n+    private final List<SessionImpl> sessionList = new ArrayList<SessionImpl>(4);\n+    private final ConnectionMetaData metadata = new ConnectionMetaDataImpl();\n+\n+    protected ConnectionImpl() {\n+        this.user = null;\n+        this.password = null;\n+    }\n+\n+    protected ConnectionImpl(String user, String password) {\n+        this.user = user;\n+        this.password = password;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SessionImpl createSession(boolean transacted, int acknowledgeMode)  throws JMSException {\n+        return createSessionImpl(transacted, acknowledgeMode, null);\n+    }\n+\n+    protected SessionImpl createSessionImpl(boolean transacted, int acknowledgeMode,\n+                                            MessagingSessionFacade.DestinationType type)  throws JMSException {\n+        final boolean needStart;\n+        synchronized (lockObject){\n+            if (connectionState.isInCloseMode())\n+              throw new javax.jms.IllegalStateException(\"Connection closed\");\n+            if (connectionState.isTransitionState()) {\n+                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                // Not expected actually, present to guard against future changes ...\n+                if (connectionState.isTransitionState())\n+                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n+\n+            }\n+\n+            assert StateManager.State.STOPPED == connectionState.getCurrentState() ||\n+                    StateManager.State.STARTED == connectionState.getCurrentState();\n+\n+            // create within lock, so that it can register with connection, etc ...\n+            // session = new SessionImpl(this, transacted, acknowledgeMode);\n+            final SessionImpl session = createSessionInstance(transacted, acknowledgeMode, type);\n+            sessionList.add(session);\n+            needStart = connectionState.isStarted();\n+\n+            if (needStart) session.start();\n+            return session;\n+        }\n+    }\n+\n+    protected abstract SessionImpl createSessionInstance(boolean transacted, int acknowledgeMode,\n+                                                         MessagingSessionFacade.DestinationType type)\n+        throws JMSException;\n+\n+    public boolean removeSession(SessionImpl session){\n+        // simply remove.\n+        synchronized (lockObject){\n+            return sessionList.remove(session);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String getClientID() {\n+        return clientID;\n+    }\n+\n+    /**\n+     * Allow clientID to be set only if it is NOT administratively configured for connection. (4.3.2)\n+     * Since we do not work (yet) within the context of a container, this aspect is a TODO for now.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void setClientID(String clientID) throws InvalidClientIDException, javax.jms.IllegalStateException {\n+        if (null == clientID) throw new InvalidClientIDException(\"clientId specified is null\");\n+\n+        synchronized (globalClientIdSet){\n+            if (globalClientIdSet.contains(clientID))\n+              throw new InvalidClientIDException(\"clientId '\" + clientID + \"' already in use in this provider\");\n+            if (null != this.clientID && !this.clientID.equals(clientID))\n+              throw new javax.jms.IllegalStateException(\"clientID already set to \" + this.clientID +\n+                  \", cant override to \" + clientID);\n+            this.clientID = clientID;\n+            globalClientIdSet.add(clientID);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ConnectionMetaData getMetaData() throws JMSException {\n+        // return new ConnectionMetaDataImpl();\n+        return metadata;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ExceptionListener getExceptionListener() throws JMSException {\n+        return exceptionListener;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void setExceptionListener(ExceptionListener exceptionListener) throws JMSException {\n+        this.exceptionListener = exceptionListener;\n+    }\n+\n+    public void initConnectionClientID() throws javax.jms.IllegalStateException, InvalidClientIDException {\n+        synchronized (lockObject){\n+            // default to hedwig_client_id ?\n+            if (null == clientID) setClientID(SessionImpl.generateRandomString());\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void start() throws JMSException {\n+\n+        final StateManager.State prevState;\n+        final List<SessionImpl> sessionListCopy;\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to start connection\");\n+\n+        synchronized (lockObject){\n+            if (connectionState.isStarted()) return ;\n+            if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n+\n+            if (connectionState.isTransitionState()){\n+                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                // Not expected actually, present to guard against future changes ...\n+                if (connectionState.isTransitionState())\n+                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                if (connectionState.isClosed()) throw new JMSException(\"Connection already closed\");\n+                if (connectionState.isStarted()) return ;\n+\n+                assert connectionState.isStopped();\n+                // try again ...\n+            }\n+\n+            prevState = connectionState.getCurrentState();\n+            connectionState.setCurrentState(StateManager.State.STARTING);\n+            initConnectionClientID();\n+            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n+        }\n+\n+        StateManager.State nextState = prevState;\n+        try {\n+            // There will be only one thread down here ...\n+\n+            // start any provider specific implementation bootstrap ...\n+            doStart(user, password);\n+            // Copy to prevent concurrent mod exceptions.\n+            if (logger.isTraceEnabled()) logger.trace(\"Starting \" + sessionListCopy.size() + \" sessions\");\n+            for (SessionImpl session : sessionListCopy) {\n+                try {\n+                    session.start();\n+                } catch (JMSException jex){\n+                    // log the error and ignore\n+                    if (logger.isInfoEnabled()) logger.info(\"exception starting session : \" + jex);\n+                    DebugUtil.dumpJMSStacktrace(logger, jex);\n+                }\n+            }\n+            nextState = StateManager.State.STARTED;\n+        } finally {\n+            // set status and notify.\n+            synchronized (lockObject){\n+                connectionState.setCurrentState(nextState);\n+                lockObject.notifyAll();\n+            }\n+        }\n+    }\n+\n+\n+    protected String getUser(){\n+        return user;\n+    }\n+    protected String getPassword(){\n+        return password;\n+    }\n+\n+    protected abstract void doStart(String user, String password) throws JMSException;\n+    protected abstract void doStop();\n+    protected abstract void doClose();\n+\n+    @Override\n+    public void stop() throws JMSException {\n+\n+        final StateManager.State prevState;\n+        final List<SessionImpl> sessionListCopy;\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to stop connection\");\n+\n+        synchronized (lockObject){\n+            if (connectionState.isClosed()) throw new JMSException(\"Already closed\");\n+            if (connectionState.isStopped()) return ;\n+\n+            if (connectionState.isTransitionState()){\n+                connectionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                // Not expected actually, present to guard against future changes ...\n+                if (connectionState.isTransitionState())\n+                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                if (connectionState.isClosed()) throw new JMSException(\"Already closed\");\n+                if (connectionState.isStopped()) return ;\n+\n+                assert connectionState.isStarted();\n+\n+                // try (again ?) ...\n+            }\n+\n+            prevState = connectionState.getCurrentState();\n+            connectionState.setCurrentState(StateManager.State.STOPPING);\n+            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n+        }\n+\n+        StateManager.State nextState = prevState;\n+        try {\n+            // In case there are any specific changes to be done.\n+            // Copy to prevent concurrent mod exceptions.\n+\n+            // Stop all sessions - doing this within MT-safe block to prevent any possibility of race conditions.\n+            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n+            if (logger.isTraceEnabled()) logger.trace(\"Stopping \" + sessionListCopy.size() + \" sessions\");\n+            for (SessionImpl session : sessionListCopy) {\n+                try {\n+                    session.stop();\n+                } catch (JMSException jex){\n+                    // log the error and ignore\n+                    if (logger.isInfoEnabled()) logger.info(\"exception closing session : \" + jex);\n+                    DebugUtil.dumpJMSStacktrace(logger, jex);\n+                }\n+            }\n+            // stop connection AFTER session's are stopped.\n+            doStop();\n+            nextState = StateManager.State.STOPPED;\n+        } finally {\n+            // set status and notify.\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+                connectionState.setCurrentState(nextState);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws JMSException {\n+\n+        final StateManager.State prevState;\n+        final List<SessionImpl> sessionListCopy;\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to close connection\");\n+\n+        synchronized (lockObject){\n+            if (connectionState.isClosed()) return ;\n+            if (! connectionState.isStopped()) {\n+                if (connectionState.isTransitionState()){\n+                    connectionState.waitForTransientStateChange(\n+                            StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                    // Not expected actually, present to guard against future changes ...\n+                    if (connectionState.isTransitionState())\n+                      throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                    if (connectionState.isClosed()) return ;\n+\n+                    assert connectionState.isStarted() || connectionState.isStopped();\n+                }\n+            }\n+\n+            prevState = connectionState.getCurrentState();\n+            connectionState.setCurrentState(StateManager.State.CLOSING);\n+            sessionListCopy = new ArrayList<SessionImpl>(sessionList);\n+        }\n+\n+        StateManager.State nextState = prevState;\n+\n+        try {\n+            // Copy to prevent concurrent mod exceptions.\n+\n+            // Close all sessions - doing this within MT-safe block to prevent any possibility of race conditions.\n+            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n+            if (logger.isTraceEnabled()) logger.trace(\"Closing \" + sessionListCopy.size() + \" sessions\");\n+            for (SessionImpl session : sessionListCopy) {\n+                try {\n+                    session.close();\n+                } catch (Exception ex){\n+                    // log the error and ignore\n+                    if (logger.isDebugEnabled()) logger.debug(\"exception closing session\", ex);\n+                    else if (logger.isInfoEnabled()) logger.info(\"exception closing session : \" + ex);\n+                }\n+            }\n+            doClose();\n+            synchronized (globalClientIdSet){\n+                assert (null != getClientID());\n+                globalClientIdSet.remove(getClientID());\n+            }\n+            nextState = StateManager.State.CLOSED;\n+        } finally {\n+            // set status and notify.\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+\n+                if (StateManager.State.CLOSED == nextState && !connectionState.isClosed()) {\n+                    // clear sessions.\n+                    sessionList.clear();\n+                }\n+                // set after everything is done.\n+                connectionState.setCurrentState(nextState);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector,\n+                                                       ServerSessionPool sessionPool, int maxMessages)\n+        throws JMSException {\n+\n+        throw new JMSException(\"Unsupported\");\n+    }\n+\n+    @Override\n+    public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName,\n+                                                              String messageSelector, ServerSessionPool sessionPool,\n+                                                              int maxMessages)\n+        throws JMSException {\n+\n+        throw new JMSException(\"Unsupported\");\n+    }\n+\n+    @Override\n+    public ConnectionConsumer createConnectionConsumer(Queue queue, String s,\n+                                                       ServerSessionPool serverSessionPool, int maxMessages)\n+        throws JMSException {\n+\n+        throw new JMSException(\"Unsupported\");\n+    }\n+\n+\n+    @Override\n+    public ConnectionConsumer createConnectionConsumer(Topic topic, String messageSelector,\n+                                                       ServerSessionPool sessionPool, int maxMessages)\n+        throws JMSException {\n+\n+        throw new JMSException(\"Unsupported\");\n+    }\n+\n+    public boolean isInStartMode() {\n+        return connectionState.isInStartMode();\n+    }\n+\n+    protected abstract MessagingSessionFacade createMessagingSessionFacade(SessionImpl session) throws JMSException;\n+\n+\n+    // required to catch resource leaks ...\n+    @Override\n+    protected void finalize() throws Throwable {\n+        super.finalize();\n+        if (!connectionState.isClosed()) {\n+            if (logger.isErrorEnabled()) logger.error(\"Connection was NOT closed before it went out of scope\");\n+            close();\n+        }\n+    }\n+\n+    private static final int LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE =\n+        Integer.getInteger(\"LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE\", 1024);\n+    // This is gaurded by publishedMessageIds\n+    private final LRUCacheSet<String> publishedMessageIds =\n+        new LRUCacheSet<String>(LOCALLY_SENT_MESSAGE_ID_CACHE_SIZE, true);\n+\n+    boolean isLocallyPublished(String messageId){\n+\n+        if (null == messageId) return false;\n+\n+        synchronized(publishedMessageIds){\n+            return publishedMessageIds.contains(messageId);\n+        }\n+    }\n+\n+    void addToLocallyPublishedMessageIds(String messageId){\n+\n+        if (null == messageId) return ;\n+\n+        synchronized(publishedMessageIds){\n+            publishedMessageIds.add(messageId);\n+        }\n+    }\n+}"},{"sha":"12210ac2e59c273709a57fcbc1d140b68e5d7048","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/ConnectionMetaDataImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,77 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms;\n+\n+import javax.jms.ConnectionMetaData;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+\n+/**\n+ * Metadata about the provider and/or connection.\n+ */\n+public class ConnectionMetaDataImpl implements ConnectionMetaData {\n+    public static final int JMS_MAJOR_VERSION = 1;\n+    public static final int JMS_MINOR_VERSION = 1;\n+    // What should be the value ?\n+    public static final String PROVIDER_NAME = \"hedwig.jms.provider\";\n+\n+    public static final int PROVIDER_MAJOR_VERSION = 1;\n+    public static final int PROVIDER_MINOR_VERSION = 0;\n+\n+    @Override\n+    public String getJMSVersion() {\n+        return JMS_MAJOR_VERSION + \".\" + JMS_MINOR_VERSION;\n+    }\n+\n+    @Override\n+    public int getJMSMajorVersion() {\n+        return JMS_MAJOR_VERSION;\n+    }\n+\n+    @Override\n+    public int getJMSMinorVersion() {\n+        return JMS_MINOR_VERSION;\n+    }\n+\n+    @Override\n+    public String getJMSProviderName() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public String getProviderVersion() {\n+        return getJMSVersion();\n+    }\n+\n+    @Override\n+    public int getProviderMajorVersion() {\n+        return PROVIDER_MAJOR_VERSION;\n+    }\n+\n+    @Override\n+    public int getProviderMinorVersion() {\n+        return PROVIDER_MINOR_VERSION;\n+    }\n+\n+    // None right now ... add more as required.\n+    @Override\n+    public Enumeration getJMSXPropertyNames() {\n+        // return Collections.emptyEnumeration();\n+        return Collections.enumeration(Collections.emptyList());\n+    }\n+}"},{"sha":"0e6d27fb462536c50cc5350c022e7f3c911198c1","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/DebugUtil.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms;\n+\n+import javax.jms.JMSException;\n+import java.io.PrintStream;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Contains some Debug Util methods.\n+ */\n+public final class DebugUtil {\n+\n+  public static void dumpAllStacktraces(Logger logger) {\n+        logger.debug(generateDumpAllStacktraces());\n+    }\n+\n+    public static void dumpAllStacktraces(PrintStream out) {\n+        out.println(generateDumpAllStacktraces());\n+    }\n+\n+    private static String generateDumpAllStacktraces(){\n+        Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();\n+\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(\"Dump start\\n---\\n\");\n+        for (Map.Entry<Thread, StackTraceElement[]> entry : map.entrySet()){\n+            sb.append(\"Thread \").append(entry.getKey()).append(\"\\n\");\n+            for (StackTraceElement traceElement : entry.getValue())\n+                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\n+\n+        }\n+        sb.append(\"---\\nDump done\\n\");\n+\n+        return sb.toString();\n+    }\n+\n+    public static void dumpJMSStacktrace(Logger logger, JMSException jex) {\n+\n+        assert logger.isDebugEnabled();\n+\n+        final Exception linkedException = jex.getLinkedException();\n+        logger.debug(\"exception\" , jex);\n+        if (null != linkedException)  {\n+            logger.debug(\"due to\" , linkedException);\n+        }\n+    }\n+}"},{"sha":"a9e1d50fe1d5c79ba5542698f3a5d66dce14ab09","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheMap.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * An LRUCacheMap\n+ */\n+class LRUCacheMap<K, V> implements Map<K, V> {\n+    private final int maxSize;\n+    private final Map<K, V> cache;\n+\n+    public LRUCacheMap(int maxSize, boolean accessOrder){\n+        this.maxSize = maxSize;\n+\n+        this.cache = new LinkedHashMap<K, V>(maxSize, 0.75f, accessOrder){\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n+                boolean retval = super.removeEldestEntry(eldest);\n+                return retval || super.size() > LRUCacheMap.this.maxSize;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public int size() {\n+        return cache.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return cache.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        return cache.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        return cache.containsValue(value);\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+        return cache.get(key);\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        return cache.put(key, value);\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        return cache.remove(key);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        cache.putAll(m);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        cache.clear();\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return cache.keySet();\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return cache.values();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        return cache.entrySet();\n+    }\n+}"},{"sha":"72ce593a02183e73ec1efb25fad41e6242903412","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/LRUCacheSet.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,115 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+* An LRUCache (set) based on the LRUCacheMap.\n+*/\n+public class LRUCacheSet<E> implements Set<E> {\n+\n+    private final int maxSize;\n+    private final Map<E, E> cache;\n+\n+    public LRUCacheSet(int maxSize, boolean accessOrder){\n+        this.maxSize = maxSize;\n+\n+        this.cache = new LinkedHashMap<E, E>(maxSize, 0.75f, accessOrder){\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<E, E> eldest) {\n+                boolean retval = super.removeEldestEntry(eldest);\n+                return retval || super.size() > LRUCacheSet.this.maxSize;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public int size() {\n+        return cache.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return cache.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean contains(Object val) {\n+        return cache.containsKey(val);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return cache.keySet().iterator();\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return cache.keySet().toArray();\n+    }\n+\n+    @Override\n+    public <T> T[] toArray(T[] a) {\n+        return cache.keySet().toArray(a);\n+    }\n+\n+    @Override\n+    public boolean add(E val) {\n+        return null == cache.put(val, val);\n+    }\n+\n+    @Override\n+    public boolean remove(Object val) {\n+        if (! contains(val)) return false;\n+        cache.remove(val);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        return cache.keySet().containsAll(c);\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> c) {\n+        boolean retval = false;\n+        for (E e : c) retval = retval | add(e);\n+        return retval;\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        return cache.keySet().retainAll(c);\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        return cache.keySet().removeAll(c);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        cache.clear();\n+    }\n+}"},{"sha":"63cf0cc8e9be7888ff2dc1658eee2037ad2813d4","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","status":"added","additions":421,"deletions":0,"changes":421,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/MessagingSessionFacade.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,421 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Queue;\n+import javax.jms.QueueBrowser;\n+import javax.jms.QueueReceiver;\n+import javax.jms.QueueSender;\n+import javax.jms.TemporaryQueue;\n+import javax.jms.TemporaryTopic;\n+import javax.jms.Topic;\n+import javax.jms.TopicPublisher;\n+import javax.jms.TopicSubscriber;\n+\n+/**\n+ * Encapsulates the actual implementation away from the rest of the system. <br/>\n+ * This will allow us to, potentially, change the underlying messaging implementation with minimal\n+ * disruption to the provide code.<br/>\n+ * <p/>\n+ * Note that provider specific validation to conform to JMS spec must be done BEFORE invoking the\n+ * business methods here.<br/>\n+ * These are supposed to handle ONLY implementation specific logic, not JMS specific constraint\n+ * enforcement(s), etc.<br/>\n+ * <p/>\n+ * Since hedwig itself might undergo changes due to the JMS provider effort, this will allow us to\n+ * decouple the changes.<br/>\n+ * In addition, it is an easy way for us to create proxy objects to allow for testing various\n+ * aspects of the provider without depending\n+ * on hedwig itself (via test facade impl's). <br/>\n+ * <p/>\n+ * Most of the javadoc's are pretty much verbatim copied from corresponding JMS javadoc's :-)\n+ *\n+ * <p/>\n+ * Note that, typically, actual ConnectionImpl and MessagingSessionFacade used are tightly coupled.\n+ * ConnectionImpl is the base class to the actual implementations ...\n+ */\n+public interface MessagingSessionFacade {\n+\n+\n+\n+    public enum DestinationType { QUEUE, TOPIC }\n+\n+    /**\n+     * Starts the session.\n+     *\n+     * @throws JMSException If we are unable to initialize hedwig client (typically).\n+     */\n+    public void start() throws JMSException;\n+\n+    /**\n+     * Stop the session.\n+     *\n+     * @throws JMSException If we are unable to stop hedwig client (typically).\n+     */\n+    public void stop() throws JMSException;\n+\n+    /**\n+     * Close the session.\n+     */\n+    public void close();\n+\n+    /**\n+     * Given a destination, find out if it is a queue or topic. Required for createProducer(),\n+     * createConsumer() methods in session.\n+     * @param destination The specified destination.\n+     * @return Its type.\n+     * @throws javax.jms.JMSException In case of internal errors.\n+     */\n+    public DestinationType findDestinationType(String destination) throws JMSException;\n+\n+    /**\n+     * Given a destination, find out if it is a queue or topic. Required for createProducer(),\n+     * createConsumer() methods in session.\n+     * @param destination The specified destination.\n+     * @return Its type.\n+     * @throws javax.jms.JMSException In case of internal errors.\n+     */\n+    public DestinationType findDestinationType(Destination destination) throws JMSException;\n+\n+    /**\n+     * Create a topic publisher to the specified destination.\n+     * @param destination The topic to publish to\n+     * @return A topic publisher for the topic specified\n+     * @throws javax.jms.JMSException In case of internal error.\n+     */\n+    public TopicPublisher createTopicPublisher(Destination destination) throws JMSException;\n+\n+\n+    /**\n+     * Create a queue sender to the specified destination.\n+     * @param destination The queue to publish to\n+     * @return A queue sender for the queue specified\n+     * @throws javax.jms.JMSException In case of internal error.\n+     */\n+    public QueueSender createQueueSender(Destination destination) throws JMSException;\n+\n+    /**\n+     * Create a topic subscriber for the specified destination.\n+     * @param destination The topic name\n+     * @return Topic subscriber for the topic.\n+     * @throws javax.jms.JMSException In case of internal error.\n+     */\n+    public TopicSubscriber createTopicSubscriber(Destination destination) throws JMSException;\n+\n+    /**\n+     * Create a queue receiver for the specified destination.\n+     * @param destination The queue name\n+     * @return Queue receiver for the queue.\n+     * @throws javax.jms.JMSException In case of internal error.\n+     */\n+    public QueueReceiver createQueueReceiver(Destination destination) throws JMSException;\n+\n+    /**\n+     * Create a queue receiver for the specified destination.\n+     * @param destination destination\n+     * @param messageSelector selector to apply\n+     * @return A queue receiver conforming to the constraints.\n+     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n+     */\n+    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector) throws JMSException;\n+\n+    /**\n+     * Create a topic subscriber for the specified destination.\n+     * @param destination destination\n+     * @param messageSelector selector to apply\n+     * @param noLocal should locally published messages be received. Note, for now, we do not (yet) support this.\n+     * @return A topic subscriber conforming to the constraints.\n+     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n+     */\n+    public TopicSubscriber createTopicSubscriber(Destination destination, String messageSelector,\n+                                                 boolean noLocal) throws JMSException;\n+\n+    /**\n+     * Create a queue receiver for the specified destination.\n+     * @param destination destination\n+     * @param messageSelector selector to apply\n+     * @param noLocal should locally published messages be received. Note, for now, we do not (yet) support this.\n+     * @return A queue receiver conforming to the constraints.\n+     * @throws javax.jms.JMSException In case of internal error or unsatisfiable constraints.\n+     */\n+    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector,\n+                                             boolean noLocal) throws JMSException;\n+\n+\n+    /**\n+     * Creates a durable subscriber to the specified topic. <br/>\n+     * <p/>\n+     * If a client needs to receive all the messages published on a topic, including the ones\n+     * published while the\n+     * subscriber is inactive, it uses a durable TopicSubscriber.\n+     * The JMS provider retains a record of this durable subscription and insures that all messages\n+     * from the\n+     * topic's publishers are retained until they are acknowledged by this durable subscriber or\n+     * they have expired.\n+     * <p/>\n+     * Sessions with durable subscribers must always provide the same client identifier.\n+     * In addition, each client must specify a subscribedId that uniquely identifies (within client\n+     * identifier) each durable\n+     * subscription it creates. Only one session at a time can have a TopicSubscriber for a particular\n+     * durable subscription.\n+     * <p/>\n+     * A client can change an existing durable subscription by creating a durable TopicSubscriber\n+     * with the same subscribedId\n+     * and a new topic and/or message selector.\n+     * Changing a durable subscriber is equivalent to unsubscribing (deleting) the old one and\n+     * creating a new one.\n+     * <p/>\n+     * In some cases, a connection may both publish and subscribe to a topic.\n+     * The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages\n+     * published by its own connection.\n+     * The default value for this attribute is false.\n+     *\n+     * @param topic The topic to subscribe to.\n+     * @param subscribedId Name used to identify the subscription. This should be a combination\n+     *  of the client-id and the session and is expected to be unique.\n+     * Only a single subscription can be active for a given subscribedId.\n+     * @return The topicsubscriber which will recieve messages for the topic.\n+     * @throws JMSException if failure due to some error\n+     */\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Creates a durable subscriber to the specified topic. <br/>\n+     * <p/>\n+     * If a client needs to receive all the messages published on a topic, including the ones published while the\n+     * subscriber is inactive, it uses a durable TopicSubscriber.\n+     * The JMS provider retains a record of this durable subscription and insures that all messages\n+     * from the\n+     * topic's publishers are retained until they are acknowledged by this durable subscriber or\n+     * they have expired.\n+     * <p/>\n+     * Sessions with durable subscribers must always provide the same client identifier.\n+     * In addition, each client must specify a subscribedId that uniquely identifies (within client\n+     * identifier) each durable\n+     * subscription it creates. Only one session at a time can have a TopicSubscriber for a particular\n+     * durable subscription.\n+     * <p/>\n+     * A client can change an existing durable subscription by creating a durable TopicSubscriber with\n+     * the same subscribedId\n+     * and a new topic and/or message selector.\n+     * Changing a durable subscriber is equivalent to unsubscribing (deleting) the old one and\n+     * creating a new one.\n+     * <p/>\n+     * In some cases, a connection may both publish and subscribe to a topic.\n+     * The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages\n+     * published by its own connection.\n+     * The default value for this attribute is false.\n+     *\n+     * @param topic The topic to subscribe to.\n+     * @param subscribedId Name used to identify the subscription. This should be a combination of\n+     *  the client-id and the session and is expected to be unique.\n+     * Only a single subscription can be active for a given subscribedId.\n+     * @param messageSelector The selector to filter the messages on.\n+     * @param noLocal Should local messages be delivered or not.\n+     * Note that noLocal implementation is NOT currently supported by hedwig and should be simulated\n+     *  by us in the provider ...\n+     * @return The topicsubscriber which will recieve messages for the topic.\n+     * @throws JMSException if failure due to some error\n+     */\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId,\n+                                                   String messageSelector, boolean noLocal) throws JMSException;\n+\n+    /**\n+     *\n+     * @param queue The queue\n+     * @return Create a queue browser for the specified queue.\n+     */\n+    public QueueBrowser createBrowser(Queue queue) throws JMSException;\n+\n+    /**\n+     *\n+     * @param queue The queue\n+     * @param messageSelector The selector to apply\n+     * @return Create a queue browser for the specified queue.\n+     */\n+    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException;\n+\n+    /**\n+     * Creates a TemporaryTopic object. Its lifetime will be that of the Connection unless it is deleted earlier.\n+     * JMS VIOLATION: Most probably we will violate JMS spec here since session &lt;-&gt; hedwig\n+     * connection and not connection &lt;-&gt; hedwig connection ...\n+     * This is, assuming ofcourse, that we can create temporary topic's !\n+     *\n+     * @return A temporary topic.\n+     * @throws JMSException In case of exceptions creating a queue.\n+     */\n+    public TemporaryTopic createTemporaryTopic() throws JMSException;\n+\n+\n+    /**\n+     * Creates a TemporaryQueue object. Its lifetime will be that of the Connection unless it is deleted earlier.\n+     * JMS VIOLATION: Most probably we will violate JMS spec here since session &lt;-&gt; hedwig\n+     * connection and not connection &lt;-&gt; hedwig connection ...\n+     * This is, assuming ofcourse, that we can create temporary topic's !\n+     *\n+     * @return A temporary queue.\n+     * @throws JMSException In case of exceptions creating a queue.\n+     */\n+    public TemporaryQueue createTemporaryQueue() throws JMSException;\n+\n+    /**\n+     * Starts a durable subscription for a client.\n+     *\n+     * @param topicName The topic name\n+     * @param subscribedId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void subscribeToTopic(String topicName, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Unsubscribes a durable subscription that has been created by a client.\n+     * <p/>\n+     * This method deletes the state being maintained on behalf of the subscriber by its provider.\n+     * <p/>\n+     * <br/>\n+     * Note that it is erroneous for a client to delete a durable subscription while there is an\n+     * active MessageConsumer or TopicSubscriber for the subscription,\n+     * or while a consumed message is part of a pending transaction or has not been acknowledged in the session.\n+     * <br/> <b>This validation MUST be done BEFORE invoking this method !</b>\n+     *\n+     * @param topicName The topic name\n+     * @param subscribedId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Starts delivery of messages from a Topic. <br/>\n+     *\n+     * @param topicName The topic name\n+     * @param subscribedId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void startTopicDelivery(String topicName, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Starts delivery of messages from a Queue. <br/>\n+     *\n+     * @param queueName The queue name\n+     * @param subscriberId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void startQueueDelivery(String queueName, String subscriberId) throws JMSException;\n+\n+    /**\n+     * Stops delivery of messages from a Topic. <br/>\n+     *\n+     * @param topicName The topic name\n+     * @param subscribedId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Stops delivery of messages from a Queue. <br/>\n+     *\n+     * @param queueName The queue name\n+     * @param subscribedId The subscription subscribedId\n+     * @throws JMSException In case of exceptions unsubscribing.\n+     */\n+    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException;\n+\n+    /**\n+     * Register an unacknowledged message. This is to be used when session is going to NOT manage\n+     * acknowledgements and\n+     * expects clients to explicitly call message.acknowledge().\n+     * This is true when : session is not transacted and it is in CLIENT_ACKNOWLEDGE mode.\n+     *\n+     * Note that invocation of this method MUST be in the order it was received from the server :\n+     * since hedwig does ack-until-N.\n+     *\n+     * @param message The un-ack message.\n+     */\n+    public void registerUnAcknowledgedMessage(SessionImpl.ReceivedMessage message);\n+\n+    /**\n+     * Acknowledge the jms message to hedwig.\n+     *\n+     * @param message The message to acknowledge.\n+     * @throws javax.jms.JMSException In case of internal errors while sending acknowledgement to hedwig\n+     */\n+    public void acknowledge(MessageImpl message) throws JMSException;\n+\n+    /**\n+     * Get the subscriber id of the TopicSubscriber.\n+     * @param topicSubscriber This must be a topic subscriber created using this facade.\n+     * @return The subscriber id of the subscriber.\n+     * @throws JMSException Typically in case this is NOT an instance compatible with this facade.\n+     */\n+    public String getSubscriberId(TopicSubscriber topicSubscriber) throws JMSException;\n+\n+    /**\n+     * Get the subscriber id of the QueueReceiver.\n+     * @param queueReceiver  This must be a queue receiver created using this facade.\n+     * @return The subscriber id of the subscriber.\n+     * @throws JMSException Typically in case this is NOT an instance compatible with this facade.\n+     */\n+    public String getSubscriberId(QueueReceiver queueReceiver) throws JMSException;\n+\n+    /**\n+     * Enqueue a message for consumption by the subscriber.\n+     * This happens when there are one or more 'recieve()' calls possible.\n+     * <p/>\n+     * The typically flow is : client DOES NOT use <br/>\n+     * {@link javax.jms.Session#setMessageListener(javax.jms.MessageListener)}<br/>\n+     * but directly creates One or more Subscribers via (For Topics) :<br/>\n+     * {@link javax.jms.Session#createConsumer(javax.jms.Destination)},<br/>\n+     * {@link javax.jms.Session#createConsumer(javax.jms.Destination, String)},<br/>\n+     * {@link javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)},<br/>\n+     * Or directly using Topic api using.<br/>\n+     * {@link javax.jms.TopicSession#createSubscriber(javax.jms.Topic)},<br/>\n+     * {@link javax.jms.TopicSession#createSubscriber(javax.jms.Topic, String, boolean)},<br/>\n+     * {@link javax.jms.TopicSession#createDurableSubscriber(javax.jms.Topic, String)},<br/>\n+     * {@link javax.jms.TopicSession#createDurableSubscriber(javax.jms.Topic, String, String, boolean)}<br/>\n+     * <p/>\n+     * The message is the enqueued in the subscriber for subsequent consumption by<br/>\n+     * {@link javax.jms.TopicSubscriber#receive()} or variants,<br/>\n+     * {@link javax.jms.MessageConsumer#receive()} or variants.<br/>\n+     *\n+     * @param subscriber The subscriber of the message.\n+     * @param receivedMessage The message to dispatch.\n+     * @param addFirst Add to begining of the received list or at end. (usually addFirst == true for\n+     * txn rollback recovery).\n+     * @throws javax.jms.JMSException If not a valid subscriber (for now).\n+     * @return Was the message successfully enqueud to the subscriber. Typically fails if already closed.\n+     */\n+    public boolean enqueueReceivedMessage(MessageConsumer subscriber, SessionImpl.ReceivedMessage receivedMessage,\n+                                          boolean addFirst) throws JMSException;\n+\n+\n+    /**\n+     *\n+     * Publish a message to the topic specified.\n+     *\n+     * @param topicName The topic to publish to.\n+     * @param message The message to send.\n+     * @throws JMSException In case of errors publishing message.\n+     * @return The message-id to be set as JMSMessageID\n+     */\n+    public String publish(String topicName, MessageImpl message) throws JMSException;\n+}"},{"sha":"7689d3b20cf2dc60eea3b11114548d3fb9cff6d6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/Mutable.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms;\n+\n+/**\n+ * A simple utility class to ship values around even particularly when variable is immutable\n+ * (like pass from inner class to outer context).\n+ */\n+public final class Mutable<T> {\n+    private T value;\n+\n+    public Mutable(T value){\n+        this.value = value;\n+    }\n+\n+    public T getValue() {\n+        return value;\n+    }\n+\n+    public void setValue(T value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\" + value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Mutable mutable = (Mutable) o;\n+\n+        if (value != null ? !value.equals(mutable.value) : mutable.value != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return value != null ? value.hashCode() : 0;\n+    }\n+}"},{"sha":"b741a8bdfa27ca27b4232c1cffccf2bf43d0e17e","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","status":"added","additions":2009,"deletions":0,"changes":2009,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/SessionImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,2009 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms;\n+\n+import org.apache.hedwig.jms.message.BytesMessageImpl;\n+import org.apache.hedwig.jms.message.MapMessageImpl;\n+import org.apache.hedwig.jms.message.MessageImpl;\n+import org.apache.hedwig.jms.message.MessageUtil;\n+import org.apache.hedwig.jms.message.ObjectMessageImpl;\n+import org.apache.hedwig.jms.message.StreamMessageImpl;\n+import org.apache.hedwig.jms.message.TextMessageImpl;\n+import org.apache.hedwig.jms.selector.Node;\n+import org.apache.hedwig.jms.selector.SelectorParser;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.Destination;\n+import javax.jms.InvalidDestinationException;\n+import javax.jms.JMSException;\n+import javax.jms.MapMessage;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.ObjectMessage;\n+import javax.jms.Queue;\n+import javax.jms.QueueBrowser;\n+import javax.jms.QueueReceiver;\n+import javax.jms.QueueSender;\n+import javax.jms.Session;\n+import javax.jms.StreamMessage;\n+import javax.jms.TemporaryQueue;\n+import javax.jms.TemporaryTopic;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+import javax.jms.TopicPublisher;\n+import javax.jms.TopicSubscriber;\n+import javax.jms.TransactionRolledBackException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implementation of jms Session.\n+ * IS NOT MT-safe (2.8) - except for close()\n+ *\n+ * We are yet to support/implement this - must pass a flag through constructor on \"how\" this object\n+ * was created and use that to throw exception...\n+ *\n+ */\n+public class SessionImpl implements Session {\n+\n+\n+    private final static Logger logger = LoggerFactory.getLogger(SessionImpl.class);\n+\n+    // 8k, too high ?\n+    public static final int MAX_SESSION_BUFFERED_MESSAGES =\n+        Integer.getInteger(\"Session.MAX_BUFFERED_MESSAGES\", 1024 * 8);\n+    // 0.5k too low/high ?\n+    public static final int MAX_SUBSCRIBER_BUFFERED_MESSAGES =\n+        Integer.getInteger(\"Session.MAX_SUBSCRIBER_BUFFERED_MESSAGES\", 512);\n+\n+    // Number of attempts to retry and see if a transaction keeps getting rolled back as part\n+    // of async delivery of messages.\n+    public static final int RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS =\n+        Integer.getInteger(\"Session.RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS\", 9);\n+\n+    private final boolean transacted;\n+    private final int acknowledgeMode;\n+    private volatile MessageListener messageListener = null;\n+\n+    private final ConnectionImpl connection;\n+    private final MessagingSessionFacade sessionFacade;\n+\n+    private final Object lockObject = new Object();\n+    // Message processing locks on this object itself - everything else on lockObject. This is to\n+    // prevent interactions with hedwig threading idioms.\n+    // messageList is a leaf in call graph - so it must not cause MT interactions with other locks\n+    // acquired prior to it.\n+    private final List<ReceivedMessage> messageList = new LinkedList<ReceivedMessage>();\n+    private final List<TransactedReceiveOperation> rolledbackMessageList\n+        = new LinkedList<TransactedReceiveOperation>();\n+\n+    private StateManager sessionState = new StateManager(StateManager.State.STOPPED, lockObject);\n+\n+    // Simply encapsulating all state within a single class.\n+    private final Subscriptions subscriptions = new Subscriptions();\n+\n+    private boolean messageListenerThreadStarted = false;\n+    private final Thread messageListenerThread;\n+    private boolean messageListenerThreadFinished = false;\n+\n+    public SessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n+        if (Session.AUTO_ACKNOWLEDGE != acknowledgeMode &&\n+            Session.CLIENT_ACKNOWLEDGE != acknowledgeMode &&\n+            Session.DUPS_OK_ACKNOWLEDGE != acknowledgeMode){\n+            // On;y if not transacted !\n+            if (!transacted){\n+                throw new javax.jms.IllegalStateException(\"Unknown/unsupported acknowledgeMode specified : \" +\n+                    acknowledgeMode);\n+            }\n+        }\n+        this.transacted = transacted;\n+        this.acknowledgeMode = acknowledgeMode;\n+        this.connection = connection;\n+        this.sessionFacade = connection.createMessagingSessionFacade(this);\n+        this.messageListenerThread = new Thread(this, \"JMS message listener thread\");\n+        // not daemon, right ?\n+        this.messageListenerThread.setDaemon(false);\n+    }\n+\n+    @Override\n+    public BytesMessage createBytesMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new BytesMessageImpl(this);\n+    }\n+\n+    @Override\n+    public MapMessage createMapMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new MapMessageImpl(this);\n+    }\n+\n+    @Override\n+    public Message createMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new MessageImpl(this);\n+    }\n+\n+    @Override\n+    public ObjectMessage createObjectMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new ObjectMessageImpl(this, null);\n+    }\n+\n+    @Override\n+    public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new ObjectMessageImpl(this, serializable);\n+    }\n+\n+    @Override\n+    public StreamMessage createStreamMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new StreamMessageImpl(this);\n+    }\n+\n+    @Override\n+    public TextMessage createTextMessage() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new TextMessageImpl(this);\n+    }\n+\n+    @Override\n+    public TextMessage createTextMessage(String payload) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        return new TextMessageImpl(this, payload);\n+    }\n+\n+    @Override\n+    public boolean getTransacted() {\n+        return transacted;\n+    }\n+\n+    @Override\n+    public int getAcknowledgeMode() {\n+        return acknowledgeMode;\n+    }\n+\n+    @Override\n+    public void commit() throws JMSException {\n+        // Apparently, we can send even if connection is not open ?\n+        // if (!sessionState.isStarted()) throw new javax.jms.IllegalStateException(\"Session not open\");\n+        if (!getTransacted()) throw new javax.jms.IllegalStateException(\"Session not transacted\");\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        commitTransactionState();\n+    }\n+\n+    @Override\n+    public void rollback() throws JMSException {\n+        if (!sessionState.isStarted()) throw new javax.jms.IllegalStateException(\"Session not open\");\n+        if (!getTransacted()) throw new javax.jms.IllegalStateException(\"Session not transacted\");\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        rollbackTransactionState();\n+    }\n+\n+    void start() throws JMSException {\n+        final StateManager.State prevState;\n+        final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> subscriptionToSubscriberMapCopy;\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to start session\");\n+\n+        synchronized (lockObject){\n+            // Do not throw exception, it might be connection starting while another thread might\n+            // be doing a close() - there is a\n+            // potential race there !\n+            // if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+            if (isClosed()) return ;\n+            if (sessionState.isStarted()) return ;\n+\n+            if (sessionState.isTransitionState()){\n+                sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                // Not expected actually, present to guard against future changes ...\n+                if (sessionState.isTransitionState())\n+                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+                if (sessionState.isStarted()) return ;\n+\n+                assert sessionState.isStopped();\n+                // try again ...\n+            }\n+\n+            prevState = sessionState.getCurrentState();\n+            sessionState.setCurrentState(StateManager.State.STARTING);\n+\n+            // Copy to prevent concurrent mod exceptions - is it required here ? Not sure ...\n+            subscriptionToSubscriberMapCopy = subscriptions.createSubscriptionToSubscriberMapCopy();\n+        }\n+\n+        StateManager.State nextState = prevState;\n+\n+        try {\n+            rollbackTransactionState();\n+            // Note: this part of the code IS thread-safe for our private state.\n+\n+            // Validate state - in terms of listener's, etc : we are relying on the single thread semantics of JMS\n+            // to NOT do any complex locking, etc.\n+\n+            if (null != getMessageListener()){\n+                // There CANNOT be any subscriber with listeners registered.\n+                for (MessageConsumer consumer : subscriptions.getAllConsumersSet()){\n+                    if (null != consumer.getMessageListener()) {\n+                        throw new JMSException(\"Session's message listener is already set - \" +\n+                            \"cannot have a consumer with listener also set.\");\n+                    }\n+                }\n+            }\n+\n+\n+            sessionFacade.start();\n+\n+            if (logger.isTraceEnabled()) logger.trace(\"Starting \" + subscriptionToSubscriberMapCopy.size() +\n+                \" subscribers\");\n+\n+            // Subscribe to all the subscriberId's\n+            for (Map.Entry<Subscription, CopyOnWriteArrayList<MessageConsumer>> entry :\n+                    subscriptionToSubscriberMapCopy.entrySet()){\n+\n+                if (entry.getValue().isEmpty()) continue;\n+                if (entry.getKey().isTopic()){\n+                    TopicSubscription topicSubscription = (TopicSubscription) entry.getKey();\n+                    try {\n+                        sessionFacade.subscribeToTopic(topicSubscription.topicName, topicSubscription.subscriberId);\n+                    } catch (JMSException e) {\n+                        // Log and ignore\n+                        // This CAN fail, it is ok to fail !\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"(Potentially Benign error) Error subscribing from topic for entry : \" +\n+                                topicSubscription);\n+                            DebugUtil.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                    try {\n+                        sessionFacade.startTopicDelivery(topicSubscription.topicName,\n+                            topicSubscription.subscriberId);\n+                    } catch (JMSException e) {\n+                        // Log and ignore\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Error starting topic delivery for entry : \" + entry.getKey());\n+                            DebugUtil.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                }\n+                else {\n+                    assert entry.getKey().isQueue();\n+\n+                    QueueSubscription queueSubscription = (QueueSubscription) entry.getKey();\n+\n+                    // There is no notion like subscription to queue, right ?\n+                    /*\n+                    try {\n+                        sessionFacade.subscribeToQueue(queueSubscription.queueName,\n+                          queueSubscription.subscriberId);\n+                    } catch (JMSException e) {\n+                        // Log and ignore\n+                        // This CAN fail, it is ok to fail !\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"(Potentially Benign error) Error subscribing from queue for entry : \" +\n+                              queueSubscription);\n+                            Util.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                    */\n+                    try {\n+                        sessionFacade.startQueueDelivery(queueSubscription.queueName, queueSubscription.subscriberId);\n+                    } catch (JMSException e) {\n+                        // Log and ignore\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Error starting queue delivery for entry : \" + entry.getKey());\n+                            DebugUtil.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                }\n+            }\n+            nextState = StateManager.State.STARTED;\n+        } finally {\n+            // set status and notify.\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+                sessionState.setCurrentState(nextState);\n+            }\n+        }\n+    }\n+\n+    void stop() throws JMSException {\n+        final StateManager.State prevState;\n+        final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> subscriptionToSubscriberMapCopy;\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to stop connection\");\n+\n+        synchronized (lockObject){\n+            if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+            if (sessionState.isStopped()) return ;\n+\n+            if (sessionState.isTransitionState()){\n+                sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                // Not expected actually, present to guard against future changes ...\n+                if (sessionState.isTransitionState())\n+                  throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                if (isClosed()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+                if (sessionState.isStopped()) return ;\n+\n+                assert sessionState.isStarted();\n+\n+                // try again ...\n+            }\n+\n+            prevState = sessionState.getCurrentState();\n+            sessionState.setCurrentState(StateManager.State.STOPPING);\n+\n+            // Copy to prevent concurrent mod exceptions.\n+            subscriptionToSubscriberMapCopy = subscriptions.createSubscriptionToSubscriberMapCopy();\n+        }\n+\n+        StateManager.State nextState = prevState;\n+        try {\n+            rollbackTransactionState();\n+            // In case there are other things to be done ...\n+\n+            // Unsubscribe to all the subscriberId's\n+            if (logger.isTraceEnabled()) logger.trace(\"Stopping \" +\n+                subscriptionToSubscriberMapCopy.size() + \" subscribers\");\n+            for (Map.Entry<Subscription, CopyOnWriteArrayList<MessageConsumer>> entry :\n+                    subscriptionToSubscriberMapCopy.entrySet()){\n+\n+                if (entry.getValue().isEmpty()) continue;\n+                if (entry.getKey().isTopic()){\n+                    TopicSubscription topicSubscription = (TopicSubscription) entry.getKey();\n+                    try {\n+                        stopTopicDelivery(topicSubscription.topicName, topicSubscription.subscriberId);\n+                    } catch (JMSException e) {\n+                        // Log and ignore\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Error unsubscribing from topic for entry : \" + topicSubscription);\n+                            DebugUtil.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                }\n+                else {\n+                  assert entry.getKey().isQueue();\n+\n+                  QueueSubscription queueSubscription = (QueueSubscription) entry.getKey();\n+                  try {\n+                      stopQueueDelivery(queueSubscription.queueName, queueSubscription.subscriberId);\n+                  } catch (JMSException e) {\n+                      // Log and ignore\n+                      if (logger.isDebugEnabled()) {\n+                          logger.debug(\"Error unsubscribing from queue for entry : \" + queueSubscription);\n+                          DebugUtil.dumpJMSStacktrace(logger, e);\n+                      }\n+                  }\n+                }\n+            }\n+            // stop facade AFTER subscriber's are stopped.\n+            sessionFacade.stop();\n+            nextState = StateManager.State.STOPPED;\n+        } finally {\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+                sessionState.setCurrentState(nextState);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * Closes the session. <br/>\n+     * Since a provider may allocate some resources on behalf of a session outside the JVM, clients\n+     * should close the resources\n+     * when they are not needed. Relying on garbage collection to eventually reclaim these resources\n+     * may not be timely enough.<br/>\n+     * <p/>\n+     * There is no need to close the producers and consumers of a closed session.\n+     * <p/>\n+     *\n+     *\n+     * A blocked message consumer receive call returns null when this session is closed.\n+     * <p/>\n+     * Closing a transacted session must roll back the transaction in progress.<br/>\n+     * This method is the only Session method that can be called concurrently.<br/>\n+     * Invoking any other Session method on a closed session must throw a JMSException.IllegalStateException.<br/>\n+     * Closing a closed session must not throw an exception.<br/>\n+     *\n+     */\n+    private static final ThreadLocal<Boolean> closeFromWithinListener = new ThreadLocal<Boolean>(){\n+        @Override\n+        protected Boolean initialValue() {\n+            return false;\n+        }\n+    };\n+\n+    @Override\n+    public void close() throws JMSException {\n+        final StateManager.State prevState;\n+        final Set<MessageConsumer> subscriberSetCopy = Collections.newSetFromMap(\n+            new IdentityHashMap<MessageConsumer, Boolean>());\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Attempting to close session\");\n+\n+        synchronized (lockObject){\n+            if (isClosed()) return ;\n+            if (! sessionState.isStopped()) {\n+                if (sessionState.isTransitionState()){\n+                    sessionState.waitForTransientStateChange(StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE, logger);\n+                    // Not expected actually, present to guard against future changes ...\n+                    if (sessionState.isTransitionState())\n+                      throw new JMSException(\"Connection did not make state change to steady state ?\");\n+\n+                    if (isClosed()) return ;\n+\n+                    assert sessionState.isStarted() || sessionState.isStopped();\n+                }\n+            }\n+\n+            prevState = sessionState.getCurrentState();\n+            sessionState.setCurrentState(StateManager.State.CLOSING);\n+            // Copy to prevent concurrent mod exceptions.\n+            subscriberSetCopy.addAll(subscriptions.getAllConsumersSet());\n+        }\n+\n+        StateManager.State nextState = prevState;\n+\n+        try {\n+            rollbackTransactionState();\n+            connection.removeSession(this);\n+\n+            // Close all publishers - doing this within synchronized block to prevent any possibility\n+            // of race conditions.\n+            // Potentially expensive, but it is a tradeoff between correctness and performance :-(\n+            if (logger.isTraceEnabled()) logger.trace(\"Closing \" + subscriberSetCopy.size() + \" subscribers\");\n+            for (MessageConsumer subscriber : subscriberSetCopy){\n+                try {\n+                    subscriber.close();\n+                } catch (JMSException e) {\n+                    // Log and ignore\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Error unsubscribing from destination for entry : \" + subscriber);\n+                        DebugUtil.dumpJMSStacktrace(logger, e);\n+                    }\n+                }\n+            }\n+            sessionFacade.close();\n+            nextState = StateManager.State.CLOSED;\n+        } finally {\n+\n+            // set status and notify.\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+                sessionState.setCurrentState(nextState);\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(this + \"Waiting for messageListenerThreadStarted \" +\n+            messageListenerThreadStarted + \", messageListenerThreadFinished \" + messageListenerThreadFinished);\n+\n+        // spin on messageListenerThreadFinished\n+        // spin ONLY if we are NOT within the listener already !\n+        if (! closeFromWithinListener.get()){\n+            synchronized (lockObject){\n+                final long waitTime = 100;\n+                long retryCount = StateManager.WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE / waitTime;\n+                if (messageListenerThreadStarted) {\n+                    while (!messageListenerThreadFinished) {\n+                        try {\n+                            lockObject.wait(waitTime);\n+                        } catch (InterruptedException e) {\n+                            // ignore ...\n+                            if (logger.isDebugEnabled()) logger.debug(\"interrupted ?\", e);\n+                        }\n+                        retryCount --;\n+                        // Fail if we have waiting long enough ... hardcoded for now.\n+                        if (retryCount <= 0) break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Waiting for messageListenerThreadFinished \" +\n+            messageListenerThreadFinished + \" DONE\");\n+    }\n+\n+    @Override\n+    public void recover() throws JMSException {\n+        // Typically will be in stopped state.\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (getTransacted())\n+          throw new javax.jms.IllegalStateException(\"cannot invoke recover in transacted session.\");\n+        throw new JMSException(\"recovery : TODO\");\n+    }\n+\n+    @Override\n+    public MessageListener getMessageListener() {\n+        return messageListener;\n+    }\n+\n+    @Override\n+    public void setMessageListener(final MessageListener messageListener) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        // Explicitly forbidding it for now : leads to too many complexities otherwise.\n+        // start session ONLY AFTER you have set the listener.\n+        if (messageListener != this.messageListener && sessionState.isInStartMode()) {\n+            throw new JMSException(\"Set the message listener BEFORE starting session (and/or connection)\");\n+        }\n+\n+        this.messageListener = messageListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (logger.isTraceEnabled()) logger.trace(\"Session thread started\");\n+        try {\n+            while (!isClosed()){\n+                final List<ReceivedMessage> messageListCopy;\n+                final List<TransactedReceiveOperation> rolledbackMessageListCopy;\n+                final MessageListener msglistener;\n+                synchronized (lockObject){\n+                    while (!isClosed() &&\n+                            (!sessionState.isStarted() ||\n+                                (null == getMessageListener() && 0 == subscriptions.getNumSubscribers()) ||\n+                                (messageList.isEmpty() && rolledbackMessageList.isEmpty())\n+                            )\n+                        ) {\n+                        // Check for buffer over-run's due to no listener being available !\n+                        if (messageList.size() > MAX_SESSION_BUFFERED_MESSAGES){\n+                            // simply discard it with an error logged.\n+                            if (logger.isInfoEnabled()) logger.info(\"Discarding \" + messageList.size() +\n+                                \" messages since there are no consumers for them\");\n+                            messageList.clear();\n+                        }\n+                        // Check for buffer over-run's due to no listener being available !\n+                        if (rolledbackMessageList.size() > MAX_SESSION_BUFFERED_MESSAGES){\n+                            // simply discard it with an error logged.\n+                            if (logger.isInfoEnabled()) logger.info(\"Discarding \" + rolledbackMessageList.size() +\n+                                \" messages since there are no consumers for them from recovered list.\");\n+                            rolledbackMessageList.clear();\n+                        }\n+\n+                        if (logger.isTraceEnabled()) logger.trace(this + \"sessionState : \" + sessionState +\n+                            \", listener \" + getMessageListener() + \", numSubscribers : \" +\n+                            subscriptions.getNumSubscribers());\n+                        try {\n+                            lockObject.wait(500);\n+                        } catch (InterruptedException e) {\n+                            // Should we ignore this ? There is no way this thread can be interrupted currently -\n+                            // while closing it will cause issues !\n+                            // Log and forget\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Ignoring interrupted exception\", e);\n+                            }\n+                        }\n+                    }\n+\n+                    if (isClosed()) break;\n+                    msglistener = getMessageListener();\n+                    messageListCopy = new ArrayList<ReceivedMessage>(messageList);\n+                    rolledbackMessageListCopy = new ArrayList<TransactedReceiveOperation>(rolledbackMessageList);\n+                    messageList.clear();\n+                    rolledbackMessageList.clear();\n+                    assert subscriptions.getNumSubscribers() > 0 || null != msglistener;\n+                }\n+\n+                if (logger.isTraceEnabled()) logger.trace(\"Processing \" + messageListCopy.size() +\n+                    \" messages using listener ? \" + (null != msglistener));\n+\n+                dispatchReceivedMessagesToSubscribers(msglistener, messageListCopy, rolledbackMessageListCopy);\n+            }\n+        } finally {\n+            String msg = null;\n+            synchronized (lockObject){\n+                lockObject.notifyAll();\n+                messageListenerThreadFinished = true;\n+                if (logger.isTraceEnabled()) msg = \"Exiting thread and setting \" +\n+                    messageListenerThreadFinished;\n+            }\n+            if (logger.isTraceEnabled()) logger.trace(msg);\n+        }\n+    }\n+\n+    private void dispatchReceivedMessagesToSubscribers(MessageListener sessionMessageListener,\n+                                                       List<ReceivedMessage> messageListCopy,\n+                                                       List<TransactedReceiveOperation> rolledbackMessageListCopy) {\n+        assert null != messageListCopy;\n+\n+        // Doing it before processing messageList.\n+        handleRollbackInDispatch(rolledbackMessageListCopy);\n+\n+        for (final ReceivedMessage receivedMessage : messageListCopy){\n+\n+            if (isClosed()) break;\n+\n+            // It is possible that previous listener rolledback transaction ... check that before\n+            // delivering the other messages !\n+            // Else we will mess up the oder of message delivery.\n+            {\n+                int retryCount = 0;\n+                while (retryCount < RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS){\n+                    if (! handleRollbackInDispatch(null)) break;\n+                    retryCount ++;\n+                }\n+                if (RETRY_DISPATCH_TO_TRANSACTION_ATTEMPTS == retryCount){\n+                    // we cant do much - close session and abort.\n+                    try {\n+                        SessionImpl.this.close();\n+                    } catch (JMSException e) {\n+                        if (logger.isDebugEnabled()) logger.debug(\"Exception closing session\", e);\n+                    }\n+                    return ;\n+                }\n+            }\n+\n+            final Subscription subscription = createSubscription(receivedMessage.destinationType,\n+                receivedMessage.originalMessage.getSourceName(), receivedMessage.originalMessage.getSubscriberId());\n+\n+            // COW - so no need to worry about concurrent-mod's or inconsistent states - other than\n+            // potential stale state,\n+            // which is fine since MessageConsumer's are essentially immutable from basic state point\n+            // of view (subscriberId, destination).\n+            CopyOnWriteArrayList<? extends MessageConsumer> subscriberList =\n+                subscriptions.getSubscribers(subscription);\n+            if (null == subscriberList) continue;\n+\n+            if (! subscriberList.listIterator().hasNext()) continue;\n+\n+            // For selector support - pick up the last register\n+            Node ast = subscriptions.getSelectorExpression(subscription);\n+            if (logger.isTraceEnabled()) logger.trace(\"subscription : \" + subscription + \", selector : \" + ast);\n+            if (null != ast){\n+                // final Boolean value = SelectorParser.evaluateSelector(ast, receivedMessage.originalMessage);\n+                final Boolean value = SelectorParser.evaluateSelector(ast, receivedMessage.msg);\n+\n+                if (null == value){\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Unable to evaluate selector ? ... ignoring message\");\n+                        logger.debug(\"Message : \" + receivedMessage.msg);\n+                    }\n+                    receivedMessage.originalMessage.getAckRunnable().run();\n+                    continue;\n+                }\n+                if (! Boolean.TRUE.equals(value)){\n+                    if (logger.isTraceEnabled()) logger.trace(\"Selector DID NOT evaluate to true (\" +\n+                        value + \"), ignore message ignoring message\");\n+                    receivedMessage.originalMessage.getAckRunnable().run();\n+                    continue;\n+                }\n+            }\n+\n+\n+            if (null != sessionMessageListener){\n+                // Since there was atleast one subscriber when we started this loop (which might\n+                // not be case anymore, but that is just an uncontrollable harmless race)\n+                // we can send it to messageListener for the session.\n+                if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + receivedMessage.originalMessage +\n+                    \" to session listener\");\n+\n+                if (isMessageExpired(receivedMessage.originalMessage)){\n+                    // message already expired.\n+                    // This means we acknowledge for all subscribers with this subscription id ...\n+                    receivedMessage.originalMessage.getAckRunnable().run();\n+                    continue;\n+                }\n+\n+                try {\n+                    final MessageImpl message = MessageUtil.createCloneForDispatch(this,\n+                        receivedMessage.originalMessage, receivedMessage.originalMessage.getSourceName(),\n+                        receivedMessage.originalMessage.getSubscriberId());\n+                    deliverToListener(sessionMessageListener, receivedMessage, message, false);\n+                } catch (JMSException e) {\n+                    // Unexpected not to be able to clone ...\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Unexpected exception trying to process message\");\n+                        DebugUtil.dumpJMSStacktrace(logger, e);\n+                    }\n+                }\n+                continue;\n+            }\n+\n+            for (final MessageConsumer subscriber : subscriberList){\n+                if (isClosed()) break;\n+                try {\n+                    final MessageListener subscriberListener = subscriber.getMessageListener();\n+                    // Clone - since each subscrber can modify the message.  We are optimizing this\n+                    // to clone only if subscriberList\n+                    // has more than one subscriber to avoid the (potentially) expensive creation.\n+                    if (getNoLocal(subscription, subscriber)){\n+                        if (isLocallyPublished(receivedMessage.originalMessage.getJMSMessageID())){\n+                            // This means we acknowledge for all subscribers with this subscription id ...\n+                            receivedMessage.originalMessage.getAckRunnable().run();\n+                            continue;\n+                        }\n+                    }\n+                    if (isMessageExpired(receivedMessage.originalMessage)){\n+                        receivedMessage.originalMessage.getAckRunnable().run();\n+                        continue;\n+                    }\n+\n+                    final MessageImpl message = MessageUtil.createCloneForDispatch(this,\n+                        receivedMessage.originalMessage, receivedMessage.originalMessage.getSourceName(),\n+                        receivedMessage.originalMessage.getSubscriberId());\n+\n+                    if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + message +\n+                        \" to subscriber subscriberListener ? \" + (subscriberListener != null));\n+\n+                    if (null != subscriberListener) {\n+                        deliverToListener(subscriberListener, receivedMessage, message, false);\n+                    }\n+                    else {\n+                        sessionFacade.enqueueReceivedMessage(subscriber,\n+                            new ReceivedMessage(receivedMessage.originalMessage, message,\n+                                receivedMessage.destinationType), false);\n+                    }\n+\n+                    if (logger.isTraceEnabled()) logger.trace(\"Dispatching \" + message +\n+                        \" to subscriberListener ? \" + (subscriberListener != null) + \", DONE\");\n+                } catch (JMSException e) {\n+                    // Unexpected not to be able to clone ...\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Unexpected exception trying to process message\", e);\n+                    }\n+                    continue ;\n+                }\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"dispatchReceivedMessagesToSubscribers() DONE\");\n+    }\n+\n+    private boolean getNoLocal(Subscription subscription, MessageConsumer subscriber) throws JMSException {\n+        if (subscription.isTopic()) return ((TopicSubscriber) subscriber).getNoLocal();\n+        // nothing equivalent for queue.\n+        // if (subscription.isQueue()) return ((QueueReceiver) subscriber).getNoLocal();\n+        return false;\n+    }\n+\n+    // Note that rollback can happen WHILE a listener is being run - so we need to check this\n+    // between EACH message delivery :-(\n+    // Not just as part of block draining of the queue.\n+    // returns true if there was any async operation to rollback (specifically async !).\n+    private boolean handleRollbackInDispatch(List<TransactedReceiveOperation> rolledbackMessageListCopy) {\n+        if (null == rolledbackMessageListCopy) {\n+            // Attempt to drain the queue.\n+            synchronized (lockObject){\n+                if (rolledbackMessageList.isEmpty()) return false;\n+                rolledbackMessageListCopy = new ArrayList<TransactedReceiveOperation>(rolledbackMessageList);\n+                rolledbackMessageList.clear();\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"rolledbackMessageList (\" +\n+            rolledbackMessageListCopy.size() + \") ... \" + rolledbackMessageListCopy);\n+\n+        LinkedList<TransactedReceiveOperation> listenerDeliveryList = new LinkedList<TransactedReceiveOperation>();\n+        for (TransactedReceiveOperation receiveOp : rolledbackMessageListCopy){\n+            if (isClosed()) break;\n+            receiveOp.recover(listenerDeliveryList);\n+        }\n+        for (TransactedReceiveOperation receiveOp : listenerDeliveryList){\n+            if (isClosed()) break;\n+            receiveOp.recoverForListener();\n+        }\n+\n+        return listenerDeliveryList.size() > 0;\n+    }\n+\n+    private void deliverToListener(MessageListener sessionMessageListener, ReceivedMessage receivedMessage,\n+                                   MessageImpl theMessage, boolean redelivery) {\n+\n+      // NOT re-enterent method ...\n+        closeFromWithinListener.set(true);\n+        try {\n+            int errorRetry = 0;\n+            boolean success = false;\n+            final int retryFor =\n+                    (!getTransacted() &&\n+                            (Session.AUTO_ACKNOWLEDGE == getAcknowledgeMode() ||\n+                                    Session.CLIENT_ACKNOWLEDGE == getAcknowledgeMode()))\n+                    ? 3 : 1;\n+\n+            while (errorRetry < retryFor && !isClosed()){\n+                try {\n+                    if (redelivery || errorRetry > 0) theMessage.setJMSRedelivered(true);\n+\n+                    // Changed my mind, always ack the message before processing it. This seems to\n+                    // be consistent with activemq testcases too ...\n+                    handleAutomaticMessageAcknowledgement(receivedMessage, sessionMessageListener);\n+                    sessionMessageListener.onMessage(theMessage);\n+                    success = true;\n+                    break ;\n+                } catch (RuntimeException rEx){\n+                    // Badly behaved client, retry ...\n+                    if (logger.isInfoEnabled())\n+                      logger.info(\"Unexpected runtime exception from client message listener.\", rEx);\n+                }\n+                errorRetry ++;\n+            }\n+\n+            if (isClosed()) return ;\n+\n+            if (!success){\n+                // If failed, then reset transaction state - so that next txn will not get affected by this.\n+                rollbackTransactionState();\n+                // We gave up deliverying message ...\n+                if (retryFor > 1) {\n+                    if (logger.isInfoEnabled())\n+                      logger.info(\"Delivery of message to listener resulted in repeated failures, \" +\n+                          \" dropping message -  session recovery should be used to handle it.\");\n+                }\n+                else {\n+                    if (logger.isInfoEnabled()) logger.info(\"Use session recovery to handle message\");\n+                }\n+            }\n+        } finally {\n+            closeFromWithinListener.remove();\n+        }\n+    }\n+\n+    public MessagingSessionFacade.DestinationType findDestinationType(String destination) throws JMSException {\n+        return sessionFacade.findDestinationType(destination);\n+    }\n+\n+    public MessagingSessionFacade.DestinationType findDestinationType(Destination destination) throws JMSException {\n+        return sessionFacade.findDestinationType(destination);\n+    }\n+\n+    @Override\n+    public MessageProducer createProducer(Destination destination) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        connection.initConnectionClientID();\n+\n+        return createProducerImpl(findDestinationType(destination), destination);\n+    }\n+\n+    private MessageProducer createProducerImpl(MessagingSessionFacade.DestinationType type,\n+                                               Destination destination) throws JMSException {\n+        switch (type){\n+            case QUEUE:\n+                return sessionFacade.createQueueSender(destination);\n+            case TOPIC:\n+                return sessionFacade.createTopicPublisher(destination);\n+            default:\n+                throw new JMSException(\"Unable to find destination type \" + destination +\n+                    \", please use explicit queue/topic methods to create producer\");\n+        }\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n+    protected TopicPublisher createPublisherImpl(Topic topic) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == topic) throw new InvalidDestinationException(\"Illegal destination \" + topic);\n+        connection.initConnectionClientID();\n+\n+        return (TopicPublisher) createProducerImpl(MessagingSessionFacade.DestinationType.TOPIC, topic);\n+    }\n+\n+\n+    @Override\n+    public MessageConsumer createConsumer(Destination destination) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == destination) throw new InvalidDestinationException(\"Illegal destination \" + destination);\n+        connection.initConnectionClientID();\n+\n+        return createConsumerImpl(findDestinationType(destination), destination);\n+    }\n+\n+    private MessageConsumer createConsumerImpl(MessagingSessionFacade.DestinationType type,\n+                                               Destination destination) throws JMSException {\n+        switch (type){\n+            case QUEUE:\n+                return sessionFacade.createQueueReceiver(destination);\n+            case TOPIC:\n+                return sessionFacade.createTopicSubscriber(destination);\n+            default:\n+                throw new JMSException(\"Unable to find destination type \" + destination +\n+                    \", please use explicit queue/topic methods to create consumer\");\n+        }\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n+    protected TopicSubscriber createSubscriberImpl(Topic topic) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == topic) throw new InvalidDestinationException(\"Illegal destination \" + topic);\n+        connection.initConnectionClientID();\n+\n+        return (TopicSubscriber) createConsumerImpl(MessagingSessionFacade.DestinationType.TOPIC, topic);\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n+    protected TopicSubscriber createSubscriberImpl(Topic topic, String messageSelector, boolean noLocal)\n+        throws JMSException {\n+\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == topic) throw new InvalidDestinationException(\"Illegal destination \" + topic);\n+        connection.initConnectionClientID();\n+\n+        return (TopicSubscriber) createConsumerImpl(MessagingSessionFacade.DestinationType.TOPIC,\n+            topic, messageSelector, noLocal);\n+    }\n+\n+\n+    @Override\n+    public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == destination) throw new InvalidDestinationException(\"Illegal destination \" + destination);\n+        connection.initConnectionClientID();\n+\n+        return createConsumer(destination, messageSelector, false);\n+    }\n+\n+    @Override\n+    public MessageConsumer createConsumer(Destination destination, String messageSelector,\n+                                          boolean noLocal) throws JMSException {\n+\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == destination) throw new InvalidDestinationException(\"Illegal destination \" + destination);\n+        connection.initConnectionClientID();\n+\n+        return createConsumerImpl(findDestinationType(destination), destination, messageSelector, noLocal);\n+    }\n+\n+    private MessageConsumer createConsumerImpl(MessagingSessionFacade.DestinationType type, Destination destination,\n+                                               String messageSelector, boolean noLocal) throws JMSException {\n+        switch (type){\n+            case QUEUE:\n+                return sessionFacade.createQueueReceiver(destination, messageSelector, noLocal);\n+            case TOPIC:\n+                return sessionFacade.createTopicSubscriber(destination, messageSelector, noLocal);\n+            default:\n+                throw new JMSException(\"Unable to find destination type \" + destination +\n+                    \", please use explicit queue/topic methods to create consumer\");\n+        }\n+    }\n+\n+    // TODO: Check if it is actually a Queue !\n+    @Override\n+    public Queue createQueue(String queueName) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        return (Queue) getDestination(MessagingSessionFacade.DestinationType.QUEUE, queueName);\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not TopicSession)\n+    protected QueueReceiver createReceiverImpl(Queue queue) throws JMSException {\n+        return sessionFacade.createQueueReceiver(queue);\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n+    protected QueueReceiver createReceiverImpl(Queue queue, String messageSelector) throws JMSException {\n+        return sessionFacade.createQueueReceiver(queue, messageSelector);\n+    }\n+\n+    // delegate to this IF this method can be invoked (specifically, if not QueueSession)\n+    protected QueueSender createSenderImpl(Queue queue) throws JMSException {\n+        return sessionFacade.createQueueSender(queue);\n+    }\n+\n+    // TODO: Check if it is actually a Topic !\n+    @Override\n+    public Topic createTopic(String topicName) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        if (null == topicName) throw new InvalidDestinationException(\"Illegal destination \" + topicName);\n+        connection.initConnectionClientID();\n+\n+        return (Topic) getDestination(MessagingSessionFacade.DestinationType.TOPIC, topicName);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        if (null == topic) throw new InvalidDestinationException(\"Illegal destination \" + topic);\n+        if (null == subscribedId) throw new JMSException(\"Illegal subscribedId \" + subscribedId);\n+        connection.initConnectionClientID();\n+\n+        subscriptions.registerSubscriberIdToTopic(subscribedId, topic.getTopicName());\n+        return sessionFacade.createDurableSubscriber(topic, createSubscriberId(subscribedId));\n+    }\n+\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId, String messageSelector,\n+                                                   boolean noLocal) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        if (null == topic) throw new InvalidDestinationException(\"Illegal destination \" + topic);\n+        if (null == subscribedId) throw new JMSException(\"Illegal subscribedId \" + subscribedId);\n+        connection.initConnectionClientID();\n+\n+        subscriptions.registerSubscriberIdToTopic(subscribedId, topic.getTopicName());\n+        return sessionFacade.createDurableSubscriber(topic, createSubscriberId(subscribedId),\n+            messageSelector, noLocal);\n+    }\n+\n+    @Override\n+    public void unsubscribe(String subscribedId) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        final String topicName = subscriptions.findTopicNameForSubscriberId(subscribedId);\n+        sessionFacade.unsubscribeFromTopic(topicName, createSubscriberId(subscribedId));\n+    }\n+\n+    public String createSubscriberId(final String subscribedId) throws JMSException {\n+        final String clientId = connection.getClientID();\n+        StringBuilder sb = new StringBuilder();\n+\n+        // Some arbitrary combination of client id and subscriber id.\n+        sb.append(\"CLIENT_ID:\");\n+        sb.append(clientId);\n+        sb.append('|');\n+        sb.append(\"SUBSCRIBER_ID:\");\n+        sb.append(subscribedId);\n+\n+        return sb.toString();\n+    }\n+\n+    /*\n+    public String createTemporaryTopicId() throws JMSException {\n+        final String clientId = connection.getClientID();\n+        StringBuilder sb = new StringBuilder();\n+\n+        // Some arbitrary combination of client id and subscriber id.\n+        sb.append(\"CLIENT_ID:\");\n+        sb.append(clientId);\n+        sb.append('|');\n+        sb.append(\"TOPIC_ID:\");\n+        sb.append(generateRandomString());\n+\n+        return sb.toString();\n+    }\n+    */\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        return sessionFacade.createBrowser(queue);\n+    }\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        return sessionFacade.createBrowser(queue, messageSelector);\n+    }\n+\n+    @Override\n+    public TemporaryQueue createTemporaryQueue() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        return sessionFacade.createTemporaryQueue();\n+    }\n+\n+    @Override\n+    public TemporaryTopic createTemporaryTopic() throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+\n+        return sessionFacade.createTemporaryTopic();\n+    }\n+\n+    public void subscriberCreated() {\n+        // subscriberCreatedCount ++;\n+    }\n+\n+    public void acknowledge(MessageImpl message) throws JMSException {\n+        if (sessionState.isInCloseMode()) throw new javax.jms.IllegalStateException(\"Already closed\");\n+        // If NOT in explicit acknowledge mode, ignore request.\n+        if (Session.CLIENT_ACKNOWLEDGE != getAcknowledgeMode()) return;\n+        // If in transaction, ignore request.\n+        if (getTransacted()) return ;\n+\n+        sessionFacade.acknowledge(message);\n+    }\n+\n+    public String toName(Destination destination) throws JMSException {\n+        if (destination instanceof Topic) return ((Topic)destination).getTopicName();\n+        if (destination instanceof Queue) return ((Queue)destination).getQueueName();\n+\n+        throw new javax.jms.IllegalStateException(\"Unknown/unsupported destination \" + destination);\n+    }\n+\n+    public static Topic asTopic(final String topicName){\n+        return new Topic() {\n+            @Override\n+            public String getTopicName() throws JMSException {\n+                return topicName;\n+            }\n+\n+            @Override\n+            public String toString(){\n+                return topicName;\n+            }\n+        };\n+    }\n+\n+\n+    public static Queue asQueue(final String queueName){\n+        return new Queue() {\n+            @Override\n+            public String getQueueName() throws JMSException {\n+                return queueName;\n+            }\n+\n+            @Override\n+            public String toString(){\n+                return queueName;\n+            }\n+        };\n+    }\n+    // TODO: Convert to JNDI lookup.\n+    public Destination getDestination(final MessagingSessionFacade.DestinationType type,\n+                                      final String destination) throws JMSException {\n+        switch (type){\n+            case TOPIC:\n+                return asTopic(destination);\n+            case QUEUE:\n+                return asQueue(destination);\n+            default:\n+                throw new JMSException(\"Unknown destination type \" + type +\n+                    \" for destination \" + destination);\n+        }\n+    }\n+\n+    public static String generateRandomString() {\n+        // UUID is expensive, but using it for now ...\n+        return UUID.randomUUID().toString();\n+    }\n+\n+    public void registerTopicSubscriptionInfo(TopicSubscription topicSubscription, Node selectorAst) {\n+        subscriptions.registerTopicSubscriptionSelector(topicSubscription, selectorAst);\n+    }\n+\n+    public void registerQueueSubscriptionInfo(QueueSubscription queueSubscription, Node selectorAst) {\n+        subscriptions.registerQueueSubscriptionSelector(queueSubscription, selectorAst);\n+    }\n+\n+    // returns true IF we need to do an explicit subscribe to the topic (there was NO subscription to it earlier).\n+    public void registerTopicSubscriber(TopicSubscriber topicSubscriber) throws JMSException {\n+        registerSubscriber(topicSubscriber, MessagingSessionFacade.DestinationType.TOPIC,\n+            topicSubscriber.getTopic().getTopicName(), sessionFacade.getSubscriberId(topicSubscriber));\n+    }\n+\n+    public void registerQueueSubscriber(QueueReceiver queueReceiver) throws JMSException {\n+        registerSubscriber(queueReceiver, MessagingSessionFacade.DestinationType.QUEUE,\n+            queueReceiver.getQueue().getQueueName(), sessionFacade.getSubscriberId(queueReceiver));\n+    }\n+\n+    private void registerSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n+                                   final String destination, final String subscriberId) throws JMSException {\n+\n+        assert MessagingSessionFacade.DestinationType.QUEUE == type ||\n+            MessagingSessionFacade.DestinationType.TOPIC == type;\n+\n+        boolean needSubscription = false;\n+        boolean needDelivery = false;\n+        if (logger.isTraceEnabled()) logger.trace(\"Registering ... \" + subscriber + \" for \" + destination +\n+            \", sid \" + subscriberId);\n+\n+        synchronized (lockObject){\n+            if (sessionState.isInCloseMode()) throw new JMSException(\"Already closed\");\n+\n+            // already subscribed.\n+            if (! subscriptions.addToSubscriberSet(subscriber)) return ;\n+\n+            if (subscriptions.addToSubscribers(subscriber, type, destination, subscriberId)) {\n+                // needSubscription = sessionState.isStarted();\n+                needSubscription = ! sessionState.isInCloseMode();\n+                needDelivery = sessionState.isStarted();\n+            }\n+        }\n+\n+        // TODO: There is a potential race here between registering/starting subscription and\n+        // stopping/closing subscription(s) elsewhere.\n+        // We should resolve it by taking a per List lock (which is gauranteed to be non-null here)\n+        // and a per List subscription status.\n+        // For now, NOT handling crazy edge-cases like this - under most circumsances, this will\n+        // fail for other reasons anyway !\n+\n+        // Session must be used by clients only in a thread safe manner, since it is ok to do this\n+        // outside the lock.\n+        if (needSubscription){\n+            if (logger.isTraceEnabled()) logger.trace(\"Subscribing ... \" + subscriber + \" for \" +\n+                destination + \", sid \" + subscriberId);\n+\n+            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n+                // Only for topic's, right ?\n+                try {\n+                    sessionFacade.subscribeToTopic(destination, subscriberId);\n+                } catch (JMSException e){\n+                    // It might be possible for this to fail ...\n+                    // Log and ignore\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Error subscribing from topic for entry : \" + subscriberId);\n+                        DebugUtil.dumpJMSStacktrace(logger, e);\n+                    }\n+                }\n+            }\n+            if (logger.isTraceEnabled()) logger.trace(\"Subscribing ... \" + subscriber + \" for \" +\n+                destination + \", sid \" + subscriberId + \" DONE\");\n+        }\n+\n+        if (needDelivery) {\n+            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n+                if (logger.isTraceEnabled()) logger.trace(\"Topic delivery ... \" + subscriber + \" for \" +\n+                    destination + \", sid \" + subscriberId);\n+                sessionFacade.startTopicDelivery(destination, subscriberId);\n+                if (logger.isTraceEnabled()) logger.trace(\"Topic delivery ... \" + subscriber + \" for \" +\n+                    destination + \", sid \" + subscriberId + \" DONE\");\n+            }\n+            else {\n+                if (logger.isTraceEnabled()) logger.trace(\"Queue delivery ... \" + subscriber + \" for \" +\n+                    destination + \", sid \" + subscriberId);\n+                sessionFacade.startQueueDelivery(destination, subscriberId);\n+                if (logger.isTraceEnabled()) logger.trace(\"Queue delivery ... \" + subscriber + \" for \" +\n+                    destination + \", sid \" + subscriberId + \" DONE\");\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"registerSubscriber ... \" + messageListenerThreadStarted);\n+        if (! messageListenerThreadStarted){\n+            try {\n+                this.messageListenerThread.start();\n+            } catch (IllegalThreadStateException  itse){\n+                // ignore\n+                // This should not happen, it will happen when Session is used in an MT-unsafe manner,\n+                // contrary to what is expected from JMS.\n+                if (logger.isDebugEnabled()) logger.debug(\"Unexpected\", itse);\n+            }\n+            messageListenerThreadStarted = true;\n+        }\n+        if (logger.isTraceEnabled()) logger.trace(\"registerSubscriber ... DONE\");\n+    }\n+\n+    public void unregisterTopicSubscriber(TopicSubscriber topicSubscriber) throws JMSException {\n+        unregisterSubscriber(topicSubscriber, MessagingSessionFacade.DestinationType.TOPIC,\n+            topicSubscriber.getTopic().getTopicName(), sessionFacade.getSubscriberId(topicSubscriber));\n+    }\n+\n+    public void unregisterQueueReceiver(QueueReceiver queueReceiver) throws JMSException {\n+        unregisterSubscriber(queueReceiver, MessagingSessionFacade.DestinationType.QUEUE,\n+            queueReceiver.getQueue().getQueueName(), sessionFacade.getSubscriberId(queueReceiver));\n+    }\n+\n+    private void unregisterSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n+                                      final String destination, final String subscriberId) throws JMSException {\n+\n+        assert MessagingSessionFacade.DestinationType.QUEUE == type ||\n+            MessagingSessionFacade.DestinationType.TOPIC == type;\n+        final boolean stopDelivery;\n+\n+        synchronized (lockObject){\n+            // if in closing, continue on anyway ...\n+            if (isClosed()) return ;\n+\n+            stopDelivery = subscriptions.removeSubscriber(subscriber, type, destination, subscriberId);\n+            if (stopDelivery) {\n+                if (! subscriptions.getAllConsumersSet().remove(subscriber)) return ;\n+            }\n+        }\n+\n+        // Session is expected to be used in a MT safe manner, since it is MT-unsafe.\n+        if (stopDelivery){\n+            if (MessagingSessionFacade.DestinationType.TOPIC == type){\n+                stopTopicDelivery(destination, subscriberId);\n+            }\n+            else {\n+                stopQueueDelivery(destination, subscriberId);\n+            }\n+        }\n+    }\n+\n+    public void handleAutomaticMessageAcknowledgement(ReceivedMessage receivedMessage,\n+                                                      MessageListener sessionMessageListener) {\n+        doHandleAutomaticMessageAcknowledgement(new TransactedReceiveOperation(receivedMessage,\n+            sessionMessageListener));\n+    }\n+\n+    public void handleAutomaticMessageAcknowledgement(ReceivedMessage receivedMessage, MessageConsumer subscriber) {\n+        doHandleAutomaticMessageAcknowledgement(new TransactedReceiveOperation(receivedMessage, subscriber));\n+    }\n+\n+    // This is a provider internal method.\n+    private void doHandleAutomaticMessageAcknowledgement(TransactedReceiveOperation receiveOperation) {\n+        if (isClosed()) return ;\n+        // If in transaction, ignore.\n+        if (transacted) {\n+            enqueueReceiveWithinTransaction(receiveOperation);\n+            return ;\n+        }\n+\n+        if (Session.AUTO_ACKNOWLEDGE == getAcknowledgeMode() ||\n+            Session.DUPS_OK_ACKNOWLEDGE == getAcknowledgeMode()){\n+            // Ignore (any) exceptions which might be thrown ...\n+            try {\n+                if (logger.isTraceEnabled()) logger.trace(\"acknowledging ... \" + receiveOperation);\n+                receiveOperation.receivedMessage.originalMessage.getAckRunnable().run();\n+            } catch (Exception ex){\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Ignoring exception while sending ack ... \", ex);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException {\n+        sessionFacade.unsubscribeFromTopic(topicName, subscribedId);\n+    }\n+\n+    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException {\n+        sessionFacade.stopTopicDelivery(topicName, subscribedId);\n+    }\n+\n+    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException {\n+        sessionFacade.stopQueueDelivery(queueName, subscribedId);\n+    }\n+\n+    public void messageReceived(final MessageImpl msg, MessagingSessionFacade.DestinationType type)\n+        throws JMSException {\n+\n+        String traceMsg = null;\n+        ReceivedMessage receivedMessage = new ReceivedMessage(msg, msg, type);\n+        synchronized (lockObject){\n+            // ignore if closed ... continue on if in closing state.\n+            if (isClosed()) return ;\n+            messageList.add(receivedMessage);\n+\n+            if (!getTransacted() && CLIENT_ACKNOWLEDGE == getAcknowledgeMode()) {\n+                sessionFacade.registerUnAcknowledgedMessage(receivedMessage);\n+            }\n+\n+            lockObject.notifyAll();\n+            if (logger.isTraceEnabled()) traceMsg = \"messageReceived from \" + msg.getSourceName() +\n+                \", for \" + msg.getSubscriberId() + \" = \" + msg;\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(traceMsg);\n+    }\n+\n+    // A simple immutable datastructure to hold details about a message which has been recieved.\n+    public static class ReceivedMessage {\n+        // Ensure that the original message is NOT modified in any way !\n+        public final MessageImpl originalMessage;\n+        // This is the message returned to the client : to the listener and/or in the TopicSubscriberImpl -\n+        // created as a\n+        // clone of the originalMessage.\n+        public final MessageImpl msg;\n+\n+        public final MessagingSessionFacade.DestinationType destinationType;\n+\n+        private ReceivedMessage(MessageImpl originalMessage, MessageImpl msg,\n+                                MessagingSessionFacade.DestinationType destinationType) {\n+            this.originalMessage = originalMessage;\n+            this.msg = msg;\n+            this.destinationType = destinationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"ReceivedMessage\");\n+            sb.append(\"{originalMessage=\").append(originalMessage);\n+            sb.append(\", msg=\").append(msg);\n+            sb.append(\", destinationType=\").append(destinationType);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    // required to catch resource leaks ...\n+    @Override\n+    protected void finalize() throws Throwable {\n+        super.finalize();\n+        if (!sessionState.isInCloseMode()) {\n+            if (logger.isErrorEnabled()) logger.error(\"Session was NOT closed before it went out of scope\");\n+            close();\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return sessionState.isClosed();\n+    }\n+\n+\n+    // TODO: Introduce a daemon thread which periodically updates this - each call to\n+    // System.currentTimeMillis is a native call\n+    // And can be very expensive if there are a lot of concurrent invocations to it : learnings\n+    // from XMPP server circa 2006 !\n+    public static long currentTimeMillis() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    public Subscription createSubscription(MessagingSessionFacade.DestinationType type, String name,\n+                                           String subscriberId){\n+        switch(type){\n+          case QUEUE:\n+              return new QueueSubscription(name, subscriberId);\n+          case TOPIC:\n+              return new TopicSubscription(name, subscriberId);\n+          default:\n+              throw new IllegalArgumentException(\"Unknown destination type \" + type +\n+                  \" for destination \" + name + \", subscriberId \" + subscriberId);\n+        }\n+    }\n+    public interface Subscription {\n+        public boolean isTopic();\n+        public boolean isQueue();\n+    }\n+\n+    public static final class TopicSubscription implements Subscription {\n+        public final String topicName;\n+        public final String subscriberId;\n+\n+        public TopicSubscription(String topicName, String subscriberId) {\n+            if (null == topicName || null == subscriberId) {\n+                throw new NullPointerException(\"Unexpected null as parameter topicName: \" +\n+                    topicName + \", subscriberId: \" + subscriberId);\n+            }\n+            this.topicName = topicName;\n+            this.subscriberId = subscriberId;\n+        }\n+\n+        public boolean isTopic() { return true; }\n+\n+        public boolean isQueue() { return false; }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            TopicSubscription that = (TopicSubscription) o;\n+\n+            if (!subscriberId.equals(that.subscriberId)) return false;\n+            if (!topicName.equals(that.topicName)) return false;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = topicName.hashCode();\n+            result = 31 * result + subscriberId.hashCode();\n+            return result;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"TopicSubscription\");\n+            sb.append(\"{topicName='\").append(topicName).append('\\'');\n+            sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static final class QueueSubscription implements Subscription {\n+        public final String queueName;\n+        public final String subscriberId;\n+\n+        public QueueSubscription(String queueName, String subscriberId) {\n+            if (null == queueName || null == subscriberId) {\n+                throw new NullPointerException(\"Unexpected null as parameter queueName: \" +\n+                    queueName + \", subscriberId: \" + subscriberId);\n+            }\n+            this.queueName = queueName;\n+            this.subscriberId = subscriberId;\n+        }\n+\n+        public boolean isTopic() { return false; }\n+\n+        public boolean isQueue() { return true; }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            QueueSubscription that = (QueueSubscription) o;\n+\n+            if (!subscriberId.equals(that.subscriberId)) return false;\n+            if (!queueName.equals(that.queueName)) return false;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = queueName.hashCode();\n+            result = 31 * result + subscriberId.hashCode();\n+            return result;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"QueueSubscription\");\n+            sb.append(\"{queueName='\").append(queueName).append('\\'');\n+            sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+\n+    private static interface TransactedOperation {\n+        public void rollback();\n+        public void commit() throws JMSException;\n+        public boolean requiresStartedSession();\n+    }\n+\n+    private class TransactedSendOperation implements TransactedOperation {\n+        private final String destination;\n+        private final MessageImpl messageImpl;\n+        private final Message userMessage;\n+\n+        private TransactedSendOperation(String destination, MessageImpl messageImpl, Message userMessage) {\n+            this.destination = destination;\n+            this.messageImpl = messageImpl;\n+            this.userMessage = userMessage;\n+        }\n+\n+\n+        @Override\n+        public void commit() throws JMSException {\n+            String msgId = SessionImpl.this.sessionFacade.publish(destination, messageImpl);\n+            if (userMessage instanceof MessageImpl) ((MessageImpl) userMessage).setJMSMessageIDInternal(msgId);\n+            else userMessage.setJMSMessageID(msgId);\n+        }\n+\n+        public void rollback() {\n+            // noop ...\n+        }\n+\n+        @Override\n+        public boolean requiresStartedSession() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"TransactedSendOperation\");\n+            sb.append(\"{destination='\").append(destination).append('\\'');\n+            sb.append(\", messageImpl=\").append(messageImpl);\n+            sb.append(\", userMessage=\").append(userMessage);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    private class TransactedReceiveOperation implements TransactedOperation {\n+        private final ReceivedMessage receivedMessage;\n+        private final MessageListener sessionMessageListener;\n+        private final MessageConsumer subscriber;\n+\n+        private TransactedReceiveOperation(ReceivedMessage receivedMessage, MessageListener sessionMessageListener) {\n+            this.receivedMessage = receivedMessage;\n+            this.sessionMessageListener = sessionMessageListener;\n+            this.subscriber = null;\n+        }\n+\n+        private TransactedReceiveOperation(ReceivedMessage receivedMessage, MessageConsumer subscriber) {\n+            this.receivedMessage = receivedMessage;\n+            this.subscriber = subscriber;\n+            this.sessionMessageListener = null;\n+        }\n+\n+        @Override\n+        public boolean requiresStartedSession() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void rollback() {\n+\n+            // async dispatch ...\n+            if (null != sessionMessageListener) {\n+                synchronized (SessionImpl.this.lockObject){\n+                    rolledbackMessageList.add(this);\n+                    SessionImpl.this.lockObject.notifyAll();\n+                }\n+            }\n+            // If rollback in sync mode, do in same thread - else a rollback, receive WILL see messages\n+            // in different order !\n+            // This is also required since in async mode, session IS NOT MT-safe - and so is\n+            // expecting this behavior.\n+            else if (null != subscriber){\n+                try {\n+                    MessageImpl theMessage = MessageUtil.createCloneForDispatch(SessionImpl.this,\n+                            receivedMessage.originalMessage,\n+                            receivedMessage.originalMessage.getSourceName(),\n+                            receivedMessage.originalMessage.getSubscriberId());\n+                    theMessage.setJMSRedelivered(true);\n+\n+                    sessionFacade.enqueueReceivedMessage(subscriber,\n+                            new ReceivedMessage(receivedMessage.originalMessage, theMessage,\n+                                receivedMessage.destinationType), true);\n+                } catch (JMSException e) {\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Unable to enqueue received message to\");\n+                        DebugUtil.dumpJMSStacktrace(logger, e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void commit() throws JMSException {\n+            try {\n+                receivedMessage.originalMessage.getAckRunnable().run();\n+            } catch (Exception ex){\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Ignoring exception while sending ack ... \", ex);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Recovery is slightly tricky - we have two cases here :\n+         * a) Messages which to be consumed via subscriber which support the sync mode - via receive(), variants.\n+         * b) Messages which are to be consumed via the subscriber or session's async mode - via listener.\n+         *\n+         *\n+         * We have to ensure that message recovery will result in the exact SAME order of message\n+         * delivery to client as it was done first time\n+         * (when rollback was triggered).\n+         * To ensure this, the recover method is called in REVERSE order in which operations were\n+         * enqueued in the txn (log) queue.\n+         *\n+         * To handle (a), sessionFacade.enqueueReceivedMessage pushes message to begining of pending\n+         * message queue in subscriber.\n+         * Taken along with reverse order of unwinding of txn log, this ensure the desired behavior for (a).\n+         *\n+         * To ensure desired behavior for (b), we pass a listenerDeliveryList as parameter - which is\n+         * used to maintain the\n+         * order of how to invoke onMessage to recover for async dispatch. Note: we keep adding to\n+         * begining of this list to ensure that\n+         * in the end, oldest message in txn log is the first message in listenerDeliveryList when\n+         * we attempt recovery.\n+         *\n+         */\n+        public void recover(LinkedList<TransactedReceiveOperation> listenerDeliveryList) {\n+            // Do the actual recovery ...\n+            if (null != subscriber){\n+                // already handled in rollback ...\n+                assert false : \"unexpected ...\";\n+            }\n+            else if (null != sessionMessageListener){\n+                listenerDeliveryList.addFirst(this);\n+            }\n+        }\n+\n+        public void recoverForListener(){\n+            assert null == subscriber;\n+            assert null != sessionMessageListener;\n+\n+            try {\n+                final MessageImpl message = MessageUtil.createCloneForDispatch(SessionImpl.this,\n+                        receivedMessage.originalMessage,\n+                        receivedMessage.originalMessage.getSourceName(),\n+                        receivedMessage.originalMessage.getSubscriberId());\n+                deliverToListener(sessionMessageListener, receivedMessage, message, true);\n+            } catch (JMSException e) {\n+                // Unexpected not to be able to clone ...\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Unexpected exception trying to process message\");\n+                    DebugUtil.dumpJMSStacktrace(logger, e);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"TransactedReceiveOperation\");\n+            sb.append(\"{receivedMessage=\").append(receivedMessage);\n+            sb.append(\", sessionMessageListener=\").append(sessionMessageListener);\n+            sb.append(\", subscriber=\").append(subscriber);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+\n+    // For txn support.\n+    private final Object transactionLock = new Object();\n+    private final List<TransactedOperation> transactedOperation = new LinkedList<TransactedOperation>();\n+\n+    private void rollbackTransactionState(){\n+        final ArrayList<TransactedOperation> transactedOperationCopy;\n+        synchronized (transactionLock){\n+            transactedOperationCopy = new ArrayList<TransactedOperation>(transactedOperation);\n+            transactedOperation.clear();\n+        }\n+        rollbackTransactionState(transactedOperationCopy);\n+    }\n+\n+    private void rollbackTransactionState(ArrayList<TransactedOperation> transactedOperationCopy){\n+\n+        if (logger.isDebugEnabled()) logger.debug(\"Attempting to rollback \" +\n+            transactedOperationCopy.size() + \" operations\");\n+        if (logger.isTraceEnabled()) logger.trace(\"Operations : \" + transactedOperationCopy);\n+\n+        // Rollback MUST be in reverse order !\n+        final int size = transactedOperationCopy.size();\n+        for (int i = size - 1;i >= 0; i --){\n+            TransactedOperation op = transactedOperationCopy.get(i);\n+            op.rollback();\n+        }\n+    }\n+\n+\n+    // Note: the messageImpl MUST be a copy of what the user sent - so that modifications by user\n+    // WILL NOT affect this.\n+    public void enqueuePublishWithinTransaction(String topicName, MessageImpl messageImpl, Message userMessage) {\n+        TransactedSendOperation sendOperation = new TransactedSendOperation(topicName, messageImpl, userMessage);\n+        synchronized (transactionLock){\n+            transactedOperation.add(sendOperation);\n+        }\n+    }\n+\n+    private void enqueueReceiveWithinTransaction(TransactedReceiveOperation receiveOperation) {\n+        synchronized (transactionLock){\n+            transactedOperation.add(receiveOperation);\n+        }\n+    }\n+\n+    private void commitTransactionState() throws JMSException {\n+        final ArrayList<TransactedOperation> transactedOperationCopy;\n+        synchronized (transactionLock){\n+            transactedOperationCopy = new ArrayList<TransactedOperation>(transactedOperation);\n+            transactedOperation.clear();\n+        }\n+\n+        if (!sessionState.isStarted()){\n+            // Ensure that there are ONLY send op's - else throw TransactionRolledBackException : we\n+            // cannot ack message !\n+            for (TransactedOperation op : transactedOperationCopy){\n+                if (op.requiresStartedSession())\n+                  throw new TransactionRolledBackException(\"Commit failed : session is not open - cant ack message\");\n+            }\n+        }\n+\n+        for (TransactedOperation op : transactedOperationCopy){\n+            try {\n+                op.commit();\n+            } catch (JMSException jEx){\n+                if (logger.isDebugEnabled()) logger.debug(\"Commit failed for \" + op, jEx);\n+                rollbackTransactionState(transactedOperationCopy);\n+                TransactionRolledBackException trbEx = new TransactionRolledBackException(\"Commit failed\");\n+                trbEx.setLinkedException(jEx);\n+                throw trbEx;\n+            }\n+        }\n+    }\n+\n+    public boolean isMessageExpired(MessageImpl message) {\n+        return 0 != message.getJMSExpiration() && SessionImpl.currentTimeMillis() > message.getJMSExpiration();\n+    }\n+\n+    public boolean isLocallyPublished(String messageId) {\n+        return connection.isLocallyPublished(messageId);\n+    }\n+\n+    public void addToLocallyPublishedMessageIds(String messageId) {\n+        connection.addToLocallyPublishedMessageIds(messageId);\n+    }\n+\n+    public ConnectionImpl getConnection() {\n+        return connection;\n+    }\n+\n+    private static final class Subscriptions {\n+        // Keeps track of number of subscribers created. This will prevent setMessageListener form\n+        // succeeding in case subscriberCreatedCount > 0\n+        // Their use is mutually exclusive.\n+        // private int subscriberCreatedCount = 0;\n+        private AtomicInteger numSubscribers = new AtomicInteger(0);\n+\n+        private final ConcurrentHashMap<TopicSubscription, Node> topicSubscriptionToSelectorMap =\n+            new ConcurrentHashMap<TopicSubscription, Node>(32);\n+        private final ConcurrentHashMap<QueueSubscription, Node> queueSubscriptionToSelectorMap =\n+            new ConcurrentHashMap<QueueSubscription, Node>(32);\n+\n+        // We make use of concurrent api for this map (and its list) since we will be reading\n+        // it heavily concurrently while modifying it rarely.\n+        private final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> topicSubscriptionToSubscriberMap =\n+            new ConcurrentHashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n+        private final Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> queueSubscriptionToSubscriberMap =\n+            new ConcurrentHashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n+\n+        // The value for the key is irrelevant - there is not\n+        private final Set<MessageConsumer> allConsumersSet = Collections.newSetFromMap(\n+            new IdentityHashMap<MessageConsumer, Boolean>());\n+\n+        private static final int SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE =\n+            Integer.getInteger(\"SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE\", 1024);\n+        // This is guarded by subscriberIdTo<Destination> lock - query/modify ONLY in that context !\n+        private final Map<String, String> topicSubscriberIdToTopicName =\n+            new LRUCacheMap<String, String>(SUBSCRIBER_ID_TO_DESTINATION_CACHE_SIZE, true);\n+\n+        public Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> createSubscriptionToSubscriberMapCopy() {\n+          Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> retval\n+              = new HashMap<Subscription, CopyOnWriteArrayList<MessageConsumer>>();\n+          retval.putAll(topicSubscriptionToSubscriberMap);\n+          retval.putAll(queueSubscriptionToSubscriberMap);\n+          return retval;\n+        }\n+\n+        public Set<MessageConsumer> getAllConsumersSet() {\n+          return allConsumersSet;\n+        }\n+\n+        public CopyOnWriteArrayList<? extends MessageConsumer> getSubscribers(Subscription subscription) {\n+            if (subscription.isTopic()) {\n+                assert subscription instanceof TopicSubscription;\n+                return topicSubscriptionToSubscriberMap.get(subscription);\n+            }\n+            if (subscription.isQueue()) {\n+                assert subscription instanceof QueueSubscription;\n+                return queueSubscriptionToSubscriberMap.get(subscription);\n+            }\n+            throw new IllegalArgumentException(\"Unknown subscription type \" + subscription);\n+        }\n+\n+        public Node getSelectorExpression(Subscription subscription) {\n+            if (subscription.isTopic()) {\n+                assert subscription instanceof TopicSubscription;\n+                return topicSubscriptionToSelectorMap.get(subscription);\n+            }\n+            if (subscription.isQueue()) {\n+                assert subscription instanceof QueueSubscription;\n+                return queueSubscriptionToSelectorMap.get(subscription);\n+            }\n+            throw new IllegalArgumentException(\"Unknown subscription type \" + subscription);\n+        }\n+\n+        public void registerSubscriberIdToTopic(String subscribedId, String topicName) throws JMSException {\n+            synchronized (topicSubscriberIdToTopicName){\n+                String currentTopicName = topicSubscriberIdToTopicName.get(subscribedId);\n+                if (null != currentTopicName && !currentTopicName.equals(topicName)) {\n+                    throw new JMSException(\"There is already a subscription in this session for \" +\n+                        \"same subscriberId for topic \" + currentTopicName);\n+                }\n+                topicSubscriberIdToTopicName.put(subscribedId, topicName);\n+            }\n+        }\n+\n+        public String findTopicNameForSubscriberId(String subscribedId) throws JMSException {\n+            synchronized (topicSubscriberIdToTopicName){\n+                String topicName = topicSubscriberIdToTopicName.get(subscribedId);\n+                if (null == topicName){\n+                    throw new JMSException(\"Unable to find topicName for subscriberId \" + subscribedId);\n+                }\n+                return topicName;\n+            }\n+        }\n+\n+        public void registerTopicSubscriptionSelector(TopicSubscription topicSubscription, Node selectorAst) {\n+            topicSubscriptionToSelectorMap.put(topicSubscription, selectorAst);\n+        }\n+\n+        public void registerQueueSubscriptionSelector(QueueSubscription queueSubscription, Node selectorAst) {\n+            queueSubscriptionToSelectorMap.put(queueSubscription, selectorAst);\n+        }\n+\n+        public boolean addToSubscriberSet(MessageConsumer consumer) {\n+            return allConsumersSet.add(consumer);\n+        }\n+\n+        public boolean addToSubscribers(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n+                                        String destination, String subscriberId) {\n+            switch (type){\n+              case QUEUE :\n+                return createIfMissingAndAdd(queueSubscriptionToSubscriberMap,\n+                    new QueueSubscription(destination, subscriberId),\n+                    subscriber);\n+              case TOPIC:\n+                return createIfMissingAndAdd(topicSubscriptionToSubscriberMap,\n+                    new TopicSubscription(destination, subscriberId),\n+                    subscriber);\n+              default:\n+                  throw new IllegalArgumentException(\"Unknown subscription type \" + type);\n+            }\n+        }\n+\n+        public boolean removeSubscriber(MessageConsumer subscriber, MessagingSessionFacade.DestinationType type,\n+                                        String destination, String subscriberId) {\n+            boolean retval = false;\n+            switch (type){\n+                case TOPIC:\n+                {\n+                    final CopyOnWriteArrayList<MessageConsumer> subscriberList =\n+                        topicSubscriptionToSubscriberMap.get(new TopicSubscription(destination, subscriberId));\n+                    if (null != subscriberList) {\n+                        if (subscriberList.remove(subscriber)){\n+                            numSubscribers.decrementAndGet();\n+                            if (subscriberList.isEmpty()){\n+                                // Unsubscribe\n+                                retval = true;\n+                            }\n+                        }\n+                    }\n+                    else retval = true;\n+                    break;\n+                }\n+                case QUEUE:\n+                {\n+                    final CopyOnWriteArrayList<MessageConsumer> subscriberList =\n+                        queueSubscriptionToSubscriberMap.get(new QueueSubscription(destination, subscriberId));\n+                    if (null != subscriberList) {\n+                        if (subscriberList.remove(subscriber)){\n+                            numSubscribers.decrementAndGet();\n+                            if (subscriberList.isEmpty()){\n+                                // Unsubscribe\n+                                retval = true;\n+                            }\n+                        }\n+                    }\n+                    else retval = true;\n+                    break;\n+                }\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown subscription type \" + type);\n+            }\n+            return retval;\n+        }\n+\n+        // returns true IF a new list is inserted.\n+        private boolean createIfMissingAndAdd(Map<Subscription, CopyOnWriteArrayList<MessageConsumer>> map,\n+                                              Subscription key, MessageConsumer value) {\n+            boolean retval = false;\n+            if (!map.containsKey(key)) {\n+                map.put(key, new CopyOnWriteArrayList<MessageConsumer>());\n+            }\n+\n+            List<MessageConsumer>  list = map.get(key);\n+            if (list.isEmpty()) retval = true;\n+            if (!list.contains(value)) {\n+                list.add(value);\n+                numSubscribers.incrementAndGet();\n+            }\n+            return retval;\n+        }\n+\n+        public int getNumSubscribers() {\n+            return numSubscribers.get();\n+        }\n+    }\n+}"},{"sha":"26db51499e2337ce62f3abd59a3a40dbf0059920","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/StateManager.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms;\n+\n+import org.slf4j.Logger;\n+\n+import javax.jms.JMSException;\n+\n+\n+/**\n+    Specific to jms package - NOT to be used elsewhere.\n+\n+    The util class allows for managing the current readiness 'state' of the object which hosts it\n+    along the axis of StateManager.State while being MT safe. Right now, both Connection and Session make use of it.\n+\n+    The lockObject is used to do timed wait's (which the host object will notify on) in case of async state changes.\n+\n+\n+    This is not a general purpose code, but specific to state transitions mentioned in jms spec.\n+\n+\n+    All use of the class goes like this :\n+\n+\n+    StateManager.State prevState;\n+    acquire lock:\n+        if in transition state, wait.\n+        if in expected state, return.\n+        if in error state, return/throw exception.\n+        if in valid state transition state -\n+            prevState = currentState.\n+            set to corresponding transition state (STARTING, CLOSING, etc).\n+        Other method specific changes.\n+    release lock:\n+\n+    nextState = prevState (in case state change failed, revert).\n+\n+    try {\n+        attempt state change.\n+        on success nextState = next valid state for this method.\n+    } finally {\n+        acquire lock:\n+          change state to nextState\n+        release lock:\n+    }\n+\n+    * So at any given point of time, the state will be in transition ONLY when there is an attempt\n+            being made to transition.\n+    * The state will always be in a final state at all other points of time.\n+    * No attempt will be made to change state while a transition state is currently in progress.\n+ */\n+final class StateManager {\n+  public static final long WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE =\n+      Long.getLong(\"WAIT_TIME_FOR_TRANSIENT_STATE_CHANGE\", 16000L);\n+\n+  static enum State {\n+        STARTING(true, false, true),\n+        STARTED(true, false, false),\n+        STOPPING(false, false, true),\n+        STOPPED(false, false, false),\n+        CLOSING(false, true, true),\n+        CLOSED(false, true, false);\n+\n+        private final boolean inStartMode;\n+        private final boolean inCloseMode;\n+        private final boolean inTransitionMode;\n+\n+        State(boolean inStartMode, boolean inCloseMode, boolean inTransitionMode) {\n+            this.inStartMode = inStartMode;\n+            this.inCloseMode = inCloseMode;\n+            this.inTransitionMode = inTransitionMode;\n+        }\n+\n+        public boolean isInStartMode() {\n+            return inStartMode;\n+        }\n+\n+        public boolean isInCloseMode() {\n+            return inCloseMode;\n+        }\n+\n+        public boolean isInTransitionMode() {\n+            return inTransitionMode;\n+        }\n+    }\n+\n+    // DO NOT do something silly like State.STARTING == currentState || State.STARTED == currentState, etc !\n+    private volatile State currentState;\n+    private final Object lockObject;\n+\n+    StateManager(State startStart, Object lockObject){\n+        this.currentState = startStart;\n+        this.lockObject = lockObject;\n+    }\n+\n+    State getCurrentState() {\n+        return currentState;\n+    }\n+\n+    boolean isStarted() {\n+        return State.STARTED == currentState;\n+    }\n+\n+    boolean isInStartMode() {\n+        return currentState.isInStartMode();\n+    }\n+\n+    boolean isStopped() {\n+        return State.STOPPED == currentState;\n+    }\n+\n+    boolean isClosed() {\n+        return State.CLOSED == currentState;\n+    }\n+\n+    // NOT locking explicitly : typically, already locked on lockObject\n+    boolean isInCloseMode() {\n+        return currentState.isInCloseMode();\n+    }\n+\n+    // NOT locking explicitly : typically, already locked on lockObject\n+    boolean isTransitionState() {\n+        return currentState.isInTransitionMode();\n+    }\n+\n+    void setCurrentState(State currentState) {\n+        this.currentState = currentState;\n+    }\n+\n+    // NOT locking explicitly : MUST be already locked on lockObject\n+    void waitForTransientStateChange(long timeout, Logger logger) throws JMSException {\n+        final long startTime = SessionImpl.currentTimeMillis();\n+        final int WAIT_UNIT = 100;\n+        int retryCount = (int)(timeout / WAIT_UNIT);\n+\n+        while (isTransitionState()) {\n+            try {\n+                // If we are NOT locked on lockObject, this will throw exception !\n+                lockObject.wait(WAIT_UNIT);\n+            } catch (InterruptedException e) {\n+                // bubble it up.\n+                JMSException jex = new JMSException(\"Thread interrupted ... \" + e);\n+                jex.setLinkedException(e);\n+                throw jex;\n+            }\n+            retryCount --;\n+            if (retryCount <= 0) {\n+                if (logger.isDebugEnabled()) DebugUtil.dumpAllStacktraces(logger);\n+                // throw new JMSException(\"wait timeout \" + (SessionImpl.currentTimeMillis() - startTime));\n+                throw new JMSException(\"wait for \" + (SessionImpl.currentTimeMillis() - startTime) + \" timeout\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"StateManager\");\n+        sb.append(\"{currentState=\").append(currentState);\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}"},{"sha":"2e0cddd7ca8d93ba7cfffda620213100b56b1230","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","status":"added","additions":106,"deletions":0,"changes":106,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContext.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.jndi;\n+\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+\n+import javax.jms.ConnectionFactory;\n+import javax.naming.Name;\n+import javax.naming.NamingException;\n+import javax.naming.directory.InitialDirContext;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Set;\n+\n+/**\n+ * Based (very very loosely) on\n+ * <a href=\"http://docs.oracle.com/javase/1.3/docs/guide/jndi/spec/spi/jndispi.fm.html\">jndi guide</a>. <br/>\n+ * The InitialContext implementation clients should be using to get to our implementation. <br/>\n+ * It is possible (by configuring via administrative means for example) to use a different DirContext\n+ * to get to our provider implementation\n+ * if the various classes exposed are the same as exposed via this DirContext.<br/>\n+ * <p/>\n+ * Ideally, the env property\n+ * {@link javax.naming.Context.INITIAL_CONTEXT_FACTORY} \"java.naming.factory.initial\" is set to our factory\n+ * {@link HedwigInitialContextFactory} classname which will return this InitialDirContext.\n+ */\n+public class HedwigInitialContext extends InitialDirContext {\n+\n+    public static final String CONNECTION_FACTORY_NAME = \"jms/ConnectionFactory\";\n+    public static final String TOPIC_CONNECTION_FACTORY_NAME = \"jms/TopicConnectionFactory\";\n+    // public static final String QUEUE_CONNECTION_FACTORY_NAME = \"jms/QueueConnectionFactory\";\n+\n+    // Hardcoding to point to HedwigConnectionFactoryImpl by default.\n+    private static final Set<String> defaultNamesMapping;\n+    static {\n+        Set<String> set = new HashSet<String>(8);\n+\n+        // The actual name's for the various factories are bound by an admin. For convinence sake,\n+        // we are providing default bindings.\n+\n+        // The default connection\n+        set.add(\"jms/ConnectionFactory\");\n+        set.add(\"jms/TopicConnectionFactory\");\n+        // Add in future - for now, we do not support it.\n+        // set.add(\"jms/QueueConnectionFactory\");\n+\n+\n+        set.add(\"ConnectionFactory\");\n+        set.add(\"TopicConnectionFactory\");\n+        // Add in future - for now, we do not support it.\n+        // set.add(\"QueueConnectionFactory\");\n+        defaultNamesMapping = Collections.unmodifiableSet(set);\n+    }\n+\n+    protected HedwigInitialContext(boolean lazy) throws NamingException {\n+        super(lazy);\n+    }\n+\n+    public HedwigInitialContext() throws NamingException {\n+        super();\n+    }\n+\n+    public HedwigInitialContext(Hashtable<?, ?> environment) throws NamingException {\n+        super(environment);\n+    }\n+\n+    private ConnectionFactory ourLookup(String name){\n+        if (defaultNamesMapping.contains(name)){\n+            return new HedwigConnectionFactoryImpl();\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Object lookup(String name) throws NamingException {\n+        ConnectionFactory factory = ourLookup(name);\n+        if (null != factory) return factory;\n+\n+        return super.lookup(name);\n+    }\n+\n+    @Override\n+    public Object lookup(Name name) throws NamingException {\n+        ConnectionFactory factory = ourLookup(name.toString());\n+        if (null != factory) return factory;\n+\n+        return super.lookup(name);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"b701aad3256b689b0e7048cb784a5c9d89fd6f0d","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/HedwigInitialContextFactory.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,33 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.jndi;\n+\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.spi.InitialContextFactory;\n+import java.util.Hashtable;\n+\n+/**\n+ * See HedwigInitialContext for more information.\n+ */\n+public class HedwigInitialContextFactory implements InitialContextFactory {\n+    @Override\n+    public Context getInitialContext(Hashtable<?, ?> environment) throws NamingException {\n+        return new HedwigInitialContext(environment);\n+    }\n+}"},{"sha":"bab5787c4c6d7849888e41872a34c034fbb08248","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/jndi/package-info.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,65 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+\n+Contains some default SHIM's to interface with JNDI - so that clients can use our JMS provider without\n+ANY code level ties.<br/>\n+The ideal way to use JNDI is to have administrator configure JNDI such that a well-known jndi NAME is\n+bound to \"org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl\" for Topic and JMS connection factory. <br/>\n+<p/>\n+<p/>\n+Alternatively, if the user is NOT within an admin controlled JNDI environment, there are two other\n+common options : <br/>\n+<ul>\n+  <li>Set the \"java.naming.factory.initial\" environment property to our Context factory\n+    \"org.apache.hedwig.jms.jndi.HedwigInitialContextFactory\"</li>\n+  <li>Directly instantiate the \"org.apache.hedwig.jms.jndi.HedwigInitialContext\" as a JNDI InitialContext\n+    and pull the relevant factories, via it.</li>\n+</ul>\n+\n+In either of these two cases, we expose 6 well defined 'names' for users, to pull the relevant\n+factories from the JNDI context.\n+<table border=\"1\">\n+  <tr>\n+    <th>JNDI name</th>\n+    <th>Connection factory</th>\n+  </tr>\n+  <tr>\n+    <td>jms/ConnectionFactory</td>\n+    <td>ConnectionFactory</td>\n+  </tr>\n+  <tr>\n+    <td>jms/TopicConnectionFactory</td>\n+    <td>TopicConnectionFactory</td>\n+  </tr>\n+  <tr>\n+    <td>jms/QueueConnectionFactory</td>\n+    <td>QueueConnectionFactory</td>\n+  </tr>\n+  <tr>\n+    <td>ConnectionFactory</td>\n+    <td>ConnectionFactory</td>\n+  </tr>\n+  <tr>\n+    <td>TopicConnectionFactory</td>\n+    <td>TopicConnectionFactory</td>\n+  </tr>\n+  <tr>\n+    <td>QueueConnectionFactory</td>\n+    <td>QueueConnectionFactory</td>\n+  </tr>\n+</table>"},{"sha":"fb564dcd5c23e9471741c7a8c439ef48140482cb","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","status":"added","additions":657,"deletions":0,"changes":657,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/BytesMessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,657 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageEOFException;\n+import javax.jms.MessageNotReadableException;\n+import javax.jms.MessageNotWriteableException;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * To be used for raw bytes ...\n+ */\n+public class BytesMessageImpl extends MessageImpl implements BytesMessage {\n+    private ReadOnlyMessage readOnlyMessage;\n+    private WriteOnlyMessage writeOnlyMessage;\n+    private boolean readMode;\n+\n+    public BytesMessageImpl(SessionImpl session) throws JMSException {\n+        super(session);\n+        clearBody();\n+    }\n+\n+    // To clone a message\n+    public BytesMessageImpl(SessionImpl session, BytesMessageImpl message, String sourceTopicName,\n+                            String subscriberId) throws JMSException {\n+        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n+        try {\n+            if (message.readMode){\n+                this.readOnlyMessage = new ReadOnlyMessage(message.readOnlyMessage.getDataCopy());\n+                this.writeOnlyMessage = null;\n+            }\n+            else {\n+                this.readOnlyMessage = null;\n+                this.writeOnlyMessage = new WriteOnlyMessage(message.writeOnlyMessage.getPayloadAsBytes());\n+            }\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.readMode = message.readMode;\n+    }\n+\n+    // To clone a message from a BytesMessage which is NOT BytesMessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    public BytesMessageImpl(BytesMessage message, SessionImpl session) throws JMSException {\n+        super((Message) message, session);\n+\n+        if (message instanceof BytesMessageImpl) {\n+            throw new JMSException(\"Coding bug - should use this constructor ONLY for non \" +\n+                \"BytesMessageImpl messages\");\n+        }\n+\n+        // copy the bytes ...\n+        final byte[] data;\n+        {\n+            final long length = message.getBodyLength();\n+            if (length < 0 || length >= Integer.MAX_VALUE) throw new JMSException(\"Unreasonably \" +\n+                \"large value for body Length : \" + length);\n+\n+            data = new byte[(int) length];\n+            int read = 0;\n+            while (read < length){\n+                int sz = message.readBytes(data, read);\n+                read += sz;\n+            }\n+        }\n+\n+        try {\n+            this.writeOnlyMessage = new WriteOnlyMessage(data);\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.readOnlyMessage  = null;\n+        this.readMode = true;\n+    }\n+\n+    public BytesMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n+                            String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n+        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n+\n+        this.readOnlyMessage = new ReadOnlyMessage(message.getBody().toByteArray());\n+        this.writeOnlyMessage = null;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    protected MessageUtil.SupportedMessageTypes  getJmsMessageType() {\n+        return MessageUtil.SupportedMessageTypes.BYTES;\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return false;\n+    }\n+\n+    @Override\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        super.populateBuilderWithHeaders(builder);\n+\n+        // Now set body and type.\n+        try {\n+            builder.setBody(ByteString.copyFrom(getPayloadData()));\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    @Override\n+    public long getBodyLength() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        return readOnlyMessage.getBodyLength();\n+    }\n+\n+    @Override\n+    public boolean readBoolean() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readBoolean();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public byte readByte() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readByte();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readUnsignedByte() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readUnsignedByte();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public short readShort() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readShort();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readUnsignedShort() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readUnsignedShort();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public char readChar() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readChar();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readInt() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readInt();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public long readLong() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readLong();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public float readFloat() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readFloat();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public double readDouble() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readDouble();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public String readUTF() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readUTF();\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readBytes(byte[] data) throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readBytes(data);\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readBytes(byte[] data, int length) throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readBytes(data, length);\n+        } catch (IOException eof){\n+            MessageEOFException eofEx = new MessageEOFException(\"eof ?\");\n+            eofEx.setLinkedException(eof);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBoolean(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeByte(byte val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeByte(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeShort(short val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeShort(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeChar(char val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeChar(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeInt(int val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeInt(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeLong(long val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeLong(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeFloat(float val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeFloat(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeDouble(double val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeDouble(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeUTF(String val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeUTF(val);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] data) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBytes(data);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] data, int offset, int length) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBytes(data, offset, length);\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    // This method is ONLY supposed to be used for object form of primitive types !\n+    @Override\n+    public void writeObject(Object obj) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            // unrolling it\n+            if (obj instanceof Boolean) {\n+                writeOnlyMessage.writeBoolean((Boolean) obj);\n+            }\n+            else if (obj instanceof Byte) {\n+                writeOnlyMessage.writeByte((Byte) obj);\n+            }\n+            else if (obj instanceof Short) {\n+                writeOnlyMessage.writeShort((Short) obj);\n+            }\n+            else if (obj instanceof Character) {\n+                writeOnlyMessage.writeChar((Character) obj);\n+            }\n+            else if (obj instanceof Integer) {\n+                writeOnlyMessage.writeInt((Integer) obj);\n+            }\n+            else if (obj instanceof Long) {\n+                writeOnlyMessage.writeLong((Long) obj);\n+            }\n+            else if (obj instanceof Float) {\n+                writeOnlyMessage.writeFloat((Float) obj);\n+            }\n+            else if (obj instanceof Double) {\n+                writeOnlyMessage.writeDouble((Double) obj);\n+            }\n+            else if (obj instanceof String) {\n+                writeOnlyMessage.writeUTF((String) obj);\n+            }\n+            else if (obj instanceof byte[]) {\n+                writeOnlyMessage.writeBytes((byte[]) obj);\n+            }\n+            else{\n+                throw new JMSException(\"Unsupported type for obj : \" + obj.getClass());\n+            }\n+        } catch (IOException ioEx){\n+            MessageEOFException eofEx = new MessageEOFException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void reset() throws JMSException {\n+        if (this.readMode) return ;\n+        try {\n+            this.readOnlyMessage = new ReadOnlyMessage(writeOnlyMessage.getPayloadAsBytes());\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to convert write-only message to read-only message .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.readMode = true;\n+        this.writeOnlyMessage = null;\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        super.clearBody();\n+        this.writeOnlyMessage = new WriteOnlyMessage();\n+        this.readOnlyMessage = null;\n+        this.readMode = false;\n+    }\n+\n+    private byte[] getPayloadData() throws IOException {\n+        if (readMode) return readOnlyMessage.getDataCopy();\n+        return writeOnlyMessage.getPayloadAsBytes();\n+    }\n+\n+    @Override\n+    BytesMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n+        throws JMSException {\n+        return new BytesMessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+\n+    // Using java object's instead of primitives to avoid having to store schema separately.\n+    private static class ReadOnlyMessage {\n+\n+        private final DataInputStream dis;\n+        private final byte[] data;\n+\n+        public ReadOnlyMessage(byte[] data) {\n+            this.dis = new DataInputStream(new ByteArrayInputStream(data));\n+            this.data = data;\n+        }\n+\n+        public byte[] getDataCopy(){\n+            byte[] retval = new byte[data.length];\n+            System.arraycopy(data, 0, retval, 0, retval.length);\n+            return retval;\n+        }\n+\n+        public int getBodyLength() {\n+            return data.length;\n+        }\n+\n+        public boolean readBoolean() throws IOException {\n+            return dis.readBoolean();\n+        }\n+\n+        public byte readByte() throws IOException {\n+            return dis.readByte();\n+        }\n+\n+        public int readUnsignedByte() throws IOException {\n+            return dis.readUnsignedByte();\n+        }\n+\n+        public short readShort() throws IOException {\n+            return dis.readShort();\n+        }\n+\n+        public int readUnsignedShort() throws IOException {\n+            return dis.readUnsignedShort();\n+        }\n+\n+        public char readChar() throws IOException {\n+            return dis.readChar();\n+        }\n+\n+        public int readInt() throws IOException {\n+            return dis.readInt();\n+        }\n+\n+        public long readLong() throws IOException {\n+            return dis.readLong();\n+        }\n+\n+        public float readFloat() throws IOException {\n+            return dis.readFloat();\n+        }\n+\n+        public double readDouble() throws IOException {\n+            return dis.readDouble();\n+        }\n+\n+        public String readUTF() throws IOException {\n+            return dis.readUTF();\n+        }\n+\n+        public int readBytes(byte[] data) throws IOException {\n+            return dis.read(data);\n+        }\n+\n+        public int readBytes(byte[] data, int length) throws IOException {\n+            if (length < 0 || length > data.length)\n+              throw new IndexOutOfBoundsException(\"Invalid length specified : \" + length + \", data : \" + data.length);\n+            return dis.read(data, 0, length);\n+        }\n+    }\n+\n+    private static class WriteOnlyMessage {\n+\n+        private final ByteArrayOutputStream baos;\n+        private final DataOutputStream dos;\n+\n+        public WriteOnlyMessage(){\n+            baos = new ByteArrayOutputStream();\n+            dos = new DataOutputStream(baos);\n+        }\n+\n+        public WriteOnlyMessage(byte[] data) throws IOException {\n+            baos = new ByteArrayOutputStream();\n+            dos = new DataOutputStream(baos);\n+            dos.write(data);\n+        }\n+\n+        public byte[] getPayloadAsBytes() throws IOException {\n+            dos.flush();\n+            return baos.toByteArray();\n+        }\n+\n+        public void writeBoolean(boolean val) throws IOException {\n+            dos.writeBoolean(val);\n+        }\n+\n+        public void writeByte(byte val) throws IOException {\n+            dos.writeByte(val);\n+        }\n+\n+        public void writeShort(short val) throws IOException {\n+            dos.writeShort(val);\n+        }\n+\n+        public void writeChar(char val) throws IOException {\n+            dos.writeChar(val);\n+        }\n+\n+        public void writeInt(int val) throws IOException {\n+            dos.writeInt(val);\n+        }\n+\n+        public void writeLong(long val) throws IOException {\n+            dos.writeLong(val);\n+        }\n+\n+        public void writeFloat(float val) throws IOException {\n+            dos.writeFloat(val);\n+        }\n+\n+        public void writeDouble(double val) throws IOException {\n+            dos.writeDouble(val);\n+        }\n+\n+        public void writeUTF(String val) throws IOException {\n+            dos.writeUTF(val);\n+        }\n+\n+        public void writeBytes(byte[] data) throws IOException {\n+            dos.write(data);\n+        }\n+\n+        public void writeBytes(byte[] data, int offset, int length) throws IOException {\n+            dos.write(data, offset, length);\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"af806fb4a5bbd39d078da93df892e424f9b036c2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","status":"added","additions":295,"deletions":0,"changes":295,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MapMessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,295 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.JMSException;\n+import javax.jms.MapMessage;\n+import javax.jms.Message;\n+import javax.jms.MessageNotWriteableException;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * There is a weaker expectation of ordering and strong expectation of &lt;key, value&gt; container for data.\n+ */\n+public class MapMessageImpl extends MessageImpl implements MapMessage {\n+    private final Map<String, Object> payload = new LinkedHashMap<String, Object>(4);\n+    private boolean readMode;\n+\n+    public MapMessageImpl(SessionImpl session) throws JMSException {\n+        super(session);\n+        clearBody();\n+    }\n+\n+    public MapMessageImpl(SessionImpl session, MapMessageImpl message, String sourceTopicName,\n+                          String subscriberId) throws JMSException {\n+        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n+        this.payload.putAll(message.payload);\n+        this.readMode = message.readMode;\n+    }\n+\n+    // To clone a message from a MapMessage which is NOT MapMessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    public MapMessageImpl(MapMessage message, SessionImpl session) throws JMSException {\n+        super((Message) message, session);\n+\n+        if (message instanceof MapMessageImpl) {\n+            throw new JMSException(\"Coding bug - should use this constructor ONLY for non MapMessageImpl messages\");\n+        }\n+\n+\n+        Enumeration keys = message.getMapNames();\n+        while (keys.hasMoreElements()){\n+            Object key = keys.nextElement();\n+            if (!(key instanceof String))\n+              throw new JMSException(\"Unsupported type (expected String) for key : \" + key);\n+\n+            String skey = (String) key;\n+            this.payload.put(skey, message.getObject(skey));\n+        }\n+        this.readMode = false;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MapMessageImpl(SessionImpl session, PubSubProtocol.Message message,\n+                          Map<String, Object> properties, String sourceTopicName, String subscriberId,\n+                          Runnable ackRunnable) throws JMSException {\n+        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n+        try {\n+            this.payload.putAll((Map<String, Object>) MessageUtil.bytesToObject(message.getBody().toByteArray()));\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    protected MessageUtil.SupportedMessageTypes  getJmsMessageType() {\n+        return MessageUtil.SupportedMessageTypes.MAP;\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return false;\n+    }\n+\n+    @Override\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        super.populateBuilderWithHeaders(builder);\n+\n+        // Now set body and type.\n+        try {\n+            builder.setBody(ByteString.copyFrom(MessageUtil.objectToBytes(this.payload)));\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    @Override\n+    public boolean getBoolean(String name) throws JMSException {\n+        return MessageUtil.asBoolean(payload.get(name));\n+    }\n+\n+    @Override\n+    public byte getByte(String name) throws JMSException {\n+        return MessageUtil.asByte(payload.get(name));\n+    }\n+\n+    @Override\n+    public short getShort(String name) throws JMSException {\n+        return MessageUtil.asShort(payload.get(name));\n+    }\n+\n+    @Override\n+    public char getChar(String name) throws JMSException {\n+        return MessageUtil.asChar(payload.get(name));\n+    }\n+\n+    @Override\n+    public int getInt(String name) throws JMSException {\n+        return MessageUtil.asInteger(payload.get(name));\n+    }\n+\n+    @Override\n+    public long getLong(String name) throws JMSException {\n+        return MessageUtil.asLong(payload.get(name));\n+    }\n+\n+    @Override\n+    public float getFloat(String name) throws JMSException {\n+        return MessageUtil.asFloat(payload.get(name));\n+    }\n+\n+    @Override\n+    public double getDouble(String name) throws JMSException {\n+        return MessageUtil.asDouble(payload.get(name));\n+    }\n+\n+    @Override\n+    public String getString(String name) throws JMSException {\n+        return MessageUtil.asString(payload.get(name));\n+    }\n+\n+    @Override\n+    public byte[] getBytes(String name) throws JMSException {\n+        return MessageUtil.asBytes(payload.get(name));\n+    }\n+\n+    @Override\n+    public Object getObject(String name) throws JMSException {\n+        return payload.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration getMapNames() throws JMSException {\n+        return Collections.enumeration(payload.keySet());\n+    }\n+\n+    @Override\n+    public void setBoolean(String name, boolean value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+    }\n+\n+    @Override\n+    public void setByte(String name, byte value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setShort(String name, short value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setChar(String name, char value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setInt(String name, int value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setLong(String name, long value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setFloat(String name, float value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setDouble(String name, double value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setString(String name, String value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setBytes(String name, byte[] value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setBytes(String name, byte[] value, int i, int i1) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public void setObject(String name, Object value) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        if (!MessageUtil.isValidKey(name)) throw new IllegalArgumentException(\"Invalid key \" + name);\n+        payload.put(name, value);\n+\n+    }\n+\n+    @Override\n+    public boolean itemExists(String name) throws JMSException {\n+        return payload.containsKey(name);\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        super.clearBody();\n+        // allow read and write.\n+        this.payload.clear();\n+        this.readMode = false;\n+    }\n+\n+    @Override\n+    public void reset() throws JMSException {\n+        if (this.readMode) return ;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    MapMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n+        return new MapMessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+}"},{"sha":"d13feb033427fbe9cdce8118224ccd66df3ad838","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","status":"added","additions":872,"deletions":0,"changes":872,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,872 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.message.header.MetadataProcessor;\n+import org.apache.hedwig.jms.selector.SelectorEvaluationException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageFormatException;\n+import javax.jms.MessageNotWriteableException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Implementation of a message.\n+ */\n+public class MessageImpl implements Message {\n+\n+    // This is of type byte for now - enough ?\n+    public static final String JMS_MESSAGE_TYPE_KEY = \"jmsBodyType\";\n+    // 'others' (non-jms clients) can depend on this boolean metadata property : for now, part\n+    // of jms values directly due to how metadata is being designed !\n+    // sigh :-(\n+    public static final String EMPTY_BODY_KEY = \"bodyEmpty\";\n+\n+\n+    private final static Logger logger = LoggerFactory.getLogger(MessageImpl.class);\n+\n+    public static final String JMS_MESSAGE_ID = \"JMSMessageID\";\n+    public static final String JMS_TIMESTAMP = \"JMSTimestamp\";\n+    public static final String JMS_CORRELATION_ID = \"JMSCorrelationID\";\n+    public static final String JMS_REPLY_TO = \"JMSReplyTo\";\n+    public static final String JMS_DESTINATION = \"JMSDestination\";\n+    public static final String JMS_DELIVERY_MODE = \"JMSDeliveryMode\";\n+    public static final String JMS_REDELIVERED = \"JMSRedelivered\";\n+    public static final String JMS_TYPE = \"JMSType\";\n+    public static final String JMS_EXPIRATION = \"JMSExpiration\";\n+    public static final String JMS_PRIORITY = \"JMSPriority\";\n+\n+    private static final Set<String> standardProperties;\n+    static {\n+        Set<String> set = new HashSet<String>(16);\n+        set.add(JMS_MESSAGE_ID);\n+        set.add(JMS_TIMESTAMP);\n+        set.add(JMS_CORRELATION_ID);\n+\n+        set.add(JMS_REPLY_TO);\n+        set.add(JMS_DESTINATION);\n+        set.add(JMS_DELIVERY_MODE);\n+\n+        // Currently simulated in provider - NOT from hedwig.\n+        set.add(JMS_REDELIVERED);\n+        set.add(JMS_TYPE);\n+\n+        set.add(JMS_EXPIRATION);\n+        set.add(JMS_PRIORITY);\n+\n+        standardProperties = Collections.unmodifiableSet(set);\n+    }\n+\n+    private final SessionImpl session;\n+    private final String serverJmsMessageId;\n+\n+    private String jmsMessageId;\n+    private long jmsTimestamp = 0;\n+    private String jmsCorrelationID;\n+\n+    private Destination jmsReplyTo;\n+    private Destination jmsDestination;\n+    private int jmsDeliveryMode = DeliveryMode.PERSISTENT;\n+\n+    private boolean jmsRedelivered;\n+    private String jmsType;\n+\n+    private long jmsExpiration = 0L;\n+    private int jmsPriority = Message.DEFAULT_PRIORITY;\n+\n+    // Note: this DOES NOT contain standard headers - which are explicitly handled.\n+    private boolean propertiesReadOnly = false;\n+    protected Map<String, Object> properties = new HashMap<String, Object>(4);\n+\n+    // key == standard property.\n+    private Set<String> standardPropertiesExists = new HashSet<String>(16);\n+    private Set<String> standardPropertiesExistsForWire = new HashSet<String>(16);\n+\n+    private final String sourceName;\n+    private final String subscriberId;\n+\n+    private final Runnable ackRunnable;\n+\n+    // This is to be set to true ONLY for testing - NOT otherwise !\n+    // The JMS api DOES NOT expose this ...\n+    // private boolean allowSpecifyJMSMessageIDForTest;\n+\n+    //private final PubSubProtocol.Message rawMessage;\n+\n+    public MessageImpl(SessionImpl session){\n+        this.session = session;\n+\n+        this.sourceName = null;\n+        this.subscriberId = null;\n+        this.ackRunnable = null;\n+        this.serverJmsMessageId = null;\n+        // this.rawMessage = null;\n+    }\n+\n+    MessageImpl(SessionImpl session, MessageImpl message, String sourceName, String subscriberId)\n+        throws JMSException {\n+        this.session = session;\n+        this.sourceName = sourceName;\n+        this.subscriberId = subscriberId;\n+        this.ackRunnable = message.getAckRunnable();\n+        this.serverJmsMessageId = message.getServerJmsMessageId();\n+        // this.rawMessage = null;\n+\n+        // Copy all properties from message to this class.\n+\n+        this.properties.putAll(message.properties);\n+\n+        // Now copy rest of the state over ...\n+        if (message.propertyExists(JMS_MESSAGE_ID)) setJMSMessageIDInternal(message.getJMSMessageID());\n+        if (message.propertyExists(JMS_TIMESTAMP)) setJMSTimestamp(message.getJMSTimestamp());\n+        if (message.propertyExists(JMS_CORRELATION_ID)) setJMSCorrelationID(message.getJMSCorrelationID());\n+        // We do not support this right now.\n+        // if (message.propertyExists(JMS_CORRELATION_ID_AS_BYTES))\n+        //    setJMSCorrelationIDAsBytes(message.getJMSCorrelationIDAsBytes());\n+        if (message.propertyExists(JMS_REPLY_TO)) setJMSReplyTo(message.getJMSReplyTo());\n+        if (message.propertyExists(JMS_DESTINATION)) setJMSDestination(message.getJMSDestination());\n+        if (message.propertyExists(JMS_DELIVERY_MODE)) setJMSDeliveryMode(message.getJMSDeliveryMode());\n+        if (message.propertyExists(JMS_REDELIVERED)) setJMSRedelivered(message.getJMSRedelivered());\n+        if (message.propertyExists(JMS_TYPE)) setJMSType(message.getJMSType());\n+        if (message.propertyExists(JMS_EXPIRATION)) setJMSExpiration(message.getJMSExpiration());\n+        if (message.propertyExists(JMS_PRIORITY)) setJMSPriority(message.getJMSPriority());\n+\n+        this.propertiesReadOnly = message.propertiesReadOnly;\n+    }\n+\n+    // To clone a message from a Message which is NOT MessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    MessageImpl(Message message, SessionImpl session) throws JMSException {\n+        this.session = session;\n+        this.sourceName = null;\n+        this.subscriberId = null;\n+        this.ackRunnable = null;\n+        this.serverJmsMessageId = null;\n+        // this.rawMessage = null;\n+\n+        assert (! (message instanceof MessageImpl ));\n+\n+        // Copy all properties from message to this class.\n+        Enumeration names = message.getPropertyNames();\n+        while (names.hasMoreElements()){\n+            Object name = names.nextElement();\n+            if (!(name instanceof String))\n+              throw new JMSException(\"Unsupported type (expected String) for key : \" + name);\n+\n+            String sname = (String) name;\n+            this.properties.put(sname, message.getObjectProperty(sname));\n+        }\n+\n+        // Now copy rest of the state over ...\n+        // JMS VIOLATION: we will be unable to check for propertyExists after this,\n+        //  at sender and receiver side ... sigh :-(\n+        setJMSMessageIDInternal(message.getJMSMessageID());\n+        setJMSTimestamp(message.getJMSTimestamp());\n+        setJMSCorrelationID(message.getJMSCorrelationID());\n+        // We do not support this right now.\n+        // setJMSCorrelationIDAsBytes(message.getJMSCorrelationIDAsBytes());\n+        setJMSReplyTo(message.getJMSReplyTo());\n+        setJMSDestination(message.getJMSDestination());\n+        setJMSDeliveryMode(message.getJMSDeliveryMode());\n+        setJMSRedelivered(message.getJMSRedelivered());\n+        setJMSType(message.getJMSType());\n+        setJMSExpiration(message.getJMSExpiration());\n+        setJMSPriority(message.getJMSPriority());\n+\n+        // Should be able to modify, right ?\n+        this.propertiesReadOnly = false;\n+\n+        // remove all jms standard keys from properties now : this should ideally result in zero\n+        // removals ... but we never know with client code !\n+        for (String key : standardProperties) properties.remove(key);\n+    }\n+\n+    MessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n+                String sourceName, String subscriberId, Runnable ackRunnable) throws JMSException {\n+        this.session = session;\n+        this.sourceName = sourceName;\n+        this.subscriberId = subscriberId;\n+        this.ackRunnable = ackRunnable;\n+        // this.rawMessage = message;\n+\n+        // setJMSMessageID(getStringProperty(properties, JMS_MESSAGE_ID));\n+        setJMSMessageIDInternal(MessageUtil.generateJMSMessageIdFromSeqId(message.getMsgId()));\n+        this.serverJmsMessageId = getJMSMessageID();\n+\n+        if (properties.containsKey(JMS_TIMESTAMP)) setJMSTimestamp(getLongProperty(properties, JMS_TIMESTAMP));\n+        if (properties.containsKey(JMS_CORRELATION_ID)) setJMSCorrelationID(\n+            getStringProperty(properties, JMS_CORRELATION_ID));\n+        if (null != getStringProperty(properties, JMS_REPLY_TO)) {\n+            setJMSReplyTo(\n+                    session.getDestination(session.findDestinationType(getStringProperty(properties, JMS_REPLY_TO)),\n+                        getStringProperty(properties, JMS_REPLY_TO)\n+                    ));\n+        }\n+        if (null != getStringProperty(properties, JMS_DESTINATION)) {\n+            setJMSDestination(\n+                    session.getDestination(session.findDestinationType(\n+                        getStringProperty(properties, JMS_DESTINATION)),\n+                        getStringProperty(properties, JMS_DESTINATION)\n+                    ));\n+        }\n+\n+        if (properties.containsKey(JMS_DELIVERY_MODE)) setJMSDeliveryMode(\n+            getIntProperty(properties, JMS_DELIVERY_MODE));\n+        if (properties.containsKey(JMS_TYPE)) setJMSType(getStringProperty(properties, JMS_TYPE));\n+\n+        if (properties.containsKey(JMS_EXPIRATION)) setJMSExpiration(\n+            getLongProperty(properties, JMS_EXPIRATION));\n+        if (properties.containsKey(JMS_PRIORITY)) setJMSPriority(\n+            getIntProperty(properties, JMS_PRIORITY));\n+\n+\n+        // remove all jms standard keys from properties now : this should result in zero removals ...\n+        // but adding anyway.\n+        for (String key : standardProperties) properties.remove(key);\n+\n+        // Immutable after reading from stream !\n+        this.propertiesReadOnly = true;\n+        this.properties.putAll(properties);\n+    }\n+\n+    protected MessageUtil.SupportedMessageTypes getJmsMessageType(){\n+        // Validate against coding bug ... this MUST be overridden in all subclasses.\n+        if (getClass() != MessageImpl.class)\n+          throw new IllegalStateException(\"This method must be overridden by subclasses. class : \" + getClass());\n+        return MessageUtil.SupportedMessageTypes.ONLY_MESSAGE;\n+    }\n+\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        // This is to be called ONLY from the base class - all children MUST override it and NOT delegate to it.\n+        if (getClass() != MessageImpl.class) {\n+            throw new JMSException(\"Unexpected to call MessageImpl's generateHedwigMessage from subclass \" +\n+                getClass());\n+        }\n+\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        populateBuilderWithHeaders(builder);\n+        // no body - will be appropriately set in populateBuilderWithHeaders().\n+        return builder.build();\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return true;\n+    }\n+\n+    /*\n+    protected void markEmptyBody(PubSubProtocol.Message.Builder builder) {\n+        MetadataProcessor.addBooleanProperty(builder, EMPTY_BODY_KEY, true);\n+        builder.setBody(ByteString.EMPTY);\n+    }\n+    */\n+\n+    protected boolean hasBodyFromProperties() {\n+        // if key missing (common case), then there is body.\n+        if (!properties.containsKey(EMPTY_BODY_KEY)) return true;\n+        // If present, then check if it is a boolean of value true.\n+        Object value = properties.get(EMPTY_BODY_KEY);\n+\n+        // special case null.\n+        if (null == value) return true;\n+        if (value instanceof Boolean) return ! (Boolean) value;\n+\n+        // unknown type ...\n+        logger.info(\"Unknown type for value of \" + EMPTY_BODY_KEY + \" in message properties : \" + value);\n+        // assume true by default.\n+        return true;\n+    }\n+\n+\n+    protected final void populateBuilderWithHeaders(PubSubProtocol.Message.Builder builder) throws JMSException {\n+\n+        Map<String, Object> propertiesCopy = new HashMap<String, Object>(properties);\n+        if (isBodyEmpty()) {\n+            propertiesCopy.put(EMPTY_BODY_KEY, true);\n+            builder.setBody(ByteString.EMPTY);\n+        }\n+        // Not setting unless required to reduce message size - change this ?\n+        // else propertiesCopy.put(EMPTY_BODY_KEY, false);\n+\n+        Iterator<Map.Entry<String, Object>> iter = propertiesCopy.entrySet().iterator();\n+        while (iter.hasNext()){\n+            Map.Entry<String, Object> entry = iter.next();\n+            if (standardProperties.contains(entry.getKey())) {\n+                if (logger.isInfoEnabled())\n+                  logger.info(\"Ignoring user attempt to set standard property as application property : \" + entry);\n+                iter.remove();\n+            }\n+        }\n+\n+\n+        // set jms message type.\n+        propertiesCopy.put(JMS_MESSAGE_TYPE_KEY, getJmsMessageType().getType());\n+        if (standardPropertiesExistsForWire.contains(JMS_CORRELATION_ID))\n+          propertiesCopy.put(JMS_CORRELATION_ID, getJMSCorrelationID());\n+\n+        // unsupported for now.\n+        // if (standardPropertiesExistsForWire.contains(JMS_CORRELATION_ID_AS_BYTES))\n+        //    propertiesCopy.put(JMS_CORRELATION_ID_AS_BYTES, getJMSCorrelationIDAsBytes());\n+        if (standardPropertiesExistsForWire.contains(JMS_DELIVERY_MODE))\n+          propertiesCopy.put(JMS_DELIVERY_MODE, getJMSDeliveryMode());\n+\n+        if (standardPropertiesExistsForWire.contains(JMS_DESTINATION))\n+          propertiesCopy.put(JMS_DESTINATION, session.toName(getJMSDestination()));\n+        if (standardPropertiesExistsForWire.contains(JMS_EXPIRATION))\n+          propertiesCopy.put(JMS_EXPIRATION, getJMSExpiration());\n+\n+        // This can be set by client - but we ignore it in hedwig.\n+        // if (standardPropertiesExistsForWire.contains(JMS_MESSAGE_ID))\n+        //    propertiesCopy.put(JMS_MESSAGE_ID, getJMSMessageID());\n+\n+        // We do not support priority - but we are gong to allow it to be specified : this is\n+        // for selectors to set conditions on it !\n+        if (standardPropertiesExistsForWire.contains(JMS_PRIORITY))\n+          propertiesCopy.put(JMS_PRIORITY, getJMSPriority());\n+\n+        // this is not to be sent to hedwig.\n+        // if (standardPropertiesExistsForWire.contains(JMS_REDELIVERED))\n+        //    propertiesCopy.put(JMS_REDELIVERED, getJMSRedelivered());\n+\n+        if (standardPropertiesExistsForWire.contains(JMS_REPLY_TO))\n+          propertiesCopy.put(JMS_REPLY_TO, session.toName(getJMSReplyTo()));\n+\n+\n+        propertiesCopy.put(JMS_TIMESTAMP, getJMSTimestamp());\n+        if (standardPropertiesExistsForWire.contains(JMS_TYPE)) propertiesCopy.put(JMS_TYPE, getJMSType());\n+\n+\n+        MetadataProcessor.addHeaders(builder, propertiesCopy);\n+    }\n+\n+    @Override\n+    public String getJMSMessageID() {\n+        return jmsMessageId;\n+    }\n+\n+    @Override\n+    public void setJMSMessageID(String jmsMessageId) throws JMSException {\n+        // JMS VIOLATION ... we are NOT allowing client to override jms message-id.\n+        // if (!allowSpecifyJMSMessageIDForTest)\n+        //    throw new JMSException(\"We do not allow setting jms message id. This will be ignored by hedwig anyway.\");\n+        if (logger.isDebugEnabled()) logger.debug(\"Setting this is irrelevant - we override it anyway - \" +\n+            \" hedwig does not allow specifying it explictly.\");\n+        setJMSMessageIDInternal(jmsMessageId);\n+    }\n+\n+    public void setJMSMessageIDInternal(String jmsMessageId) throws JMSException {\n+        this.jmsMessageId = jmsMessageId;\n+        if (null != jmsMessageId){\n+            // We do not allow sending the property over wire.\n+            this.standardPropertiesExists.add(JMS_MESSAGE_ID);\n+            // this.standardPropertiesExistsForWire.add(JMS_MESSAGE_ID);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_MESSAGE_ID);\n+            // this.standardPropertiesExistsForWire.remove(JMS_MESSAGE_ID);\n+        }\n+    }\n+\n+    // The immutable message Id set by the server.\n+    public String getServerJmsMessageId() {\n+        return serverJmsMessageId;\n+    }\n+\n+    @Override\n+    public long getJMSTimestamp() {\n+        return jmsTimestamp;\n+    }\n+\n+    @Override\n+    public void setJMSTimestamp(long jmsTimestamp) {\n+        this.jmsTimestamp = jmsTimestamp;\n+        this.standardPropertiesExists.add(JMS_TIMESTAMP);\n+        // this.standardPropertiesExistsForWire.add(JMS_TIMESTAMP);\n+    }\n+\n+    @Override\n+    public byte[] getJMSCorrelationIDAsBytes() {\n+        throw new UnsupportedOperationException(\"unsupported\");\n+    }\n+\n+    @Override\n+    public void setJMSCorrelationIDAsBytes(byte[] bytes) {\n+        throw new UnsupportedOperationException(\"unsupported\");\n+    }\n+\n+    @Override\n+    public void setJMSCorrelationID(String jmsCorrelationID) {\n+        this.jmsCorrelationID = jmsCorrelationID;\n+        if (null != jmsCorrelationID){\n+            this.standardPropertiesExists.add(JMS_CORRELATION_ID);\n+            this.standardPropertiesExistsForWire.add(JMS_CORRELATION_ID);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_CORRELATION_ID);\n+            this.standardPropertiesExistsForWire.remove(JMS_CORRELATION_ID);\n+        }\n+    }\n+\n+    @Override\n+    public String getJMSCorrelationID() {\n+        return jmsCorrelationID;\n+    }\n+\n+    @Override\n+    public Destination getJMSReplyTo() {\n+        return jmsReplyTo;\n+    }\n+\n+    @Override\n+    public void setJMSReplyTo(Destination jmsReplyTo) {\n+        this.jmsReplyTo = jmsReplyTo;\n+        if (null != jmsReplyTo){\n+            this.standardPropertiesExists.add(JMS_REPLY_TO);\n+            this.standardPropertiesExistsForWire.add(JMS_REPLY_TO);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_REPLY_TO);\n+            this.standardPropertiesExistsForWire.remove(JMS_REPLY_TO);\n+        }\n+    }\n+\n+    @Override\n+    public Destination getJMSDestination() {\n+        return jmsDestination;\n+    }\n+\n+    @Override\n+    public void setJMSDestination(Destination jmsDestination) {\n+        this.jmsDestination = jmsDestination;\n+        if (null != jmsDestination){\n+            this.standardPropertiesExists.add(JMS_DESTINATION);\n+            this.standardPropertiesExistsForWire.add(JMS_DESTINATION);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_DESTINATION);\n+            this.standardPropertiesExistsForWire.remove(JMS_DESTINATION);\n+        }\n+    }\n+\n+    @Override\n+    public int getJMSDeliveryMode() {\n+        return jmsDeliveryMode;\n+    }\n+\n+    @Override\n+    public void setJMSDeliveryMode(int jmsDeliveryMode) {\n+        this.jmsDeliveryMode = jmsDeliveryMode;\n+        this.standardPropertiesExists.add(JMS_DELIVERY_MODE);\n+        this.standardPropertiesExistsForWire.add(JMS_DELIVERY_MODE);\n+    }\n+\n+    @Override\n+    public boolean getJMSRedelivered() {\n+        return jmsRedelivered;\n+    }\n+\n+    @Override\n+    public void setJMSRedelivered(boolean jmsRedelivered) {\n+        this.jmsRedelivered = jmsRedelivered;\n+        this.standardPropertiesExists.add(JMS_REDELIVERED);\n+        // this.standardPropertiesExistsForWire.add(JMS_REDELIVERED);\n+    }\n+\n+    @Override\n+    public String getJMSType() {\n+        return jmsType;\n+    }\n+\n+    @Override\n+    public void setJMSType(String jmsType) {\n+        this.jmsType = jmsType;\n+        if (null != jmsType){\n+            this.standardPropertiesExists.add(JMS_TYPE);\n+            this.standardPropertiesExistsForWire.add(JMS_TYPE);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_TYPE);\n+            this.standardPropertiesExistsForWire.remove(JMS_TYPE);\n+        }\n+    }\n+\n+    @Override\n+    public long getJMSExpiration() {\n+        return jmsExpiration;\n+    }\n+\n+    @Override\n+    public void setJMSExpiration(long jmsExpiration) {\n+        // We simulate it now !\n+        // if (logger.isInfoEnabled()) logger.info(\"JMSExpiration is not supported right now by Hedwig ...\");\n+        this.jmsExpiration = jmsExpiration;\n+\n+        if (0 != jmsExpiration){\n+            this.standardPropertiesExists.add(JMS_EXPIRATION);\n+            this.standardPropertiesExistsForWire.add(JMS_EXPIRATION);\n+        }\n+        else {\n+            this.standardPropertiesExists.remove(JMS_EXPIRATION);\n+            this.standardPropertiesExistsForWire.remove(JMS_EXPIRATION);\n+        }\n+    }\n+\n+    @Override\n+    public int getJMSPriority() {\n+        return jmsPriority;\n+    }\n+\n+    @Override\n+    public void setJMSPriority(int jmsPriority) {\n+        this.jmsPriority = jmsPriority;\n+        this.standardPropertiesExists.add(JMS_PRIORITY);\n+        // Sent over wire ?\n+        this.standardPropertiesExistsForWire.add(JMS_PRIORITY);\n+    }\n+\n+    @Override\n+    public void clearProperties() {\n+        this.propertiesReadOnly = false;\n+        properties.clear();\n+    }\n+\n+    /**\n+     * JMS VIOLATION ? The spec & javadoc is unclear as to whether this method must include jms\n+     * standard properties or not.\n+     * But going by javadoc of\n+     * @see #getPropertyNames() , we have this specified :\n+     * \"Note that JMS standard header fields are not considered properties and are not returned\n+     * in this enumeration.\"\n+     * Which indicates this method must not include standard properties.\n+     */\n+    @Override\n+    public boolean propertyExists(String key) {\n+        if (!standardProperties.contains(key)) return properties.containsKey(key);\n+\n+        // Evaluate depending on type of property.\n+        return standardPropertiesExists.contains(key);\n+    }\n+\n+    @Override\n+    public boolean getBooleanProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getBooleanProperty(properties, key);\n+    }\n+\n+    private boolean getBooleanProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asBoolean(properties.get(key));\n+    }\n+\n+    @Override\n+    public byte getByteProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getByteProperty(properties, key);\n+    }\n+\n+    private byte getByteProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asByte(properties.get(key));\n+    }\n+\n+    @Override\n+    public short getShortProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getShortProperty(properties, key);\n+    }\n+\n+    private short getShortProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asShort(properties.get(key));\n+    }\n+\n+    @Override\n+    public int getIntProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getIntProperty(properties, key);\n+    }\n+\n+    private int getIntProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asInteger(properties.get(key));\n+    }\n+\n+    @Override\n+    public long getLongProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getLongProperty(properties, key);\n+    }\n+\n+    private long getLongProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asLong(properties.get(key));\n+    }\n+\n+    @Override\n+    public float getFloatProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getFloatProperty(properties, key);\n+    }\n+\n+    private float getFloatProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asFloat(properties.get(key));\n+    }\n+\n+    @Override\n+    public double getDoubleProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getDoubleProperty(properties, key);\n+    }\n+\n+    private double getDoubleProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asDouble(properties.get(key));\n+    }\n+\n+    public Object getSelectorProcessingPropertyValue(String key) throws SelectorEvaluationException {\n+        if (properties.containsKey(key)) return properties.get(key);\n+        if (! standardProperties.contains(key)) return null;\n+\n+        if (JMS_MESSAGE_ID.equals(key)) return getJMSMessageID();\n+        if (JMS_TIMESTAMP.equals(key)) return getJMSTimestamp();\n+        if (JMS_CORRELATION_ID.equals(key)) return getJMSCorrelationID();\n+        // We do not support this right now.\n+        // if (JMS_CORRELATION_ID_AS_BYTES.equals(key)) return getJMSCorrelationIDAsBytes();\n+        if (JMS_REPLY_TO.equals(key)) return getJMSReplyTo();\n+        if (JMS_DESTINATION.equals(key)) return getJMSDestination();\n+        if (JMS_DELIVERY_MODE.equals(key)) {\n+            // 3.8.1.3 Special Notes \"When used in a message selector JMSDeliveryMode is treated as having the\n+            // values PERSISTENT and NON_PERSISTENT.\"\n+            final int deliveryMode = getJMSDeliveryMode();\n+            if (DeliveryMode.PERSISTENT == deliveryMode) return \"PERSISTENT\";\n+            if (DeliveryMode.NON_PERSISTENT == deliveryMode) return \"NON_PERSISTENT\";\n+            // unknown !\n+            if (logger.isInfoEnabled()) logger.info(\"Unknown delivery mode specified ... \" + deliveryMode);\n+            return null;\n+        }\n+        if (JMS_REDELIVERED.equals(key)) return getJMSRedelivered();\n+        if (JMS_TYPE.equals(key)) return getJMSType();\n+        if (JMS_EXPIRATION.equals(key)) return getJMSExpiration();\n+        if (JMS_PRIORITY.equals(key)) return getJMSPriority();\n+\n+        throw new SelectorEvaluationException(\"Unable to retrieve value for key : '\" + key + \"'\");\n+    }\n+\n+    @Override\n+    public String getStringProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        return getStringProperty(properties, key);\n+    }\n+\n+    private String getStringProperty(Map<String, Object> properties, String key) throws JMSException {\n+        return MessageUtil.asString(properties.get(key));\n+    }\n+\n+    @Override\n+    public Object getObjectProperty(String key) throws JMSException {\n+        checkIfStandardProperty(key);\n+        // if (!propertyExists(key)) return null;\n+\n+        return properties.get(key);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getPropertyNames() throws JMSException {\n+        return Collections.enumeration(properties.keySet());\n+    }\n+\n+    @Override\n+    public void setBooleanProperty(String key, boolean value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setByteProperty(String key, byte value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setShortProperty(String key, short value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setIntProperty(String key, int value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setLongProperty(String key, long value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setFloatProperty(String key, float value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setDoubleProperty(String key, double value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setStringProperty(String key, String value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+        properties.put(key, value);\n+    }\n+\n+    @Override\n+    public void setObjectProperty(String key, Object value) throws JMSException {\n+        if (!MessageUtil.isValidKey(key)) throw new IllegalArgumentException(\"Invalid key \" + key);\n+        if (propertiesReadOnly)\n+          throw new MessageNotWriteableException(\"Message not writable. attempt to set property \" +\n+              key + \" = \" + value);\n+        checkIfStandardProperty(key);\n+\n+        if (null == value ||\n+                value instanceof Boolean ||\n+                value instanceof Byte ||\n+                value instanceof Short ||\n+                value instanceof Integer ||\n+                value instanceof Long ||\n+                value instanceof Float ||\n+                value instanceof Double ||\n+                value instanceof byte[] ||\n+                value instanceof String) {\n+            properties.put(key, value);\n+            return ;        }\n+\n+        throw new MessageFormatException(\"Unsupported type for value \" + value.getClass());\n+    }\n+\n+    // JMS VIOLATION ?\n+    // I am not sure if getting and setting standard properties is allowed via the generic\n+    // get/set methods : the spec seems unclear on it.\n+    // Some javadocs seem to indicate it is NOT allowed. Hence this check ...\n+    // If it is allowed in JMS - to support it, we will need to have a if/else block within each set/get\n+    // which delegates to corresponding jms header set/get ...\n+    private void checkIfStandardProperty(String key) throws JMSException {\n+        if (standardProperties.contains(key))\n+          throw new JMSException(\"Cannot get/set standard JMS properties using *Property api\");\n+    }\n+\n+    @Override\n+    public void acknowledge() throws JMSException {\n+        session.acknowledge(this);\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        // Clear the body of the message.\n+    }\n+\n+    public String getSourceName() {\n+        return sourceName;\n+    }\n+\n+    public String getSubscriberId() {\n+        return subscriberId;\n+    }\n+\n+    MessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n+        if (MessageImpl.class != getClass()) {\n+            throw new JMSException(\"Unexpected to call MessageImpl's createClone from subclass \" + getClass());\n+        }\n+        return new MessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"MessageImpl\");\n+        sb.append(\"{session=\").append(session);\n+        sb.append(\", jmsMessageId='\").append(jmsMessageId).append('\\'');\n+        sb.append(\", jmsTimestamp=\").append(jmsTimestamp);\n+        sb.append(\", jmsCorrelationID='\").append(jmsCorrelationID).append('\\'');\n+        sb.append(\", jmsReplyTo=\").append(jmsReplyTo);\n+        sb.append(\", jmsDestination=\").append(jmsDestination);\n+        sb.append(\", jmsDeliveryMode=\").append(jmsDeliveryMode);\n+        sb.append(\", jmsRedelivered=\").append(jmsRedelivered);\n+        sb.append(\", jmsType='\").append(jmsType).append('\\'');\n+        sb.append(\", jmsExpiration=\").append(jmsExpiration);\n+        sb.append(\", jmsPriority=\").append(jmsPriority);\n+        sb.append(\", properties=\").append(properties);\n+        sb.append(\", standardPropertiesExists=\").append(standardPropertiesExists);\n+        sb.append(\", standardPropertiesExistsForWire=\").append(standardPropertiesExistsForWire);\n+        sb.append(\", sourceName='\").append(sourceName).append('\\'');\n+        sb.append(\", subscriberId='\").append(subscriberId).append('\\'');\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+\n+    void reset() throws JMSException {\n+        // noop ... children will override to do needful.\n+    }\n+\n+    public Runnable getAckRunnable() {\n+        return ackRunnable;\n+    }\n+}"},{"sha":"15b75ee737bbf6d50a6d7fa033186af70d718952","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","status":"added","additions":444,"deletions":0,"changes":444,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/MessageUtil.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,444 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.message.header.MetadataProcessor;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.JMSException;\n+import javax.jms.MapMessage;\n+import javax.jms.Message;\n+import javax.jms.MessageFormatException;\n+import javax.jms.ObjectMessage;\n+import javax.jms.StreamMessage;\n+import javax.jms.TextMessage;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bunch of simple util methods to reduce code in the implementation.\n+ */\n+public class MessageUtil {\n+\n+    // The various message types supported.\n+    public enum SupportedMessageTypes {\n+      ONLY_MESSAGE((byte) 0),\n+      TEXT((byte) 1),\n+      BYTES((byte) 2),\n+      MAP((byte) 3),\n+      STREAM((byte) 4),\n+      OBJECT((byte) 5);\n+\n+      private final byte type;\n+      private SupportedMessageTypes(byte type){\n+        this.type = type;\n+      }\n+\n+      public byte getType() {\n+        return type;\n+      }\n+    }\n+\n+    private static final Map<Byte, SupportedMessageTypes> valueToSupportedMessageType;\n+    static {\n+        SupportedMessageTypes[] arr = SupportedMessageTypes.values();\n+        Map<Byte, SupportedMessageTypes> map = new HashMap<Byte, SupportedMessageTypes>(arr.length);\n+        for (SupportedMessageTypes type : arr){\n+            map.put(type.getType(), type);\n+        }\n+        valueToSupportedMessageType = Collections.unmodifiableMap(map);\n+    }\n+\n+    public static boolean asBoolean(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return false;\n+        if (null == value) return Boolean.valueOf((String) value);\n+\n+        if (value instanceof Boolean) return (Boolean) value;\n+        if (value instanceof String) return Boolean.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static byte asByte(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0;\n+        if (null == value) return Byte.valueOf((String) value);\n+\n+        if (value instanceof Byte) return (Byte) value;\n+        if (value instanceof String) return Byte.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static short asShort(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0;\n+        if (null == value) return Short.valueOf((String) value);\n+\n+        if (value instanceof Byte) return (Byte) value;\n+        if (value instanceof Short) return (Short) value;\n+        if (value instanceof String) return Short.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static int asInteger(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0;\n+        if (null == value) return Integer.valueOf((String) value);\n+\n+        if (value instanceof Byte) return (Byte) value;\n+        if (value instanceof Short) return (Short) value;\n+        if (value instanceof Integer) return (Integer) value;\n+        if (value instanceof String) return Integer.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static long asLong(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0;\n+        if (null == value) return Long.valueOf((String) value);\n+\n+        if (value instanceof Byte) return (Byte) value;\n+        if (value instanceof Short) return (Short) value;\n+        if (value instanceof Integer) return (Integer) value;\n+        if (value instanceof Long) return (Long) value;\n+        if (value instanceof String) return Long.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static float asFloat(Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0.0f;\n+        if (null == value) return Float.valueOf((String) value);\n+\n+        if (value instanceof Float) return (Float) value;\n+        if (value instanceof String) return Float.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static double asDouble (Object value) throws MessageFormatException {\n+        // The JMS spec explicitly wants us to raise NPE !\n+        // if (null == value) return 0.0;\n+        if (null == value) return Double.valueOf((String) value);\n+\n+        if (value instanceof Float) return (Float) value;\n+        if (value instanceof Double ) return (Double) value;\n+        if (value instanceof String) return Double.valueOf((String) value);\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static Double asDoubleSelectorProcessing(Object value) throws MessageFormatException {\n+        if (null == value) return null;\n+\n+        if (value instanceof Float) return (double) (Float) value;\n+        if (value instanceof Double ) return (Double) value;\n+\n+        if (value instanceof Long) return (double) (Long) value;\n+        if (value instanceof Integer) return (double) (Integer) value;\n+        if (value instanceof Short) return (double) (Short) value;\n+        if (value instanceof Byte) return (double) (Byte) value;\n+\n+        return null;\n+    }\n+\n+    public static Integer asIntegerSelectorProcessing(Object value) throws MessageFormatException {\n+        if (null == value) return null;\n+\n+        if (value instanceof Float) return (int) (float) (Float) value;\n+        if (value instanceof Double ) return (int) (double) (Double) value;\n+\n+        if (value instanceof Long) return (int) (long) (Long) value;\n+        if (value instanceof Integer) return (Integer) value;\n+        if (value instanceof Short) return (int) (Short) value;\n+        if (value instanceof Byte) return (int) (Byte) value;\n+\n+        return null;\n+    }\n+\n+    public static String asString(Object value) {\n+        if (null == value) return null;\n+\n+        if (value instanceof String) return (String) value;\n+        // converts from boolean, byte, short, char, int, long, float and double to String.\n+        return \"\" + value;\n+    }\n+\n+    public static char asChar(Object value) throws MessageFormatException {\n+        // treat it as integer with null\n+        if (null == value) return (char) 0;\n+\n+        // only from/to char\n+        if (value instanceof Character) return (Character) value;\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static byte[] asBytes(Object value) throws MessageFormatException {\n+        if (null == value || value instanceof byte[]) return (byte[]) value;\n+        throw new MessageFormatException(\"Unsupported property type \" + value.getClass() + \" for \" + value);\n+    }\n+\n+    public static boolean isValidKey(String key) {\n+        return null != key && 0 != key.length();\n+    }\n+\n+    public static byte[] objectToBytes(Object obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        try {\n+            oos.writeObject(obj);\n+            oos.flush();\n+        } finally {\n+            try { oos.close(); } catch (IOException ioEx) { /* ignore */ }\n+        }\n+\n+        return baos.toByteArray();\n+    }\n+\n+    public static Object bytesToObject(byte[] data) throws IOException {\n+        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));\n+        try {\n+            return ois.readObject();\n+        } catch (ClassNotFoundException  cnfEx){\n+            // unexpected !\n+            throw new IllegalStateException(\"Unexpected\", cnfEx);\n+        } finally {\n+            try { ois.close(); } catch(IOException ioEx) { /* ignore */ }\n+        }\n+    }\n+\n+\n+\n+    public static MessageImpl processHedwigMessage(SessionImpl session, PubSubProtocol.Message message,\n+                                                   String sourceTopicName, String subscriberId,\n+                                                   Runnable ackRunnable) throws JMSException {\n+        Map<String, Object> map = MetadataProcessor.parseHeaders(message);\n+\n+        Object jmsBodyTypeValue = map.get(MessageImpl.JMS_MESSAGE_TYPE_KEY);\n+        // Should we treat these as bytes message by default ?\n+        // if (! (jmsBodyTypeValue instanceof Byte) )\n+        //    throw new JMSException(\"Unsupported message : \" + message + \", unable to determine jms message type \" +\n+        //      jmsBodyTypeValue);\n+        if (! (jmsBodyTypeValue instanceof Byte) ) jmsBodyTypeValue = (Byte) SupportedMessageTypes.BYTES.getType();\n+\n+        SupportedMessageTypes type = valueToSupportedMessageType.get((Byte) jmsBodyTypeValue);\n+        switch (type){\n+            case STREAM:\n+                return new StreamMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            case MAP:\n+                return new MapMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            case TEXT:\n+                return new TextMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            case OBJECT:\n+                return new ObjectMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            case BYTES:\n+                return new BytesMessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            case ONLY_MESSAGE:\n+                return new MessageImpl(session, message, map, sourceTopicName, subscriberId, ackRunnable);\n+            default:\n+                throw new JMSException(\"Unsupported message type : \" + type + \" for message \" + message);\n+        }\n+    }\n+\n+    public static MessageImpl createMessageCopy(SessionImpl session, Message message) throws JMSException {\n+        if (message instanceof MessageImpl) {\n+            return createMessageImplCopy(session, (MessageImpl) message);\n+        }\n+\n+        if (message instanceof BytesMessage) {\n+            return new BytesMessageImpl((BytesMessage) message, session);\n+        }\n+        if (message instanceof MapMessage) {\n+            return new MapMessageImpl((MapMessage) message, session);\n+        }\n+        if (message instanceof ObjectMessage) {\n+            return new ObjectMessageImpl((ObjectMessage) message, session);\n+        }\n+        if (message instanceof StreamMessage) {\n+            return new StreamMessageImpl((StreamMessage) message, session);\n+        }\n+        if (message instanceof TextMessage) {\n+            return new TextMessageImpl((TextMessage) message, session);\n+        }\n+\n+        return new MessageImpl(message, session);\n+    }\n+\n+    private static MessageImpl createMessageImplCopy(SessionImpl session, MessageImpl message)\n+        throws JMSException {\n+\n+        if (message instanceof BytesMessageImpl) {\n+            return new BytesMessageImpl(session, (BytesMessageImpl) message, message.getSourceName(),\n+                message.getSubscriberId());\n+        }\n+        if (message instanceof MapMessageImpl) {\n+            return new MapMessageImpl(session, (MapMessageImpl) message, message.getSourceName(),\n+                message.getSubscriberId());\n+        }\n+        if (message instanceof ObjectMessageImpl) {\n+            return new ObjectMessageImpl(session, (ObjectMessageImpl) message, message.getSourceName(),\n+                message.getSubscriberId());\n+        }\n+        if (message instanceof StreamMessageImpl) {\n+            return new StreamMessageImpl(session, (StreamMessageImpl) message, message.getSourceName(),\n+                message.getSubscriberId());\n+        }\n+        if (message instanceof TextMessageImpl) {\n+            return new TextMessageImpl(session, (TextMessageImpl) message, message.getSourceName(),\n+                message.getSubscriberId());\n+        }\n+\n+        return new MessageImpl(session, message, message.getSourceName(), message.getSubscriberId());\n+    }\n+\n+    private static final String JMS_MESSAGE_ID_PREFIX = \"ID:\";\n+    private static final String LOCAL_PREFIX = \"LOCAL(\";\n+    private static final String REMOTE_PREFIX = \"REMOTE(\";\n+    private static final char SEQ_ID_SUFFIX = ')';\n+    private static final char REMOTE_RECORD_SEPARATOR = ',';\n+    private static final char REMOTE_RECORD_SEQ_ID_PREFIX = '[';\n+    private static final char REMOTE_RECORD_SEQ_ID_SUFFIX = ']';\n+    private static final Pattern remoteMessageIdSplitPattern = Pattern.compile(\"\" + REMOTE_RECORD_SEPARATOR);\n+\n+    /**\n+     * Based on\n+     * {@link org.apache.hedwig.admin.console.ReadTopic#formatMessage(PubSubProtocol.Message)}\n+     *\n+     * This is tightly coupled with\n+     * @see #generateSeqIdFromJMSMessageId(String)\n+     *\n+     * @param seqId The sequence id to convert to string.\n+     * @return The string representation of the seq-id.\n+     */\n+    public static String generateJMSMessageIdFromSeqId(final PubSubProtocol.MessageSeqId seqId) {\n+        StringBuilder sb = new StringBuilder();\n+        // mandatory prefix for system generated id's.\n+        sb.append(JMS_MESSAGE_ID_PREFIX);\n+\n+        if (seqId.hasLocalComponent()) {\n+            sb.append(LOCAL_PREFIX).append(seqId.getLocalComponent()).append(SEQ_ID_SUFFIX);\n+        } else {\n+            List<PubSubProtocol.RegionSpecificSeqId> remoteIds = seqId.getRemoteComponentsList();\n+            boolean first = true;\n+\n+            sb.append(REMOTE_PREFIX);\n+            for (PubSubProtocol.RegionSpecificSeqId rssid : remoteIds) {\n+                if (!first) sb.append(REMOTE_RECORD_SEPARATOR);\n+                first = false;\n+                sb.append(rssid.getRegion().toStringUtf8());\n+                sb.append(REMOTE_RECORD_SEQ_ID_PREFIX);\n+                sb.append(rssid.getSeqId());\n+                sb.append(REMOTE_RECORD_SEQ_ID_SUFFIX);\n+            }\n+            sb.append(SEQ_ID_SUFFIX);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Based on\n+     * {@link org.apache.hedwig.admin.console.ReadTopic#formatMessage(PubSubProtocol.Message)}\n+     *\n+     * This is tightly coupled with\n+     * @see #generateJMSMessageIdFromSeqId(org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId)\n+     * @param messageId The message id to convert to string.\n+     * @return The seq-id\n+     * @throws javax.jms.JMSException In case of exceptions doing the conversion.\n+     */\n+    public static PubSubProtocol.MessageSeqId generateSeqIdFromJMSMessageId(final String messageId)\n+        throws JMSException {\n+        if (null == messageId || !messageId.startsWith(JMS_MESSAGE_ID_PREFIX)) {\n+            throw new JMSException(\"Invalid messageId specified '\" + messageId + \"'\");\n+        }\n+\n+        PubSubProtocol.MessageSeqId.Builder builder = PubSubProtocol.MessageSeqId.newBuilder();\n+        // local ?\n+        if (messageId.regionMatches(JMS_MESSAGE_ID_PREFIX.length(), LOCAL_PREFIX, 0, LOCAL_PREFIX.length())){\n+            try {\n+                long seqId = Long.parseLong(messageId.substring(JMS_MESSAGE_ID_PREFIX.length() +\n+                    LOCAL_PREFIX.length(), messageId.length() - 1));\n+                builder.setLocalComponent(seqId);\n+            } catch (NumberFormatException nfEx){\n+                JMSException jEx = new JMSException(\"Unable to parse local seq id from '\" +\n+                    messageId + \"' .. \" + nfEx);\n+                jEx.setLinkedException(nfEx);\n+                throw jEx;\n+            }\n+        }\n+        else {\n+            assert messageId.regionMatches(JMS_MESSAGE_ID_PREFIX.length(), REMOTE_PREFIX, 0,\n+                REMOTE_PREFIX.length());\n+\n+            final String[] remoteParts;\n+            {\n+                final String remoteMessageId = messageId.substring(JMS_MESSAGE_ID_PREFIX.length() +\n+                    REMOTE_PREFIX.length(), messageId.length() - 1);\n+                // Should ew stop using pattern and move to using indexOf's ?\n+                remoteParts = remoteMessageIdSplitPattern.split(remoteMessageId);\n+            }\n+\n+            for (String remote : remoteParts){\n+                if (REMOTE_RECORD_SEQ_ID_SUFFIX != remote.charAt(remote.length() - 1))\n+                  throw new JMSException(\"Invalid remote region snippet (no seq suffix) '\" +\n+                      remote + \"' within '\" + messageId);\n+                final int regionIndx = remote.indexOf(REMOTE_RECORD_SEQ_ID_PREFIX);\n+                if (-1 == regionIndx)\n+                  throw new JMSException(\"Invalid remote region snippet (no region) '\" + remote +\n+                      \"' within '\" + messageId);\n+                final String region = remote.substring(0, regionIndx);\n+                final long seqId;\n+\n+\n+                try {\n+                    seqId = Long.parseLong(remote.substring(regionIndx + 1, remote.length() - 1));\n+                } catch (NumberFormatException nfEx){\n+                    JMSException jEx = new JMSException(\"Unable to parse remote seq id from '\" +\n+                        remote + \"' within '\" + messageId + \"' .. \" + nfEx);\n+                    jEx.setLinkedException(nfEx);\n+                    throw jEx;\n+                }\n+\n+                PubSubProtocol.RegionSpecificSeqId.Builder rbuilder =\n+                    PubSubProtocol.RegionSpecificSeqId.newBuilder();\n+                rbuilder.setRegion(ByteString.copyFromUtf8(region));\n+                rbuilder.setSeqId(seqId);\n+                builder.addRemoteComponents(rbuilder);\n+            }\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    public static MessageImpl createCloneForDispatch(SessionImpl session, MessageImpl msg,\n+                                                     String sourceTopicName, String subscriberId) throws JMSException {\n+        MessageImpl retval = msg.createClone(session, sourceTopicName, subscriberId);\n+        retval.reset();\n+        return retval;\n+    }\n+}"},{"sha":"ba26c4c1b55a1b6e6a441ef4bc33a6841f520d1a","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/ObjectMessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageNotWriteableException;\n+import javax.jms.ObjectMessage;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * read/write serializable java object ...\n+ *\n+ */\n+public class ObjectMessageImpl extends MessageImpl implements ObjectMessage {\n+    private Serializable payload;\n+    private boolean readMode;\n+\n+    public ObjectMessageImpl(SessionImpl session, Serializable payload) {\n+        super(session);\n+        this.payload = payload;\n+        this.readMode = false;\n+    }\n+\n+    public ObjectMessageImpl(SessionImpl session, ObjectMessageImpl message, String sourceTopicName,\n+                             String subscriberId) throws JMSException {\n+        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n+\n+        this.payload = copySerializable(message.getObject());\n+        this.readMode = message.readMode;\n+    }\n+\n+    private Serializable copySerializable(Serializable object) throws JMSException {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            oos.writeObject(object);\n+            oos.flush();\n+            oos.close();\n+            baos.flush();\n+            baos.close();\n+\n+            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n+            return (Serializable) ois.readObject();\n+        } catch (IOException e){\n+            JMSException jmsEx = new javax.jms.IllegalStateException(\"Unexpected exception\");\n+            jmsEx.setLinkedException(e);\n+            throw jmsEx;\n+        } catch (ClassNotFoundException e) {\n+            JMSException jmsEx = new javax.jms.IllegalStateException(\"Unexpected exception\");\n+            jmsEx.setLinkedException(e);\n+            throw jmsEx;\n+        }\n+    }\n+\n+    // To clone a message from a ObjectMessage which is NOT ObjectMessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    public ObjectMessageImpl(ObjectMessage message, SessionImpl session) throws JMSException {\n+        super((Message) message, session);\n+\n+        if (message instanceof ObjectMessageImpl) {\n+            throw new JMSException(\"Coding bug - should use this constructor ONLY for non ObjectMessageImpl messages\");\n+        }\n+\n+\n+        this.payload = message.getObject();\n+        this.readMode = false;\n+    }\n+\n+    public ObjectMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n+                             String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n+        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n+\n+        try {\n+            this.payload = hasBodyFromProperties() ?\n+                (Serializable) MessageUtil.bytesToObject(message.getBody().toByteArray()) : null;\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n+        return MessageUtil.SupportedMessageTypes.OBJECT;\n+    }\n+\n+    @Override\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        super.populateBuilderWithHeaders(builder);\n+\n+        // Now set body and type.\n+        try {\n+            if (! isBodyEmpty()) builder.setBody(ByteString.copyFrom(MessageUtil.objectToBytes(this.payload)));\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return null == this.payload;\n+    }\n+\n+    @Override\n+    public void setObject(Serializable payload) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        this.payload = payload;\n+    }\n+\n+    @Override\n+    public Serializable getObject() throws JMSException {\n+        return payload;\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        super.clearBody();\n+        // allow read and write.\n+        this.payload = null;\n+        this.readMode = false;\n+    }\n+\n+    @Override\n+    public void reset() throws JMSException {\n+        if (this.readMode) return ;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    ObjectMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n+        throws JMSException {\n+\n+        return new ObjectMessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+}"},{"sha":"2aa74a2e690aabe2300d5a9e34d85b06d1bb0e71","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","status":"added","additions":752,"deletions":0,"changes":752,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/StreamMessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,752 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.Mutable;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.IllegalStateException;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageEOFException;\n+import javax.jms.MessageNotReadableException;\n+import javax.jms.MessageNotWriteableException;\n+import javax.jms.StreamMessage;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.Map;\n+\n+/**\n+ * Though similar to BytesMessageImpl, the difference is that BytesMessage expects the user to know\n+ * the schema while\n+ * StreamMessage user expects type conversion, etc.\n+ *\n+ * In our case, the stream is not a true open stream to the server; it is buffered in memory.\n+ */\n+public class StreamMessageImpl extends MessageImpl implements StreamMessage {\n+    private ReadOnlyMessage readOnlyMessage;\n+    private WriteOnlyMessage writeOnlyMessage;\n+    private boolean readMode;\n+\n+    public StreamMessageImpl(SessionImpl session) throws JMSException {\n+        super(session);\n+        clearBody();\n+    }\n+\n+    // To clone a message\n+    public StreamMessageImpl(SessionImpl session, StreamMessageImpl message, String sourceTopicName,\n+                             String subscriberId) throws JMSException {\n+        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n+        try {\n+            if (message.readMode){\n+                this.readOnlyMessage = new ReadOnlyMessage(message.getPayloadData());\n+                this.writeOnlyMessage = null;\n+            }\n+            else {\n+                this.readOnlyMessage = null;\n+                this.writeOnlyMessage = new WriteOnlyMessage(message.getPayloadData());\n+            }\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        this.readMode = message.readMode;\n+    }\n+\n+    // To clone a message from a StreamMessage which is NOT StreamMessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    public StreamMessageImpl(StreamMessage message, SessionImpl session) throws JMSException {\n+        super((Message) message, session);\n+\n+        if (message instanceof StreamMessageImpl) {\n+            throw new JMSException(\"Coding bug - should use this constructor ONLY for non StreamMessageImpl messages\");\n+        }\n+\n+        final byte[] data;\n+        try {\n+            WriteOnlyMessage wom = new WriteOnlyMessage();\n+            try {\n+                Object obj;\n+                while (null != (obj = message.readObject())){\n+                    wom.writeObject(obj);\n+                }\n+            } catch (EOFException eof){\n+                // ignore ...\n+            }\n+            data = wom.getPayloadAsBytes(null);\n+        } catch (IOException e) {\n+            JMSException jEx = new JMSException(\"Unable to write to internal message .. \" + e);\n+            jEx.setLinkedException(e);\n+            throw jEx;\n+        }\n+\n+        this.writeOnlyMessage = new WriteOnlyMessage(data);\n+\n+        this.readOnlyMessage  = null;\n+        this.readMode = false;\n+    }\n+\n+    StreamMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n+                      String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n+        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n+\n+        final byte[] data = message.getBody().toByteArray();\n+        try {\n+            this.readOnlyMessage = new ReadOnlyMessage(data);\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to clone/copy input message \" + message + \" .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        this.writeOnlyMessage = null;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n+        return MessageUtil.SupportedMessageTypes.STREAM;\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return false;\n+    }\n+\n+    @Override\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        super.populateBuilderWithHeaders(builder);\n+\n+        // Now set body and type.\n+        try {\n+            byte[] data = getPayloadData();\n+            builder.setBody(ByteString.copyFrom(data));\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"Unable to read message data .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+\n+        return builder.build();\n+    }\n+\n+\n+    @Override\n+    public boolean readBoolean() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readBoolean();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public byte readByte() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readByte();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public short readShort() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readShort();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public char readChar() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readChar();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readInt() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readInt();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public long readLong() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readLong();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public float readFloat() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readFloat();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public double readDouble() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readDouble();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public String readString() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readString();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public int readBytes(byte[] data) throws JMSException {\n+        throw new UnsupportedOperationException(\"Please use readObject - this method is not supported\");\n+    }\n+\n+    @Override\n+    public Object readObject() throws JMSException {\n+        if (!readMode) throw new MessageNotReadableException(\"Message not readable\");\n+        try {\n+            return readOnlyMessage.readObject();\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"ioEx ?\");\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBoolean(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeByte(byte val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeByte(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeShort(short val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeShort(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeChar(char val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeChar(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeInt(int val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeInt(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeLong(long val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeLong(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeFloat(float val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeFloat(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeDouble(double val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeDouble(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(String val) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeString(val);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] data) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBytes(data);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] data, int offset, int length) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeBytes(data, offset, length);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    // This method is ONLY supposed to be used for object form of primitive types !\n+    @Override\n+    public void writeObject(Object obj) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        try {\n+            writeOnlyMessage.writeObject(obj);\n+        } catch (IOException ioEx){\n+            JMSException eofEx = new JMSException(\"Unexpected ioex : \" + ioEx);\n+            eofEx.setLinkedException(ioEx);\n+            throw eofEx;\n+        }\n+    }\n+\n+    @Override\n+    public void reset() throws JMSException {\n+        if (this.readMode) return ;\n+        this.readMode = true;\n+        try {\n+            byte[] data = writeOnlyMessage.getPayloadAsBytes(null);\n+            this.readOnlyMessage = new ReadOnlyMessage(data);\n+        } catch (IOException e) {\n+            JMSException ex = new JMSException(\"cant convert to read only message ... unexpected actually .. \" + e);\n+            ex.setLinkedException(e);\n+            throw ex;\n+        }\n+        this.writeOnlyMessage = null;\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        super.clearBody();\n+        this.writeOnlyMessage = new WriteOnlyMessage();\n+        this.readOnlyMessage = null;\n+        this.readMode = false;\n+    }\n+\n+    private byte[] getPayloadData() throws IOException, IllegalStateException {\n+        if (readMode) return readOnlyMessage.getDataCopy();\n+\n+        Mutable<byte[]> preCloseData = new Mutable<byte[]>(null);\n+        byte[] data = writeOnlyMessage.getPayloadAsBytes(preCloseData);\n+\n+        writeOnlyMessage = new WriteOnlyMessage(preCloseData.getValue());\n+        return data;\n+    }\n+\n+\n+    @Override\n+    StreamMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId)\n+        throws JMSException {\n+        return new StreamMessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+\n+    // Using java object's instead of primitives to avoid having to store schema separately.\n+    private static class ReadOnlyMessage {\n+\n+        private final ObjectInputStream ois;\n+        private final byte[] data;\n+        private final Deque<Object> unreadObjects = new ArrayDeque<Object>(4);\n+\n+        public ReadOnlyMessage(byte[] data) throws IOException {\n+            this.data = data;\n+            this.ois = new ObjectInputStream(new ByteArrayInputStream(data));\n+        }\n+\n+        public byte[] getDataCopy(){\n+            return Arrays.copyOf(data, data.length);\n+        }\n+\n+        private void unreadObject(Object obj) {\n+            unreadObjects.push(obj);\n+        }\n+\n+        private Object readNextObject() throws IOException, JMSException {\n+            try {\n+                if (! unreadObjects.isEmpty()) return unreadObjects.pop();\n+\n+                return ois.readObject();\n+            } catch (ClassNotFoundException e) {\n+                // unexpected !\n+                javax.jms.IllegalStateException jEx =\n+                    new javax.jms.IllegalStateException(\"Unexpected not to be able to resolve class\");\n+                jEx.setLinkedException(e);\n+                throw jEx;\n+            } catch (EOFException eof) {\n+                throw new MessageEOFException(\"eof\");\n+            }\n+        }\n+\n+        public boolean readBoolean() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Boolean value = MessageUtil.asBoolean(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public byte readByte() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Byte value = MessageUtil.asByte(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public short readShort() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Short value = MessageUtil.asShort(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public char readChar() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Character value = MessageUtil.asChar(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public int readInt() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Integer value = MessageUtil.asInteger(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public long readLong() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Long value = MessageUtil.asLong(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public float readFloat() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Float value = MessageUtil.asFloat(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public double readDouble() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                Double value = MessageUtil.asDouble(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public String readString() throws IOException, JMSException {\n+            Object obj = readNextObject();\n+            boolean failed = true;\n+            try {\n+                String value = MessageUtil.asString(obj);\n+                failed = false;\n+                return value;\n+            } finally {\n+                if (failed) unreadObject(obj);\n+            }\n+        }\n+\n+        public Object readObject() throws IOException, JMSException {\n+            return readNextObject();\n+        }\n+    }\n+\n+    private static class WriteOnlyMessage {\n+\n+        private final ByteArrayOutputStream baos;\n+        // private ObjectOutputStream oos;\n+        private final ObjectOutputStream oos;\n+\n+        public WriteOnlyMessage() throws JMSException {\n+            baos = new ByteArrayOutputStream();\n+            try {\n+                oos = new ObjectOutputStream(baos);\n+            } catch (IOException e) {\n+                IllegalStateException jEx =\n+                    new IllegalStateException(\"Unexpected to not be able to create empty write only message\");\n+                jEx.setLinkedException(e);\n+                throw jEx;\n+            }\n+        }\n+\n+        private WriteOnlyMessage(final byte[] data) throws IllegalStateException {\n+            baos = new ByteArrayOutputStream();\n+            try {\n+                if (null != data) baos.write(data);\n+                baos.flush();\n+                oos = new ObjectOutputStream(baos){\n+                    // Do not write the header if data is based on already materialized stream.\n+                    protected void writeStreamHeader() throws IOException {\n+                        if (null == data || 0 == data.length) super.writeStreamHeader();\n+                    }\n+                };\n+            } catch (IOException e) {\n+                IllegalStateException jEx =\n+                    new IllegalStateException(\"Unexpected to not be able to create empty write only message\");\n+                jEx.setLinkedException(e);\n+                throw jEx;\n+            }\n+        }\n+\n+        public byte[] getPayloadAsBytes(Mutable<byte[]> preCloseData) throws IOException {\n+            oos.flush();\n+            baos.flush();\n+            if (null != preCloseData) preCloseData.setValue(baos.toByteArray());\n+            oos.close();\n+            baos.flush();\n+            baos.close();\n+            // oos = null;\n+            return baos.toByteArray();\n+        }\n+\n+        public void writeBoolean(boolean val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeByte(byte val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeShort(short val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeChar(char val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeInt(int val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeLong(long val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeFloat(float val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeDouble(double val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeString(String val) throws IOException {\n+            oos.writeObject(val);\n+        }\n+\n+        public void writeBytes(byte[] data) throws IOException {\n+            oos.writeObject(data);\n+        }\n+\n+        // copy and write as a single byte array.\n+        public void writeBytes(byte[] data, int offset, int length) throws IOException {\n+            byte[] arr = new byte[length];\n+            System.arraycopy(data, offset, arr, 0, length);\n+            writeBytes(arr);\n+        }\n+\n+        public void writeObject(Object obj) throws JMSException, IOException {\n+            // unrolling it\n+            if (obj instanceof Boolean) {\n+                writeBoolean((Boolean) obj);\n+            }\n+            else if (obj instanceof Byte) {\n+                writeByte((Byte) obj);\n+            }\n+            else if (obj instanceof Short) {\n+                writeShort((Short) obj);\n+            }\n+            else if (obj instanceof Character) {\n+                writeChar((Character) obj);\n+            }\n+            else if (obj instanceof Integer) {\n+                writeInt((Integer) obj);\n+            }\n+            else if (obj instanceof Long) {\n+                writeLong((Long) obj);\n+            }\n+            else if (obj instanceof Float) {\n+                writeFloat((Float) obj);\n+            }\n+            else if (obj instanceof Double) {\n+                writeDouble((Double) obj);\n+            }\n+            else if (obj instanceof String) {\n+                writeString((String) obj);\n+            }\n+            else if (obj instanceof byte[]) {\n+                writeBytes((byte[]) obj);\n+            }\n+            else{\n+                throw new JMSException(\"Unsupported type for obj : \" + obj.getClass());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"dc3a3ca4e8298471e06fc307d37a3cdc40da70b3","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/TextMessageImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.message;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageNotWriteableException;\n+import javax.jms.TextMessage;\n+import java.util.Map;\n+\n+/**\n+ * read/write text message ...\n+ */\n+public class TextMessageImpl extends MessageImpl implements TextMessage {\n+    private String payload;\n+    private boolean readMode;\n+\n+    public TextMessageImpl(SessionImpl session) {\n+        super(session);\n+        this.readMode = false;\n+    }\n+\n+    public TextMessageImpl(SessionImpl session, String payload) {\n+        super(session);\n+        this.payload = payload;\n+        this.readMode = false;\n+    }\n+\n+    public TextMessageImpl(SessionImpl session, TextMessageImpl message, String sourceTopicName,\n+                           String subscriberId) throws JMSException {\n+        super(session, (MessageImpl) message, sourceTopicName, subscriberId);\n+\n+        this.payload = message.getText();\n+        this.readMode = message.readMode;\n+    }\n+\n+\n+    // To clone a message from a TextMessage which is NOT TextMessageImpl\n+    // Changing order of parameter to NOT accidentally clash with the constructor above.\n+    // This is midly confusing, but helps a lot in preventing accidental bugs !\n+    public TextMessageImpl(TextMessage message, SessionImpl session) throws JMSException {\n+        super((Message) message, session);\n+\n+        if (message instanceof TextMessageImpl) {\n+            throw new JMSException(\"Coding bug - should use this constructor ONLY for non TextMessageImpl messages\");\n+        }\n+\n+        this.payload = message.getText();\n+        this.readMode = false;\n+    }\n+\n+    public TextMessageImpl(SessionImpl session, PubSubProtocol.Message message, Map<String, Object> properties,\n+                           String sourceTopicName, String subscriberId, Runnable ackRunnable) throws JMSException {\n+        super(session, message, properties, sourceTopicName, subscriberId, ackRunnable);\n+\n+        this.payload = hasBodyFromProperties() ? message.getBody().toStringUtf8() : null;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    protected MessageUtil.SupportedMessageTypes getJmsMessageType() {\n+        return MessageUtil.SupportedMessageTypes.TEXT;\n+    }\n+\n+    @Override\n+    public PubSubProtocol.Message generateHedwigMessage() throws JMSException {\n+        PubSubProtocol.Message.Builder builder = PubSubProtocol.Message.newBuilder();\n+        super.populateBuilderWithHeaders(builder);\n+        if (! isBodyEmpty()) builder.setBody(ByteString.copyFromUtf8(this.payload));\n+        return builder.build();\n+    }\n+\n+    protected boolean isBodyEmpty(){\n+        return null == this.payload;\n+    }\n+\n+    @Override\n+    public void setText(String payload) throws JMSException {\n+        if (readMode) throw new MessageNotWriteableException(\"Message not writable\");\n+        this.payload = payload;\n+    }\n+\n+    @Override\n+    public String getText() throws JMSException {\n+        return payload;\n+    }\n+\n+    @Override\n+    public void clearBody() throws JMSException {\n+        super.clearBody();\n+        this.payload = null;\n+        this.readMode = false;\n+    }\n+\n+    @Override\n+    public void reset() throws JMSException {\n+        if (this.readMode) return ;\n+        this.readMode = true;\n+    }\n+\n+    @Override\n+    TextMessageImpl createClone(SessionImpl session, String sourceTopicName, String subscriberId) throws JMSException {\n+        return new TextMessageImpl(session, this, sourceTopicName, subscriberId);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"TextMessageImpl\");\n+        sb.append(\"{payload='\").append(payload).append('\\'');\n+        sb.append(\", readMode=\").append(readMode);\n+        sb.append(\", parent=\").append(super.toString());\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}"},{"sha":"c4b51233e6c750c1d0ba5d5c52f9ff5573f01e9c","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","status":"added","additions":1126,"deletions":0,"changes":1126,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/JmsHeader.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,1126 @@\n+// Generated by the protocol buffer compiler.  DO NOT EDIT!\n+// source: src/main/protobuf/JmsHeader.proto\n+\n+package org.apache.hedwig.jms.message.header;\n+\n+public final class JmsHeader {\n+  private JmsHeader() {}\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistry registry) {\n+  }\n+  public enum ProtocolVersion\n+      implements com.google.protobuf.ProtocolMessageEnum {\n+    VERSION_ONE(0, 1),\n+    ;\n+    \n+    public static final int VERSION_ONE_VALUE = 1;\n+    \n+    \n+    public final int getNumber() { return value; }\n+    \n+    public static ProtocolVersion valueOf(int value) {\n+      switch (value) {\n+        case 1: return VERSION_ONE;\n+        default: return null;\n+      }\n+    }\n+    \n+    public static com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>\n+        internalGetValueMap() {\n+      return internalValueMap;\n+    }\n+    private static com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>\n+        internalValueMap =\n+          new com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>() {\n+            public ProtocolVersion findValueByNumber(int number) {\n+              return ProtocolVersion.valueOf(number);\n+            }\n+          };\n+    \n+    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+        getValueDescriptor() {\n+      return getDescriptor().getValues().get(index);\n+    }\n+    public final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptorForType() {\n+      return getDescriptor();\n+    }\n+    public static final com.google.protobuf.Descriptors.EnumDescriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.jms.message.header.JmsHeader.getDescriptor().getEnumTypes().get(0);\n+    }\n+    \n+    private static final ProtocolVersion[] VALUES = {\n+      VERSION_ONE, \n+    };\n+    \n+    public static ProtocolVersion valueOf(\n+        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+      if (desc.getType() != getDescriptor()) {\n+        throw new java.lang.IllegalArgumentException(\n+          \"EnumValueDescriptor is not for this type.\");\n+      }\n+      return VALUES[desc.getIndex()];\n+    }\n+    \n+    private final int index;\n+    private final int value;\n+    \n+    private ProtocolVersion(int index, int value) {\n+      this.index = index;\n+      this.value = value;\n+    }\n+    \n+    // @@protoc_insertion_point(enum_scope:Hedwig.Jms.Header.ProtocolVersion)\n+  }\n+  \n+  public interface JmsValueOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n+    boolean hasType();\n+    org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType();\n+    \n+    // optional bool booleanValue = 2;\n+    boolean hasBooleanValue();\n+    boolean getBooleanValue();\n+    \n+    // optional sint32 byteValue = 3;\n+    boolean hasByteValue();\n+    int getByteValue();\n+    \n+    // optional sint32 shortValue = 4;\n+    boolean hasShortValue();\n+    int getShortValue();\n+    \n+    // optional sint32 intValue = 5;\n+    boolean hasIntValue();\n+    int getIntValue();\n+    \n+    // optional sint64 longValue = 6;\n+    boolean hasLongValue();\n+    long getLongValue();\n+    \n+    // optional float floatValue = 7;\n+    boolean hasFloatValue();\n+    float getFloatValue();\n+    \n+    // optional double doubleValue = 8;\n+    boolean hasDoubleValue();\n+    double getDoubleValue();\n+    \n+    // optional string stringValue = 9;\n+    boolean hasStringValue();\n+    String getStringValue();\n+    \n+    // optional bytes bytesValue = 10;\n+    boolean hasBytesValue();\n+    com.google.protobuf.ByteString getBytesValue();\n+  }\n+  public static final class JmsValue extends\n+      com.google.protobuf.GeneratedMessage\n+      implements JmsValueOrBuilder {\n+    // Use JmsValue.newBuilder() to construct.\n+    private JmsValue(Builder builder) {\n+      super(builder);\n+    }\n+    private JmsValue(boolean noInit) {}\n+    \n+    private static final JmsValue defaultInstance;\n+    public static JmsValue getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public JmsValue getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n+    }\n+    \n+    public enum ValueType\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      BOOLEAN(0, 1),\n+      BYTE(1, 2),\n+      SHORT(2, 3),\n+      INT(3, 4),\n+      LONG(4, 5),\n+      FLOAT(5, 6),\n+      DOUBLE(6, 7),\n+      STRING(7, 8),\n+      BYTES(8, 9),\n+      ;\n+      \n+      public static final int BOOLEAN_VALUE = 1;\n+      public static final int BYTE_VALUE = 2;\n+      public static final int SHORT_VALUE = 3;\n+      public static final int INT_VALUE = 4;\n+      public static final int LONG_VALUE = 5;\n+      public static final int FLOAT_VALUE = 6;\n+      public static final int DOUBLE_VALUE = 7;\n+      public static final int STRING_VALUE = 8;\n+      public static final int BYTES_VALUE = 9;\n+      \n+      \n+      public final int getNumber() { return value; }\n+      \n+      public static ValueType valueOf(int value) {\n+        switch (value) {\n+          case 1: return BOOLEAN;\n+          case 2: return BYTE;\n+          case 3: return SHORT;\n+          case 4: return INT;\n+          case 5: return LONG;\n+          case 6: return FLOAT;\n+          case 7: return DOUBLE;\n+          case 8: return STRING;\n+          case 9: return BYTES;\n+          default: return null;\n+        }\n+      }\n+      \n+      public static com.google.protobuf.Internal.EnumLiteMap<ValueType>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static com.google.protobuf.Internal.EnumLiteMap<ValueType>\n+          internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<ValueType>() {\n+              public ValueType findValueByNumber(int number) {\n+                return ValueType.valueOf(number);\n+              }\n+            };\n+      \n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(index);\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDescriptor().getEnumTypes().get(0);\n+      }\n+      \n+      private static final ValueType[] VALUES = {\n+        BOOLEAN, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE, STRING, BYTES, \n+      };\n+      \n+      public static ValueType valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+      \n+      private final int index;\n+      private final int value;\n+      \n+      private ValueType(int index, int value) {\n+        this.index = index;\n+        this.value = value;\n+      }\n+      \n+      // @@protoc_insertion_point(enum_scope:Hedwig.Jms.Header.JmsValue.ValueType)\n+    }\n+    \n+    private int bitField0_;\n+    // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n+    public static final int TYPE_FIELD_NUMBER = 1;\n+    private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType type_;\n+    public boolean hasType() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType() {\n+      return type_;\n+    }\n+    \n+    // optional bool booleanValue = 2;\n+    public static final int BOOLEANVALUE_FIELD_NUMBER = 2;\n+    private boolean booleanValue_;\n+    public boolean hasBooleanValue() {\n+      return ((bitField0_ & 0x00000002) == 0x00000002);\n+    }\n+    public boolean getBooleanValue() {\n+      return booleanValue_;\n+    }\n+    \n+    // optional sint32 byteValue = 3;\n+    public static final int BYTEVALUE_FIELD_NUMBER = 3;\n+    private int byteValue_;\n+    public boolean hasByteValue() {\n+      return ((bitField0_ & 0x00000004) == 0x00000004);\n+    }\n+    public int getByteValue() {\n+      return byteValue_;\n+    }\n+    \n+    // optional sint32 shortValue = 4;\n+    public static final int SHORTVALUE_FIELD_NUMBER = 4;\n+    private int shortValue_;\n+    public boolean hasShortValue() {\n+      return ((bitField0_ & 0x00000008) == 0x00000008);\n+    }\n+    public int getShortValue() {\n+      return shortValue_;\n+    }\n+    \n+    // optional sint32 intValue = 5;\n+    public static final int INTVALUE_FIELD_NUMBER = 5;\n+    private int intValue_;\n+    public boolean hasIntValue() {\n+      return ((bitField0_ & 0x00000010) == 0x00000010);\n+    }\n+    public int getIntValue() {\n+      return intValue_;\n+    }\n+    \n+    // optional sint64 longValue = 6;\n+    public static final int LONGVALUE_FIELD_NUMBER = 6;\n+    private long longValue_;\n+    public boolean hasLongValue() {\n+      return ((bitField0_ & 0x00000020) == 0x00000020);\n+    }\n+    public long getLongValue() {\n+      return longValue_;\n+    }\n+    \n+    // optional float floatValue = 7;\n+    public static final int FLOATVALUE_FIELD_NUMBER = 7;\n+    private float floatValue_;\n+    public boolean hasFloatValue() {\n+      return ((bitField0_ & 0x00000040) == 0x00000040);\n+    }\n+    public float getFloatValue() {\n+      return floatValue_;\n+    }\n+    \n+    // optional double doubleValue = 8;\n+    public static final int DOUBLEVALUE_FIELD_NUMBER = 8;\n+    private double doubleValue_;\n+    public boolean hasDoubleValue() {\n+      return ((bitField0_ & 0x00000080) == 0x00000080);\n+    }\n+    public double getDoubleValue() {\n+      return doubleValue_;\n+    }\n+    \n+    // optional string stringValue = 9;\n+    public static final int STRINGVALUE_FIELD_NUMBER = 9;\n+    private java.lang.Object stringValue_;\n+    public boolean hasStringValue() {\n+      return ((bitField0_ & 0x00000100) == 0x00000100);\n+    }\n+    public String getStringValue() {\n+      java.lang.Object ref = stringValue_;\n+      if (ref instanceof String) {\n+        return (String) ref;\n+      } else {\n+        com.google.protobuf.ByteString bs = \n+            (com.google.protobuf.ByteString) ref;\n+        String s = bs.toStringUtf8();\n+        if (com.google.protobuf.Internal.isValidUtf8(bs)) {\n+          stringValue_ = s;\n+        }\n+        return s;\n+      }\n+    }\n+    private com.google.protobuf.ByteString getStringValueBytes() {\n+      java.lang.Object ref = stringValue_;\n+      if (ref instanceof String) {\n+        com.google.protobuf.ByteString b = \n+            com.google.protobuf.ByteString.copyFromUtf8((String) ref);\n+        stringValue_ = b;\n+        return b;\n+      } else {\n+        return (com.google.protobuf.ByteString) ref;\n+      }\n+    }\n+    \n+    // optional bytes bytesValue = 10;\n+    public static final int BYTESVALUE_FIELD_NUMBER = 10;\n+    private com.google.protobuf.ByteString bytesValue_;\n+    public boolean hasBytesValue() {\n+      return ((bitField0_ & 0x00000200) == 0x00000200);\n+    }\n+    public com.google.protobuf.ByteString getBytesValue() {\n+      return bytesValue_;\n+    }\n+    \n+    private void initFields() {\n+      type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n+      booleanValue_ = false;\n+      byteValue_ = 0;\n+      shortValue_ = 0;\n+      intValue_ = 0;\n+      longValue_ = 0L;\n+      floatValue_ = 0F;\n+      doubleValue_ = 0D;\n+      stringValue_ = \"\";\n+      bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasType()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeEnum(1, type_.getNumber());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        output.writeBool(2, booleanValue_);\n+      }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        output.writeSInt32(3, byteValue_);\n+      }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        output.writeSInt32(4, shortValue_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        output.writeSInt32(5, intValue_);\n+      }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        output.writeSInt64(6, longValue_);\n+      }\n+      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n+        output.writeFloat(7, floatValue_);\n+      }\n+      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n+        output.writeDouble(8, doubleValue_);\n+      }\n+      if (((bitField0_ & 0x00000100) == 0x00000100)) {\n+        output.writeBytes(9, getStringValueBytes());\n+      }\n+      if (((bitField0_ & 0x00000200) == 0x00000200)) {\n+        output.writeBytes(10, bytesValue_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeEnumSize(1, type_.getNumber());\n+      }\n+      if (((bitField0_ & 0x00000002) == 0x00000002)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBoolSize(2, booleanValue_);\n+      }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeSInt32Size(3, byteValue_);\n+      }\n+      if (((bitField0_ & 0x00000008) == 0x00000008)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeSInt32Size(4, shortValue_);\n+      }\n+      if (((bitField0_ & 0x00000010) == 0x00000010)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeSInt32Size(5, intValue_);\n+      }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeSInt64Size(6, longValue_);\n+      }\n+      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeFloatSize(7, floatValue_);\n+      }\n+      if (((bitField0_ & 0x00000080) == 0x00000080)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeDoubleSize(8, doubleValue_);\n+      }\n+      if (((bitField0_ & 0x00000100) == 0x00000100)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(9, getStringValueBytes());\n+      }\n+      if (((bitField0_ & 0x00000200) == 0x00000200)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(10, bytesValue_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.jms.message.header.JmsHeader.JmsValue parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.hedwig.jms.message.header.JmsHeader.JmsValueOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.hedwig.jms.message.header.JmsHeader.internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        booleanValue_ = false;\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        byteValue_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        shortValue_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        intValue_ = 0;\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        longValue_ = 0L;\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        floatValue_ = 0F;\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        doubleValue_ = 0D;\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        stringValue_ = \"\";\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDescriptor();\n+      }\n+      \n+      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue getDefaultInstanceForType() {\n+        return org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDefaultInstance();\n+      }\n+      \n+      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue build() {\n+        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue buildPartial() {\n+        org.apache.hedwig.jms.message.header.JmsHeader.JmsValue result = new org.apache.hedwig.jms.message.header.JmsHeader.JmsValue(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.type_ = type_;\n+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {\n+          to_bitField0_ |= 0x00000002;\n+        }\n+        result.booleanValue_ = booleanValue_;\n+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        result.byteValue_ = byteValue_;\n+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {\n+          to_bitField0_ |= 0x00000008;\n+        }\n+        result.shortValue_ = shortValue_;\n+        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {\n+          to_bitField0_ |= 0x00000010;\n+        }\n+        result.intValue_ = intValue_;\n+        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        result.longValue_ = longValue_;\n+        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {\n+          to_bitField0_ |= 0x00000040;\n+        }\n+        result.floatValue_ = floatValue_;\n+        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {\n+          to_bitField0_ |= 0x00000080;\n+        }\n+        result.doubleValue_ = doubleValue_;\n+        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {\n+          to_bitField0_ |= 0x00000100;\n+        }\n+        result.stringValue_ = stringValue_;\n+        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {\n+          to_bitField0_ |= 0x00000200;\n+        }\n+        result.bytesValue_ = bytesValue_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.hedwig.jms.message.header.JmsHeader.JmsValue) {\n+          return mergeFrom((org.apache.hedwig.jms.message.header.JmsHeader.JmsValue)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue other) {\n+        if (other == org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.getDefaultInstance()) return this;\n+        if (other.hasType()) {\n+          setType(other.getType());\n+        }\n+        if (other.hasBooleanValue()) {\n+          setBooleanValue(other.getBooleanValue());\n+        }\n+        if (other.hasByteValue()) {\n+          setByteValue(other.getByteValue());\n+        }\n+        if (other.hasShortValue()) {\n+          setShortValue(other.getShortValue());\n+        }\n+        if (other.hasIntValue()) {\n+          setIntValue(other.getIntValue());\n+        }\n+        if (other.hasLongValue()) {\n+          setLongValue(other.getLongValue());\n+        }\n+        if (other.hasFloatValue()) {\n+          setFloatValue(other.getFloatValue());\n+        }\n+        if (other.hasDoubleValue()) {\n+          setDoubleValue(other.getDoubleValue());\n+        }\n+        if (other.hasStringValue()) {\n+          setStringValue(other.getStringValue());\n+        }\n+        if (other.hasBytesValue()) {\n+          setBytesValue(other.getBytesValue());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasType()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 8: {\n+              int rawValue = input.readEnum();\n+              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType value = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.valueOf(rawValue);\n+              if (value == null) {\n+                unknownFields.mergeVarintField(1, rawValue);\n+              } else {\n+                bitField0_ |= 0x00000001;\n+                type_ = value;\n+              }\n+              break;\n+            }\n+            case 16: {\n+              bitField0_ |= 0x00000002;\n+              booleanValue_ = input.readBool();\n+              break;\n+            }\n+            case 24: {\n+              bitField0_ |= 0x00000004;\n+              byteValue_ = input.readSInt32();\n+              break;\n+            }\n+            case 32: {\n+              bitField0_ |= 0x00000008;\n+              shortValue_ = input.readSInt32();\n+              break;\n+            }\n+            case 40: {\n+              bitField0_ |= 0x00000010;\n+              intValue_ = input.readSInt32();\n+              break;\n+            }\n+            case 48: {\n+              bitField0_ |= 0x00000020;\n+              longValue_ = input.readSInt64();\n+              break;\n+            }\n+            case 61: {\n+              bitField0_ |= 0x00000040;\n+              floatValue_ = input.readFloat();\n+              break;\n+            }\n+            case 65: {\n+              bitField0_ |= 0x00000080;\n+              doubleValue_ = input.readDouble();\n+              break;\n+            }\n+            case 74: {\n+              bitField0_ |= 0x00000100;\n+              stringValue_ = input.readBytes();\n+              break;\n+            }\n+            case 82: {\n+              bitField0_ |= 0x00000200;\n+              bytesValue_ = input.readBytes();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required .Hedwig.Jms.Header.JmsValue.ValueType type = 1;\n+      private org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n+      public boolean hasType() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType getType() {\n+        return type_;\n+      }\n+      public Builder setType(org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000001;\n+        type_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearType() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        type_ = org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.ValueType.BOOLEAN;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional bool booleanValue = 2;\n+      private boolean booleanValue_ ;\n+      public boolean hasBooleanValue() {\n+        return ((bitField0_ & 0x00000002) == 0x00000002);\n+      }\n+      public boolean getBooleanValue() {\n+        return booleanValue_;\n+      }\n+      public Builder setBooleanValue(boolean value) {\n+        bitField0_ |= 0x00000002;\n+        booleanValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearBooleanValue() {\n+        bitField0_ = (bitField0_ & ~0x00000002);\n+        booleanValue_ = false;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional sint32 byteValue = 3;\n+      private int byteValue_ ;\n+      public boolean hasByteValue() {\n+        return ((bitField0_ & 0x00000004) == 0x00000004);\n+      }\n+      public int getByteValue() {\n+        return byteValue_;\n+      }\n+      public Builder setByteValue(int value) {\n+        bitField0_ |= 0x00000004;\n+        byteValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearByteValue() {\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        byteValue_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional sint32 shortValue = 4;\n+      private int shortValue_ ;\n+      public boolean hasShortValue() {\n+        return ((bitField0_ & 0x00000008) == 0x00000008);\n+      }\n+      public int getShortValue() {\n+        return shortValue_;\n+      }\n+      public Builder setShortValue(int value) {\n+        bitField0_ |= 0x00000008;\n+        shortValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearShortValue() {\n+        bitField0_ = (bitField0_ & ~0x00000008);\n+        shortValue_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional sint32 intValue = 5;\n+      private int intValue_ ;\n+      public boolean hasIntValue() {\n+        return ((bitField0_ & 0x00000010) == 0x00000010);\n+      }\n+      public int getIntValue() {\n+        return intValue_;\n+      }\n+      public Builder setIntValue(int value) {\n+        bitField0_ |= 0x00000010;\n+        intValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearIntValue() {\n+        bitField0_ = (bitField0_ & ~0x00000010);\n+        intValue_ = 0;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional sint64 longValue = 6;\n+      private long longValue_ ;\n+      public boolean hasLongValue() {\n+        return ((bitField0_ & 0x00000020) == 0x00000020);\n+      }\n+      public long getLongValue() {\n+        return longValue_;\n+      }\n+      public Builder setLongValue(long value) {\n+        bitField0_ |= 0x00000020;\n+        longValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearLongValue() {\n+        bitField0_ = (bitField0_ & ~0x00000020);\n+        longValue_ = 0L;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional float floatValue = 7;\n+      private float floatValue_ ;\n+      public boolean hasFloatValue() {\n+        return ((bitField0_ & 0x00000040) == 0x00000040);\n+      }\n+      public float getFloatValue() {\n+        return floatValue_;\n+      }\n+      public Builder setFloatValue(float value) {\n+        bitField0_ |= 0x00000040;\n+        floatValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearFloatValue() {\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        floatValue_ = 0F;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional double doubleValue = 8;\n+      private double doubleValue_ ;\n+      public boolean hasDoubleValue() {\n+        return ((bitField0_ & 0x00000080) == 0x00000080);\n+      }\n+      public double getDoubleValue() {\n+        return doubleValue_;\n+      }\n+      public Builder setDoubleValue(double value) {\n+        bitField0_ |= 0x00000080;\n+        doubleValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearDoubleValue() {\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        doubleValue_ = 0D;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional string stringValue = 9;\n+      private java.lang.Object stringValue_ = \"\";\n+      public boolean hasStringValue() {\n+        return ((bitField0_ & 0x00000100) == 0x00000100);\n+      }\n+      public String getStringValue() {\n+        java.lang.Object ref = stringValue_;\n+        if (!(ref instanceof String)) {\n+          String s = ((com.google.protobuf.ByteString) ref).toStringUtf8();\n+          stringValue_ = s;\n+          return s;\n+        } else {\n+          return (String) ref;\n+        }\n+      }\n+      public Builder setStringValue(String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000100;\n+        stringValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearStringValue() {\n+        bitField0_ = (bitField0_ & ~0x00000100);\n+        stringValue_ = getDefaultInstance().getStringValue();\n+        onChanged();\n+        return this;\n+      }\n+      void setStringValue(com.google.protobuf.ByteString value) {\n+        bitField0_ |= 0x00000100;\n+        stringValue_ = value;\n+        onChanged();\n+      }\n+      \n+      // optional bytes bytesValue = 10;\n+      private com.google.protobuf.ByteString bytesValue_ = com.google.protobuf.ByteString.EMPTY;\n+      public boolean hasBytesValue() {\n+        return ((bitField0_ & 0x00000200) == 0x00000200);\n+      }\n+      public com.google.protobuf.ByteString getBytesValue() {\n+        return bytesValue_;\n+      }\n+      public Builder setBytesValue(com.google.protobuf.ByteString value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000200;\n+        bytesValue_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearBytesValue() {\n+        bitField0_ = (bitField0_ & ~0x00000200);\n+        bytesValue_ = getDefaultInstance().getBytesValue();\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:Hedwig.Jms.Header.JmsValue)\n+    }\n+    \n+    static {\n+      defaultInstance = new JmsValue(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:Hedwig.Jms.Header.JmsValue)\n+  }\n+  \n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_Hedwig_Jms_Header_JmsValue_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable;\n+  \n+  public static com.google.protobuf.Descriptors.FileDescriptor\n+      getDescriptor() {\n+    return descriptor;\n+  }\n+  private static com.google.protobuf.Descriptors.FileDescriptor\n+      descriptor;\n+  static {\n+    java.lang.String[] descriptorData = {\n+      \"\\n!src/main/protobuf/JmsHeader.proto\\022\\021Hed\" +\n+      \"wig.Jms.Header\\\"\\343\\002\\n\\010JmsValue\\0223\\n\\004type\\030\\001 \\002(\" +\n+      \"\\0162%.Hedwig.Jms.Header.JmsValue.ValueType\" +\n+      \"\\022\\024\\n\\014booleanValue\\030\\002 \\001(\\010\\022\\021\\n\\tbyteValue\\030\\003 \\001(\" +\n+      \"\\021\\022\\022\\n\\nshortValue\\030\\004 \\001(\\021\\022\\020\\n\\010intValue\\030\\005 \\001(\\021\\022\" +\n+      \"\\021\\n\\tlongValue\\030\\006 \\001(\\022\\022\\022\\n\\nfloatValue\\030\\007 \\001(\\002\\022\\023\" +\n+      \"\\n\\013doubleValue\\030\\010 \\001(\\001\\022\\023\\n\\013stringValue\\030\\t \\001(\\t\" +\n+      \"\\022\\022\\n\\nbytesValue\\030\\n \\001(\\014\\\"n\\n\\tValueType\\022\\013\\n\\007BOO\" +\n+      \"LEAN\\020\\001\\022\\010\\n\\004BYTE\\020\\002\\022\\t\\n\\005SHORT\\020\\003\\022\\007\\n\\003INT\\020\\004\\022\\010\\n\\004\" +\n+      \"LONG\\020\\005\\022\\t\\n\\005FLOAT\\020\\006\\022\\n\\n\\006DOUBLE\\020\\007\\022\\n\\n\\006STRING\\020\",\n+      \"\\010\\022\\t\\n\\005BYTES\\020\\t*\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSI\" +\n+      \"ON_ONE\\020\\001B(\\n$org.apache.hedwig.jms.messag\" +\n+      \"e.headerH\\001\"\n+    };\n+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n+      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n+        public com.google.protobuf.ExtensionRegistry assignDescriptors(\n+            com.google.protobuf.Descriptors.FileDescriptor root) {\n+          descriptor = root;\n+          internal_static_Hedwig_Jms_Header_JmsValue_descriptor =\n+            getDescriptor().getMessageTypes().get(0);\n+          internal_static_Hedwig_Jms_Header_JmsValue_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_Hedwig_Jms_Header_JmsValue_descriptor,\n+              new java.lang.String[] { \"Type\", \"BooleanValue\", \"ByteValue\", \"ShortValue\", \"IntValue\", \"LongValue\", \"FloatValue\", \"DoubleValue\", \"StringValue\", \"BytesValue\", },\n+              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.class,\n+              org.apache.hedwig.jms.message.header.JmsHeader.JmsValue.Builder.class);\n+          return null;\n+        }\n+      };\n+    com.google.protobuf.Descriptors.FileDescriptor\n+      .internalBuildGeneratedFileFrom(descriptorData,\n+        new com.google.protobuf.Descriptors.FileDescriptor[] {\n+        }, assigner);\n+  }\n+  \n+  // @@protoc_insertion_point(outer_class_scope)\n+}"},{"sha":"38fccd9bd81c01c7e7883c481812739a812caf9f","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/header/MetadataProcessor.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms.message.header;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Decouple rest of system from handling metadata/headers in hedwig.\n+ * Since this part might change (and is shared across the system), changes to it should be isolated from rest of\n+ * jms provider as much as possible so that they can evolve independently with minimal overlap.\n+ */\n+public class MetadataProcessor {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(MetadataProcessor.class);\n+\n+    public static Map<String, Object> parseHeaders(PubSubProtocol.Message message){\n+        Map<String, Object> properties = new HashMap<String, Object>();\n+\n+        // if not header or properties, return empty map ...\n+        if (! message.hasHeader() || ! message.getHeader().hasProperties()) return properties;\n+\n+        // first, populate the map, then remove the standard headers from it.\n+        for (PubSubProtocol.Map.Entry entry : message.getHeader().getProperties().getEntriesList()){\n+            final JmsHeader.JmsValue value;\n+            try {\n+                ByteString data = entry.getValue();\n+                value = JmsHeader.JmsValue.parseFrom(data);\n+            } catch (InvalidProtocolBufferException e) {\n+                // incorrect type, we cant do much, ignore and continue.\n+                if (logger.isDebugEnabled()) logger.debug(\"Cant parse header \" +\n+                    entry.getKey() + \" as a jms value, ignoring\");\n+                continue;\n+            }\n+\n+            switch(value.getType()){\n+                case BOOLEAN:\n+                    properties.put(entry.getKey(), (boolean) value.getBooleanValue());\n+                    break;\n+                case BYTE:\n+                    properties.put(entry.getKey(), (byte) value.getByteValue());\n+                    break;\n+                case SHORT:\n+                    properties.put(entry.getKey(), (short) value.getShortValue());\n+                    break;\n+                case INT:\n+                    properties.put(entry.getKey(), (int) value.getIntValue());\n+                    break;\n+                case LONG:\n+                    properties.put(entry.getKey(), (long) value.getLongValue());\n+                    break;\n+                case FLOAT:\n+                    properties.put(entry.getKey(), (float) value.getFloatValue());\n+                    break;\n+                case DOUBLE:\n+                    properties.put(entry.getKey(), (double) value.getDoubleValue());\n+                    break;\n+                case STRING:\n+                    properties.put(entry.getKey(), (String) value.getStringValue());\n+                    break;\n+                case BYTES:\n+                    properties.put(entry.getKey(), value.getBytesValue());\n+                    break;\n+                default:\n+                    // future addition not yet supported ...\n+                    logger.info(\"Unknown metadata key type \" + value.getType() +\n+                        \" ... unsupported by jms provider. Ignoring\");\n+                    continue;\n+            }\n+        }\n+        return properties;\n+    }\n+\n+    public static void addHeaders(PubSubProtocol.Message.Builder builder, Map<String, Object> properties) {\n+        // Too many builder.addMetadata(...) code in this method, externalize to their own methods ? maybe later ...\n+        // add the user properties, and then override standard properties.\n+\n+        PubSubProtocol.Map.Builder mapBuilder = PubSubProtocol.Map.newBuilder();\n+\n+        for (Map.Entry<String, Object> entry : properties.entrySet()){\n+            // ignoring, right ?\n+            if (null == entry.getValue()) continue;\n+\n+            final JmsHeader.JmsValue.Builder jmsValueBuilder = JmsHeader.JmsValue.newBuilder();\n+\n+            final String key = entry.getKey();\n+            final Object value = entry.getValue();\n+            if (value instanceof Boolean){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BOOLEAN);\n+                jmsValueBuilder.setBooleanValue((Boolean) value);\n+            }\n+            else if (value instanceof Byte){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BYTE);\n+                jmsValueBuilder.setByteValue((Byte) value);\n+            }\n+            else if (value instanceof Short){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.SHORT);\n+                jmsValueBuilder.setShortValue((Short) value);\n+            }\n+            else if (value instanceof Integer){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.INT);\n+                jmsValueBuilder.setIntValue((Integer) value);\n+            }\n+            else if (value instanceof Long){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.LONG);\n+                jmsValueBuilder.setLongValue((Long) value);\n+            }\n+            else if (value instanceof Float){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.FLOAT);\n+                jmsValueBuilder.setFloatValue((Float) value);\n+            }\n+            else if (value instanceof Double){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.DOUBLE);\n+                jmsValueBuilder.setDoubleValue((Double) value);\n+            }\n+            else if (value instanceof String){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.STRING);\n+                jmsValueBuilder.setStringValue((String) value);\n+            }\n+            else if (value instanceof byte[]){\n+                jmsValueBuilder.setType(JmsHeader.JmsValue.ValueType.BYTES);\n+                jmsValueBuilder.setBytesValue(ByteString.copyFrom((byte[]) value));\n+            }\n+            else {\n+                throw new IllegalArgumentException(\"Unknown property value type ? \" + entry);\n+            }\n+\n+\n+            PubSubProtocol.Map.Entry.Builder entryBuilder = PubSubProtocol.Map.Entry.newBuilder();\n+            entryBuilder.setKey(key);\n+            entryBuilder.setValue(jmsValueBuilder.build().toByteString());\n+\n+            mapBuilder.addEntries(entryBuilder.build());\n+        }\n+\n+        PubSubProtocol.MessageHeader.Builder messageHeaderBuilder = PubSubProtocol.MessageHeader.newBuilder();\n+        messageHeaderBuilder.setProperties(mapBuilder.build());\n+\n+        builder.setHeader(messageHeaderBuilder.build());\n+    }\n+}"},{"sha":"0cd78cb2dc86f2c77ded2e576de7271f872e5103","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/message/package-info.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,29 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+Contains implementations of various Message's supported by JMS. <br/>\n+The implementations take care of these aspects : <br/>\n+<ul>\n+  <li>Provide a JMS compliant implementation for the different messages</li>\n+  <li>Allows the system to accept and convert Message's NOT created via this package.</li>\n+  <li>Allows system to generate hedwig wire-format messages from these JMS messages. (taken with above,\n+    it allows us to send any JMS message over wire).</li>\n+  <li>Allows system to parse hedwig wire-format messages into JMS messages</li>\n+</ul>\n+\n+Most of the implementation is hidden away and exposed via the MessagUtil - except for what is mandated\n+by JMS, and some state information required by hedwig."},{"sha":"e0150686eaf255b76abc8ca2292099ce6e9357f0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/package-info.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,92 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+\n+<h3>Introduction</h3>\n+\n+Contains the basic (hedwig agnostic) aspects of the provider implementation <br/>\n+This package enforces (to a large part) the constraints expected by JMS api and maintains state and\n+manages the lifecycle of rest of the provider system. <br/>\n+<p/>\n+It depends only on message package.<br/>\n+It is decoupled from actual nitty-gritties of the hedwig specific aspects via a Facade - which\n+encapsulates all functionalities required off hedwig. <br/>\n+It is envisioned that we will have additional implementations for the facade as time goes by :\n+<ul>\n+  <li>Test mockup facade to test provider aspects decoupled from hedwig</li>\n+  <li>Facade's to experiment with add and/or modify functionality exposed to provider (support for\n+    Queue for example without modifying existing code).</li>\n+  <li>Facade's to experiment with add and/or modify functionality to hedwig itself.</li>\n+  <li>This space for rent :-)</li>\n+</ul>\n+\n+\n+<h3>Missing functionality</h3>\n+\n+Various aspects of JMS are currently unsupported - the detailed list is long, but the main caveats\n+with the provider currently are :\n+<ul>\n+\n+  <li>No support for Queues : Hedwig currently does not have a notion of JMS queue's for us to leverage.</li>\n+\n+  <li>No support for noLocal : Hedwig DOES NOT conform to JMS model of\n+    connection -(n)-> session -(n)-> publisher/subscriber. Each session has a hedwig connection.<br/>\n+Currently I am simulating noLocal, but this IS fragile and works for the duration of connection -\n+    ONLY until the message id is still in a LRUCache. As mentioned before, this is a kludge, and not\n+    a good solution.<br/>\n+  </li>\n+\n+  <li>Note that everything is durable in hedwig - so we do not support NON_PERSISTENT delivery mode.</li>\n+\n+  <li>Calling unsubscribe on a durable subscription will fail if it was NOT created in the current session. <br/>\n+    In hedwig, to unsubscribe, we need the subscription id and the topic ... <br/>\n+    To simulate unsubscribe(), we store the subscriberId to topicName mapping when a create* api is\n+    invoked. <br/>\n+    Hence, if create* was NOT called, then we have no way to infer which topic the subscription-id\n+    refers to from hedwig, and so cant unsubscribe. <br/>\n+    The workaround is - simply create a durable subsriber just as a workaround of this limitation -\n+    the topicName will be known to the user/client anyway.</li>\n+\n+  <li>Explicit session recovery is not supported.<br/>\n+Reconnection of hedwig session (either explicitly or implicitly by underlying client implementation) will\n+automatically trigger redelivery of un-acknowledged messages.\n+  </li>\n+\n+  <li>Because of the above, setting the JMSRedelivered flag is almost impossible in a consistent way.<br/>\n+Currently, we simulate it for redelivery due to provider side events : rollback of txn, exception\n+    in message listener (primarily). <br/>\n+At best we can simulate it with a kludge - at risk of potentially running out of resources ... this\n+    is being investigated : but unlikely to have a clean fix. <br/>\n+  </li>\n+\n+  <li>Hedwig only supports marking all messages until seq-id as received : while JMS indicates abilit\n+    y to acknowledge individual messages.<br/>\n+This distinction is currently unsupported. Investigating if we can do something about it.\n+  </li>\n+\n+  <li>JMS spec requires\n+    \"A connection's delivery of incoming messages can be temporarily stopped <br/>\n+using its stop() method. It can be restarted using its start() method. When the <br/>\n+connection is stopped, delivery to all the connections MessageConsumers is <br/>\n+inhibited: synchronous receives block, and messages are not delivered to <br/>\n+MessageListeners.\"<br/>\n+  We honour this for undelivered messages from server - but if stop is called while there are\n+    pending messages yet to be delivered to a listner (or buffered in subscriber for receive),\n+    then they will be delivered irrespective of stop().</li>\n+\n+</ul>\n+Hopefully I am not missing any of the big points ..."},{"sha":"a2845be563110ae8fd0e7cf36bc085b51e0d5196","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryArithmeticFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,184 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Binary arithematic of values ..\n+ */\n+public abstract class BinaryArithmeticFunction extends BinaryExprFunction {\n+\n+    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n+                                            MessageImpl message) throws SelectorEvaluationException {\n+\n+        switch (left.type) {\n+            case INT: {\n+                switch (right.type) {\n+                    case INT:\n+                        return new SelectorConstant(computeWithInt(left.getIntValue(), right.getIntValue()));\n+                    case DOUBLE:\n+                        return new SelectorConstant(computeWithInt(left.getIntValue(), right.getDoubleValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+            case DOUBLE: {\n+                switch (right.type) {\n+                    case INT:\n+                        return new SelectorConstant(computeWithDouble(left.getDoubleValue(), right.getIntValue()));\n+                    case DOUBLE:\n+                        return new SelectorConstant(computeWithDouble(left.getDoubleValue(), right.getDoubleValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+            case BOOLEAN:\n+            case STRING:\n+            default:\n+                throw new SelectorEvaluationException(getClass() + \" Unsupported type : \" + left.type +\n+                    \". left : \" + left + \", right : \" + right);\n+        }\n+    }\n+\n+\n+    protected abstract Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException;\n+\n+    protected abstract Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException;\n+\n+    protected abstract Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException;\n+\n+    protected abstract Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException;\n+\n+\n+    public static final BinaryArithmeticFunction ADD_FUNCTION = new BinaryArithmeticFunction() {\n+        @Override\n+        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return (double) left + right;\n+        }\n+\n+        @Override\n+        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left + right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left + right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left + (double) right;\n+        }\n+    };\n+\n+    public static final BinaryArithmeticFunction SUB_FUNCTION = new BinaryArithmeticFunction() {\n+        @Override\n+        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return (double) left - right;\n+        }\n+\n+        @Override\n+        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left - right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left - right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left - (double) right;\n+        }\n+    };\n+\n+    public static final BinaryArithmeticFunction MULTIPLY_FUNCTION = new BinaryArithmeticFunction() {\n+        @Override\n+        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return (double) left * right;\n+        }\n+\n+        @Override\n+        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left * right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left * right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left * (double) right;\n+        }\n+    };\n+\n+    public static final BinaryArithmeticFunction DIVIDE_FUNCTION = new BinaryArithmeticFunction() {\n+        @Override\n+        protected Double computeWithInt(Integer left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            if ((double) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n+            return (double) left / right;\n+        }\n+\n+        @Override\n+        protected Integer computeWithInt(Integer left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            if ((int) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n+            return left / right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            if ((double) 0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n+            return left / right;\n+        }\n+\n+        @Override\n+        protected Double computeWithDouble(Double left, Integer right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            if (0 == right) throw new SelectorEvaluationException(getClass() + \" denominator == 0\");\n+            return left / (double) right;\n+        }\n+    };\n+\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"6c41b6d0560c337ef82e39561283d4918c4af53b","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/BinaryExprFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,51 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Evaluate binary expressions - where there is a left and right expression to be evaluated.\n+ */\n+public abstract class BinaryExprFunction implements ExprFunction {\n+\n+    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+        if (state.getStack().size() < 2)\n+            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+\n+        SelectorConstant right = state.getStack().pop();\n+        SelectorConstant left = state.getStack().pop();\n+\n+        SelectorConstant result = evaluateImpl(left, right, state.getMessage());\n+\n+        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": left \" + left +\n+            \", right \" + right + \" -> \" + result);\n+\n+        if (null != result) state.getStack().push(result);\n+        else throw new SelectorEvaluationException(getClass() +\n+            \" Unexpected to return a null response in binary function evaluation\");\n+    }\n+\n+    protected abstract SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n+                                                     MessageImpl message) throws SelectorEvaluationException;\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"da708e3b57df48ba268bffdd3fc10f49a7cfaec4","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ExprFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,25 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+/**\n+ * All function's referenced in the ast implement this interface to evaluate it result.\n+ */\n+public interface ExprFunction {\n+    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException;\n+}"},{"sha":"143269fd7f67219631622d9d1c7c9f3652ad1bd1","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","status":"added","additions":180,"deletions":0,"changes":180,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/InterpretSelectorParserVisitor.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,180 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+/**\n+ * Visits the AST to evaluate the message (in the SelectorEvalState) against this ast parse tree to see if the\n+ * message evaluates to true or false (whether to allow message to be submitted or not to consumers).\n+ */\n+public class InterpretSelectorParserVisitor implements SelectorParserVisitor {\n+    @Override\n+    public Object visit(SimpleNode node, SelectorEvalState data) throws SelectorEvaluationException {\n+        throw new SelectorEvaluationException(getClass() + \" Should not result in this method being called !\");\n+    }\n+\n+    @Override\n+    public Object visit(ASTOrExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTAndExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNotExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTGreaterThan node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLessThan node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLessThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTGreaterThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNotEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTIsNullExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTBetweenExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTInExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLikeExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLookupExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTAddExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTSubExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTDivideExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTMultiplyExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNegateExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        node.childrenAccept(this, data);\n+        node.getExprFunction().evaluate(data);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTConstant node, SelectorEvalState data) throws SelectorEvaluationException {\n+        // node.childrenAccept(this, data);\n+        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n+            \" parse error ? \" + node);\n+        data.getStack().push(node.getConstantValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTStringVarargParams node, SelectorEvalState data) throws SelectorEvaluationException {\n+        // node.childrenAccept(this, data);\n+        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n+            \" parse error ? \" + node);\n+        data.getStack().push(node.getConstantValue());\n+        return null;\n+    }\n+}"},{"sha":"4db66f7851faec7378f85eed909ba08874ed68c9","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/LogicalComparisonFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Logical comparison between two booleans.\n+ */\n+public abstract class LogicalComparisonFunction extends BinaryExprFunction {\n+    public static final LogicalComparisonFunction AND_FUNCTION = new LogicalComparisonFunction() {\n+        @Override\n+        protected Boolean doComparison(Boolean left, Boolean right) {\n+            if (null == left || null == right) {\n+                return (Boolean.FALSE.equals(left) || Boolean.FALSE.equals(right)) ? false : null;\n+            }\n+            return left && right;\n+        }\n+    };\n+\n+    public static final LogicalComparisonFunction OR_FUNCTION = new LogicalComparisonFunction() {\n+        @Override\n+        protected Boolean doComparison(Boolean left, Boolean right) {\n+            if (null == left || null == right) {\n+                return (Boolean.TRUE.equals(left) || Boolean.TRUE.equals(right)) ? true : null;\n+            }\n+\n+            return left || right;\n+        }\n+    };\n+\n+\n+    protected abstract Boolean doComparison(Boolean left, Boolean right);\n+\n+    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n+                                            MessageImpl message) throws SelectorEvaluationException {\n+        if (SelectorConstant.SelectorDataType.BOOLEAN != left.type ||\n+            SelectorConstant.SelectorDataType.BOOLEAN != right.type) {\n+            throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + left + \", \" + right);\n+        }\n+\n+        return new SelectorConstant(doComparison(left.getBoolValue(), right.getBoolValue()));\n+    }\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"b23b3e105915515c883f048aa5e43c87d3fca609","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/MyNode.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,101 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Root of all nodes in the AST generated.\n+ * Encapsulates state for evaluation of the ast by an interpreter.\n+ */\n+public class MyNode {\n+\n+    final static Logger logger = LoggerFactory.getLogger(MyNode.class);\n+\n+    // This is se for case of constant value literals.\n+    private SelectorConstant selectorConstant;\n+\n+    // This is the actual expression to evaluate.\n+    private ExprFunction exprFunction;\n+\n+    // Called while interpreting ..\n+    public SelectorConstant getConstantValue() throws SelectorEvaluationException {\n+        if (null == selectorConstant)\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unexpected not to have evalData populated for \" + this);\n+        return selectorConstant;\n+    }\n+\n+    public void addToStringSet(String str) throws ParseException {\n+        if (null == selectorConstant) throw new ParseException(getClass() +\n+            \" Unexpected not to have evalData populated for \" + this);\n+        selectorConstant.addToStringSet(str);\n+    }\n+\n+    // Called while parsing ..\n+    public void setConstantValue(SelectorConstant selectorData) throws ParseException {\n+        if (null != this.selectorConstant)\n+            throw new ParseException(getClass() + \" Value already set ? prev : \" +\n+                this.selectorConstant + \", new : \" + selectorData);\n+\n+        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(\"Setting constant value \" +\n+            selectorData + \" for \" + this);\n+\n+        this.selectorConstant = selectorData;\n+    }\n+\n+\n+    // Called while interpreting ..\n+    public ExprFunction getExprFunction() throws SelectorEvaluationException {\n+        if (null == exprFunction)\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unexpected not to have exprFunction populated for \" + this);\n+        return exprFunction;\n+    }\n+\n+    // Called while parsing ..\n+    public void setExprFunction(ExprFunction exprFunction) throws ParseException {\n+        if (null != this.exprFunction)\n+            throw new ParseException(getClass() + \" exprFunction already set ? prev : \" +\n+                this.exprFunction + \", new : \" + exprFunction);\n+\n+        if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(\"Setting function expr \" +\n+            exprFunction + \" for \" + this);\n+\n+        this.exprFunction = exprFunction;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"MyNode\");\n+        sb.append(\"{selectorConstant=\").append(selectorConstant);\n+        sb.append(\", exprFunction=\").append(exprFunction);\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+\n+\n+\n+\n+    // Internal to the parser - DO NOT use outside !\n+    SelectorConstant getConstantValueInternal() { return selectorConstant; }\n+    ExprFunction getExprFunctionInternal() { return exprFunction; }\n+}"},{"sha":"83df4f100114a3f1372ac62d6645312ef29c2f40","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","status":"added","additions":512,"deletions":0,"changes":512,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/PropertyExprFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,512 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+/**\n+ * Handles property (and header) dereference against message evaluation (based on identifier specified).\n+ */\n+public abstract class PropertyExprFunction implements ExprFunction {\n+\n+    public static class LookupExpr extends PropertyExprFunction {\n+        private final String identifier;\n+\n+        public LookupExpr(String identifier) {\n+            this.identifier = identifier;\n+        }\n+\n+        @Override\n+        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+            // No (stack) params required ...\n+\n+            SelectorConstant result = doEvaluate(state.getMessage());\n+            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": identifier '\" +\n+                identifier + \"' -> \" + result);\n+            state.getStack().push(result);\n+            return;\n+        }\n+\n+        private SelectorConstant doEvaluate(final MessageImpl message) throws SelectorEvaluationException {\n+\n+\n+            if (!message.propertyExists(identifier)) {\n+                // defaulting to String, does it matter ?\n+                return new SelectorConstant((String) null);\n+            }\n+\n+            final Object val = message.getSelectorProcessingPropertyValue(identifier);\n+\n+            if (val instanceof Byte) {\n+                return new SelectorConstant((int) (Byte) val);\n+            }\n+            if (val instanceof Short) {\n+                return new SelectorConstant((int) (Short) val);\n+            }\n+            if (val instanceof Integer) {\n+                return new SelectorConstant((Integer) val);\n+            }\n+            if (val instanceof Long) {\n+                long lval = (Long) val;\n+                if (lval >= (long) Integer.MAX_VALUE || lval <= (long) Integer.MIN_VALUE)\n+                    throw new SelectorEvaluationException(getClass() + \" long value \" + lval +\n+                        \" out of range for an int\");\n+\n+                return new SelectorConstant((int) lval);\n+            }\n+            if (val instanceof Boolean) {\n+                return new SelectorConstant((Boolean) val);\n+            }\n+            if (val instanceof Float) {\n+                return new SelectorConstant((double) (Float) val);\n+            }\n+            if (val instanceof Double) {\n+                return new SelectorConstant((Double) val);\n+            }\n+            if (val instanceof String) {\n+                return new SelectorConstant((String) val);\n+            }\n+\n+\n+            throw new SelectorEvaluationException(getClass() + \" Unable to interpret value '\" + val +\n+                \"' for identifier \" + identifier);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"LookupExpr\");\n+            sb.append(\"{identifier='\").append(identifier).append('\\'');\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static class IsNullExpr extends PropertyExprFunction {\n+\n+        private final boolean negate;\n+\n+        public IsNullExpr(boolean negate) {\n+            this.negate = negate;\n+        }\n+\n+        @Override\n+        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+\n+            final SelectorConstant result = doEvaluate(state);\n+            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \" -> \" + result);\n+            state.getStack().push(result);\n+        }\n+\n+        private SelectorConstant doEvaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+\n+            if (state.getStack().isEmpty())\n+                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+\n+            final SelectorConstant value = state.getStack().pop();\n+\n+            boolean result = value.isNull();\n+            if (negate) result = !result;\n+            return new SelectorConstant(result);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"IsNullExpr\");\n+            sb.append(\"{negate=\").append(negate);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static class InExpr extends PropertyExprFunction {\n+\n+        private final boolean negate;\n+\n+        public InExpr(boolean negate) {\n+            this.negate = negate;\n+        }\n+\n+        @Override\n+        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+            if (state.getStack().size() < 2)\n+                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+\n+            final SelectorConstant paramSet = state.getStack().pop();\n+            final SelectorConstant checkFor = state.getStack().pop();\n+\n+            final SelectorConstant result = doEvaluate(paramSet, checkFor);\n+            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": checkFor '\" +\n+                checkFor + \"', paramSet '\" + paramSet+ \"' -> \" + result);\n+\n+            state.getStack().push(result);\n+            return ;\n+\n+        }\n+\n+        private SelectorConstant doEvaluate(SelectorConstant paramSet, SelectorConstant checkFor)\n+            throws SelectorEvaluationException {\n+\n+            if (checkFor.isNull()){\n+                return new SelectorConstant((String) null);\n+            }\n+\n+            if (SelectorConstant.SelectorDataType.STRING_SET != paramSet.type) {\n+                throw new SelectorEvaluationException(getClass() + \" Expected string list, found : \" +\n+                    paramSet.type + \", for \" + paramSet);\n+            }\n+            if (SelectorConstant.SelectorDataType.STRING != checkFor.type){\n+                throw new SelectorEvaluationException(getClass() + \" Expected string , found : \" +\n+                    checkFor.type + \", for \" + checkFor);\n+            }\n+\n+            boolean result = paramSet.getStringSet().contains(checkFor.getStringValue());\n+            if (negate) result = !result;\n+            return new SelectorConstant(result);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"InExpr\");\n+            sb.append(\"{negate=\").append(negate);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static class LikeExpr extends PropertyExprFunction {\n+\n+        private final Pattern likePattern;\n+        private final String likePatternStr;\n+        private final boolean negate;\n+\n+        public LikeExpr(String likeExpression, String escapeCharacter, boolean negate) throws ParseException {\n+            if (null != escapeCharacter && 1 != escapeCharacter.length()) {\n+                throw new ParseException(getClass() + \" Escape character must be a single character : '\" +\n+                    escapeCharacter + \"'\");\n+            }\n+            this.likePatternStr = generateRegexpPattern(likeExpression, escapeCharacter);\n+            try {\n+                this.likePattern = Pattern.compile(this.likePatternStr, Pattern.DOTALL);\n+            } catch (PatternSyntaxException psEx){\n+                throw new ParseException(LikeExpr.class + \" Unable to compile '\" + likeExpression +\n+                    \"' into regexp Pattern using '\" + this.likePatternStr+ \"'\");\n+            }\n+            this.negate = negate;\n+        }\n+\n+        private static String generateRegexpWithoutWildcard(final String expression){\n+            int indxOffset = 0;\n+            int substringOffset = 0;\n+            StringBuilder sb = new StringBuilder();\n+            while (indxOffset < expression.length()){\n+                final int indxUnder = expression.indexOf('_', indxOffset);\n+                final int indxMod = expression.indexOf('%', indxOffset);\n+                if (-1 == indxUnder && -1 == indxMod) break;\n+\n+                final int indx;\n+\n+                if (-1 != indxUnder && -1 != indxMod) indx = Math.min(indxUnder, indxMod);\n+                else if (-1 != indxUnder) indx = indxUnder;\n+                else indx = indxMod;\n+\n+                if (indx != substringOffset) {\n+                    sb.append(Pattern.quote(expression.substring(substringOffset, indx)));\n+                }\n+                sb.append(indx == indxUnder ? \".\" : \".*\");\n+                substringOffset = indx + 1;\n+                indxOffset = indx + 1;\n+            }\n+            if (expression.length() != substringOffset) {\n+                sb.append(Pattern.quote(expression.substring(substringOffset)));\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        // If wildcard if prefixed with escapeChar, ignore it.\n+        private static String generateRegexpWithWildcard(final String expression, char escapeChar){\n+            int indxOffset = 0;\n+            int substringOffset = 0;\n+            StringBuilder sb = new StringBuilder();\n+            while (indxOffset < expression.length()){\n+                final int indxUnder = expression.indexOf('_', indxOffset);\n+                final int indxMod = expression.indexOf('%', indxOffset);\n+                if (-1 == indxUnder && -1 == indxMod) break;\n+\n+                final int indx;\n+\n+                if (-1 != indxUnder && -1 != indxMod) indx = Math.min(indxUnder, indxMod);\n+                else if (-1 != indxUnder) indx = indxUnder;\n+                else indx = indxMod;\n+\n+                if (indx > 0 && escapeChar == expression.charAt(indx - 1)) {\n+                    // ignore it.\n+                    indxOffset = indx + 1;\n+                    continue;\n+                }\n+\n+                if (indx != substringOffset) {\n+                    sb.append(Pattern.quote(expression.substring(substringOffset, indx)));\n+                }\n+                sb.append(indx == indxUnder ? \".\" : \".*\");\n+                substringOffset = indx + 1;\n+                indxOffset = indx + 1;\n+            }\n+            if (expression.length() != substringOffset) {\n+                sb.append(Pattern.quote(expression.substring(substringOffset)));\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        private static String generateRegexpPattern(final String likeExpression,\n+                                                    final String escapeCharacterStr) throws ParseException {\n+\n+            if (null == escapeCharacterStr){\n+                // Ok, hand-generating the pattern seems to be the only generic way to handle this, sigh :-(\n+\n+                String rpat = generateRegexpWithoutWildcard(likeExpression);\n+                return rpat;\n+            }\n+\n+            // expect this to be there ...\n+            final char escapeChar = escapeCharacterStr.charAt(0);\n+\n+            // Test when escapeChar == ']', '[' and '^'. done !\n+            String rpat = generateRegexpWithWildcard(likeExpression, escapeChar);\n+\n+            rpat = rpat.replace(escapeChar + \"%\", \"%\");\n+            rpat = rpat.replace(escapeChar + \"_\", \"_\");\n+\n+            return rpat;\n+        }\n+\n+        @Override\n+        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+\n+            if (state.getStack().isEmpty()) throw new SelectorEvaluationException(getClass() +\n+                \" stack corruption ? \" + state.getStack());\n+\n+            final SelectorConstant checkFor = state.getStack().pop();\n+\n+            final SelectorConstant result = doEvaluate(checkFor);\n+            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": checkFor '\" +\n+                checkFor + \"' -> \" + result);\n+\n+            state.getStack().push(result);\n+            return ;\n+        }\n+\n+        private SelectorConstant doEvaluate(SelectorConstant checkFor) throws SelectorEvaluationException {\n+            if (checkFor.isNull()){\n+                return new SelectorConstant((String) null);\n+            }\n+\n+            if (SelectorConstant.SelectorDataType.STRING != checkFor.type){\n+                throw new SelectorEvaluationException(getClass() + \" Expected string , found : \" +\n+                    checkFor.type + \", for \" + checkFor);\n+            }\n+\n+\n+            final String value = checkFor.getStringValue();\n+\n+            if (null == value) {\n+                return new SelectorConstant((Boolean) null);\n+            }\n+\n+            boolean result = likePattern.matcher(value).matches();\n+            if (negate) result = !result;\n+            return new SelectorConstant(result);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"LikeExpr\");\n+            sb.append(\"{likePatternStr=\").append(likePatternStr);\n+            sb.append(\", negate=\").append(negate);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static class BetweenExpr extends PropertyExprFunction {\n+\n+        private final boolean negate;\n+\n+        public BetweenExpr(boolean negate) {\n+            this.negate = negate;\n+        }\n+\n+        @Override\n+        public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+            if (state.getStack().size() < 3){\n+                throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+            }\n+\n+            final SelectorConstant right = state.getStack().pop();\n+            final SelectorConstant left = state.getStack().pop();\n+\n+            final SelectorConstant checkFor = state.getStack().pop();\n+\n+            final SelectorConstant result = doEvaluate(checkFor, left, right);\n+            if (MyNode.logger.isTraceEnabled()) MyNode.logger.trace(getClass() + \": left '\" + left +\n+                \"', right '\" + right + \"', checkFor '\" + checkFor + \"' -> \" + result);\n+            state.getStack().push(result);\n+        }\n+\n+        private SelectorConstant doEvaluate(final SelectorConstant checkFor, final SelectorConstant left,\n+                                            final SelectorConstant right) throws SelectorEvaluationException {\n+\n+            if (left.isNull() || right.isNull()) {\n+                // Unexpected for a bound to be null ...\n+                throw new SelectorEvaluationException(getClass() + \" Unexpected for left or right bound to be null \" +\n+                    left + \", \" + right);\n+            }\n+\n+            if (checkFor.isNull()){\n+                // If checkFor is null, then it cant be between anyway - return unknown.\n+                return new SelectorConstant((Boolean) null);\n+            }\n+\n+            final Boolean result;\n+\n+            // Between left and right ...\n+            switch (left.type) {\n+                case INT: {\n+                    switch (right.type) {\n+                        case INT: {\n+                            result = handleBetweenIntAndInt(checkFor, left.getIntValue(),\n+                                right.getIntValue());\n+                            break;\n+                        }\n+                        case DOUBLE: {\n+                            result = handleBetweenIntAndDouble(checkFor, left.getIntValue(),\n+                                right.getDoubleValue());\n+                            break;\n+                        }\n+                        default:\n+                            throw new SelectorEvaluationException(getClass() + \" Unsupported type for right \" +\n+                                right.type);\n+                    }\n+                    break;\n+                }\n+                case DOUBLE: {\n+                    switch (right.type) {\n+                        case INT: {\n+                            result = handleBetweenIntAndDouble(checkFor, right.getIntValue(),\n+                                left.getDoubleValue());\n+                            break;\n+                        }\n+                        case DOUBLE: {\n+                            result = handleBetweenDoubleAndDouble(checkFor, left.getDoubleValue(),\n+                                right.getDoubleValue());\n+                            break;\n+                        }\n+                        default:\n+                            throw new SelectorEvaluationException(getClass() +\n+                                \" Unsupported type for right \" + right.type);\n+                    }\n+                    break;\n+                }\n+                default:\n+                    throw new SelectorEvaluationException(getClass() + \" Unsupported type for left \" + right.type);\n+            }\n+\n+            if (null == result) {\n+                // Cannot find the result as the type we expected.\n+                return new SelectorConstant((Boolean) null);\n+            }\n+\n+\n+            return new SelectorConstant(negate ? !result : result);\n+        }\n+\n+        private Boolean handleBetweenIntAndInt(SelectorConstant checkFor, int intBound,\n+                                               int otherIntBound) throws SelectorEvaluationException {\n+            final int low = Math.min(intBound, otherIntBound);\n+            final int high = Math.max(intBound, otherIntBound);\n+\n+            assert ! checkFor.isNull();\n+\n+\n+            switch (checkFor.type){\n+                case INT:\n+                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n+                case DOUBLE:\n+                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n+                default:\n+                    throw new SelectorEvaluationException(getClass() +\n+                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n+            }\n+        }\n+\n+        private Boolean handleBetweenIntAndDouble(SelectorConstant checkFor, int intBound,\n+                                                  double doubleBound) throws SelectorEvaluationException {\n+            final double low = Math.min((double) intBound, doubleBound);\n+            final double high = Math.max((double) intBound, doubleBound);\n+\n+            assert ! checkFor.isNull();\n+\n+\n+            switch (checkFor.type){\n+                case INT:\n+                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n+                case DOUBLE:\n+                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n+                default:\n+                    throw new SelectorEvaluationException(getClass() +\n+                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n+            }\n+        }\n+\n+        private Boolean handleBetweenDoubleAndDouble(SelectorConstant checkFor, double doubleBound,\n+                                                     double otherDoubleBound) throws SelectorEvaluationException {\n+            final double low = Math.min(doubleBound, otherDoubleBound);\n+            final double high = Math.max(doubleBound, otherDoubleBound);\n+\n+            assert ! checkFor.isNull();\n+\n+\n+            switch (checkFor.type){\n+                case INT:\n+                    return checkFor.getIntValue() >= low && checkFor.getIntValue() <= high;\n+                case DOUBLE:\n+                    return checkFor.getDoubleValue() >= low && checkFor.getDoubleValue() <= high;\n+                default:\n+                    throw new SelectorEvaluationException(getClass() +\n+                        \" Identifier value is of illegal type \" + checkFor.type + \" ... \" + checkFor);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"BetweenExpr\");\n+            sb.append(\"{negate=\").append(negate);\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"e4af1c75d8ec6b47fa81432de654f7a240708a7f","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorConstant.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,187 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+/**\n+ * A constant in the AST ends up getting pushed into the stack as this.\n+ */\n+public class SelectorConstant {\n+\n+    public enum SelectorDataType {BOOLEAN, INT, DOUBLE, STRING, STRING_SET}\n+\n+    public final SelectorDataType type;\n+\n+    private final Boolean boolValue;\n+    private final Integer intValue;\n+    private final Double doubleValue;\n+    private final String stringValue;\n+\n+    private final Set<String> stringSet;\n+\n+    public SelectorConstant(Boolean boolValue) {\n+        this.type = SelectorDataType.BOOLEAN;\n+        this.boolValue = boolValue;\n+        this.intValue = null;\n+        this.doubleValue = null;\n+        this.stringValue = null;\n+        this.stringSet = null;\n+    }\n+\n+    public SelectorConstant(Integer intValue) {\n+        this.type = SelectorDataType.INT;\n+        this.boolValue = null;\n+        this.intValue = intValue;\n+        this.doubleValue = null;\n+        this.stringValue = null;\n+        this.stringSet = null;\n+    }\n+\n+    public SelectorConstant(Double doubleValue) {\n+        this.type = SelectorDataType.DOUBLE;\n+        this.boolValue = null;\n+        this.intValue = null;\n+        this.doubleValue = doubleValue;\n+        this.stringValue = null;\n+        this.stringSet = null;\n+    }\n+\n+    public SelectorConstant(String stringValue) {\n+        this.type = SelectorDataType.STRING;\n+        this.boolValue = null;\n+        this.intValue = null;\n+        this.doubleValue = null;\n+        this.stringValue = stringValue;\n+        this.stringSet = null;\n+    }\n+\n+    public SelectorConstant(Set<String> stringSet) {\n+        this.type = SelectorDataType.STRING_SET;\n+        this.boolValue = null;\n+        this.intValue = null;\n+        this.doubleValue = null;\n+        this.stringValue = null;\n+        this.stringSet = stringSet;\n+    }\n+\n+    public void addToStringSet(String value) throws ParseException {\n+        if (SelectorDataType.STRING_SET != type)\n+            throw new ParseException(getClass() + \" Attempting to add to a non-string_list type : \" + type);\n+        if (null == this.stringSet) throw new ParseException(getClass() +\n+            \" Attempting to add to a null string_list : \" + stringSet);\n+        this.stringSet.add(value);\n+    }\n+\n+    public boolean isNull() {\n+        switch (type) {\n+            case BOOLEAN:\n+                return null == boolValue;\n+            case INT:\n+                return null == intValue;\n+            case DOUBLE:\n+                return null == doubleValue;\n+            case STRING:\n+                return null == stringValue;\n+            case STRING_SET:\n+                return null == stringSet;\n+            default:\n+                throw new IllegalStateException(getClass() + \" Unknown type ? \" + type);\n+        }\n+    }\n+\n+    public boolean isTrue() throws SelectorEvaluationException {\n+        switch (type) {\n+            case BOOLEAN:\n+                return null != boolValue && Boolean.TRUE.equals(boolValue);\n+            default:\n+                throw new SelectorEvaluationException(getClass() + \" Unexpected type \" + type +\n+                    \", value \" + getValueAsString());\n+        }\n+    }\n+\n+    public String getValueAsString() throws SelectorEvaluationException {\n+        switch (type) {\n+            case BOOLEAN:\n+                return Boolean.toString(boolValue);\n+            case INT:\n+                return Integer.toString(intValue);\n+            case DOUBLE:\n+                return Double.toString(doubleValue);\n+            case STRING:\n+                return stringValue;\n+            case STRING_SET:\n+                return null != stringSet ? stringSet.toString() : \"null\";\n+            default:\n+                throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" + type);\n+        }\n+    }\n+\n+    public String toString() {\n+        try {\n+            switch (type) {\n+                case BOOLEAN:\n+                    return \"boolean : \" + getValueAsString();\n+                case INT:\n+                    return \"int : \" + getValueAsString();\n+                case DOUBLE:\n+                    return \"double : \" + getValueAsString();\n+                case STRING:\n+                    return \"string : \" + getValueAsString();\n+                case STRING_SET:\n+                    return \"string_list : \" + getValueAsString();\n+                default:\n+                    throw new IllegalStateException(getClass() + \" Unexpected type\");\n+            }\n+        } catch (SelectorEvaluationException seEx) {\n+            throw new IllegalStateException(getClass() + \" Unexpected exception\", seEx);\n+        }\n+    }\n+\n+    public Boolean getBoolValue() throws SelectorEvaluationException {\n+        if (SelectorDataType.BOOLEAN != type)\n+            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n+        return boolValue;\n+    }\n+\n+    public Integer getIntValue() throws SelectorEvaluationException {\n+        if (SelectorDataType.INT != type)\n+            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n+        return intValue;\n+    }\n+\n+    public Double getDoubleValue() throws SelectorEvaluationException {\n+        if (SelectorDataType.DOUBLE != type)\n+            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n+        return doubleValue;\n+    }\n+\n+    public String getStringValue() throws SelectorEvaluationException {\n+        if (SelectorDataType.STRING != type)\n+            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n+        return stringValue;\n+    }\n+\n+    public Set<String> getStringSet() throws SelectorEvaluationException {\n+        if (SelectorDataType.STRING_SET != type)\n+            throw new SelectorEvaluationException(getClass() + \" Illegal access to boolean for type \" + type);\n+        // wrap to prevent changes ...\n+        return Collections.unmodifiableSet(stringSet);\n+    }\n+}"},{"sha":"d760e0c8c69830d916de7f962f914c7c335211d6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvalState.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+/**\n+ * Holds (any) state data required to evaluate a Selector.\n+ */\n+public class SelectorEvalState {\n+    private final MessageImpl message;\n+    private final Deque<SelectorConstant> stack;\n+\n+    // Used ONLY for debugging ... it is sad that this is part of SelectorEvalState - but I dont\n+    // have time to do anything else right now !\n+    private int debugIndentCount = 0;\n+\n+    public SelectorEvalState(MessageImpl message) {\n+        this.message = message;\n+        this.stack = new ArrayDeque<SelectorConstant>(32);\n+    }\n+\n+    public MessageImpl getMessage() {\n+        return message;\n+    }\n+\n+    public Deque<SelectorConstant> getStack() {\n+        return stack;\n+    }\n+\n+    public int getDebugIndentCount() {\n+        return debugIndentCount;\n+    }\n+\n+    public void setDebugIndentCount(int debugIndentCount) {\n+        this.debugIndentCount = debugIndentCount;\n+    }\n+}"},{"sha":"7425189e99231bda7410d68e438f007e66f5bad2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/SelectorEvaluationException.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+/**\n+ * Thrown when evaluating a selector.\n+ */\n+public class SelectorEvaluationException extends Exception {\n+\n+    public SelectorEvaluationException() {\n+    }\n+\n+    public SelectorEvaluationException(String message) {\n+        super(message);\n+    }\n+\n+    public SelectorEvaluationException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public SelectorEvaluationException(Throwable cause) {\n+        super(cause);\n+    }\n+}"},{"sha":"dedda05f4d77f6ccd9505c223a1e01012ce2cc57","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/TreeDumperSelectorParserVisitor.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+/**\n+ * To dump the AST - used ONLY for debugging\n+ */\n+public class TreeDumperSelectorParserVisitor implements SelectorParserVisitor{\n+\n+    private static final int INDENT_PER_LEVEL = 4;\n+\n+    private static void emitDebug(SimpleNode node, SelectorEvalState data, boolean start)\n+        throws SelectorEvaluationException {\n+\n+        if (!start && 0 == node.jjtGetNumChildren()) return ;\n+\n+        final StringBuilder sb = new StringBuilder();\n+        int count = data.getDebugIndentCount();\n+        for (int i = 0;i < count * INDENT_PER_LEVEL; i ++){\n+            sb.append(' ');\n+        }\n+\n+        sb.append(node.getClass().getName()).append(\" -> \").append(node);\n+        sb.append(\", Constant -> \").append(node.getConstantValueInternal());\n+        sb.append(\", Func -> \").append(node.getExprFunctionInternal());\n+        if (0 != node.jjtGetNumChildren()) sb.append(start ? \" OPEN\" : \" CLOSE\");\n+\n+        MyNode.logger.trace(sb.toString());\n+    }\n+\n+    @Override\n+    public Object visit(SimpleNode node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTOrExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTAndExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNotExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTGreaterThan node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLessThan node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLessThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTGreaterThanEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNotEqualTo node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTIsNullExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTBetweenExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTInExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLikeExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTAddExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTSubExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTDivideExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTMultiplyExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTNegateExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTLookupExpr node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        data.setDebugIndentCount(data.getDebugIndentCount() + 1);\n+        node.childrenAccept(this, data);\n+        data.setDebugIndentCount(data.getDebugIndentCount() - 1);\n+        emitDebug(node, data, false);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTConstant node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n+            \" parse error ? \" + node);\n+        return null;\n+    }\n+\n+    @Override\n+    public Object visit(ASTStringVarargParams node, SelectorEvalState data) throws SelectorEvaluationException {\n+        emitDebug(node, data, true);\n+        if (0 != node.jjtGetNumChildren()) throw new SelectorEvaluationException(getClass() +\n+            \" parse error ? \" + node);\n+        return null;\n+    }\n+}"},{"sha":"59170e7944e00ad9e0fbad0c3627a133e778a213","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryArithmeticFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,73 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Unary arithematic operations\n+ */\n+public abstract class UnaryArithmeticFunction implements ExprFunction {\n+\n+    public static final UnaryArithmeticFunction NEGATE_FUNCTION = new UnaryArithmeticFunction() {\n+\n+        @Override\n+        protected SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n+            throws SelectorEvaluationException {\n+\n+            switch (value.type) {\n+                case INT: {\n+                    Integer val = value.getIntValue();\n+                    if (null == val) return new SelectorConstant((Integer) null);\n+                    return new SelectorConstant(-(int) val);\n+                }\n+                case DOUBLE: {\n+                    Double val = value.getDoubleValue();\n+                    if (null == val) return new SelectorConstant((Double) null);\n+                    return new SelectorConstant(-(double) val);\n+                }\n+                default:\n+                    throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + value);\n+            }\n+        }\n+    };\n+\n+    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+        if (state.getStack().size() < 1)\n+            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+\n+        SelectorConstant value = state.getStack().pop();\n+\n+        SelectorConstant result = evaluateImpl(value, state.getMessage());\n+\n+        if (null != result) state.getStack().push(result);\n+        else\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unexpected to return a null response in binary function evaluation\");\n+    }\n+\n+    protected abstract SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n+        throws SelectorEvaluationException;\n+\n+\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"c50514be715db173709a8ce9adc0158e6d453504","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/UnaryExprFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Unary function's.\n+ */\n+public abstract class UnaryExprFunction implements ExprFunction {\n+\n+    public static final UnaryExprFunction NOT_FUNCTION = new UnaryExprFunction() {\n+\n+        @Override\n+        protected SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n+            throws SelectorEvaluationException {\n+            if (SelectorConstant.SelectorDataType.BOOLEAN != value.type) {\n+                throw new SelectorEvaluationException(getClass() + \" Invalid value type ? \" + value);\n+            }\n+\n+            final Boolean boolValue = value.getBoolValue();\n+            final Boolean result = null == boolValue ? null : !boolValue;\n+            return new SelectorConstant(result);\n+        }\n+    };\n+\n+    public void evaluate(SelectorEvalState state) throws SelectorEvaluationException {\n+        if (state.getStack().size() < 1)\n+            throw new SelectorEvaluationException(getClass() + \" stack corruption ? \" + state.getStack());\n+\n+        SelectorConstant value = state.getStack().pop();\n+\n+        SelectorConstant result = evaluateImpl(value, state.getMessage());\n+\n+        if (null != result) state.getStack().push(result);\n+        else\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unexpected to return a null response in binary function evaluation\");\n+    }\n+\n+    protected abstract SelectorConstant evaluateImpl(SelectorConstant value, MessageImpl message)\n+        throws SelectorEvaluationException;\n+\n+\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"24957d374e1786df465588b017e02fb2dfa29bd0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","status":"added","additions":329,"deletions":0,"changes":329,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/ValueComparisonFunction.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,329 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.selector;\n+\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+/**\n+ * Comparison of values ..\n+ */\n+public abstract class ValueComparisonFunction extends BinaryExprFunction {\n+\n+    protected SelectorConstant evaluateImpl(SelectorConstant left, SelectorConstant right,\n+                                            MessageImpl message) throws SelectorEvaluationException {\n+\n+        switch (left.type) {\n+            case INT: {\n+                switch (right.type) {\n+                    case INT:\n+                        return new SelectorConstant(compareWithInt(left.getIntValue(), right.getIntValue()));\n+                    case DOUBLE:\n+                        return new SelectorConstant(compareWithInt(left.getIntValue(), right.getDoubleValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+            case DOUBLE: {\n+                switch (right.type) {\n+                    case INT:\n+                        return new SelectorConstant(compareWithDouble(left.getDoubleValue(), right.getIntValue()));\n+                    case DOUBLE:\n+                        return new SelectorConstant(compareWithDouble(left.getDoubleValue(), right.getDoubleValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+            case BOOLEAN: {\n+                switch (right.type) {\n+                    case BOOLEAN:\n+                        return new SelectorConstant(compareWithBoolean(left.getBoolValue(), right.getBoolValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+\n+            case STRING: {\n+                switch (right.type) {\n+                    case STRING:\n+                        return new SelectorConstant(compareWithString(left.getStringValue(), right.getStringValue()));\n+                    default:\n+                        throw new SelectorEvaluationException(getClass() + \" Unexpected type : \" +\n+                            right.type + \". left : \" + left + \", right : \" + right);\n+                }\n+            }\n+\n+            default:\n+                throw new SelectorEvaluationException(getClass() + \" Unsupported type : \" +\n+                    left.type + \". left : \" + left + \", right : \" + right);\n+        }\n+    }\n+\n+    protected abstract Boolean compareWithInt(Integer left, Double right) throws SelectorEvaluationException;\n+\n+    protected abstract Boolean compareWithInt(Integer left, Integer right) throws SelectorEvaluationException;\n+\n+    protected abstract Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException;\n+\n+    protected abstract Boolean compareWithDouble(Double left, Integer right) throws SelectorEvaluationException;\n+\n+    protected abstract Boolean compareWithString(String left, String right) throws SelectorEvaluationException;\n+\n+    protected abstract Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException;\n+\n+\n+    public static final ValueComparisonFunction GREATER_THAN_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left > right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left > right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left > right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left > (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass()\n+                    + \" Unsupported string comparison for greater_than operator\");\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass()\n+                    + \" Unsupported boolean comparison for greater_than operator\");\n+        }\n+    };\n+\n+\n+    public static final ValueComparisonFunction GREATER_THAN_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left >= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left >= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left >= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left >= (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported string comparison for greater_than operator\");\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported boolean comparison for greater_than operator\");\n+        }\n+    };\n+\n+    public static final ValueComparisonFunction LESS_THAN_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left < right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left < right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left < right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left < (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported string comparison for greater_than operator\");\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported boolean comparison for greater_than operator\");\n+        }\n+    };\n+\n+\n+    public static final ValueComparisonFunction LESS_THAN_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left <= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left <= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left <= right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left <= (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported string comparison for greater_than operator\");\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            throw new SelectorEvaluationException(getClass() +\n+                \" Unsupported boolean comparison for greater_than operator\");\n+        }\n+    };\n+\n+    public static final ValueComparisonFunction EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left == right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return (int) left == right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return (double) left == right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left == (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left.equals(right);\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return left.equals(right);\n+        }\n+    };\n+\n+\n+    public static final ValueComparisonFunction NOT_EQUAL_TO_FUNCTION = new ValueComparisonFunction() {\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Double right) {\n+            if (null == left || null == right) return null;\n+            return (double) left != right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithInt(Integer left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return (int) left != right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Double right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return (double) left != right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithDouble(Double left, Integer right) {\n+            if (null == left || null == right) return null;\n+            return left != (double) right;\n+        }\n+\n+        @Override\n+        protected Boolean compareWithString(String left, String right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return !left.equals(right);\n+        }\n+\n+        @Override\n+        protected Boolean compareWithBoolean(Boolean left, Boolean right) throws SelectorEvaluationException {\n+            if (null == left || null == right) return null;\n+            return !left.equals(right);\n+        }\n+    };\n+\n+\n+\n+    @Override\n+    public String toString(){\n+        return getClass().getName();\n+    }\n+}"},{"sha":"e426eb84cad68b42b5917c5fa703eaac11cb9ef0","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/selector/package-info.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,35 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+\n+Contains implementation of the selector, associated files and interpreter. <br/>\n+This depends on files generated by the grammar at $HEDWIG_CLIENT_JMS/src/main/grammar/javacc/selector_grammar.jjt <br/>\n+<p/>\n+This package depends on message package to pull headers, etc. <br/>\n+<p/>\n+<p/>\n+The code essentially is split into three things :\n+<ul>\n+  <li>Basic implementation of the selector, interpreter and grammar interface code : split between this\n+    package and the generated package (of same name).</li>\n+  <li>State objects, visitor implementation, etc to help evaluate the generated AST based on the message.\n+    MyNode, SelectorConstant, SelectorEvalState, etc.</li>\n+  <li>The functions to evaluate and implement functionality - expose constructs to interpreter to evaluate.\n+    *Function classes.</li>\n+</ul>\n+\n+The code relies heavily on the javacc grammar and the interpreter generated based on it : so please modify with care !"},{"sha":"6ef09704fe04086f8d63175dff6a80c66bbcae82","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionFactoryImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.JMSException;\n+import javax.jms.TopicConnection;\n+import javax.jms.TopicConnectionFactory;\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import javax.naming.Referenceable;\n+import java.io.Serializable;\n+\n+/**\n+ * Implementation of jmx ConnectionFactory\n+ * MUST be MT-safe (2.8)\n+ */\n+public class HedwigConnectionFactoryImpl implements ConnectionFactory, TopicConnectionFactory,\n+    Referenceable, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    @Override\n+    public HedwigConnectionImpl createConnection() throws JMSException {\n+        HedwigConnectionImpl retval = new HedwigConnectionImpl();\n+        return retval;\n+    }\n+\n+    @Override\n+    public HedwigConnectionImpl createConnection(String user, String password) throws JMSException {\n+        HedwigConnectionImpl retval = new HedwigConnectionImpl(user, password);\n+        return retval;\n+    }\n+\n+    @Override\n+    public Reference getReference() throws NamingException {\n+        return new Reference(getClass().getName());\n+    }\n+\n+    @Override\n+    public TopicConnection createTopicConnection() throws JMSException {\n+        return new HedwigConnectionImpl();\n+    }\n+\n+    @Override\n+    public TopicConnection createTopicConnection(String user, String password) throws JMSException {\n+        return new HedwigConnectionImpl(user, password);\n+    }\n+}"},{"sha":"98f4273c6715040f358c35df6036ccfa359ce639","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigConnectionImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.jms.ConnectionImpl;\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.SessionImpl;\n+\n+import javax.jms.JMSException;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+\n+/**\n+ * Returns the hedwig specific functionality of the Connection - which is tied to this spi impl.\n+ * Coupled with HedwigMessagingSessionFacade.\n+ *\n+ */\n+public class HedwigConnectionImpl extends ConnectionImpl {\n+\n+    private ClientConfiguration hedwigClientConfig;\n+\n+    public HedwigConnectionImpl() throws JMSException {\n+        super();\n+        init(getUser(), getPassword());\n+    }\n+\n+    public HedwigConnectionImpl(String user, String password) throws JMSException {\n+        super (user, password);\n+        init(getUser(), getPassword());\n+    }\n+\n+    @Override\n+    protected SessionImpl createSessionInstance(boolean transacted, int acknowledgeMode,\n+                                                MessagingSessionFacade.DestinationType type) throws JMSException {\n+        if (null == type) return new SessionImpl(this, transacted, acknowledgeMode);\n+        switch (type){\n+            case QUEUE:\n+                return new QueueSessionImpl(this, transacted, acknowledgeMode);\n+            case TOPIC:\n+                return new TopicSessionImpl(this, transacted, acknowledgeMode);\n+            default:\n+                throw new JMSException(\"Unknown type \" + type);\n+        }\n+    }\n+\n+    @Override\n+    protected void doStart(String user, String password) throws JMSException {\n+        // noop for now ...\n+    }\n+\n+    protected void init(String user, String password) throws JMSException {\n+        // load to check sanity.\n+        hedwigClientConfig = loadConfig();\n+\n+        // TODO: Set configuration options specified by the user of api - user/passwd/etc.\n+    }\n+\n+    // copied from earlier code ...\n+    private ClientConfiguration loadConfig() throws JMSException {\n+        ClientConfiguration config = new ClientConfiguration();\n+\n+        // TODO: This is not very extensible and useful ... we need to pick the info from\n+        // configuration specified by user, NOT only from static files !\n+        // Also, we need to be able to support multiple configuration in a single client !\n+        // We need a better solution ....\n+\n+        try {\n+            // 1. try to load the client configuration as specified from a\n+            // system property\n+            if (System.getProperty(HEDWIG_CLIENT_CONFIG_FILE) != null) {\n+                File configFile = new File(System.getProperty(HEDWIG_CLIENT_CONFIG_FILE));\n+                if (!configFile.exists()) {\n+                    throw new JMSException(\n+                            \"Cannot create connection: cannot find Hedwig client configuration file specified as [\"\n+                                    + System.getProperty(HEDWIG_CLIENT_CONFIG_FILE) + \"]\");\n+                }\n+                config.loadConf(configFile.toURI().toURL());\n+            } else {\n+                // 2. try to load a \"hedwig-client.cfg\" file from the classpath\n+                config.loadConf(new URL(null, \"classpath://hedwig-client.cfg\", new URLStreamHandler() {\n+                    protected URLConnection openConnection(URL u) throws IOException {\n+                        // rely on the relevant classloader - not system classloader.\n+                        final URL resourceUrl = HedwigConnectionImpl.this.getClass().getClassLoader().\n+                            getResource(u.getPath());\n+                        return resourceUrl.openConnection();\n+                    }\n+                }));\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            JMSException je = new JMSException(\"Cannot load Hedwig client configuration file \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (ConfigurationException e) {\n+            JMSException je = new JMSException(\"Cannot load Hedwig client configuration \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        }\n+\n+        /*\n+        System.out.println(\"getConsumedMessagesBufferSize : \" + config.getConsumedMessagesBufferSize());\n+        System.out.println(\"getDefaultServerHost : \" + config.getDefaultServerHost());\n+        System.out.println(\"isSSLEnabled : \" + config.isSSLEnabled());\n+        System.out.println(\"getMaximumMessageSize : \" + config.getMaximumMessageSize());\n+        System.out.println(\"getMaximumOutstandingMessages : \" + config.getMaximumOutstandingMessages());\n+        System.out.println(\"getMaximumServerRedirects : \"  + config.getMaximumServerRedirects());\n+        System.out.println(\"getServerAckResponseTimeout : \"  + config.getServerAckResponseTimeout());\n+        */\n+\n+        return config;\n+    }\n+\n+    public ClientConfiguration getHedwigClientConfig() {\n+        return hedwigClientConfig;\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        // nothing specific to be done.\n+    }\n+\n+    @Override\n+    protected void doClose(){\n+        // nothing specific to be done.\n+    }\n+\n+    @Override\n+    protected MessagingSessionFacade createMessagingSessionFacade(SessionImpl session) throws JMSException {\n+        return new HedwigMessagingSessionFacade(this, session);\n+    }\n+\n+    @Override\n+    public TopicSessionImpl createTopicSession(boolean transacted, int acknowledgeMode) throws JMSException {\n+        return (TopicSessionImpl) createSessionImpl(transacted, acknowledgeMode,\n+            MessagingSessionFacade.DestinationType.TOPIC);\n+    }\n+\n+    @Override\n+    public QueueSessionImpl createQueueSession(boolean transacted, int acknowledgeMode) throws JMSException {\n+        return (QueueSessionImpl) createSessionImpl(transacted, acknowledgeMode,\n+            MessagingSessionFacade.DestinationType.QUEUE);\n+    }\n+}"},{"sha":"850bb52d47c8e7d5f565b864fcc6a77d2b293a76","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","status":"added","additions":621,"deletions":0,"changes":621,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/HedwigMessagingSessionFacade.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,621 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.InvalidSubscriberIdException;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.DebugUtil;\n+import org.apache.hedwig.jms.message.MessageImpl;\n+import org.apache.hedwig.jms.message.MessageUtil;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.util.Callback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Queue;\n+import javax.jms.QueueBrowser;\n+import javax.jms.QueueReceiver;\n+import javax.jms.QueueSender;\n+import javax.jms.TemporaryQueue;\n+import javax.jms.TemporaryTopic;\n+import javax.jms.Topic;\n+import javax.jms.TopicPublisher;\n+import javax.jms.TopicSubscriber;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+/**\n+ * Implementation of hedwig specific implementation. <br/>\n+ * JMS VIOLATION: This implementation creates a single backend hedwig connection PER session - and\n+ * DOES NOT share multiple sessoins on top of a single connection.\n+ * <p/>\n+ * This is a wilful violation of JMS specification, but exists only because Hedwig does not have\n+ * any notion to support this. <br/>\n+ * Once hedwig does allow for session multiplexing, we will need to revisit this (or create a new impl)\n+ * to take into account the changes.\n+ *\n+ */\n+public class HedwigMessagingSessionFacade implements MessagingSessionFacade, MessageHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(HedwigMessagingSessionFacade.class);\n+\n+            // We simulate noLocal through the connection - which will be shared across sessions.\n+    private final HedwigConnectionImpl connection;\n+    private final SessionImpl session;\n+    private HedwigClient hedwigClient;\n+    private volatile boolean stopped = false;\n+\n+    /*\n+     Hedwig server has a ack-until-N approach to acknoledgements : that is, if we acknowledge message N,\n+     all previous N-1 message are also\n+     acknowledged.\n+     But hedwig-client DOES NOT support this : particularly in context of throttling.\n+\n+     So, when we are in CLIENT_ACKNOWLEDGE mode and NOT in transacted session, I am modifying the behavior\n+     to mirror expectation of both\n+     hedwig client and server here in SessionImpl itself (instead of facade where this probably belong better).\n+\n+     This approach does not seem to work fine due to implicit assumptions in hedwig client ... I am\n+     modifying it in following way :\n+     a) For each message receieved, maintain it in List.\n+     b) Acknowledging a message means traversing this list to find message with same seq-id : and\n+     acknowledge ALL message until that in the list.\n+     Since hedwig does ack until, inctead of individual ack, this violation of JMS spec is consistent with hedwig.\n+     Note that even though hedwig does ack until, hedwig client on other hand DOES NOT ! It will\n+     throttle connection if we do not ack individually ...\n+     sigh :-(\n+      */\n+    private final List<SessionImpl.ReceivedMessage> unAckMessageList = new LinkedList<SessionImpl.ReceivedMessage>();\n+\n+    // Both of these synchronized on deliveryStartInfoSet.\n+    private final Set<DeliveryStartInfo> deliveryStartInfoSet = new HashSet<DeliveryStartInfo>(32);\n+    private final Set<DeliveryStartInfo> subscribeInfoSet = new HashSet<DeliveryStartInfo>(32);\n+\n+    private static final class DeliveryStartInfo {\n+        private final String topicName;\n+        private final String subscriberId;\n+\n+        private DeliveryStartInfo(String subscriberId, String topicName) {\n+            this.subscriberId = subscriberId;\n+            this.topicName = topicName;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            DeliveryStartInfo that = (DeliveryStartInfo) o;\n+\n+            if (subscriberId != null ? !subscriberId.equals(that.subscriberId) : that.subscriberId != null)\n+                return false;\n+            if (topicName != null ? !topicName.equals(that.topicName) : that.topicName != null) return false;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = topicName != null ? topicName.hashCode() : 0;\n+            result = 31 * result + (subscriberId != null ? subscriberId.hashCode() : 0);\n+            return result;\n+        }\n+    }\n+\n+\n+    public HedwigMessagingSessionFacade(HedwigConnectionImpl connection, SessionImpl session) throws JMSException {\n+        this.connection = connection;\n+        this.session = session;\n+        // always create client ...\n+        final ClientConfiguration cfg = connection.getHedwigClientConfig();\n+        if (null == cfg) throw new JMSException(\"Unable to fetch client config ?\");\n+        this.hedwigClient = new HedwigClient(cfg);\n+        resetStartInfoSet();\n+    }\n+\n+    @Override\n+    public void start() throws JMSException {\n+        if (!connection.isInStartMode()) throw new JMSException(\"Connection not yet started ?\");\n+        if (logger.isTraceEnabled()) logger.trace(\"Creating HedwigClient\");\n+        // create only if there is need for it.\n+        if (null == this.hedwigClient) {\n+            this.hedwigClient = new HedwigClient(connection.getHedwigClientConfig());\n+            resetStartInfoSet();\n+        }\n+        this.stopped = false;\n+    }\n+\n+    @Override\n+    public void stop() {\n+        // stopping does not inhibit send.\n+        if (logger.isTraceEnabled()) logger.trace(\"Stopping HedwigClient\");\n+        /*\n+        HedwigClient client = this.hedwigClient;\n+        this.hedwigClient = null;\n+        client.close();\n+        */\n+        this.stopped = true;\n+    }\n+\n+\n+    @Override\n+    public void close() {\n+        HedwigClient client = this.hedwigClient;\n+        resetStartInfoSet();\n+\n+        this.stopped = true;\n+        this.hedwigClient = null;\n+        if (logger.isTraceEnabled()) logger.trace(\"Closing HedwigClient\");\n+        client.close();\n+    }\n+\n+    private void resetStartInfoSet(){\n+        synchronized (deliveryStartInfoSet){\n+            deliveryStartInfoSet.clear();\n+            subscribeInfoSet.clear();\n+        }\n+    }\n+\n+    @Override\n+    public DestinationType findDestinationType(String destination) throws JMSException {\n+        // TODO: For now, we support ONLY topic's, so always returning that.\n+        return DestinationType.TOPIC;\n+    }\n+\n+    @Override\n+    public DestinationType findDestinationType(Destination destination) throws JMSException {\n+        if (destination instanceof Topic) return DestinationType.TOPIC;\n+        if (destination instanceof Queue) return DestinationType.QUEUE;\n+\n+        // TODO: For now, we support ONLY topic's, so always returning that when unknown.\n+        return DestinationType.TOPIC;\n+    }\n+\n+    @Override\n+    public TopicPublisher createTopicPublisher(Destination destination) throws JMSException {\n+        return new TopicPublisherImpl(this, session, null != destination ?\n+            session.createTopic(session.toName(destination)) : null);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createTopicSubscriber(Destination destination) throws JMSException {\n+        session.subscriberCreated();\n+        connection.initConnectionClientID();\n+        return new TopicSubscriberImpl(session, session.createTopic(session.toName(destination)),\n+                session.createSubscriberId(SessionImpl.generateRandomString()), true);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createTopicSubscriber(Destination destination,\n+                                                 String messageSelector, boolean noLocal) throws JMSException {\n+        session.subscriberCreated();\n+        connection.initConnectionClientID();\n+        return new TopicSubscriberImpl(session,\n+                session.createTopic(session.toName(destination)),\n+                session.createSubscriberId(SessionImpl.generateRandomString()), messageSelector, noLocal, true);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n+        if (null != session.getMessageListener()) {\n+            throw new JMSException(\"Message listener is set - not other form of message receipt can be used\");\n+        }\n+        session.subscriberCreated();\n+\n+        TopicSubscriberImpl subscriber = new TopicSubscriberImpl(session, topic, subscribedId, false);\n+        subscriber.start();\n+        return subscriber;\n+    }\n+\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId,\n+                                                   String messageSelector, boolean noLocal) throws JMSException {\n+        if (null != session.getMessageListener()) {\n+            throw new JMSException(\"Message listener is set - not other form of message receipt can be used\");\n+        }\n+        session.subscriberCreated();\n+        connection.initConnectionClientID();\n+\n+        return new TopicSubscriberImpl(session, topic, subscribedId, messageSelector, noLocal, false);\n+    }\n+\n+    /*\n+    @Override\n+    public void unsubscribe(String subscriberId) throws JMSException {\n+        throw new JMSException(\"Hedwig requires BOTH topic name and subscriberId to unsubscribe -\n+        unlike JMS. Need to figure this out.\");\n+    }\n+    */\n+\n+    // Note: order SENSITIVE !!\n+    @Override\n+    public void registerUnAcknowledgedMessage(SessionImpl.ReceivedMessage message) {\n+        synchronized (unAckMessageList){\n+            unAckMessageList.add(message);\n+        }\n+    }\n+\n+    @Override\n+    // public void acknowledge(String topicName, String subscriberId, String jmsMessageID)\n+    public void acknowledge(MessageImpl message) throws JMSException {\n+        if (this.stopped || null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in stopped or closed state, cant acknowledge message\");\n+\n+        /*\n+         This approach does not seem to work fine due to implicit assumptions in hedwig client ...\n+         I am modifying it in following way :\n+         a) For each message receieved, maintain it in List.\n+         b) Acknowledging a message means traversing this list to find message with same seq-id :\n+         and acknowledge ALL message until that in the list.\n+         Since hedwig does ack until, inctead of individual ack, this violation of JMS spec is consistent with hedwig.\n+         Note that even though hedwig does ack until, hedwig client on other hand DOES NOT ! It will\n+          throttle connection if we do not ack individually ...\n+         sigh :-(\n+          */\n+        // sendAcknowledge(topicName, subscriberId, seqId);\n+\n+        LinkedList<SessionImpl.ReceivedMessage> ackList = new LinkedList<SessionImpl.ReceivedMessage>();\n+        synchronized (unAckMessageList){\n+            // Should I simply copy and release ?\n+            ListIterator<SessionImpl.ReceivedMessage> iter = unAckMessageList.listIterator();\n+\n+            boolean found = false;\n+            while (iter.hasNext()){\n+                if (iter.next().originalMessage.getServerJmsMessageId().equals(message.getServerJmsMessageId())){\n+                    found = true;\n+                    break;\n+                }\n+            }\n+\n+            // probably already acknowledged ?\n+            if (!found) return ;\n+            while (iter.hasPrevious()){\n+                ackList.addFirst(iter.previous());\n+                iter.remove();\n+            }\n+        }\n+\n+        // Now acknowledge the messages in ackList by running its runnable.\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"facade acknowledge ackList (\" + ackList.size() + \") ... \" + ackList);\n+        }\n+        for (SessionImpl.ReceivedMessage msg : ackList){\n+            try {\n+                msg.originalMessage.getAckRunnable().run();\n+            } catch (Exception ex){\n+                // Ignore any exception thrown.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Ignoring exception thrown while acknowledging messages\", ex);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    private void sendAcknowledge(String topicName, String subscriberId, PubSubProtocol.MessageSeqId seqId)\n+        throws JMSException {\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Acknowledging \" +\n+            MessageUtil.generateJMSMessageIdFromSeqId(seqId) + \" for \" + topicName + \" by \" + subscriberId);\n+        try {\n+            hedwigClient.getSubscriber().consume(ByteString.copyFromUtf8(topicName),\n+                ByteString.copyFromUtf8(subscriberId), seqId);\n+        } catch (PubSubException.ClientNotSubscribedException e) {\n+            JMSException jEx = new JMSException(\"Client not subscribed .. \" + e);\n+            jEx.setLinkedException(e);\n+            throw jEx;\n+        }\n+    }\n+\n+\n+    public void subscribeToTopic(String topicName, String subscribedId) throws JMSException {\n+        if (null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in closed state, cant subscribe to topic \" + topicName);\n+\n+        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n+        final boolean start;\n+        synchronized (deliveryStartInfoSet){\n+            start =  ! subscribeInfoSet.contains(info);\n+\n+            if (start) {\n+                subscribeInfoSet.add(info);\n+            }\n+        }\n+\n+        if (! start) {\n+            if (logger.isDebugEnabled()) logger.debug(\"Client already subscribed ?\");\n+            return ;\n+        }\n+\n+        try {\n+            hedwigClient.getSubscriber().subscribe(ByteString.copyFromUtf8(topicName),\n+                    ByteString.copyFromUtf8(subscribedId),\n+                PubSubProtocol.SubscribeRequest.CreateOrAttach.CREATE_OR_ATTACH);\n+        } catch (PubSubException.CouldNotConnectException e) {\n+            JMSException je = new JMSException(\"receive failed, could not connect .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (PubSubException.ClientAlreadySubscribedException e) {\n+            JMSException je = new JMSException(\"receive failed, already subscribed .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (PubSubException.ServiceDownException e) {\n+            JMSException je = new JMSException(\"receive failed, hedwig service down .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (InvalidSubscriberIdException e) {\n+            JMSException je = new JMSException(\"receive failed, invalid subscriber .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        }\n+    }\n+\n+    public void unsubscribeFromTopic(String topicName, String subscribedId) throws JMSException {\n+        if (null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n+\n+        // Also implies removal of delivery, right ?\n+        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n+        synchronized (deliveryStartInfoSet){\n+            deliveryStartInfoSet.remove(info);\n+            subscribeInfoSet.remove(info);\n+        }\n+\n+        try {\n+            hedwigClient.getSubscriber().unsubscribe(ByteString.copyFromUtf8(topicName),\n+                ByteString.copyFromUtf8(subscribedId));\n+        } catch (PubSubException.CouldNotConnectException e) {\n+            JMSException je = new JMSException(\"receive failed, could not connect .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (PubSubException.ServiceDownException e) {\n+            JMSException je = new JMSException(\"receive failed, hedwig service down .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (InvalidSubscriberIdException e) {\n+            JMSException je = new JMSException(\"receive failed, invalid subscriber .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        } catch (PubSubException.ClientNotSubscribedException e) {\n+            JMSException je = new JMSException(\"receive failed, client not subscribed .. \" + e);\n+            je.setLinkedException(e);\n+            throw je;\n+        }\n+    }\n+\n+    public void stopTopicDelivery(String topicName, String subscribedId) throws JMSException {\n+        if (null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n+\n+        DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n+        synchronized (deliveryStartInfoSet){\n+            deliveryStartInfoSet.remove(info);\n+        }\n+\n+        try {\n+            hedwigClient.getSubscriber().stopDelivery(ByteString.copyFromUtf8(topicName),\n+                ByteString.copyFromUtf8(subscribedId));\n+        } catch (PubSubException.ClientNotSubscribedException e) {\n+            if (logger.isTraceEnabled()) logger.trace(\"Client not subscribed or already unsubscribed ? \", e);\n+        }\n+    }\n+\n+    public void startTopicDelivery(String topicName, String subscribedId) throws JMSException {\n+        if (null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n+\n+        final DeliveryStartInfo info = new DeliveryStartInfo(topicName, subscribedId);\n+        final boolean start;\n+        synchronized (deliveryStartInfoSet){\n+            start =  ! deliveryStartInfoSet.contains(info);\n+\n+            if (start) {\n+                deliveryStartInfoSet.add(info);\n+            }\n+        }\n+\n+        if (! start) {\n+            if (logger.isDebugEnabled()) logger.debug(\"Client already started delivery ?\");\n+            return ;\n+        }\n+\n+        try {\n+            if (logger.isTraceEnabled()) logger.trace(\"Start topic delivery for \" + topicName +\n+                \", subscriberId \" + subscribedId);\n+            hedwigClient.getSubscriber().startDelivery(ByteString.copyFromUtf8(topicName),\n+                ByteString.copyFromUtf8(subscribedId), this);\n+            if (logger.isTraceEnabled()) logger.trace(\"Start topic delivery for \" + topicName +\n+                \", subscriberId \" + subscribedId + \" DONE\");\n+        } catch (PubSubException.ClientNotSubscribedException e) {\n+            if (logger.isDebugEnabled()) logger.debug(\"Client not subscribed or already unsubscribed ? \", e);\n+        } catch (AlreadyStartDeliveryException e) {\n+            if (logger.isDebugEnabled()) logger.debug(\"Client already started delivery ? \", e);\n+        }\n+    }\n+\n+    @Override\n+    public void deliver(ByteString topic, ByteString subscriberId, PubSubProtocol.Message msg,\n+                        final Callback<Void> callback, final Object context) {\n+        // Deliver the message to the session.\n+\n+        if (this.stopped) {\n+            if (logger.isDebugEnabled()) logger.debug(\"Ignoring message while in stopped mode .. topic - \" +\n+                topic.toStringUtf8() + \", subscriber - \" + subscriberId.toStringUtf8() + \", msg - \" + msg);\n+            return ;\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"recieved message from server : topic - \" +\n+                topic.toStringUtf8() + \", subscriber - \" + subscriberId.toStringUtf8() + \", msg - \" + msg);\n+\n+        // I am assuming that we can defer the acknowledgement of the message ...\n+        final String topicName = topic.toStringUtf8();\n+        final String sid = subscriberId.toStringUtf8();\n+        final PubSubProtocol.MessageSeqId seqId = msg.getMsgId();\n+        final Runnable ack = new Runnable(){\n+            public void run() {\n+                callback.operationFinished(context, null);\n+                // Only when auto-send is NOT enabled.\n+                if (! connection.getHedwigClientConfig().isAutoSendConsumeMessageEnabled()) {\n+                    try {\n+                        sendAcknowledge(topicName, sid, seqId);\n+                    } catch (JMSException e) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Unable to send acknowledgement ... \" + topicName + \", \" +\n+                                sid + \", seqId : \" + seqId);\n+                            DebugUtil.dumpJMSStacktrace(logger, e);\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        try {\n+            if (logger.isTraceEnabled()) logger.trace(\"Pushing to session \" + session);\n+\n+            MessageImpl messageImpl = MessageUtil.processHedwigMessage(session, msg, topicName, sid, ack);\n+            session.messageReceived(messageImpl, DestinationType.TOPIC);\n+        } catch (JMSException e) {\n+            // Unable to process the incoming message - log and ignore ?\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Unable to consume message\");\n+                DebugUtil.dumpJMSStacktrace(logger, e);\n+            }\n+        }\n+    }\n+\n+    public String getSubscriberId(TopicSubscriber topicSubscriber) throws JMSException {\n+        if (! (topicSubscriber instanceof TopicSubscriberImpl) )\n+          throw new JMSException(\"TopicSubscriber not instanceof of TopicSubscriberImpl ? \" +\n+              topicSubscriber.getClass());\n+\n+        return ((TopicSubscriberImpl) topicSubscriber).getSubscriberId();\n+    }\n+\n+    @Override\n+    public boolean enqueueReceivedMessage(MessageConsumer messageConsumer, SessionImpl.ReceivedMessage receivedMessage,\n+                                          boolean addFirst) throws JMSException {\n+        if (! (messageConsumer instanceof TopicSubscriberImpl) )\n+          throw new JMSException(\"TopicSubscriber not instanceof of TopicSubscriberImpl ? \" +\n+              messageConsumer.getClass());\n+\n+        return ((TopicSubscriberImpl) messageConsumer).enqueueReceivedMessage(receivedMessage, addFirst);\n+    }\n+\n+    public Publisher getPublisher() throws javax.jms.IllegalStateException {\n+        if (null == hedwigClient)\n+          throw new javax.jms.IllegalStateException(\"session in closed state, cant acknowledge message\");\n+        return hedwigClient.getPublisher();\n+    }\n+\n+    public String publish(String topicName, MessageImpl message) throws JMSException {\n+        try {\n+            PubSubProtocol.PublishResponse response = getPublisher().publish(\n+                ByteString.copyFromUtf8(topicName), message.generateHedwigMessage());\n+            PubSubProtocol.MessageSeqId seqId =\n+                (null != response && response.hasPublishedMsgId() ? response.getPublishedMsgId() : null);\n+            if (null == seqId){\n+                // if (logger.isDebugEnabled())\n+                // logger.debug(\"Unexpected NOT to receive the sequence id in response to publish \" + response);\n+                logger.warn(\"Unexpected NOT to receive the sequence id in response to publish \" + response);\n+                return null;\n+            }\n+\n+            return MessageUtil.generateJMSMessageIdFromSeqId(seqId);\n+        } catch (PubSubException.CouldNotConnectException e) {\n+            JMSException jmsEx = new JMSException(\"Cant publish to \" + topicName + \" .. \" + e);\n+            jmsEx.setLinkedException(e);\n+            throw jmsEx;\n+        } catch (PubSubException.ServiceDownException e) {\n+            JMSException jmsEx = new JMSException(\"Cant publish to \" + topicName + \" .. \" + e);\n+            jmsEx.setLinkedException(e);\n+            throw jmsEx;\n+        }\n+    }\n+\n+    // Queue methods which are NOT supported yet.\n+    @Override\n+    public QueueSender createQueueSender(Destination destination) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public QueueReceiver createQueueReceiver(Destination destination) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public QueueReceiver createQueueReceiver(Destination destination, String messageSelector,\n+                                             boolean noLocal) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public String getSubscriberId(QueueReceiver queueReceiver) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public void stopQueueDelivery(String queueName, String subscribedId) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public void startQueueDelivery(String queueName, String subscriberId) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public TemporaryTopic createTemporaryTopic() throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+    @Override\n+    public TemporaryQueue createTemporaryQueue() throws JMSException {\n+        throw new JMSException(\"hedwig does not support queues yet\");\n+    }\n+\n+}"},{"sha":"a13e259eeb6d4974e6d1d837baebe38f961cd875","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageConsumerImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.selector.Node;\n+import org.apache.hedwig.jms.selector.ParseException;\n+import org.apache.hedwig.jms.selector.SelectorParser;\n+\n+import javax.jms.InvalidSelectorException;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+\n+/**\n+ * Base class for consumers ...\n+ */\n+public abstract class MessageConsumerImpl implements MessageConsumer {\n+    private final String messageSelector;\n+    private final Node selectorAst;\n+    // volatile to prevent need to lock and ensure visibility of mods across threads.\n+    private volatile MessageListener messageListener;\n+\n+    protected MessageConsumerImpl(String msgSelector) throws InvalidSelectorException {\n+        {\n+            msgSelector = null != msgSelector ? msgSelector.trim() : null;\n+            this.messageSelector = (null == msgSelector || 0 == msgSelector.length()) ?\n+                null : msgSelector;\n+        }\n+        try {\n+            this.selectorAst = null == this.messageSelector ?\n+                null : SelectorParser.parseMessageSelector(this.messageSelector);\n+        } catch (ParseException pEx) {\n+            InvalidSelectorException jmsEx =\n+                new InvalidSelectorException(\"Unable to parse selector '\" + this.messageSelector + \"'\");\n+            jmsEx.setLinkedException(pEx);\n+            throw jmsEx;\n+        }\n+    }\n+\n+    @Override\n+    public String getMessageSelector() {\n+        return messageSelector;\n+    }\n+\n+    public Node getSelectorAst() {\n+        return selectorAst;\n+    }\n+\n+    @Override\n+    public MessageListener getMessageListener() {\n+        return messageListener;\n+    }\n+\n+    @Override\n+    public void setMessageListener(MessageListener messageListener) throws JMSException {\n+        this.messageListener = messageListener;\n+    }\n+\n+}"},{"sha":"caf4b3e316804e7355f21ced76d3083abbcfb8e6","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/MessageProducerImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,117 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.SessionImpl;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.JMSException;\n+import javax.jms.MessageProducer;\n+\n+/**\n+ *\n+ */\n+public abstract class MessageProducerImpl implements MessageProducer {\n+\n+    static final int DEFAULT_PRIORITY = 4;\n+\n+    private final SessionImpl session;\n+\n+    // We dont really use this - since we always populate message-id : found in response of publish.\n+    private boolean disableMessageID = false;\n+    // We can support this, but dont - will overly complicate some aspects of the code : deferring for now\n+    // (we will need to pass this around along all failure paths).\n+    private boolean disableMessageTimestamp = false;\n+    // Hedwig supports only PERSISTENT mode, so setting to anytihng else will just cause it to be ignored.\n+    private int deliveryMode = DeliveryMode.PERSISTENT;\n+    // Hedwig does not support priorities, so everything is at default priority !\n+    // this does not influence actual message delivery.\n+    private int defaultPriority = DEFAULT_PRIORITY;\n+    // Hedwig does not support TTL (iirc), so we allow setting/querying this, but it has no\n+    // actual impact on the message delivery/expiry.\n+    private long timeToLive = 0;\n+\n+    protected MessageProducerImpl(SessionImpl session) {\n+        this.session = session;\n+    }\n+\n+    @Override\n+    public void setDisableMessageID(boolean disableMessageID) throws JMSException {\n+        this.disableMessageID = disableMessageID;\n+    }\n+\n+    @Override\n+    public boolean getDisableMessageID() throws JMSException {\n+        return disableMessageID;\n+    }\n+\n+    protected SessionImpl getSession() {\n+        return session;\n+    }\n+\n+\n+    @Override\n+    public void setDisableMessageTimestamp(boolean disableMessageTimestamp) throws JMSException {\n+        this.disableMessageTimestamp = disableMessageTimestamp;\n+    }\n+\n+    @Override\n+    public boolean getDisableMessageTimestamp() throws JMSException {\n+        return disableMessageTimestamp;\n+    }\n+\n+    @Override\n+    public void setDeliveryMode(int deliveryMode) throws JMSException {\n+        if (DeliveryMode.NON_PERSISTENT != deliveryMode &&\n+            DeliveryMode.PERSISTENT != deliveryMode) {\n+            throw new JMSException(\"Invalid delivery mode specified : \" + deliveryMode);\n+        }\n+\n+        // if (DeliveryMode.NON_PERSISTENT == deliveryMode)\n+        // throw new JMSException(\"non-persistent delivery mode is not yet supported\");\n+        this.deliveryMode = deliveryMode;\n+    }\n+\n+    @Override\n+    public int getDeliveryMode() throws JMSException {\n+        return deliveryMode;\n+    }\n+\n+\n+    @Override\n+    public void setPriority(int defaultPriority) throws JMSException {\n+        // Not supported, we simply allow it to be set and retrieved ...\n+        this.defaultPriority = defaultPriority;\n+    }\n+\n+    @Override\n+    public int getPriority() throws JMSException {\n+        return defaultPriority;\n+    }\n+\n+\n+    @Override\n+    public void setTimeToLive(long timeToLive) throws JMSException {\n+        this.timeToLive = timeToLive;\n+    }\n+\n+    @Override\n+    public long getTimeToLive() throws JMSException {\n+        return timeToLive;\n+    }\n+}"},{"sha":"2beeea753a39889b8d3bf4b415cd5ab4cb2811fc","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/QueueSessionImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.ConnectionImpl;\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.SessionImpl;\n+\n+import javax.jms.JMSException;\n+import javax.jms.Queue;\n+import javax.jms.QueueReceiver;\n+import javax.jms.QueueSender;\n+import javax.jms.QueueSession;\n+import javax.jms.TemporaryTopic;\n+import javax.jms.Topic;\n+import javax.jms.TopicSubscriber;\n+\n+/**\n+ * Queue specific impl\n+ */\n+public class QueueSessionImpl extends SessionImpl implements QueueSession {\n+\n+    public QueueSessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n+        super(connection, transacted, acknowledgeMode);\n+    }\n+\n+    @Override\n+    public QueueReceiver createReceiver(Queue queue) throws JMSException {\n+        return super.createReceiverImpl(queue);\n+    }\n+\n+    @Override\n+    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n+        return super.createReceiverImpl(queue, messageSelector);\n+    }\n+\n+    @Override\n+    public QueueSender createSender(Queue queue) throws JMSException {\n+        return super.createSenderImpl(queue);\n+    }\n+\n+    // JMS requires these methods cant be called on QueueSession.\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n+    }\n+\n+    @Override\n+    public TopicSubscriber createDurableSubscriber(Topic topic, String subscribedId, String messageSelector,\n+                                                   boolean noLocal) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n+    }\n+\n+    @Override\n+    public TemporaryTopic createTemporaryTopic() throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n+    }\n+\n+    @Override\n+    public void unsubscribe(String subscribedId) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n+    }\n+\n+  @Override\n+    public Topic createTopic(String topicName) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on QueueSession\");\n+    }\n+}"},{"sha":"982bf9522ba488437d90b08f18cba452d3a3be7d","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicPublisherImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,226 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.message.MessageImpl;\n+import org.apache.hedwig.jms.message.MessageUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.InvalidDestinationException;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.Topic;\n+import javax.jms.TopicPublisher;\n+\n+/**\n+ *\n+ */\n+public class TopicPublisherImpl extends MessageProducerImpl implements TopicPublisher {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TopicPublisherImpl.class);\n+\n+    private final HedwigMessagingSessionFacade facade;\n+    private final Topic topic;\n+\n+    public TopicPublisherImpl(HedwigMessagingSessionFacade facade, SessionImpl session, Topic topic) {\n+        super(session);\n+        this.facade = facade;\n+        this.topic = topic;\n+    }\n+\n+    @Override\n+    public Topic getTopic() throws JMSException {\n+        return topic;\n+    }\n+\n+    @Override\n+    public void publish(Message message) throws JMSException {\n+        if (null == getTopic()) throw new UnsupportedOperationException(\"Need to specify topic\");\n+        publish(getTopic(), message);\n+    }\n+\n+    @Override\n+    public void publish(Topic topic, Message message) throws JMSException {\n+        publish(topic, message, getDeliveryMode(), getPriority(), getTimeToLive());\n+    }\n+\n+    @Override\n+    public void publish(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {\n+        if (null == getTopic()) throw new UnsupportedOperationException(\"Need to specify topic\");\n+        publish(getTopic(), message, deliveryMode, priority, timeToLive);\n+    }\n+\n+    // all publish/send methods delegate to this ...\n+    @Override\n+    public void publish(final Topic topic, final Message message, final int deliveryMode,\n+                        final int priority, final long timeToLive) throws JMSException {\n+\n+        // Simulating this in provider ...\n+        // if (0 != timeToLive) throw new JMSException(\"We do not support TTL for messages right now.\n+        // Specified TTL : \" + timeToLive);\n+\n+        if (MessageProducerImpl.DEFAULT_PRIORITY != priority) {\n+            if (logger.isInfoEnabled())\n+              logger.info(\"We do not support message priorities right now. Specified priority : \" + priority);\n+        }\n+        if (DeliveryMode.PERSISTENT != deliveryMode) {\n+            if (logger.isInfoEnabled())\n+              logger.info(\"We support only PERSISTENT delivery mode. Unsupported mode : \" + deliveryMode);\n+        }\n+\n+        if (null == topic){\n+            throw new InvalidDestinationException(\"Topic must be specified to publish \" + topic);\n+        }\n+\n+        final MessageImpl copiedMessageImpl;\n+        if (message instanceof MessageImpl) copiedMessageImpl = MessageUtil.createCloneForDispatch(\n+            getSession(), (MessageImpl) message, topic.getTopicName(), null);\n+        else copiedMessageImpl = MessageUtil.createMessageCopy(getSession(), message);\n+\n+        // Note: Ensure that we set properties below on both message (user input) and copiedMessageImpl\n+        // (the cloned/copied message).\n+        // We are doing set on both instead of set followed by close/copy to prevent cases where message\n+        // implementation drops\n+        // headers (like our own impl earlier !)\n+\n+        // priority ...\n+        {\n+            // Set the message priority\n+            // 3.4.10 JMSPriority \"When a message is sent, this field is ignored. After completion of\n+            // the send, it holds the value specified by the method sending the message.\"\n+            // On other hand, we have\n+            // 3.4.12 Overriding Message Header Fields : \"JMS permits an administrator to configure\n+            // JMS to override the client-specified\n+            // values for JMSDeliveryMode, JMSExpiration and JMSPriority. If this is done, the header\n+            // field value must reflect the\n+            // administratively specified value.\"\n+            // For now, to unblock testcases, setting to msgPriority :-) Actually, I think we should\n+            // set it to Message.DEFAULT_PRIORITY ...\n+            message.setJMSPriority(priority);\n+            copiedMessageImpl.setJMSPriority(priority);\n+            // message.setJMSPriority(Message.DEFAULT_PRIORITY);\n+            // copiedMessageImpl.setJMSPriority(Message.DEFAULT_PRIORITY);\n+        }\n+\n+        // delivery mode ...\n+        {\n+\n+            // 3.4.2 JMSDeliveryMode \"The JMSDeliveryMode header field contains the delivery mode\n+            // specified when the message was sent.\n+            // When a message is sent, this field is ignored. After completion of the send, it holds\n+            // the delivery mode specified by the sending method.\"\n+            message.setJMSDeliveryMode(deliveryMode);\n+            copiedMessageImpl.setJMSDeliveryMode(deliveryMode);\n+        }\n+\n+        // destination ...\n+        {\n+            // 3.4.1 JMSDestination \"The JMSDestination header field contains the destination to which\n+            // the message is being sent.\n+            // When a message is sent, this field is ignored. After completion of the send, it holds\n+            // the destination object\n+            // specified by the sending method. When a message is received, its destination value\n+            // must be equivalent to the\n+            // value assigned when it was sent.\"\n+            message.setJMSDestination(getSession().createTopic(topic.getTopicName()));\n+            copiedMessageImpl.setJMSDestination(getSession().createTopic(topic.getTopicName()));\n+        }\n+\n+        {\n+            // 3.4.4 JMSTimestamp\n+            // \"The JMSTimestamp header field contains the time a message was handed off to a provider to be sent.\n+            // It is not the time the message was actually transmitted because the actual send may occur later\n+            // due to transactions or other client side queueing of messages.\"\n+            final long timestamp = SessionImpl.currentTimeMillis();\n+            message.setJMSTimestamp(timestamp);\n+            copiedMessageImpl.setJMSTimestamp(timestamp);\n+        }\n+\n+        if (timeToLive > 0) {\n+            final long expiryTime = SessionImpl.currentTimeMillis() + timeToLive;\n+            message.setJMSExpiration(expiryTime);\n+            copiedMessageImpl.setJMSExpiration(expiryTime);\n+        }\n+        else {\n+            // no expiry.\n+            message.setJMSExpiration(0);\n+        }\n+\n+\n+        if (getSession().getTransacted()){\n+            // enqueue if within transactions.\n+            getSession().enqueuePublishWithinTransaction(topic.getTopicName(), copiedMessageImpl, message);\n+            return ;\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Publishing message ... recepient \" + topic.getTopicName());\n+        // facade.getPublisher().publish(ByteString.copyFromUtf8(topic.getTopicName()),\n+        // copiedMessageImpl.generateHedwigMessage(this));\n+        String msgId = facade.publish(topic.getTopicName(), copiedMessageImpl);\n+        getSession().addToLocallyPublishedMessageIds(msgId);\n+        if (message instanceof MessageImpl) ((MessageImpl) message).setJMSMessageIDInternal(msgId);\n+        else message.setJMSMessageID(msgId);\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Publishing message ... recepient \" +\n+            topic.getTopicName() + \", msgId : \" + msgId + \" DONE\");\n+\n+        // This is not required, we already do this as part of copiedMessageImpl.generateHedwigMessage()\n+        // message.setJMSTimestamp(SessionImpl.currentTimeMillis());\n+\n+    }\n+\n+    @Override\n+    public Destination getDestination() throws JMSException {\n+        return topic;\n+    }\n+\n+    @Override\n+    public void close() throws JMSException {\n+        // This will be a noop actually ... session.close() takes care of closing the publisher.\n+    }\n+\n+    @Override\n+    public void send(Message message) throws JMSException {\n+        publish(message);\n+    }\n+\n+    @Override\n+    public void send(Destination destination, Message message) throws JMSException {\n+        if (!(destination instanceof Topic))\n+          throw new JMSException(\"Expected destination to be a Topic : \" + destination);\n+        publish((Topic) destination, message);\n+    }\n+\n+    @Override\n+    public void send(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {\n+        publish(message, deliveryMode, priority, timeToLive);\n+    }\n+\n+    @Override\n+    public void send(Destination destination, Message message, int deliveryMode,\n+                     int priority, long timeToLive) throws JMSException {\n+        if (!(destination instanceof Topic))\n+          throw new JMSException(\"Expected destination to be a Topic : \" + destination);\n+\n+        publish((Topic) destination, message, deliveryMode, priority, timeToLive);\n+    }\n+}"},{"sha":"e96f9984207e7e373ee6d39dc798e6096d8d7f2b","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSessionImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.ConnectionImpl;\n+import org.apache.hedwig.jms.SessionImpl;\n+\n+import javax.jms.JMSException;\n+import javax.jms.Queue;\n+import javax.jms.QueueBrowser;\n+import javax.jms.TemporaryQueue;\n+import javax.jms.Topic;\n+import javax.jms.TopicPublisher;\n+import javax.jms.TopicSession;\n+import javax.jms.TopicSubscriber;\n+\n+/**\n+ * Topic specific impl\n+ */\n+public class TopicSessionImpl extends SessionImpl implements TopicSession {\n+\n+    public TopicSessionImpl(ConnectionImpl connection, boolean transacted, int acknowledgeMode) throws JMSException {\n+        super(connection, transacted, acknowledgeMode);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createSubscriber(Topic topic) throws JMSException {\n+        return super.createSubscriberImpl(topic);\n+    }\n+\n+    @Override\n+    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n+        return super.createSubscriberImpl(topic, messageSelector, noLocal);\n+    }\n+\n+    @Override\n+    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n+        return super.createPublisherImpl(topic);\n+    }\n+\n+    @Override\n+    public TemporaryQueue createTemporaryQueue() throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n+    }\n+\n+    @Override\n+    public Queue createQueue(String queueName) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n+    }\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n+    }\n+\n+    @Override\n+    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n+        throw new javax.jms.IllegalStateException(\"Cant call this method on TopicSession\");\n+    }\n+}"},{"sha":"4a51e8dd8eb2cccd68cfd5661c011fc31bfba520","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","status":"added","additions":323,"deletions":0,"changes":323,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/TopicSubscriberImpl.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.jms.spi;\n+\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.DebugUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.jms.InvalidSelectorException;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageListener;\n+import javax.jms.Topic;\n+import javax.jms.TopicSubscriber;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Subscriber to a topic.\n+ *\n+ */\n+public class TopicSubscriberImpl extends MessageConsumerImpl implements TopicSubscriber {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TopicSubscriberImpl.class);\n+\n+    private final SessionImpl session;\n+    private final Topic topic;\n+    private final String subscriberId;\n+    private final boolean noLocal;\n+\n+    private final boolean forceUnsubscribe;\n+    private volatile boolean registered = false;\n+    private boolean closed = false;\n+\n+    // Any publically exposed object MUST NOT rely on 'this' for its locking semantics unless it is\n+    // explicitly exposing this behavior.\n+    private final Object lockObject = new Object();\n+    private final LinkedList<SessionImpl.ReceivedMessage> pendingMessageList\n+        = new LinkedList<SessionImpl.ReceivedMessage>();\n+\n+    public TopicSubscriberImpl(SessionImpl session, Topic topic, String subscriberId,\n+                               boolean forceUnsubscribe) throws JMSException {\n+        super(null);\n+        this.session = session;\n+        this.topic = topic;\n+        this.subscriberId = subscriberId;\n+        // default is false right ?\n+        this.noLocal = false;\n+        this.forceUnsubscribe = forceUnsubscribe;\n+\n+        // I am not sure if we have to register with session immediately on create or not ...\n+        registerWithSession();\n+    }\n+\n+    public TopicSubscriberImpl(SessionImpl session, Topic topic, String subscriberId,\n+                               String messageSelector, boolean noLocal, boolean forceUnsubscribe) throws JMSException {\n+        super(messageSelector);\n+        this.session = session;\n+        this.topic = topic;\n+        this.subscriberId = subscriberId;\n+\n+        this.noLocal = noLocal;\n+        this.forceUnsubscribe = forceUnsubscribe;\n+\n+        if (null == getSelectorAst()){\n+            // Only if NOT empty string - treat empty string as null selector spec.\n+            if (null != messageSelector && 0 != messageSelector.trim().length()){\n+                throw new InvalidSelectorException(\"Invalid selector specified '\" + messageSelector + \"'\");\n+            }\n+        }\n+        else {\n+            session.registerTopicSubscriptionInfo(new SessionImpl.TopicSubscription(topic.getTopicName(),\n+                subscriberId), getSelectorAst());\n+        }\n+\n+        // I am not sure if we have to register with session immediately on create or not ...\n+        registerWithSession();\n+    }\n+\n+    @Override\n+    public Topic getTopic() {\n+        return topic;\n+    }\n+\n+    @Override\n+    public boolean getNoLocal() {\n+        return noLocal;\n+    }\n+\n+    public String getSubscriberId() {\n+        return subscriberId;\n+    }\n+\n+    @Override\n+    public void setMessageListener(MessageListener messageListener) throws JMSException {\n+        super.setMessageListener(messageListener);\n+        registerWithSession();\n+    }\n+\n+    private void registerWithSession() throws JMSException {\n+\n+        // Fail fast ... volatile perf hit is ok in comparison to rest.\n+        if (this.registered) return ;\n+\n+        final boolean register;\n+        synchronized (lockObject){\n+            // if (closed) throw new JMSException(\"Already closed\");\n+            if (closed) return ;\n+\n+            if (!this.registered) {\n+                this.registered = true;\n+                register = true;\n+            }\n+            else register = false;\n+        }\n+        if (register) this.session.registerTopicSubscriber(this);\n+    }\n+\n+    @Override\n+    public Message receive() throws JMSException {\n+        return receive(0);\n+    }\n+\n+\n+    @Override\n+    public Message receive(final long maxTimeout) throws JMSException {\n+        return receiveImpl(maxTimeout, true);\n+    }\n+\n+    private Message receiveImpl(final long maxTimeout, boolean canWait) throws JMSException {\n+        final long waitTimeout;\n+        final long startTime;\n+\n+        // periodically wake up !\n+        if (canWait){\n+            if (maxTimeout <= 0) waitTimeout = 1000;\n+            else {\n+                long duration = maxTimeout / 16;\n+                if (duration <= 0) duration = 1;\n+                waitTimeout = duration;\n+            }\n+            startTime = SessionImpl.currentTimeMillis();\n+        }\n+        else {\n+            waitTimeout = 0;\n+            startTime = 0;\n+        }\n+\n+        registerWithSession();\n+\n+        // check before lock ...\n+        if (null != getMessageListener()) {\n+          throw new javax.jms.IllegalStateException(\n+                  \"There is a message listener already subscribed for this subscriber\");\n+        }\n+\n+        final SessionImpl.ReceivedMessage message;\n+        final List<SessionImpl.ReceivedMessage> ackList = new ArrayList<SessionImpl.ReceivedMessage>(4);\n+\n+        synchronized (lockObject){\n+\n+outer:\n+            while (true) {\n+\n+                // Should we ignore cached messages instead of this ?\n+                // Once closed, wont help much anyway, right ?\n+                if (closed) {\n+                    message = null;\n+                    break outer;\n+                }\n+\n+                // While we waited, it could have been set.\n+                if (null != getMessageListener()) {\n+                  throw new javax.jms.IllegalStateException(\n+                          \"There is a message listener already subscribed for this subscriber\");\n+                }\n+\n+                while (canWait && pendingMessageList.isEmpty()){\n+\n+                    // Should we ignore cached messages instead of this ?\n+                    // Once closed, wont help much anyway, right ?\n+                    if (closed) {\n+                        message = null;\n+                        break outer;\n+                    }\n+\n+                    if (0 != maxTimeout && startTime + maxTimeout < SessionImpl.currentTimeMillis()) {\n+                        message = null;\n+                        break outer;\n+                    }\n+\n+                    try {\n+                        lockObject.wait(waitTimeout);\n+                    } catch (InterruptedException iEx){\n+                        JMSException jEx = new JMSException(\"Interrupted .. \" + iEx);\n+                        jEx.setLinkedException(iEx);\n+                        throw jEx;\n+                    }\n+                }\n+\n+\n+                if (pendingMessageList.isEmpty()) {\n+                    message = null;\n+                    break outer;\n+                }\n+                SessionImpl.ReceivedMessage tmessage = pendingMessageList.remove();\n+                ackList.add(tmessage);\n+\n+                if (noLocal){\n+                    if (session.isLocallyPublished(tmessage.originalMessage.getJMSMessageID())){\n+                        // find next message.\n+                        continue;\n+                    }\n+                }\n+                if (session.isMessageExpired(tmessage.originalMessage)) continue;\n+                // use this message then.\n+                message = tmessage;\n+                break;\n+            }\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"Acklist receive (\" + ackList.size() + \") ... \" + ackList);\n+        for (SessionImpl.ReceivedMessage ackMessage : ackList){\n+            session.handleAutomaticMessageAcknowledgement(ackMessage, this);\n+        }\n+\n+        if (logger.isTraceEnabled()) logger.trace(\"receive response \" + (null != message ? message.msg : null));\n+        return null != message ? message.msg : null;\n+   }\n+\n+    @Override\n+    public Message receiveNoWait() throws JMSException {\n+        return receiveImpl(0, false);\n+    }\n+\n+    @Override\n+    public void close() throws JMSException {\n+\n+        final boolean unregister;\n+        final boolean unsubscribe;\n+\n+        synchronized (lockObject){\n+            if (closed) return ;\n+            closed = true;\n+\n+            // This means that we drop all pending messages ...\n+            // gc friendly.\n+            pendingMessageList.clear();\n+\n+            unregister = registered;\n+            this.registered = false;\n+\n+            unsubscribe = this.forceUnsubscribe;\n+        }\n+\n+        if (unregister) this.session.unregisterTopicSubscriber(this);\n+\n+        // this.session.stopTopicDelivery(topic.getTopicName(), subscriberId);\n+        if (unsubscribe) session.unsubscribeFromTopic(topic.getTopicName(), subscriberId);\n+\n+        // nothing else to be done ...\n+    }\n+\n+    boolean enqueueReceivedMessage(SessionImpl.ReceivedMessage receivedMessage, final boolean addFirst) {\n+        if (logger.isTraceEnabled())\n+          logger.trace(\"Enqueing message \" + receivedMessage + \" to subscriber \" + subscriberId +\n+              \" for topic \" + topic.toString() + \", addFirst : \" + addFirst);\n+\n+        String infoMsg = null;\n+        String traceMsg = null;\n+        synchronized (lockObject){\n+            // ignore\n+            if (closed) return false;\n+            // If number of buffered messages > some max limit, evict them - else we run out of memory !\n+            if (pendingMessageList.size() > SessionImpl.MAX_SUBSCRIBER_BUFFERED_MESSAGES) {\n+                // simply discard it with an error logged.\n+                infoMsg = \"Discarding \" + pendingMessageList.size() + \" messages since there are no consumers for them\";\n+                pendingMessageList.clear();\n+            }\n+\n+            // Note: Selector evaluation will happen in SessionImpl.\n+            // if (!selectorMatched(receivedMessage)) return false;\n+\n+            if (addFirst) pendingMessageList.addFirst(receivedMessage);\n+            else pendingMessageList.add(receivedMessage);\n+\n+            lockObject.notifyAll();\n+            if (logger.isTraceEnabled()) traceMsg = \"pendingMessageList (\" + pendingMessageList.size() +\n+                \") : \\n\" + pendingMessageList + \"\\n---\\n next : \" + pendingMessageList.getFirst();\n+        }\n+\n+        if (null != infoMsg) logger.info(infoMsg);\n+        if (logger.isTraceEnabled() && null != traceMsg) logger.trace(traceMsg);\n+\n+        return true;\n+    }\n+\n+    public void start() {\n+        try {\n+            registerWithSession();\n+        } catch (JMSException jEx){\n+            // ignore.\n+            DebugUtil.dumpJMSStacktrace(logger, jEx);\n+        }\n+    }\n+}"},{"sha":"fe6c1e13359acaa55a5cdce2b5f75188be7282f2","filename":"hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/java/org/apache/hedwig/jms/spi/package-info.html?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,30 @@\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+\n+\n+Contains all the implementation which interacts directly with Hedwig (except for message parsing\n+which is in message package). <br/>\n+The does not, typically, adhere to JMS MT-constraints - and needs to be MT-safe : it can be invoked\n+by underlying hedwig thread-pools and by client JMS invocations concurrently. <br/>\n+\n+Primarily provides :\n+<ul>\n+  <li>The HedwigConnectionImpl which is (by default) looked up via JNDI. This bootstraps access to rest of system.</li>\n+  <li>The default MessagingSessionFacade implementation for Hedwig.</li>\n+  <li>Associated implementations relevant to the classes exposed by the Facade - Topic handling\n+    (no support for Queue yet), etc</li>\n+</ul>"},{"sha":"2338587bcc56d2236503ce9c5beecbdbffaac2a9","filename":"hedwig-client-jms/src/main/protobuf/JmsHeader.proto","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/protobuf/JmsHeader.proto","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/protobuf/JmsHeader.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/protobuf/JmsHeader.proto?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+option java_package = \"org.apache.hedwig.jms.message.header\";\n+option optimize_for = SPEED;\n+// change ?\n+package Hedwig.Jms.Header;\n+\n+enum ProtocolVersion{\n+    VERSION_ONE = 1;\n+}\n+\n+message JmsValue {\n+    enum ValueType {\n+        BOOLEAN = 1;\n+        BYTE = 2;\n+        SHORT = 3;\n+        INT = 4;\n+        LONG = 5;\n+        FLOAT = 6;\n+        DOUBLE = 7;\n+        STRING = 8;\n+        // raw bytes. (custom correlation id, for example, uses this : though we dont support it right now).\n+        BYTES = 9;\n+    };\n+\n+    required ValueType type = 1;\n+\n+    optional bool booleanValue = 2;\n+    optional sint32 byteValue = 3;\n+    optional sint32 shortValue = 4;\n+    optional sint32 intValue = 5;\n+    optional sint64 longValue = 6;\n+    optional float floatValue = 7;\n+    optional double doubleValue = 8;\n+    optional string stringValue = 9;\n+    optional bytes bytesValue = 10;\n+}\n+\n+"},{"sha":"27d78f185b3ffd211c918e3f458df6bf0de7a8a2","filename":"hedwig-client-jms/src/main/resources/log4j.properties","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/main/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/main/resources/log4j.properties?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,35 @@\n+#\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+#\n+\n+# log4j.rootLogger=trace, CONSOLE\n+# log4j.rootLogger=info, CONSOLE\n+log4j.rootLogger=off, CONSOLE\n+\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=off\n+# log4j.appender.CONSOLE.Threshold=info\n+# log4j.appender.CONSOLE.Threshold=trace\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+log4j.logger.org.apache=OFF\n+# log4j.logger.org.apache=INFO\n+# log4j.logger.org.apache=TRACE\n+"},{"sha":"f4c0f7ec023e63a073597fa5540b5fb07ecbfda9","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/AutoFailTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,153 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import junit.framework.TestCase;\n+import org.apache.hedwig.JmsTestBase;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Enforces a test case to run for only an allotted time to prevent them from\n+ * hanging and breaking the whole testing.\n+ */\n+\n+public abstract class AutoFailTestSupport extends JmsTestBase {\n+    public static final int EXIT_SUCCESS = 0;\n+    public static final int EXIT_ERROR = 1;\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoFailTestSupport.class);\n+\n+    private long maxTestTime = 5 * 60 * 1000; // 5 mins by default\n+    private Thread autoFailThread;\n+\n+    private boolean verbose = true;\n+    private boolean useAutoFail; // Disable auto fail by default\n+    private AtomicBoolean isTestSuccess;\n+\n+    protected void setUp() throws Exception {\n+        // Runs the auto fail thread before performing any setup\n+        if (isAutoFail()) {\n+            startAutoFailThread();\n+        }\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+\n+        // Stops the auto fail thread only after performing any clean up\n+        stopAutoFailThread();\n+    }\n+\n+    /**\n+     * Manually start the auto fail thread. To start it automatically, just set\n+     * the auto fail to true before calling any setup methods. As a rule, this\n+     * method is used only when you are not sure, if the setUp and tearDown\n+     * method is propagated correctly.\n+     */\n+    public void startAutoFailThread() {\n+        setAutoFail(true);\n+        isTestSuccess = new AtomicBoolean(false);\n+        autoFailThread = new Thread(new Runnable() {\n+            public void run() {\n+                try {\n+                    // Wait for test to finish succesfully\n+                    Thread.sleep(getMaxTestTime());\n+                } catch (InterruptedException e) {\n+                    // This usually means the test was successful\n+                } finally {\n+                    // Check if the test was able to tear down succesfully,\n+                    // which usually means, it has finished its run.\n+                    if (!isTestSuccess.get()) {\n+                        LOG.error(\"Test case has exceeded the maximum allotted time to run of: \"\n+                                  + getMaxTestTime() + \" ms.\");\n+                        dumpAllThreads(getName());\n+                        System.exit(EXIT_ERROR);\n+                    }\n+                }\n+            }\n+        }, \"AutoFailThread\");\n+\n+        if (verbose) {\n+            LOG.info(\"Starting auto fail thread...\");\n+        }\n+\n+        LOG.info(\"Starting auto fail thread...\");\n+        autoFailThread.start();\n+    }\n+\n+    /**\n+     * Manually stops the auto fail thread. As a rule, this method is used only\n+     * when you are not sure, if the setUp and tearDown method is propagated\n+     * correctly.\n+     */\n+    public void stopAutoFailThread() {\n+        if (isAutoFail() && autoFailThread != null && autoFailThread.isAlive()) {\n+            isTestSuccess.set(true);\n+\n+            if (verbose) {\n+                LOG.info(\"Stopping auto fail thread...\");\n+            }\n+\n+            LOG.info(\"Stopping auto fail thread...\");\n+            autoFailThread.interrupt();\n+        }\n+    }\n+\n+    /**\n+     * Sets the auto fail value. As a rule, this should be used only before any\n+     * setup methods is called to automatically enable the auto fail thread in\n+     * the setup method of the test case.\n+     *\n+     * @param val\n+     */\n+    public void setAutoFail(boolean val) {\n+        this.useAutoFail = val;\n+    }\n+\n+    public boolean isAutoFail() {\n+        return this.useAutoFail;\n+    }\n+\n+    /**\n+     * The assigned value will only be reflected when the auto fail thread has\n+     * started its run. Value is in milliseconds.\n+     *\n+     * @param val\n+     */\n+    public void setMaxTestTime(long val) {\n+        this.maxTestTime = val;\n+    }\n+\n+    public long getMaxTestTime() {\n+        return this.maxTestTime;\n+    }\n+\n+    public static void dumpAllThreads(String prefix) {\n+        Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();\n+        for (Entry<Thread, StackTraceElement[]> stackEntry : stacks.entrySet()) {\n+            System.err.println(prefix + \" \" + stackEntry.getKey());\n+            for(StackTraceElement element : stackEntry.getValue()) {\n+                System.err.println(\"     \" + element);\n+            }\n+        }\n+    }\n+}"},{"sha":"d4155a767083bb83a664462e7ad3cae49e847bbe","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","status":"added","additions":250,"deletions":0,"changes":250,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/CombinationTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Poor mans way of getting JUnit to run a test case through a few different\n+ * combinations of options. Usage: If you have a test case called testFoo what\n+ * you want to run through a few combinations, of of values for the attributes\n+ * age and color, you would something like: <code>\n+ *    public void initCombosForTestFoo() {\n+ *        addCombinationValues( \"age\", new Object[]{ new Integer(21), new Integer(30) } );\n+ *        addCombinationValues( \"color\", new Object[]{\"blue\", \"green\"} );\n+ *    }\n+ * </code>\n+ * The testFoo test case would be run for each possible combination of age and\n+ * color that you setup in the initCombosForTestFoo method. Before each\n+ * combination is run, the age and color fields of the test class are set to one\n+ * of the values defined. This is done before the normal setUp method is called.\n+ * If you want the test combinations to show up as separate test runs in the\n+ * JUnit reports, add a suite method to your test case similar to: <code>\n+ *     public static Test suite() {\n+ *         return suite(FooTest.class);\n+ *     }\n+ * </code>\n+ *\n+ *\n+ */\n+public abstract class CombinationTestSupport extends AutoFailTestSupport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CombinationTestSupport.class);\n+\n+    private HashMap<String, ComboOption> comboOptions = new HashMap<String, ComboOption>();\n+    private boolean combosEvaluated;\n+    private Map<String, Object> options;\n+\n+    static class ComboOption {\n+        final String attribute;\n+        final LinkedHashSet<Object> values = new LinkedHashSet<Object>();\n+\n+        public ComboOption(String attribute, Collection<Object> options) {\n+            this.attribute = attribute;\n+            this.values.addAll(options);\n+        }\n+    }\n+\n+    public void addCombinationValues(String attribute, Object[] options) {\n+        ComboOption co = this.comboOptions.get(attribute);\n+        if (co == null) {\n+            this.comboOptions.put(attribute, new ComboOption(attribute, Arrays.asList(options)));\n+        } else {\n+            co.values.addAll(Arrays.asList(options));\n+        }\n+    }\n+\n+    public void runBare() throws Throwable {\n+        if (combosEvaluated) {\n+            super.runBare();\n+        } else {\n+            CombinationTestSupport[] combinations = getCombinations();\n+            for (int i = 0; i < combinations.length; i++) {\n+                CombinationTestSupport test = combinations[i];\n+                if (getName() == null || getName().equals(test.getName())) {\n+                    test.runBare();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void setOptions(Map<String, Object> options) throws NoSuchFieldException, IllegalAccessException {\n+        this.options = options;\n+        for (Iterator<String> iterator = options.keySet().iterator(); iterator.hasNext();) {\n+            String attribute = iterator.next();\n+            Object value = options.get(attribute);\n+            try {\n+                Field field = getClass().getField(attribute);\n+                field.set(this, value);\n+            } catch (Throwable e) {\n+                try {\n+                    boolean found = false;\n+                    String setterName = \"set\" + attribute.substring(0, 1).toUpperCase() +\n+                                        attribute.substring(1);\n+                    for(Method method : getClass().getMethods()) {\n+                        if (method.getName().equals(setterName)) {\n+                            method.invoke(this, value);\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+\n+                    if (!found) {\n+                        throw new NoSuchMethodError(\"No setter found for field: \" + attribute);\n+                    }\n+\n+                } catch(Throwable ex) {\n+                    LOG.info(\"Could not set field '\" + attribute + \"' to value '\" + value +\n+                             \"', make sure the field exists and is public or has a setter.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private CombinationTestSupport[] getCombinations() {\n+        try {\n+            Method method = getClass().getMethod(\"initCombos\", (Class[])null);\n+            method.invoke(this, (Object[])null);\n+        } catch (Throwable e) {\n+        }\n+\n+        String name = getName().split(\" \")[0];\n+        String comboSetupMethodName = \"initCombosFor\" + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n+        try {\n+            Method method = getClass().getMethod(comboSetupMethodName, (Class[])null);\n+            method.invoke(this, (Object[])null);\n+        } catch (Throwable e) {\n+        }\n+\n+        try {\n+            ArrayList<HashMap<String, Object>> expandedOptions = new ArrayList<HashMap<String, Object>>();\n+            expandCombinations(new ArrayList<ComboOption>(comboOptions.values()), expandedOptions);\n+\n+            if (expandedOptions.isEmpty()) {\n+                combosEvaluated = true;\n+                return new CombinationTestSupport[] {this};\n+            } else {\n+\n+                ArrayList<CombinationTestSupport> result = new ArrayList<CombinationTestSupport>();\n+                // Run the test case for each possible combination\n+                for (Iterator<HashMap<String, Object>> iter = expandedOptions.iterator(); iter.hasNext();) {\n+                    CombinationTestSupport combo = (CombinationTestSupport)TestSuite.createTest(getClass(), name);\n+                    combo.combosEvaluated = true;\n+                    combo.setOptions(iter.next());\n+                    result.add(combo);\n+                }\n+\n+                CombinationTestSupport rc[] = new CombinationTestSupport[result.size()];\n+                result.toArray(rc);\n+                return rc;\n+            }\n+        } catch (Throwable e) {\n+            combosEvaluated = true;\n+            return new CombinationTestSupport[] {this};\n+        }\n+\n+    }\n+\n+    private void expandCombinations(List<ComboOption> optionsLeft, List<HashMap<String, Object>> expandedCombos) {\n+        if (!optionsLeft.isEmpty()) {\n+            HashMap<String, Object> map;\n+            if (comboOptions.size() == optionsLeft.size()) {\n+                map = new HashMap<String, Object>();\n+                expandedCombos.add(map);\n+            } else {\n+                map = expandedCombos.get(expandedCombos.size() - 1);\n+            }\n+\n+            LinkedList<ComboOption> l = new LinkedList<ComboOption>(optionsLeft);\n+            ComboOption comboOption = l.removeLast();\n+            int i = 0;\n+            for (Iterator<Object> iter = comboOption.values.iterator(); iter.hasNext();) {\n+                Object value = iter.next();\n+                if (i != 0) {\n+                    map = new HashMap<String, Object>(map);\n+                    expandedCombos.add(map);\n+                }\n+                map.put(comboOption.attribute, value);\n+                expandCombinations(l, expandedCombos);\n+                i++;\n+            }\n+        }\n+    }\n+\n+    public static Test suite(Class<? extends CombinationTestSupport> clazz) {\n+        TestSuite suite = new TestSuite();\n+\n+        ArrayList<String> names = new ArrayList<String>();\n+        Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            String name = methods[i].getName();\n+            if (names.contains(name) || !isPublicTestMethod(methods[i])) {\n+                continue;\n+            }\n+            names.add(name);\n+            Test test = TestSuite.createTest(clazz, name);\n+            if (test instanceof CombinationTestSupport) {\n+                CombinationTestSupport[] combinations = ((CombinationTestSupport)test).getCombinations();\n+                for (int j = 0; j < combinations.length; j++) {\n+                    suite.addTest(combinations[j]);\n+                }\n+            } else {\n+                suite.addTest(test);\n+            }\n+        }\n+        return suite;\n+    }\n+\n+    private static boolean isPublicTestMethod(Method m) {\n+        return isTestMethod(m) && Modifier.isPublic(m.getModifiers());\n+    }\n+\n+    private static boolean isTestMethod(Method m) {\n+        String name = m.getName();\n+        Class<?>[] parameters = m.getParameterTypes();\n+        Class<?> returnType = m.getReturnType();\n+        return parameters.length == 0 && name.startsWith(\"test\") && returnType.equals(Void.TYPE);\n+    }\n+\n+    public String getName() {\n+        return getName(false);\n+    }\n+\n+    public String getName(boolean original) {\n+        if (options != null && !original) {\n+            return super.getName() + \" \" + options;\n+        }\n+        return super.getName();\n+    }\n+}"},{"sha":"e1e85e5ee3b99c2fea3fc6ac9348ee4af7154619","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ConnectionCleanupTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,73 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.JMSException;\n+import javax.jms.Session;\n+\n+import junit.framework.TestCase;\n+import org.apache.hedwig.JmsTestBase;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+\n+public class ConnectionCleanupTest extends JmsTestBase {\n+\n+    private HedwigConnectionImpl connection;\n+    private HedwigConnectionFactoryImpl factory;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        this.factory = new HedwigConnectionFactoryImpl();\n+        connection = factory.createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        connection.close();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * @throws JMSException\n+     */\n+    public void testChangeClientID() throws JMSException {\n+\n+        connection.setClientID(\"test\");\n+        connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        try {\n+            connection.setClientID(\"test\");\n+            fail(\"Should have received JMSException\");\n+        } catch (JMSException e) {\n+        }\n+\n+        connection.close();\n+        connection = factory.createConnection();\n+        connection.setClientID(\"test\");\n+\n+        connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        try {\n+            connection.setClientID(\"test\");\n+            fail(\"Should have received JMSException\");\n+        } catch (JMSException e) {\n+        }\n+    }\n+\n+}"},{"sha":"93e0615c450ef57d921e436dcf4a60006ee6a8d4","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ConsumerReceiveWithTimeoutTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.Topic;\n+\n+public class ConsumerReceiveWithTimeoutTest extends TestSupport {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Test to check if consumer thread wakes up inside a receive(timeout) after\n+     * a message is dispatched to the consumer\n+     *\n+     * @throws javax.jms.JMSException\n+     */\n+    public void testConsumerReceiveBeforeMessageDispatched() throws JMSException {\n+\n+        connection.start();\n+\n+        final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        final Topic queue = session.createTopic(\"test\");\n+        MessageConsumer consumer = session.createConsumer(queue);\n+\n+        Thread t = new Thread() {\n+            public void run() {\n+                try {\n+                    // wait for 10 seconds to allow consumer.receive to be run\n+                    // first\n+                    Thread.sleep(10000);\n+                    MessageProducer producer = session.createProducer(queue);\n+                    producer.send(session.createTextMessage(\"Hello\"));\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        };\n+\n+        t.start();\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(60000);\n+        assertNotNull(msg);\n+        session.close();\n+\n+    }\n+\n+}"},{"sha":"685683762a4f04fe6f96461784338e5fba4d7da7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/ExpiryHogTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,61 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.util.concurrent.TimeUnit;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+\n+\n+\n+\n+/**\n+ * User: gtully\n+ */\n+public class ExpiryHogTest extends JmsMultipleClientsTestSupport {\n+    boolean sleep = false;\n+\n+    int numMessages = 4;\n+\n+    public void testImmediateDispatchWhenCacheDisabled() throws Exception {\n+        ConnectionFactory f = createConnectionFactory();\n+        destination = createDestination();\n+        startConsumers(f, destination);\n+        sleep = true;\n+        this.startProducers(f, destination, numMessages);\n+        allMessagesList.assertMessagesReceived(numMessages);\n+    }\n+\n+    protected TextMessage createTextMessage(Session session, String initText) throws Exception {\n+        if (sleep) {\n+            TimeUnit.SECONDS.sleep(10);\n+        }\n+        TextMessage msg = super.createTextMessage(session, initText);\n+        // what is the point of setting this !\n+        // msg.setJMSExpiration(4000);\n+        return msg;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        autoFail = false;\n+        persistent = true;\n+        super.setUp();\n+    }\n+}"},{"sha":"408b40e7ff4eac752aa63ac1055cf288976be475","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","status":"added","additions":936,"deletions":0,"changes":936,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSConsumerTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,936 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+\n+\n+\n+import junit.framework.Test;\n+\n+\n+import javax.jms.Destination;\n+\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+import org.junit.Ignore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test cases used to test the JMS message consumer.\n+ */\n+public class JMSConsumerTest extends JmsTestSupport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JMSConsumerTest.class);\n+\n+    public Destination destination;\n+    public int deliveryMode;\n+    public int prefetch;\n+    public int ackMode;\n+    public MessagingSessionFacade.DestinationType destinationType;\n+    public boolean durableConsumer;\n+\n+    public static Test suite() {\n+        return suite(JMSConsumerTest.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public void initCombosForTestMessageListenerWithConsumerCanBeStopped() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),\n+                                                           Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new MessagingSessionFacade.DestinationType[] {\n+                MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMessageListenerWithConsumerCanBeStopped() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch done1 = new CountDownLatch(1);\n+        final CountDownLatch done2 = new CountDownLatch(1);\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = (MessageConsumer)session.createConsumer(destination);\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                counter.incrementAndGet();\n+                if (counter.get() == 1) {\n+                    done1.countDown();\n+                }\n+                if (counter.get() == 2) {\n+                    done2.countDown();\n+                }\n+            }\n+        });\n+\n+        // Send a first message to make sure that the consumer dispatcher is\n+        // running\n+        sendMessages(session, destination, 1);\n+        assertTrue(done1.await(1, TimeUnit.SECONDS));\n+        assertEquals(1, counter.get());\n+\n+        // Stop the consumer.\n+        connection.stop();\n+\n+        // Send a message, but should not get delivered.\n+        sendMessages(session, destination, 1);\n+        assertFalse(done2.await(1, TimeUnit.SECONDS));\n+        assertEquals(1, counter.get());\n+\n+        // Start the consumer, and the message should now get delivered.\n+        connection.start();\n+        assertTrue(done2.await(1, TimeUnit.SECONDS));\n+        assertEquals(2, counter.get());\n+    }\n+\n+    public void testMessageListenerWithConsumerCanBeStoppedConcurently() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch closeDone = new CountDownLatch(1);\n+\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n+\n+        final Map<Thread, Throwable> exceptions =\n+            Collections.synchronizedMap(new HashMap<Thread, Throwable>());\n+        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n+            public void uncaughtException(Thread t, Throwable e) {\n+                LOG.error(\"Uncaught exception:\", e);\n+                exceptions.put(t, e);\n+            }\n+        });\n+\n+        final int numOutStanding = (connection.getHedwigClientConfig().getMaximumOutstandingMessages() * 2 / 3) + 1;\n+\n+        final MessageConsumer consumer = (MessageConsumer)session.createConsumer(destination);\n+\n+        final class AckAndClose implements Runnable {\n+            private Message message;\n+\n+            public AckAndClose(Message m) {\n+                this.message = m;\n+            }\n+\n+            public void run() {\n+                try {\n+                    message.acknowledge();\n+                    int count = counter.incrementAndGet();\n+                    if (590 == count) {\n+                        // close in a separate thread is ok by jms\n+                        consumer.close();\n+                        closeDone.countDown();\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Exception on close or ack:\", e);\n+                    exceptions.put(Thread.currentThread(), e);\n+                }\n+            }\n+        };\n+\n+        final AtomicInteger listenerReceivedCount = new AtomicInteger(0);\n+        // final ExecutorService executor = Executors.newSingleThreadExecutor();\n+        final ExecutorService executor = Executors.newCachedThreadPool();\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                // close can be in a different thread, but NOT acknowledge iirc\n+                // - this will not cause a problem for us though ...\n+                // ack and close eventually in separate thread\n+                int val = listenerReceivedCount.incrementAndGet();\n+                // System.out.println(\"message count : \" + val + \", message : \" + m);\n+                executor.execute(new AckAndClose(m));\n+                // new AckAndClose(m).run();\n+            }\n+        });\n+\n+        // preload the queue\n+        sendMessages(session, destination, 600);\n+\n+        assert closeDone.await(10, TimeUnit.SECONDS) :\n+        \"closeDone : \" + closeDone.getCount() + \", counter : \" + counter.get()\n+            + \", listenerReceivedCount : \" + listenerReceivedCount.get();\n+        // await possible exceptions\n+        Thread.sleep(1000);\n+        assertTrue(\"no exceptions: \" + exceptions, exceptions.isEmpty());\n+    }\n+\n+\n+    public void initCombosForTestMutiReceiveWithPrefetch1() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"ackMode\", new Object[] {\n+                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),\n+                Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMutiReceiveWithPrefetch1() throws Exception {\n+\n+        // Set prefetch to 1\n+        connection.start();\n+\n+        // Use all the ack modes\n+        Session session = connection.createSession(false, ackMode);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        // Make sure 4 messages were delivered.\n+        Message message = null;\n+        for (int i = 0; i < 4; i++) {\n+            message = consumer.receive(1000);\n+            assertNotNull(message);\n+        }\n+        assertNull(consumer.receiveNoWait());\n+        assert null != message;\n+        message.acknowledge();\n+    }\n+\n+    public void initCombosForTestDurableConsumerSelectorChange() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testDurableConsumerSelectorChange() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test\");\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageProducer producer = session.createProducer(destination);\n+        producer.setDeliveryMode(deliveryMode);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic)destination, \"test\", \"color='red'\", false);\n+\n+        // Send the messages\n+        TextMessage message = session.createTextMessage(\"1st\");\n+        message.setStringProperty(\"color\", \"red\");\n+        producer.send(message);\n+\n+        Message m = consumer.receive(1000);\n+        assertNotNull(m);\n+        assertEquals(\"1st\", ((TextMessage)m).getText());\n+\n+        // Change the subscription.\n+        consumer.close();\n+        consumer = session.createDurableSubscriber((Topic)destination, \"test\", \"color='blue'\", false);\n+\n+        message = session.createTextMessage(\"2nd\");\n+        message.setStringProperty(\"color\", \"red\");\n+        producer.send(message);\n+        message = session.createTextMessage(\"3rd\");\n+        message.setStringProperty(\"color\", \"blue\");\n+        producer.send(message);\n+\n+        // Selector should skip the 2nd message.\n+        m = consumer.receive(1000);\n+        assertNotNull(m);\n+        assertEquals(\"3rd\", ((TextMessage)m).getText());\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void initCombosForTestSendReceiveBytesMessage() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testSendReceiveBytesMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        BytesMessage message = session.createBytesMessage();\n+        message.writeBoolean(true);\n+        message.writeBoolean(false);\n+        producer.send(message);\n+\n+        // Make sure only 1 message was delivered.\n+        BytesMessage m = (BytesMessage)consumer.receive(1000);\n+        assertNotNull(m);\n+        assertTrue(m.readBoolean());\n+        assertFalse(m.readBoolean());\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void initCombosForTestSetMessageListenerAfterStart() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testSetMessageListenerAfterStart() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // See if the message get sent to the listener\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                counter.incrementAndGet();\n+                if (counter.get() == 4) {\n+                    done.countDown();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n+        Thread.sleep(200);\n+\n+        // Make sure only 4 messages were delivered.\n+        assertEquals(4, counter.get());\n+    }\n+\n+    public void initCombosForTestPassMessageListenerIntoCreateConsumer() {\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testPassMessageListenerIntoCreateConsumer() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        SessionImpl session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                counter.incrementAndGet();\n+                if (counter.get() == 4) {\n+                    done.countDown();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n+        Thread.sleep(200);\n+\n+        // Make sure only 4 messages were delivered.\n+        assertEquals(4, counter.get());\n+    }\n+\n+    public void initCombosForTestMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"ackMode\", new Object[] {Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMessageListenerOnMessageCloseUnackedWithPrefetch1StayInQueue() throws Exception {\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch sendDone = new CountDownLatch(1);\n+        final CountDownLatch got2Done = new CountDownLatch(1);\n+\n+        // Set prefetch to 1\n+        // This test case does not work if optimized message dispatch is used as\n+        // the main thread send block until the consumer receives the\n+        // message. This test depends on thread decoupling so that the main\n+        // thread can stop the consumer thread.\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-1\");\n+        connection.start();\n+\n+        // Use all the ack modes\n+        Session session = connection.createSession(false, ackMode);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n+        consumer.setMessageListener(new MessageListener() {\n+            private final HedwigConnectionImpl _connection = connection;\n+            public void onMessage(Message m) {\n+                try {\n+                    TextMessage tm = (TextMessage)m;\n+                    LOG.info(\"Got in first listener: \" + tm.getText());\n+                    assertEquals(messageTextPrefix + counter.get(), tm.getText());\n+                    counter.incrementAndGet();\n+                    if (counter.get() == 2) {\n+                        sendDone.await();\n+                        _connection.close();\n+                        got2Done.countDown();\n+                    }\n+                    // will fail when we close connection when counter == 2 !\n+                    tm.acknowledge();\n+                } catch (Throwable e) {\n+                    // e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+        sendDone.countDown();\n+\n+        // Wait for first 2 messages to arrive.\n+        assert got2Done.await(5, TimeUnit.SECONDS) :\n+        \"counter1 : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \" + sendDone.getCount();\n+\n+        // Re-start connection.\n+        connection.close();\n+        connection = (HedwigConnectionImpl)factory.createConnection();\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-1\");\n+        connections.add(connection);\n+\n+        // Pickup the remaining messages.\n+        final CountDownLatch done2 = new CountDownLatch(1);\n+        session = connection.createSession(false, ackMode);\n+        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                try {\n+                    TextMessage tm = (TextMessage)m;\n+                    LOG.info(\"Got in second listener: \" + tm.getText());\n+                    // order is not guaranteed as the connection is started before the listener is set.\n+                    // assertEquals(messageTextPrefix + counter.get(), tm.getText());\n+                    counter.incrementAndGet();\n+                    tm.acknowledge();\n+                    if (counter.get() == 4) {\n+                        done2.countDown();\n+                    }\n+                } catch (Throwable e) {\n+                    LOG.error(\"unexpected ex onMessage: \", e);\n+                }\n+            }\n+        });\n+\n+        connection.start();\n+\n+        assert done2.await(2000, TimeUnit.MILLISECONDS) :\n+        \"count2 : \" + done2.getCount() + \", counter : \" + counter.get();\n+        Thread.sleep(200);\n+\n+        // assert msg 2 was redelivered as close() from onMessages() will only ack in auto_ack and dups_ok mode\n+        assert 5 == counter.get(): \"count3 : \" + done2.getCount() + \", counter : \" + counter.get();\n+    }\n+\n+    public void initCombosForTestMessageListenerAutoAckOnCloseWithPrefetch1() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"ackMode\", new Object[] {\n+                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMessageListenerAutoAckOnCloseWithPrefetch1() throws Exception {\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch sendDone = new CountDownLatch(1);\n+        final CountDownLatch got2Done = new CountDownLatch(1);\n+\n+        // Set prefetch to 1\n+        // This test case does not work if optimized message dispatch is used as\n+        // the main thread send block until the consumer receives the\n+        // message. This test depends on thread decoupling so that the main\n+        // thread can stop the consumer thread.\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-2\");\n+        connection.start();\n+\n+        // Use all the ack modes\n+        Session session = connection.createSession(false, ackMode);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n+        final List<Message> receivedMessages = new ArrayList<Message>(8);\n+        consumer.setMessageListener(new MessageListener() {\n+            final HedwigConnectionImpl _connection = connection;\n+            public void onMessage(Message m) {\n+                try {\n+                    TextMessage tm = (TextMessage)m;\n+                    LOG.info(\"Got in first listener: \" + tm.getText());\n+                    assertEquals(messageTextPrefix + counter.get(), tm.getText());\n+                    counter.incrementAndGet();\n+                    m.acknowledge();\n+                    receivedMessages.add(m);\n+                    if (counter.get() == 2) {\n+                        sendDone.await();\n+                        _connection.close();\n+                        got2Done.countDown();\n+                    }\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+        sendDone.countDown();\n+\n+        // Wait for first 2 messages to arrive.\n+        assert got2Done.await(5, TimeUnit.SECONDS) :\n+        \"counter : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \" + sendDone.getCount();\n+\n+        // Re-start connection.\n+        connection.close();\n+        connection = (HedwigConnectionImpl)factory.createConnection();\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-2\");\n+        connections.add(connection);\n+\n+        // Pickup the remaining messages.\n+        final CountDownLatch done2 = new CountDownLatch(1);\n+        session = connection.createSession(false, ackMode);\n+        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                try {\n+                    TextMessage tm = (TextMessage)m;\n+                    LOG.info(\"Got in second listener: \" + tm.getText());\n+                    counter.incrementAndGet();\n+                    m.acknowledge();\n+                    receivedMessages.add(m);\n+                    if (counter.get() == 4) {\n+                        done2.countDown();\n+                    }\n+                } catch (Throwable e) {\n+                    LOG.error(\"unexpected ex onMessage: \", e);\n+                }\n+            }\n+        });\n+\n+        connection.start();\n+\n+        assert done2.await(5, TimeUnit.SECONDS) : \"count : \" + done2.getCount() + \", counter : \" + counter.get();\n+        Thread.sleep(200);\n+\n+        // close from onMessage with Auto_ack will ack\n+        // Make sure only 4 messages were delivered.\n+        assert 4 == counter.get() :\n+        \"counter : \" + counter.get() + \", got2Done : \" + got2Done.getCount() + \", sendDone : \"\n+            + sendDone.getCount() + \", messages : \" + receivedMessages;\n+    }\n+\n+    public void initCombosForTestMessageListenerWithConsumerWithPrefetch1() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMessageListenerWithConsumerWithPrefetch1() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                counter.incrementAndGet();\n+                if (counter.get() == 4) {\n+                    done.countDown();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n+        Thread.sleep(200);\n+\n+        // Make sure only 4 messages were delivered.\n+        assertEquals(4, counter.get());\n+    }\n+\n+    public void initCombosForTestMessageListenerWithConsumer() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testMessageListenerWithConsumer() throws Exception {\n+\n+        final AtomicInteger counter = new AtomicInteger(0);\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        consumer.setMessageListener(new MessageListener() {\n+            public void onMessage(Message m) {\n+                counter.incrementAndGet();\n+                if (counter.get() == 4) {\n+                    done.countDown();\n+                }\n+            }\n+        });\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        assertTrue(done.await(1000, TimeUnit.MILLISECONDS));\n+        Thread.sleep(200);\n+\n+        // Make sure only 4 messages were delivered.\n+        assertEquals(4, counter.get());\n+    }\n+\n+    public void initCombosForTestUnackedWithPrefetch1StayInQueue() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"ackMode\", new Object[] {\n+                Integer.valueOf(Session.AUTO_ACKNOWLEDGE), Integer.valueOf(Session.DUPS_OK_ACKNOWLEDGE),\n+                Integer.valueOf(Session.CLIENT_ACKNOWLEDGE)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testUnackedWithPrefetch1StayInQueue() throws Exception {\n+\n+        // Set prefetch to 1\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-3\");\n+        connection.start();\n+\n+        // Use all the ack modes\n+        Session session = connection.createSession(false, ackMode);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id3\");\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        // Only pick up the first 2 messages.\n+        Message message = null;\n+        for (int i = 0; i < 2; i++) {\n+            message = consumer.receive(1000);\n+            assertNotNull(message);\n+            assert (message instanceof TextMessage);\n+            assert (((TextMessage) message).getText().equals(messageTextPrefix  + i))\n+                : \"Received message \" + ((TextMessage) message).getText() + \" .. i = \" + i;\n+        }\n+        assert null != message;\n+        message.acknowledge();\n+\n+        connection.close();\n+        connection = (HedwigConnectionImpl)factory.createConnection();\n+        if (null == connection.getClientID()) connection.setClientID(getName() + \"test-client-id-3\");\n+        // Use all the ack modes\n+        session = connection.createSession(false, ackMode);\n+        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id3\");\n+        connections.add(connection);\n+        connection.start();\n+\n+        // Pickup the rest of the messages.\n+        for (int i = 0; i < 2; i++) {\n+            message = consumer.receive(1000);\n+            assertNotNull(message);\n+            assert (message instanceof TextMessage);\n+            assert (((TextMessage) message).getText().equals(messageTextPrefix  + (i + 2))) :\n+            \"Received message \" + ((TextMessage) message).getText() + \" .. i = \" + i;\n+        }\n+        message.acknowledge();\n+        // assertNull(consumer.receiveNoWait());\n+        {\n+            Message msg = consumer.receiveNoWait();\n+            assert null == msg : \"Unexpected message \" + msg;\n+        }\n+\n+    }\n+\n+    public void initCombosForTestPrefetch1MessageNotDispatched() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+    }\n+\n+    public void testPrefetch1MessageNotDispatched() throws Exception {\n+\n+        // Set prefetch to 1\n+        connection.start();\n+\n+        Session session = connection.createSession(true, 0);\n+        destination = SessionImpl.asTopic(\"TEST\");\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // The prefetch should fill up with 1 message.\n+        // Since prefetch is still full, the 2nd message should get dispatched\n+        // to another consumer.. lets create the 2nd consumer test that it does\n+        // make sure it does.\n+        HedwigConnectionImpl connection2 = (HedwigConnectionImpl)factory.createConnection();\n+        connection2.start();\n+        connections.add(connection2);\n+        Session session2 = connection2.createSession(true, 0);\n+        MessageConsumer consumer2 = session2.createConsumer(destination);\n+\n+        // Send 2 messages to the destination.\n+        sendMessages(session, destination, 2);\n+        session.commit();\n+\n+        // Pick up the first message.\n+        Message message1 = consumer.receive(1000);\n+        assertNotNull(message1);\n+        assertNotNull(consumer.receive(1000));\n+\n+        // Pick up the 2nd messages.\n+        Message message2 = consumer2.receive(5000);\n+        assertNotNull(message2);\n+        assertNotNull(consumer2.receive(1000));\n+\n+        session.commit();\n+        session2.commit();\n+\n+        assertNull(consumer.receiveNoWait());\n+\n+    }\n+\n+    public void initCombosForTestDontStart() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] { MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testDontStart() throws Exception {\n+\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // Send the messages\n+        sendMessages(session, destination, 1);\n+\n+        // Make sure no messages were delivered.\n+        assertNull(consumer.receive(1000));\n+    }\n+\n+    public void initCombosForTestStartAfterSend() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testStartAfterSend() throws Exception {\n+\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // Send the messages\n+        sendMessages(session, destination, 1);\n+\n+        // Start the conncection after the message was sent.\n+        connection.start();\n+\n+        // Make sure only 1 message was delivered.\n+        assertNotNull(consumer.receive(1000));\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void initCombosForTestReceiveMessageWithConsumer() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testReceiveMessageWithConsumer() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        // Send the messages\n+        sendMessages(session, destination, 1);\n+\n+        // Make sure only 1 message was delivered.\n+        Message m = consumer.receive(1000);\n+        assertNotNull(m);\n+        assertEquals(\"0\", ((TextMessage)m).getText());\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+\n+    public void testDupsOkConsumer() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.DUPS_OK_ACKNOWLEDGE);\n+        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id4\");\n+\n+        // Send the messages\n+        sendMessages(session, destination, 4);\n+\n+        // Make sure only 4 message are delivered.\n+        for( int i=0; i < 4; i++){\n+            Message m = consumer.receive(1000);\n+            assertNotNull(m);\n+        }\n+        assertNull(consumer.receive(1000));\n+\n+        // Close out the consumer.. no other messages should be left on the queue.\n+        consumer.close();\n+\n+        consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id4\");\n+        assertNull(consumer.receive(1000));\n+    }\n+\n+    public void testRedispatchOfUncommittedTx() throws Exception {\n+\n+        connection.start();\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n+\n+        sendMessages(connection, destination, 2);\n+\n+        assertNotNull(consumer.receive(1000));\n+        assertNotNull(consumer.receive(1000));\n+\n+        // install another consumer while message dispatch is unacked/uncommitted\n+\n+        // no commit so will auto rollback and get re-dispatched to redisptachConsumer\n+        session.close();\n+\n+        Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        MessageConsumer redispatchConsumer\n+            = redispatchSession.createDurableSubscriber((Topic) destination, \"subscriber-id2\");\n+\n+        Message msg = redispatchConsumer.receive(1000);\n+        assertNotNull(msg);\n+        // assertTrue(\"redelivered flag set\", msg.getJMSRedelivered());\n+\n+        msg = redispatchConsumer.receive(1000);\n+        assertNotNull(msg);\n+        // assertTrue(msg.getJMSRedelivered());\n+        redispatchSession.commit();\n+\n+        assertNull(redispatchConsumer.receive(500));\n+        redispatchSession.close();\n+    }\n+\n+\n+    public void testRedispatchOfRolledbackTx() throws Exception {\n+\n+        connection.start();\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        destination = createDestination(session, MessagingSessionFacade.DestinationType.TOPIC);\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n+\n+        sendMessages(connection, destination, 2);\n+\n+        assertNotNull(consumer.receive(1000));\n+        assertNotNull(consumer.receive(1000));\n+\n+        // install another consumer while message dispatch is unacked/uncommitted\n+\n+        session.rollback();\n+        session.close();\n+\n+        Session redispatchSession = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        MessageConsumer redispatchConsumer\n+            = redispatchSession.createDurableSubscriber((Topic) destination, \"subscriber-id1\");\n+\n+        Message msg = redispatchConsumer.receive(1000);\n+        assertNotNull(msg);\n+        // assertTrue(msg.getJMSRedelivered());\n+        msg = redispatchConsumer.receive(1000);\n+        assertNotNull(msg);\n+        // assertTrue(msg.getJMSRedelivered());\n+        redispatchSession.commit();\n+\n+        assertNull(redispatchConsumer.receive(500));\n+        redispatchSession.close();\n+    }\n+\n+    public void initCombosForTestAckOfExpired() {\n+        addCombinationValues(\"destinationType\",\n+                new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testAckOfExpired() throws Exception {\n+        HedwigConnectionFactoryImpl fact = new HedwigConnectionFactoryImpl();\n+        connection = fact.createConnection();\n+\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = (Destination) (destinationType == MessagingSessionFacade.DestinationType.QUEUE ?\n+                session.createTopic(\"test\") : session.createTopic(\"test\"));\n+\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+            MessageProducer producer = sendSession.createProducer(destination);\n+        final int count = 4;\n+\n+\n+        // producer.setTimeToLive(0);\n+        for (int i = 0; i < count; i++) {\n+            TextMessage message = sendSession.createTextMessage(\"no expiry\" + i);\n+            producer.send(message);\n+        }\n+\n+        MessageConsumer amqConsumer = (MessageConsumer) consumer;\n+\n+        for(int i=0; i<count; i++) {\n+            TextMessage msg = (TextMessage) amqConsumer.receive();\n+            assertNotNull(msg);\n+            assertTrue(\"message has \\\"no expiry\\\" text: \" + msg.getText(), msg.getText().contains(\"no expiry\"));\n+\n+            // force an ack when there are expired messages\n+            msg.acknowledge();\n+        }\n+    }\n+}"},{"sha":"343919a9573575613b2779b50fc9e24406dbaebf","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSDurableTopicRedeliverTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Message;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JMSDurableTopicRedeliverTest extends JmsTopicRedeliverTest {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JMSDurableTopicRedeliverTest.class);\n+\n+    protected void setUp() throws Exception {\n+        durable = true;\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Sends and consumes the messages.\n+     *\n+     * @throws Exception\n+     */\n+    public void testRedeliverNewSession() throws Exception {\n+        String text = \"TEST: \" + System.currentTimeMillis();\n+        Message sendMessage = session.createTextMessage(text);\n+\n+        if (verbose) {\n+            LOG.info(\"About to send a message: \" + sendMessage + \" with text: \" + text);\n+        }\n+        producer.send(producerDestination, sendMessage);\n+\n+        // receive but don't acknowledge\n+        Message unackMessage = consumer.receive(1000);\n+        assertNotNull(unackMessage);\n+        String unackId = unackMessage.getJMSMessageID();\n+        assertEquals(((TextMessage)unackMessage).getText(), text);\n+        assertFalse(unackMessage.getJMSRedelivered());\n+        consumeSession.close();\n+        consumer.close();\n+\n+        // receive then acknowledge\n+        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumer = createConsumer();\n+        Message ackMessage = consumer.receive(1000);\n+        assertNotNull(ackMessage);\n+        ackMessage.acknowledge();\n+        String ackId = ackMessage.getJMSMessageID();\n+        assertEquals(((TextMessage)ackMessage).getText(), text);\n+        // assertTrue(ackMessage.getJMSRedelivered());\n+        assertEquals(unackId, ackId);\n+        consumeSession.close();\n+        consumer.close();\n+\n+        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumer = createConsumer();\n+        assertNull(consumer.receive(1000));\n+    }\n+}"},{"sha":"24551f381c3b57af08a2ebfea57a7955eae2c48e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","status":"added","additions":165,"deletions":0,"changes":165,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSIndividualAckTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,165 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+/**\n+ *\n+ */\n+public class JMSIndividualAckTest extends TestSupport {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if acknowledged messages are being consumed.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testAckedMessageAreConsumed() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        // Reset the session.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests if acknowledged messages are being consumed.\n+     *\n+     * @throws JMSException\n+     */\n+    // This test cant, unfortunately, pass\n+    //- in hedwig, acknowledge is a ACKNOWLEDGE UNTIL. So the last ack will ack all messages until then ...\n+    /*\n+    public void testLastMessageAcked() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        TextMessage msg1 = session.createTextMessage(\"msg1\");\n+        TextMessage msg2 = session.createTextMessage(\"msg2\");\n+        TextMessage msg3 = session.createTextMessage(\"msg3\");\n+        producer.send(msg1);\n+        producer.send(msg2);\n+        producer.send(msg3);\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        // Reset the session.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertEquals(msg1,msg);\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertEquals(msg2,msg);\n+        msg = consumer.receive(1000);\n+        assertNull(msg);\n+        session.close();\n+    }\n+    */\n+\n+    /**\n+     * Tests if unacknowledged messages are being re-delivered when the consumer connects again.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        // Don't ack the message.\n+\n+        // Reset the session.  This should cause the unacknowledged message to be re-delivered.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    protected String getQueueName() {\n+        return getClass().getName() + \".\" + getName();\n+    }\n+\n+}"},{"sha":"cee1698ada8286ea408c2f45ea72f7fe2b4d1a27","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","status":"added","additions":504,"deletions":0,"changes":504,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,504 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.net.URISyntaxException;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Vector;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MapMessage;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageEOFException;\n+import javax.jms.MessageFormatException;\n+import javax.jms.MessageProducer;\n+import javax.jms.ObjectMessage;\n+import javax.jms.Session;\n+import javax.jms.StreamMessage;\n+import javax.jms.TextMessage;\n+\n+import junit.framework.Test;\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.message.StreamMessageImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+\n+import javax.jms.Destination;\n+\n+/**\n+ * Test cases used to test the JMS message consumer.\n+ */\n+public class JMSMessageTest extends JmsTestSupport {\n+\n+    public Destination destination;\n+    public int deliveryMode = DeliveryMode.NON_PERSISTENT;\n+    public int prefetch;\n+    public int ackMode;\n+    public MessagingSessionFacade.DestinationType destinationType = MessagingSessionFacade.DestinationType.TOPIC;\n+    public boolean durableConsumer;\n+\n+    /**\n+     * Run all these tests in both marshaling and non-marshaling mode.\n+     */\n+    public void initCombos() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),\n+                                                           Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testTextMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // Send the message.\n+        {\n+            TextMessage message = session.createTextMessage();\n+            message.setText(\"Hi\");\n+            producer.send(message);\n+        }\n+\n+        // Check the Message\n+        {\n+            TextMessage message = (TextMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertEquals(\"Hi\", message.getText());\n+        }\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public static Test suite() {\n+        return suite(JMSMessageTest.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    protected ConnectionFactory createConnectionFactory() throws URISyntaxException {\n+        HedwigConnectionFactoryImpl factory = new HedwigConnectionFactoryImpl();\n+        return factory;\n+    }\n+\n+    public void testBytesMessageLength() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // Send the message\n+        {\n+            BytesMessage message = session.createBytesMessage();\n+            message.writeInt(1);\n+            message.writeInt(2);\n+            message.writeInt(3);\n+            message.writeInt(4);\n+            producer.send(message);\n+        }\n+\n+        // Check the message.\n+        {\n+            BytesMessage message = (BytesMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertEquals(16, message.getBodyLength());\n+        }\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void testObjectMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // send the message.\n+        {\n+            ObjectMessage message = session.createObjectMessage();\n+            message.setObject(\"Hi\");\n+            producer.send(message);\n+        }\n+\n+        // Check the message\n+        {\n+            ObjectMessage message = (ObjectMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertEquals(\"Hi\", message.getObject());\n+        }\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void testBytesMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // Send the message\n+        {\n+            BytesMessage message = session.createBytesMessage();\n+            message.writeBoolean(true);\n+            producer.send(message);\n+        }\n+\n+        // Check the message\n+        {\n+            BytesMessage message = (BytesMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertTrue(message.readBoolean());\n+\n+            try {\n+                message.readByte();\n+                fail(\"Expected exception not thrown.\");\n+            } catch (MessageEOFException e) {\n+            }\n+\n+        }\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void testStreamMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // Send the message.\n+        {\n+            StreamMessage message = session.createStreamMessage();\n+            message.writeString(\"This is a test to see how it works.\");\n+            producer.send(message);\n+        }\n+\n+        // Check the message.\n+        {\n+            StreamMessage message = (StreamMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+\n+            // Invalid conversion should throw exception and not move the stream\n+            // position.\n+            try {\n+                message.readByte();\n+                fail(\"Should have received NumberFormatException\");\n+            } catch (NumberFormatException e) {\n+            } catch (MessageFormatException e) {\n+            }\n+\n+            assertEquals(\"This is a test to see how it works.\", message.readString());\n+\n+            // Invalid conversion should throw exception and not move the stream\n+            // position.\n+            try {\n+                message.readByte();\n+                fail(\"Should have received MessageEOFException\");\n+            } catch (MessageEOFException e) {\n+            }\n+        }\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void testMapMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // send the message.\n+        {\n+            MapMessage message = session.createMapMessage();\n+            message.setBoolean(\"boolKey\", true);\n+            producer.send(message);\n+        }\n+\n+        // get the message.\n+        {\n+            MapMessage message = (MapMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertTrue(message.getBoolean(\"boolKey\"));\n+        }\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    static class ForeignMessage implements TextMessage {\n+\n+        public int deliveryMode;\n+\n+        private String messageId;\n+        private long timestamp;\n+        private String correlationId;\n+        private Destination replyTo;\n+        private Destination destination;\n+        private boolean redelivered;\n+        private String type;\n+        private long expiration;\n+        private int priority;\n+        private String text;\n+        private HashMap<String, Object> props = new HashMap<String, Object>();\n+\n+        public String getJMSMessageID() throws JMSException {\n+            return messageId;\n+        }\n+\n+        public void setJMSMessageID(String arg0) throws JMSException {\n+            messageId = arg0;\n+        }\n+\n+        public long getJMSTimestamp() throws JMSException {\n+            return timestamp;\n+        }\n+\n+        public void setJMSTimestamp(long arg0) throws JMSException {\n+            timestamp = arg0;\n+        }\n+\n+        public byte[] getJMSCorrelationIDAsBytes() throws JMSException {\n+            return null;\n+        }\n+\n+        public void setJMSCorrelationIDAsBytes(byte[] arg0) throws JMSException {\n+        }\n+\n+        public void setJMSCorrelationID(String arg0) throws JMSException {\n+            correlationId = arg0;\n+        }\n+\n+        public String getJMSCorrelationID() throws JMSException {\n+            return correlationId;\n+        }\n+\n+        public Destination getJMSReplyTo() throws JMSException {\n+            return replyTo;\n+        }\n+\n+        public void setJMSReplyTo(Destination arg0) throws JMSException {\n+            replyTo = arg0;\n+        }\n+\n+        public Destination getJMSDestination() throws JMSException {\n+            return destination;\n+        }\n+\n+        public void setJMSDestination(Destination arg0) throws JMSException {\n+            destination = arg0;\n+        }\n+\n+        public int getJMSDeliveryMode() throws JMSException {\n+            return deliveryMode;\n+        }\n+\n+        public void setJMSDeliveryMode(int arg0) throws JMSException {\n+            deliveryMode = arg0;\n+        }\n+\n+        public boolean getJMSRedelivered() throws JMSException {\n+            return redelivered;\n+        }\n+\n+        public void setJMSRedelivered(boolean arg0) throws JMSException {\n+            redelivered = arg0;\n+        }\n+\n+        public String getJMSType() throws JMSException {\n+            return type;\n+        }\n+\n+        public void setJMSType(String arg0) throws JMSException {\n+            type = arg0;\n+        }\n+\n+        public long getJMSExpiration() throws JMSException {\n+            return expiration;\n+        }\n+\n+        public void setJMSExpiration(long arg0) throws JMSException {\n+            expiration = arg0;\n+        }\n+\n+        public int getJMSPriority() throws JMSException {\n+            return priority;\n+        }\n+\n+        public void setJMSPriority(int arg0) throws JMSException {\n+            priority = arg0;\n+        }\n+\n+        public void clearProperties() throws JMSException {\n+        }\n+\n+        public boolean propertyExists(String arg0) throws JMSException {\n+            return false;\n+        }\n+\n+        public boolean getBooleanProperty(String arg0) throws JMSException {\n+            return false;\n+        }\n+\n+        public byte getByteProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public short getShortProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public int getIntProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public long getLongProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public float getFloatProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public double getDoubleProperty(String arg0) throws JMSException {\n+            return 0;\n+        }\n+\n+        public String getStringProperty(String arg0) throws JMSException {\n+            return (String)props.get(arg0);\n+        }\n+\n+        public Object getObjectProperty(String arg0) throws JMSException {\n+            return props.get(arg0);\n+        }\n+\n+        public Enumeration getPropertyNames() throws JMSException {\n+            return new Vector<String>(props.keySet()).elements();\n+        }\n+\n+        public void setBooleanProperty(String arg0, boolean arg1) throws JMSException {\n+        }\n+\n+        public void setByteProperty(String arg0, byte arg1) throws JMSException {\n+        }\n+\n+        public void setShortProperty(String arg0, short arg1) throws JMSException {\n+        }\n+\n+        public void setIntProperty(String arg0, int arg1) throws JMSException {\n+        }\n+\n+        public void setLongProperty(String arg0, long arg1) throws JMSException {\n+        }\n+\n+        public void setFloatProperty(String arg0, float arg1) throws JMSException {\n+        }\n+\n+        public void setDoubleProperty(String arg0, double arg1) throws JMSException {\n+        }\n+\n+        public void setStringProperty(String arg0, String arg1) throws JMSException {\n+            props.put(arg0, arg1);\n+        }\n+\n+        public void setObjectProperty(String arg0, Object arg1) throws JMSException {\n+            props.put(arg0, arg1);\n+        }\n+\n+        public void acknowledge() throws JMSException {\n+        }\n+\n+        public void clearBody() throws JMSException {\n+        }\n+\n+        public void setText(String arg0) throws JMSException {\n+            text = arg0;\n+        }\n+\n+        public String getText() throws JMSException {\n+            return text;\n+        }\n+    }\n+\n+    public void testForeignMessage() throws Exception {\n+\n+        // Receive a message with the JMS API\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageProducer producer = session.createProducer(destination);\n+\n+        // Send the message.\n+        {\n+            ForeignMessage message = new ForeignMessage();\n+            message.text = \"Hello\";\n+            message.setStringProperty(\"test\", \"value\");\n+            // long timeToLive = 10000L;\n+            long timeToLive = 0L;\n+            long start = System.currentTimeMillis();\n+            producer.send(message, Session.AUTO_ACKNOWLEDGE, 7, timeToLive);\n+            long end = System.currentTimeMillis();\n+\n+\n+            //validate jms spec 1.1 section 3.4.11 table 3.1\n+            // JMSDestination, JMSDeliveryMode,  JMSPriority, JMSMessageID, and JMSTimestamp\n+            //must be set by sending a message.\n+\n+            // This is NOT specified in the spec !\n+            // exception for jms destination as the format is provider defined so it is only set on the copy\n+            // assertNull(message.getJMSDestination());\n+\n+            assertEquals(Session.AUTO_ACKNOWLEDGE, message.getJMSDeliveryMode());\n+            // assertTrue(start  + timeToLive <= message.getJMSExpiration());\n+            // assertTrue(end + timeToLive >= message.getJMSExpiration());\n+            assertEquals(7, message.getJMSPriority());\n+            assertNotNull(message.getJMSMessageID());\n+            assertTrue(start <= message.getJMSTimestamp());\n+            assertTrue(end >= message.getJMSTimestamp());\n+        }\n+\n+        // Validate message is OK.\n+        {\n+            TextMessage message = (TextMessage)consumer.receive(1000);\n+            assertNotNull(message);\n+            assertEquals(\"Hello\", message.getText());\n+            assertEquals(\"value\", message.getStringProperty(\"test\"));\n+        }\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+}"},{"sha":"cadb071d5ade1de32dbf691998e5acb45b1e8948","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","status":"added","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JMSUsecaseTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,109 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+import junit.framework.Test;\n+\n+import javax.jms.Destination;\n+\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.message.MessageImpl;\n+\n+public class JMSUsecaseTest extends JmsTestSupport {\n+\n+    public Destination destination;\n+    public int deliveryMode;\n+    public int prefetch;\n+    public MessagingSessionFacade.DestinationType destinationType;\n+    public boolean durableConsumer;\n+\n+    public static Test suite() {\n+        return suite(JMSUsecaseTest.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public void initCombosForTestSendReceive() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testSendReceive() throws Exception {\n+        // Send a message to the broker.\n+        connection.start();\n+        SessionImpl session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        destination = createDestination(session, destinationType);\n+        MessageProducer producer = session.createProducer(destination);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        MessageImpl message = new MessageImpl(session);\n+        producer.send(message);\n+\n+        // Make sure only 1 message was delivered.\n+        assertNotNull(consumer.receive(1000));\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    public void initCombosForTestSendReceiveTransacted() {\n+        addCombinationValues(\"deliveryMode\", new Object[] {\n+                Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});\n+        addCombinationValues(\"destinationType\", new Object[] {MessagingSessionFacade.DestinationType.TOPIC});\n+    }\n+\n+    public void testSendReceiveTransacted() throws Exception {\n+        // Send a message to the broker.\n+        connection.start();\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        destination = createDestination(session, destinationType);\n+        MessageProducer producer = session.createProducer(destination);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        producer.send(session.createTextMessage(\"test\"));\n+\n+        // Message should not be delivered until commit.\n+        assertNull(consumer.receiveNoWait());\n+        session.commit();\n+\n+        // Make sure only 1 message was delivered.\n+        Message message = consumer.receive(1000);\n+        assertNotNull(message);\n+        assertFalse(message.getJMSRedelivered());\n+        assertNull(consumer.receiveNoWait());\n+\n+        // Message should be redelivered is rollback is used.\n+        session.rollback();\n+\n+        // Make sure only 1 message was delivered.\n+        message = consumer.receive(2000);\n+        assertNotNull(message);\n+        assertTrue(message.getJMSRedelivered());\n+        assertNull(consumer.receiveNoWait());\n+\n+        // If we commit now, the message should not be redelivered.\n+        session.commit();\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+}"},{"sha":"ec5243f6725bb237f35a5b38d3149793e68470db","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckListenerTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,77 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Connection;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+public class JmsAutoAckListenerTest extends TestSupport implements MessageListener {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if acknowleged messages are being consumed.\n+     *\n+     * @throws javax.jms.JMSException\n+     */\n+    public void testAckedMessageAreConsumed() throws Exception {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"test\");\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        consumer.setMessageListener(this);\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+\n+        Thread.sleep(10000);\n+        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        // Attempt to Consume the message...check if message was acknowledge\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        Message msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+\n+    public void onMessage(Message message) {\n+        assertNotNull(message);\n+\n+    }\n+}"},{"sha":"13eaa2742f91df69d586b5e006eed437160b81d7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsAutoAckTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,75 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+public class JmsAutoAckTest extends TestSupport {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if acknowleged messages are being consumed.\n+     *\n+     * @throws javax.jms.JMSException\n+     */\n+    public void testAckedMessageAreConsumed() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"test\");\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+\n+        // Reset the session.\n+        session.close();\n+        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+}"},{"sha":"dd914b5f2fda3e934a93539c8a2bfa35e8d17cb2","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","status":"added","additions":204,"deletions":0,"changes":204,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsBenchmark.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,204 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.jms.BytesMessage;\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.DeliveryMode;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+import junit.framework.Test;\n+\n+\n+\n+import javax.jms.Destination;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Benchmarks the broker by starting many consumer and producers against the\n+ * same destination. Make sure you run with jvm option -server (makes a big\n+ * difference). The tests simulate storing 1000 1k jms messages to see the rate\n+ * of processing msg/sec.\n+ */\n+public class JmsBenchmark extends JmsTestSupport {\n+    private static final transient Logger LOG = LoggerFactory.getLogger(JmsBenchmark.class);\n+\n+    private static final long SAMPLE_DELAY = Integer.parseInt(System.getProperty(\"SAMPLE_DELAY\", \"\" + 1000 * 5));\n+    private static final long SAMPLES = Integer.parseInt(System.getProperty(\"SAMPLES\", \"10\"));\n+    private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\",\n+                                                                                    \"\" + 1000 * 60));\n+    private static final int PRODUCER_COUNT = Integer.parseInt(System.getProperty(\"PRODUCER_COUNT\", \"10\"));\n+    private static final int CONSUMER_COUNT = Integer.parseInt(System.getProperty(\"CONSUMER_COUNT\", \"10\"));\n+\n+    public Destination destination;\n+\n+    public static Test suite() {\n+        return suite(JmsBenchmark.class);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(JmsBenchmark.class);\n+    }\n+\n+    public void initCombos() {\n+        addCombinationValues(\"destination\", new Object[] {SessionImpl.asTopic(\"TEST\")});\n+    }\n+\n+    protected ConnectionFactory createConnectionFactory() throws URISyntaxException, IOException {\n+        return new HedwigConnectionFactoryImpl();\n+    }\n+\n+    /**\n+     * @throws Throwable\n+     */\n+    public void testConcurrentSendReceive() throws Throwable {\n+\n+        final Semaphore connectionsEstablished = new Semaphore(1 - (CONSUMER_COUNT + PRODUCER_COUNT));\n+        final Semaphore workerDone = new Semaphore(1 - (CONSUMER_COUNT + PRODUCER_COUNT));\n+        final CountDownLatch sampleTimeDone = new CountDownLatch(1);\n+\n+        final AtomicInteger producedMessages = new AtomicInteger(0);\n+        final AtomicInteger receivedMessages = new AtomicInteger(0);\n+\n+        final Callable producer = new Callable() {\n+            public Object call() throws JMSException, InterruptedException {\n+                Connection connection = factory.createConnection();\n+                connections.add(connection);\n+                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+                MessageProducer producer = session.createProducer(destination);\n+                producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n+                BytesMessage message = session.createBytesMessage();\n+                message.writeBytes(new byte[1024]);\n+                connection.start();\n+                connectionsEstablished.release();\n+\n+                while (!sampleTimeDone.await(0, TimeUnit.MILLISECONDS)) {\n+                    producer.send(message);\n+                    producedMessages.incrementAndGet();\n+                }\n+\n+                connection.close();\n+                workerDone.release();\n+                return null;\n+            }\n+        };\n+\n+        final Callable consumer = new Callable() {\n+            public Object call() throws JMSException, InterruptedException {\n+                Connection connection = factory.createConnection();\n+                connections.add(connection);\n+                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+                MessageConsumer consumer = session.createConsumer(destination);\n+\n+                consumer.setMessageListener(new MessageListener() {\n+                    public void onMessage(Message msg) {\n+                        receivedMessages.incrementAndGet();\n+                    }\n+                });\n+                connection.start();\n+\n+                connectionsEstablished.release();\n+                sampleTimeDone.await();\n+\n+                connection.close();\n+                workerDone.release();\n+                return null;\n+            }\n+        };\n+\n+        final Throwable workerError[] = new Throwable[1];\n+        for (int i = 0; i < PRODUCER_COUNT; i++) {\n+            new Thread(\"Producer:\" + i) {\n+                public void run() {\n+                    try {\n+                        producer.call();\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                        workerError[0] = e;\n+                    }\n+                }\n+            }.start();\n+        }\n+\n+        for (int i = 0; i < CONSUMER_COUNT; i++) {\n+            new Thread(\"Consumer:\" + i) {\n+                public void run() {\n+                    try {\n+                        consumer.call();\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                        workerError[0] = e;\n+                    }\n+                }\n+            }.start();\n+        }\n+\n+        LOG.info(getName() + \": Waiting for Producers and Consumers to startup.\");\n+        connectionsEstablished.acquire();\n+        LOG.info(\"Producers and Consumers are now running.  Waiting for system to reach steady state: \"\n+                 + (SAMPLE_DELAY / 1000.0f) + \" seconds\");\n+        Thread.sleep(1000 * 10);\n+\n+        LOG.info(\"Starting sample: \" + SAMPLES + \" each lasting \" + (SAMPLE_DURATION / 1000.0f) + \" seconds\");\n+\n+        for (int i = 0; i < SAMPLES; i++) {\n+\n+            long start = System.currentTimeMillis();\n+            producedMessages.set(0);\n+            receivedMessages.set(0);\n+\n+            Thread.sleep(SAMPLE_DURATION);\n+\n+            long end = System.currentTimeMillis();\n+            int r = receivedMessages.get();\n+            int p = producedMessages.get();\n+\n+            LOG.info(\"published: \" + p + \" msgs at \" + (p * 1000f / (end - start)) + \" msgs/sec, \"\n+                     + \"consumed: \" + r + \" msgs at \" + (r * 1000f / (end - start)) + \" msgs/sec\");\n+        }\n+\n+        LOG.info(\"Sample done.\");\n+        sampleTimeDone.countDown();\n+\n+        workerDone.acquire();\n+        if (workerError[0] != null) {\n+            throw workerError[0];\n+        }\n+\n+    }\n+\n+}"},{"sha":"78d7fb3de4597a348f9cdf381302bdf9d57f1e71","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckListenerTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,127 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Connection;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+public class JmsClientAckListenerTest extends TestSupport implements MessageListener {\n+\n+    private Connection connection;\n+    private boolean dontAck;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if acknowleged messages are being consumed.\n+     *\n+     * @throws javax.jms.JMSException\n+     */\n+    public void testAckedMessageAreConsumed() throws Exception {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"test\");\n+        MessageProducer producer = session.createProducer(queue);\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        consumer.setMessageListener(this);\n+\n+        Thread.sleep(10000);\n+\n+        // Reset the session.\n+        session.close();\n+\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        Message msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests if unacknowleged messages are being redelivered when the consumer\n+     * connects again.\n+     *\n+     * @throws javax.jms.JMSException\n+     */\n+    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws Exception {\n+        connection.start();\n+        // don't aknowledge message on onMessage() call\n+        dontAck = true;\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"test\");\n+        MessageProducer producer = session.createProducer(queue);\n+        // Consume the message...\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        consumer.setMessageListener(this);\n+\n+        // Don't ack the message.\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Reset the session. This should cause the Unacked message to be\n+        // redelivered.\n+        session.close();\n+\n+        Thread.sleep(10000);\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        Message msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    public void onMessage(Message message) {\n+\n+        assertNotNull(message);\n+        if (!dontAck) {\n+            try {\n+                message.acknowledge();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+\n+        }\n+\n+    }\n+}"},{"sha":"c4aa3c6d70ba91bac5053c95465d44642f8829d0","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsClientAckTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+public class JmsClientAckTest extends TestSupport {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if acknowledged messages are being consumed.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testAckedMessageAreConsumed() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        // Reset the session.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests if acknowledged messages are being consumed.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testLastMessageAcked() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        producer.send(session.createTextMessage(\"Hello\"));\n+        producer.send(session.createTextMessage(\"Hello2\"));\n+        producer.send(session.createTextMessage(\"Hello3\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        // Reset the session.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        msg = consumer.receive(1000);\n+        assertNull(msg);\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests if unacknowledged messages are being re-delivered when the consumer connects again.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testUnAckedMessageAreNotConsumedOnSessionClose() throws JMSException {\n+        connection.start();\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getQueueName());\n+        MessageProducer producer = session.createProducer(queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n+        producer.send(session.createTextMessage(\"Hello\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        // Don't ack the message.\n+\n+        // Reset the session.  This should cause the unacknowledged message to be re-delivered.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id3\");\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    protected String getQueueName() {\n+        return getClass().getName() + \".\" + getName();\n+    }\n+\n+}"},{"sha":"36496146654eafde7506438d53f85f762dff51e7","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","status":"added","additions":169,"deletions":0,"changes":169,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConnectionStartStopTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,169 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import org.apache.hedwig.jms.DebugUtil;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import java.util.Random;\n+import java.util.Vector;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import javax.jms.Connection;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+public class JmsConnectionStartStopTest extends TestSupport {\n+\n+    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory\n+        .getLog(JmsConnectionStartStopTest.class);\n+\n+    private Connection startedConnection;\n+    private Connection stoppedConnection;\n+\n+    /**\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+\n+        super.setUp();\n+        LOG.info(getClass().getClassLoader().getResource(\"log4j.properties\"));\n+\n+        HedwigConnectionFactoryImpl factory = createConnectionFactory();\n+        startedConnection = factory.createConnection();\n+        startedConnection.start();\n+        stoppedConnection = factory.createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        stoppedConnection.close();\n+        startedConnection.close();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if the consumer receives the messages that were sent before the\n+     * connection was started.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testStoppedConsumerHoldsMessagesTillStarted() throws JMSException {\n+        Session startedSession = startedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Session stoppedSession = stoppedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        // Setup the consumers.\n+        Topic topic = startedSession.createTopic(\"test\");\n+        MessageConsumer startedConsumer = startedSession.createConsumer(topic);\n+        MessageConsumer stoppedConsumer = stoppedSession.createConsumer(topic);\n+\n+        // Send the message.\n+        MessageProducer producer = startedSession.createProducer(topic);\n+        TextMessage message = startedSession.createTextMessage(\"Hello\");\n+        producer.send(message);\n+\n+        // Test the assertions.\n+        Message m = startedConsumer.receive(1000);\n+        assertNotNull(m);\n+\n+        m = stoppedConsumer.receive(1000);\n+        assertNull(m);\n+\n+        stoppedConnection.start();\n+        m = stoppedConsumer.receive(5000);\n+        assertNotNull(m);\n+\n+        startedSession.close();\n+        stoppedSession.close();\n+    }\n+\n+    /**\n+     * Tests if the consumer is able to receive messages eveb when the\n+     * connecction restarts multiple times.\n+     *\n+     * @throws Exception\n+     */\n+    public void testMultipleConnectionStops() throws Exception {\n+        testStoppedConsumerHoldsMessagesTillStarted();\n+        stoppedConnection.stop();\n+        testStoppedConsumerHoldsMessagesTillStarted();\n+        stoppedConnection.stop();\n+        testStoppedConsumerHoldsMessagesTillStarted();\n+    }\n+\n+\n+    public void testConcurrentSessionCreateWithStart() throws Exception {\n+        ThreadPoolExecutor executor = new ThreadPoolExecutor(50, Integer.MAX_VALUE,\n+                                      60L, TimeUnit.SECONDS,\n+                                      new SynchronousQueue<Runnable>());\n+        final Vector<Throwable> exceptions = new Vector<Throwable>();\n+        final Random rand = new Random();\n+        final int numIterations = 100;\n+        final CountDownLatch latch = new CountDownLatch(numIterations * 2);\n+        Runnable createSessionTask = new Runnable() {\n+            public void run() {\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(10));\n+                    latch.countDown();\n+                    stoppedConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    exceptions.add(e);\n+                }\n+            }\n+        };\n+\n+        Runnable startStopTask = new Runnable() {\n+            public void run() {\n+                try {\n+                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(10));\n+                    latch.countDown();\n+                    stoppedConnection.start();\n+                    stoppedConnection.stop();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    exceptions.add(e);\n+                }\n+            }\n+        };\n+\n+        for (int i=0; i<numIterations; i++) {\n+            executor.execute(createSessionTask);\n+            executor.execute(startStopTask);\n+        }\n+\n+        executor.shutdown();\n+        final long remaining;\n+        {\n+            boolean terminated = executor.awaitTermination(30, TimeUnit.SECONDS);\n+            remaining = latch.getCount();\n+            if (!terminated){\n+                DebugUtil.dumpAllStacktraces(System.err);\n+            }\n+            assertTrue(\"executor terminated. remaining : \" + remaining, terminated);\n+        }\n+        assertTrue(\"remaining : \" + remaining + \", no exceptions: \" + exceptions, exceptions.isEmpty());\n+    }\n+}"},{"sha":"aaf47f2d0ad64e2c6ea314250d293bc95b12d689","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","status":"added","additions":157,"deletions":0,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsConsumerResetActiveListenerTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,157 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import java.util.Vector;\n+\n+import org.apache.hedwig.JmsTestBase;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.jms.Connection;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import junit.framework.TestCase;\n+\n+\n+public class JmsConsumerResetActiveListenerTest extends JmsTestBase {\n+\n+    private Connection connection;\n+    private HedwigConnectionFactoryImpl factory;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        factory = new HedwigConnectionFactoryImpl();\n+        connection = factory.createConnection();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * verify the (undefined by spec) behaviour of setting a listener while receiving a message.\n+     *\n+     * @throws Exception\n+     */\n+    public void testSetListenerFromListener() throws Exception {\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Destination dest = session.createTopic(\"Queue-\" + getName());\n+        final MessageConsumer consumer = session.createConsumer(dest);\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        final AtomicBoolean first = new AtomicBoolean(true);\n+        final Vector<Object> results = new Vector<Object>();\n+        consumer.setMessageListener(new MessageListener() {\n+\n+            public void onMessage(Message message) {\n+                if (first.compareAndSet(true, false)) {\n+                    try {\n+                        consumer.setMessageListener(this);\n+                        results.add(message);\n+                    } catch (JMSException e) {\n+                        results.add(e);\n+                    }\n+                } else {\n+                    results.add(message);\n+                }\n+                latch.countDown();\n+            }\n+        });\n+\n+        connection.start();\n+\n+        MessageProducer producer = session.createProducer(dest);\n+        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n+        producer.send(session.createTextMessage(\"First\"));\n+        producer.send(session.createTextMessage(\"Second\"));\n+\n+        assertTrue(\"we did not timeout\", latch.await(5, TimeUnit.SECONDS));\n+\n+        assertEquals(\"we have a result\", 2, results.size());\n+        Object result = results.get(0);\n+        assertTrue(result instanceof TextMessage);\n+        assertEquals(\"result is first\", \"First\", ((TextMessage)result).getText());\n+        result = results.get(1);\n+        assertTrue(result instanceof TextMessage);\n+        assertEquals(\"result is first\", \"Second\", ((TextMessage)result).getText());\n+    }\n+\n+    /**\n+     * and a listener on a new consumer, just in case.\n+      *\n+     * @throws Exception\n+     */\n+    public void testNewConsumerSetListenerFromListener() throws Exception {\n+        final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        final Destination dest = session.createTopic(\"Queue-\" + getName());\n+        final MessageConsumer consumer = session.createConsumer(dest);\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        final AtomicBoolean first = new AtomicBoolean(true);\n+        final Vector<Object> results = new Vector<Object>();\n+        consumer.setMessageListener(new MessageListener() {\n+\n+            public void onMessage(Message message) {\n+                if (first.compareAndSet(true, false)) {\n+                    try {\n+                        MessageConsumer anotherConsumer = session.createConsumer(dest);\n+                        anotherConsumer.setMessageListener(this);\n+                        results.add(message);\n+                    } catch (JMSException e) {\n+                        results.add(e);\n+                    }\n+                } else {\n+                    results.add(message);\n+                }\n+                latch.countDown();\n+            }\n+        });\n+\n+        connection.start();\n+\n+        MessageProducer producer = session.createProducer(dest);\n+        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n+        producer.send(session.createTextMessage(\"First\"));\n+        producer.send(session.createTextMessage(\"Second\"));\n+\n+        assertTrue(\"we did not timeout\", latch.await(5, TimeUnit.SECONDS));\n+\n+        assertEquals(\"we have a result\", 2, results.size());\n+        Object result = results.get(0);\n+        assertTrue(result instanceof TextMessage);\n+        assertEquals(\"result is first\", \"First\", ((TextMessage)result).getText());\n+        result = results.get(1);\n+        assertTrue(result instanceof TextMessage);\n+        assertEquals(\"result is first\", \"Second\", ((TextMessage)result).getText());\n+    }\n+ }"},{"sha":"218bbe5dcd873f89ed91bc41a0610613f470ad2d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsCreateConsumerInOnMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.Topic;\n+\n+public class JmsCreateConsumerInOnMessageTest extends TestSupport implements MessageListener {\n+\n+    private Connection connection;\n+    private Session publisherSession;\n+    private Session consumerSession;\n+    private MessageConsumer consumer;\n+    private MessageConsumer testConsumer;\n+    private MessageProducer producer;\n+    private Topic topic;\n+    private Object lock = new Object();\n+\n+    /*\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        super.topic = true;\n+        connection = createConnection(false);\n+        connection.setClientID(\"connection:\" + getSubject());\n+        publisherSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        topic = (Topic)super.createDestination(\"Test.Topic\");\n+        consumer = consumerSession.createConsumer(topic);\n+        consumer.setMessageListener(this);\n+        producer = publisherSession.createProducer(topic);\n+        connection.start();\n+    }\n+\n+    /*\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        connection.close();\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Tests if a consumer can be created asynchronusly\n+     *\n+     * @throws Exception\n+     */\n+    public void testCreateConsumer() throws Exception {\n+        Message msg = super.createMessage();\n+        producer.send(msg);\n+        if (testConsumer == null) {\n+            synchronized (lock) {\n+                lock.wait(3000);\n+            }\n+        }\n+        assertTrue(testConsumer != null);\n+    }\n+\n+    /**\n+     * Use the asynchronous subscription mechanism\n+     *\n+     * @param message\n+     */\n+    public void onMessage(Message message) {\n+        try {\n+            testConsumer = consumerSession.createConsumer(topic);\n+            consumerSession.createProducer(topic);\n+            synchronized (lock) {\n+                lock.notify();\n+            }\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            assertTrue(false);\n+        }\n+    }\n+}"},{"sha":"548e7a81f291df2f8801c50a8f00a43b9b41fdb4","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSelectorTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,26 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+\n+public class JmsDurableTopicSelectorTest extends JmsTopicSelectorTest {\n+    public void setUp() throws Exception {\n+        durable = true;\n+        super.setUp();\n+    }\n+}"},{"sha":"b2e2ed736587d087f9d453d4e3374f88e9a494e5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicSendReceiveTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,87 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.Destination;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+import org.apache.activemq.test.JmsTopicSendReceiveTest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsDurableTopicSendReceiveTest extends JmsTopicSendReceiveTest {\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsDurableTopicSendReceiveTest.class);\n+\n+    protected Connection connection2;\n+    protected Session session2;\n+    protected Session consumeSession2;\n+    protected MessageConsumer consumer2;\n+    protected MessageProducer producer2;\n+    protected Destination consumerDestination2;\n+    protected Destination producerDestination2;\n+\n+    /**\n+     * Set up a durable suscriber test.\n+     *\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        this.durable = true;\n+        super.setUp();\n+    }\n+\n+    /**\n+     * Test if all the messages sent are being received.\n+     *\n+     * @throws Exception\n+     */\n+    public void testSendWhileClosed() throws Exception {\n+        connection2 = createConnection(false);\n+        if (null == connection.getClientID()) connection2.setClientID(getName() + \"test\");\n+        connection2.start();\n+        session2 = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        producer2 = session2.createProducer(null);\n+        producer2.setDeliveryMode(deliveryMode);\n+        producerDestination2 = session2.createTopic(getProducerSubject() + \"2\");\n+        Thread.sleep(1000);\n+\n+        consumeSession2 = connection2.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        consumerDestination2 = session2.createTopic(getConsumerSubject() + \"2\");\n+        consumer2 = consumeSession2.createDurableSubscriber((Topic)consumerDestination2, getName());\n+        Thread.sleep(1000);\n+        consumer2.close();\n+        TextMessage message = session2.createTextMessage(\"test\");\n+        message.setStringProperty(\"test\", \"test\");\n+        message.setJMSType(\"test\");\n+        producer2.send(producerDestination2, message);\n+        LOG.info(\"Creating durable consumer\");\n+        consumer2 = consumeSession2.createDurableSubscriber((Topic)consumerDestination2, getName());\n+        Message msg = consumer2.receive(1000);\n+        assertNotNull(msg);\n+        assertEquals(((TextMessage)msg).getText(), \"test\");\n+        assertEquals(msg.getJMSType(), \"test\");\n+        assertEquals(msg.getStringProperty(\"test\"), \"test\");\n+        connection2.stop();\n+        connection2.close();\n+    }\n+}"},{"sha":"c0da42febbbea1aea5d8283dd048cdd3abda121c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsDurableTopicTransactionTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,38 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.DeliveryMode;\n+\n+import org.apache.activemq.test.JmsResourceProvider;\n+\n+public class JmsDurableTopicTransactionTest extends JmsTopicTransactionTest {\n+\n+    /**\n+     * @see JmsTransactionTestSupport#getJmsResourceProvider()\n+     */\n+    protected JmsResourceProvider getJmsResourceProvider() {\n+        JmsResourceProvider provider = new JmsResourceProvider();\n+        provider.setTopic(true);\n+        provider.setDeliveryMode(DeliveryMode.PERSISTENT);\n+        provider.setClientID(getClass().getName());\n+        provider.setDurableName(getName());\n+        return provider;\n+    }\n+\n+}"},{"sha":"3873a0f48525032aa57d90bef4c8c9401cf23665","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","status":"added","additions":281,"deletions":0,"changes":281,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsMultipleClientsTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.net.URI;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.TopicSubscriber;\n+\n+\n+\n+import javax.jms.Destination;\n+\n+\n+import org.apache.activemq.util.MessageIdList;\n+\n+/**\n+ * Test case support used to test multiple message comsumers and message\n+ * producers connecting to a single broker.\n+ */\n+public class JmsMultipleClientsTestSupport extends CombinationTestSupport {\n+\n+    protected Map<MessageConsumer, MessageIdList> consumers\n+        = new HashMap<MessageConsumer, MessageIdList>(); // Map of consumer with messages received\n+    protected int consumerCount = 1;\n+    protected int producerCount = 1;\n+\n+    protected int messageSize = 1024;\n+\n+    protected boolean useConcurrentSend = true;\n+    protected boolean autoFail = true;\n+    protected boolean durable;\n+    public boolean topic;\n+    protected boolean persistent;\n+\n+    protected Destination destination;\n+    protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());\n+    protected MessageIdList allMessagesList = new MessageIdList();\n+\n+    private AtomicInteger producerLock;\n+\n+    protected void startProducers(Destination dest, int msgCount) throws Exception {\n+        startProducers(createConnectionFactory(), dest, msgCount);\n+    }\n+\n+    protected void startProducers(final ConnectionFactory factory,\n+                                  final Destination dest, final int msgCount) throws Exception {\n+        // Use concurrent send\n+        if (useConcurrentSend) {\n+            producerLock = new AtomicInteger(producerCount);\n+\n+            for (int i = 0; i < producerCount; i++) {\n+                Thread t = new Thread(new Runnable() {\n+                    public void run() {\n+                        try {\n+                            sendMessages(factory.createConnection(), dest, msgCount);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n+                        }\n+\n+                        synchronized (producerLock) {\n+                            producerLock.decrementAndGet();\n+                            producerLock.notifyAll();\n+                        }\n+                    }\n+                });\n+\n+                t.start();\n+            }\n+\n+            // Wait for all producers to finish sending\n+            synchronized (producerLock) {\n+                while (producerLock.get() != 0) {\n+                    producerLock.wait(2000);\n+                }\n+            }\n+\n+            // Use serialized send\n+        } else {\n+            for (int i = 0; i < producerCount; i++) {\n+                sendMessages(factory.createConnection(), dest, msgCount);\n+            }\n+        }\n+    }\n+\n+    protected void sendMessages(Connection connection, Destination destination, int count) throws Exception {\n+        connections.add(connection);\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        MessageProducer producer = session.createProducer(destination);\n+        producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);\n+\n+        for (int i = 0; i < count; i++) {\n+            TextMessage msg = createTextMessage(session, \"\" + i);\n+            producer.send(msg);\n+        }\n+\n+        producer.close();\n+        session.close();\n+        connection.close();\n+    }\n+\n+    protected TextMessage createTextMessage(Session session, String initText) throws Exception {\n+        TextMessage msg = session.createTextMessage();\n+\n+        // Pad message text\n+        if (initText.length() < messageSize) {\n+            char[] data = new char[messageSize - initText.length()];\n+            Arrays.fill(data, '*');\n+            String str = new String(data);\n+            msg.setText(initText + str);\n+\n+            // Do not pad message text\n+        } else {\n+            msg.setText(initText);\n+        }\n+\n+        return msg;\n+    }\n+\n+    protected void startConsumers(Destination dest) throws Exception {\n+        startConsumers(createConnectionFactory(), dest);\n+    }\n+\n+    protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {\n+        MessageConsumer consumer;\n+        for (int i = 0; i < consumerCount; i++) {\n+            if (durable && topic) {\n+                consumer = createDurableSubscriber(factory.createConnection(), dest, \"consumer\" + (i + 1));\n+            } else {\n+                consumer = createMessageConsumer(factory.createConnection(), dest);\n+            }\n+            MessageIdList list = new MessageIdList();\n+            list.setParent(allMessagesList);\n+            consumer.setMessageListener(list);\n+            consumers.put(consumer, list);\n+        }\n+    }\n+\n+    protected MessageConsumer createMessageConsumer(Connection conn, Destination dest) throws Exception {\n+        connections.add(conn);\n+\n+        Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        final MessageConsumer consumer = sess.createConsumer(dest);\n+        conn.start();\n+\n+        return consumer;\n+    }\n+\n+    protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {\n+        conn.setClientID(name);\n+        connections.add(conn);\n+        conn.start();\n+\n+        Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);\n+\n+        return consumer;\n+    }\n+\n+    protected void waitForAllMessagesToBeReceived(int messageCount) throws Exception {\n+        allMessagesList.waitForMessagesToArrive(messageCount);\n+    }\n+\n+    protected Destination createDestination() throws JMSException {\n+        String name = \".\" + getClass().getName() + \".\" + getName();\n+        // ensure not inadvertently composite because of combos\n+        name = name.replace(' ','_');\n+        name = name.replace(',','&');\n+        if (topic) {\n+            destination = SessionImpl.asTopic(\"Topic\" + name);\n+            return (Destination)destination;\n+        } else {\n+            destination = SessionImpl.asTopic(\"Queue\" + name);\n+            return (Destination)destination;\n+        }\n+    }\n+\n+    protected ConnectionFactory createConnectionFactory() throws Exception {\n+        return new HedwigConnectionFactoryImpl();\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setAutoFail(autoFail);\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {\n+            Connection conn = iter.next();\n+            try {\n+                conn.close();\n+            } catch (Throwable e) {\n+            }\n+        }\n+        allMessagesList.flushMessages();\n+        consumers.clear();\n+        super.tearDown();\n+    }\n+\n+    /*\n+     * Some helpful assertions for multiple consumers.\n+     */\n+    protected void assertConsumerReceivedAtLeastXMessages(MessageConsumer consumer, int msgCount) {\n+        MessageIdList messageIdList = consumers.get(consumer);\n+        messageIdList.assertAtLeastMessagesReceived(msgCount);\n+    }\n+\n+    protected void assertConsumerReceivedAtMostXMessages(MessageConsumer consumer, int msgCount) {\n+        MessageIdList messageIdList = consumers.get(consumer);\n+        messageIdList.assertAtMostMessagesReceived(msgCount);\n+    }\n+\n+    protected void assertConsumerReceivedXMessages(MessageConsumer consumer, int msgCount) {\n+        MessageIdList messageIdList = consumers.get(consumer);\n+        messageIdList.assertMessagesReceivedNoWait(msgCount);\n+    }\n+\n+    protected void assertEachConsumerReceivedAtLeastXMessages(int msgCount) {\n+        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n+            assertConsumerReceivedAtLeastXMessages(i.next(), msgCount);\n+        }\n+    }\n+\n+    protected void assertEachConsumerReceivedAtMostXMessages(int msgCount) {\n+        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n+            assertConsumerReceivedAtMostXMessages(i.next(), msgCount);\n+        }\n+    }\n+\n+    protected void assertEachConsumerReceivedXMessages(int msgCount) {\n+        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n+            assertConsumerReceivedXMessages(i.next(), msgCount);\n+        }\n+    }\n+\n+    protected void assertTotalMessagesReceived(int msgCount) {\n+        allMessagesList.assertMessagesReceivedNoWait(msgCount);\n+\n+        // now lets count the individual messages received\n+        int totalMsg = 0;\n+        for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {\n+            MessageIdList messageIdList = consumers.get(i.next());\n+            totalMsg += messageIdList.getMessageCount();\n+        }\n+        assertEquals(\"Total of consumers message count\", msgCount, totalMsg);\n+    }\n+}"},{"sha":"fba706456fdcb2fc0e88bd39de9cddae63a53f38","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","status":"added","additions":380,"deletions":0,"changes":380,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRedeliveredTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,380 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+\n+import org.apache.hedwig.JmsTestBase;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class JmsRedeliveredTest extends JmsTestBase {\n+\n+    private Connection connection;\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Creates a connection.\n+     *\n+     * @return connection\n+     * @throws Exception\n+     */\n+    protected Connection createConnection() throws Exception {\n+        HedwigConnectionFactoryImpl factory = new HedwigConnectionFactoryImpl();\n+        return factory.createConnection();\n+    }\n+\n+    /**\n+     * Tests if a message unacknowledged message gets to be resent when the\n+     * session is closed and then a new consumer session is created.\n+     *\n+     */\n+    public void testTopicSessionCloseMarksMessageRedelivered() throws JMSException {\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"queue-\" + getName());\n+        MessageProducer producer = createProducer(session, queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        producer.send(createTextMessage(session));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+        // Don't ack the message.\n+\n+        // Reset the session. This should cause the Unacked message to be\n+        // redelivered.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id1\");\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        // Since we only simulate this in provider, we cannot do this across consumers !\n+        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+\n+    public void testTopicSessionCloseMarksUnAckedMessageRedelivered() throws JMSException {\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"queue-\" + getName());\n+        MessageProducer producer = createProducer(session, queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        producer.send(createTextMessage(session, \"1\"));\n+        producer.send(createTextMessage(session, \"2\"));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+        assertEquals(\"1\", ((TextMessage)msg).getText());\n+        msg.acknowledge();\n+\n+        // Don't ack the message.\n+        msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+        assertEquals(\"2\", ((TextMessage)msg).getText());\n+\n+        // Reset the session. This should cause the Unacked message to be\n+        // redelivered.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(queue, \"subscriber-id2\");\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        assertEquals(\"2\", ((TextMessage)msg).getText());\n+        // Since we only simulate this in provider, we cannot do this across consumers !\n+        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests session recovery and that the redelivered message is marked as\n+     * such. Session uses client acknowledgement, the destination is a queue.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testTopicRecoverMarksMessageRedelivered() throws Exception {\n+        connection.setClientID(getName());\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"queue-\" + getName());\n+        MessageProducer producer = createProducer(session, queue);\n+        MessageConsumer consumer = session.createDurableSubscriber(queue, getName() + \" - subscriber\");\n+        producer.send(createTextMessage(session));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+        // Don't ack the message.\n+\n+        // We DO NOT support session recovery\n+        // - to unblock this test, I am stopp'ing and start'ing connection : not the same, but ...\n+        // Reset the session. This should cause the Unacked message to be\n+        // redelivered.\n+        // session.recover();\n+        connection.close();\n+        connection = createConnection();\n+        connection.setClientID(getName());\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumer = session.createDurableSubscriber(queue, getName() + \" - subscriber\");\n+        connection.start();\n+\n+        // Attempt to Consume the message...\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests rollback message to be marked as redelivered. Session uses client\n+     * acknowledgement and the destination is a queue.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testTopicRollbackMarksMessageRedelivered() throws JMSException {\n+        connection.start();\n+\n+        Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(\"queue-\" + getName());\n+        MessageProducer producer = createProducer(session, queue);\n+        MessageConsumer consumer = session.createConsumer(queue);\n+        producer.send(createTextMessage(session));\n+        session.commit();\n+\n+        // Get the message... Should not be redelivered.\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+\n+        // Rollback.. should cause redelivery.\n+        session.rollback();\n+\n+        // Attempt to Consume the message...\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+\n+        session.commit();\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests if the message gets to be re-delivered when the session closes and\n+     * that the re-delivered message is marked as such. Session uses client\n+     * acknowledgment, the destination is a topic and the consumer is a durable\n+     * subscriber.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testDurableTopicSessionCloseMarksMessageRedelivered() throws JMSException {\n+        connection.setClientID(getName());\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        Topic topic = session.createTopic(\"topic-\" + getName());\n+        MessageConsumer consumer = session.createDurableSubscriber(topic, \"sub1\");\n+\n+        // This case only works with persistent messages since transient\n+        // messages\n+        // are dropped when the consumer goes offline.\n+        MessageProducer producer = session.createProducer(topic);\n+        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n+        producer.send(createTextMessage(session));\n+\n+        // Consume the message...\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be re-delivered.\", msg.getJMSRedelivered());\n+        // Don't ack the message.\n+\n+        // Reset the session. This should cause the Unacked message to be\n+        // re-delivered.\n+        session.close();\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        // Attempt to Consume the message...\n+        consumer = session.createDurableSubscriber(topic, \"sub1\");\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        // Since we only simulate this in provider, we cannot do this across consumers !\n+        // assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+        msg.acknowledge();\n+\n+        session.close();\n+    }\n+\n+    /**\n+     * Tests rollback message to be marked as redelivered. Session uses client\n+     * acknowledgement and the destination is a topic.\n+     *\n+     * @throws JMSException\n+     */\n+    public void testDurableTopicRollbackMarksMessageRedelivered() throws JMSException {\n+        if (null == connection.getClientID()) connection.setClientID(getName());\n+        connection.start();\n+\n+        Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);\n+        Topic topic = session.createTopic(\"topic-\" + getName());\n+        MessageConsumer consumer = session.createDurableSubscriber(topic, \"sub1\");\n+\n+        MessageProducer producer = createProducer(session, topic);\n+        producer.send(createTextMessage(session));\n+        session.commit();\n+\n+        // Get the message... Should not be redelivered.\n+        Message msg = consumer.receive(1000);\n+        assertNotNull(msg);\n+        assertFalse(\"Message should not be redelivered.\", msg.getJMSRedelivered());\n+\n+        // Rollback.. should cause redelivery.\n+        session.rollback();\n+\n+        // Attempt to Consume the message...\n+        msg = consumer.receive(2000);\n+        assertNotNull(msg);\n+        assertTrue(\"Message should be redelivered.\", msg.getJMSRedelivered());\n+\n+        session.commit();\n+        session.close();\n+    }\n+\n+    /**\n+     * Creates a text message.\n+     *\n+     * @param session\n+     * @return TextMessage.\n+     * @throws JMSException\n+     */\n+    private TextMessage createTextMessage(Session session) throws JMSException {\n+        return createTextMessage(session, \"Hello\");\n+    }\n+\n+    private TextMessage createTextMessage(Session session, String txt) throws JMSException {\n+        return session.createTextMessage(txt);\n+    }\n+\n+    /**\n+     * Creates a producer.\n+     *\n+     * @param session\n+     * @param queue - destination.\n+     * @return MessageProducer\n+     * @throws JMSException\n+     */\n+    private MessageProducer createProducer(Session session, Destination queue) throws JMSException {\n+        MessageProducer producer = session.createProducer(queue);\n+        producer.setDeliveryMode(getDeliveryMode());\n+        return producer;\n+    }\n+\n+    /**\n+     * Returns delivery mode.\n+     *\n+     * @return int - persistent delivery mode.\n+     */\n+    protected int getDeliveryMode() {\n+        return DeliveryMode.PERSISTENT;\n+    }\n+\n+    /**\n+     * Run the JmsRedeliverTest with the delivery mode set as persistent.\n+     */\n+    public static final class PersistentCase extends JmsRedeliveredTest {\n+\n+        /**\n+         * Returns delivery mode.\n+         *\n+         * @return int - persistent delivery mode.\n+         */\n+        protected int getDeliveryMode() {\n+            return DeliveryMode.PERSISTENT;\n+        }\n+    }\n+\n+    /**\n+     * Run the JmsRedeliverTest with the delivery mode set as non-persistent.\n+     */\n+    public static final class TransientCase extends JmsRedeliveredTest {\n+\n+        /**\n+         * Returns delivery mode.\n+         *\n+         * @return int - non-persistent delivery mode.\n+         */\n+        protected int getDeliveryMode() {\n+            return DeliveryMode.NON_PERSISTENT;\n+        }\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTestSuite(PersistentCase.class);\n+        suite.addTestSuite(TransientCase.class);\n+        return suite;\n+    }\n+}"},{"sha":"82572be43fb84719989042af5f1c975d059ffd47","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","status":"added","additions":339,"deletions":0,"changes":339,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsRollbackRedeliveryTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,339 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq;\n+\n+\n+import javax.jms.Topic;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsRollbackRedeliveryTest extends AutoFailTestSupport {\n+    protected static final Logger LOG = LoggerFactory.getLogger(JmsRollbackRedeliveryTest.class);\n+    final int nbMessages = 10;\n+    final String destinationName = \"Destination\";\n+    boolean consumerClose = true;\n+    boolean rollback = true;\n+\n+    public void setUp() throws Exception {\n+        setAutoFail(true);\n+        super.setUp();\n+    }\n+\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void testRedelivery() throws Exception {\n+        doTestRedelivery(false);\n+    }\n+\n+    public void testRedeliveryWithInterleavedProducer() throws Exception {\n+        doTestRedelivery(true);\n+    }\n+\n+    public void doTestRedelivery(boolean interleaveProducer) throws Exception {\n+\n+        ConnectionFactory connectionFactory = new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination = session.createTopic(destinationName);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        connection.start();\n+\n+        if (interleaveProducer) {\n+            populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);\n+        } else {\n+            populateDestination(nbMessages, destinationName, connection);\n+        }\n+        // Consume messages and rollback transactions\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n+            while (received.get() < nbMessages) {\n+                TextMessage msg = (TextMessage) consumer.receive(6000000);\n+                if (msg != null) {\n+                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n+                        LOG.info(\"Received message \" + msg.getText()\n+                                 + \" (\" + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                        assertTrue(msg.getJMSRedelivered());\n+                        // assertEquals(2, msg.getLongProperty(\"JMSXDeliveryCount\"));\n+                        session.commit();\n+                    } else {\n+                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n+                        assertFalse(\"should not have redelivery flag set, id: \"\n+                                    + msg.getJMSMessageID(), msg.getJMSRedelivered());\n+                        session.rollback();\n+                    }\n+                }\n+            }\n+            consumer.close();\n+            session.close();\n+        }\n+    }\n+\n+    public void testRedeliveryOnSingleConsumer() throws Exception {\n+\n+        ConnectionFactory connectionFactory =\n+            new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        connection.start();\n+        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination = session.createTopic(destinationName);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+\n+        populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);\n+\n+        // Consume messages and rollback transactions\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n+            while (received.get() < nbMessages) {\n+                TextMessage msg = (TextMessage) consumer.receive(6000000);\n+                if (msg != null) {\n+                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n+                        LOG.info(\"Received message \" + msg.getText() + \" (\"\n+                                 + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                        assertTrue(msg.getJMSRedelivered());\n+                        session.commit();\n+                    } else {\n+                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n+                        session.rollback();\n+                    }\n+                }\n+            }\n+            consumer.close();\n+            session.close();\n+        }\n+    }\n+\n+    public void testRedeliveryOnSingleSession() throws Exception {\n+\n+        ConnectionFactory connectionFactory =\n+            new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination = session.createTopic(destinationName);\n+        MessageConsumer consumer = session.createConsumer(destination);\n+        connection.start();\n+\n+        populateDestination(nbMessages, destinationName, connection);\n+\n+        // Consume messages and rollback transactions\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();\n+            while (received.get() < nbMessages) {\n+                TextMessage msg = (TextMessage) consumer.receive(6000000);\n+                if (msg != null) {\n+                    if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {\n+                        LOG.info(\"Received message \" + msg.getText() + \" (\"\n+                                 + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                        assertTrue(msg.getJMSRedelivered());\n+                        session.commit();\n+                    } else {\n+                        LOG.info(\"Rollback message \" + msg.getText() + \" id: \" +  msg.getJMSMessageID());\n+                        session.rollback();\n+                    }\n+                }\n+            }\n+            consumer.close();\n+            session.close();\n+        }\n+    }\n+\n+    // AMQ-1593\n+    public void testValidateRedeliveryCountOnRollback() throws Exception {\n+\n+        final int numMessages = 1;\n+        ConnectionFactory connectionFactory =\n+            new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        Destination destination = session.createTopic(destinationName);\n+\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-1\");\n+        connection.start();\n+\n+        populateDestination(numMessages, destinationName, connection);\n+\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            // hardcoded, we actually allow for infinite rollback/redelivery ...\n+            final int maxRetries = 5;\n+            while (received.get() < maxRetries) {\n+                TextMessage msg = (TextMessage) consumer.receive(1000);\n+                assert msg != null;\n+                if (msg != null) {\n+                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n+                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                    session.rollback();\n+                }\n+            }\n+            session.close();\n+            consumeMessage(connection, \"subscriber-id-1\");\n+        }\n+    }\n+\n+    // AMQ-1593\n+    public void testValidateRedeliveryCountOnRollbackWithPrefetch0() throws Exception {\n+\n+       final int numMessages = 1;\n+       ConnectionFactory connectionFactory =\n+            new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        Destination destination = session.createTopic(destinationName);\n+\n+        MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-2\");\n+        connection.start();\n+\n+        populateDestination(numMessages, destinationName, connection);\n+\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            // hardcoded, we actually allow for infinite rollback/redelivery ...\n+            final int maxRetries = 5;\n+            while (received.get() < maxRetries) {\n+                TextMessage msg = (TextMessage) consumer.receive(1000);\n+                assert msg != null;\n+                if (msg != null) {\n+                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n+                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                    session.rollback();\n+                }\n+            }\n+\n+            session.close();\n+            consumeMessage(connection, \"subscriber-id-2\");\n+        }\n+    }\n+\n+\n+    private void consumeMessage(Connection connection, String subscriberId)\n+            throws JMSException {\n+        Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+        Destination destination = session.createTopic(destinationName);\n+        MessageConsumer consumer;\n+        if (null == subscriberId) consumer = session.createConsumer(destination);\n+        else consumer = session.createDurableSubscriber((Topic) destination, subscriberId);\n+\n+        TextMessage msg = (TextMessage) consumer.receive(1000);\n+        assertNotNull(msg);\n+        session.commit();\n+        session.close();\n+    }\n+\n+    public void testRedeliveryPropertyWithNoRollback() throws Exception {\n+        final int numMessages = 1;\n+        ConnectionFactory connectionFactory =\n+            new HedwigConnectionFactoryImpl();\n+        Connection connection = connectionFactory.createConnection();\n+        // ensure registration of durable subscription\n+        {\n+            connection.setClientID(getName() + \"-client-id-1\");\n+            Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+            Destination destination = session.createTopic(destinationName);\n+\n+            MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-3\");\n+        }\n+        connection.start();\n+\n+        populateDestination(numMessages, destinationName, connection);\n+        connection.close();\n+        {\n+            AtomicInteger received = new AtomicInteger();\n+            // hardcoded, we actually allow for infinite rollback/redelivery ...\n+            final int maxRetries = 5;\n+            while (received.get() < maxRetries) {\n+                connection = connectionFactory.createConnection();\n+                connection.setClientID(getName() + \"-client-id-1\");\n+                connection.start();\n+                Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n+                Destination destination = session.createTopic(destinationName);\n+\n+                MessageConsumer consumer = session.createDurableSubscriber((Topic) destination, \"subscriber-id-3\");\n+                TextMessage msg = (TextMessage) consumer.receive(2000);\n+                assert msg != null;\n+                if (msg != null) {\n+                    LOG.info(\"Received message \" + msg.getText() + \" (\"\n+                             + received.getAndIncrement() + \")\" + msg.getJMSMessageID());\n+                }\n+                session.close();\n+                connection.close();\n+            }\n+            connection = connectionFactory.createConnection();\n+            connection.setClientID(getName() + \"-client-id-1\");\n+            connection.start();\n+            consumeMessage(connection, \"subscriber-id-3\");\n+        }\n+    }\n+\n+    private void populateDestination(final int nbMessages,\n+            final String destinationName, Connection connection)\n+            throws JMSException {\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination = session.createTopic(destinationName);\n+        MessageProducer producer = session.createProducer(destination);\n+        for (int i = 1; i <= nbMessages; i++) {\n+            producer.send(session.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n+        }\n+        producer.close();\n+        session.close();\n+    }\n+\n+\n+    private void populateDestinationWithInterleavedProducer(final int nbMessages,\n+            final String destinationName, Connection connection)\n+            throws JMSException {\n+        Session session1 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination1 = session1.createTopic(destinationName);\n+        MessageProducer producer1 = session1.createProducer(destination1);\n+        Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Destination destination2 = session2.createTopic(destinationName);\n+        MessageProducer producer2 = session2.createProducer(destination2);\n+\n+        for (int i = 1; i <= nbMessages; i++) {\n+            if (i%2 == 0) {\n+                producer1.send(session1.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n+            } else {\n+                producer2.send(session2.createTextMessage(\"<hello id='\" + i + \"'/>\"));\n+            }\n+        }\n+        producer1.close();\n+        session1.close();\n+        producer2.close();\n+        session2.close();\n+    }\n+\n+}"},{"sha":"62a17150c8d9ffce52e1c493bb68d12fccce4bb9","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","status":"added","additions":234,"deletions":0,"changes":234,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsSendReceiveTestSupport extends TestSupport implements MessageListener {\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveTestSupport.class);\n+\n+    protected int messageCount = 100;\n+    protected String[] data;\n+    protected Session session;\n+    protected MessageConsumer consumer;\n+    protected MessageProducer producer;\n+    protected Destination consumerDestination;\n+    protected Destination producerDestination;\n+    protected List<Message> messages = createConcurrentList();\n+    protected boolean topic = true;\n+    protected boolean durable;\n+    protected int deliveryMode = DeliveryMode.PERSISTENT;\n+    protected final Object lock = new Object();\n+    protected boolean verbose;\n+\n+    /*\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        String temp = System.getProperty(\"messageCount\");\n+\n+        if (temp != null) {\n+            int i = Integer.parseInt(temp);\n+            if (i > 0) {\n+                messageCount = i;\n+            }\n+        }\n+\n+        LOG.info(\"Message count for test case is: \" + messageCount);\n+        data = new String[messageCount];\n+\n+        for (int i = 0; i < messageCount; i++) {\n+            data[i] = \"Text for message: \" + i + \" at \" + new Date();\n+        }\n+    }\n+\n+    /**\n+     * Sends and consumes the messages.\n+     *\n+     * @throws Exception\n+     */\n+    public void testSendReceive() throws Exception {\n+        messages.clear();\n+        for (int i = 0; i < data.length; i++) {\n+            Message message = session.createTextMessage(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"About to send a message: \" + message + \" with text: \" + data[i]);\n+                }\n+            }\n+\n+            sendToProducer(producer, producerDestination, message);\n+            messageSent();\n+        }\n+\n+        assertMessagesAreReceived();\n+        LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n+    }\n+\n+    /**\n+     * Sends a message to a destination using the supplied producer\n+     * @param producer\n+     * @param producerDestination\n+     * @param message\n+     * @throws JMSException\n+     */\n+    protected void sendToProducer(MessageProducer producer,\n+            Destination producerDestination, Message message) throws JMSException {\n+        producer.send(producerDestination, message);\n+    }\n+\n+    /**\n+     * Asserts messages are received.\n+     *\n+     * @throws JMSException\n+     */\n+    protected void assertMessagesAreReceived() throws JMSException {\n+        waitForMessagesToBeDelivered();\n+        assertMessagesReceivedAreValid(messages);\n+    }\n+\n+    /**\n+     * Tests if the messages received are valid.\n+     *\n+     * @param receivedMessages - list of received messages.\n+     * @throws JMSException\n+     */\n+    protected void assertMessagesReceivedAreValid(List<Message> receivedMessages) throws JMSException {\n+        List<Object> copyOfMessages = Arrays.asList(receivedMessages.toArray());\n+        int counter = 0;\n+\n+        if (data.length != copyOfMessages.size()) {\n+            for (Iterator<Object> iter = copyOfMessages.iterator(); iter.hasNext();) {\n+                TextMessage message = (TextMessage)iter.next();\n+                if (LOG.isInfoEnabled()) {\n+                    LOG.info(\"<== \" + counter++ + \" = \" + message.getText());\n+                }\n+            }\n+        }\n+\n+        assertEquals(\"Not enough messages received\", data.length, receivedMessages.size());\n+\n+        for (int i = 0; i < data.length; i++) {\n+            TextMessage received = (TextMessage)receivedMessages.get(i);\n+            String text = received.getText();\n+            String stringProperty = received.getStringProperty(\"stringProperty\");\n+            int intProperty = received.getIntProperty(\"intProperty\");\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.info(\"Received Text: \" + text);\n+                }\n+            }\n+\n+            assertEquals(\"Message: \" + i, data[i], text);\n+            assertEquals(data[i], stringProperty);\n+            assertEquals(i, intProperty);\n+        }\n+    }\n+\n+    /**\n+     * Waits for messages to be delivered.\n+     */\n+    protected void waitForMessagesToBeDelivered() {\n+        long maxWaitTime = 30000;\n+        long waitTime = maxWaitTime;\n+        long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();\n+\n+        synchronized (lock) {\n+            while (messages.size() < data.length && waitTime >= 0) {\n+                try {\n+                    lock.wait(200);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+\n+                waitTime = maxWaitTime - (System.currentTimeMillis() - start);\n+            }\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see javax.jms.MessageListener#onMessage(javax.jms.Message)\n+     */\n+    public synchronized void onMessage(Message message) {\n+        consumeMessage(message, messages);\n+    }\n+\n+    /**\n+     * Consumes messages.\n+     *\n+     * @param message - message to be consumed.\n+     * @param messageList -list of consumed messages.\n+     */\n+    protected void consumeMessage(Message message, List<Message> messageList) {\n+        if (verbose) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.info(\"Received message: \" + message);\n+            }\n+        }\n+\n+        messageList.add(message);\n+\n+        if (messageList.size() >= data.length) {\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the ArrayList as a synchronized list.\n+     *\n+     * @return List\n+     */\n+    protected List<Message> createConcurrentList() {\n+        return Collections.synchronizedList(new ArrayList<Message>());\n+    }\n+\n+    /**\n+     * Just a hook so can insert failure tests\n+     *\n+     * @throws Exception\n+     */\n+    protected void messageSent() throws Exception {\n+\n+    }\n+}"},{"sha":"82d2108baf6b8a132f7066005260a9c479007841","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","status":"added","additions":239,"deletions":0,"changes":239,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendReceiveWithMessageExpirationTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,239 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import java.util.Date;\n+import java.util.Vector;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.jms.Connection;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.Topic;\n+\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsSendReceiveWithMessageExpirationTest extends TestSupport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveWithMessageExpirationTest.class);\n+\n+    protected int messageCount = 100;\n+    protected String[] data;\n+    protected Session session;\n+    protected Destination consumerDestination;\n+    protected Destination producerDestination;\n+    protected boolean durable;\n+    protected int deliveryMode = DeliveryMode.PERSISTENT;\n+    protected long timeToLive = 5000;\n+    protected boolean verbose;\n+\n+    protected Connection connection;\n+\n+    protected void setUp() throws Exception {\n+\n+        super.setUp();\n+\n+        data = new String[messageCount];\n+\n+        for (int i = 0; i < messageCount; i++) {\n+            data[i] = \"Text for message: \" + i + \" at \" + new Date();\n+        }\n+\n+        connectionFactory = createConnectionFactory();\n+        connection = createConnection(!durable);\n+\n+        if (durable) {\n+            connection.setClientID(getClass().getName());\n+        }\n+\n+        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+    }\n+\n+    /**\n+     * Test consuming an expired queue.\n+     *\n+     * @throws Exception\n+     */\n+    public void testConsumeExpiredQueue() throws Exception {\n+\n+        MessageProducer producer = createProducer(timeToLive);\n+\n+        consumerDestination = session.createTopic(getConsumerSubject());\n+        producerDestination = session.createTopic(getProducerSubject());\n+\n+        MessageConsumer consumer = createConsumer();\n+        connection.start();\n+\n+        for (int i = 0; i < data.length; i++) {\n+            Message message = session.createTextMessage(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"About to send a queue message: \" + message + \" with text: \" + data[i]);\n+                }\n+            }\n+\n+            producer.send(producerDestination, message, producer.getDeliveryMode(),\n+                          producer.getPriority(), timeToLive);\n+        }\n+\n+        // sleeps a second longer than the expiration time.\n+        // Basically waits till queue expires.\n+        Thread.sleep(timeToLive + 1000);\n+\n+        // message should have expired.\n+        assertNull(consumer.receive(1000));\n+    }\n+\n+    /**\n+     * Sends and consumes the messages to a queue destination.\n+     *\n+     * @throws Exception\n+     */\n+    public void testConsumeQueue() throws Exception {\n+\n+        MessageProducer producer = createProducer(0);\n+\n+        consumerDestination = session.createTopic(getConsumerSubject());\n+        producerDestination = session.createTopic(getProducerSubject());\n+\n+        MessageConsumer consumer = createConsumer();\n+        connection.start();\n+\n+        for (int i = 0; i < data.length; i++) {\n+            Message message = session.createTextMessage(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"About to send a queue message: \" + message + \" with text: \" + data[i]);\n+                }\n+            }\n+\n+            producer.send(producerDestination, message);\n+        }\n+\n+        // should receive a queue since there is no expiration.\n+        assertNotNull(consumer.receive(1000));\n+    }\n+\n+    /**\n+     * Test consuming an expired topic.\n+     *\n+     * @throws Exception\n+     */\n+    public void testConsumeExpiredTopic() throws Exception {\n+\n+        MessageProducer producer = createProducer(timeToLive);\n+\n+        consumerDestination = session.createTopic(getConsumerSubject());\n+        producerDestination = session.createTopic(getProducerSubject());\n+\n+        MessageConsumer consumer = createConsumer();\n+        connection.start();\n+\n+        for (int i = 0; i < data.length; i++) {\n+            Message message = session.createTextMessage(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"About to send a topic message: \" + message + \" with text: \" + data[i]);\n+                }\n+            }\n+\n+            producer.send(producerDestination, message);\n+        }\n+\n+        // sleeps a second longer than the expiration time.\n+        // Basically waits till topic expires.\n+        Thread.sleep(timeToLive + 1000);\n+\n+        // message should have expired.\n+        assertNull(consumer.receive(1000));\n+    }\n+\n+    /**\n+     * Sends and consumes the messages to a topic destination.\n+     *\n+     * @throws Exception\n+     */\n+    public void testConsumeTopic() throws Exception {\n+\n+        MessageProducer producer = createProducer(0);\n+\n+        consumerDestination = session.createTopic(getConsumerSubject());\n+        producerDestination = session.createTopic(getProducerSubject());\n+\n+        MessageConsumer consumer = createConsumer();\n+        connection.start();\n+\n+        for (int i = 0; i < data.length; i++) {\n+            Message message = session.createTextMessage(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"About to send a topic message: \" + message + \" with text: \" + data[i]);\n+                }\n+            }\n+\n+            producer.send(producerDestination, message);\n+        }\n+\n+        // should receive a topic since there is no expiration.\n+        assertNotNull(consumer.receive(1000));\n+    }\n+\n+    protected MessageProducer createProducer(long timeToLive) throws JMSException {\n+        MessageProducer producer = session.createProducer(null);\n+        producer.setDeliveryMode(deliveryMode);\n+        producer.setTimeToLive(timeToLive);\n+\n+        return producer;\n+    }\n+\n+    protected MessageConsumer createConsumer() throws JMSException {\n+        if (durable) {\n+            LOG.info(\"Creating durable consumer\");\n+            return session.createDurableSubscriber((Topic)consumerDestination, getName());\n+        }\n+        return session.createConsumer(consumerDestination);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        LOG.info(\"Dumping stats...\");\n+        LOG.info(\"Closing down connection\");\n+\n+        session.close();\n+        connection.close();\n+        super.tearDown();\n+    }\n+\n+}"},{"sha":"7b60106ec70858e54dfccb6241ecaac575f5338c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsSendWithAsyncCallbackTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+\n+import javax.jms.Connection;\n+import javax.jms.DeliveryMode;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageListener;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.Topic;\n+import javax.jms.Message;\n+\n+public class JmsSendWithAsyncCallbackTest extends TestSupport {\n+\n+    private Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        connection = createConnection();\n+    }\n+\n+    /**\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+            connection = null;\n+        }\n+        super.tearDown();\n+    }\n+\n+    public void testAsyncCallbackIsFaster() throws JMSException, InterruptedException {\n+        connection.start();\n+\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getName());\n+\n+        // setup a consumer to drain messages..\n+        MessageConsumer consumer = session.createConsumer(queue);\n+        consumer.setMessageListener(new MessageListener() {\n+            @Override\n+            public void onMessage(Message message) {\n+            }\n+        });\n+\n+        // warmup...\n+        for(int i=0; i < 10; i++) {\n+            benchmarkNonCallbackRate();\n+            benchmarkCallbackRate();\n+        }\n+\n+        double callbackRate = benchmarkCallbackRate();\n+        double nonCallbackRate = benchmarkNonCallbackRate();\n+\n+        System.out.println(String.format(\"AsyncCallback Send rate: %,.2f m/s\", callbackRate));\n+        System.out.println(String.format(\"NonAsyncCallback Send rate: %,.2f m/s\", nonCallbackRate));\n+\n+        // there is no such requirement in hedwig case :-)\n+        // The async style HAS to be faster than the non-async style..\n+        // assertTrue( callbackRate/nonCallbackRate > 1.5 );\n+    }\n+\n+    private double benchmarkNonCallbackRate() throws JMSException {\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getName());\n+        int count = 1000;\n+        MessageProducer producer = session.createProducer(queue);\n+        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < count; i++) {\n+            producer.send(session.createTextMessage(\"Hello\"));\n+        }\n+        return 1000.0 * count / (System.currentTimeMillis() - start);\n+    }\n+\n+    private double benchmarkCallbackRate() throws JMSException, InterruptedException {\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        Topic queue = session.createTopic(getName());\n+        int count = 1000;\n+        MessageProducer producer = session.createProducer(queue);\n+        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < count; i++) {\n+            producer.send(session.createTextMessage(\"Hello\"));\n+        }\n+        return 1000.0 * count / (System.currentTimeMillis() - start);\n+    }\n+\n+}"},{"sha":"82ec6aefa3cedf5c078dc571dcbaeb60bd4517e6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","status":"added","additions":174,"deletions":0,"changes":174,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import org.apache.hedwig.jms.MessagingSessionFacade;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+\n+\n+\n+import javax.jms.Destination;\n+\n+/**\n+ * Test cases used to test the JMS message consumer.\n+ */\n+public class JmsTestSupport extends CombinationTestSupport {\n+\n+    static final private AtomicLong TEST_COUNTER = new AtomicLong();\n+    public String userName;\n+    public String password;\n+    public String messageTextPrefix = \"\";\n+\n+    protected ConnectionFactory factory;\n+    protected HedwigConnectionImpl connection;\n+\n+    protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());\n+\n+    // /////////////////////////////////////////////////////////////////\n+    //\n+    // Test support methods.\n+    //\n+    // /////////////////////////////////////////////////////////////////\n+    protected Destination createDestination(Session session,\n+            MessagingSessionFacade.DestinationType type) throws JMSException {\n+        String testMethod = getName();\n+        if( testMethod.indexOf(\" \")>0 ) {\n+            testMethod = testMethod.substring(0, testMethod.indexOf(\" \"));\n+        }\n+        String name = \"TEST.\" + getClass().getName() + \".\" +testMethod+\".\"+TEST_COUNTER.getAndIncrement();\n+        switch (type) {\n+        case QUEUE:\n+            return (Destination)session.createTopic(name);\n+        case TOPIC:\n+            return (Destination)session.createTopic(name);\n+        default:\n+            throw new IllegalArgumentException(\"type: \" + type);\n+        }\n+    }\n+\n+    protected void sendMessages(Destination destination, int count) throws Exception {\n+        ConnectionFactory factory = createConnectionFactory();\n+        Connection connection = factory.createConnection();\n+        connection.start();\n+        sendMessages(connection, destination, count);\n+        connection.close();\n+    }\n+\n+    protected void sendMessages(Connection connection, Destination destination, int count) throws JMSException {\n+        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+        sendMessages(session, destination, count);\n+        session.close();\n+    }\n+\n+    protected void sendMessages(Session session, Destination destination, int count) throws JMSException {\n+        MessageProducer producer = session.createProducer(destination);\n+        for (int i = 0; i < count; i++) {\n+            producer.send(session.createTextMessage(messageTextPrefix  + i));\n+        }\n+        producer.close();\n+    }\n+\n+    protected ConnectionFactory createConnectionFactory() throws Exception {\n+        return new HedwigConnectionFactoryImpl();\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        if (System.getProperty(\"basedir\") == null) {\n+            File file = new File(\".\");\n+            System.setProperty(\"basedir\", file.getAbsolutePath());\n+        }\n+\n+        factory = createConnectionFactory();\n+        connection = (HedwigConnectionImpl)factory.createConnection(userName, password);\n+        connections.add(connection);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        for (Iterator iter = connections.iterator(); iter.hasNext();) {\n+            Connection conn = (Connection)iter.next();\n+            try {\n+                conn.close();\n+            } catch (Throwable e) {\n+            }\n+            iter.remove();\n+        }\n+        super.tearDown();\n+    }\n+\n+    protected void safeClose(Connection c) {\n+        try {\n+            c.close();\n+        } catch (Throwable e) {\n+        }\n+    }\n+\n+    protected void safeClose(Session s) {\n+        try {\n+            s.close();\n+        } catch (Throwable e) {\n+        }\n+    }\n+\n+    protected void safeClose(MessageConsumer c) {\n+        try {\n+            c.close();\n+        } catch (Throwable e) {\n+        }\n+    }\n+\n+    protected void safeClose(MessageProducer p) {\n+        try {\n+            p.close();\n+        } catch (Throwable e) {\n+        }\n+    }\n+\n+    protected void profilerPause(String prompt) throws IOException {\n+        if (System.getProperty(\"profiler\") != null) {\n+            pause(prompt);\n+        }\n+    }\n+\n+    protected void pause(String prompt) throws IOException {\n+        System.out.println();\n+        System.out.println(prompt + \"> Press enter to continue: \");\n+        while (System.in.read() != '\\n') {\n+        }\n+    }\n+\n+}"},{"sha":"78afcdde52fe48a38f0e49078714d95386ce0981","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicCompositeSendReceiveTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,101 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Topic;\n+\n+import org.apache.activemq.test.JmsTopicSendReceiveTest;\n+import org.apache.hedwig.jms.SessionImpl;\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+\n+public class JmsTopicCompositeSendReceiveTest extends JmsTopicSendReceiveTest {\n+    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory\n+            .getLog(JmsTopicCompositeSendReceiveTest.class);\n+\n+    Destination consumerDestination2;\n+    MessageConsumer consumer2;\n+\n+    /**\n+     * Sets a test to have a queue destination and non-persistent delivery mode.\n+     *\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        deliveryMode = DeliveryMode.NON_PERSISTENT;\n+        super.setUp();\n+        consumerDestination2 = consumeSession.createTopic(\"FOO.BAR.HUMBUG2\");\n+        LOG.info(\"Created  consumer destination: \" + consumerDestination2\n+                 + \" of type: \" + consumerDestination2.getClass());\n+\n+        /*\n+        JMS spec 6.11.1\n+\"Sessions with durable subscribers must always provide the same client\n+identifier. In addition, each client must specify a name that uniquely identifies\n+(within client identifier) each durable subscription it creates. Only one session\n+at a time can have a TopicSubscriber for a particular durable subscription. See\n+Section 4.3.2, Client Identifier, for more information.\n+A client can change an existing durable subscription by creating a durable\n+TopicSubscriber with the same name and a new topic and/or message selector,\n+or NoLocal attribute. Changing a durable subscription is equivalent to deleting\n+and recreating it.\"\n+\n+        So, we CANNOT reuse the subscriber id !\n+         */\n+        if (durable) {\n+            LOG.info(\"Creating durable consumer\");\n+            consumer2 = consumeSession.createDurableSubscriber((Topic) consumerDestination2, getName() + \"_2\");\n+        } else {\n+            consumer2 = consumeSession.createConsumer(consumerDestination2);\n+        }\n+        consumer2.setMessageListener(this);\n+    }\n+\n+    /**\n+     * Returns the consumer subject.\n+     *\n+     * @return String - consumer subject\n+     * @see org.apache.activemq.test.TestSupport#getConsumerSubject()\n+     */\n+    protected String getConsumerSubject() {\n+        return \"FOO.BAR.HUMBUG\";\n+    }\n+\n+    /**\n+     * Returns the producer subject.\n+     *\n+     * @return String - producer subject\n+     * @see org.apache.activemq.test.TestSupport#getProducerSubject()\n+     */\n+    protected String getProducerSubject() {\n+        return \"FOO.BAR.HUMBUG\";\n+    }\n+\n+    /**\n+     * Test if all the messages sent are being received.\n+     *\n+     * @throws Exception\n+     */\n+    public void testSendReceive() throws Exception {\n+        super.testSendReceive();\n+        // messages.clear();\n+        assertMessagesAreReceived();\n+        LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n+    }\n+}"},{"sha":"ac25e58e066bd54e8f2b6b32db71fbf8b0757886","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","status":"added","additions":176,"deletions":0,"changes":176,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicRedeliverTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,176 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+import org.apache.hedwig.jms.spi.HedwigConnectionImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsTopicRedeliverTest extends TestSupport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsTopicRedeliverTest.class);\n+\n+    protected Connection connection;\n+    protected Session session;\n+    protected Session consumeSession;\n+    protected MessageConsumer consumer;\n+    protected MessageProducer producer;\n+    protected Destination consumerDestination;\n+    protected Destination producerDestination;\n+    protected boolean topic = true;\n+    protected boolean durable = true;\n+    protected boolean verbose;\n+    // hardcoded to some random default.\n+    protected long initRedeliveryDelay = 1000L;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        connectionFactory = createConnectionFactory();\n+        connection = createConnection();\n+\n+        if (durable && null == connection.getClientID()) {\n+            connection.setClientID(getClass().getName());\n+        }\n+\n+        LOG.info(\"Created connection: \" + connection);\n+\n+        session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+\n+        LOG.info(\"Created session: \" + session);\n+        LOG.info(\"Created consumeSession: \" + consumeSession);\n+        producer = session.createProducer(null);\n+        // producer.setDeliveryMode(deliveryMode);\n+\n+        LOG.info(\"Created producer: \" + producer);\n+\n+        if (topic) {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        } else {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        }\n+\n+        LOG.info(\"Created  consumer destination: \"\n+                 + consumerDestination + \" of type: \" + consumerDestination.getClass());\n+        LOG.info(\"Created  producer destination: \"\n+                 + producerDestination + \" of type: \" + producerDestination.getClass());\n+        consumer = createConsumer();\n+        connection.start();\n+\n+        LOG.info(\"Created connection: \" + connection);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        if (connection != null) {\n+            connection.close();\n+        }\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Returns the consumer subject.\n+     *\n+     * @return String - consumer subject\n+     * @see org.apache.activemq.test.TestSupport#getConsumerSubject()\n+     */\n+    protected String getConsumerSubject() {\n+        return \"TEST\";\n+    }\n+\n+    /**\n+     * Returns the producer subject.\n+     *\n+     * @return String - producer subject\n+     * @see org.apache.activemq.test.TestSupport#getProducerSubject()\n+     */\n+    protected String getProducerSubject() {\n+        return \"TEST\";\n+    }\n+\n+    /**\n+     * Sends and consumes the messages.\n+     *\n+     * @throws Exception\n+     */\n+    public void testRecover() throws Exception {\n+        String text = \"TEST\";\n+        Message sendMessage = session.createTextMessage(text);\n+\n+        if (verbose) {\n+            LOG.info(\"About to send a message: \" + sendMessage + \" with text: \" + text);\n+        }\n+        producer.send(producerDestination, sendMessage);\n+\n+        // receive but don't acknowledge\n+        Message unackMessage = consumer.receive(initRedeliveryDelay + 1000);\n+        assertNotNull(unackMessage);\n+        String unackId = unackMessage.getJMSMessageID();\n+        assertEquals(((TextMessage)unackMessage).getText(), text);\n+        assertFalse(unackMessage.getJMSRedelivered());\n+\n+        // We DO NOT support session recovery\n+        // - to unblock this test, I am stopp'ing and start'ing connection : not the same, but ...\n+        // receive then acknowledge\n+        // consumeSession.recover();\n+        connection.close();\n+        connection = createConnection();\n+        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumer = createConsumer();\n+        connection.start();\n+\n+        Message ackMessage = consumer.receive(initRedeliveryDelay + 1000);\n+        assertNotNull(ackMessage);\n+        ackMessage.acknowledge();\n+        String ackId = ackMessage.getJMSMessageID();\n+        assertEquals(((TextMessage)ackMessage).getText(), text);\n+        // assertTrue(ackMessage.getJMSRedelivered());\n+        assertEquals(unackId, ackId);\n+\n+        // We DO NOT support session recovery\n+        // - to unblock this test, I am stopp'ing and start'ing connection : not the same, but ...\n+        // consumeSession.recover();\n+        connection.close();\n+        connection = createConnection();\n+        consumeSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);\n+        consumer = createConsumer();\n+        connection.start();\n+\n+        assertNull(consumer.receiveNoWait());\n+    }\n+\n+    protected MessageConsumer createConsumer() throws JMSException {\n+        if (durable) {\n+            LOG.info(\"Creating durable consumer\");\n+            return consumeSession.createDurableSubscriber((Topic)consumerDestination, getName());\n+        }\n+        return consumeSession.createConsumer(consumerDestination);\n+    }\n+\n+}"},{"sha":"73dd2edb5d15cfb76e37968fc3a5873bd204132e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","status":"added","additions":212,"deletions":0,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSelectorTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,212 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.Message;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import javax.jms.Topic;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ */\n+public class JmsTopicSelectorTest extends TestSupport {\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsTopicSelectorTest.class);\n+\n+    protected Connection connection;\n+    protected Session session;\n+    protected MessageConsumer consumer;\n+    protected MessageProducer producer;\n+    protected Destination consumerDestination;\n+    protected Destination producerDestination;\n+    protected boolean topic = true;\n+    protected boolean durable;\n+    protected int deliveryMode = DeliveryMode.PERSISTENT;\n+\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        connectionFactory = createConnectionFactory();\n+        connection = createConnection(!durable);\n+        if (durable) {\n+            connection.setClientID(getClass().getName());\n+        }\n+\n+        LOG.info(\"Created connection: \" + connection);\n+\n+        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        LOG.info(\"Created session: \" + session);\n+\n+        if (topic) {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        } else {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        }\n+\n+        LOG.info(\"Created  consumer destination: \" + consumerDestination\n+                 + \" of type: \" + consumerDestination.getClass());\n+        LOG.info(\"Created  producer destination: \" + producerDestination\n+                 + \" of type: \" + producerDestination.getClass());\n+        producer = session.createProducer(producerDestination);\n+        producer.setDeliveryMode(deliveryMode);\n+\n+        LOG.info(\"Created producer: \" + producer + \" delivery mode = \"\n+                 + (deliveryMode == DeliveryMode.PERSISTENT ? \"PERSISTENT\" : \"NON_PERSISTENT\"));\n+        connection.start();\n+    }\n+\n+    public void tearDown() throws Exception {\n+        session.close();\n+        connection.close();\n+        super.tearDown();\n+    }\n+\n+    protected MessageConsumer createConsumer(String selector) throws JMSException {\n+        if (durable) {\n+            LOG.info(\"Creating durable consumer\");\n+            return session.createDurableSubscriber((Topic)consumerDestination, getName(), selector, false);\n+        }\n+        return session.createConsumer(consumerDestination, selector);\n+    }\n+\n+    public void sendMessages() throws Exception {\n+        TextMessage message = session.createTextMessage(\"1\");\n+        message.setIntProperty(\"id\", 1);\n+        message.setJMSType(\"a\");\n+        message.setStringProperty(\"stringProperty\", \"a\");\n+        message.setLongProperty(\"longProperty\", 1);\n+        message.setBooleanProperty(\"booleanProperty\", true);\n+        producer.send(message);\n+\n+        message = session.createTextMessage(\"2\");\n+        message.setIntProperty(\"id\", 2);\n+        message.setJMSType(\"a\");\n+        message.setStringProperty(\"stringProperty\", \"a\");\n+        message.setLongProperty(\"longProperty\", 1);\n+        message.setBooleanProperty(\"booleanProperty\", false);\n+        producer.send(message);\n+\n+        message = session.createTextMessage(\"3\");\n+        message.setIntProperty(\"id\", 3);\n+        message.setJMSType(\"a\");\n+        message.setStringProperty(\"stringProperty\", \"a\");\n+        message.setLongProperty(\"longProperty\", 1);\n+        message.setBooleanProperty(\"booleanProperty\", true);\n+        producer.send(message);\n+\n+        message = session.createTextMessage(\"4\");\n+        message.setIntProperty(\"id\", 4);\n+        message.setJMSType(\"b\");\n+        message.setStringProperty(\"stringProperty\", \"b\");\n+        message.setLongProperty(\"longProperty\", 2);\n+        message.setBooleanProperty(\"booleanProperty\", false);\n+        producer.send(message);\n+\n+        message = session.createTextMessage(\"5\");\n+        message.setIntProperty(\"id\", 5);\n+        message.setJMSType(\"c\");\n+        message.setStringProperty(\"stringProperty\", \"c\");\n+        message.setLongProperty(\"longProperty\", 3);\n+        message.setBooleanProperty(\"booleanProperty\", true);\n+        producer.send(message);\n+    }\n+\n+    public void consumeMessages(int remaining) throws Exception {\n+        consumer = createConsumer(null);\n+        for (int i = 0; i < remaining; i++) {\n+            consumer.receive(1000);\n+        }\n+        consumer.close();\n+\n+    }\n+\n+    public void testEmptyPropertySelector() throws Exception {\n+        int remaining = 5;\n+        Message message = null;\n+        consumer = createConsumer(\"\");\n+        sendMessages();\n+        while (true) {\n+            message = consumer.receive(1000);\n+            if (message == null) {\n+                break;\n+            }\n+\n+            remaining--;\n+        }\n+        assertEquals(remaining, 0);\n+        consumer.close();\n+        consumeMessages(remaining);\n+    }\n+\n+    public void testPropertySelector() throws Exception {\n+        int remaining = 5;\n+        Message message = null;\n+        consumer = createConsumer(\"stringProperty = 'a' and longProperty = 1 and booleanProperty = true\");\n+        sendMessages();\n+        while (true) {\n+            message = consumer.receive(1000);\n+            if (message == null) {\n+                break;\n+            }\n+            String text = ((TextMessage)message).getText();\n+            if (!text.equals(\"1\") && !text.equals(\"3\")) {\n+                fail(\"unexpected message: \" + text);\n+            }\n+            remaining--;\n+        }\n+        assertEquals(remaining, 3);\n+        consumer.close();\n+        consumeMessages(remaining);\n+\n+    }\n+\n+    public void testJMSPropertySelector() throws Exception {\n+        int remaining = 5;\n+        Message message = null;\n+        consumer = createConsumer(\"JMSType = 'a' and stringProperty = 'a'\");\n+        sendMessages();\n+        while (true) {\n+            message = consumer.receive(1000);\n+            if (message == null) {\n+                break;\n+            }\n+            String text = ((TextMessage)message).getText();\n+            if (!text.equals(\"1\") && !text.equals(\"2\") && !text.equals(\"3\")) {\n+                fail(\"unexpected message: \" + text);\n+            }\n+            remaining--;\n+        }\n+        assertEquals(remaining, 2);\n+        consumer.close();\n+        consumeMessages(remaining);\n+\n+    }\n+\n+}"},{"sha":"e75d6fe9b31466dd09382b60da5d146e5a63687c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveSubscriberTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,33 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Topic;\n+import javax.jms.TopicSession;\n+\n+public class JmsTopicSendReceiveSubscriberTest extends JmsTopicSendReceiveTest {\n+    protected MessageConsumer createConsumer() throws JMSException {\n+        if (durable) {\n+            return super.createConsumer();\n+        } else {\n+            TopicSession topicSession = (TopicSession)session;\n+            return topicSession.createSubscriber((Topic)consumerDestination, null, false);\n+        }\n+    }\n+}"},{"sha":"dc590d87b982b625e78ca028e3d55f39ec0c2124","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Connection;\n+import javax.jms.DeliveryMode;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Session;\n+import javax.jms.Topic;\n+import javax.jms.TopicConnection;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class JmsTopicSendReceiveTest extends JmsSendReceiveTestSupport {\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsTopicSendReceiveTest.class);\n+\n+    protected Connection connection;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        connectionFactory = createConnectionFactory();\n+        connection = createConnection(!durable);\n+        if (durable) {\n+            connection.setClientID(getClass().getName());\n+        }\n+\n+        LOG.info(\"Created connection: \" + connection);\n+\n+        session = ((TopicConnection) connection).createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n+\n+        LOG.info(\"Created session: \" + session);\n+        producer = session.createProducer(null);\n+        producer.setDeliveryMode(deliveryMode);\n+\n+        LOG.info(\"Created producer: \" + producer + \" delivery mode = \"\n+                 + (deliveryMode == DeliveryMode.PERSISTENT ? \"PERSISTENT\" : \"NON_PERSISTENT\"));\n+\n+        if (topic) {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        } else {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        }\n+\n+        LOG.info(\"Created  consumer destination: \" + consumerDestination\n+                 + \" of type: \" + consumerDestination.getClass());\n+        LOG.info(\"Created  producer destination: \" + producerDestination\n+                 + \" of type: \" + producerDestination.getClass());\n+        consumer = createConsumer();\n+        consumer.setMessageListener(this);\n+        connection.start();\n+\n+        // log.info(\"Created connection: \" + connection);\n+    }\n+\n+    protected MessageConsumer createConsumer() throws JMSException {\n+        if (durable) {\n+            LOG.info(\"Creating durable consumer\");\n+            return session.createDurableSubscriber((Topic)consumerDestination, getName());\n+        }\n+        return session.createConsumer(consumerDestination);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        LOG.info(\"Dumping stats...\");\n+        // connectionFactory.getStats().reset();\n+\n+        LOG.info(\"Closing down connection\");\n+\n+        /** TODO we should be able to shut down properly */\n+        session.close();\n+        connection.close();\n+\n+        super.tearDown();\n+    }\n+\n+}"},{"sha":"36f4bebede7af8afa02d6bd3b1cbaebfe5fd4f85","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.Connection;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+import javax.jms.DeliveryMode;\n+import javax.jms.Destination;\n+import javax.jms.JMSException;\n+import javax.jms.MessageConsumer;\n+import javax.jms.Session;\n+\n+/**\n+ * @version\n+ */\n+public class JmsTopicSendReceiveWithTwoConnectionsTest extends JmsSendReceiveTestSupport {\n+\n+    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory\n+        .getLog(JmsTopicSendReceiveWithTwoConnectionsTest.class);\n+\n+    protected Connection sendConnection;\n+    protected Connection receiveConnection;\n+    protected Session receiveSession;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        connectionFactory = createConnectionFactory();\n+\n+        sendConnection = createSendConnection();\n+        sendConnection.start();\n+\n+        receiveConnection = createReceiveConnection();\n+        receiveConnection.start();\n+\n+        LOG.info(\"Created sendConnection: \" + sendConnection);\n+        LOG.info(\"Created receiveConnection: \" + receiveConnection);\n+\n+        session = createSendSession(sendConnection);\n+        receiveSession = createReceiveSession(receiveConnection);\n+\n+        LOG.info(\"Created sendSession: \" + session);\n+        LOG.info(\"Created receiveSession: \" + receiveSession);\n+\n+        producer = session.createProducer(null);\n+        producer.setDeliveryMode(deliveryMode);\n+\n+        LOG.info(\"Created producer: \" + producer + \" delivery mode = \"\n+                 + (deliveryMode == DeliveryMode.PERSISTENT ? \"PERSISTENT\" : \"NON_PERSISTENT\"));\n+\n+        if (topic) {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        } else {\n+            consumerDestination = session.createTopic(getConsumerSubject());\n+            producerDestination = session.createTopic(getProducerSubject());\n+        }\n+\n+        LOG.info(\"Created  consumer destination: \" + consumerDestination + \" of type: \"\n+                 + consumerDestination.getClass());\n+        LOG.info(\"Created  producer destination: \" + producerDestination + \" of type: \"\n+                 + producerDestination.getClass());\n+\n+        consumer = createConsumer(receiveSession, consumerDestination);\n+        consumer.setMessageListener(this);\n+\n+        LOG.info(\"Started connections\");\n+    }\n+\n+    protected Session createReceiveSession(Connection receiveConnection) throws Exception {\n+        return receiveConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+    }\n+\n+    protected Session createSendSession(Connection sendConnection) throws Exception {\n+        return sendConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n+    }\n+\n+    protected Connection createReceiveConnection() throws Exception {\n+        return createConnection(false);\n+    }\n+\n+    protected Connection createSendConnection() throws Exception {\n+        return createConnection(false);\n+    }\n+\n+    protected MessageConsumer createConsumer(Session session, Destination dest) throws JMSException {\n+        return session.createConsumer(dest);\n+    }\n+\n+    protected HedwigConnectionFactoryImpl createConnectionFactory() throws Exception {\n+        return new HedwigConnectionFactoryImpl();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        session.close();\n+        receiveSession.close();\n+        sendConnection.close();\n+        receiveConnection.close();\n+        super.tearDown();\n+    }\n+}"},{"sha":"f122176289c951b754bacd7f3a0e540bd324da5c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendReceiveWithTwoConnectionsWithJMXTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,28 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import org.apache.hedwig.jms.spi.HedwigConnectionFactoryImpl;\n+\n+public class JmsTopicSendReceiveWithTwoConnectionsWithJMXTest extends\n+    JmsTopicSendReceiveWithTwoConnectionsTest {\n+\n+    protected HedwigConnectionFactoryImpl createConnectionFactory() throws Exception {\n+        return new HedwigConnectionFactoryImpl();\n+    }\n+}"},{"sha":"e7fd5bf03a1bd3fa911adf8617d1e47735288f4f","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicSendSameMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,46 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import javax.jms.TextMessage;\n+\n+public class JmsTopicSendSameMessageTest extends JmsTopicSendReceiveWithTwoConnectionsTest {\n+\n+    private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory\n+        .getLog(JmsTopicSendSameMessageTest.class);\n+\n+    public void testSendReceive() throws Exception {\n+        messages.clear();\n+\n+        TextMessage message = session.createTextMessage();\n+\n+        for (int i = 0; i < data.length; i++) {\n+            message.setText(data[i]);\n+            message.setStringProperty(\"stringProperty\", data[i]);\n+            message.setIntProperty(\"intProperty\", i);\n+\n+            if (verbose) {\n+                LOG.info(\"About to send a message: \" + message + \" with text: \" + data[i]);\n+            }\n+\n+            producer.send(producerDestination, message);\n+        }\n+\n+        assertMessagesAreReceived();\n+    }\n+}"},{"sha":"81060f6a270ac32201e4e12c4f22936f0ed59b20","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTopicTransactionTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b","patch":"@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq;\n+\n+import javax.jms.Topic;\n+import org.apache.activemq.test.JmsResourceProvider;\n+\n+\n+public class JmsTopicTransactionTest extends JmsTransactionTestSupport {\n+\n+    /**\n+     * @see org.apache.activemq.JmsTransactionTestSupport#getJmsResourceProvider()\n+     */\n+    protected JmsResourceProvider getJmsResourceProvider() {\n+        JmsResourceProvider p = new JmsResourceProvider();\n+        p.setTopic(true);\n+        p.setDurableName(\"testsub\");\n+        p.setClientID(\"testclient\");\n+        return p;\n+    }\n+\n+}"},{"sha":"23a9121a3223066fdf673c7eda74f52b4051d6df","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/JmsTransactionTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"5593dafc59d5e4ab78c40103ac48bc89e36281da","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/LoadTestBurnIn.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"735d701ebbbd39d3eebec7ab25188415a81f76b5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/MessageListenerRedeliveryTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"002fea04116088f13df2060b81bfbd63d83f7921","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/RedeliveryPolicyTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"fd838ab28f9011c6f5b84ce12c0655beba6bf2a6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/TestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"4b12ccca1f3252d60241601fe39c3946e23e2847","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/TimeStampTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"1d187240e4c77264422e3640fd14c34e2dbc184b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleConsumer.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"4facc3dc3a9baa5280d1f06d3c11864b6c02f380","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/demo/SimpleProducer.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c5d9b0c2fcf4a1408481b01968e758aaba370a96","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","status":"added","additions":222,"deletions":0,"changes":222,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadClient.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"814981415236fcb587bd5c33c0fed4d4f51706bf","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadController.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"66880af9c96463c11a338adba9aab34c2590f127","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/load/LoadTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a113f8c312b943a833f606ce7dfbaec3e187bf03","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/ConnectionChurnTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a03fab9671685b343070130722c5a1e96360af3a","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/InactiveDurableTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"8959de26fe156dff0e393a7405c37d608d9ab331","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","status":"added","additions":212,"deletions":0,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NetworkedSyncTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"f05e4820e15033e9f71b183396b2f8ecd1b0fe1b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/NumberOfDestinationsTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"9eefad588cdbd246b04b18c5a87bc4696b304ecc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfConsumer.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a65b2c0bb70c36a39b39b4c3fb589bd6fc90a452","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfProducer.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"7942667d2b7d284d6a9da8d775599dd9e407d277","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/PerfRate.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"e9092110d0ca8bd1dd611ea6b6f04e58b8d47169","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicNetworkTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c10d3bf2cfbf7dd5a3163b96fed853076c8a7f78","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleDurableTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"0d32d490e79bf5ee423b3729a3ab8b1d8d33eed8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNetworkTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a2e2b7d4adc8a9b187a1f07a0d0a9cc6324e256e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleNonPersistentTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"5df97e5a84237ac364dec016699f2a272ef75130","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","status":"added","additions":181,"deletions":0,"changes":181,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SimpleTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c670dbda47351b0daed033b4f2ccaecbdb46bcce","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumer.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"7b66d77ec37e5abef23febb7ecd097abae1a6c0d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowConsumerTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"45bfc2826bc8e6030636e615e167c2c6b4fdc671","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/perf/SlowDurableConsumerTopicTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"e05770edcadf814fb5937f9863b80b68ce9a1da2","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsResourceProvider.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"bc150df3461fffad145e0aba43c75f94c17a13a8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","status":"added","additions":273,"deletions":0,"changes":273,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsSendReceiveTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"0fcde3394ec03d8ddecf0f0b738d2b674ca76bde","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"6f55fcbf3763f80c7ada40cb320916f781115188","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsAndByteSelectorTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"2d4a633fa7fe7c79d1496d4ac1eb1785ff4c73a8","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/JmsTopicSendReceiveWithTwoConnectionsTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"6de9021bee196b87f7301ad9c5ed268463855453","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/TestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"0bc8a8e6b8d6deb0489d60bc9bdc35448cc27ab3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/test/rollback/DelegatingTransactionalMessageListener.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"5bc1a079794352110e84f9a4409554eb16fa341c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSentMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"b4da7a70e10fdad19d9b8d68ca93043caf49b4cc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ChangeSessionDeliveryModeTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"7ea8cc02573b948e423485472c33262a849d5c52","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositeConsumeTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"068881dc0f232cbf6a52033c99cc61b2bc775426","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/CompositePublishTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"087c5ef4ba9e928700c844dfcf53357248a767da","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","status":"added","additions":413,"deletions":0,"changes":413,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ConcurrentProducerDurableConsumerTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"b14ef718c50552a9ec9ccc5bbbaedd97547e17bb","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","status":"added","additions":322,"deletions":0,"changes":322,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DiscriminatingConsumerLoadTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"fa79d69ea1a85ad6ff7a2840847e267efad82f5e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DispatchMultipleConsumersTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c4fa74de491bf5d9b53c7d747c0212fa5abc7033","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","status":"added","additions":192,"deletions":0,"changes":192,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableConsumerCloseAndReconnectTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a9272793d7575be2bf73cd27c2c61e62fb8311b6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","status":"added","additions":628,"deletions":0,"changes":628,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubProcessTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"b8d12da0fa03c9f4ac7c37eaa16999171a4b242d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","status":"added","additions":256,"deletions":0,"changes":256,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubSelectorDelayTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"0a9968b50f8f50fadf378ea041ee37363ff2fc8b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/DurableSubscriptionHangTestCase.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"edf180b819b2f00ab3b59df71831e164a1fef31e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/MyObject.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"adfb47dc7c0df2a11613fd6caf83a89c71a3978d","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","status":"added","additions":340,"deletions":0,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/NonBlockingConsumerRedeliveryTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"fa7b0eae6534393d42aecbb1fa09322b966cbc2c","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","status":"added","additions":241,"deletions":0,"changes":241,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ObjectMessageNotSerializableTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"3f570df014ca89eccbb5fecd591a58e502dfd194","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/ProducerConsumerTestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"6fd3ef5e618c39df78278dd1ea8def0cd6af91a5","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnDurableTopicConsumedMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"31d021946de943231020b3c006c4bf29b7293f7b","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/PublishOnTopicConsumedMessageTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"0327f664bd02f11b14542e67ce56eb88e6e18d69","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/SubscribeClosePublishThenConsumeTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c2902cf85729ce2b6b8535b2ce0c9c7a1d26e129","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","status":"added","additions":157,"deletions":0,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TestSupport.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"2c1e24ce4287859f7e4c06615bbbc9169e5e3fb1","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","status":"added","additions":300,"deletions":0,"changes":300,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TopicRedeliverTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"375004be89d3a4c498246fe6250c8cf2b72a1517","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionRollbackOrderTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"6b9a2f9c865a0996080489823d0a307e7cc836f3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/usecases/TransactionTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"1f9ce8ef91393588580716bb8165eee77ece59f6","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/ConsumerThread.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"c4f55d4cfbb7ab363600cecd5456c090aaba3ebc","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/DefaultTestAppender.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"197e3fdb9be75118ff9a11b708052f5e9fae1847","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/IdGenerator.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"a9584a83ce3ab60c753156653be3c63af64dc85a","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","status":"added","additions":267,"deletions":0,"changes":267,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/MessageIdList.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"12dfe3af8a7081186408c9eced3fe503c3037b3e","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/ProducerThread.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"49537627247223c489f4085610f28be64f0d5867","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/SimplePojo.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"1a89fe5ea63cd4e8429aafb376e84da91dce98d3","filename":"hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/activemq/util/Wait.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"ecf8830ea8d0b10d33aef09323a8751a4e3da1fe","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/JmsTestBase.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"be64fc4ce6112546bb5e0332167c6017457e2ee0","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","status":"added","additions":337,"deletions":0,"changes":337,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/BasicJMSTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"918dbbf11b97e4a9b658461b3907e26771df9dc3","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","status":"added","additions":376,"deletions":0,"changes":376,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/BasicSelectorGrammarTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"7895b1d73d45caede79d77a8d430d286545cf653","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorParserTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"96e4a11649f279bf27e38c74a65338082d8dd155","filename":"hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","status":"added","additions":399,"deletions":0,"changes":399,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client-jms/src/test/java/org/apache/hedwig/jms/selector/activemq/SelectorTest.java?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"},{"sha":"7f99eff471a2771a90b7922d4b466aecf2fd74e7","filename":"pom.xml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/e95b9392d4ba38c68617dff16de53e523d8ea51b/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/e95b9392d4ba38c68617dff16de53e523d8ea51b/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/pom.xml?ref=e95b9392d4ba38c68617dff16de53e523d8ea51b"}]}

