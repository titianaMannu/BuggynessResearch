{"sha":"ea36e59a1c314bf698d572e5f714e0b68e554a6e","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYTM2ZTU5YTFjMzE0YmY2OThkNTcyZTVmNzE0ZTBiNjhlNTU0YTZl","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-12-28T11:32:15Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-12-28T11:32:15Z"},"message":"BOOKKEEPER-514: TestDeadLock hanging sometimes (ivank, sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1426461 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7837e9f85e7a67aec1c66bc681432d229b26b600","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7837e9f85e7a67aec1c66bc681432d229b26b600"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ea36e59a1c314bf698d572e5f714e0b68e554a6e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ea36e59a1c314bf698d572e5f714e0b68e554a6e","html_url":"https://github.com/apache/bookkeeper/commit/ea36e59a1c314bf698d572e5f714e0b68e554a6e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ea36e59a1c314bf698d572e5f714e0b68e554a6e/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","url":"https://api.github.com/repos/apache/bookkeeper/commits/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","html_url":"https://github.com/apache/bookkeeper/commit/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555"}],"stats":{"total":349,"additions":50,"deletions":299},"files":[{"sha":"53fe29c5abe7f2255efe9a6acc8bc128a1c6ca22","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -155,6 +155,8 @@ Trunk (unreleased changes)\n         BOOKKEEPER-447: Bookie can fail to recover if index pages flushed before ledger flush acknowledged (ivank via sijie)\n \tBOOKKEEPER-520: BookieFailureTest hangs on precommit build (sijie via fpj, jira reopened)\n \n+\tBOOKKEEPER-514: TestDeadLock hanging sometimes (ivank, sijie via fpj)\n+\n       hedwig-protocol:\n \n         BOOKKEEPER-394: CompositeException message is not useful (Stu Hood via sijie)"},{"sha":"051464d51f1ab10e4d6deb7437ea3abd8602657d","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":21,"deletions":23,"changes":44,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-benchmark/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-benchmark/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/pom.xml?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -67,27 +67,6 @@\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-log4j12</artifactId>\n       <version>1.6.4</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-       <groupId>org.apache.hadoop</groupId>\n-       <artifactId>hadoop-common</artifactId>\n-       <version>0.23.1</version>\n-       <scope>compile</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.hadoop</groupId>\n-      <artifactId>hadoop-hdfs</artifactId>\n-      <version>0.23.1</version>\n-      <scope>compile</scope>\n-      <!-- commons-daemon has a malformed pom, which can cause the build to fail in an\n-           environment which uses an artifactory cache. -->\n-      <exclusions>\n-        <exclusion>\n-          <groupId>commons-daemon</groupId>\n-          <artifactId>commons-daemon</artifactId>\n-        </exclusion>\n-      </exclusions>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>\n@@ -113,8 +92,8 @@\n       <groupId>org.apache.bookkeeper</groupId>\n       <artifactId>bookkeeper-server</artifactId>\n       <version>${project.parent.version}</version>\n-      <type>jar</type>\n       <scope>compile</scope>\n+      <type>jar</type>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.bookkeeper</groupId>\n@@ -133,7 +112,6 @@\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>1.2.15</version>\n-      <scope>provided</scope>\n       <exclusions>\n \t<exclusion>\n \t  <groupId>javax.mail</groupId>\n@@ -158,5 +136,25 @@\n       <artifactId>commons-cli</artifactId>\n       <version>1.2</version>\n     </dependency>\n+    <dependency>\n+       <groupId>org.apache.hadoop</groupId>\n+       <artifactId>hadoop-common</artifactId>\n+       <version>0.23.1</version>\n+       <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.hadoop</groupId>\n+      <artifactId>hadoop-hdfs</artifactId>\n+      <version>0.23.1</version>\n+      <scope>compile</scope>\n+      <!-- commons-daemon has a malformed pom, which can cause the build to fail in an\n+           environment which uses an artifactory cache. -->\n+      <exclusions>\n+        <exclusion>\n+          <groupId>commons-daemon</groupId>\n+          <artifactId>commons-daemon</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n   </dependencies>\n </project>"},{"sha":"95f7e684d0974838711ebac978dff7878bc2d1be","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":5,"deletions":22,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -28,7 +28,6 @@\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.Queue;\n-import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n@@ -46,6 +45,8 @@\n import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;\n import org.apache.bookkeeper.util.SafeRunnable;\n \n+import com.google.common.util.concurrent.RateLimiter;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -68,8 +69,7 @@\n     final DigestManager macManager;\n     final DistributionSchedule distributionSchedule;\n \n-    final Semaphore opCounterSem;\n-    private final Integer throttling;\n+    final RateLimiter throttler;\n \n     /**\n      * Invalid entry id. This value is returned from methods which\n@@ -96,8 +96,7 @@\n \n         this.ledgerId = ledgerId;\n \n-        this.throttling = bk.getConf().getThrottleValue();\n-        this.opCounterSem = new Semaphore(throttling);\n+        this.throttler = RateLimiter.create(bk.getConf().getThrottleValue());\n \n         macManager = DigestManager.instantiate(ledgerId, password, digestType);\n         this.ledgerKey = MacDigestManager.genDigest(\"ledger\", password);\n@@ -167,15 +166,6 @@ DigestManager getDigestManager() {\n         return macManager;\n     }\n \n-    /**\n-     * Return total number of available slots.\n-     *\n-     * @return int    available slots\n-     */\n-    Semaphore getAvailablePermits() {\n-        return this.opCounterSem;\n-    }\n-\n     /**\n      *  Add to the length of the ledger in bytes.\n      *\n@@ -489,12 +479,7 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n                 \"Invalid values for offset(\"+offset\n                 +\") or length(\"+length+\")\");\n         }\n-        try {\n-            opCounterSem.acquire();\n-        } catch (InterruptedException e) {\n-            cb.addComplete(BKException.Code.InterruptedException,\n-                           LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n-        }\n+        throttler.acquire();\n \n         final long entryId;\n         final long currentLength;\n@@ -504,7 +489,6 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n             // updating lastAddPushed\n             if (metadata.isClosed()) {\n                 LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                LedgerHandle.this.opCounterSem.release();\n                 cb.addComplete(BKException.Code.LedgerClosedException,\n                                LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n                 return;\n@@ -526,7 +510,6 @@ public void safeRun() {\n                 }\n             });\n         } catch (RuntimeException e) {\n-            opCounterSem.release();\n             cb.addComplete(BKException.Code.InterruptedException,\n                     LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n         }"},{"sha":"e4d2a7f25e1d62383c20a23f64859422b61ca6ca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -168,7 +168,6 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n \n     void submitCallback(final int rc) {\n         cb.addComplete(rc, lh, entryId, ctx);\n-        lh.opCounterSem.release();\n     }\n \n     @Override"},{"sha":"90c0554b7283622ee0d78503f46a408ce651f8cf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -308,7 +308,7 @@ public void run() {\n     }\n \n     void sendReadTo(InetSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n-        lh.opCounterSem.acquire();\n+        lh.throttler.acquire();\n \n         lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId, \n                                      this, new ReadContext(to, entry));\n@@ -319,8 +319,6 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final C\n         final ReadContext rctx = (ReadContext)ctx;\n         final LedgerEntryRequest entry = rctx.entry;\n \n-        lh.opCounterSem.release();\n-\n         if (rc != BKException.Code.OK) {\n             entry.logErrorAndReattemptRead(rctx.to, \"Error: \" + BKException.getMessage(rc), rc);\n             return;"},{"sha":"b2ae05e6bdda81d0861063f62d5e30d469b21c6a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -75,7 +75,6 @@\n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n     InetSocketAddress addr;\n-    Semaphore opCounterSem = new Semaphore(2000);\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor;"},{"sha":"3d03cd38dea1e919cc6732de55418d9727ad60db","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/8a396e1f74ff9f9cf25d3b4bfc43c8a112992555/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java?ref=8a396e1f74ff9f9cf25d3b4bfc43c8a112992555","patch":"@@ -1,127 +0,0 @@\n-package org.apache.bookkeeper.client;\n-\n-/*\n-*\n-* Licensed to the Apache Software Foundation (ASF) under one\n-* or more contributor license agreements.  See the NOTICE file\n-* distributed with this work for additional information\n-* regarding copyright ownership.  The ASF licenses this file\n-* to you under the Apache License, Version 2.0 (the\n-* \"License\"); you may not use this file except in compliance\n-* with the License.  You may obtain a copy of the License at\n-*\n-*   http://www.apache.org/licenses/LICENSE-2.0\n-*\n-* Unless required by applicable law or agreed to in writing,\n-* software distributed under the License is distributed on an\n-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-* KIND, either express or implied.  See the License for the\n-* specific language governing permissions and limitations\n-* under the License.\n-*\n-*/\n-\n-import java.util.Enumeration;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n-import org.apache.bookkeeper.test.BookieFailureTest;\n-import org.junit.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class BookieThrottleTest extends BookKeeperClusterTestCase{\n-\n-    private static Logger LOG = LoggerFactory.getLogger(BookieFailureTest.class);\n-    private DigestType digestType;\n-    private LedgerHandle lh;\n-    private static CountDownLatch countDownLatch;\n-    private int throttle = 5;\n-    private int TIME_OUT = 30;\n-\n-    // Constructor\n-    public BookieThrottleTest() {\n-        super(4);\n-        this.digestType = DigestType.CRC32;\n-    }\n-\n-    @Test\n-    public void testVerifyPermitRelaseInReadFailure() throws Exception {\n-        baseClientConf.setThrottleValue(numBookies);\n-        int numEntries = throttle * 2;\n-        System.setProperty(\"throttle\", String.valueOf(throttle));\n-\n-        lh = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n-        // Add ledger entries.\n-        for (int i = 0; i < numEntries; i++) {\n-            lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (i))\n-                    .getBytes());\n-        }\n-        LOG.info(\"Finished writing all ledger entries so shutdown all the bookies \" +\n-                \"to verify the read permits.\");\n-\n-        for (int i = 0; i < numBookies; i++) {\n-            bs.get(i).shutdown();\n-        }\n-\n-        try {\n-            lh.readEntries(0, throttle-1);\n-        } catch (BKException e) {\n-            LOG.info( \"Exception when reading the entries, since all bookies are stopped\", e);\n-        }\n-        LOG.debug(\"*** READ COMPLETE ***\");\n-        // grace period, just to avoid randomness\n-        Thread.sleep(2000);\n-        assertEquals(\"Permits is not released when read has failed from all replicas\",\n-                throttle, lh.getAvailablePermits().availablePermits());\n-        lh.close();\n-    }\n-\n-    @Test\n-    public void testVerifyPermitRelaseInAsyncReadFailure() throws Exception {\n-        baseClientConf.setThrottleValue(numBookies);\n-        System.setProperty(\"throttle\", String.valueOf(throttle));\n-\n-        lh = bkc.createLedger(numBookies, 1, digestType, \"\"\n-                .getBytes());\n-        // Add ledger entries.\n-        int numEntries = throttle * 2;\n-        for (int i = 0; i < numEntries; i++) {\n-            lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (i))\n-                    .getBytes());\n-        }\n-        LOG.info(\"Finished writing all ledger entries so shutdown all the bookies \"+\n-                \"to verify the read permits.\");\n-\n-        for (int i = 0; i < numBookies; i++) {\n-            bs.get(i).shutdown();\n-        }\n-        BookieReadCallback bookieReadCallback = new BookieReadCallback();\n-        countDownLatch = new CountDownLatch(throttle);\n-        try {\n-            lh.asyncReadEntries(0, throttle-1, bookieReadCallback, null);\n-        } catch (Exception e) {\n-            LOG.info( \"Exception when reading the entries, since all bookies are stopped\", e);\n-        }\n-        countDownLatch.await(TIME_OUT, TimeUnit.SECONDS);\n-        LOG.debug(\"*** READ COMPLETE ***\");\n-        // grace period, just to avoid randomness\n-        Thread.sleep(2000);\n-        assertEquals(\"Permits is not released when read has failed from all replicas\",\n-                throttle, lh.getAvailablePermits().availablePermits());\n-        lh.close();\n-    }\n-\n-    static class BookieReadCallback implements ReadCallback\n-    {\n-        @Override\n-        public void readComplete(int rc, LedgerHandle lh,\n-                Enumeration<LedgerEntry> seq, Object ctx) {\n-            assertTrue(\"Expected Not OK, since all bookies are stopped\", rc != BKException.Code.OK);\n-            countDownLatch.countDown();\n-        }        \n-    }\n-}"},{"sha":"b464317e4388eaba4cb204b93c55b6782c180613","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"modified","additions":17,"deletions":8,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -291,40 +291,49 @@ public void testSpeculativeReadScheduling() throws Exception {\n         Set<InetSocketAddress> noHost = new HashSet();\n         Set<InetSocketAddress> secondHostOnly = new HashSet();\n         secondHostOnly.add(ensemble.get(1));\n+        PendingReadOp.LedgerEntryRequest req0 = null, req2 = null, req4 = null;\n         try {\n             LatchCallback latch0 = new LatchCallback();\n             PendingReadOp op = new PendingReadOp(l, bkspec.scheduler,\n                                                  0, 5, latch0, null);\n \n             // if we've already heard from all hosts,\n             // we only send the initial read\n-            PendingReadOp.LedgerEntryRequest req0\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 0);\n+            req0 = op.new LedgerEntryRequest(ensemble, l.getId(), 0);\n             assertTrue(\"Should have sent to first\",\n                        req0.maybeSendSpeculativeRead(allHosts).equals(ensemble.get(0)));\n             assertNull(\"Should not have sent another\",\n                        req0.maybeSendSpeculativeRead(allHosts));\n \n             // if we have heard from some hosts, but not one we have sent to\n             // send again\n-            PendingReadOp.LedgerEntryRequest req2\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 2);\n+            req2 = op.new LedgerEntryRequest(ensemble, l.getId(), 2);\n             assertTrue(\"Should have sent to third\",\n                        req2.maybeSendSpeculativeRead(noHost).equals(ensemble.get(2)));\n             assertTrue(\"Should have sent to first\",\n                        req2.maybeSendSpeculativeRead(secondHostOnly).equals(ensemble.get(0)));\n \n             // if we have heard from some hosts, which includes one we sent to\n             // do not read again\n-            PendingReadOp.LedgerEntryRequest req4\n-                = op.new LedgerEntryRequest(ensemble, l.getId(), 4);\n+            req4 = op.new LedgerEntryRequest(ensemble, l.getId(), 4);\n             assertTrue(\"Should have sent to second\",\n                        req4.maybeSendSpeculativeRead(noHost).equals(ensemble.get(1)));\n             assertNull(\"Should not have sent another\",\n                        req4.maybeSendSpeculativeRead(secondHostOnly));\n         } finally {\n-            // wait for all ops to complete\n-            l.opCounterSem.acquire(bkspec.getConf().getThrottleValue());\n+            for (PendingReadOp.LedgerEntryRequest req\n+                     : new PendingReadOp.LedgerEntryRequest[] { req0, req2, req4 }) {\n+                if (req != null) {\n+                    int i = 0;\n+                    while (!req.isComplete()) {\n+                        if (i++ > 10) {\n+                            break; // wait for up to 10 seconds\n+                        }\n+                        Thread.sleep(1000);\n+                    }\n+                    assertTrue(\"Request should be done\", req0.isComplete());\n+                }\n+            }\n \n             l.close();\n             bkspec.close();"},{"sha":"2ed71f325714701589d04ce44063f8c435a17032","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":0,"deletions":113,"changes":113,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -415,119 +415,6 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         }\n     }\n \n-    /**\n-     * Method for obtaining the available permits of a ledger handle\n-     * using reflection to avoid adding a new public method to the\n-     * class.\n-     *\n-     * @param lh\n-     * @return\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    int getAvailablePermits(LedgerHandle lh) throws\n-        NoSuchFieldException, IllegalAccessException\n-    {\n-        Field field = LedgerHandle.class.getDeclaredField(\"opCounterSem\");\n-        field.setAccessible(true);\n-        return ((Semaphore)field.get(lh)).availablePermits();\n-    }\n-\n-    @Test\n-    public void testReadWriteAsyncSingleClientThrottle() throws\n-        IOException, NoSuchFieldException, IllegalAccessException {\n-        SyncObj sync = new SyncObj();\n-        try {\n-\n-            Integer throttle = 100;\n-            ThrottleTestCallback tcb = new ThrottleTestCallback(throttle);\n-            // Create a ledger\n-            bkc.getConf().setThrottleValue(throttle);\n-            lh = bkc.createLedger(digestType, ledgerPassword);\n-            // bkc.initMessageDigest(\"SHA1\");\n-            ledgerId = lh.getId();\n-            LOG.info(\"Ledger ID: \" + lh.getId());\n-\n-            numEntriesToWrite = 8000;\n-            for (int i = 0; i < (numEntriesToWrite - 2000); i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n-\n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.asyncAddEntry(entry.array(), this, sync);\n-                /*\n-                 * Check that the difference is no larger than the throttling threshold\n-                 */\n-                int testValue = getAvailablePermits(lh);\n-                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n-            }\n-\n-\n-            for (int i = 0; i < 2000; i++) {\n-                ByteBuffer entry = ByteBuffer.allocate(4);\n-                entry.putInt(rng.nextInt(maxInt));\n-                entry.position(0);\n-\n-                entries.add(entry.array());\n-                entriesSize.add(entry.array().length);\n-                lh.asyncAddEntry(entry.array(), this, sync);\n-\n-                /*\n-                 * Check that the difference is no larger than the throttling threshold\n-                 */\n-                int testValue = getAvailablePermits(lh);\n-                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n-            }\n-\n-            // wait for all entries to be acknowledged\n-            synchronized (sync) {\n-                while (sync.counter < numEntriesToWrite) {\n-                    LOG.debug(\"Entries counter = \" + sync.counter);\n-                    sync.wait();\n-                }\n-                assertEquals(\"Error adding\", BKException.Code.OK, sync.getReturnCode());\n-            }\n-\n-            LOG.debug(\"*** WRITE COMPLETE ***\");\n-            // close ledger\n-            lh.close();\n-\n-            // *** WRITING PART COMPLETE // READ PART BEGINS ***\n-\n-            // open ledger\n-            lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n-            LOG.debug(\"Number of entries written: \" + (lh.getLastAddConfirmed() + 1));\n-            assertTrue(\"Verifying number of entries written\", lh.getLastAddConfirmed() == (numEntriesToWrite - 1));\n-\n-            // read entries\n-            sync.counter = 0;\n-            for (int i = 0; i < numEntriesToWrite; i+=throttle) {\n-                lh.asyncReadEntries(i, i + throttle - 1, tcb, sync);\n-                int testValue = getAvailablePermits(lh);\n-                assertTrue(\"Difference is incorrect : \" + i + \", \" + sync.counter + \", \" + testValue, testValue <= throttle);\n-            }\n-\n-            synchronized (sync) {\n-                while (sync.counter < numEntriesToWrite) {\n-                    LOG.info(\"Entries counter = \" + sync.counter);\n-                    sync.wait();\n-                }\n-                assertEquals(\"Error reading\", BKException.Code.OK, sync.getReturnCode());\n-            }\n-\n-            LOG.debug(\"*** READ COMPLETE ***\");\n-\n-            lh.close();\n-        } catch (BKException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to BookKeeper exception\");\n-        } catch (InterruptedException e) {\n-            LOG.error(\"Test failed\", e);\n-            fail(\"Test failed due to interruption\");\n-        }\n-    }\n-\n     @Test\n     public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {\n         SyncObj sync = new SyncObj();"},{"sha":"c174ed66c1188bee10b37295dc042a0740874c33","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/ea36e59a1c314bf698d572e5f714e0b68e554a6e/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea36e59a1c314bf698d572e5f714e0b68e554a6e/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java?ref=ea36e59a1c314bf698d572e5f714e0b68e554a6e","patch":"@@ -141,7 +141,10 @@ public void run() {\n                                 publisher.asyncPublish(topic, getMsg(9999), new TestCallback(queue), null);\n                             }\n                             for (int i=0; i<3; i++) {\n-                                assertTrue(queue.take());\n+                                if (!queue.take()) {\n+                                    logger.error(\"Error publishing to topic {}\", topic);\n+                                    ConcurrencyUtils.put(consumeQueue, false);\n+                                }\n                             }\n                         } catch (Exception e) {\n                             logger.error(\"Failed to publish message to obtain permit.\");"}]}

