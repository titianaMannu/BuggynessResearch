{"sha":"ea4a13a45d8d2102f5f0098e404d3de66777a39b","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYTRhMTNhNDVkOGQyMTAyZjVmMDA5OGU0MDRkM2RlNjY3NzdhMzli","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-10-30T15:23:54Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2013-10-30T15:23:54Z"},"message":"BOOKKEEPER-700: GarbageCollectorThread exsiting with ArrayIndexOutOfBoundsException (rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1537130 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"407b088fe8cc67e6360f8a56228a72349a331b3d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/407b088fe8cc67e6360f8a56228a72349a331b3d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ea4a13a45d8d2102f5f0098e404d3de66777a39b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ea4a13a45d8d2102f5f0098e404d3de66777a39b","html_url":"https://github.com/apache/bookkeeper/commit/ea4a13a45d8d2102f5f0098e404d3de66777a39b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ea4a13a45d8d2102f5f0098e404d3de66777a39b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f345cb9472250eca2b724fa14b8d2c08425b6a2f","url":"https://api.github.com/repos/apache/bookkeeper/commits/f345cb9472250eca2b724fa14b8d2c08425b6a2f","html_url":"https://github.com/apache/bookkeeper/commit/f345cb9472250eca2b724fa14b8d2c08425b6a2f"}],"stats":{"total":152,"additions":101,"deletions":51},"files":[{"sha":"40985dbefec2ea82423d4768d9533cefc2535deb","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ea4a13a45d8d2102f5f0098e404d3de66777a39b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ea4a13a45d8d2102f5f0098e404d3de66777a39b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ea4a13a45d8d2102f5f0098e404d3de66777a39b","patch":"@@ -120,6 +120,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-659: LRU page management in ledger cache. (Aniruddha, Robin Dhamankar & sijie via ivank)\n \n+        BOOKKEEPER-700: GarbageCollectorThread exsiting with ArrayIndexOutOfBoundsException (rakeshr via ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-601: readahead cache size isn't updated correctly (sijie via fpj)"},{"sha":"4365227a26ed8b964b4afad8b4d0e52729b8c65f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/ea4a13a45d8d2102f5f0098e404d3de66777a39b/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea4a13a45d8d2102f5f0098e404d3de66777a39b/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=ea4a13a45d8d2102f5f0098e404d3de66777a39b","patch":"@@ -31,6 +31,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.util.concurrent.RateLimiter;\n \n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n@@ -147,6 +148,10 @@ public void onRotateEntryLog() {\n \n         synchronized private void waitEntrylogFlushed() throws IOException {\n             try {\n+                if (offsets.size() <= 0) {\n+                    LOG.debug(\"Skipping entry log flushing, as there is no offset!\");\n+                    return;\n+                }\n                 synchronized (flushLock) {\n                     Offset lastOffset = offsets.get(offsets.size()-1);\n                     long lastOffsetLogId = EntryLogger.logIdForOffset(lastOffset.offset);\n@@ -351,7 +356,8 @@ private void doGcEntryLogs() {\n      * would not be compacted.\n      * </p>\n      */\n-    private void doCompactEntryLogs(double threshold) {\n+    @VisibleForTesting\n+    void doCompactEntryLogs(double threshold) {\n         LOG.info(\"Do compaction to compact those files lower than \" + threshold);\n         // sort the ledger meta by occupied unused space\n         Comparator<EntryLogMetadata> sizeComparator = new Comparator<EntryLogMetadata>() {"},{"sha":"bd6770111e849ef05719fe5976de361061e7f9d4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"modified","additions":92,"deletions":50,"changes":142,"blob_url":"https://github.com/apache/bookkeeper/blob/ea4a13a45d8d2102f5f0098e404d3de66777a39b/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/ea4a13a45d8d2102f5f0098e404d3de66777a39b/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java?ref=ea4a13a45d8d2102f5f0098e404d3de66777a39b","patch":"@@ -22,7 +22,6 @@\n  */\n import java.io.File;\n import java.io.IOException;\n-import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -321,54 +320,7 @@ public void testCompactionSafety() throws Exception {\n         tearDown(); // I dont want the test infrastructure\n         ServerConfiguration conf = new ServerConfiguration();\n         final Set<Long> ledgers = Collections.newSetFromMap(new ConcurrentHashMap<Long, Boolean>());\n-        LedgerManager manager = new LedgerManager() {\n-                @Override\n-                public void createLedger(LedgerMetadata metadata, GenericCallback<Long> cb) {\n-                    unsupported();\n-                }\n-                @Override\n-                public void removeLedgerMetadata(long ledgerId, Version version,\n-                                                 GenericCallback<Void> vb) {\n-                    unsupported();\n-                }\n-                @Override\n-                public void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb) {\n-                    unsupported();\n-                }\n-                @Override\n-                public void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata,\n-                        GenericCallback<Void> cb) {\n-                    unsupported();\n-                }\n-                @Override\n-                public void asyncProcessLedgers(Processor<Long> processor,\n-                                                AsyncCallback.VoidCallback finalCb,\n-                        Object context, int successRc, int failureRc) {\n-                    unsupported();\n-                }\n-                @Override\n-                public void close() throws IOException {}\n-\n-                void unsupported() {\n-                    LOG.error(\"Unsupported operation called\", new Exception());\n-                    throw new RuntimeException(\"Unsupported op\");\n-                }\n-                @Override\n-                public LedgerRangeIterator getLedgerRanges() {\n-                    final AtomicBoolean hasnext = new AtomicBoolean(true);\n-                    return new LedgerManager.LedgerRangeIterator() {\n-                        @Override\n-                        public boolean hasNext() throws IOException {\n-                            return hasnext.get();\n-                        }\n-                        @Override\n-                        public LedgerManager.LedgerRange next() throws IOException {\n-                            hasnext.set(false);\n-                            return new LedgerManager.LedgerRange(ledgers);\n-                        }\n-                    };\n-                 }\n-            };\n+        LedgerManager manager = getLedgerManager(ledgers);\n \n         File tmpDir = File.createTempFile(\"bkTest\", \".dir\");\n         tmpDir.delete();\n@@ -451,8 +403,98 @@ public void checkpointComplete(CheckpointSource.Checkpoint checkpoint, boolean c\n         storage.getEntry(1, 1); // entry should exist\n     }\n \n+    private LedgerManager getLedgerManager(final Set<Long> ledgers) {\n+        LedgerManager manager = new LedgerManager() {\n+                @Override\n+                public void createLedger(LedgerMetadata metadata, GenericCallback<Long> cb) {\n+                    unsupported();\n+                }\n+                @Override\n+                public void removeLedgerMetadata(long ledgerId, Version version,\n+                                                 GenericCallback<Void> vb) {\n+                    unsupported();\n+                }\n+                @Override\n+                public void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb) {\n+                    unsupported();\n+                }\n+                @Override\n+                public void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata,\n+                        GenericCallback<Void> cb) {\n+                    unsupported();\n+                }\n+                @Override\n+                public void asyncProcessLedgers(Processor<Long> processor,\n+                                                AsyncCallback.VoidCallback finalCb,\n+                        Object context, int successRc, int failureRc) {\n+                    unsupported();\n+                }\n+                @Override\n+                public void close() throws IOException {}\n+\n+                void unsupported() {\n+                    LOG.error(\"Unsupported operation called\", new Exception());\n+                    throw new RuntimeException(\"Unsupported op\");\n+                }\n+                @Override\n+                public LedgerRangeIterator getLedgerRanges() {\n+                    final AtomicBoolean hasnext = new AtomicBoolean(true);\n+                    return new LedgerManager.LedgerRangeIterator() {\n+                        @Override\n+                        public boolean hasNext() throws IOException {\n+                            return hasnext.get();\n+                        }\n+                        @Override\n+                        public LedgerManager.LedgerRange next() throws IOException {\n+                            hasnext.set(false);\n+                            return new LedgerManager.LedgerRange(ledgers);\n+                        }\n+                    };\n+                 }\n+            };\n+        return manager;\n+    }\n+\n+    /**\n+     * Test that compaction should execute silently when there is no entry logs\n+     * to compact. {@see https://issues.apache.org/jira/browse/BOOKKEEPER-700}\n+     */\n+    @Test(timeout = 60000)\n+    public void testWhenNoLogsToCompact() throws Exception {\n+        tearDown(); // I dont want the test infrastructure\n+        ServerConfiguration conf = new ServerConfiguration();\n+        File tmpDir = File.createTempFile(\"bkTest\", \".dir\");\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+        conf.setLedgerDirNames(new String[] { tmpDir.toString() });\n+\n+        LedgerDirsManager dirs = new LedgerDirsManager(conf);\n+        final Set<Long> ledgers = Collections\n+                .newSetFromMap(new ConcurrentHashMap<Long, Boolean>());\n+        LedgerManager manager = getLedgerManager(ledgers);\n+        CheckpointSource checkpointSource = new CheckpointSource() {\n+\n+            @Override\n+            public Checkpoint newCheckpoint() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void checkpointComplete(Checkpoint checkpoint,\n+                    boolean compact) throws IOException {\n+            }\n+        };\n+        InterleavedLedgerStorage storage = new InterleavedLedgerStorage(conf,\n+                manager, dirs, checkpointSource);\n+\n+        double threshold = 0.1;\n+        // shouldn't throw exception\n+        storage.gcThread.doCompactEntryLogs(threshold);\n+    }\n+\n     private ByteBuffer genEntry(long ledger, long entry, int size) {\n-        byte[] data = new byte[size];\n         ByteBuffer bb = ByteBuffer.wrap(new byte[size]);\n         bb.putLong(ledger);\n         bb.putLong(entry);"}]}

