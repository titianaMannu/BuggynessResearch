{"sha":"eba338eb398f8a22987c6bd8352bf2d649fb7c33","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYmEzMzhlYjM5OGY4YTIyOTg3YzZiZDgzNTJiZjJkNjQ5ZmI3YzMz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-26T23:52:18Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-09-26T23:52:18Z"},"message":"BOOKKEEPER-364: re-factor hedwig java client to support both one-subscription-per-channel and multiplex-subscriptions-per-channel. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1390777 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0c402096885886729d6136c3e32da92def36bca3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0c402096885886729d6136c3e32da92def36bca3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/eba338eb398f8a22987c6bd8352bf2d649fb7c33","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/eba338eb398f8a22987c6bd8352bf2d649fb7c33","html_url":"https://github.com/apache/bookkeeper/commit/eba338eb398f8a22987c6bd8352bf2d649fb7c33","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/eba338eb398f8a22987c6bd8352bf2d649fb7c33/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"881cda5c85d17f952bdc2c7e101eef669bce35d2","url":"https://api.github.com/repos/apache/bookkeeper/commits/881cda5c85d17f952bdc2c7e101eef669bce35d2","html_url":"https://github.com/apache/bookkeeper/commit/881cda5c85d17f952bdc2c7e101eef669bce35d2"}],"stats":{"total":5493,"additions":3553,"deletions":1940},"files":[{"sha":"ebca3128cab18ad926ccba96c8982932cb25aeb6","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -174,6 +174,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-335: client-side message filter for cpp client. (sijie via ivank)\n \n+        BOOKKEEPER-364: re-factor hedwig java client to support both one-subscription-per-channel and multiplex-subscriptions-per-channel. (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"346d74b34b1a728f38b0a74e036fc88b1c0e8474","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","status":"modified","additions":10,"deletions":12,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/MessageConsumeData.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.hedwig.client.data;\n \n-import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n \n /**\n@@ -31,28 +31,26 @@\n public class MessageConsumeData {\n \n     // Member variables\n-    public final ByteString topic;\n-    public final ByteString subscriberId;\n+    public final TopicSubscriber topicSubscriber;\n     // This is the Message sent from the server for Subscribes for consumption\n     // by the client.\n     public final Message msg;\n \n     // Constructor\n-    public MessageConsumeData(final ByteString topic, final ByteString subscriberId, final Message msg) {\n-        this.topic = topic;\n-        this.subscriberId = subscriberId;\n+    public MessageConsumeData(final TopicSubscriber topicSubscriber, final Message msg) {\n+        this.topicSubscriber = topicSubscriber;\n         this.msg = msg;\n     }\n \n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n-        if (topic != null)\n-            sb.append(\"Topic: \" + topic.toStringUtf8());\n-        if (subscriberId != null)\n-            sb.append(PubSubData.COMMA).append(\"SubscriberId: \" + subscriberId.toStringUtf8());\n-        if (msg != null)\n-            sb.append(PubSubData.COMMA).append(\"Message: \" + msg);\n+        if (topicSubscriber != null) {\n+            sb.append(\"Subscription: \").append(topicSubscriber);\n+        }\n+        if (msg != null) {\n+            sb.append(PubSubData.COMMA).append(\"Message: \").append(msg);\n+        }\n         return sb.toString();\n     }\n }"},{"sha":"bb2c0bb658b8bdef6f7b535df671a857a0b0df06","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/AbstractResponseHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.handlers;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.exceptions.ServerRedirectLoopException;\n+import org.apache.hedwig.client.exceptions.TooManyServerRedirectsException;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(AbstractResponseHandler.class);\n+\n+    protected final ClientConfiguration cfg;\n+    protected final HChannelManager channelManager;\n+\n+    protected AbstractResponseHandler(ClientConfiguration cfg,\n+                                      HChannelManager channelManager) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+    }\n+\n+    /**\n+     * Logic to handle received response.\n+     *\n+     * @param response\n+     *            PubSubResponse received from hub server.\n+     * @param pubSubData\n+     *            PubSubData for the pub/sub request.\n+     * @param channel\n+     *            Channel we used to make the request.\n+     */\n+    public abstract void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                                        Channel channel) throws Exception;\n+\n+    /**\n+     * Logic to repost a PubSubRequest when the server responds with a redirect\n+     * indicating they are not the topic master.\n+     *\n+     * @param response\n+     *            PubSubResponse from the server for the redirect\n+     * @param pubSubData\n+     *            PubSubData for the original PubSubRequest made\n+     * @param channel\n+     *            Channel Channel we used to make the original PubSubRequest\n+     * @throws Exception\n+     *             Throws an exception if there was an error in doing the\n+     *             redirect repost of the PubSubRequest\n+     */\n+    protected void handleRedirectResponse(PubSubResponse response, PubSubData pubSubData,\n+                                          Channel channel)\n+            throws Exception {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a redirect from host: {}, response: {}, pubSubData: {}\",\n+                         va(NetUtils.getHostFromChannel(channel), response, pubSubData));\n+        }\n+        // In this case, the PubSub request was done to a server that is not\n+        // responsible for the topic. First make sure that we haven't\n+        // exceeded the maximum number of server redirects.\n+        int curNumServerRedirects = (pubSubData.triedServers == null) ? 0 : pubSubData.triedServers.size();\n+        if (curNumServerRedirects >= cfg.getMaximumServerRedirects()) {\n+            // We've already exceeded the maximum number of server redirects\n+            // so consider this as an error condition for the client.\n+            // Invoke the operationFailed callback and just return.\n+            logger.debug(\"Exceeded the number of server redirects ({}) so error out.\",\n+                         curNumServerRedirects);\n+            PubSubException exception = new ServiceDownException(\n+                new TooManyServerRedirectsException(\"Already reached max number of redirects: \"\n+                                                    + curNumServerRedirects));\n+            pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            return;\n+        }\n+\n+        // We will redirect and try to connect to the correct server\n+        // stored in the StatusMsg of the response. First store the\n+        // server that we sent the PubSub request to for the topic.\n+        ByteString triedServer = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(\n+                                                         NetUtils.getHostFromChannel(channel)));\n+        if (pubSubData.triedServers == null) {\n+            pubSubData.triedServers = new LinkedList<ByteString>();\n+        }\n+        pubSubData.shouldClaim = true;\n+        pubSubData.triedServers.add(triedServer);\n+\n+        // Now get the redirected server host (expected format is\n+        // Hostname:Port:SSLPort) from the server's response message. If one is\n+        // not given for some reason, then redirect to the default server\n+        // host/VIP to repost the request.\n+        String statusMsg = response.getStatusMsg();\n+        InetSocketAddress redirectedHost;\n+        boolean redirectToDefaultServer;\n+        if (statusMsg != null && statusMsg.length() > 0) {\n+            if (cfg.isSSLEnabled()) {\n+                redirectedHost = new HedwigSocketAddress(statusMsg).getSSLSocketAddress();\n+            } else {\n+                redirectedHost = new HedwigSocketAddress(statusMsg).getSocketAddress();\n+            }\n+            redirectToDefaultServer = false;\n+        } else {\n+            redirectedHost = cfg.getDefaultServerHost();\n+            redirectToDefaultServer = true;\n+        }\n+\n+        // Make sure the redirected server is not one we've already attempted\n+        // already before in this PubSub request.\n+        if (pubSubData.triedServers.contains(ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(redirectedHost)))) {\n+            logger.error(\"We've already sent this PubSubRequest before to redirectedHost: {}, pubSubData: {}\",\n+                         va(redirectedHost, pubSubData));\n+            PubSubException exception = new ServiceDownException(\n+                new ServerRedirectLoopException(\"Already made the request before to redirected host: \"\n+                                                + redirectedHost));\n+            pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            return;\n+        }\n+\n+        // submit the pub/sub request to redirected host\n+        if (redirectToDefaultServer) {\n+            channelManager.submitOpToDefaultServer(pubSubData);\n+        } else {\n+            channelManager.redirectToHost(pubSubData, redirectedHost);\n+        }\n+    }\n+\n+}"},{"sha":"436c14f85b5e65be42196f14d5160ecc4db652ee","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","status":"modified","additions":41,"deletions":43,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/MessageConsumeCallback.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -19,101 +19,99 @@\n \n import java.util.TimerTask;\n \n-import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n-import org.apache.hedwig.client.netty.ResponseHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.channel.Channel;\n \n+import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.MessageConsumeData;\n-import org.apache.hedwig.client.data.TopicSubscriber;\n-import org.apache.hedwig.client.netty.HedwigClientImpl;\n+import org.apache.hedwig.client.netty.HChannelManager;\n import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n \n /**\n  * This is the Callback used by the MessageHandlers on the client app when\n  * they've finished consuming a subscription message sent from the server\n  * asynchronously. This callback back to the client libs will be stateless so we\n  * can use a singleton for the class. The object context used should be the\n  * MessageConsumeData type. That will contain all of the information needed to\n- * call the message consume logic in the client lib ResponseHandler.\n+ * call the message consume logic in the client lib HChannelHandler.\n  *\n  */\n public class MessageConsumeCallback implements Callback<Void> {\n \n     private static Logger logger = LoggerFactory.getLogger(MessageConsumeCallback.class);\n \n-    private final HedwigClientImpl client;\n+    private final HChannelManager channelManager;\n+    private final long consumeRetryWaitTime;\n \n-    public MessageConsumeCallback(HedwigClientImpl client) {\n-        this.client = client;\n+    public MessageConsumeCallback(ClientConfiguration cfg,\n+                                  HChannelManager channelManager) {\n+        this.channelManager = channelManager;\n+        this.consumeRetryWaitTime =\n+            cfg.getMessageConsumeRetryWaitTime();\n     }\n \n     class MessageConsumeRetryTask extends TimerTask {\n         private final MessageConsumeData messageConsumeData;\n-        private final TopicSubscriber topicSubscriber;\n \n-        public MessageConsumeRetryTask(MessageConsumeData messageConsumeData, TopicSubscriber topicSubscriber) {\n+        public MessageConsumeRetryTask(MessageConsumeData messageConsumeData) {\n             this.messageConsumeData = messageConsumeData;\n-            this.topicSubscriber = topicSubscriber;\n         }\n \n         @Override\n         public void run() {\n             // Try to consume the message again\n-            Channel topicSubscriberChannel = client.getSubscriber().getChannelForTopic(topicSubscriber);\n-            ResponseHandler handler = null;\n-            try {\n-                handler = HedwigClientImpl.getResponseHandlerFromChannel(topicSubscriberChannel);\n-            } catch (NoResponseHandlerException e) {\n-                logger.debug(\"No response handler found while invoking asyncMessageConsumed in the Message\"\n-                    + \" consume retry task.\", e);\n-                // Explicitly close the channel\n-                if (null != topicSubscriberChannel) {\n-                    topicSubscriberChannel.close();\n-                }\n+            SubscribeResponseHandler subscribeHChannelHandler =\n+                channelManager.getSubscribeResponseHandler(messageConsumeData.topicSubscriber);\n+            if (null == subscribeHChannelHandler ||\n+                !subscribeHChannelHandler.hasSubscription(messageConsumeData.topicSubscriber)) {\n+                logger.warn(\"No subscription {} found to retry delivering message {}.\",\n+                            va(messageConsumeData.topicSubscriber,\n+                               MessageIdUtils.msgIdToReadableString(messageConsumeData.msg.getMsgId())));\n                 return;\n             }\n-            handler.getSubscribeResponseHandler().asyncMessageConsume(messageConsumeData.msg);\n+\n+            subscribeHChannelHandler.asyncMessageDeliver(messageConsumeData.topicSubscriber,\n+                                                         messageConsumeData.msg);\n         }\n     }\n \n     public void operationFinished(Object ctx, Void resultOfOperation) {\n         MessageConsumeData messageConsumeData = (MessageConsumeData) ctx;\n-        TopicSubscriber topicSubscriber = new TopicSubscriber(messageConsumeData.topic, messageConsumeData.subscriberId);\n-        // Message has been successfully consumed by the client app so callback\n-        // to the ResponseHandler indicating that the message is consumed.\n-        Channel topicSubscriberChannel = client.getSubscriber().getChannelForTopic(topicSubscriber);\n-        ResponseHandler handler = null;\n-        try {\n-            handler = HedwigClientImpl.getResponseHandlerFromChannel(topicSubscriberChannel);\n-        } catch (NoResponseHandlerException e) {\n-            logger.debug(\"No response handler found while invoking messageConsumed.\", e);\n-            // Explicitly close the channel\n-            if (null != topicSubscriberChannel) {\n-                topicSubscriberChannel.close();\n-            }\n+\n+        SubscribeResponseHandler subscribeHChannelHandler =\n+            channelManager.getSubscribeResponseHandler(messageConsumeData.topicSubscriber);\n+        if (null == subscribeHChannelHandler ||\n+            !subscribeHChannelHandler.hasSubscription(messageConsumeData.topicSubscriber)) {\n+            logger.warn(\"No subscription {} found to consume message {}.\",\n+                        va(messageConsumeData.topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(messageConsumeData.msg.getMsgId())));\n             return;\n         }\n-        handler.getSubscribeResponseHandler().messageConsumed(messageConsumeData.msg);\n+\n+        // Message has been successfully consumed by the client app so callback\n+        // to the HChannelHandler indicating that the message is consumed.\n+        subscribeHChannelHandler.messageConsumed(messageConsumeData.topicSubscriber,\n+                                                 messageConsumeData.msg);\n     }\n \n     public void operationFailed(Object ctx, PubSubException exception) {\n         // Message has NOT been successfully consumed by the client app so\n-        // callback to the ResponseHandler to try the async MessageHandler\n+        // callback to the HChannelHandler to try the async MessageHandler\n         // Consume logic again.\n         MessageConsumeData messageConsumeData = (MessageConsumeData) ctx;\n-        TopicSubscriber topicSubscriber = new TopicSubscriber(messageConsumeData.topic, messageConsumeData.subscriberId);\n-        logger.error(\"Message was not consumed successfully by client MessageHandler: \" + messageConsumeData);\n+        logger.error(\"Message was not consumed successfully by client MessageHandler: {}\",\n+                     messageConsumeData);\n \n         // Sleep a pre-configured amount of time (in milliseconds) before we\n         // do the retry. In the future, we can have more dynamic logic on\n         // what duration to sleep based on how many times we've retried, or\n         // perhaps what the last amount of time we slept was. We could stick\n         // some of this meta-data into the MessageConsumeData when we retry.\n-        client.getClientTimer().schedule(new MessageConsumeRetryTask(messageConsumeData, topicSubscriber),\n-                                         client.getConfiguration().getMessageConsumeRetryWaitTime());\n+        channelManager.schedule(new MessageConsumeRetryTask(messageConsumeData),\n+                                consumeRetryWaitTime);\n     }\n \n }"},{"sha":"fc6a0251074488ef169090531dd8c7336e12681d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","status":"modified","additions":11,"deletions":14,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/PublishResponseHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,32 +17,29 @@\n  */\n package org.apache.hedwig.client.handlers;\n \n-import org.apache.hedwig.protocol.PubSubProtocol;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n \n+import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.client.netty.HedwigClientImpl;\n-import org.apache.hedwig.client.netty.ResponseHandler;\n+import org.apache.hedwig.client.netty.HChannelManager;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n \n-public class PublishResponseHandler {\n+public class PublishResponseHandler extends AbstractResponseHandler {\n \n     private static Logger logger = LoggerFactory.getLogger(PublishResponseHandler.class);\n \n-    private final ResponseHandler responseHandler;\n-\n-    public PublishResponseHandler(ResponseHandler responseHandler) {\n-        this.responseHandler = responseHandler;\n+    public PublishResponseHandler(ClientConfiguration cfg,\n+                                  HChannelManager channelManager) {\n+        super(cfg, channelManager);\n     }\n \n-    // Main method to handle Publish Response messages from the server.\n-    public void handlePublishResponse(PubSubResponse response, PubSubData pubSubData, Channel channel) throws Exception {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Handling a Publish response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                         + HedwigClientImpl.getHostFromChannel(channel));\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n         switch (response.getStatusCode()) {\n         case SUCCESS:\n             // Response was success so invoke the callback's operationFinished\n@@ -59,7 +56,7 @@ public void handlePublishResponse(PubSubResponse response, PubSubData pubSubData\n         case NOT_RESPONSIBLE_FOR_TOPIC:\n             // Redirect response so we'll need to repost the original Publish\n             // Request\n-            responseHandler.handleRedirectResponse(response, pubSubData, channel);\n+            handleRedirectResponse(response, pubSubData, channel);\n             break;\n         default:\n             // Consider all other status codes as errors, operation failed"},{"sha":"b8e5aec1111bc577af1221dd6722ace27ed98e12","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":96,"deletions":296,"changes":392,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,244 +17,59 @@\n  */\n package org.apache.hedwig.client.handlers;\n \n-import java.util.Collections;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-import java.util.Set;\n+import java.net.InetSocketAddress;\n \n-import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n \n import org.apache.hedwig.client.api.MessageHandler;\n-import org.apache.hedwig.client.data.MessageConsumeData;\n-import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.TopicSubscriber;\n-import org.apache.hedwig.client.netty.HedwigClientImpl;\n-import org.apache.hedwig.client.netty.ResponseHandler;\n-import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n-import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n-import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n \n-public class SubscribeResponseHandler {\n-\n-    private static Logger logger = LoggerFactory.getLogger(SubscribeResponseHandler.class);\n-\n-    private final ResponseHandler responseHandler;\n-\n-    // Member variables used when this ResponseHandler is for a Subscribe\n-    // channel. We need to be able to consume messages sent back to us from\n-    // the server, and to also recreate the Channel connection if it ever goes\n-    // down. For that, we need to store the original PubSubData for the\n-    // subscribe request, and also the MessageHandler that was registered when\n-    // delivery of messages started for the subscription.\n-    private PubSubData origSubData;\n-    private Channel subscribeChannel;\n-    private MessageHandler messageHandler;\n-    // Counter for the number of consumed messages so far to buffer up before we\n-    // send the Consume message back to the server along with the last/largest\n-    // message seq ID seen so far in that batch.\n-    private int numConsumedMessagesInBuffer = 0;\n-    private MessageSeqId lastMessageSeqId;\n-    // Queue used for subscribes when the MessageHandler hasn't been registered\n-    // yet but we've already received subscription messages from the server.\n-    // This will be lazily created as needed.\n-    private Queue<Message> subscribeMsgQueue;\n-    // Set to store all of the outstanding subscribed messages that are pending\n-    // to be consumed by the client app's MessageHandler. If this ever grows too\n-    // big (e.g. problem at the client end for message consumption), we can\n-    // throttle things by temporarily setting the Subscribe Netty Channel\n-    // to not be readable. When the Set has shrunk sufficiently, we can turn the\n-    // channel back on to read new messages.\n-    private Set<Message> outstandingMsgSet;\n-\n-    public SubscribeResponseHandler(ResponseHandler responseHandler) {\n-        this.responseHandler = responseHandler;\n-    }\n-\n-    // Public getter to retrieve the original PubSubData used for the Subscribe\n-    // request.\n-    synchronized public PubSubData getOrigSubData() {\n-        return origSubData;\n-    }\n-\n-    // Main method to handle Subscribe responses from the server that we sent\n-    // a Subscribe Request to.\n-    public void handleSubscribeResponse(PubSubResponse response, PubSubData pubSubData, Channel channel)\n-            throws Exception {\n-        // If this was not a successful response to the Subscribe request, we\n-        // won't be using the Netty Channel created so just close it.\n-        if (!response.getStatusCode().equals(StatusCode.SUCCESS)) {\n-            try {\n-                HedwigClientImpl.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n-            } catch (NoResponseHandlerException e) {\n-                // Log an error. But should we also return and not process anything further?\n-                logger.error(\"No response handler found while trying to close channel explicitly while handling a \" +\n-                        \"failed subscription response.\", e);\n-                // Continue closing the channel because this is an unexpected event and state should be reset.\n-            }\n-            channel.close();\n-        }\n-\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Handling a Subscribe response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                         + HedwigClientImpl.getHostFromChannel(channel));\n-        switch (response.getStatusCode()) {\n-        case SUCCESS:\n-            synchronized(this) {\n-                // For successful Subscribe requests, store this Channel locally\n-                // and set it to not be readable initially.\n-                // This way we won't be delivering messages for this topic\n-                // subscription until the client explicitly says so.\n-                subscribeChannel = channel;\n-                subscribeChannel.setReadable(false);\n-                // Store the original PubSubData used to create this successful\n-                // Subscribe request.\n-                origSubData = pubSubData;\n-\n-                SubscriptionPreferences preferences = null;\n-                if (response.hasResponseBody()) {\n-                    ResponseBody respBody = response.getResponseBody();\n-                    if (respBody.hasSubscribeResponse()) {\n-                        SubscribeResponse resp = respBody.getSubscribeResponse();\n-                        if (resp.hasPreferences()) {\n-                            preferences = resp.getPreferences();\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Receive subscription preferences for (topic:\" + pubSubData.topic.toStringUtf8()\n-                                           + \", subscriber:\" + pubSubData.subscriberId.toStringUtf8() + \") :\"\n-                                           + SubscriptionStateUtils.toString(preferences));\n-                            }\n-                        }\n-                    }\n-                }\n+/**\n+ * An interface provided to manage all subscriptions on a channel.\n+ *\n+ * Its responsibility is to handle all subscribe responses received on that channel,\n+ * clear up subscriptions and retry reconnectin subscriptions when channel disconnected,\n+ * and handle delivering messages to {@link MessageHandler} and sent consume messages\n+ * back to hub servers.\n+ */\n+public abstract class SubscribeResponseHandler extends AbstractResponseHandler {\n \n-                // Store the mapping for the TopicSubscriber to the Channel.\n-                // This is so we can control the starting and stopping of\n-                // message deliveries from the server on that Channel. Store\n-                // this only on a successful ack response from the server.\n-                TopicSubscriber topicSubscriber = new TopicSubscriber(pubSubData.topic, pubSubData.subscriberId);\n-                responseHandler.getSubscriber().setChannelAndPreferencesForTopic(topicSubscriber, channel, preferences);\n-                // Lazily create the Set (from a concurrent hashmap) to keep track\n-                // of outstanding Messages to be consumed by the client app. At this\n-                // stage, delivery for that topic hasn't started yet so creation of\n-                // this Set should be thread safe. We'll create the Set with an initial\n-                // capacity equal to the configured parameter for the maximum number of\n-                // outstanding messages to allow. The load factor will be set to\n-                // 1.0f which means we'll only rehash and allocate more space if\n-                // we ever exceed the initial capacity. That should be okay\n-                // because when that happens, things are slow already and piling\n-                // up on the client app side to consume messages.\n-                outstandingMsgSet = Collections.newSetFromMap(\n-                        new ConcurrentHashMap<Message,Boolean>(\n-                                responseHandler.getConfiguration().getMaximumOutstandingMessages(), 1.0f));\n-            }\n-            // Response was success so invoke the callback's operationFinished\n-            // method.\n-            pubSubData.getCallback().operationFinished(pubSubData.context, null);\n-            break;\n-        case CLIENT_ALREADY_SUBSCRIBED:\n-            // For Subscribe requests, the server says that the client is\n-            // already subscribed to it.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n-                                                    \"Client is already subscribed for topic: \" +\n-                                                        pubSubData.topic.toStringUtf8() + \", subscriberId: \" +\n-                                                        pubSubData.subscriberId.toStringUtf8()));\n-            break;\n-        case SERVICE_DOWN:\n-            // Response was service down failure so just invoke the callback's\n-            // operationFailed method.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                    \"Server responded with a SERVICE_DOWN status\"));\n-            break;\n-        case NOT_RESPONSIBLE_FOR_TOPIC:\n-            // Redirect response so we'll need to repost the original Subscribe\n-            // Request\n-            responseHandler.handleRedirectResponse(response, pubSubData, channel);\n-            break;\n-        default:\n-            // Consider all other status codes as errors, operation failed\n-            // cases.\n-            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                    \"Server responded with a status code of: \" +\n-                                                        response.getStatusCode()));\n-            break;\n-        }\n+    protected SubscribeResponseHandler(ClientConfiguration cfg,\n+                                       HChannelManager channelManager) {\n+        super(cfg, channelManager);\n     }\n \n-    // Main method to handle consuming a message for a topic that the client is\n-    // subscribed to.\n-    public void handleSubscribeMessage(PubSubResponse response) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Handling a Subscribe message in response: {}, topic: {}, subscriberId: {}\",\n-                    new Object[] { response, getOrigSubData().topic.toStringUtf8(),\n-                                   getOrigSubData().subscriberId.toStringUtf8() });\n-        }\n-        Message message = response.getMessage();\n-\n-        synchronized (this) {\n-            // Consume the message asynchronously that the client is subscribed\n-            // to. Do this only if delivery for the subscription has started and\n-            // a MessageHandler has been registered for the TopicSubscriber.\n-            if (messageHandler != null) {\n-                asyncMessageConsume(message);\n-            } else {\n-                // MessageHandler has not yet been registered so queue up these\n-                // messages for the Topic Subscription. Make the initial lazy\n-                // creation of the message queue thread safe just so we don't\n-                // run into a race condition where two simultaneous threads process\n-                // a received message and both try to create a new instance of\n-                // the message queue. Performance overhead should be okay\n-                // because the delivery of the topic has not even started yet\n-                // so these messages are not consumed and just buffered up here.\n-                if (subscribeMsgQueue == null)\n-                    subscribeMsgQueue = new LinkedList<Message>();\n-                logger.debug(\"Message has arrived but Subscribe channel does not have a registered \"\n-                    + \"MessageHandler yet so queueing up the message: {}\", message);\n-                subscribeMsgQueue.add(message);\n-            }\n-        }\n-    }\n+    /**\n+     * Handle Message delivered by the server.\n+     *\n+     * @param response\n+     *          Message received from the server.\n+     */\n+    public abstract void handleSubscribeMessage(PubSubResponse response);\n \n     /**\n      * Method called when a message arrives for a subscribe Channel and we want\n-     * to consume it asynchronously via the registered MessageHandler (should\n+     * to deliver it asynchronously via the registered MessageHandler (should\n      * not be null when called here).\n      *\n      * @param message\n      *            Message from Subscribe Channel we want to consume.\n      */\n-    protected void asyncMessageConsume(Message message) {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Call the client app's MessageHandler asynchronously to consume the message: \" + message\n-                         + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                         + origSubData.subscriberId.toStringUtf8());\n-        // Add this \"pending to be consumed\" message to the outstandingMsgSet.\n-        outstandingMsgSet.add(message);\n-        // Check if we've exceeded the max size for the outstanding message set.\n-        if (outstandingMsgSet.size() >= responseHandler.getConfiguration().getMaximumOutstandingMessages()\n-                && subscribeChannel.isReadable()) {\n-            // Too many outstanding messages so throttle it by setting the Netty\n-            // Channel to not be readable.\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Too many outstanding messages (\" + outstandingMsgSet.size()\n-                             + \") so throttling the subscribe netty Channel\");\n-            subscribeChannel.setReadable(false);\n-        }\n-        MessageConsumeData messageConsumeData = new MessageConsumeData(origSubData.topic, origSubData.subscriberId,\n-                message);\n-        messageHandler.deliver(origSubData.topic, origSubData.subscriberId, message, responseHandler.getClient()\n-                .getConsumeCallback(), messageConsumeData);\n-    }\n+    protected abstract void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                                Message message);\n \n     /**\n      * Method called when the client app's MessageHandler has asynchronously\n@@ -267,100 +82,85 @@ protected void asyncMessageConsume(Message message) {\n      * could be consumed by the client app and then called back to here, make\n      * this method synchronized.\n      *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n      * @param message\n      *            Message sent from server for topic subscription that has been\n      *            consumed by the client.\n      */\n-    protected synchronized void messageConsumed(Message message) {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Message has been successfully consumed by the client app for message: \" + message\n-                         + \", topic: \" + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                         + origSubData.subscriberId.toStringUtf8());\n-        // Update the consumed messages buffer variables\n-        if (responseHandler.getConfiguration().isAutoSendConsumeMessageEnabled()) {\n-            // Update these variables only if we are auto-sending consume\n-            // messages to the server. Otherwise the onus is on the client app\n-            // to call the Subscriber consume API to let the server know which\n-            // messages it has successfully consumed.\n-            numConsumedMessagesInBuffer++;\n-            lastMessageSeqId = message.getMsgId();\n-        }\n-        // Remove this consumed message from the outstanding Message Set.\n-        outstandingMsgSet.remove(message);\n-\n-        // For consume response to server, there is a config param on how many\n-        // messages to consume and buffer up before sending the consume request.\n-        // We just need to keep a count of the number of messages consumed\n-        // and the largest/latest msg ID seen so far in this batch. Messages\n-        // should be delivered in order and without gaps. Do this only if\n-        // auto-sending of consume messages is enabled.\n-        if (responseHandler.getConfiguration().isAutoSendConsumeMessageEnabled()\n-                && numConsumedMessagesInBuffer >= responseHandler.getConfiguration().getConsumedMessagesBufferSize()) {\n-            // Send the consume request and reset the consumed messages buffer\n-            // variables. We will use the same Channel created from the\n-            // subscribe request for the TopicSubscriber.\n-            logger.debug(\"Consumed message buffer limit reached so send the Consume Request to the \"\n-                + \"server with lastMessageSeqId: {}\", lastMessageSeqId);\n-            responseHandler.getSubscriber().doConsume(origSubData, subscribeChannel, lastMessageSeqId);\n-            numConsumedMessagesInBuffer = 0;\n-            lastMessageSeqId = null;\n-        }\n-\n-        // Check if we throttled message consumption previously when the\n-        // outstanding message limit was reached. For now, only turn the\n-        // delivery back on if there are no more outstanding messages to\n-        // consume. We could make this a configurable parameter if needed.\n-        if (!subscribeChannel.isReadable() && outstandingMsgSet.isEmpty()) {\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Message consumption has caught up so okay to turn off throttling of \" +\n-                    \"messages on the subscribe channel for topic: \" + origSubData.topic.toStringUtf8()\n-                       + \", subscriberId: \" + origSubData.subscriberId.toStringUtf8());\n-            subscribeChannel.setReadable(true);\n-        }\n-    }\n+    protected abstract void messageConsumed(TopicSubscriber topicSubscriber,\n+                                            Message message);\n \n     /**\n-     * Setter used for Subscribe flows when delivery for the subscription is\n-     * started. This is used to register the MessageHandler needed to consumer\n-     * the subscribed messages for the topic.\n+     * Start delivering messages for a given topic subscriber.\n      *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n      * @param messageHandler\n      *            MessageHandler to register for this ResponseHandler instance.\n+     * @throws ClientNotSubscribedException\n+     *            If the client is not currently subscribed to the topic\n+     * @throws AlreadyStartDeliveryException\n+     *            If someone started delivery a message handler before stopping existed one.\n      */\n-    public void setMessageHandler(MessageHandler messageHandler) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Setting the messageHandler for topic: {}, subscriberId: {}\",\n-                         getOrigSubData().topic.toStringUtf8(),\n-                         getOrigSubData().subscriberId.toStringUtf8());\n-        }\n-        synchronized (this) {\n-            this.messageHandler = messageHandler;\n-            // Once the MessageHandler is registered, see if we have any queued up\n-            // subscription messages sent to us already from the server. If so,\n-            // consume those first. Do this only if the MessageHandler registered is\n-            // not null (since that would be the HedwigSubscriber.stopDelivery\n-            // call).\n-            if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n-                if (logger.isDebugEnabled())\n-                    logger.debug(\"Consuming \" + subscribeMsgQueue.size() + \" queued up messages for topic: \"\n-                                 + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                                 + origSubData.subscriberId.toStringUtf8());\n-                for (Message message : subscribeMsgQueue) {\n-                    asyncMessageConsume(message);\n-                }\n-                // Now we can remove the queued up messages since they are all\n-                // consumed.\n-                subscribeMsgQueue.clear();\n-            }\n-        }\n-    }\n+    public abstract void startDelivery(TopicSubscriber topicSubscriber,\n+                                       MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n \n     /**\n-     * Getter for the MessageHandler that is set for this subscribe channel.\n+     * Stop delivering messages for a given topic subscriber.\n      *\n-     * @return The MessageHandler for consuming messages\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @throws ClientNotSubscribedException\n+     *             If the client is not currently subscribed to the topic\n      */\n-    public MessageHandler getMessageHandler() {\n-        return messageHandler;\n-    }\n+    public abstract void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException;\n+\n+    /**\n+     * Whether the given topic subscriber subscribed thru this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @return whether the given topic subscriber subscribed thru this handler.\n+     */\n+    public abstract boolean hasSubscription(TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Close subscription from this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param callback\n+     *            Callback when the subscription is closed. \n+     * @param context\n+     *            Callback context.\n+     */\n+    public abstract void asyncCloseSubscription(TopicSubscriber topicSubscriber,\n+                                                Callback<ResponseBody> callback,\n+                                                Object context);\n+\n+    /**\n+     * Consume a given message for given topic subscriber thru this handler.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     */\n+    public abstract void consume(TopicSubscriber topicSubscriber,\n+                                 MessageSeqId messageSeqId);\n+\n+    /**\n+     * This method is called when the underlying channel is disconnected due to server failure.\n+     *\n+     * The implementation should take the responsibility to clear subscriptions and retry\n+     * reconnecting subscriptions to new hub servers.\n+     *\n+     * @param host\n+     *          Host that channel connected to has disconnected.\n+     * @param channel\n+     *          Channel connected to.\n+     */\n+    public abstract void onChannelDisconnected(InetSocketAddress host,\n+                                               Channel channel);\n }"},{"sha":"3ddd5390553150162e9482d6e2125998cb12fde2","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","status":"modified","additions":17,"deletions":18,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/UnsubscribeResponseHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -21,36 +21,35 @@\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n \n+import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.client.netty.HedwigClientImpl;\n-import org.apache.hedwig.client.netty.ResponseHandler;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n \n-public class UnsubscribeResponseHandler {\n+public class UnsubscribeResponseHandler extends AbstractResponseHandler {\n \n     private static Logger logger = LoggerFactory.getLogger(UnsubscribeResponseHandler.class);\n \n-    private final ResponseHandler responseHandler;\n-\n-    public UnsubscribeResponseHandler(ResponseHandler responseHandler) {\n-        this.responseHandler = responseHandler;\n+    public UnsubscribeResponseHandler(ClientConfiguration cfg,\n+                                      HChannelManager channelManager) {\n+        super(cfg, channelManager);\n     }\n \n-    // Main method to handle Unsubscribe Response messages from the server.\n-    public void handleUnsubscribeResponse(PubSubResponse response, PubSubData pubSubData, Channel channel)\n+    @Override\n+    public void handleResponse(final PubSubResponse response, final PubSubData pubSubData,\n+                               final Channel channel)\n             throws Exception {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Handling an Unsubscribe response: \" + response + \", pubSubData: \" + pubSubData + \", host: \"\n-                         + HedwigClientImpl.getHostFromChannel(channel));\n         switch (response.getStatusCode()) {\n         case SUCCESS:\n-            // For successful Unsubscribe requests, we can now safely close the\n-            // Subscribe Channel and any cached data for that TopicSubscriber.\n-            responseHandler.getSubscriber().closeSubscription(pubSubData.topic, pubSubData.subscriberId);\n-            // Response was success so invoke the callback's operationFinished\n-            // method.\n+            // since for unsubscribe request, we close subscription first\n+            // for now, we don't need to do anything now.\n             pubSubData.getCallback().operationFinished(pubSubData.context, null);\n             break;\n         case CLIENT_NOT_SUBSCRIBED:\n@@ -70,7 +69,7 @@ public void handleUnsubscribeResponse(PubSubResponse response, PubSubData pubSub\n         case NOT_RESPONSIBLE_FOR_TOPIC:\n             // Redirect response so we'll need to repost the original\n             // Unsubscribe Request\n-            responseHandler.handleRedirectResponse(response, pubSubData, channel);\n+            handleRedirectResponse(response, pubSubData, channel);\n             break;\n         default:\n             // Consider all other status codes as errors, operation failed"},{"sha":"633506e44b54d54b01c920b056a6328a2496d610","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/CleanupChannelMap.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CleanupChannelMap<T> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(CleanupChannelMap.class);\n+    \n+    private final ConcurrentHashMap<T, HChannel> channels;\n+\n+    // Boolean indicating if the channel map is closed or not.\n+    protected boolean closed = false;\n+    protected final ReentrantReadWriteLock closedLock =\n+        new ReentrantReadWriteLock();\n+\n+    public CleanupChannelMap() {\n+        channels = new ConcurrentHashMap<T, HChannel>();\n+    }\n+\n+    /**\n+     * Add channel to the map. If an old channel has been bound\n+     * to <code>key</code>, the <code>channel</code> would be\n+     * closed immediately and the old channel is returned. Otherwise,\n+     * the <code>channel</code> is put in the map for future usage.\n+     *\n+     * If the channel map has been closed, the channel would be closed\n+     * immediately.\n+     *\n+     * @param key\n+     *            Key\n+     * @param channel\n+     *            Channel\n+     * @return the channel instance to use.\n+     */\n+    public HChannel addChannel(T key, HChannel channel) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                channel.close();\n+                return channel;\n+            }\n+            HChannel oldChannel = channels.putIfAbsent(key, channel);\n+            if (null != oldChannel) {\n+                logger.info(\"Channel for {} already exists, so no need to store it.\", key);\n+                channel.close();\n+                return oldChannel;\n+            } else {\n+                logger.debug(\"Storing a new channel for {}.\", key);\n+                return channel;\n+            }\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @return the channel bound with <code>key</code>.\n+     */\n+    public HChannel getChannel(T key) {\n+        return channels.get(key);\n+    }\n+\n+    /**\n+     * Remove the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @return the channel bound with <code>key</code>, null if no channel\n+     *         is bound with <code>key</code>.\n+     */\n+    public HChannel removeChannel(T key) {\n+        return channels.remove(key);\n+    }\n+\n+    /**\n+     * Remove the channel bound with <code>key</code>.\n+     *\n+     * @param key Key\n+     * @param channel The channel expected to be bound with <code>key</code>.\n+     * @return true if the channel is removed, false otherwise.\n+     */\n+    public boolean removeChannel(T key, HChannel channel) {\n+        return channels.remove(key, channel);\n+    }\n+\n+    /**\n+     * Return the channels in the map.\n+     *\n+     * @return the set of channels.\n+     */\n+    public Collection<HChannel> getChannels() {\n+        return channels.values();\n+    }\n+\n+    /**\n+     * Close the channels map.\n+     */\n+    public void close() {\n+        closedLock.writeLock().lock();\n+        try {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        } finally {\n+            closedLock.writeLock().unlock();\n+        }\n+        logger.debug(\"Closing channels map.\");\n+        for (HChannel channel : channels.values()) {\n+            channel.close(true);\n+        }\n+        channels.clear();\n+        logger.debug(\"Closed channels map.\");\n+    }\n+}"},{"sha":"68867a3fffc57c2d59f4b070f7684dad9a946d1a","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/881cda5c85d17f952bdc2c7e101eef669bce35d2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/881cda5c85d17f952bdc2c7e101eef669bce35d2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java?ref=881cda5c85d17f952bdc2c7e101eef669bce35d2","patch":"@@ -1,127 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.client.netty;\n-\n-import java.net.InetSocketAddress;\n-import java.util.LinkedList;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.jboss.netty.channel.ChannelFuture;\n-import org.jboss.netty.channel.ChannelFutureListener;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n-import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.util.HedwigSocketAddress;\n-\n-public class ConnectCallback implements ChannelFutureListener {\n-\n-    private static Logger logger = LoggerFactory.getLogger(ConnectCallback.class);\n-\n-    // Private member variables\n-    private PubSubData pubSubData;\n-    private InetSocketAddress host;\n-    private final HedwigClientImpl client;\n-    private final HedwigPublisher pub;\n-    private final HedwigSubscriber sub;\n-    private final ClientConfiguration cfg;\n-\n-    // Constructor\n-    public ConnectCallback(PubSubData pubSubData, InetSocketAddress host, HedwigClientImpl client) {\n-        super();\n-        this.pubSubData = pubSubData;\n-        this.host = host;\n-        this.client = client;\n-        this.pub = client.getPublisher();\n-        this.sub = client.getSubscriber();\n-        this.cfg = client.getConfiguration();\n-    }\n-\n-    public void operationComplete(ChannelFuture future) throws Exception {\n-        // If the client has stopped, there is no need to proceed with any\n-        // callback logic here.\n-        if (client.hasStopped()) {\n-            future.getChannel().close();\n-            return;\n-        }\n-\n-        // Check if the connection to the server was done successfully.\n-        if (!future.isSuccess()) {\n-            logger.error(\"Error connecting to host: \" + host);\n-\n-            future.getChannel().close();\n-\n-            // If we were not able to connect to the host, it could be down.\n-            ByteString hostString = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(host));\n-            if (pubSubData.connectFailedServers != null && pubSubData.connectFailedServers.contains(hostString)) {\n-                // We've already tried to connect to this host before so just\n-                // invoke the operationFailed callback.\n-                logger.error(\"Error connecting to host more than once so just invoke the operationFailed callback!\");\n-                pubSubData.getCallback().operationFailed(pubSubData.context, new CouldNotConnectException(\n-                                                        \"Could not connect to host: \" + host));\n-            } else {\n-                logger.debug(\"Try to connect to server: {} again for pubSubData: {}\", host, pubSubData);\n-                // Keep track of this current server that we failed to connect\n-                // to but retry the request on the default server host/VIP.\n-                // The topic2Host mapping might need to be updated.\n-                if (pubSubData.connectFailedServers == null)\n-                    pubSubData.connectFailedServers = new LinkedList<ByteString>();\n-                pubSubData.connectFailedServers.add(hostString);\n-                client.doConnect(pubSubData, cfg.getDefaultServerHost());\n-            }\n-\n-            // Finished with failure logic so just return.\n-            return;\n-        }\n-\n-        // Now that we have connected successfully to the server, see what type\n-        // of PubSub request this was.\n-        logger.debug(\"Connection to host: {} was successful for pubSubData: {}\", host, pubSubData);\n-        if (pubSubData.operationType.equals(OperationType.PUBLISH)) {\n-            // Publish Request so store this Channel connection in the\n-            // HedwigPublisher Map (if it doesn't exist yet) and then\n-            // do the publish on the cached channel mapped to the host.\n-            // Note that due to race concurrency situations, it is\n-            // possible that the cached channel is not the same one\n-            // as the channel established here. If that is the case,\n-            // this channel will be closed but we'll always publish on the\n-            // cached channel in the HedwigPublisher.host2Channel map.\n-            pub.storeHost2ChannelMapping(future.getChannel());\n-            pub.doPublish(pubSubData, pub.host2Channel.get(HedwigClientImpl.getHostFromChannel(future.getChannel())));\n-        } else if (pubSubData.operationType.equals(OperationType.UNSUBSCRIBE)) {\n-            // Unsubscribe Request so store this Channel connection in the\n-            // HedwigPublisher Map (if it doesn't exist yet) and then do the\n-            // unsubscribe. Unsubscribe requests will share and reuse\n-            // the netty Channel connections that Publish requests use.\n-            pub.storeHost2ChannelMapping(future.getChannel());\n-            sub.doSubUnsub(pubSubData, pub.host2Channel.get(HedwigClientImpl.getHostFromChannel(future.getChannel())));\n-        } else {\n-            // Subscribe Request. We do not store the Channel connection yet for\n-            // Subscribes here. This will be done only when we've found the\n-            // right server topic master. That is only determined when we\n-            // receive a successful server ack response to the Subscribe\n-            // request (handled in ResponseHandler). There is no need to store\n-            // the Unsubscribe channel connection as we won't use it again.\n-            sub.doSubUnsub(pubSubData, future.getChannel());\n-        }\n-    }\n-\n-}"},{"sha":"94e0a808e7858020c4d0f3692126b7590bc169bb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/FilterableMessageHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -27,7 +27,7 @@\n /**\n  * Handlers used by a subscription.\n  */\n-class FilterableMessageHandler implements MessageHandler {\n+public class FilterableMessageHandler implements MessageHandler {\n \n     MessageHandler msgHandler;\n     ClientMessageFilter  msgFilter;"},{"sha":"340cec57553513c96524c12f7f2826648107581e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannel.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import org.jboss.netty.channel.Channel;\n+import org.apache.hedwig.client.data.PubSubData;\n+\n+/**\n+ * A wrapper interface over netty {@link Channel} to submit hedwig's\n+ * {@link PubSubData} requests.\n+ */\n+public interface HChannel {\n+\n+    /**\n+     * Submit a pub/sub request.\n+     *\n+     * @param op\n+     *          Pub/Sub Request.\n+     */\n+    public void submitOp(PubSubData op);\n+\n+    /**\n+     * @return underlying netty channel\n+     */\n+    public Channel getChannel();\n+\n+    /**\n+     * Close the channel without waiting.\n+     */\n+    public void close();\n+\n+    /**\n+     * Close the channel\n+     *\n+     * @param wait\n+     *          Whether wait until the channel is closed.\n+     */\n+    public void close(boolean wait);\n+}"},{"sha":"6fae6bb2588d6d6b666df72793c3628c16fba38e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HChannelManager.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.net.InetSocketAddress;\n+import java.util.TimerTask;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+\n+/**\n+ * A manager manages 1) all channels established to hub servers,\n+ * 2) the actions taken by the topic subscribers.\n+ */\n+public interface HChannelManager {\n+\n+    /**\n+     * Submit a pub/sub request after a given <code>delay</code>.\n+     *\n+     * @param op\n+     *          Pub/Sub Request.\n+     * @param delay\n+     *          Delay time in ms.\n+     */\n+    public void submitOpAfterDelay(PubSubData op, long delay);\n+\n+    /**\n+     * Submit a pub/sub request.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Request.\n+     */\n+    public void submitOp(PubSubData pubSubData);\n+\n+    /**\n+     * Submit a pub/sub request to default server.\n+     *\n+     * @param pubSubData\n+     *           Pub/Sub request.\n+     */\n+    public void submitOpToDefaultServer(PubSubData pubSubData);\n+\n+    /**\n+     * Submit a pub/sub request to a given host.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub request.\n+     * @param host\n+     *          Given host address.\n+     */\n+    public void redirectToHost(PubSubData pubSubData, InetSocketAddress host);\n+\n+    /**\n+     * Generate next transaction id for pub/sub request sending thru this manager.\n+     *\n+     * @return next transaction id.\n+     */\n+    public long nextTxnId();\n+\n+    /**\n+     * Schedule a timer task after a given <code>delay</code>.\n+     *\n+     * @param task\n+     *          A timer task\n+     * @param delay\n+     *          Delay time in ms.\n+     */\n+    public void schedule(TimerTask task, long delay);\n+\n+    /**\n+     * Get the subscribe response handler managed the given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @return subscribe response handler managed it, otherwise return null.\n+     */\n+    public SubscribeResponseHandler getSubscribeResponseHandler(\n+                                    TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Start delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @param messageHandler\n+     *            MessageHandler to register for this ResponseHandler instance.\n+     * @throws ClientNotSubscribedException\n+     *            If the client is not currently subscribed to the topic\n+     * @throws AlreadyStartDeliveryException\n+     *            If someone started delivery a message handler before stopping existed one.\n+     */\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException;\n+\n+    /**\n+     * Stop delivering messages for a given topic subscriber.\n+     *\n+     * @param topicSubscriber\n+     *            Topic Subscriber\n+     * @throws ClientNotSubscribedException\n+     *             If the client is not currently subscribed to the topic\n+     */\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException;\n+\n+    /**\n+     * Close the subscription of the given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @param callback\n+     *          Callback\n+     * @param context\n+     *          Callback context\n+     */\n+    public void asyncCloseSubscription(TopicSubscriber topicSubscriber,\n+                                       Callback<ResponseBody> callback,\n+                                       Object context);\n+\n+    /**\n+     * Return the subscription event emitter to emit subscription events.\n+     *\n+     * @return subscription event emitter.\n+     */\n+    public SubscriptionEventEmitter getSubscriptionEventEmitter();\n+\n+    /**\n+     * Is the channel manager closed.\n+     *\n+     * @return true if the channel manager is closed, otherwise return false.\n+     */\n+    public boolean isClosed();\n+\n+    /**\n+     * Close the channel manager.\n+     */\n+    public void close();\n+}"},{"sha":"1724e0409526d93920b702c62bbe5d73e12ae04e","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"modified","additions":13,"deletions":309,"changes":322,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,33 +17,18 @@\n  */\n package org.apache.hedwig.client.netty;\n \n-import java.net.InetSocketAddress;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.atomic.AtomicLong;\n \n-import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.bootstrap.ClientBootstrap;\n-import org.jboss.netty.channel.Channel;\n import org.jboss.netty.channel.ChannelFactory;\n-import org.jboss.netty.channel.ChannelFuture;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n import com.google.protobuf.ByteString;\n \n-import org.apache.bookkeeper.util.MathUtils;\n import org.apache.hedwig.client.api.Client;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.client.handlers.MessageConsumeCallback;\n-import org.apache.hedwig.client.ssl.SslClientContextFactory;\n-import org.apache.hedwig.exceptions.PubSubException.UncertainStateException;\n+import org.apache.hedwig.client.netty.impl.simple.SimpleHChannelManager;\n \n /**\n  * This is a top level Hedwig Client class that encapsulates the common\n@@ -54,49 +39,18 @@\n \n     private static final Logger logger = LoggerFactory.getLogger(HedwigClientImpl.class);\n \n-    // Empty Topic List\n-    private ConcurrentLinkedQueue<ByteString> EMPTY_TOPIC_LIST =\n-        new ConcurrentLinkedQueue<ByteString>();\n-\n-    // Global counter used for generating unique transaction ID's for\n-    // publish and subscribe requests\n-    protected final AtomicLong globalCounter = new AtomicLong();\n-    // Static String constants\n-    protected static final String COLON = \":\";\n-\n     // The Netty socket factory for making connections to the server.\n     protected final ChannelFactory socketFactory;\n     // Whether the socket factory is one we created or is owned by whoever\n     // instantiated us.\n     protected boolean ownChannelFactory = false;\n \n-    // PipelineFactory to create netty client channels to the appropriate server\n-    private ClientChannelPipelineFactory pipelineFactory;\n-\n-    // Concurrent Map to store the mapping from the Topic to the Host.\n-    // This could change over time since servers can drop mastership of topics\n-    // for load balancing or failover. If a server host ever goes down, we'd\n-    // also want to remove all topic mappings the host was responsible for.\n-    // The second Map is used as the inverted version of the first one.\n-    protected final ConcurrentMap<ByteString, InetSocketAddress> topic2Host = new ConcurrentHashMap<ByteString, InetSocketAddress>();\n-    private final ConcurrentMap<InetSocketAddress, ConcurrentLinkedQueue<ByteString>> host2Topics =\n-        new ConcurrentHashMap<InetSocketAddress, ConcurrentLinkedQueue<ByteString>>();\n-\n-    // Each client instantiation will have a Timer for running recurring\n-    // threads. One such timer task thread to is to timeout long running\n-    // PubSubRequests that are waiting for an ack response from the server.\n-    private final Timer clientTimer = new Timer(true);\n-\n-    // Boolean indicating if the client is running or has stopped.\n-    // Once we stop the client, we should sidestep all of the connect,\n-    // write callback and channel disconnected logic.\n-    private boolean isStopped = false;\n+    // channel manager manages all the channels established by the client\n+    protected final HChannelManager channelManager;\n \n     private HedwigSubscriber sub;\n     private final HedwigPublisher pub;\n     private final ClientConfiguration cfg;\n-    private final MessageConsumeCallback consumeCb;\n-    private SslClientContextFactory sslFactory = null;\n \n     public static Client create(ClientConfiguration cfg) {\n         return new HedwigClientImpl(cfg);\n@@ -109,7 +63,8 @@ public static Client create(ClientConfiguration cfg, ChannelFactory socketFactor\n     // Base constructor that takes in a Configuration object.\n     // This will create its own client socket channel factory.\n     protected HedwigClientImpl(ClientConfiguration cfg) {\n-        this(cfg, new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n+        this(cfg, new NioClientSocketChannelFactory(\n+                  Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));\n         ownChannelFactory = true;\n     }\n \n@@ -118,23 +73,20 @@ protected HedwigClientImpl(ClientConfiguration cfg) {\n     protected HedwigClientImpl(ClientConfiguration cfg, ChannelFactory socketFactory) {\n         this.cfg = cfg;\n         this.socketFactory = socketFactory;\n+        channelManager = new SimpleHChannelManager(cfg, socketFactory);\n+\n         pub = new HedwigPublisher(this);\n         sub = new HedwigSubscriber(this);\n-        pipelineFactory = new ClientChannelPipelineFactory(this);\n-        consumeCb = new MessageConsumeCallback(this);\n-        if (cfg.isSSLEnabled()) {\n-            sslFactory = new SslClientContextFactory(cfg);\n-        }\n-        // Schedule all of the client timer tasks. Currently we only have the\n-        // Request Timeout task.\n-        clientTimer.schedule(new PubSubRequestTimeoutTask(), 0, cfg.getTimeoutThreadRunInterval());\n     }\n \n-    // Public getters for the various components of a client.\n     public ClientConfiguration getConfiguration() {\n         return cfg;\n     }\n \n+    public HChannelManager getHChannelManager() {\n+        return channelManager;\n+    }\n+\n     public HedwigSubscriber getSubscriber() {\n         return sub;\n     }\n@@ -149,96 +101,14 @@ public HedwigPublisher getPublisher() {\n         return pub;\n     }\n \n-    public MessageConsumeCallback getConsumeCallback() {\n-        return consumeCb;\n-    }\n-\n-    public SslClientContextFactory getSslFactory() {\n-        return sslFactory;\n-    }\n-\n-    // We need to deal with the possible problem of a PubSub request being\n-    // written to successfully to the server host but for some reason, the\n-    // ack message back never comes. What could happen is that the VoidCallback\n-    // stored in the ResponseHandler.txn2PublishData map will never be called.\n-    // We should have a configured timeout so if that passes from the time a\n-    // write was successfully done to the server, we can fail this async PubSub\n-    // transaction. The caller could possibly redo the transaction if needed at\n-    // a later time. Creating a timeout cleaner TimerTask to do this here.\n-    class PubSubRequestTimeoutTask extends TimerTask {\n-        /**\n-         * Implement the TimerTask's abstract run method.\n-         */\n-        @Override\n-        public void run() {\n-            logger.debug(\"Running the PubSubRequest Timeout Task\");\n-            // Loop through all outstanding PubSubData requests and check if\n-            // the requestWriteTime has timed out compared to the current time.\n-            long curTime = MathUtils.now();\n-            long timeoutInterval = cfg.getServerAckResponseTimeout();\n-\n-            // First check the ResponseHandlers associated with cached\n-            // channels in HedwigPublisher.host2Channel. This stores the\n-            // channels used for Publish and Unsubscribe requests.\n-            for (Channel channel : pub.host2Channel.values()) {\n-                ResponseHandler responseHandler = null;\n-                try {\n-                    responseHandler = getResponseHandlerFromChannel(channel);\n-                } catch (NoResponseHandlerException e) {\n-                    logger.warn(\"No response handler found for channel\" + channel + \" in the retry timeout task.\", e);\n-                    continue;\n-                }\n-                for (PubSubData pubSubData : responseHandler.txn2PubSubData.values()) {\n-                    checkPubSubDataToTimeOut(pubSubData, responseHandler, curTime, timeoutInterval);\n-                }\n-            }\n-            // Now do the same for the cached channels in\n-            // HedwigSubscriber.topicSubscriber2Channel. This stores the\n-            // channels used exclusively for Subscribe requests.\n-            for (Channel channel : sub.topicSubscriber2Channel.values()) {\n-                ResponseHandler responseHandler = null;\n-                try {\n-                    responseHandler = getResponseHandlerFromChannel(channel);\n-                } catch (NoResponseHandlerException e) {\n-                    logger.warn(\"No response handler found for channel\" + channel + \" in the retry timeout task.\", e);\n-                    continue;\n-                }\n-                for (PubSubData pubSubData : responseHandler.txn2PubSubData.values()) {\n-                    checkPubSubDataToTimeOut(pubSubData, responseHandler, curTime, timeoutInterval);\n-                }\n-            }\n-        }\n-\n-        private void checkPubSubDataToTimeOut(PubSubData pubSubData, ResponseHandler responseHandler, long curTime,\n-                                              long timeoutInterval) {\n-            if (curTime > pubSubData.requestWriteTime + timeoutInterval) {\n-                // Current PubSubRequest has timed out so remove it from the\n-                // ResponseHandler's map and invoke the VoidCallback's\n-                // operationFailed method.\n-                logger.error(\"Current PubSubRequest has timed out for pubSubData: \" + pubSubData);\n-                responseHandler.txn2PubSubData.remove(pubSubData.txnId);\n-                pubSubData.getCallback().operationFailed(pubSubData.context,\n-                    new UncertainStateException(\"Server ack response never received so PubSubRequest has timed out!\"));\n-            }\n-        }\n-    }\n-\n     // When we are done with the client, this is a clean way to gracefully close\n     // all channels/sockets created by the client and to also release all\n     // resources used by netty.\n     public void close() {\n         logger.info(\"Stopping the client!\");\n-        // Set the client boolean flag to indicate the client has stopped.\n-        isStopped = true;\n-        // Stop the timer and all timer task threads.\n-        clientTimer.cancel();\n-\n-        pub.close();\n-        sub.close();\n \n-        // Clear out all Maps.\n-        topic2Host.clear();\n-        host2Topics.clear();\n+        // close channel manager to release all channels\n+        channelManager.close(); \n \n         // Release resources used by the ChannelFactory on the client if we are\n         // the owner that created it.\n@@ -248,170 +118,4 @@ public void close() {\n         logger.info(\"Completed stopping the client!\");\n     }\n \n-    /**\n-     * This is a helper method to do the connect attempt to the server given the\n-     * inputted host/port. This can be used to connect to the default server\n-     * host/port which is the VIP. That will pick a server in the cluster at\n-     * random to connect to for the initial PubSub attempt (with redirect logic\n-     * being done at the server side). Additionally, this could be called after\n-     * the client makes an initial PubSub attempt at a server, and is redirected\n-     * to the one that is responsible for the topic. Once the connect to the\n-     * server is done, we will perform the corresponding PubSub write on that\n-     * channel.\n-     *\n-     * @param pubSubData\n-     *            PubSub call's data wrapper object\n-     * @param serverHost\n-     *            Input server host to connect to of type InetSocketAddress\n-     */\n-    public void doConnect(PubSubData pubSubData, InetSocketAddress serverHost) {\n-        logger.debug(\"Connecting to host: {} with pubSubData: {}\", serverHost, pubSubData);\n-        // Set up the ClientBootStrap so we can create a new Channel connection\n-        // to the server.\n-        ClientBootstrap bootstrap = new ClientBootstrap(socketFactory);\n-        bootstrap.setPipelineFactory(pipelineFactory);\n-        bootstrap.setOption(\"tcpNoDelay\", true);\n-        bootstrap.setOption(\"keepAlive\", true);\n-\n-        // Start the connection attempt to the input server host.\n-        ChannelFuture future = bootstrap.connect(serverHost);\n-        future.addListener(new ConnectCallback(pubSubData, serverHost, this));\n-    }\n-\n-    /**\n-     * Helper method to store the topic2Host mapping in the HedwigClient cache\n-     * map. This method is assumed to be called when we've done a successful\n-     * connection to the correct server topic master.\n-     *\n-     * @param pubSubData\n-     *            PubSub wrapper data\n-     * @param channel\n-     *            Netty Channel\n-     */\n-    protected void storeTopic2HostMapping(PubSubData pubSubData, Channel channel) {\n-        // Retrieve the server host that we've connected to and store the\n-        // mapping from the topic to this host. For all other non-redirected\n-        // server statuses, we consider that as a successful connection to the\n-        // correct topic master.\n-        InetSocketAddress host = getHostFromChannel(channel);\n-        InetSocketAddress existingHost = topic2Host.get(pubSubData.topic);\n-        if (existingHost != null && existingHost.equals(host)) {\n-            // Entry in map exists for the topic but it is the same as the\n-            // current host. In this case there is nothing to do.\n-            return;\n-        }\n-\n-        // Store the relevant mappings for this topic and host combination.\n-        if (topic2Host.putIfAbsent(pubSubData.topic, host) == null) {\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Stored info for topic: \" + pubSubData.topic.toStringUtf8() + \", old host: \"\n-                            + existingHost + \", new host: \" + host);\n-            ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n-            if (topicsForHost == null) {\n-                ConcurrentLinkedQueue<ByteString> newTopicsList = new ConcurrentLinkedQueue<ByteString>();\n-                topicsForHost = host2Topics.putIfAbsent(host, newTopicsList);\n-                if (topicsForHost == null) {\n-                  topicsForHost = newTopicsList;\n-                }\n-            }\n-            topicsForHost.add(pubSubData.topic);\n-        }\n-    }\n-\n-    /**\n-     * Helper static method to get the String Hostname:Port from a netty\n-     * Channel. Assumption is that the netty Channel was originally created with\n-     * an InetSocketAddress. This is true with the Hedwig netty implementation.\n-     *\n-     * @param channel\n-     *            Netty channel to extract the hostname and port from.\n-     * @return String representation of the Hostname:Port from the Netty Channel\n-     */\n-    public static InetSocketAddress getHostFromChannel(Channel channel) {\n-        return (InetSocketAddress) channel.getRemoteAddress();\n-    }\n-\n-    /**\n-     * Helper static method to get the ResponseHandler instance from a Channel\n-     * via the ChannelPipeline it is associated with. The assumption is that the\n-     * last ChannelHandler tied to the ChannelPipeline is the ResponseHandler.\n-     *\n-     * @param channel\n-     *            Channel we are retrieving the ResponseHandler instance for\n-     * @return ResponseHandler Instance tied to the Channel's Pipeline\n-     * @throws NoResponseHandlerException if the response handler found for the channel is null.\n-     */\n-    public static ResponseHandler getResponseHandlerFromChannel(Channel channel) throws NoResponseHandlerException {\n-        if (null == channel) {\n-            throw new NoResponseHandlerException(\"Received a null value for the channel. Cannot retrieve the response handler\");\n-        }\n-        ResponseHandler handler = (ResponseHandler) channel.getPipeline().getLast();\n-        if (null == handler) {\n-            throw new NoResponseHandlerException(\"Could not retrieve the response handler from the channel's pipeline.\");\n-        }\n-        return handler;\n-    }\n-\n-    // Public getter for entries in the topic2Host Map.\n-    public InetSocketAddress getHostForTopic(ByteString topic) {\n-        return topic2Host.get(topic);\n-    }\n-\n-    // If a server host goes down or the channel to it gets disconnected,\n-    // we want to clear out all relevant cached information. We'll\n-    // need to remove all of the topic mappings that the host was\n-    // responsible for.\n-    public void clearAllTopicsForHost(InetSocketAddress host) {\n-        logger.debug(\"Clearing all topics for host: {}\", host);\n-        // For each of the topics that the host was responsible for,\n-        // remove it from the topic2Host mapping.\n-        ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n-        if (topicsForHost != null) {\n-            for (ByteString topic : topicsForHost) {\n-                if (logger.isDebugEnabled())\n-                    logger.debug(\"Removing mapping for topic: \" + topic.toStringUtf8() + \" from host: \" + host);\n-                topic2Host.remove(topic, host);\n-            }\n-            // Now it is safe to remove the host2Topics mapping entry.\n-            host2Topics.remove(host, topicsForHost);\n-        }\n-    }\n-\n-    // If a subscribe channel goes down, the topic might have moved.\n-    // We only clear out that topic for the host and not all cached information.\n-    public void clearHostForTopic(ByteString topic, InetSocketAddress host) {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Clearing topic: \" + topic.toStringUtf8() + \" for host: \"\n-                    + host);\n-        }\n-        if (topic2Host.remove(topic, host)) {\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Removed topic to host mapping for topic: \" + topic.toStringUtf8()\n-                           + \" and host: \" + host);\n-            }\n-        }\n-        ConcurrentLinkedQueue<ByteString> topicsForHost = host2Topics.get(host);\n-        if (null != topicsForHost && topicsForHost.remove(topic)) {\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Removed topic: \" + topic.toStringUtf8() + \" from host: \" + host);\n-            }\n-            if (topicsForHost.isEmpty()) {\n-                // remove only topic list is empty\n-                host2Topics.remove(host, EMPTY_TOPIC_LIST);\n-            }\n-        }\n-    }\n-\n-    // Public getter to see if the client has been stopped.\n-    public boolean hasStopped() {\n-        return isStopped;\n-    }\n-\n-    // Public getter to get the client's Timer object.\n-    // This is so we can reuse this and not have to create multiple Timer\n-    // objects.\n-    public Timer getClientTimer() {\n-        return clientTimer;\n-    }\n-\n }"},{"sha":"5611bdd0c6e5f6871ec1fd6c751f6b16761aa2e6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"modified","additions":39,"deletions":189,"changes":228,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,32 +17,21 @@\n  */\n package org.apache.hedwig.client.netty;\n \n-import java.net.InetSocketAddress;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFuture;\n \n import com.google.protobuf.ByteString;\n \n-import org.apache.bookkeeper.util.MathUtils;\n import org.apache.hedwig.client.api.Publisher;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.PubSubData;\n import org.apache.hedwig.client.handlers.PubSubCallback;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n-import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n-import org.apache.hedwig.protocol.PubSubProtocol.PublishRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PublishResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.util.Callback;\n \n /**\n@@ -53,27 +42,19 @@\n \n     private static Logger logger = LoggerFactory.getLogger(HedwigPublisher.class);\n \n-    // Concurrent Map to store the mappings for a given Host (Hostname:Port) to\n-    // the Channel that has been established for it previously. This channel\n-    // will be used whenever we publish on a topic that the server is the master\n-    // of currently. The channels used here will only be used for publish and\n-    // unsubscribe requests.\n-    protected final ConcurrentMap<InetSocketAddress, Channel> host2Channel = new ConcurrentHashMap<InetSocketAddress, Channel>();\n-\n-    private final HedwigClientImpl client;\n-    private final ClientConfiguration cfg;\n-    private boolean closed = false;\n+    private final HChannelManager channelManager;\n \n     protected HedwigPublisher(HedwigClientImpl client) {\n-        this.client = client;\n-        this.cfg = client.getConfiguration();\n+        this.channelManager = client.getHChannelManager();\n     }\n \n-    public PubSubProtocol.PublishResponse publish(ByteString topic, Message msg)\n+    public PublishResponse publish(ByteString topic, Message msg)\n         throws CouldNotConnectException, ServiceDownException {\n \n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Calling a sync publish for topic: \" + topic.toStringUtf8() + \", msg: \" + msg);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Calling a sync publish for topic: {}, msg: {}.\",\n+                         topic.toStringUtf8(), msg);\n+        }\n         PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null, null, null);\n         synchronized (pubSubData) {\n             PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n@@ -105,192 +86,61 @@ else if (failureException instanceof CouldNotConnectException) {\n                 } else {\n                     // For other types of PubSubExceptions, just throw a generic\n                     // ServiceDownException but log a warning message.\n-                    logger.error(\"Unexpected exception type when a sync publish operation failed: \" + failureException);\n+                    logger.error(\"Unexpected exception type when a sync publish operation failed: \",\n+                                 failureException);\n                     throw new ServiceDownException(\"Server ack response to publish request is not successful\");\n                 }\n             }\n \n-            PubSubProtocol.ResponseBody respBody = pubSubCallback.getResponseBody();\n-            if (null == respBody) return null;\n+            ResponseBody respBody = pubSubCallback.getResponseBody();\n+            if (null == respBody) {\n+                return null;\n+            }\n             return respBody.hasPublishResponse() ? respBody.getPublishResponse() : null;\n         }\n     }\n \n-    public void asyncPublish(ByteString topic, Message msg, final Callback<Void> callback, Object context) {\n+    public void asyncPublish(ByteString topic, Message msg,\n+                             final Callback<Void> callback, Object context) {\n         asyncPublishWithResponseImpl(topic, msg,\n-            new VoidCallbackAdapter<PubSubProtocol.ResponseBody>(callback), context);\n+                                     new VoidCallbackAdapter<ResponseBody>(callback), context);\n     }\n \n     public void asyncPublishWithResponse(ByteString topic, Message msg,\n-                                         Callback<PubSubProtocol.PublishResponse> _callback, Object context) {\n+                                         Callback<PublishResponse> callback,\n+                                         Object context) {\n         // adapt the callback.\n-        asyncPublishWithResponseImpl(topic, msg, new PublishResponseCallbackAdapter(_callback), context);\n+        asyncPublishWithResponseImpl(topic, msg,\n+                                     new PublishResponseCallbackAdapter(callback), context);\n     }\n \n     private void asyncPublishWithResponseImpl(ByteString topic, Message msg,\n-                                              Callback<PubSubProtocol.ResponseBody> callback, Object context) {\n-\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Calling an async publish for topic: \" + topic.toStringUtf8() + \", msg: \" + msg);\n-        // Check if we already have a Channel connection set up to the server\n-        // for the given Topic.\n-        PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null, callback, context);\n-        InetSocketAddress host = client.topic2Host.get(topic);\n-        if (host != null) {\n-            Channel channel = host2Channel.get(host);\n-            if (channel != null) {\n-                // We already have the Channel connection for the server host so\n-                // do the publish directly. We will deal with redirect logic\n-                // later on if that server is no longer the current host for\n-                // the topic.\n-                doPublish(pubSubData, channel);\n-            } else {\n-                // We have a mapping for the topic to host but don't have a\n-                // Channel for that server. This can happen if the Channel\n-                // is disconnected for some reason. Do the connect then to\n-                // the specified server host to create a new Channel connection.\n-                client.doConnect(pubSubData, host);\n-            }\n-        } else {\n-            // Server host for the given topic is not known yet so use the\n-            // default server host/port as defined in the configs. This should\n-            // point to the server VIP which would redirect to a random server\n-            // (which might not be the server hosting the topic).\n-            host = cfg.getDefaultServerHost();\n-            Channel channel = host2Channel.get(host);\n-            if (channel != null) {\n-                // if there is a channel to default server, use it!\n-                doPublish(pubSubData, channel);\n-                return;\n-            }\n-            client.doConnect(pubSubData, host);\n-        }\n-    }\n-\n-    /**\n-     * This is a helper method to write the actual publish message once the\n-     * client is connected to the server and a Channel is available.\n-     *\n-     * @param pubSubData\n-     *            Publish call's data wrapper object\n-     * @param channel\n-     *            Netty I/O channel for communication between the client and\n-     *            server\n-     */\n-    protected void doPublish(PubSubData pubSubData, Channel channel) {\n-        // Create a PubSubRequest\n-        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n-        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n-        pubsubRequestBuilder.setType(OperationType.PUBLISH);\n-        if (pubSubData.triedServers != null && pubSubData.triedServers.size() > 0) {\n-            pubsubRequestBuilder.addAllTriedServers(pubSubData.triedServers);\n-        }\n-        long txnId = client.globalCounter.incrementAndGet();\n-        pubsubRequestBuilder.setTxnId(txnId);\n-        pubsubRequestBuilder.setShouldClaim(pubSubData.shouldClaim);\n-        pubsubRequestBuilder.setTopic(pubSubData.topic);\n-\n-        // Now create the PublishRequest\n-        PublishRequest.Builder publishRequestBuilder = PublishRequest.newBuilder();\n-\n-        publishRequestBuilder.setMsg(pubSubData.msg);\n-\n-        // Set the PublishRequest into the outer PubSubRequest\n-        pubsubRequestBuilder.setPublishRequest(publishRequestBuilder);\n-\n-        // Update the PubSubData with the txnId and the requestWriteTime\n-        pubSubData.txnId = txnId;\n-        pubSubData.requestWriteTime = MathUtils.now();\n-\n-        // Before we do the write, store this information into the\n-        // ResponseHandler so when the server responds, we know what\n-        // appropriate Callback Data to invoke for the given txn ID.\n-        try {\n-            HedwigClientImpl.getResponseHandlerFromChannel(channel).txn2PubSubData.put(txnId, pubSubData);\n-        } catch (NoResponseHandlerException e) {\n-            logger.error(\"No response handler found while storing the publish callback.\");\n-            // Callback on pubsubdata indicating failure.\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new CouldNotConnectException(\"No response \" +\n-                    \"handler found while attempting to publish. So could not connect.\"));\n-            return;\n+                                              Callback<ResponseBody> callback,\n+                                              Object context) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Calling an async publish for topic: {}, msg: {}.\",\n+                         topic.toStringUtf8(), msg);\n         }\n-\n-        // Finally, write the Publish request through the Channel.\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Writing a Publish request to host: \" + HedwigClientImpl.getHostFromChannel(channel)\n-                         + \" for pubSubData: \" + pubSubData);\n-        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n-        future.addListener(new WriteCallback(pubSubData, client));\n+        PubSubData pubSubData = new PubSubData(topic, msg, null, OperationType.PUBLISH, null,\n+                                               callback, context);\n+        channelManager.submitOp(pubSubData);\n     }\n \n-    // Synchronized method to store the host2Channel mapping (if it doesn't\n-    // exist yet). Retrieve the hostname info from the Channel created via the\n-    // RemoteAddress tied to it.\n-    protected synchronized void storeHost2ChannelMapping(Channel channel) {\n-        InetSocketAddress host = HedwigClientImpl.getHostFromChannel(channel);\n-        if (!closed && host2Channel.putIfAbsent(host, channel) == null) {\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Stored a new Channel mapping for host: \" + host);\n-        } else {\n-            // If we've reached here, that means we already have a Channel\n-            // mapping for the given host. This should ideally not happen\n-            // and it means we are creating another Channel to a server host\n-            // to publish on when we could have used an existing one. This could\n-            // happen due to a race condition if initially multiple concurrent\n-            // threads are publishing on the same topic and no Channel exists\n-            // currently to the server. We are not synchronizing this initial\n-            // creation of Channels to a given host for performance.\n-            // Another possible way to have redundant Channels created is if\n-            // a new topic is being published to, we connect to the default\n-            // server host which should be a VIP that redirects to a \"real\"\n-            // server host. Since we don't know beforehand what is the full\n-            // set of server hosts, we could be redirected to a server that\n-            // we already have a channel connection to from a prior existing\n-            // topic. Close these redundant channels as they won't be used.\n-            logger.debug(\"Channel mapping to host: {} already exists so no need to store it.\", host);\n-            try {\n-                HedwigClientImpl.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n-            } catch (NoResponseHandlerException e) {\n-                logger.error(\"Could not get response handler while closing channel.\");\n-            }\n-            channel.close();\n-        }\n-    }\n+    private static class PublishResponseCallbackAdapter implements Callback<ResponseBody>{\n \n-    // Public getter for entries in the host2Channel Map.\n-    // This is used for classes that need this information but are not in the\n-    // same classpath.\n-    public Channel getChannelForHost(InetSocketAddress host) {\n-        return host2Channel.get(host);\n-    }\n+        private final Callback<PublishResponse> delegate;\n \n-    void close() {\n-        synchronized(this) {\n-            closed = true;\n-        }\n-        for (Channel channel : host2Channel.values()) {\n-            try {\n-                client.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n-            } catch (NoResponseHandlerException e) {\n-                logger.error(\"No response handler while trying explicitly close Publisher channel \" + channel);\n-            }\n-            channel.close().awaitUninterruptibly();\n-        }\n-        host2Channel.clear();\n-    }\n-\n-    private static class PublishResponseCallbackAdapter implements Callback<PubSubProtocol.ResponseBody>{\n-\n-        private final Callback<PubSubProtocol.PublishResponse> delegate;\n-\n-        private PublishResponseCallbackAdapter(Callback<PubSubProtocol.PublishResponse> delegate) {\n+        private PublishResponseCallbackAdapter(Callback<PublishResponse> delegate) {\n             this.delegate = delegate;\n         }\n \n         @Override\n-        public void operationFinished(Object ctx, PubSubProtocol.ResponseBody resultOfOperation) {\n-            if (null == resultOfOperation) delegate.operationFinished(ctx, null);\n-            else delegate.operationFinished(ctx, resultOfOperation.getPublishResponse());\n+        public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n+            if (null == resultOfOperation) {\n+                delegate.operationFinished(ctx, null);\n+            } else {\n+                delegate.operationFinished(ctx, resultOfOperation.getPublishResponse());\n+            }\n         }\n \n         @Override"},{"sha":"1f78897da66a668e3b32ee0ceb3f13b54ee03976","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":73,"deletions":489,"changes":562,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -17,25 +17,13 @@\n  */\n package org.apache.hedwig.client.netty;\n \n-import java.net.InetSocketAddress;\n-import java.util.Collections;\n import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n \n-import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n-import org.apache.hedwig.protocol.PubSubProtocol;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFuture;\n-import org.jboss.netty.channel.ChannelFutureListener;\n \n import com.google.protobuf.ByteString;\n \n-import org.apache.bookkeeper.util.MathUtils;\n import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.api.Subscriber;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n@@ -44,22 +32,17 @@\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n import org.apache.hedwig.client.exceptions.InvalidSubscriberIdException;\n import org.apache.hedwig.client.handlers.PubSubCallback;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n import org.apache.hedwig.filter.ClientMessageFilter;\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n-import org.apache.hedwig.protocol.PubSubProtocol.ConsumeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n-import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n-import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n@@ -73,46 +56,22 @@\n \n     private static Logger logger = LoggerFactory.getLogger(HedwigSubscriber.class);\n \n-    // Concurrent Map to store the cached Channel connections on the client side\n-    // to a server host for a given Topic + SubscriberId combination. For each\n-    // TopicSubscriber, we want a unique Channel connection to the server for\n-    // it. We can also get the ResponseHandler tied to the Channel via the\n-    // Channel Pipeline.\n-    protected final ConcurrentMap<TopicSubscriber, Channel> topicSubscriber2Channel = new ConcurrentHashMap<TopicSubscriber, Channel>();\n-    protected final ConcurrentMap<TopicSubscriber, SubscriptionPreferences> topicSubscriber2Preferences =\n-        new ConcurrentHashMap<TopicSubscriber, SubscriptionPreferences>();\n-\n-    // Concurrent Map to store Message handler for each topic + sub id combination.\n-    // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n-    // user set when connection is recovered\n-    protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler= new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n-\n-    protected final CopyOnWriteArraySet<SubscriptionListener> listeners;\n-\n-    protected final HedwigClientImpl client;\n     protected final ClientConfiguration cfg;\n-    private final Object closeLock = new Object();\n-    private boolean closed = false;\n+    protected final HChannelManager channelManager;\n \n     public HedwigSubscriber(HedwigClientImpl client) {\n-        this.client = client;\n         this.cfg = client.getConfiguration();\n-        this.listeners = new CopyOnWriteArraySet<SubscriptionListener>();\n+        this.channelManager = client.getHChannelManager();\n     }\n \n     public void addSubscriptionListener(SubscriptionListener listener) {\n-        listeners.add(listener); \n+        channelManager.getSubscriptionEventEmitter()\n+                      .addSubscriptionListener(listener);\n     }\n \n     public void removeSubscriptionListener(SubscriptionListener listener) {\n-        listeners.remove(listener);\n-    }\n-\n-    void emitSubscriptionEvent(ByteString topic, ByteString subscriberId,\n-                               SubscriptionEvent event) {\n-        for (SubscriptionListener listener : listeners) {\n-            listener.processEvent(topic, subscriberId, event);\n-        }\n+        channelManager.getSubscriptionEventEmitter()\n+                      .removeSubscriptionListener(listener);\n     }\n \n     // Private method that holds the common logic for doing synchronous\n@@ -167,7 +126,7 @@ else if (failureException instanceof ClientNotSubscribedException)\n                 else if (failureException instanceof ServiceDownException)\n                     throw (ServiceDownException) failureException;\n                 else {\n-                    logger.error(\"Unexpected PubSubException thrown: \" + failureException.toString());\n+                    logger.error(\"Unexpected PubSubException thrown: \", failureException);\n                     // Throw a generic ServiceDownException but wrap the\n                     // original PubSubException within it.\n                     throw new ServiceDownException(failureException);\n@@ -181,7 +140,7 @@ else if (failureException instanceof ServiceDownException)\n     // flows are very similar. The assumption is that the input OperationType is\n     // either SUBSCRIBE or UNSUBSCRIBE.\n     private void asyncSubUnsub(ByteString topic, ByteString subscriberId,\n-                               Callback<PubSubProtocol.ResponseBody> callback, Object context,\n+                               Callback<ResponseBody> callback, Object context,\n                                OperationType operationType, SubscriptionOptions options) {\n         if (logger.isDebugEnabled()) {\n             StringBuilder debugMsg = new StringBuilder().append(\"Calling a async subUnsub request for topic: \")\n@@ -194,41 +153,18 @@ private void asyncSubUnsub(ByteString topic, ByteString subscriberId,\n             }\n             logger.debug(debugMsg.toString());\n         }\n-        // Check if we know which server host is the master for the topic we are\n-        // subscribing to.\n-        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, options, callback,\n-                                               context);\n-\n-        InetSocketAddress host = client.topic2Host.get(topic);\n-        if (host != null) {\n-            Channel existingChannel = null;\n-            if (operationType.equals(OperationType.UNSUBSCRIBE) &&\n-                (existingChannel = client.getPublisher().host2Channel.get(host)) != null) {\n-                // For unsubscribes, we can reuse the channel connections to the\n-                // server host that are cached for publishes. For publish and\n-                // unsubscribe flows, we will thus use the same Channels and\n-                // will cache and store them during the ConnectCallback.\n-                doSubUnsub(pubSubData, existingChannel);\n-            } else {\n-                // We know which server host is the master for the topic so\n-                // connect to that first. For subscribes, we want a new channel\n-                // connection each time for the TopicSubscriber. If the\n-                // TopicSubscriber is already connected and subscribed,\n-                // we assume the server will respond with an appropriate status\n-                // indicating this. For unsubscribes, it is possible that the\n-                // client is subscribed to the topic already but does not\n-                // have a Channel connection yet to the server host. e.g. Client\n-                // goes down and comes back up but client side soft state memory\n-                // does not have the netty Channel connection anymore.\n-                client.doConnect(pubSubData, host);\n+        if (OperationType.SUBSCRIBE.equals(operationType)) {\n+            if (options.getMessageBound() <= 0 &&\n+                cfg.getSubscriptionMessageBound() > 0) {\n+                SubscriptionOptions.Builder soBuilder =\n+                    SubscriptionOptions.newBuilder(options).setMessageBound(\n+                        cfg.getSubscriptionMessageBound());\n+                options = soBuilder.build();\n             }\n-        } else {\n-            // Server host for the given topic is not known yet so use the\n-            // default server host/port as defined in the configs. This should\n-            // point to the server VIP which would redirect to a random server\n-            // (which might not be the server hosting the topic).\n-            client.doConnect(pubSubData, cfg.getDefaultServerHost());\n         }\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType,\n+                                               options, callback, context);\n+        channelManager.submitOp(pubSubData);\n     }\n \n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n@@ -256,7 +192,7 @@ protected void subscribe(ByteString topic, ByteString subscriberId, Subscription\n         try {\n             subUnsub(topic, subscriberId, OperationType.SUBSCRIBE, options);\n         } catch (ClientNotSubscribedException e) {\n-            logger.error(\"Unexpected Exception thrown: \" + e.toString());\n+            logger.error(\"Unexpected Exception thrown: \", e);\n             // This exception should never be thrown here. But just in case,\n             // throw a generic ServiceDownException but wrap the original\n             // Exception within it.\n@@ -285,8 +221,9 @@ protected void asyncSubscribe(ByteString topic, ByteString subscriberId,\n                                          \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n             return;\n         }\n-        asyncSubUnsub(topic, subscriberId, new VoidCallbackAdapter<PubSubProtocol.ResponseBody>(callback),\n-            context, OperationType.SUBSCRIBE, options);\n+        asyncSubUnsub(topic, subscriberId,\n+                      new VoidCallbackAdapter<ResponseBody>(callback), context,\n+                      OperationType.SUBSCRIBE, options);\n     }\n \n     public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n@@ -312,28 +249,30 @@ protected void unsubscribe(ByteString topic, ByteString subscriberId, boolean is\n         try {\n             subUnsub(topic, subscriberId, OperationType.UNSUBSCRIBE, null);\n         } catch (ClientAlreadySubscribedException e) {\n-            logger.error(\"Unexpected Exception thrown: \" + e.toString());\n+            logger.error(\"Unexpected Exception thrown: \", e);\n             // This exception should never be thrown here. But just in case,\n             // throw a generic ServiceDownException but wrap the original\n             // Exception within it.\n             throw new ServiceDownException(e);\n         }\n     }\n \n-    public void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId, final Callback<Void> callback,\n-                                 final Object context) {\n+    public void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n+                                 final Callback<Void> callback, final Object context) {\n         doAsyncUnsubscribe(topic, subscriberId,\n-            new VoidCallbackAdapter<PubSubProtocol.ResponseBody>(callback), context, false);\n+                           new VoidCallbackAdapter<ResponseBody>(callback),\n+                           context, false);\n     }\n \n     protected void asyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n                                     final Callback<Void> callback, final Object context, boolean isHub) {\n         doAsyncUnsubscribe(topic, subscriberId,\n-            new VoidCallbackAdapter<PubSubProtocol.ResponseBody>(callback), context, isHub);\n+                           new VoidCallbackAdapter<ResponseBody>(callback),\n+                           context, isHub);\n     }\n \n     private void doAsyncUnsubscribe(final ByteString topic, final ByteString subscriberId,\n-                                    final Callback<PubSubProtocol.ResponseBody> callback,\n+                                    final Callback<ResponseBody> callback,\n                                     final Object context, boolean isHub) {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n@@ -344,9 +283,9 @@ private void doAsyncUnsubscribe(final ByteString topic, final ByteString subscri\n         }\n         // Asynchronously close the subscription. On the callback to that\n         // operation once it completes, post the async unsubscribe request.\n-        doAsyncCloseSubscription(topic, subscriberId, new Callback<PubSubProtocol.ResponseBody>() {\n+        doAsyncCloseSubscription(topic, subscriberId, new Callback<ResponseBody>() {\n             @Override\n-            public void operationFinished(Object ctx, PubSubProtocol.ResponseBody resultOfOperation) {\n+            public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n                 asyncSubUnsub(topic, subscriberId, callback, context, OperationType.UNSUBSCRIBE, null);\n             }\n \n@@ -369,184 +308,22 @@ private boolean isValidSubscriberId(ByteString subscriberId, boolean isHub) {\n \n     public void consume(ByteString topic, ByteString subscriberId, MessageSeqId messageSeqId)\n             throws ClientNotSubscribedException {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Calling consume for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8() + \", messageSeqId: \" + messageSeqId);\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Calling consume for {}, messageSeqId: {}.\",\n+                     topicSubscriber, messageSeqId);\n+\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            channelManager.getSubscribeResponseHandler(topicSubscriber);\n         // Check that this topic subscription on the client side exists.\n-        Channel channel = topicSubscriber2Channel.get(topicSubscriber);\n-        if (channel == null) {\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n             throw new ClientNotSubscribedException(\n-                \"Cannot send consume message since client is not subscribed to topic: \" + topic.toStringUtf8()\n-                + \", subscriberId: \" + subscriberId.toStringUtf8());\n+                \"Cannot send consume message since client is not subscribed to topic: \"\n+                + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n         }\n-        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, OperationType.CONSUME, null, null, null);\n         // Send the consume message to the server using the same subscribe\n         // channel that the topic subscription uses.\n-        doConsume(pubSubData, channel, messageSeqId);\n-    }\n-\n-    /**\n-     * Convert client-side subscription options to subscription preferences\n-     *\n-     * @param options\n-     *          Client-Side subscription options\n-     */\n-    protected SubscriptionPreferences.Builder options2Preferences(SubscriptionOptions options) {\n-        // prepare subscription preferences\n-        SubscriptionPreferences.Builder preferencesBuilder = SubscriptionPreferences.newBuilder();\n-\n-        // set message bound\n-        if (options.getMessageBound() > 0) {\n-            preferencesBuilder.setMessageBound(options.getMessageBound());\n-        } else if (cfg.getSubscriptionMessageBound() > 0) {\n-            preferencesBuilder.setMessageBound(cfg.getSubscriptionMessageBound());\n-        }\n-\n-        // set message filter\n-        if (options.hasMessageFilter()) {\n-            preferencesBuilder.setMessageFilter(options.getMessageFilter());\n-        }\n-\n-        // set user options\n-        if (options.hasOptions()) {\n-            preferencesBuilder.setOptions(options.getOptions());\n-        }\n-\n-        return preferencesBuilder;\n-    }\n-\n-    /**\n-     * This is a helper method to write the actual subscribe/unsubscribe message\n-     * once the client is connected to the server and a Channel is available.\n-     *\n-     * @param pubSubData\n-     *            Subscribe/Unsubscribe call's data wrapper object. We assume\n-     *            that the operationType field is either SUBSCRIBE or\n-     *            UNSUBSCRIBE.\n-     * @param channel\n-     *            Netty I/O channel for communication between the client and\n-     *            server\n-     */\n-    protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n-        // Create a PubSubRequest\n-        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n-        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n-        pubsubRequestBuilder.setType(pubSubData.operationType);\n-        if (pubSubData.triedServers != null && pubSubData.triedServers.size() > 0) {\n-            pubsubRequestBuilder.addAllTriedServers(pubSubData.triedServers);\n-        }\n-        long txnId = client.globalCounter.incrementAndGet();\n-        pubsubRequestBuilder.setTxnId(txnId);\n-        pubsubRequestBuilder.setShouldClaim(pubSubData.shouldClaim);\n-        pubsubRequestBuilder.setTopic(pubSubData.topic);\n-\n-        // Create either the Subscribe or Unsubscribe Request\n-        if (pubSubData.operationType.equals(OperationType.SUBSCRIBE)) {\n-            // Create the SubscribeRequest\n-            SubscribeRequest.Builder subscribeRequestBuilder = SubscribeRequest.newBuilder();\n-            subscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n-            subscribeRequestBuilder.setCreateOrAttach(pubSubData.options.getCreateOrAttach());\n-            subscribeRequestBuilder.setForceAttach(pubSubData.options.getForceAttach());\n-            // For now, all subscribes should wait for all cross-regional\n-            // subscriptions to be established before returning.\n-            subscribeRequestBuilder.setSynchronous(true);\n-            // set subscription preferences\n-            SubscriptionPreferences.Builder preferencesBuilder =\n-                options2Preferences(pubSubData.options);\n-            // backward compatable with 4.1.0\n-            if (preferencesBuilder.hasMessageBound()) {\n-                subscribeRequestBuilder.setMessageBound(preferencesBuilder.getMessageBound());\n-            }\n-            subscribeRequestBuilder.setPreferences(preferencesBuilder);\n-\n-            // Set the SubscribeRequest into the outer PubSubRequest\n-            pubsubRequestBuilder.setSubscribeRequest(subscribeRequestBuilder);\n-        } else {\n-            // Create the UnSubscribeRequest\n-            UnsubscribeRequest.Builder unsubscribeRequestBuilder = UnsubscribeRequest.newBuilder();\n-            unsubscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n-\n-            // Set the UnsubscribeRequest into the outer PubSubRequest\n-            pubsubRequestBuilder.setUnsubscribeRequest(unsubscribeRequestBuilder);\n-        }\n-\n-        // Update the PubSubData with the txnId and the requestWriteTime\n-        pubSubData.txnId = txnId;\n-        pubSubData.requestWriteTime = MathUtils.now();\n-\n-        // Before we do the write, store this information into the\n-        // ResponseHandler so when the server responds, we know what\n-        // appropriate Callback Data to invoke for the given txn ID.\n-        try {\n-            HedwigClientImpl.getResponseHandlerFromChannel(channel).txn2PubSubData.put(txnId, pubSubData);\n-        } catch (Exception e) {\n-            logger.error(\"No response handler found while storing the subscribe callback.\");\n-            // Call operationFailed on the pubsubdata callback to indicate failure\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new CouldNotConnectException(\"No response \" +\n-                    \"handler found while attempting to subscribe.\"));\n-            return;\n-        }\n-\n-        // Finally, write the Subscribe request through the Channel.\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Writing a SubUnsub request to host: \" + HedwigClientImpl.getHostFromChannel(channel)\n-                         + \" for pubSubData: \" + pubSubData);\n-        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n-        future.addListener(new WriteCallback(pubSubData, client));\n-    }\n-\n-    /**\n-     * This is a helper method to write a consume message to the server after a\n-     * subscribe Channel connection is made to the server and messages are being\n-     * consumed by the client.\n-     *\n-     * @param pubSubData\n-     *            Consume call's data wrapper object. We assume that the\n-     *            operationType field is CONSUME.\n-     * @param channel\n-     *            Netty I/O channel for communication between the client and\n-     *            server\n-     * @param messageSeqId\n-     *            Message Seq ID for the latest/last message the client has\n-     *            consumed.\n-     */\n-    public void doConsume(final PubSubData pubSubData, final Channel channel, final MessageSeqId messageSeqId) {\n-        // Create a PubSubRequest\n-        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n-        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n-        pubsubRequestBuilder.setType(OperationType.CONSUME);\n-        long txnId = client.globalCounter.incrementAndGet();\n-        pubsubRequestBuilder.setTxnId(txnId);\n-        pubsubRequestBuilder.setTopic(pubSubData.topic);\n-\n-        // Create the ConsumeRequest\n-        ConsumeRequest.Builder consumeRequestBuilder = ConsumeRequest.newBuilder();\n-        consumeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n-        consumeRequestBuilder.setMsgId(messageSeqId);\n-\n-        // Set the ConsumeRequest into the outer PubSubRequest\n-        pubsubRequestBuilder.setConsumeRequest(consumeRequestBuilder);\n-\n-        // For Consume requests, we will send them from the client in a fire and\n-        // forget manner. We are not expecting the server to send back an ack\n-        // response so no need to register this in the ResponseHandler. There\n-        // are no callbacks to invoke since this isn't a client initiated\n-        // action. Instead, just have a future listener that will log an error\n-        // message if there was a problem writing the consume request.\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Writing a Consume request to host: \" + HedwigClientImpl.getHostFromChannel(channel)\n-                         + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);\n-        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (!future.isSuccess()) {\n-                    logger.error(\"Error writing a Consume request to host: \" + HedwigClientImpl.getHostFromChannel(channel)\n-                                 + \" with messageSeqId: \" + messageSeqId + \" for pubSubData: \" + pubSubData);\n-                }\n-            }\n-        });\n+        subscribeResponseHandler.consume(topicSubscriber, messageSeqId);\n     }\n \n     public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n@@ -559,7 +336,11 @@ public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws\n         // correct way to contact the server to get this info is then.\n         // The client side just has soft memory state for client subscription\n         // information.\n-        return topicSubscriber2Channel.containsKey(new TopicSubscriber(topic, subscriberId));\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            channelManager.getSubscribeResponseHandler(topicSubscriber);\n+        return !(null == subscribeResponseHandler ||\n+                 !subscribeResponseHandler.hasSubscription(topicSubscriber));\n     }\n \n     public List<ByteString> getSubscriptionList(ByteString subscriberId) throws CouldNotConnectException,\n@@ -569,157 +350,32 @@ public boolean hasSubscription(ByteString topic, ByteString subscriberId) throws\n         return null;\n     }\n \n-    public void startDelivery(final ByteString topic, final ByteString subscriberId, MessageHandler messageHandler)\n+    public void startDelivery(final ByteString topic, final ByteString subscriberId,\n+                              MessageHandler messageHandler)\n             throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n-        startDelivery(topic, subscriberId, messageHandler, false);\n+        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n+        logger.debug(\"Starting delivery for {}.\", topicSubscriber);\n+        channelManager.startDelivery(topicSubscriber, messageHandler); \n     }\n \n     public void startDeliveryWithFilter(final ByteString topic, final ByteString subscriberId,\n                                         MessageHandler messageHandler,\n                                         ClientMessageFilter messageFilter)\n             throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n         if (null == messageHandler || null == messageFilter) {\n-            throw new NullPointerException(\"Null message handler or message filter is provided.\");\n+            throw new NullPointerException(\"Null message handler or message filter is       provided.\");\n         }\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n-        SubscriptionPreferences preferences = topicSubscriber2Preferences.get(topicSubscriber);\n-        if (null == preferences) {\n-            throw new ClientNotSubscribedException(\"No subscription preferences found to filter messages for topic: \"\n-                    + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n-        }\n-        // pass subscription preferences to message filter\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Start delivering messages with filter on topic: \" + topic.toStringUtf8()\n-                         + \", subscriberId: \" + subscriberId.toStringUtf8() + \", preferences: \"\n-                         + SubscriptionStateUtils.toString(preferences));\n-        }\n-        messageFilter.setSubscriptionPreferences(topic, subscriberId, preferences);\n         messageHandler = new FilterableMessageHandler(messageHandler, messageFilter);\n-        startDelivery(topic, subscriberId, messageHandler, false);\n+        logger.debug(\"Starting delivery with filter for {}.\", topicSubscriber);\n+        channelManager.startDelivery(topicSubscriber, messageHandler);\n     }\n \n-    public void restartDelivery(final ByteString topic, final ByteString subscriberId)\n-        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n-        startDelivery(topic, subscriberId, null, true);\n-    }\n-\n-    private void startDelivery(final ByteString topic, final ByteString subscriberId,\n-                               MessageHandler messageHandler, boolean restart)\n-        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Starting delivery for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8());\n+    public void stopDelivery(final ByteString topic, final ByteString subscriberId)\n+    throws ClientNotSubscribedException {\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n-        // Make sure we know about this topic subscription on the client side\n-        // exists. The assumption is that the client should have in memory the\n-        // Channel created for the TopicSubscriber once the server has sent\n-        // an ack response to the initial subscribe request.\n-        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n-        if (topicSubscriberChannel == null) {\n-            logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8());\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n-                                                   + \", subscriberId: \" + subscriberId.toStringUtf8());\n-        }\n-\n-        // Need to ensure the setting of handler and the readability of channel is in sync\n-        // as there's a race condition that connection recovery and user might call this at the same time\n-        MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n-        if (restart) {\n-            // restart using existing msg handler \n-            messageHandler = existedMsgHandler;\n-        } else {\n-            // some has started delivery but not stop it\n-            if (null != existedMsgHandler) {\n-                throw new AlreadyStartDeliveryException(\"A message handler has been started for topic subscriber \" + topicSubscriber);\n-            }\n-            if (messageHandler != null) {\n-                if (null != topicSubscriber2MessageHandler.putIfAbsent(topicSubscriber, messageHandler)) {\n-                    throw new AlreadyStartDeliveryException(\"Someone is also starting delivery for topic subscriber \" + topicSubscriber);\n-                }\n-            }\n-        }\n-        try {\n-            HedwigClientImpl.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-            .setMessageHandler(messageHandler);\n-        } catch (NoResponseHandlerException e) {\n-            // We did not find a response handler. So remove this subscription handler and throw an exception.\n-            topicSubscriber2MessageHandler.remove(topicSubscriber, existedMsgHandler);\n-            asyncCloseSubscription(topic, subscriberId, new Callback<Void>() {\n-                @Override\n-                public void operationFinished(Object ctx, Void resultOfOperation) {\n-                    logger.warn(\"Closed subscription for topic \" + topic.toStringUtf8() + \" and subscriber \" +\n-                    subscriberId.toStringUtf8());\n-                }\n-\n-                @Override\n-                public void operationFailed(Object ctx, PubSubException exception) {\n-                    logger.warn(\"Error while closing subscription for topic \" + topic.toStringUtf8() + \" and subscriber \" +\n-                            subscriberId.toStringUtf8());\n-                }\n-            }, null);\n-\n-            // We should tell the client to resubscribe.\n-            throw new ClientNotSubscribedException(\"Closed subscription for topic \" + topic.toStringUtf8() + \" and\" +\n-                    \"subscriber Id \"  + subscriberId.toStringUtf8());\n-        }\n-        // Now make the TopicSubscriber Channel readable (it is set to not be\n-        // readable when the initial subscription is done). Note that this is an\n-        // asynchronous call. If this fails (not likely), the futureListener\n-        // will just log an error message for now.\n-        ChannelFuture future = topicSubscriberChannel.setReadable(true);\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (!future.isSuccess()) {\n-                    logger.error(\"Unable to make subscriber Channel readable in startDelivery call for topic: \"\n-                                 + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n-                }\n-            }\n-        });\n-    }\n-\n-    public void stopDelivery(final ByteString topic, final ByteString subscriberId) throws ClientNotSubscribedException {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Stopping delivery for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8());\n-        TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n-        // Make sure we know that this topic subscription on the client side\n-        // exists. The assumption is that the client should have in memory the\n-        // Channel created for the TopicSubscriber once the server has sent\n-        // an ack response to the initial subscribe request.\n-        Channel topicSubscriberChannel = topicSubscriber2Channel.get(topicSubscriber);\n-        if (topicSubscriberChannel == null) {\n-            logger.error(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8());\n-            throw new ClientNotSubscribedException(\"Client is not yet subscribed to topic: \" + topic.toStringUtf8()\n-                                                   + \", subscriberId: \" + subscriberId.toStringUtf8());\n-        }\n-\n-        // Unregister the MessageHandler for the subscribe Channel's\n-        // Response Handler.\n-        try {\n-            HedwigClientImpl.getResponseHandlerFromChannel(topicSubscriberChannel).getSubscribeResponseHandler()\n-                .setMessageHandler(null);\n-        } catch (NoResponseHandlerException e) {\n-            // Here it's okay if we can't set the response handler's message handler to null. We should just remove it.\n-            logger.warn(\"Could not set message handler to null for subscription channel \" + topicSubscriberChannel + \", ignoring.\");\n-        }\n-        this.topicSubscriber2MessageHandler.remove(topicSubscriber);\n-        // Now make the TopicSubscriber channel not-readable. This will buffer\n-        // up messages if any are sent from the server. Note that this is an\n-        // asynchronous call. If this fails (not likely), the futureListener\n-        // will just log an error message for now.\n-        ChannelFuture future = topicSubscriberChannel.setReadable(false);\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (!future.isSuccess()) {\n-                    logger.error(\"Unable to make subscriber Channel not readable in stopDelivery call for topic: \"\n-                                 + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n-                }\n-            }\n-        });\n+        logger.debug(\"Stopping delivery for {}.\", topicSubscriber);\n+        channelManager.stopDelivery(topicSubscriber); \n     }\n \n     public void closeSubscription(ByteString topic, ByteString subscriberId) throws ServiceDownException {\n@@ -744,94 +400,22 @@ public void closeSubscription(ByteString topic, ByteString subscriberId) throws\n     public void asyncCloseSubscription(final ByteString topic, final ByteString subscriberId,\n                                        final Callback<Void> callback, final Object context) {\n         doAsyncCloseSubscription(topic, subscriberId,\n-            new VoidCallbackAdapter<PubSubProtocol.ResponseBody> (callback), context);\n+                                 new VoidCallbackAdapter<ResponseBody>(callback), context);\n     }\n \n     private void doAsyncCloseSubscription(final ByteString topic, final ByteString subscriberId,\n-                                       final Callback<PubSubProtocol.ResponseBody> callback, final Object context) {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Closing subscription asynchronously for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n-                         + subscriberId.toStringUtf8());\n+                                          final Callback<ResponseBody> callback, final Object context) {\n         TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);\n-        // Remove all cached references for the TopicSubscriber\n-        Channel channel = topicSubscriber2Channel.remove(topicSubscriber);\n-        if (channel != null) {\n-            // Close the subscribe channel asynchronously.\n-            try {\n-                HedwigClientImpl.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n-            } catch (NoResponseHandlerException e) {\n-                // Don't close the channel if you can't find the handler.\n-                logger.warn(\"No response handler found, so could not close subscription channel \" + channel);\n-            }\n-            // We still close the channel as this is an unexpected event and should be handled as one.\n-            ChannelFuture future = channel.close();\n-            future.addListener(new ChannelFutureListener() {\n-                @Override\n-                public void operationComplete(ChannelFuture future) throws Exception {\n-                    if (!future.isSuccess()) {\n-                        logger.error(\"Failed to close the subscription channel for topic: \" + topic.toStringUtf8()\n-                                     + \", subscriberId: \" + subscriberId.toStringUtf8());\n-                        callback.operationFailed(context, new ServiceDownException(\n-                                                     \"Failed to close the subscription channel for topic: \" + topic.toStringUtf8()\n-                                                     + \", subscriberId: \" + subscriberId.toStringUtf8()));\n-                    } else {\n-                        callback.operationFinished(context, null);\n-                    }\n-                }\n-            });\n-        } else {\n-            logger.warn(\"Trying to close a subscription when we don't have a subscribe channel cached for topic: \"\n-                        + topic.toStringUtf8() + \", subscriberId: \" + subscriberId.toStringUtf8());\n-            callback.operationFinished(context, null);\n-        }\n-    }\n-\n-    // Public getter and setters for entries in the topic2Host Map.\n-    // This is used for classes that need this information but are not in the\n-    // same classpath.\n-    public Channel getChannelForTopic(TopicSubscriber topic) {\n-        return topicSubscriber2Channel.get(topic);\n-    }\n-\n-    public void setChannelAndPreferencesForTopic(TopicSubscriber topic, Channel channel,\n-                                                 SubscriptionPreferences preferences) {\n-        synchronized (closeLock) {\n-            if (closed) {\n-                channel.close();\n-                return;\n-            }\n-            Channel oldc = topicSubscriber2Channel.putIfAbsent(topic, channel);\n-            if (oldc != null) {\n-                logger.warn(\"Dropping new channel for \" + topic + \", due to existing channel: \" + oldc);\n-                channel.close();\n-            }\n-            if (null != preferences) {\n-                topicSubscriber2Preferences.put(topic, preferences);\n-            }\n-        }\n-    }\n-\n-    public void removeTopicSubscriber(TopicSubscriber topic) {\n-        synchronized (topic) {\n-            topicSubscriber2Preferences.remove(topic);\n-            topicSubscriber2Channel.remove(topic);\n-        }\n-    }\n-\n-    void close() {\n-        synchronized (closeLock) {\n-            closed = true;\n-        }\n-\n-        // Close all of the open Channels.\n-        for (Channel channel : topicSubscriber2Channel.values()) {\n-            try {\n-                client.getResponseHandlerFromChannel(channel).handleChannelClosedExplicitly();\n-            } catch (NoResponseHandlerException e) {\n-                logger.error(\"No response handler found while trying to close subscription channel.\");\n-            }\n-            channel.close().awaitUninterruptibly();\n+        logger.debug(\"Stopping delivery for {} before closing subscription.\", topicSubscriber);\n+        // We only stop delivery here not in channel manager\n+        // Because channelManager#asyncCloseSubscription will called\n+        // when subscription channel disconnected to clear local subscription\n+        try {\n+            channelManager.stopDelivery(topicSubscriber); \n+        } catch (ClientNotSubscribedException cnse) {\n+            // it is OK to ignore the exception when closing subscription\n         }\n-        topicSubscriber2Channel.clear();\n+        logger.debug(\"Closing subscription asynchronously for {}.\", topicSubscriber);\n+        channelManager.asyncCloseSubscription(topicSubscriber, callback, context);\n     }\n }"},{"sha":"58c191264b351cfb8e49bd6693b4bf68d2a5d5a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","status":"added","additions":198,"deletions":0,"changes":198,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/NetUtils.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,198 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.jboss.netty.channel.Channel;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.ConsumeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PublishRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n+\n+/**\n+ * Utilities for network operations.\n+ */\n+public class NetUtils {\n+\n+    /**\n+     * Helper static method to get the String Hostname:Port from a netty\n+     * Channel. Assumption is that the netty Channel was originally created with\n+     * an InetSocketAddress. This is true with the Hedwig netty implementation.\n+     *\n+     * @param channel\n+     *            Netty channel to extract the hostname and port from.\n+     * @return String representation of the Hostname:Port from the Netty Channel\n+     */\n+    public static InetSocketAddress getHostFromChannel(Channel channel) {\n+        return (InetSocketAddress) channel.getRemoteAddress();\n+    }\n+\n+    /**\n+     * This is a helper method to build the actual pub/sub message.\n+     *\n+     * @param txnId\n+     *            Transaction Id.\n+     * @param pubSubData\n+     *            Publish call's data wrapper object.\n+     * @return pub sub request to send\n+     */\n+    public static PubSubRequest.Builder buildPubSubRequest(long txnId,\n+                                                           PubSubData pubSubData) {\n+        // Create a PubSubRequest\n+        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n+        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n+        pubsubRequestBuilder.setType(pubSubData.operationType);\n+        // for consume request, we don't need to care about tried servers list\n+        if (OperationType.CONSUME != pubSubData.operationType) {\n+            if (pubSubData.triedServers != null && pubSubData.triedServers.size() > 0) {\n+                pubsubRequestBuilder.addAllTriedServers(pubSubData.triedServers);\n+            }\n+        }\n+        pubsubRequestBuilder.setTxnId(txnId);\n+        pubsubRequestBuilder.setShouldClaim(pubSubData.shouldClaim);\n+        pubsubRequestBuilder.setTopic(pubSubData.topic);\n+\n+        switch (pubSubData.operationType) {\n+        case PUBLISH:\n+            // Set the PublishRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setPublishRequest(buildPublishRequest(pubSubData));\n+            break;\n+        case SUBSCRIBE:\n+            // Set the SubscribeRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setSubscribeRequest(buildSubscribeRequest(pubSubData));\n+            break;\n+        case UNSUBSCRIBE:\n+            // Set the UnsubscribeRequest into the outer PubSubRequest\n+            pubsubRequestBuilder.setUnsubscribeRequest(buildUnsubscribeRequest(pubSubData));\n+            break;\n+        }\n+\n+        // Update the PubSubData with the txnId and the requestWriteTime\n+        pubSubData.txnId = txnId;\n+        pubSubData.requestWriteTime = System.currentTimeMillis();\n+\n+        return pubsubRequestBuilder;\n+    }\n+\n+    // build publish request\n+    private static PublishRequest.Builder buildPublishRequest(PubSubData pubSubData) {\n+        PublishRequest.Builder publishRequestBuilder = PublishRequest.newBuilder();\n+        publishRequestBuilder.setMsg(pubSubData.msg);\n+        return publishRequestBuilder;\n+    }\n+\n+    // build subscribe request\n+    private static SubscribeRequest.Builder buildSubscribeRequest(PubSubData pubSubData) { SubscribeRequest.Builder subscribeRequestBuilder = SubscribeRequest.newBuilder();\n+        subscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n+        subscribeRequestBuilder.setCreateOrAttach(pubSubData.options.getCreateOrAttach());\n+        subscribeRequestBuilder.setForceAttach(pubSubData.options.getForceAttach());\n+        // For now, all subscribes should wait for all cross-regional\n+        // subscriptions to be established before returning.\n+        subscribeRequestBuilder.setSynchronous(true);\n+        // set subscription preferences\n+        SubscriptionPreferences.Builder preferencesBuilder =\n+            options2Preferences(pubSubData.options);\n+        // backward compatable with 4.1.0\n+        if (preferencesBuilder.hasMessageBound()) {\n+            subscribeRequestBuilder.setMessageBound(preferencesBuilder.getMessageBound());\n+        } \n+        subscribeRequestBuilder.setPreferences(preferencesBuilder);\n+        return subscribeRequestBuilder;\n+    }\n+\n+    // build unsubscribe request\n+    private static UnsubscribeRequest.Builder buildUnsubscribeRequest(PubSubData pubSubData) {\n+        // Create the UnSubscribeRequest\n+        UnsubscribeRequest.Builder unsubscribeRequestBuilder = UnsubscribeRequest.newBuilder();\n+        unsubscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n+        return unsubscribeRequestBuilder;\n+    }\n+\n+    /**\n+     * Build consume request\n+     *\n+     * @param txnId\n+     *          Transaction Id.\n+     * @param topicSubscriber\n+     *          Topic Subscriber.\n+     * @param messageSeqId\n+     *          Message Seq Id.\n+     * @return pub/sub request.\n+     */\n+    public static PubSubRequest.Builder buildConsumeRequest(long txnId,\n+                                                            TopicSubscriber topicSubscriber,\n+                                                            MessageSeqId messageSeqId) {\n+        // Create a PubSubRequest\n+        PubSubRequest.Builder pubsubRequestBuilder = PubSubRequest.newBuilder();\n+        pubsubRequestBuilder.setProtocolVersion(ProtocolVersion.VERSION_ONE);\n+        pubsubRequestBuilder.setType(OperationType.CONSUME);\n+\n+        pubsubRequestBuilder.setTxnId(txnId);\n+        pubsubRequestBuilder.setTopic(topicSubscriber.getTopic());\n+\n+        // Create the ConsumeRequest\n+        ConsumeRequest.Builder consumeRequestBuilder = ConsumeRequest.newBuilder();\n+        consumeRequestBuilder.setSubscriberId(topicSubscriber.getSubscriberId());\n+        consumeRequestBuilder.setMsgId(messageSeqId);\n+\n+        pubsubRequestBuilder.setConsumeRequest(consumeRequestBuilder);\n+\n+        return pubsubRequestBuilder;\n+    }\n+\n+    /**\n+     * Convert client-side subscription options to subscription preferences\n+     *\n+     * @param options\n+     *          Client-Side subscription options\n+     * @return subscription preferences\n+     */\n+    private static SubscriptionPreferences.Builder options2Preferences(SubscriptionOptions options) {\n+        // prepare subscription preferences\n+        SubscriptionPreferences.Builder preferencesBuilder =\n+            SubscriptionPreferences.newBuilder();\n+\n+        // set message bound\n+        if (options.getMessageBound() > 0) {\n+            preferencesBuilder.setMessageBound(options.getMessageBound());\n+        }\n+\n+        // set message filter\n+        if (options.hasMessageFilter()) {\n+            preferencesBuilder.setMessageFilter(options.getMessageFilter());\n+        }\n+\n+        // set user options\n+        if (options.hasOptions()) {\n+            preferencesBuilder.setOptions(options.getOptions());\n+        }\n+\n+        return preferencesBuilder;\n+    }\n+\n+}"},{"sha":"127cfb81454f7bed8d26eadb3b5482457720dde3","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"removed","additions":0,"deletions":376,"changes":376,"blob_url":"https://github.com/apache/bookkeeper/blob/881cda5c85d17f952bdc2c7e101eef669bce35d2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/881cda5c85d17f952bdc2c7e101eef669bce35d2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=881cda5c85d17f952bdc2c7e101eef669bce35d2","patch":"@@ -1,376 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.client.netty;\n-\n-import java.net.InetSocketAddress;\n-import java.util.LinkedList;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelPipelineCoverage;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.ExceptionEvent;\n-import org.jboss.netty.channel.MessageEvent;\n-import org.jboss.netty.channel.SimpleChannelHandler;\n-import org.jboss.netty.handler.ssl.SslHandler;\n-\n-import com.google.protobuf.ByteString;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.client.exceptions.ServerRedirectLoopException;\n-import org.apache.hedwig.client.exceptions.TooManyServerRedirectsException;\n-import org.apache.hedwig.client.handlers.PublishResponseHandler;\n-import org.apache.hedwig.client.handlers.SubscribeReconnectCallback;\n-import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n-import org.apache.hedwig.client.handlers.UnsubscribeResponseHandler;\n-import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n-import org.apache.hedwig.exceptions.PubSubException.UncertainStateException;\n-import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n-import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n-import org.apache.hedwig.util.HedwigSocketAddress;\n-import org.apache.hedwig.util.SubscriptionListener;\n-\n-@ChannelPipelineCoverage(\"all\")\n-public class ResponseHandler extends SimpleChannelHandler {\n-\n-    private static Logger logger = LoggerFactory.getLogger(ResponseHandler.class);\n-\n-    // Concurrent Map to store for each async PubSub request, the txn ID\n-    // and the corresponding PubSub call's data which stores the VoidCallback to\n-    // invoke when we receive a PubSub ack response from the server.\n-    // This is specific to this instance of the ResponseHandler which is\n-    // tied to a specific netty Channel Pipeline.\n-    protected final ConcurrentMap<Long, PubSubData> txn2PubSubData = new ConcurrentHashMap<Long, PubSubData>();\n-\n-    // Boolean indicating if we closed the channel this ResponseHandler is\n-    // attached to explicitly or not. If so, we do not need to do the\n-    // channel disconnected logic here.\n-    private boolean channelClosedExplicitly = false;\n-\n-    private final HedwigClientImpl client;\n-    private final HedwigPublisher pub;\n-    private final HedwigSubscriber sub;\n-    private final ClientConfiguration cfg;\n-\n-    private final PublishResponseHandler pubHandler;\n-    private final SubscribeResponseHandler subHandler;\n-    private final UnsubscribeResponseHandler unsubHandler;\n-\n-    public ResponseHandler(HedwigClientImpl client) {\n-        this.client = client;\n-        this.sub = client.getSubscriber();\n-        this.pub = client.getPublisher();\n-        this.cfg = client.getConfiguration();\n-        this.pubHandler = new PublishResponseHandler(this);\n-        this.subHandler = new SubscribeResponseHandler(this);\n-        this.unsubHandler = new UnsubscribeResponseHandler(this);\n-    }\n-\n-    // Public getters needed for the private members\n-    public HedwigClientImpl getClient() {\n-        return client;\n-    }\n-\n-    public HedwigSubscriber getSubscriber() {\n-        return sub;\n-    }\n-\n-    public ClientConfiguration getConfiguration() {\n-        return cfg;\n-    }\n-\n-    public SubscribeResponseHandler getSubscribeResponseHandler() {\n-        return subHandler;\n-    }\n-\n-    @Override\n-    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        // If the Message is not a PubSubResponse, just send it upstream and let\n-        // something else handle it.\n-        if (!(e.getMessage() instanceof PubSubResponse)) {\n-            ctx.sendUpstream(e);\n-        }\n-        // Retrieve the PubSubResponse from the Message that was sent by the\n-        // server.\n-        PubSubResponse response = (PubSubResponse) e.getMessage();\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Response received from host: \" + HedwigClientImpl.getHostFromChannel(ctx.getChannel())\n-                         + \", response: \" + response);\n-\n-        // Determine if this PubSubResponse is an ack response for a PubSub\n-        // Request or if it is a message being pushed to the client subscriber.\n-        if (response.hasMessage()) {\n-            // Subscribed messages being pushed to the client so handle/consume\n-            // it and return.\n-            subHandler.handleSubscribeMessage(response);\n-            return;\n-        }\n-\n-        // Response is an ack to a prior PubSubRequest so first retrieve the\n-        // PubSub data for this txn.\n-        PubSubData pubSubData = txn2PubSubData.remove(response.getTxnId());\n-        // Validate that the PubSub data for this txn was stored. If not, just\n-        // log an error message and return since we don't know how to handle\n-        // this.\n-        if (pubSubData == null) {\n-            logger.error(\"PubSub Data was not found for PubSubResponse: \" + response);\n-            return;\n-        }\n-\n-        // Store the topic2Host mapping if this wasn't a server redirect. We'll\n-        // assume that if the server was able to have an open Channel connection\n-        // to the client, and responded with an ack message other than the\n-        // NOT_RESPONSIBLE_FOR_TOPIC one, it is the correct topic master.\n-        if (!response.getStatusCode().equals(StatusCode.NOT_RESPONSIBLE_FOR_TOPIC)) {\n-            client.storeTopic2HostMapping(pubSubData, ctx.getChannel());\n-        }\n-\n-        // Depending on the operation type, call the appropriate handler.\n-        switch (pubSubData.operationType) {\n-        case PUBLISH:\n-            pubHandler.handlePublishResponse(response, pubSubData, ctx.getChannel());\n-            break;\n-        case SUBSCRIBE:\n-            subHandler.handleSubscribeResponse(response, pubSubData, ctx.getChannel());\n-            break;\n-        case UNSUBSCRIBE:\n-            unsubHandler.handleUnsubscribeResponse(response, pubSubData, ctx.getChannel());\n-            break;\n-        default:\n-            // The above are the only expected PubSubResponse messages received\n-            // from the server for the various client side requests made.\n-            logger.error(\"Response received from server is for an unhandled operation type, txnId: \"\n-                         + response.getTxnId() + \", operationType: \" + pubSubData.operationType);\n-        }\n-    }\n-\n-    /**\n-     * Logic to repost a PubSubRequest when the server responds with a redirect\n-     * indicating they are not the topic master.\n-     *\n-     * @param response\n-     *            PubSubResponse from the server for the redirect\n-     * @param pubSubData\n-     *            PubSubData for the original PubSubRequest made\n-     * @param channel\n-     *            Channel Channel we used to make the original PubSubRequest\n-     * @throws Exception\n-     *             Throws an exception if there was an error in doing the\n-     *             redirect repost of the PubSubRequest\n-     */\n-    public void handleRedirectResponse(PubSubResponse response, PubSubData pubSubData, Channel channel)\n-            throws Exception {\n-        if (logger.isDebugEnabled())\n-            logger.debug(\"Handling a redirect from host: \" + HedwigClientImpl.getHostFromChannel(channel) + \", response: \"\n-                         + response + \", pubSubData: \" + pubSubData);\n-        // In this case, the PubSub request was done to a server that is not\n-        // responsible for the topic. First make sure that we haven't\n-        // exceeded the maximum number of server redirects.\n-        int curNumServerRedirects = (pubSubData.triedServers == null) ? 0 : pubSubData.triedServers.size();\n-        if (curNumServerRedirects >= cfg.getMaximumServerRedirects()) {\n-            // We've already exceeded the maximum number of server redirects\n-            // so consider this as an error condition for the client.\n-            // Invoke the operationFailed callback and just return.\n-            logger.debug(\"Exceeded the maximum number of redirects ({}): erroring out.\", curNumServerRedirects);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                    new TooManyServerRedirectsException(\"Already reached max number of redirects: \"\n-                                                            + curNumServerRedirects)));\n-            return;\n-        }\n-\n-        // We will redirect and try to connect to the correct server\n-        // stored in the StatusMsg of the response. First store the\n-        // server that we sent the PubSub request to for the topic.\n-        ByteString triedServer = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(HedwigClientImpl\n-                                 .getHostFromChannel(channel)));\n-        if (pubSubData.triedServers == null)\n-            pubSubData.triedServers = new LinkedList<ByteString>();\n-        pubSubData.shouldClaim = true;\n-        pubSubData.triedServers.add(triedServer);\n-\n-        // Now get the redirected server host (expected format is\n-        // Hostname:Port:SSLPort) from the server's response message. If one is\n-        // not given for some reason, then redirect to the default server\n-        // host/VIP to repost the request.\n-        String statusMsg = response.getStatusMsg();\n-        InetSocketAddress redirectedHost;\n-        if (statusMsg != null && statusMsg.length() > 0) {\n-            if (cfg.isSSLEnabled()) {\n-                redirectedHost = new HedwigSocketAddress(statusMsg).getSSLSocketAddress();\n-            } else {\n-                redirectedHost = new HedwigSocketAddress(statusMsg).getSocketAddress();\n-            }\n-        } else {\n-            redirectedHost = cfg.getDefaultServerHost();\n-        }\n-\n-        // Make sure the redirected server is not one we've already attempted\n-        // already before in this PubSub request.\n-        if (pubSubData.triedServers.contains(ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(redirectedHost)))) {\n-            logger.error(\"We've already sent this PubSubRequest before to redirectedHost: \" + redirectedHost\n-                         + \", pubSubData: \" + pubSubData);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n-                                                    new ServerRedirectLoopException(\"Already made the request before to redirected host: \"\n-                                                            + redirectedHost)));\n-            return;\n-        }\n-\n-        // Check if we already have a Channel open to the redirected server\n-        // host.\n-        Channel redirectedHostChannel = pub.host2Channel.get(redirectedHost);\n-        if (pubSubData.operationType.equals(OperationType.SUBSCRIBE) || redirectedHostChannel == null) {\n-            // We don't have an existing channel to the redirected host OR this\n-            // is a redirected Subscribe request. For Subscribe requests, we\n-            // always want to create a new unique Channel connection to the\n-            // topic master server for the TopicSubscriber.\n-            client.doConnect(pubSubData, redirectedHost);\n-        } else {\n-            // For Publish and Unsubscribe requests, we can just post the\n-            // request again directly on the existing cached redirected host\n-            // channel.\n-            if (pubSubData.operationType.equals(OperationType.PUBLISH)) {\n-                pub.doPublish(pubSubData, redirectedHostChannel);\n-            } else if (pubSubData.operationType.equals(OperationType.UNSUBSCRIBE)) {\n-                sub.doSubUnsub(pubSubData, redirectedHostChannel);\n-            }\n-        }\n-    }\n-\n-    // Logic to deal with what happens when a Channel to a server host is\n-    // disconnected.\n-    @Override\n-    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-        // If this channel was closed explicitly by the client code,\n-        // we do not need to do any of this logic. This could happen\n-        // for redundant Publish channels created or redirected subscribe\n-        // channels that are not used anymore or when we shutdown the\n-        // client and manually close all of the open channels.\n-        // Also don't do any of the disconnect logic if the client has stopped.\n-        if (channelClosedExplicitly || client.hasStopped())\n-            return;\n-\n-        // Make sure the host retrieved is not null as there could be some weird\n-        // channel disconnect events happening during a client shutdown.\n-        // If it is, just return as there shouldn't be anything we need to do.\n-        InetSocketAddress host = HedwigClientImpl.getHostFromChannel(ctx.getChannel());\n-        logger.warn(\"Channel was disconnected to host: \" + host);\n-        if (host == null)\n-            return;\n-\n-        // If this Channel was used for Publish and Unsubscribe flows, just\n-        // remove it from the HewdigPublisher's host2Channel map. We will\n-        // re-establish a Channel connection to that server when the next\n-        // publish/unsubscribe request to a topic that the server owns occurs.\n-        PubSubData origSubData = subHandler.getOrigSubData();\n-\n-        // Now determine what type of operation this channel was used for.\n-        if (origSubData == null) {\n-            // Only remove the Channel from the mapping if this current\n-            // disconnected channel is the same as the cached entry.\n-            // Due to race concurrency situations, it is possible to\n-            // create multiple channels to the same host for publish\n-            // and unsubscribe requests.\n-            Channel channel = pub.host2Channel.get(host);\n-            if (channel != null && channel.equals(ctx.getChannel())) {\n-                logger.debug(\"Disconnected channel for host: {} was for Publish/Unsubscribe requests\" +\n-                    \" so remove all references to it.\", host);\n-                if (pub.host2Channel.remove(host, channel)) {\n-                    client.clearAllTopicsForHost(host);\n-                }\n-            }\n-        } else {\n-            // Subscribe channel disconnected so first close and clear all\n-            // cached Channel data set up for this topic subscription.\n-            sub.closeSubscription(origSubData.topic, origSubData.subscriberId);\n-            // a subscription channel disconnecteda because topic has moved.\n-            // just clear the entry for the given topic\n-            client.clearHostForTopic(origSubData.topic, host);\n-            // Since the connection to the server host that was responsible\n-            // for the topic died, we are not sure about the state of that\n-            // server. Resend the original subscribe request data to the default\n-            // server host/VIP. Also clear out all of the servers we've\n-            // contacted or attempted to from this request as we are starting a\n-            // \"fresh\" subscribe request.\n-            origSubData.clearServersList();\n-            // do resubscribe if the subscription enables it\n-            if (origSubData.options.getEnableResubscribe()) {\n-                // Set a new type of VoidCallback for this async call. We need this\n-                // hook so after the subscribe reconnect has completed, delivery for\n-                // that topic subscriber should also be restarted (if it was that\n-                // case before the channel disconnect).\n-                origSubData.setCallback(new SubscribeReconnectCallback(origSubData, client));\n-                origSubData.context = null;\n-                // Clear the shouldClaim flag\n-                origSubData.shouldClaim = false;\n-                logger.debug(\"Disconnected subscribe channel so reconnect with origSubData: {}\", origSubData);\n-                client.doConnect(origSubData, cfg.getDefaultServerHost());\n-            } else {\n-                logger.info(\"Subscription channel for (topic:{}, subscriber:{}) is disconnected.\",\n-                            origSubData.topic.toStringUtf8(), origSubData.subscriberId.toStringUtf8());\n-                sub.emitSubscriptionEvent(origSubData.topic, origSubData.subscriberId,\n-                                          SubscriptionEvent.TOPIC_MOVED);\n-            }\n-        }\n-\n-        // Finally, all of the PubSubRequests that are still waiting for an ack\n-        // response from the server need to be removed and timed out. Invoke the\n-        // operationFailed callbacks on all of them. Use the\n-        // UncertainStateException since the server did receive the request but\n-        // we're not sure of the state of the request since the ack response was\n-        // never received.\n-        for (PubSubData pubSubData : txn2PubSubData.values()) {\n-            logger.debug(\"Channel disconnected so invoking the operationFailed callback for pubSubData: {}\",\n-                pubSubData);\n-            pubSubData.getCallback().operationFailed(pubSubData.context, new UncertainStateException(\n-                                                    \"Server ack response never received before server connection disconnected!\"));\n-        }\n-        txn2PubSubData.clear();\n-    }\n-\n-    // Logic to deal with what happens when a Channel to a server host is\n-    // connected. This is needed if the client is using an SSL port to\n-    // communicate with the server. If so, we need to do the SSL handshake here\n-    // when the channel is first connected.\n-    @Override\n-    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-        // No need to initiate the SSL handshake if we are closing this channel\n-        // explicitly or the client has been stopped.\n-        if (cfg.isSSLEnabled() && !channelClosedExplicitly && !client.hasStopped()) {\n-            logger.debug(\"Initiating the SSL handshake\");\n-            ctx.getPipeline().get(SslHandler.class).handshake(e.getChannel());\n-        }\n-    }\n-\n-    public void handleChannelClosedExplicitly(){\n-        // TODO: BOOKKEEPER-350 : Handle consume buffering, etc here - in a different patch\n-        channelClosedExplicitly = true;\n-    }\n-\n-    @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {\n-        logger.error(\"Exception caught on client channel\", e.getCause());\n-        e.getChannel().close();\n-    }\n-\n-}"},{"sha":"ffe866108ec54a3fbf082d91e198bf53ecaabf18","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/SubscriptionEventEmitter.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.concurrent.CopyOnWriteArraySet;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.util.SubscriptionListener;\n+\n+public class SubscriptionEventEmitter {\n+\n+    private final CopyOnWriteArraySet<SubscriptionListener> listeners;\n+\n+    public SubscriptionEventEmitter() {\n+        listeners = new CopyOnWriteArraySet<SubscriptionListener>();\n+    }\n+\n+    public void addSubscriptionListener(SubscriptionListener listener) {\n+        listeners.add(listener); \n+    }\n+\n+    public void removeSubscriptionListener(SubscriptionListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    public void emitSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                      SubscriptionEvent event) {\n+        for (SubscriptionListener listener : listeners) {\n+            listener.processEvent(topic, subscriberId, event);\n+        }\n+    }\n+\n+}"},{"sha":"32b140c50dfb8e0b826ebf7440a55691eb7376c6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","status":"added","additions":621,"deletions":0,"changes":621,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/AbstractHChannelManager.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,621 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.MessageConsumeCallback;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.SubscriptionEventEmitter;\n+import org.apache.hedwig.client.ssl.SslClientContextFactory;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageHeader;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * Basic HChannel Manager Implementation\n+ */\n+public abstract class AbstractHChannelManager implements HChannelManager {\n+\n+    private static Logger logger = LoggerFactory.getLogger(AbstractHChannelManager.class);\n+\n+    // Empty Topic List\n+    private final static Set<ByteString> EMPTY_TOPIC_SET =\n+        new HashSet<ByteString>();\n+\n+    // Boolean indicating if the channel manager is running or has been closed.\n+    // Once we stop the manager, we should sidestep all of the connect, write callback\n+    // and channel disconnected logic.\n+    protected boolean closed = false;\n+    protected final ReentrantReadWriteLock closedLock =\n+        new ReentrantReadWriteLock();\n+\n+    // Global counter used for generating unique transaction ID's for\n+    // publish and subscribe requests\n+    protected final AtomicLong globalCounter = new AtomicLong();\n+\n+    // Concurrent Map to store the mapping from the Topic to the Host.\n+    // This could change over time since servers can drop mastership of topics\n+    // for load balancing or failover. If a server host ever goes down, we'd\n+    // also want to remove all topic mappings the host was responsible for.\n+    // The second Map is used as the inverted version of the first one.\n+    protected final ConcurrentMap<ByteString, InetSocketAddress> topic2Host =\n+        new ConcurrentHashMap<ByteString, InetSocketAddress>();\n+    // The inverse mapping is used only when clearing all topics. For performance\n+    // consideration, we don't guarantee host2Topics to be consistent with\n+    // topic2Host. it would be better to not rely on this mapping for anything\n+    // significant.\n+    protected final ConcurrentMap<InetSocketAddress, Set<ByteString>> host2Topics =\n+        new ConcurrentHashMap<InetSocketAddress, Set<ByteString>>();\n+\n+    // This channels will be used for publish and unsubscribe requests\n+    protected final CleanupChannelMap<InetSocketAddress> host2NonSubscriptionChannels =\n+        new CleanupChannelMap<InetSocketAddress>();\n+\n+    private final ClientConfiguration cfg;\n+    // The Netty socket factory for making connections to the server.\n+    protected final ChannelFactory socketFactory;\n+    // PipelineFactory to create non-subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory nonSubscriptionChannelPipelineFactory;\n+    // ssl context factory\n+    private SslClientContextFactory sslFactory = null;\n+\n+    // default server channel\n+    private final HChannel defaultServerChannel;\n+\n+    // Each client instantiation will have a Timer for running recurring\n+    // threads. One such timer task thread to is to timeout long running\n+    // PubSubRequests that are waiting for an ack response from the server.\n+    private final Timer clientTimer = new Timer(true);\n+    // a common consume callback for all consume requests.\n+    private final MessageConsumeCallback consumeCb;\n+    // A event emitter to emit subscription events\n+    private final SubscriptionEventEmitter eventEmitter;\n+\n+    protected AbstractHChannelManager(ClientConfiguration cfg,\n+                                      ChannelFactory socketFactory) {\n+        this.cfg = cfg;\n+        this.socketFactory = socketFactory;\n+        this.nonSubscriptionChannelPipelineFactory =\n+            new NonSubscriptionChannelPipelineFactory(cfg, this);\n+\n+        // create a default server channel\n+        defaultServerChannel =\n+            new DefaultServerChannel(cfg.getDefaultServerHost(), this);\n+\n+        if (cfg.isSSLEnabled()) {\n+            sslFactory = new SslClientContextFactory(cfg);\n+        }\n+\n+        consumeCb = new MessageConsumeCallback(cfg, this);\n+        eventEmitter = new SubscriptionEventEmitter();\n+\n+        // Schedule Request Timeout task.\n+        clientTimer.schedule(new PubSubRequestTimeoutTask(), 0,\n+                             cfg.getTimeoutThreadRunInterval());\n+    }\n+\n+    @Override\n+    public SubscriptionEventEmitter getSubscriptionEventEmitter() {\n+        return eventEmitter;\n+    }\n+\n+    public MessageConsumeCallback getConsumeCallback() {\n+        return consumeCb;\n+    }\n+\n+    public SslClientContextFactory getSslFactory() {\n+        return sslFactory;\n+    }\n+\n+    protected ChannelFactory getChannelFactory() {\n+        return socketFactory;\n+    }\n+\n+    protected ClientChannelPipelineFactory getNonSubscriptionChannelPipelineFactory() {\n+        return this.nonSubscriptionChannelPipelineFactory;\n+    }\n+\n+    protected abstract ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory();\n+\n+    @Override\n+    public void schedule(final TimerTask task, final long delay) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                logger.warn(\"Task {} is not scheduled due to the channel manager is closed.\",\n+                            task);\n+                return;\n+            }\n+            clientTimer.schedule(task, delay);\n+        } finally {\n+            this.closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void submitOpAfterDelay(final PubSubData pubSubData, final long delay) {\n+        this.closedLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                pubSubData.getCallback().operationFailed(pubSubData.context,\n+                    new ServiceDownException(\"Client has been closed.\"));\n+                return;\n+            }\n+            clientTimer.schedule(new TimerTask() {\n+                @Override\n+                public void run() {\n+                    logger.debug(\"Submit request {} in {} ms later.\",\n+                                 va(pubSubData, delay));\n+                    submitOp(pubSubData);\n+                }\n+            }, delay);\n+        } finally {\n+            closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void submitOp(PubSubData pubSubData) {\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = getNonSubscriptionChannelByTopic(pubSubData.topic);\n+        } else {\n+            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n+                                                     pubSubData.subscriberId);\n+            hChannel = getSubscriptionChannelByTopicSubscriber(ts);\n+        }\n+        // no channel found to submit pubsub data\n+        // choose the default server\n+        if (null == hChannel) {\n+            hChannel = defaultServerChannel;\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    @Override\n+    public void redirectToHost(PubSubData pubSubData, InetSocketAddress host) {\n+        logger.debug(\"Submit operation {} to host {}.\",\n+                     va(pubSubData, host));\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = getNonSubscriptionChannel(host);\n+            if (null == hChannel) {\n+                // create a channel to connect to specified host\n+                hChannel = createAndStoreNonSubscriptionChannel(host);\n+            }\n+        } else {\n+            hChannel = getSubscriptionChannel(host);\n+            if (null == hChannel) {\n+                // create a subscription channel to specified host\n+                hChannel = createAndStoreSubscriptionChannel(host);\n+            }\n+        }\n+        // no channel found to submit pubsub data\n+        // choose the default server\n+        if (null == hChannel) {\n+            hChannel = defaultServerChannel;\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    void submitOpThruChannel(PubSubData pubSubData, Channel channel) {\n+        logger.debug(\"Submit operation {} to thru channel {}.\",\n+                     va(pubSubData, channel));\n+        HChannel hChannel;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            hChannel = createAndStoreNonSubscriptionChannel(channel);\n+        } else {\n+            hChannel = createAndStoreSubscriptionChannel(channel);\n+        }\n+        hChannel.submitOp(pubSubData);\n+    }\n+\n+    @Override\n+    public void submitOpToDefaultServer(PubSubData pubSubData) {\n+        logger.debug(\"Submit operation {} to default server {}.\",\n+                     va(pubSubData, defaultServerChannel));\n+        defaultServerChannel.submitOp(pubSubData);\n+    }\n+\n+    // Synchronized method to store the host2Channel mapping (if it doesn't\n+    // exist yet). Retrieve the hostname info from the Channel created via the\n+    // RemoteAddress tied to it.\n+    private HChannel createAndStoreNonSubscriptionChannel(Channel channel) {\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getNonSubscriptionChannelPipelineFactory());\n+        return storeNonSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel createAndStoreNonSubscriptionChannel(InetSocketAddress host) {\n+        HChannel newHChannel = new HChannelImpl(host, this,\n+                                                getNonSubscriptionChannelPipelineFactory());\n+        return storeNonSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel storeNonSubscriptionChannel(InetSocketAddress host,\n+                                                 HChannel newHChannel) {\n+        return host2NonSubscriptionChannels.addChannel(host, newHChannel);\n+    }\n+\n+    /**\n+     * Is there a {@link HChannel} existed for a given host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    private HChannel getNonSubscriptionChannel(InetSocketAddress host) {\n+        return host2NonSubscriptionChannels.getChannel(host);\n+    }\n+\n+    /**\n+     * Get a non-subscription channel for a given <code>topic</code>.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @return if <code>topic</code>'s owner is unknown, return null.\n+     *         if <code>topic</code>'s owner is know and there is a channel\n+     *         existed before, return the existed channel, otherwise created\n+     *         a new one.\n+     */\n+    private HChannel getNonSubscriptionChannelByTopic(ByteString topic) {\n+        InetSocketAddress host = topic2Host.get(topic);\n+        if (null == host) {\n+            // we don't know where is the topic\n+            return null;\n+        } else {\n+            // we had know which server owned the topic\n+            HChannel channel = getNonSubscriptionChannel(host);\n+            if (null == channel) {\n+                // create a channel to connect to specified host\n+                channel = createAndStoreNonSubscriptionChannel(host);\n+            }\n+            return channel;\n+        }\n+    }\n+\n+    /**\n+     * Handle the disconnected event from a non-subscription {@link HChannel}.\n+     *\n+     * @param host\n+     *          Which host is disconnected.\n+     * @param channel\n+     *          The underlying established channel.\n+     */\n+    protected void onNonSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                        Channel channel) {\n+        // Only remove the Channel from the mapping if this current\n+        // disconnected channel is the same as the cached entry.\n+        // Due to race concurrency situations, it is possible to\n+        // create multiple channels to the same host for publish\n+        // and unsubscribe requests.\n+        HChannel hChannel = host2NonSubscriptionChannels.getChannel(host);\n+        if (null == hChannel) {\n+            return;\n+        }\n+        Channel underlyingChannel = hChannel.getChannel();\n+        if (null == underlyingChannel ||\n+            !underlyingChannel.equals(channel)) {\n+            return;\n+        }\n+        logger.info(\"NonSubscription Channel {} to {} disconnected.\",\n+                    va(channel, host));\n+        // remove existed channel\n+        if (host2NonSubscriptionChannels.removeChannel(host, hChannel)) {\n+            clearAllTopicsForHost(host);\n+        }\n+    }\n+\n+    /**\n+     * Create and store a subscription {@link HChannel} thru the underlying established\n+     * <code>channel</code>\n+     *\n+     * @param channel\n+     *          The underlying established subscription channel.\n+     */\n+    protected abstract HChannel createAndStoreSubscriptionChannel(Channel channel);\n+\n+    /**\n+     * Create and store a subscription {@link HChannel} to target host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    protected abstract HChannel createAndStoreSubscriptionChannel(InetSocketAddress host);\n+\n+    /**\n+     * Is there a subscription {@link HChannel} existed for a given host.\n+     *\n+     * @param host\n+     *          Target host address.\n+     */\n+    protected abstract HChannel getSubscriptionChannel(InetSocketAddress host);\n+\n+    /**\n+     * Get a subscription channel for a given <code>topicSubscriber</code>.\n+     *\n+     * @param topicSubscriber\n+     *          Topic Subscriber\n+     * @return if <code>topic</code>'s owner is unknown, return null.\n+     *         if <code>topic</code>'s owner is know and there is a channel\n+     *         existed before, return the existed channel, otherwise created\n+     *         a new one for the <code>topicSubscriber</code>.\n+     */\n+    protected abstract HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber topicSubscriber);\n+\n+    /**\n+     * Handle the disconnected event from a subscription {@link HChannel}.\n+     *\n+     * @param host\n+     *          Which host is disconnected.\n+     * @param channel\n+     *          The underlying established channel.\n+     */\n+    protected abstract void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                              Channel channel);\n+\n+    private void sendConsumeRequest(final TopicSubscriber topicSubscriber,\n+                                    final MessageSeqId messageSeqId,\n+                                    final Channel channel) {\n+        PubSubRequest.Builder pubsubRequestBuilder =\n+            NetUtils.buildConsumeRequest(nextTxnId(), topicSubscriber, messageSeqId);  \n+\n+        // For Consume requests, we will send them from the client in a fire and\n+        // forget manner. We are not expecting the server to send back an ack\n+        // response so no need to register this in the ResponseHandler. There\n+        // are no callbacks to invoke since this isn't a client initiated\n+        // action. Instead, just have a future listener that will log an error\n+        // message if there was a problem writing the consume request.\n+        logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                     va(NetUtils.getHostFromChannel(channel), messageSeqId, topicSubscriber));\n+        ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                                 va(NetUtils.getHostFromChannel(channel),\n+                                    messageSeqId, topicSubscriber));\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Helper method to store the topic2Host mapping in the channel manager cache\n+     * map. This method is assumed to be called when we've done a successful\n+     * connection to the correct server topic master.\n+     *\n+     * @param topic\n+     *            Topic Name\n+     * @param host\n+     *            Host Address\n+     */\n+    protected void storeTopic2HostMapping(ByteString topic, InetSocketAddress host) {\n+        InetSocketAddress oldHost = topic2Host.putIfAbsent(topic, host);\n+        if (null != oldHost && oldHost.equals(host)) {\n+            // Entry in map exists for the topic but it is the same as the\n+            // current host. In this case there is nothing to do.\n+            return;\n+        }\n+\n+        if (null != oldHost) {\n+            if (topic2Host.replace(topic, oldHost, host)) {\n+                // Store the relevant mappings for this topic and host combination.\n+                logger.debug(\"Storing info for topic: {}, old host: {}, new host: {}.\",\n+                             va(topic.toStringUtf8(), oldHost, host));\n+                clearHostForTopic(topic, oldHost);\n+            } else {\n+                logger.warn(\"Ownership of topic: {} has been changed from {} to {} when storeing host: {}\",\n+                            va(topic.toStringUtf8(), oldHost, topic2Host.get(topic), host));\n+                return;\n+            }\n+        } else {\n+            logger.debug(\"Storing info for topic: {}, host: {}.\",\n+                         va(topic.toStringUtf8(), host));\n+        }\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null == topicsForHost) {\n+            Set<ByteString> newTopicsSet = new HashSet<ByteString>();\n+            topicsForHost = host2Topics.putIfAbsent(host, newTopicsSet);\n+            if (null == topicsForHost) {\n+              topicsForHost = newTopicsSet;\n+            }\n+        }\n+        synchronized (topicsForHost) {\n+            // check whether the ownership changed, since it might happened\n+            // after replace succeed\n+            if (host.equals(topic2Host.get(topic))) {\n+                topicsForHost.add(topic);\n+            }\n+        }\n+    }\n+\n+    // If a server host goes down or the channel to it gets disconnected,\n+    // we want to clear out all relevant cached information. We'll\n+    // need to remove all of the topic mappings that the host was\n+    // responsible for.\n+    protected void clearAllTopicsForHost(InetSocketAddress host) {\n+        logger.debug(\"Clearing all topics for host: {}\", host);\n+        // For each of the topics that the host was responsible for,\n+        // remove it from the topic2Host mapping.\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null != topicsForHost) {\n+            synchronized (topicsForHost) {\n+                for (ByteString topic : topicsForHost) {\n+                    logger.debug(\"Removing mapping for topic: {} from host: {}.\",\n+                                 va(topic.toStringUtf8(), host));\n+                    topic2Host.remove(topic, host);\n+                }\n+            }\n+            // Now it is safe to remove the host2Topics mapping entry.\n+            host2Topics.remove(host, topicsForHost);\n+        }\n+    }\n+\n+    // If a subscribe channel goes down, the topic might have moved.\n+    // We only clear out that topic for the host and not all cached information.\n+    public void clearHostForTopic(ByteString topic, InetSocketAddress host) {\n+        logger.debug(\"Clearing topic: {} from host: {}.\",\n+                     va(topic.toStringUtf8(), host));\n+        if (topic2Host.remove(topic, host)) {\n+            logger.debug(\"Removed topic to host mapping for topic: {} and host: {}.\",\n+                         va(topic.toStringUtf8(), host));\n+        }\n+        Set<ByteString> topicsForHost = host2Topics.get(host);\n+        if (null != topicsForHost) {\n+            boolean removed;\n+            synchronized (topicsForHost) {\n+                removed = topicsForHost.remove(topic);\n+            }\n+            if (removed) {\n+                logger.debug(\"Removed topic: {} from host: {}.\",\n+                             topic.toStringUtf8(), host);\n+                if (topicsForHost.isEmpty()) {\n+                    // remove only topic list is empty\n+                    host2Topics.remove(host, EMPTY_TOPIC_SET);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long nextTxnId() {\n+        return globalCounter.incrementAndGet();\n+    }\n+\n+    // We need to deal with the possible problem of a PubSub request being\n+    // written to successfully to the server host but for some reason, the\n+    // ack message back never comes. What could happen is that the VoidCallback\n+    // stored in the ResponseHandler.txn2PublishData map will never be called.\n+    // We should have a configured timeout so if that passes from the time a\n+    // write was successfully done to the server, we can fail this async PubSub\n+    // transaction. The caller could possibly redo the transaction if needed at\n+    // a later time. Creating a timeout cleaner TimerTask to do this here.\n+    class PubSubRequestTimeoutTask extends TimerTask {\n+        /**\n+         * Implement the TimerTask's abstract run method.\n+         */\n+        @Override\n+        public void run() {\n+            if (isClosed()) {\n+                return;\n+            }\n+            logger.debug(\"Running the PubSubRequest Timeout Task\");\n+            // First check those non-subscription channels\n+            for (HChannel channel : host2NonSubscriptionChannels.getChannels()) {\n+                try {\n+                    HChannelHandler channelHandler =\n+                        HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                    channelHandler.checkTimeoutRequests();\n+                } catch (NoResponseHandlerException nrhe) {\n+                    continue;\n+                }\n+            }\n+            // Then check those subscription channels\n+            checkTimeoutRequestsOnSubscriptionChannels();\n+        }\n+    }\n+\n+    /**\n+     * Chekout the pub/sub requests on subscription channels.\n+     */\n+    protected abstract void checkTimeoutRequestsOnSubscriptionChannels();\n+\n+    @Override\n+    public boolean isClosed() {\n+        closedLock.readLock().lock();\n+        try {\n+            return closed; \n+        } finally {\n+            closedLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Close all subscription channels when close channel manager.\n+     */\n+    protected abstract void closeSubscriptionChannels();\n+\n+    @Override\n+    public void close() {\n+        logger.info(\"Shutting down the channels manager.\");\n+        closedLock.writeLock().lock();\n+        try {\n+            // Not first time to close\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        } finally {\n+            closedLock.writeLock().unlock();\n+        }\n+        clientTimer.cancel();\n+        // Clear all existed channels\n+        host2NonSubscriptionChannels.close();\n+\n+        // clear all subscription channels\n+        closeSubscriptionChannels();\n+\n+        // Clear out all Maps\n+        topic2Host.clear();\n+        host2Topics.clear();\n+    }\n+\n+}"},{"sha":"ab86f236091e4a2db5364bd392cc2ad537e3cedb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","status":"renamed","additions":24,"deletions":10,"changes":34,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/ClientChannelPipelineFactory.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -15,7 +15,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.hedwig.client.netty;\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.util.Map;\n \n import org.jboss.netty.channel.ChannelPipeline;\n import org.jboss.netty.channel.ChannelPipelineFactory;\n@@ -26,32 +28,44 @@\n import org.jboss.netty.handler.codec.protobuf.ProtobufEncoder;\n import org.jboss.netty.handler.ssl.SslHandler;\n \n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public abstract class ClientChannelPipelineFactory implements ChannelPipelineFactory {\n \n-public class ClientChannelPipelineFactory implements ChannelPipelineFactory {\n+    protected ClientConfiguration cfg;\n+    protected AbstractHChannelManager channelManager;\n+\n+    public ClientChannelPipelineFactory(ClientConfiguration cfg,\n+                                        AbstractHChannelManager channelManager) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+    }\n \n-    private HedwigClientImpl client;\n+    protected abstract Map<OperationType, AbstractResponseHandler> createResponseHandlers();\n \n-    public ClientChannelPipelineFactory(HedwigClientImpl client) {\n-        this.client = client;\n+    private HChannelHandler createHChannelHandler() {\n+        return new HChannelHandler(cfg, channelManager, createResponseHandlers());\n     }\n \n     // Retrieve a ChannelPipeline from the factory.\n     public ChannelPipeline getPipeline() throws Exception {\n         // Create a new ChannelPipline using the factory method from the\n         // Channels helper class.\n         ChannelPipeline pipeline = Channels.pipeline();\n-        if (client.getSslFactory() != null) {\n-            pipeline.addLast(\"ssl\", new SslHandler(client.getSslFactory().getEngine()));\n+        if (channelManager.getSslFactory() != null) {\n+            pipeline.addLast(\"ssl\", new SslHandler(channelManager.getSslFactory().getEngine()));\n         }\n-        pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(client.getConfiguration()\n-                         .getMaximumMessageSize(), 0, 4, 0, 4));\n+        pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(\n+                         cfg.getMaximumMessageSize(), 0, 4, 0, 4));\n         pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n \n         pipeline.addLast(\"protobufdecoder\", new ProtobufDecoder(PubSubProtocol.PubSubResponse.getDefaultInstance()));\n         pipeline.addLast(\"protobufencoder\", new ProtobufEncoder());\n \n-        pipeline.addLast(\"responsehandler\", new ResponseHandler(client));\n+        pipeline.addLast(\"responsehandler\", createHChannelHandler());\n         return pipeline;\n     }\n ","previous_filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ClientChannelPipelineFactory.java"},{"sha":"10c05ef666e6eb3cc706ee54eb509f30f2910622","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/DefaultServerChannel.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,92 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handle requests sent to default hub server. <b>DefaultServerChannel</b> would not\n+ * be used as a channel to send requests directly. It just takes the responsibility to\n+ * connect to the default server. After the underlying netty channel is established,\n+ * it would call {@link HChannelManager#submitOpThruChannel()} to send requests thru\n+ * the underlying netty channel.\n+ */\n+class DefaultServerChannel extends HChannelImpl {\n+\n+    private static Logger logger = LoggerFactory.getLogger(DefaultServerChannel.class);\n+\n+    DefaultServerChannel(InetSocketAddress host, AbstractHChannelManager channelManager) {\n+        super(host, channelManager);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[DefaultServer: \").append(host).append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void submitOp(final PubSubData pubSubData) {\n+        // for each pub/sub request sent to default hub server\n+        // we would establish a fresh connection for it\n+        ClientChannelPipelineFactory pipelineFactory;\n+        if (OperationType.PUBLISH.equals(pubSubData.operationType) ||\n+            OperationType.UNSUBSCRIBE.equals(pubSubData.operationType)) {\n+            pipelineFactory = channelManager.getNonSubscriptionChannelPipelineFactory();\n+        } else {\n+            pipelineFactory = channelManager.getSubscriptionChannelPipelineFactory();\n+        }\n+        ChannelFuture future = connect(host, pipelineFactory);\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                // If the channel has been closed, there is no need to proceed with any callback\n+                // logic here.\n+                if (closed) {\n+                    future.getChannel().close();\n+                    return;\n+                }\n+\n+                // Check if the connection to the server was done successfully.\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error connecting to host {}.\", host);\n+                    future.getChannel().close();\n+\n+                    retryOrFailOp(pubSubData);\n+                    // Finished with failure logic so just return.\n+                    return;\n+                }\n+                logger.debug(\"Connected to host {} for pubSubData: {}\",\n+                             va(host, pubSubData));\n+                channelManager.submitOpThruChannel(pubSubData, future.getChannel());\n+            }\n+        });\n+    }\n+\n+}"},{"sha":"7753c6e85e6b601812e657d8a0ed070cc50d77ba","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.ChannelPipelineCoverage;\n+import org.jboss.netty.channel.ChannelStateEvent;\n+import org.jboss.netty.channel.ExceptionEvent;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelHandler;\n+import org.jboss.netty.handler.ssl.SslHandler;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.exceptions.PubSubException.UncertainStateException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+@ChannelPipelineCoverage(\"all\")\n+public class HChannelHandler extends SimpleChannelHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HChannelHandler.class);\n+\n+    // Concurrent Map to store for each async PubSub request, the txn ID\n+    // and the corresponding PubSub call's data which stores the VoidCallback to\n+    // invoke when we receive a PubSub ack response from the server.\n+    // This is specific to this instance of the HChannelHandler which is\n+    // tied to a specific netty Channel Pipeline.\n+    private final ConcurrentMap<Long, PubSubData> txn2PubSubData =\n+        new ConcurrentHashMap<Long, PubSubData>();\n+\n+    // Boolean indicating if we closed the channel this HChannelHandler is\n+    // attached to explicitly or not. If so, we do not need to do the\n+    // channel disconnected logic here.\n+    private volatile boolean channelClosedExplicitly = false;\n+\n+    private final AbstractHChannelManager channelManager;\n+    private final ClientConfiguration cfg;\n+\n+    private final Map<OperationType, AbstractResponseHandler> handlers;\n+    private final SubscribeResponseHandler subHandler;\n+\n+    public HChannelHandler(ClientConfiguration cfg,\n+                           AbstractHChannelManager channelManager,\n+                           Map<OperationType, AbstractResponseHandler> handlers) {\n+        this.cfg = cfg;\n+        this.channelManager = channelManager;\n+        this.handlers = handlers;\n+        subHandler = (SubscribeResponseHandler) handlers.get(OperationType.SUBSCRIBE);\n+    }\n+\n+    public SubscribeResponseHandler getSubscribeResponseHandler() {\n+        return subHandler;\n+    }\n+\n+    public void removeTxn(long txnId) {\n+        txn2PubSubData.remove(txnId);\n+    }\n+\n+    public void addTxn(long txnId, PubSubData pubSubData) {\n+        txn2PubSubData.put(txnId, pubSubData);\n+    }\n+\n+    @Override\n+    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+        // If the Message is not a PubSubResponse, just send it upstream and let\n+        // something else handle it.\n+        if (!(e.getMessage() instanceof PubSubResponse)) {\n+            ctx.sendUpstream(e);\n+            return;\n+        }\n+        // Retrieve the PubSubResponse from the Message that was sent by the\n+        // server.\n+        PubSubResponse response = (PubSubResponse) e.getMessage();\n+        logger.debug(\"Response received from host: {}, response: {}.\",\n+                     va(NetUtils.getHostFromChannel(ctx.getChannel()), response));\n+\n+        // Determine if this PubSubResponse is an ack response for a PubSub\n+        // Request or if it is a message being pushed to the client subscriber.\n+        if (response.hasMessage()) {\n+            // Subscribed messages being pushed to the client so handle/consume\n+            // it and return.\n+            if (null == subHandler) {\n+                logger.error(\"Received message from a non-subscription channel : {}\",\n+                             response);\n+            } else {\n+                subHandler.handleSubscribeMessage(response);\n+            }\n+            return;\n+        }\n+\n+        // Response is an ack to a prior PubSubRequest so first retrieve the\n+        // PubSub data for this txn.\n+        PubSubData pubSubData = txn2PubSubData.remove(response.getTxnId());\n+\n+        // Validate that the PubSub data for this txn is stored. If not, just\n+        // log an error message and return since we don't know how to handle\n+        // this.\n+        if (pubSubData == null) {\n+            logger.error(\"PubSub Data was not found for PubSubResponse: {}\", response);\n+            return;\n+        }\n+\n+        // Store the topic2Host mapping if this wasn't a server redirect. We'll\n+        // assume that if the server was able to have an open Channel connection\n+        // to the client, and responded with an ack message other than the\n+        // NOT_RESPONSIBLE_FOR_TOPIC one, it is the correct topic master.\n+        if (!response.getStatusCode().equals(StatusCode.NOT_RESPONSIBLE_FOR_TOPIC)) {\n+            // Retrieve the server host that we've connected to and store the\n+            // mapping from the topic to this host. For all other non-redirected\n+            // server statuses, we consider that as a successful connection to the\n+            // correct topic master.\n+            InetSocketAddress host = NetUtils.getHostFromChannel(ctx.getChannel());\n+            channelManager.storeTopic2HostMapping(pubSubData.topic, host);\n+        }\n+\n+        // Depending on the operation type, call the appropriate handler.\n+        logger.debug(\"Handling a {} response: {}, pubSubData: {}, host: {}.\",\n+                     va(pubSubData.operationType, response, pubSubData, ctx.getChannel()));\n+        AbstractResponseHandler respHandler = handlers.get(pubSubData.operationType);\n+        if (null == respHandler) {\n+            // The above are the only expected PubSubResponse messages received\n+            // from the server for the various client side requests made.\n+            logger.error(\"Response received from server is for an unhandled operation {}, txnId: {}.\",\n+                         va(pubSubData.operationType, response.getTxnId()));\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new UnexpectedConditionException(\"Can't find response handler for operation \"\n+                                                 + pubSubData.operationType));\n+            return;\n+        }\n+        respHandler.handleResponse(response, pubSubData, ctx.getChannel());\n+    }\n+\n+    public void checkTimeoutRequests() {\n+        long curTime = System.currentTimeMillis();\n+        long timeoutInterval = cfg.getServerAckResponseTimeout();\n+        for (PubSubData pubSubData : txn2PubSubData.values()) {\n+            checkTimeoutRequest(pubSubData, curTime, timeoutInterval);\n+        }\n+    }\n+\n+    private void checkTimeoutRequest(PubSubData pubSubData,\n+                                     long curTime, long timeoutInterval) {\n+        if (curTime > pubSubData.requestWriteTime + timeoutInterval) {\n+            // Current PubSubRequest has timed out so remove it from the\n+            // ResponseHandler's map and invoke the VoidCallback's\n+            // operationFailed method.\n+            logger.error(\"Current PubSubRequest has timed out for pubSubData: \" + pubSubData);\n+            txn2PubSubData.remove(pubSubData.txnId);\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new UncertainStateException(\"Server ack response never received so PubSubRequest has timed out!\"));\n+        }\n+    }\n+\n+    // Logic to deal with what happens when a Channel to a server host is\n+    // disconnected.\n+    @Override\n+    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        // If this channel was closed explicitly by the client code,\n+        // we do not need to do any of this logic. This could happen\n+        // for redundant Publish channels created or redirected subscribe\n+        // channels that are not used anymore or when we shutdown the\n+        // client and manually close all of the open channels.\n+        // Also don't do any of the disconnect logic if the client has stopped.\n+        if (channelClosedExplicitly || channelManager.isClosed()) {\n+            return;\n+        }\n+\n+        // Make sure the host retrieved is not null as there could be some weird\n+        // channel disconnect events happening during a client shutdown.\n+        // If it is, just return as there shouldn't be anything we need to do.\n+        InetSocketAddress host = NetUtils.getHostFromChannel(ctx.getChannel());\n+        if (host == null) {\n+            return;\n+        }\n+\n+        logger.info(\"Channel {} was disconnected to host {}.\",\n+                    va(ctx.getChannel(), host));\n+\n+        // If this Channel was used for Publish and Unsubscribe flows, just\n+        // remove it from the HewdigPublisher's host2Channel map. We will\n+        // re-establish a Channel connection to that server when the next\n+        // publish/unsubscribe request to a topic that the server owns occurs.\n+\n+        // Now determine what type of operation this channel was used for.\n+        if (null == subHandler) {\n+            channelManager.onNonSubscriptionChannelDisconnected(host, ctx.getChannel());\n+        } else {\n+            channelManager.onSubscriptionChannelDisconnected(host, ctx.getChannel());\n+        }\n+\n+        // Finally, all of the PubSubRequests that are still waiting for an ack\n+        // response from the server need to be removed and timed out. Invoke the\n+        // operationFailed callbacks on all of them. Use the\n+        // UncertainStateException since the server did receive the request but\n+        // we're not sure of the state of the request since the ack response was\n+        // never received.\n+        for (PubSubData pubSubData : txn2PubSubData.values()) {\n+            logger.debug(\"Channel disconnected so invoking the operationFailed callback for pubSubData: {}\",\n+                         pubSubData);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new UncertainStateException(\n+                                                     \"Server ack response never received before server connection disconnected!\"));\n+        }\n+        txn2PubSubData.clear();\n+    }\n+\n+    // Logic to deal with what happens when a Channel to a server host is\n+    // connected. This is needed if the client is using an SSL port to\n+    // communicate with the server. If so, we need to do the SSL handshake here\n+    // when the channel is first connected.\n+    @Override\n+    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        // No need to initiate the SSL handshake if we are closing this channel\n+        // explicitly or the client has been stopped.\n+        if (cfg.isSSLEnabled() && !channelClosedExplicitly && !channelManager.isClosed()) {\n+            logger.debug(\"Initiating the SSL handshake\");\n+            ctx.getPipeline().get(SslHandler.class).handshake(e.getChannel());\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {\n+        logger.error(\"Exception caught on client channel\", e.getCause());\n+        e.getChannel().close();\n+    }\n+\n+    public void closeExplicitly() {\n+        // TODO: BOOKKEEPER-350 : Handle consume buffering, etc here - in a different patch\n+        channelClosedExplicitly = true;\n+    }\n+}"},{"sha":"fd58747b87182b2df95e3a5d25ddfd609e3bb0a5","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","status":"added","additions":371,"deletions":0,"changes":371,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelImpl.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,371 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.jboss.netty.bootstrap.ClientBootstrap;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.util.HedwigSocketAddress;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide a wrapper over netty channel for Hedwig operations.\n+ */\n+public class HChannelImpl implements HChannel {\n+\n+    private static Logger logger = LoggerFactory.getLogger(HChannelImpl.class);\n+\n+    enum State {\n+        DISCONNECTED,\n+        CONNECTING,\n+        CONNECTED,\n+    };\n+\n+    InetSocketAddress host;\n+    final AbstractHChannelManager channelManager;\n+    final ClientChannelPipelineFactory pipelineFactory;\n+    volatile Channel channel;\n+    volatile State state;\n+\n+    // Indicates whether the channel is closed or not.\n+    volatile boolean closed = false;\n+    // Queue the pubsub requests when the channel is not connected.\n+    Queue<PubSubData> pendingOps = new ArrayDeque<PubSubData>();\n+\n+    /**\n+     * Create a un-established channel with provided target <code>host</code>.\n+     *\n+     * @param host\n+     *          Target host address.\n+     * @param channelManager\n+     *          Channel manager manages the channels.\n+     */\n+    protected HChannelImpl(InetSocketAddress host, AbstractHChannelManager channelManager) {\n+        this(host, channelManager, null);\n+    }\n+\n+    public HChannelImpl(InetSocketAddress host, AbstractHChannelManager channelManager,\n+                        ClientChannelPipelineFactory pipelineFactory) {\n+        this(host, null, channelManager, pipelineFactory);\n+        state = State.DISCONNECTED;\n+    }\n+\n+    /**\n+     * Create a <code>HChannel</code> with an established netty channel.\n+     *\n+     * @param host\n+     *          Target host address.\n+     * @param channel\n+     *          Established Netty channel.\n+     * @param channelManager\n+     *          Channel manager manages the channels.\n+     */\n+    public HChannelImpl(InetSocketAddress host, Channel channel,\n+                        AbstractHChannelManager channelManager,\n+                        ClientChannelPipelineFactory pipelineFactory) {\n+        this.host = host;\n+        this.channel = channel;\n+        this.channelManager = channelManager;\n+        this.pipelineFactory = pipelineFactory;\n+        state = State.CONNECTED;\n+    }\n+\n+    @Override\n+    public void submitOp(PubSubData pubSubData) {\n+        boolean doOpNow = false;\n+\n+        // common case without lock first\n+        if (null != channel && State.CONNECTED == state) {\n+            doOpNow = true;\n+        } else {\n+            synchronized (this) {\n+                // check channel & state again under lock\n+                if (null != channel && State.CONNECTED == state) {\n+                    doOpNow = true;\n+                } else {\n+                    // if reached here, channel is either null (first connection attempt),\n+                    // or the channel is disconnected. Connection attempt is still in progress,\n+                    // queue up this op. Op will be executed when connection attempt either\n+                    // fails or succeeds\n+                    pendingOps.add(pubSubData);\n+                }\n+            }\n+            if (!doOpNow) {\n+                // start connection attempt to server\n+                connect();\n+            }\n+        }\n+        if (doOpNow) {\n+            executeOpAfterConnected(pubSubData); \n+        }\n+    }\n+\n+    /**\n+     * Execute pub/sub operation after the underlying channel is connected.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Operation\n+     */\n+    private void executeOpAfterConnected(PubSubData pubSubData) {\n+        PubSubRequest.Builder reqBuilder =\n+            NetUtils.buildPubSubRequest(channelManager.nextTxnId(), pubSubData);\n+        writePubSubRequest(pubSubData, reqBuilder.build());\n+    }\n+\n+    @Override\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    private void writePubSubRequest(PubSubData pubSubData, PubSubRequest pubSubRequest) {\n+        if (closed || null == channel || State.CONNECTED != state) {\n+            retryOrFailOp(pubSubData);\n+            return;\n+        }\n+\n+        // Before we do the write, store this information into the\n+        // ResponseHandler so when the server responds, we know what\n+        // appropriate Callback Data to invoke for the given txn ID.\n+        try {\n+            getHChannelHandlerFromChannel(channel)\n+                .addTxn(pubSubData.txnId, pubSubData);\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {} when writing request.\"\n+                        + \" It might already disconnect.\", channel);\n+            return;\n+        }\n+\n+        // Finally, write the pub/sub request through the Channel.\n+        logger.debug(\"Writing a {} request to host: {} for pubSubData: {}.\",\n+                     va(pubSubData.operationType, host, pubSubData));\n+        ChannelFuture future = channel.write(pubSubRequest);\n+        future.addListener(new WriteCallback(pubSubData, channelManager));\n+    }\n+\n+    /**\n+     * Re-submit operation to default server or fail it.\n+     *\n+     * @param pubSubData\n+     *          Pub/Sub Operation\n+     */\n+    protected void retryOrFailOp(PubSubData pubSubData) {\n+        // if we were not able to connect to the host, it could be down\n+        ByteString hostString = ByteString.copyFromUtf8(HedwigSocketAddress.sockAddrStr(host));\n+        if (pubSubData.connectFailedServers != null &&\n+            pubSubData.connectFailedServers.contains(hostString)) {\n+            // We've already tried to connect to this host before so just\n+            // invoke the operationFailed callback.\n+            logger.error(\"Error connecting to host {} more than once so fail the request: {}\",\n+                         va(host, pubSubData));\n+            pubSubData.getCallback().operationFailed(pubSubData.context,\n+                new CouldNotConnectException(\"Could not connect to host: \" + host));\n+        } else {\n+            logger.error(\"Retry to connect to default hub server again for pubSubData: {}\",\n+                         pubSubData);\n+            // Keep track of this current server that we failed to connect\n+            // to but retry the request on the default server host/VIP.\n+            if (pubSubData.connectFailedServers == null) {\n+                pubSubData.connectFailedServers = new LinkedList<ByteString>();\n+            }\n+            pubSubData.connectFailedServers.add(hostString);\n+            channelManager.submitOpToDefaultServer(pubSubData);\n+        }\n+    }\n+\n+    private void onChannelConnected(ChannelFuture future) {\n+        Queue<PubSubData> oldPendingOps;\n+        synchronized (this) {\n+            // if the channel is closed by client, do nothing\n+            if (closed) {\n+                future.getChannel().close();\n+                return;\n+            }\n+            state = State.CONNECTED;\n+            channel = future.getChannel();\n+            host = NetUtils.getHostFromChannel(channel);\n+            oldPendingOps = pendingOps;\n+            pendingOps = new ArrayDeque<PubSubData>();\n+        }\n+        for (PubSubData op : oldPendingOps) {\n+            executeOpAfterConnected(op);\n+        }\n+    }\n+\n+    private void onChannelConnectFailure() {\n+        Queue<PubSubData> oldPendingOps;\n+        synchronized (this) {\n+            state = State.DISCONNECTED;\n+            channel = null;\n+            oldPendingOps = pendingOps;\n+            pendingOps = new ArrayDeque<PubSubData>();\n+        }\n+        for (PubSubData op : oldPendingOps) {\n+            retryOrFailOp(op);\n+        }\n+    }\n+\n+    private void connect() {\n+        synchronized (this) {\n+            if (State.CONNECTING == state ||\n+                State.CONNECTED == state) {\n+                return;\n+            }\n+            state = State.CONNECTING;\n+        }\n+        // Start the connection attempt to the input server host.\n+        ChannelFuture future = connect(host, pipelineFactory);\n+        future.addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                // If the channel has been closed, there is no need to proceed with any\n+                // callback logic here.\n+                if (closed) {\n+                    future.getChannel().close();\n+                    return;\n+                }\n+\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error connecting to host {}.\", host);\n+                    future.getChannel().close();\n+\n+                    // if we were not able to connect to the host, it could be down.\n+                    onChannelConnectFailure();\n+                    return;\n+                }\n+                logger.debug(\"Connected to server {}.\", host);\n+                // Now that we have connected successfully to the server, execute all queueing\n+                // requests.\n+                onChannelConnected(future);\n+            }\n+\n+        });\n+    }\n+\n+    /**\n+     * This is a helper method to do the connect attempt to the server given the\n+     * inputted host/port. This can be used to connect to the default server\n+     * host/port which is the VIP. That will pick a server in the cluster at\n+     * random to connect to for the initial PubSub attempt (with redirect logic\n+     * being done at the server side). Additionally, this could be called after\n+     * the client makes an initial PubSub attempt at a server, and is redirected\n+     * to the one that is responsible for the topic. Once the connect to the\n+     * server is done, we will perform the corresponding PubSub write on that\n+     * channel.\n+     *\n+     * @param serverHost\n+     *            Input server host to connect to of type InetSocketAddress\n+     * @param pipelineFactory\n+     *            PipelineFactory to create response handler to handle responses from\n+     *            underlying channel.\n+     */\n+    protected ChannelFuture connect(InetSocketAddress serverHost,\n+                                    ClientChannelPipelineFactory pipelineFactory) {\n+        logger.debug(\"Connecting to host {} ...\", serverHost);\n+        // Set up the ClientBootStrap so we can create a new Channel connection\n+        // to the server.\n+        ClientBootstrap bootstrap = new ClientBootstrap(channelManager.getChannelFactory());\n+        bootstrap.setPipelineFactory(pipelineFactory);\n+        bootstrap.setOption(\"tcpNoDelay\", true);\n+        bootstrap.setOption(\"keepAlive\", true);\n+\n+        // Start the connection attempt to the input server host.\n+        return bootstrap.connect(serverHost);\n+    }\n+\n+    @Override\n+    public void close(boolean wait) {\n+        synchronized (this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+        }\n+        if (null == channel) {\n+            return;\n+        }\n+        try {\n+            getHChannelHandlerFromChannel(channel).closeExplicitly();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No channel handler found for channel {} when closing it.\",\n+                        channel);\n+        }\n+        if (wait) {\n+            channel.close().awaitUninterruptibly();\n+        } else {\n+            channel.close();\n+        }\n+        channel = null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[HChannel: host - \").append(host)\n+          .append(\", channel - \").append(channel)\n+          .append(\", pending reqs - \").append(pendingOps.size())\n+          .append(\", closed - \").append(closed).append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void close() {\n+        close(false);\n+    }\n+\n+    /**\n+     * Helper static method to get the ResponseHandler instance from a Channel\n+     * via the ChannelPipeline it is associated with. The assumption is that the\n+     * last ChannelHandler tied to the ChannelPipeline is the ResponseHandler.\n+     *\n+     * @param channel\n+     *            Channel we are retrieving the ResponseHandler instance for\n+     * @return ResponseHandler Instance tied to the Channel's Pipeline\n+     */\n+    public static HChannelHandler getHChannelHandlerFromChannel(Channel channel)\n+    throws NoResponseHandlerException {\n+        if (null == channel) {\n+            throw new NoResponseHandlerException(\"Received a null value for the channel. Cannot retrieve the response handler\");\n+        }\n+\n+        HChannelHandler handler = (HChannelHandler) channel.getPipeline().getLast();\n+        if (null == handler) {\n+            throw new NoResponseHandlerException(\"Could not retrieve the response handler from the channel's pipeline.\");\n+        }\n+        return handler;\n+    }\n+\n+}"},{"sha":"a91bbf8dbb7bb64edbb884522c09f666959c2fe6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/NonSubscriptionChannelPipelineFactory.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.PublishResponseHandler;\n+import org.apache.hedwig.client.handlers.UnsubscribeResponseHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class NonSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public NonSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                 AbstractHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.PUBLISH,\n+                     new PublishResponseHandler(cfg, channelManager));\n+        handlers.put(OperationType.UNSUBSCRIBE,\n+                     new UnsubscribeResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"26dd15308fe645afeeaf01d011be2a1f775bf080","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","status":"renamed","additions":17,"deletions":13,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/WriteCallback.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.hedwig.client.netty;\n+package org.apache.hedwig.client.netty.impl;\n \n import java.net.InetSocketAddress;\n import java.util.LinkedList;\n@@ -27,8 +27,9 @@\n import org.jboss.netty.channel.ChannelFutureListener;\n \n import com.google.protobuf.ByteString;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.NetUtils;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.util.HedwigSocketAddress;\n \n@@ -38,38 +39,41 @@\n \n     // Private member variables\n     private PubSubData pubSubData;\n-    private final HedwigClientImpl client;\n-    private final ClientConfiguration cfg;\n+    private final HChannelManager channelManager;\n \n     // Constructor\n-    public WriteCallback(PubSubData pubSubData, HedwigClientImpl client) {\n+    public WriteCallback(PubSubData pubSubData,\n+                         HChannelManager channelManager) {\n         super();\n         this.pubSubData = pubSubData;\n-        this.client = client;\n-        this.cfg = client.getConfiguration();\n+        this.channelManager = channelManager;\n     }\n \n     public void operationComplete(ChannelFuture future) throws Exception {\n         // If the client has stopped, there is no need to proceed\n         // with any callback logic here.\n-        if (client.hasStopped()) {\n+        if (channelManager.isClosed()) {\n             future.getChannel().close();\n             return;\n         }\n \n         // When the write operation to the server is done, we just need to check\n         // if it was successful or not.\n-        InetSocketAddress host = HedwigClientImpl.getHostFromChannel(future.getChannel());\n+        InetSocketAddress host = NetUtils.getHostFromChannel(future.getChannel());\n         if (!future.isSuccess()) {\n-            logger.error(\"Error writing on channel to host: \" + host);\n+            logger.error(\"Error writing on channel to host: {}\", host);\n             // On a write failure for a PubSubRequest, we also want to remove\n             // the saved txnId to PubSubData in the ResponseHandler. These\n             // requests will not receive an ack response from the server\n             // so there is no point storing that information there anymore.\n             try {\n-                HedwigClientImpl.getResponseHandlerFromChannel(future.getChannel()).txn2PubSubData.remove(pubSubData.txnId);\n+                HChannelHandler channelHandler = \n+                    HChannelImpl.getHChannelHandlerFromChannel(future.getChannel());\n+                channelHandler.removeTxn(pubSubData.txnId);\n+                channelHandler.closeExplicitly();\n             } catch (NoResponseHandlerException e) {\n-                // We just couldn't remove the transaction ID's mapping. The handler was null, so this has been reset anyway.\n+                // We just couldn't remove the transaction ID's mapping.\n+                // The handler was null, so this has been reset anyway.\n                 logger.warn(\"Could not find response handler to remove txnId mapping to pubsub data. Ignoring.\");\n             }\n \n@@ -93,7 +97,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 if (pubSubData.writeFailedServers == null)\n                     pubSubData.writeFailedServers = new LinkedList<ByteString>();\n                 pubSubData.writeFailedServers.add(hostString);\n-                client.doConnect(pubSubData, cfg.getDefaultServerHost());\n+                channelManager.submitOpToDefaultServer(pubSubData);\n             }\n         } else {\n             // Now that the write to the server is done, we have to wait for it","previous_filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java"},{"sha":"592d8b61ff9d61ee0a5e158c37a9ff53ee282c5d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","status":"added","additions":308,"deletions":0,"changes":308,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleHChannelManager.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * Simple HChannel Manager which establish a connection for each subscription.\n+ */\n+public class SimpleHChannelManager extends AbstractHChannelManager {\n+\n+    private static Logger logger = LoggerFactory.getLogger(SimpleHChannelManager.class);\n+\n+    // Concurrent Map to store the cached Channel connections on the client side\n+    // to a server host for a given Topic + SubscriberId combination. For each\n+    // TopicSubscriber, we want a unique Channel connection to the server for\n+    // it. We can also get the ResponseHandler tied to the Channel via the\n+    // Channel Pipeline.\n+    protected final CleanupChannelMap<TopicSubscriber> topicSubscriber2Channel;\n+\n+    // Concurrent Map to store Message handler for each topic + sub id combination.\n+    // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n+    // user set when connection is recovered\n+    protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler\n+        = new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n+\n+    // PipelineFactory to create subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory subscriptionChannelPipelineFactory;\n+\n+    public SimpleHChannelManager(ClientConfiguration cfg,\n+                                 ChannelFactory socketFactory) {\n+        super(cfg, socketFactory);\n+        topicSubscriber2Channel = new CleanupChannelMap<TopicSubscriber>();\n+        this.subscriptionChannelPipelineFactory =\n+            new SimpleSubscriptionChannelPipelineFactory(cfg, this);\n+    }\n+\n+    @Override\n+    protected ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory() {\n+        return subscriptionChannelPipelineFactory;\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(Channel channel) {\n+        // for simple channel, we don't store subscription channel now\n+        // we store it until we received success response\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        return new HChannelImpl(host, channel, this,\n+                                getSubscriptionChannelPipelineFactory());\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(InetSocketAddress host) {\n+        // for simple channel, we don't store subscription channel now\n+        // we store it until we received success response\n+        return new HChannelImpl(host, this,\n+                                getSubscriptionChannelPipelineFactory());\n+    }\n+\n+    protected HChannel storeSubscriptionChannel(TopicSubscriber topicSubscriber,\n+                                                Channel channel) {\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        return topicSubscriber2Channel.addChannel(topicSubscriber, newHChannel);\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannel(InetSocketAddress host) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber subscriber) {\n+        HChannel channel = topicSubscriber2Channel.getChannel(subscriber);\n+        if (null != channel) {\n+            // there is no channel established for this subscription\n+            return channel;\n+        } else {\n+            InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+            if (null == host) {\n+                return null;\n+            } else {\n+                channel = getSubscriptionChannel(host);\n+                if (null == channel) {\n+                    channel = createAndStoreSubscriptionChannel(host);\n+                }\n+                return channel;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                     Channel channel) {\n+        logger.info(\"Subscription Channel {} disconnected from {}.\",\n+                    va(channel, host));\n+        try {\n+            // get hchannel handler\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            channelHandler.getSubscribeResponseHandler()\n+                          .onChannelDisconnected(host, channel);\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {} when it disconnected.\",\n+                        channel);\n+        }\n+    }\n+\n+    @Override\n+    public SubscribeResponseHandler getSubscribeResponseHandler(TopicSubscriber topicSubscriber) {\n+        HChannel hChannel = topicSubscriber2Channel.getChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            return null;\n+        }\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            return null;\n+        }\n+        try {\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            return channelHandler.getSubscribeResponseHandler();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {}, topic subscriber {}.\",\n+                        channel, topicSubscriber);\n+            return null;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, messageHandler, false);\n+    }\n+\n+    protected void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, null, true);\n+    }\n+\n+    private void startDelivery(TopicSubscriber topicSubscriber,\n+                               MessageHandler messageHandler, boolean restart)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        // Make sure we know about this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n+        if (restart) {\n+            // restart using existing msg handler \n+            messageHandler = existedMsgHandler;\n+        } else {\n+            // some has started delivery but not stop it\n+            if (null != existedMsgHandler) {\n+                throw new AlreadyStartDeliveryException(\"A message handler has been started for topic subscriber \" + topicSubscriber);\n+            }\n+            if (messageHandler != null) {\n+                if (null != topicSubscriber2MessageHandler.putIfAbsent(topicSubscriber, messageHandler)) {\n+                    throw new AlreadyStartDeliveryException(\"Someone is also starting delivery for topic subscriber \" + topicSubscriber);\n+                }\n+            }\n+        }\n+\n+        // tell subscribe response handler to start delivering messages for topicSubscriber\n+        subscribeResponseHandler.startDelivery(topicSubscriber, messageHandler);\n+    }\n+\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        // Make sure we know that this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        // tell subscribe response handler to stop delivering messages for a given topic subscriber\n+        topicSubscriber2MessageHandler.remove(topicSubscriber);\n+        subscribeResponseHandler.stopDelivery(topicSubscriber);\n+    }\n+                            \n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        HChannel hChannel = topicSubscriber2Channel.removeChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            logger.warn(\"Trying to close a subscription when we don't have a subscribe channel cached for {}\",\n+                        topicSubscriber);\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+\n+        try {\n+            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found when closing {}'s channel {}.\",\n+                        channel, topicSubscriber);\n+        }\n+        ChannelFuture future = channel.close();\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Failed to close the subscription channel for {}\",\n+                                 topicSubscriber);\n+                    callback.operationFailed(context, new ServiceDownException(\n+                        \"Failed to close the subscription channel for \" + topicSubscriber));\n+                } else {\n+                    callback.operationFinished(context, (ResponseBody)null);\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void checkTimeoutRequestsOnSubscriptionChannels() {\n+        // timeout task may be started before constructing topicSubscriber2Channel\n+        if (null == topicSubscriber2Channel) {\n+            return;\n+        }\n+        for (HChannel channel : topicSubscriber2Channel.getChannels()) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                channelHandler.checkTimeoutRequests();\n+            } catch (NoResponseHandlerException nrhe) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void closeSubscriptionChannels() {\n+        topicSubscriber2Channel.close();\n+    }\n+}"},{"sha":"61b3b1ac362e9bf68faee44485e0c9de3c9b09bd","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"added","additions":538,"deletions":0,"changes":538,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,538 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Collections;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class SimpleSubscribeResponseHandler extends SubscribeResponseHandler {\n+\n+    private static Logger logger = LoggerFactory.getLogger(SimpleSubscribeResponseHandler.class);\n+\n+    // Member variables used when this ResponseHandler is for a Subscribe\n+    // channel. We need to be able to consume messages sent back to us from\n+    // the server, and to also recreate the Channel connection if it ever goes\n+    // down. For that, we need to store the original PubSubData for the\n+    // subscribe request, and also the MessageHandler that was registered when\n+    // delivery of messages started for the subscription.\n+    private volatile PubSubData origSubData;\n+    private volatile TopicSubscriber origTopicSubscriber;\n+    private SubscriptionPreferences preferences;\n+    private Channel subscribeChannel;\n+    private MessageHandler messageHandler;\n+    // Counter for the number of consumed messages so far to buffer up before we\n+    // send the Consume message back to the server along with the last/largest\n+    // message seq ID seen so far in that batch.\n+    private int numConsumedMessagesInBuffer = 0;\n+    private MessageSeqId lastMessageSeqId;\n+    // Queue used for subscribes when the MessageHandler hasn't been registered\n+    // yet but we've already received subscription messages from the server.\n+    // This will be lazily created as needed.\n+    private Queue<Message> subscribeMsgQueue;\n+    // Set to store all of the outstanding subscribed messages that are pending\n+    // to be consumed by the client app's MessageHandler. If this ever grows too\n+    // big (e.g. problem at the client end for message consumption), we can\n+    // throttle things by temporarily setting the Subscribe Netty Channel\n+    // to not be readable. When the Set has shrunk sufficiently, we can turn the\n+    // channel back on to read new messages.\n+    private Set<Message> outstandingMsgSet;\n+\n+    private SimpleHChannelManager sChannelManager;\n+\n+    protected SimpleSubscribeResponseHandler(ClientConfiguration cfg,\n+                                             HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        sChannelManager = (SimpleHChannelManager) channelManager;\n+    }\n+\n+    protected HChannelManager getHChannelManager() {\n+        return this.sChannelManager;\n+    }\n+\n+    protected ClientConfiguration getConfiguration() {\n+        return cfg;\n+    }\n+\n+    protected MessageHandler getMessageHandler() {\n+        return messageHandler;\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        // If this was not a successful response to the Subscribe request, we\n+        // won't be using the Netty Channel created so just close it.\n+        if (!response.getStatusCode().equals(StatusCode.SUCCESS)) {\n+            HChannelImpl.getHChannelHandlerFromChannel(channel).closeExplicitly();\n+            channel.close();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n+                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n+        }\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            // Store the original PubSubData used to create this successful\n+            // Subscribe request.\n+            origSubData = pubSubData;\n+            origTopicSubscriber = new TopicSubscriber(pubSubData.topic,\n+                                                      pubSubData.subscriberId);\n+            synchronized(this) {\n+                // For successful Subscribe requests, store this Channel locally\n+                // and set it to not be readable initially.\n+                // This way we won't be delivering messages for this topic\n+                // subscription until the client explicitly says so.\n+                subscribeChannel = channel;\n+                subscribeChannel.setReadable(false);\n+                if (response.hasResponseBody()) {\n+                    ResponseBody respBody = response.getResponseBody(); \n+                    if (respBody.hasSubscribeResponse()) {\n+                        SubscribeResponse resp = respBody.getSubscribeResponse();\n+                        if (resp.hasPreferences()) {\n+                            preferences = resp.getPreferences();\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Receive subscription preferences for {} : {}\",\n+                                             va(origTopicSubscriber,\n+                                                SubscriptionStateUtils.toString(preferences)));\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Store the mapping for the TopicSubscriber to the Channel.\n+                // This is so we can control the starting and stopping of\n+                // message deliveries from the server on that Channel. Store\n+                // this only on a successful ack response from the server.\n+                sChannelManager.storeSubscriptionChannel(origTopicSubscriber,\n+                                                                    channel);\n+\n+                // Lazily create the Set (from a concurrent hashmap) to keep track\n+                // of outstanding Messages to be consumed by the client app. At this\n+                // stage, delivery for that topic hasn't started yet so creation of\n+                // this Set should be thread safe. We'll create the Set with an initial\n+                // capacity equal to the configured parameter for the maximum number of\n+                // outstanding messages to allow. The load factor will be set to\n+                // 1.0f which means we'll only rehash and allocate more space if\n+                // we ever exceed the initial capacity. That should be okay\n+                // because when that happens, things are slow already and piling\n+                // up on the client app side to consume messages.\n+                outstandingMsgSet = Collections.newSetFromMap(\n+                        new ConcurrentHashMap<Message,Boolean>(\n+                                cfg.getMaximumOutstandingMessages(), 1.0f));\n+            }\n+            // Response was success so invoke the callback's operationFinished\n+            // method.\n+            pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            break;\n+        case CLIENT_ALREADY_SUBSCRIBED:\n+            // For Subscribe requests, the server says that the client is\n+            // already subscribed to it.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n+                                                     \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                     + pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original Subscribe\n+            // Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: {}\", response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a status code of: \" + response.getStatusCode()));\n+            break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n+                         va(response, origTopicSubscriber));\n+        }\n+        Message message = response.getMessage();\n+\n+        synchronized (this) {\n+            // Consume the message asynchronously that the client is subscribed\n+            // to. Do this only if delivery for the subscription has started and\n+            // a MessageHandler has been registered for the TopicSubscriber.\n+            if (messageHandler != null) {\n+                asyncMessageDeliver(origTopicSubscriber, message);\n+            } else {\n+                // MessageHandler has not yet been registered so queue up these\n+                // messages for the Topic Subscription. Make the initial lazy\n+                // creation of the message queue thread safe just so we don't\n+                // run into a race condition where two simultaneous threads process\n+                // a received message and both try to create a new instance of\n+                // the message queue. Performance overhead should be okay\n+                // because the delivery of the topic has not even started yet\n+                // so these messages are not consumed and just buffered up here.\n+                if (subscribeMsgQueue == null)\n+                    subscribeMsgQueue = new LinkedList<Message>();\n+                if (logger.isDebugEnabled()) {\n+                    logger\n+                    .debug(\"Message has arrived but Subscribe channel does not have a registered MessageHandler yet so queueing up the message: {}\",\n+                           message);\n+                }\n+                subscribeMsgQueue.add(message);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                       Message message) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        synchronized (this) { \n+            // Add this \"pending to be consumed\" message to the outstandingMsgSet.\n+            outstandingMsgSet.add(message);\n+            // Check if we've exceeded the max size for the outstanding message set.\n+            if (outstandingMsgSet.size() >= cfg.getMaximumOutstandingMessages()\n+                    && subscribeChannel.isReadable()) {\n+                // Too many outstanding messages so throttle it by setting the Netty\n+                // Channel to not be readable.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Too many outstanding messages ({}) so throttling the subscribe netty Channel\",\n+                                 outstandingMsgSet.size());\n+                }\n+                subscribeChannel.setReadable(false);\n+            }\n+        }\n+        MessageConsumeData messageConsumeData =\n+            new MessageConsumeData(topicSubscriber, message);\n+        messageHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                               message, sChannelManager.getConsumeCallback(),\n+                               messageConsumeData);\n+    }\n+\n+    @Override\n+    protected synchronized void messageConsumed(TopicSubscriber topicSubscriber,\n+                                                Message message) {\n+        logger.debug(\"Message has been successfully consumed by the client app for message:  {}, {}\",\n+                     message, topicSubscriber);\n+        // Update the consumed messages buffer variables\n+        if (cfg.isAutoSendConsumeMessageEnabled()) {\n+            // Update these variables only if we are auto-sending consume\n+            // messages to the server. Otherwise the onus is on the client app\n+            // to call the Subscriber consume API to let the server know which\n+            // messages it has successfully consumed.\n+            numConsumedMessagesInBuffer++;\n+            lastMessageSeqId = message.getMsgId();\n+        }\n+        // Remove this consumed message from the outstanding Message Set.\n+        outstandingMsgSet.remove(message);\n+\n+        // For consume response to server, there is a config param on how many\n+        // messages to consume and buffer up before sending the consume request.\n+        // We just need to keep a count of the number of messages consumed\n+        // and the largest/latest msg ID seen so far in this batch. Messages\n+        // should be delivered in order and without gaps. Do this only if\n+        // auto-sending of consume messages is enabled.\n+        if (cfg.isAutoSendConsumeMessageEnabled()\n+                && numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n+            // Send the consume request and reset the consumed messages buffer\n+            // variables. We will use the same Channel created from the\n+            // subscribe request for the TopicSubscriber.\n+            if (logger.isDebugEnabled()) {\n+                logger\n+                .debug(\"Consumed message buffer limit reached so send the Consume Request to the server with lastMessageSeqId: {}\",\n+                       lastMessageSeqId);\n+            }\n+            consume(topicSubscriber, lastMessageSeqId);\n+            numConsumedMessagesInBuffer = 0;\n+            lastMessageSeqId = null;\n+        }\n+\n+        // Check if we throttled message consumption previously when the\n+        // outstanding message limit was reached. For now, only turn the\n+        // delivery back on if there are no more outstanding messages to\n+        // consume. We could make this a configurable parameter if needed.\n+        if (!subscribeChannel.isReadable() && outstandingMsgSet.size() == 0) {\n+            if (logger.isDebugEnabled())\n+                logger\n+                .debug(\"Message consumption has caught up so okay to turn off throttling of messages on the subscribe channel for {}\",\n+                       topicSubscriber);\n+            subscribeChannel.setReadable(true);\n+        }\n+    }\n+\n+    @Override\n+    public void startDelivery(final TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Start delivering message for {} using message handler {}\",\n+                         va(topicSubscriber, messageHandler));\n+        }\n+        if (!hasSubscription(topicSubscriber)) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        synchronized (this) {\n+            if (null != this.messageHandler) {\n+                    throw new AlreadyStartDeliveryException(\"A message handler \" + this.messageHandler\n+                        + \" has been started for \" + topicSubscriber);\n+            }\n+            // instantiante a message handler\n+            if (null != messageHandler &&\n+                messageHandler instanceof FilterableMessageHandler) {\n+                FilterableMessageHandler filterMsgHandler =\n+                    (FilterableMessageHandler) messageHandler;\n+                // pass subscription preferences to message filter\n+                if (null == preferences) {\n+                    // no preferences means talking to an old version hub server\n+                    logger.warn(\"Start delivering messages with filter but no subscription \"\n+                              + \"preferences found. It might due to talking to an old version\"\n+                              + \" hub server.\");\n+                    // use the original message handler.\n+                    messageHandler = filterMsgHandler.getMessageHandler();\n+                } else {\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n+                                     va(topicSubscriber,\n+                                        SubscriptionStateUtils.toString(preferences)));\n+                    }\n+                    ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n+                    msgFilter.setSubscriptionPreferences(\n+                        topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                        preferences);\n+                }\n+            }\n+\n+            this.messageHandler = messageHandler;\n+            // Once the MessageHandler is registered, see if we have any queued up\n+            // subscription messages sent to us already from the server. If so,\n+            // consume those first. Do this only if the MessageHandler registered is\n+            // not null (since that would be the HedwigSubscriber.stopDelivery\n+            // call).\n+            if (messageHandler != null && subscribeMsgQueue != null && subscribeMsgQueue.size() > 0) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Consuming {} queued up messages for {}\",\n+                                 va(subscribeMsgQueue.size(), topicSubscriber));\n+                }\n+                for (Message message : subscribeMsgQueue) {\n+                    asyncMessageDeliver(topicSubscriber, message);\n+                }\n+                // Now we can remove the queued up messages since they are all\n+                // consumed.\n+                subscribeMsgQueue.clear();\n+            }\n+            // Now make the TopicSubscriber Channel readable (it is set to not be\n+            // readable when the initial subscription is done). Note that this is an\n+            // asynchronous call. If this fails (not likely), the futureListener\n+            // will just log an error message for now.\n+            ChannelFuture future = subscribeChannel.setReadable(true);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                        logger.error(\"Unable to make subscriber Channel readable in startDelivery call for {}\",\n+                                     topicSubscriber);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void stopDelivery(final TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n+        }\n+\n+        if (!hasSubscription(topicSubscriber)) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+\n+        synchronized (this) {\n+            this.messageHandler = null;\n+            // Now make the TopicSubscriber channel not-readable. This will buffer\n+            // up messages if any are sent from the server. Note that this is an\n+            // asynchronous call. If this fails (not likely), the futureListener\n+            // will just log an error message for now.\n+            ChannelFuture future = subscribeChannel.setReadable(false);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                        logger.error(\"Unable to make subscriber Channel not readable in stopDelivery call for {}\",\n+                                     topicSubscriber);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n+        if (null == origTopicSubscriber) {\n+            return false;\n+        } else {\n+            return origTopicSubscriber.equals(topicSubscriber);\n+        }\n+    }\n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        // nothing to do just clear status\n+        // channel manager takes the responsibility to close the channel\n+        callback.operationFinished(context, (ResponseBody)null);\n+    }\n+\n+    @Override\n+    public synchronized  void consume(final TopicSubscriber topicSubscriber,\n+                                      final MessageSeqId messageSeqId) {\n+        PubSubRequest.Builder pubsubRequestBuilder =\n+            NetUtils.buildConsumeRequest(sChannelManager.nextTxnId(),\n+                                         topicSubscriber, messageSeqId);  \n+\n+        // For Consume requests, we will send them from the client in a fire and\n+        // forget manner. We are not expecting the server to send back an ack\n+        // response so no need to register this in the ResponseHandler. There\n+        // are no callbacks to invoke since this isn't a client initiated\n+        // action. Instead, just have a future listener that will log an error\n+        // message if there was a problem writing the consume request.\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                         va(NetUtils.getHostFromChannel(subscribeChannel),\n+                            messageSeqId, topicSubscriber));\n+        }\n+        ChannelFuture future = subscribeChannel.write(pubsubRequestBuilder.build());\n+        future.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                                 va(NetUtils.getHostFromChannel(subscribeChannel),\n+                                    messageSeqId, topicSubscriber));\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void onChannelDisconnected(InetSocketAddress host,\n+                                      Channel channel) {\n+        sChannelManager.clearHostForTopic(origTopicSubscriber.getTopic(), host);\n+        // clear subscription status\n+        sChannelManager.asyncCloseSubscription(origTopicSubscriber, new Callback<ResponseBody>() {\n+\n+            @Override\n+            public void operationFinished(Object ctx, ResponseBody result) {\n+                finish();\n+            }\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                finish();\n+            }\n+\n+            private void finish() {\n+                // Since the connection to the server host that was responsible\n+                // for the topic died, we are not sure about the state of that\n+                // server. Resend the original subscribe request data to the default\n+                // server host/VIP. Also clear out all of the servers we've\n+                // contacted or attempted to from this request as we are starting a\n+                // \"fresh\" subscribe request.\n+                origSubData.clearServersList();\n+                // do resubscribe if the subscription enables it\n+                if (origSubData.options.getEnableResubscribe()) {\n+                    // Set a new type of VoidCallback for this async call. We need this\n+                    // hook so after the subscribe reconnect has completed, delivery for\n+                    // that topic subscriber should also be restarted (if it was that\n+                    // case before the channel disconnect).\n+                    final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n+                    SubscribeReconnectCallback reconnectCb =\n+                        new SubscribeReconnectCallback(origTopicSubscriber,\n+                                                       origSubData,\n+                                                       sChannelManager,\n+                                                       retryWaitTime);\n+                    origSubData.setCallback(reconnectCb);\n+                    origSubData.context = null;\n+                    // Clear the shouldClaim flag\n+                    origSubData.shouldClaim = false;\n+                    logger.debug(\"Reconnect {}'s subscription channel with origSubData {}\",\n+                                 origTopicSubscriber, origSubData);\n+                    sChannelManager.submitOpToDefaultServer(origSubData);\n+                } else {\n+                    logger.info(\"Subscription channel for ({}) is disconnected.\",\n+                                origTopicSubscriber);\n+                    sChannelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n+                        origSubData.topic, origSubData.subscriberId, SubscriptionEvent.TOPIC_MOVED);\n+                }\n+            }\n+        }, null);\n+    }\n+\n+}"},{"sha":"e293e2da7cf595e6a5bebae4afc800d20f515d4c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscriptionChannelPipelineFactory.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,46 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.simple;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class SimpleSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public SimpleSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                    SimpleHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new SimpleSubscribeResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"f9ce409a613f3789db569b091402a81c01a7d330","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","status":"renamed","additions":26,"deletions":43,"changes":69,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SubscribeReconnectCallback.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -15,24 +15,19 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.hedwig.client.handlers;\n+package org.apache.hedwig.client.netty.impl.simple;\n \n-import java.util.TimerTask;\n-\n-import org.apache.hedwig.protocol.PubSubProtocol;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.hedwig.client.api.MessageHandler;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n-import org.apache.hedwig.client.netty.HedwigClientImpl;\n-import org.apache.hedwig.client.netty.HedwigSubscriber;\n import org.apache.hedwig.exceptions.PubSubException;\n-\n import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n \n /**\n  * This class is used when a Subscribe channel gets disconnected and we attempt\n@@ -42,72 +37,60 @@\n  * callback will be the hook for this.\n  *\n  */\n-public class SubscribeReconnectCallback implements Callback<PubSubProtocol.ResponseBody> {\n+class SubscribeReconnectCallback implements Callback<ResponseBody> {\n \n     private static Logger logger = LoggerFactory.getLogger(SubscribeReconnectCallback.class);\n \n     // Private member variables\n+    private final TopicSubscriber origTopicSubscriber;\n     private final PubSubData origSubData;\n-    private final HedwigClientImpl client;\n-    private final HedwigSubscriber sub;\n-    private final ClientConfiguration cfg;\n+    private final SimpleHChannelManager channelManager;\n+    private final long retryWaitTime;\n \n     // Constructor\n-    public SubscribeReconnectCallback(PubSubData origSubData, HedwigClientImpl client) {\n+    SubscribeReconnectCallback(TopicSubscriber origTopicSubscriber,\n+                               PubSubData origSubData,\n+                               SimpleHChannelManager channelManager,\n+                               long retryWaitTime) {\n+        this.origTopicSubscriber = origTopicSubscriber;\n         this.origSubData = origSubData;\n-        this.client = client;\n-        this.sub = client.getSubscriber();\n-        this.cfg = client.getConfiguration();\n-    }\n-\n-    class SubscribeReconnectRetryTask extends TimerTask {\n-        @Override\n-        public void run() {\n-            logger.debug(\"Retrying subscribe reconnect request for origSubData: {}\", origSubData);\n-            // Clear out all of the servers we've contacted or attempted to from\n-            // this request.\n-            origSubData.clearServersList();\n-            client.doConnect(origSubData, cfg.getDefaultServerHost());\n-        }\n+        this.channelManager = channelManager;\n+        this.retryWaitTime = retryWaitTime;\n     }\n \n-    public void operationFinished(Object ctx, PubSubProtocol.ResponseBody resultOfOperation) {\n+    @Override\n+    public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n         logger.debug(\"Subscribe reconnect succeeded for origSubData: {}\", origSubData);\n         // Now we want to restart delivery for the subscription channel only\n         // if delivery was started at the time the original subscribe channel\n         // was disconnected.\n         try {\n-            sub.restartDelivery(origSubData.topic, origSubData.subscriberId);\n+            channelManager.restartDelivery(origTopicSubscriber);\n         } catch (ClientNotSubscribedException e) {\n             // This exception should never be thrown here but just in case,\n             // log an error and just keep retrying the subscribe request.\n-            logger.error(\"Subscribe was successful but error starting delivery for topic: \"\n-                         + origSubData.topic.toStringUtf8() + \", subscriberId: \"\n-                         + origSubData.subscriberId.toStringUtf8(), e);\n+            logger.error(\"Subscribe was successful but error starting delivery for {} : {}\",\n+                         va(origTopicSubscriber, e.getMessage()));\n             retrySubscribeRequest();\n         } catch (AlreadyStartDeliveryException asde) {\n             // should not reach here\n         }\n     }\n \n+    @Override\n     public void operationFailed(Object ctx, PubSubException exception) {\n         // If the subscribe reconnect fails, just keep retrying the subscribe\n         // request. There isn't a way to flag to the application layer that\n         // a topic subscription has failed. So instead, we'll just keep\n         // retrying in the background until success.\n-        logger.error(\"Subscribe reconnect failed with error: \" + exception.getMessage());\n+        logger.error(\"Subscribe reconnect failed with error: \", exception);\n         retrySubscribeRequest();\n     }\n \n     private void retrySubscribeRequest() {\n-        // If the client has stopped, there is no need to proceed with any\n-        // callback logic here.\n-        if (client.hasStopped())\n-            return;\n-\n-        // Retry the subscribe request but only after waiting for a\n-        // preconfigured amount of time.\n-        client.getClientTimer().schedule(new SubscribeReconnectRetryTask(),\n-                                         client.getConfiguration().getSubscribeReconnectRetryWaitTime());\n+        origSubData.clearServersList();\n+        logger.debug(\"Reconnect subscription channel for {} in {} ms later.\",\n+                     va(origTopicSubscriber, retryWaitTime));\n+        channelManager.submitOpAfterDelay(origSubData, retryWaitTime);\n     }\n }","previous_filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java"},{"sha":"07236a5e816319e6cb1f3b63828bf3e23ac9e2a8","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/package-info.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A Netty based Hedwig client implementation.\n+ *\n+ * <h3>Components</h3>\n+ *\n+ * The netty based implementation contains following components:\n+ * <ul>\n+ *   <li>{@link HChannel}: A interface wrapper of netty {@link org.jboss.netty.channel.Channel}\n+ *       to submit hedwig's {@link org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest}s\n+ *       to target host.</li>\n+ *   <li>{@link HChanneHandler}: A wrapper of netty {@link org.jboss.netty.channel.ChannelHandler}\n+ *       to handle events of its underlying netty channel, such as responses received, channel\n+ *       disconnected, etc. A {@link HChannelHandler} is bound with a {@link HChannel}.</li>\n+ *   <li>{@link HChannelManager}: A manager manages all established {@link HChannel}s.\n+ *       It provides a clean interface for publisher/subscriber to send\n+ *       {@link org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest}s</li>\n+ * </ul>\n+ *\n+ * <h3>Main Flow</h3>\n+ *\n+ * <ul>\n+ *   <li>{@link HedwigPublisher}/{@link HedwigSubscriber} delegates {@link HChannelManager}\n+ *       to submit pub/sub requests.</li>\n+ *   <li>{@link HChannelManager} find the owner hubs, establish a {@link HChannel} to hub servers\n+ *       and send the requests to them.</li>\n+ *   <li>{@link HChannelHandler} dispatches responses to target\n+ *       {@link org.apache.hedwig.client.handlers.AbstractResponseHandler} to process.</li>\n+ *   <li>{@link HChannelHandler} detects an underlying netty {@link org.jboss.netty.channel.Channel}\n+ *       disconnected. It calles {@link HChannelManager} to clear cached {@link HChannel} that\n+ *       it bound with. For non-subscritpion channels, it would fail all pending requests;\n+ *       For subscription channels, it would fail all pending requests and retry to reconnect\n+ *       those successful subscriptions.</li>\n+ * </ul>\n+ *\n+ * <h3>HChannel</h3>\n+ *\n+ * Two kinds of {@link HChannel}s provided in current implementation. {@link HChannelImpl}\n+ * provides the ability to multiplex pub/sub requests in an underlying netty\n+ * {@link org.jboss.netty.channel.Channel}, while {@link DefaultServerChannel} provides the\n+ * ability to establish a netty channel {@link org.jboss.netty.channel.Channel} for a pub/sub\n+ * request. After the underlying netty channel is estabilished, it would be converted into\n+ * a {@link HChannelImpl} by {@link HChannelManager#submitOpThruChannel(pubSubData, channel)}.\n+ *\n+ * Although {@link HChannelImpl} provides multiplexing ability, it still could be used for\n+ * one-channel-per-subscription case, which just sent only one subscribe request thru the\n+ * underlying channel.\n+ *\n+ * <h3>HChannelHandler</h3>\n+ *\n+ * {@link HChannelHandler} is generic netty {@link org.jboss.netty.channel.ChannelHandler},\n+ * which handles events from the underlying channel. A <i>HChannelHandler</i> is bound with\n+ * a {@link HChannel} as channel pipeplien when the underlying channel is established. It\n+ * takes the responsibility of dispatching response to target response handler. For a\n+ * non-subscription channel, it just handles <b>PUBLISH</b> and <b>UNSUBSCRIBE</b> responses.\n+ * For a subscription channel, it handles <b>SUBSCRIBE</b> response. For consume requests,\n+ * we treated them in a fire-and-forget way, so they are not need to be handled by any response\n+ * handler.\n+ *\n+ * <h3>HChannelManager</h3>\n+ *\n+ * {@link HChannelManager} manages all outstanding connections to target hub servers for a client.\n+ * Since a subscription channel acts quite different from a non-subscription channel, the basic\n+ * implementation {@link AbstractHChannelManager} manages non-subscription channels and\n+ * subscription channels in different channel sets. Currently hedwig client provides\n+ * {@link SimpleHChannelManager} which manages subscription channels in one-channel-per-subscription\n+ * way. In future, if we want to multiplex multiple subscriptions in one channel, we just need\n+ * to provide an multiplexing version of {@link AbstractHChannelManager} which manages channels\n+ * in multiplexing way, and a multiplexing version of {@link org.apache.hedwig.client.handlers.SubscribeResponseHandler}\n+ * which handles multiple subscriptions in one channel.\n+ */\n+package org.apache.hedwig.client.netty;"},{"sha":"b8d22dac7943dee562e9a8eb6469659dc31493e4","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/VarArgs.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -0,0 +1,26 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.util;\n+\n+public class VarArgs {\n+\n+    public static Object[] va(Object...args) {\n+        return args;\n+    }\n+\n+}"},{"sha":"ce0f3f6ff8b85cc265f35544a1f6d0ac657a1703","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/eba338eb398f8a22987c6bd8352bf2d649fb7c33/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=eba338eb398f8a22987c6bd8352bf2d649fb7c33","patch":"@@ -347,6 +347,33 @@ public void testAsyncSubscribe() throws Exception {\n         assertTrue(queue.take());\n     }\n \n+    @Test\n+    public void testStartDeliveryAfterCloseSub() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"testStartDeliveryAfterCloseSub\");\n+        ByteString subid = ByteString.copyFromUtf8(\"mysubid\");\n+        subscriber.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+\n+        // Start delivery for the subscriber\n+        subscriber.startDelivery(topic, subid, new TestMessageHandler());\n+\n+        // Now publish some messages for the topic to be consumed by the\n+        // subscriber.\n+        publisher.publish(topic, Message.newBuilder()\n+                                .setBody(ByteString.copyFromUtf8(\"Message #1\")).build());\n+        assertTrue(consumeQueue.take());\n+\n+        // Close subscriber for the subscriber\n+        subscriber.closeSubscription(topic, subid);\n+\n+        // subscribe again\n+        subscriber.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+        subscriber.startDelivery(topic, subid, new TestMessageHandler());\n+\n+        publisher.publish(topic, Message.newBuilder()\n+                                .setBody(ByteString.copyFromUtf8(\"Message #2\")).build());\n+        assertTrue(consumeQueue.take());\n+    }\n+\n     @Test\n     public void testSubscribeAndConsume() throws Exception {\n         ByteString topic = ByteString.copyFromUtf8(\"myConsumeTopic\");"}]}

