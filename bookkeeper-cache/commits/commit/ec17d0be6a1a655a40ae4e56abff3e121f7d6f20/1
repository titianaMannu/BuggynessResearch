{"sha":"ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYzE3ZDBiZTZhMWE2NTVhNDBhZTRlNTZhYmZmM2UxMjFmN2Q2ZjIw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-09T15:26:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-09T15:26:17Z"},"message":"BOOKKEEPER-191: Hub server should change ledger to write, so consumed messages have chance to be garbage collected. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1371255 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0398779b400c531c9cbb1137a7b94a2885ce2e5d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0398779b400c531c9cbb1137a7b94a2885ce2e5d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","html_url":"https://github.com/apache/bookkeeper/commit/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"5c59fa532fa44a1803e1d986181c58c1b00f0a4c","url":"https://api.github.com/repos/apache/bookkeeper/commits/5c59fa532fa44a1803e1d986181c58c1b00f0a4c","html_url":"https://github.com/apache/bookkeeper/commit/5c59fa532fa44a1803e1d986181c58c1b00f0a4c"}],"stats":{"total":673,"additions":550,"deletions":123},"files":[{"sha":"11b09aef0faa0dec476dc546829777fbfc1630ad","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","patch":"@@ -66,6 +66,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-259: Create a topic manager using versioned write for leader election (sijie via ivank)\n \n+        BOOKKEEPER-191: Hub server should change ledger to write, so consumed messages have chance to be garbage collected. (sijie via ivank)\n+\n     IMPROVEMENTS:\n \n       bookkeeper-server:"},{"sha":"a758f6c1b93df59bc6b7b572c070b461e5665b21","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","patch":"@@ -61,6 +61,7 @@\n     protected final static String BK_ENSEMBLE_SIZE = \"bk_ensemble_size\";\n     protected final static String BK_QUORUM_SIZE = \"bk_quorum_size\";\n     protected final static String RETRY_REMOTE_SUBSCRIBE_THREAD_RUN_INTERVAL = \"retry_remote_subscribe_thread_run_interval\";\n+    protected final static String MAX_ENTRIES_PER_LEDGER = \"max_entries_per_ledger\";\n \n     // manager related settings\n     protected final static String METADATA_MANAGER_BASED_TOPIC_MANAGER_ENABLED = \"metadata_manager_based_topic_manager_enabled\";\n@@ -295,6 +296,17 @@ public int getBkQuorumSize() {\n         return conf.getInt(BK_QUORUM_SIZE, 2);\n     }\n \n+    /**\n+     * This parameter is used when BookKeeper is the persistence storage,\n+     * and indicates when the number of entries stored in a ledger reach\n+     * the threshold, hub server will open a new ledger to write.\n+     *\n+     * @return max entries per ledger\n+     */\n+    public long getMaxEntriesPerLedger() {\n+        return conf.getLong(MAX_ENTRIES_PER_LEDGER, 0L);\n+    }\n+\n     /*\n      * Is this a valid configuration that we can run with? This code might grow\n      * over time."},{"sha":"d2c42982e45dc4419cf769bd3b4ef26701a96438","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":318,"deletions":119,"changes":437,"blob_url":"https://github.com/apache/bookkeeper/blob/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","patch":"@@ -20,14 +20,16 @@\n import java.io.IOException;\n import java.util.Enumeration;\n import java.util.Iterator;\n-import java.util.Set;\n import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Set;\n import java.util.TreeMap;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n@@ -78,6 +80,10 @@\n     private ServerConfiguration cfg;\n     private TopicManager tm;\n \n+    // max number of entries allowed in a ledger\n+    private static final long UNLIMITED_ENTRIES = 0L;\n+    private final long maxEntriesPerLedger;\n+\n     static class InMemoryLedgerRange {\n         LedgerRange range;\n         long startSeqIdIncluded; // included, for the very first ledger, this\n@@ -131,6 +137,19 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n          */\n         AtomicBoolean doRelease = new AtomicBoolean(false);\n \n+        /**\n+         * Flag indicats the topic is changing ledger\n+         */\n+        AtomicBoolean doChangeLedger = new AtomicBoolean(false);\n+        /**\n+         * Last seq id to change ledger.\n+         */\n+        long lastSeqIdBeforeLedgerChange = -1;\n+        /**\n+         * List to buffer all persist requests during changing ledger.\n+         */\n+        LinkedList<PersistRequest> deferredRequests = null;\n+\n         final static int UNLIMITED = 0;\n         int messageBound = UNLIMITED;\n     }\n@@ -160,6 +179,7 @@ public BookkeeperPersistenceManager(BookKeeper bk, MetadataManagerFactory metaMa\n         this.tpManager = metaManagerFactory.newTopicPersistenceManager();\n         this.cfg = cfg;\n         this.tm = tm;\n+        this.maxEntriesPerLedger = cfg.getMaxEntriesPerLedger();\n         queuer = new TopicOpQueuer(executor);\n         tm.addTopicOwnershipChangeListener(this);\n     }\n@@ -460,6 +480,51 @@ public long getSeqIdAfterSkipping(ByteString topic, long seqId, int skipAmount)\n         return Math.max(seqId + skipAmount, getMinSeqIdForTopic(topic));\n     }\n \n+    /**\n+     * Release topic on failure\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param e\n+     *          Failure Exception\n+     * @param ctx\n+     *          Callback context\n+     */\n+    protected void releaseTopicIfRequested(final ByteString topic, Exception e, Object ctx) {\n+        TopicInfo topicInfo = topicInfos.get(topic);\n+        if (topicInfo == null) {\n+            logger.warn(\"No topic found when trying to release ownership of topic \" + topic.toStringUtf8()\n+                      + \" on failure.\");\n+            return;\n+        }\n+        // do release owner ship of topic\n+        if (topicInfo.doRelease.compareAndSet(false, true)) {\n+            logger.info(\"Release topic \" + topic.toStringUtf8() + \" when bookkeeper persistence mananger encounters failure :\",\n+                        e);\n+            tm.releaseTopic(topic, new Callback<Void>() {\n+                @Override\n+                public void operationFailed(Object ctx, PubSubException exception) {\n+                    logger.error(\"Exception found on releasing topic \" + topic.toStringUtf8()\n+                               + \" when encountering exception from bookkeeper:\", exception);\n+                }\n+                @Override\n+                public void operationFinished(Object ctx, Void resultOfOperation) {\n+                    logger.info(\"successfully releasing topic {} when encountering\"\n+                              + \" exception from bookkeeper\", topic.toStringUtf8());\n+                }\n+            }, null);\n+        }\n+        // if release happens when the topic is changing ledger\n+        // we need to fail all queued persist requests\n+        if (topicInfo.doChangeLedger.get()) {\n+            for (PersistRequest pr : topicInfo.deferredRequests) {\n+                pr.getCallback().operationFailed(ctx, new PubSubException.ServiceDownException(e));\n+            }\n+            topicInfo.deferredRequests.clear();\n+            topicInfo.lastSeqIdBeforeLedgerChange = -1;\n+        }\n+    }\n+\n     public class PersistOp extends TopicOpQueuer.SynchronousOp {\n         PersistRequest request;\n \n@@ -470,79 +535,134 @@ public PersistOp(PersistRequest request) {\n \n         @Override\n         public void runInternal() {\n-            final TopicInfo topicInfo = topicInfos.get(topic);\n+            doPersistMessage(request);\n+        }\n+    }\n \n-            if (topicInfo == null) {\n-                request.getCallback().operationFailed(request.ctx,\n-                                                 new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n-                return;\n-            }\n+    /**\n+     * Persist a message by executing a persist request.\n+     */\n+    protected void doPersistMessage(final PersistRequest request) {\n+        final ByteString topic = request.topic;\n+        final TopicInfo topicInfo = topicInfos.get(topic);\n \n-            if (topicInfo.doRelease.get()) {\n-                request.getCallback().operationFailed(request.ctx, new PubSubException.ServiceDownException(\n-                    \"The ownership of the topic is releasing due to unrecoverable issue.\"));\n-                return;\n-            }\n+        if (topicInfo == null) {\n+            request.getCallback().operationFailed(request.ctx,\n+                                             new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n+            return;\n+        }\n \n-            final long localSeqId = topicInfo.lastSeqIdPushed.getLocalComponent() + 1;\n-            MessageSeqId.Builder builder = MessageSeqId.newBuilder();\n-            if (request.message.hasMsgId()) {\n-                MessageIdUtils.takeRegionMaximum(builder, topicInfo.lastSeqIdPushed, request.message.getMsgId());\n-            } else {\n-                builder.addAllRemoteComponents(topicInfo.lastSeqIdPushed.getRemoteComponentsList());\n-            }\n-            builder.setLocalComponent(localSeqId);\n+        if (topicInfo.doRelease.get()) {\n+            request.getCallback().operationFailed(request.ctx, new PubSubException.ServiceDownException(\n+                \"The ownership of the topic is releasing due to unrecoverable issue.\"));\n+            return;\n+        }\n \n-            topicInfo.lastSeqIdPushed = builder.build();\n-            Message msgToSerialize = Message.newBuilder(request.message).setMsgId(topicInfo.lastSeqIdPushed).build();\n+        // if the topic is changing ledger, queue following persist requests until ledger is changed\n+        if (topicInfo.doChangeLedger.get()) {\n+            logger.info(\"Topic {} is changing ledger, so queue persist request for message.\",\n+                        topic.toStringUtf8());\n+            topicInfo.deferredRequests.add(request);\n+            return;\n+        }\n \n-            final MessageSeqId responseSeqId = msgToSerialize.getMsgId();\n+        final long localSeqId = topicInfo.lastSeqIdPushed.getLocalComponent() + 1;\n+        MessageSeqId.Builder builder = MessageSeqId.newBuilder();\n+        if (request.message.hasMsgId()) {\n+            MessageIdUtils.takeRegionMaximum(builder, topicInfo.lastSeqIdPushed, request.message.getMsgId());\n+        } else {\n+            builder.addAllRemoteComponents(topicInfo.lastSeqIdPushed.getRemoteComponentsList());\n+        }\n+        builder.setLocalComponent(localSeqId);\n+\n+        // check whether reach the threshold of a ledger, if it does,\n+        // open a ledger to write\n+        long entriesInThisLedger = localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded + 1;\n+        if (UNLIMITED_ENTRIES != maxEntriesPerLedger &&\n+            entriesInThisLedger >= maxEntriesPerLedger) {\n+            if (topicInfo.doChangeLedger.compareAndSet(false, true)) {\n+                // for order guarantees, we should wait until all the adding operations for current ledger\n+                // are succeed. so we just mark it as lastSeqIdBeforeLedgerChange\n+                // when the lastSeqIdBeforeLedgerChange acked, we do changing the ledger\n+                if (null == topicInfo.deferredRequests) {\n+                    topicInfo.deferredRequests = new LinkedList<PersistRequest>();\n+                }\n+                topicInfo.lastSeqIdBeforeLedgerChange = localSeqId;\n+            }\n+        }\n \n-            topicInfo.currentLedgerRange.handle.asyncAddEntry(msgToSerialize.toByteArray(),\n-            new SafeAsynBKCallback.AddCallback() {\n-                @Override\n-                public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-                    if (rc != BKException.Code.OK) {\n-                        BKException bke = BKException.create(rc);\n-                        logger.error(\"Error while persisting entry to ledger: \" + lh.getId() + \" for topic: \"\n-                                     + topic.toStringUtf8(), bke);\n+        topicInfo.lastSeqIdPushed = builder.build();\n+        Message msgToSerialize = Message.newBuilder(request.message).setMsgId(topicInfo.lastSeqIdPushed).build();\n \n-                        // To preserve ordering guarantees, we\n-                        // should give up the topic and not let\n-                        // other operations through\n-                        if (topicInfo.doRelease.compareAndSet(false, true)) {\n-                            tm.releaseTopic(request.topic, new Callback<Void>() {\n-                                @Override\n-                                public void operationFailed(Object ctx, PubSubException exception) {\n-                                    logger.error(\"Exception found on releasing topic \" + request.topic.toStringUtf8()\n-                                               + \" when encountering exception from bookkeeper:\", exception);\n-                                }\n-                                @Override\n-                                public void operationFinished(Object ctx, Void resultOfOperation) {\n-                                    logger.debug(\"successfully releasing topic {} when encountering\"\n-                                                 + \" exception from bookkeeper\", request.topic.toStringUtf8());\n-                                }\n-                            }, null);\n-                        }\n-                        request.getCallback().operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                        return;\n-                    }\n+        final MessageSeqId responseSeqId = msgToSerialize.getMsgId();\n+        topicInfo.currentLedgerRange.handle.asyncAddEntry(msgToSerialize.toByteArray(),\n+        new SafeAsynBKCallback.AddCallback() {\n+            AtomicBoolean processed = new AtomicBoolean(false);\n+            @Override\n+            public void safeAddComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n \n-                    if (entryId + topicInfo.currentLedgerRange.startSeqIdIncluded != localSeqId) {\n-                        String msg = \"Expected BK to assign entry-id: \"\n-                                     + (localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded)\n-                                     + \" but it instead assigned entry-id: \" + entryId + \" topic: \"\n-                                     + topic.toStringUtf8() + \"ledger: \" + lh.getId();\n-                        logger.error(msg);\n-                        throw new UnexpectedError(msg);\n-                    }\n+                // avoid double callback by mistake, since we may do change ledger in this callback.\n+                if (!processed.compareAndSet(false, true)) {\n+                    return;\n+                }\n+                if (rc != BKException.Code.OK) {\n+                    BKException bke = BKException.create(rc);\n+                    logger.error(\"Error while persisting entry to ledger: \" + lh.getId() + \" for topic: \"\n+                                 + topic.toStringUtf8(), bke);\n+                    request.getCallback().operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+\n+                    // To preserve ordering guarantees, we\n+                    // should give up the topic and not let\n+                    // other operations through\n+                    releaseTopicIfRequested(request.topic, bke, ctx);\n+                    return;\n+                }\n \n-                    topicInfo.lastEntryIdAckedInCurrentLedger = entryId;\n-                    request.getCallback().operationFinished(ctx, responseSeqId);\n+                if (entryId + topicInfo.currentLedgerRange.startSeqIdIncluded != localSeqId) {\n+                    String msg = \"Expected BK to assign entry-id: \"\n+                                 + (localSeqId - topicInfo.currentLedgerRange.startSeqIdIncluded)\n+                                 + \" but it instead assigned entry-id: \" + entryId + \" topic: \"\n+                                 + topic.toStringUtf8() + \"ledger: \" + lh.getId();\n+                    logger.error(msg);\n+                    throw new UnexpectedError(msg);\n                 }\n-            }, request.ctx);\n \n-        }\n+                topicInfo.lastEntryIdAckedInCurrentLedger = entryId;\n+                request.getCallback().operationFinished(ctx, responseSeqId);\n+                // if this acked entry is the last entry of current ledger\n+                // we can add a ChangeLedgerOp to execute to change ledger\n+                if (topicInfo.doChangeLedger.get() &&\n+                    entryId + topicInfo.currentLedgerRange.startSeqIdIncluded == topicInfo.lastSeqIdBeforeLedgerChange) {\n+                    // change ledger\n+                    changeLedger(topic, new Callback<Void>() {\n+                        @Override\n+                        public void operationFailed(Object ctx, PubSubException exception) {\n+                            logger.error(\"Failed to change ledger for topic \" + topic.toStringUtf8(), exception);\n+                            // change ledger failed, we should give up topic\n+                            releaseTopicIfRequested(request.topic, exception, ctx);\n+                        }\n+                        @Override\n+                        public void operationFinished(Object ctx, Void resultOfOperation) {\n+                            topicInfo.doChangeLedger.set(false);\n+                            topicInfo.lastSeqIdBeforeLedgerChange = -1;\n+                            // the ledger is changed, persist queued requests\n+                            // if the number of queued persist requests is more than maxEntriesPerLedger\n+                            // we just persist maxEntriesPerLedger requests, other requests are still queued\n+                            // until next ledger changed.\n+                            int numRequests = 0;\n+                            while (!topicInfo.deferredRequests.isEmpty() &&\n+                                   numRequests < maxEntriesPerLedger) {\n+                                PersistRequest pr = topicInfo.deferredRequests.removeFirst();\n+                                doPersistMessage(pr);\n+                                ++numRequests;\n+                            }\n+                            logger.debug(\"Finished persisting {} queued requests, but there are still {} requests in queue.\",\n+                                         numRequests, topicInfo.deferredRequests.size());\n+                        }\n+                    }, ctx);\n+                }\n+            }\n+        }, request.ctx);\n     }\n \n     public void persistMessage(PersistRequest request) {\n@@ -622,7 +742,7 @@ void processTopicLedgerRanges(final LedgerRanges ranges, final Version version)\n             }\n \n             // All ledgers were found properly closed, just start a new one\n-            openNewTopicLedger(version, topicInfo);\n+            openNewTopicLedger(topic, version, topicInfo, false, cb, ctx);\n         }\n \n         /**\n@@ -654,7 +774,7 @@ public void safeOpenComplete(int rc, LedgerHandle ledgerHandle, Object ctx) {\n                         // couldn't write to, so just ignore it\n                         logger.info(\"Pruning empty ledger: \" + ledgerId + \" for topic: \" + topic.toStringUtf8());\n                         closeLedger(ledgerHandle);\n-                        openNewTopicLedger(expectedVersionOfLedgerNode, topicInfo);\n+                        openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo, false, cb, ctx);\n                         return;\n                     }\n \n@@ -695,77 +815,91 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                             logger.info(\"Recovered unclosed ledger: \" + ledgerId + \" for topic: \"\n                                         + topic.toStringUtf8() + \" with \" + numEntriesInLastLedger + \" entries\");\n \n-                            openNewTopicLedger(expectedVersionOfLedgerNode, topicInfo);\n+                            openNewTopicLedger(topic, expectedVersionOfLedgerNode, topicInfo, false, cb, ctx);\n                         }\n                     }, ctx);\n \n                 }\n \n             }, ctx);\n         }\n+    }\n \n-        /**\n-         *\n-         * @param requiredVersionOfLedgersNode\n-         *            The version of the ledgers node when we read it, should be\n-         *            the same when we try to write\n-         */\n-        private void openNewTopicLedger(final Version expectedVersionOfLedgersNode, final TopicInfo topicInfo) {\n-            bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,\n-            new SafeAsynBKCallback.CreateCallback() {\n-                boolean processed = false;\n-\n-                @Override\n-                public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n-                    if (processed) {\n-                        return;\n-                    } else {\n-                        processed = true;\n-                    }\n+    /**\n+     * Open New Ledger to write for a topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param expectedVersionOfLedgersNode\n+     *          Expected Version to Update Ledgers Node.\n+     * @param topicInfo\n+     *          Topic Information\n+     * @param changeLedger\n+     *          Whether is it called when changing ledger\n+     * @param cb\n+     *          Callback to trigger after opening new ledger.\n+     * @param ctx\n+     *          Callback context.\n+     */\n+    void openNewTopicLedger(final ByteString topic,\n+                            final Version expectedVersionOfLedgersNode, final TopicInfo topicInfo,\n+                            final boolean changeLedger,\n+                            final Callback<Void> cb, final Object ctx) {\n+        bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,\n+        new SafeAsynBKCallback.CreateCallback() {\n+            AtomicBoolean processed = new AtomicBoolean(false);\n+\n+            @Override\n+            public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n+                if (!processed.compareAndSet(false, true)) {\n+                    return;\n+                }\n \n-                    if (rc != BKException.Code.OK) {\n-                        BKException bke = BKException.create(rc);\n-                        logger.error(\"Could not create new ledger while acquiring topic: \"\n-                                     + topic.toStringUtf8(), bke);\n-                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n-                        return;\n-                    }\n+                if (rc != BKException.Code.OK) {\n+                    BKException bke = BKException.create(rc);\n+                    logger.error(\"Could not create new ledger while acquiring topic: \"\n+                                 + topic.toStringUtf8(), bke);\n+                    cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                    return;\n+                }\n \n+                // compute last seq id\n+                if (!changeLedger) {\n                     topicInfo.lastSeqIdPushed = topicInfo.ledgerRanges.isEmpty() ? MessageSeqId.newBuilder()\n                                                 .setLocalComponent(0).build() : topicInfo.ledgerRanges.lastEntry().getValue().range\n                                                 .getEndSeqIdIncluded();\n+                }\n \n-                    LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId()).build();\n-                    topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, topicInfo.lastSeqIdPushed\n-                            .getLocalComponent() + 1, lh);\n+                LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(lh.getId()).build();\n+                topicInfo.currentLedgerRange = new InMemoryLedgerRange(lastRange, topicInfo.lastSeqIdPushed\n+                        .getLocalComponent() + 1, lh);\n \n-                    // Persist the fact that we started this new\n-                    // ledger to ZK\n+                // Persist the fact that we started this new\n+                // ledger to ZK\n \n-                    LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n-                    for (InMemoryLedgerRange imlr : topicInfo.ledgerRanges.values()) {\n-                        builder.addRanges(imlr.range);\n-                    }\n-                    builder.addRanges(lastRange);\n-\n-                    tpManager.writeTopicPersistenceInfo(\n-                    topic, builder.build(), expectedVersionOfLedgersNode, new Callback<Version>() {\n-                        @Override\n-                        public void operationFinished(Object ctx, Version newVersion) {\n-                            // Finally, all done\n-                            topicInfo.ledgerRangesVersion = newVersion;\n-                            topicInfos.put(topic, topicInfo);\n-                            cb.operationFinished(ctx, null);\n-                        }\n-                        @Override\n-                        public void operationFailed(Object ctx, PubSubException exception) {\n-                            cb.operationFailed(ctx, exception);\n-                        }\n-                    }, ctx);\n-                    return;\n+                LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n+                for (InMemoryLedgerRange imlr : topicInfo.ledgerRanges.values()) {\n+                    builder.addRanges(imlr.range);\n                 }\n-            }, ctx);\n-        }\n+                builder.addRanges(lastRange);\n+\n+                tpManager.writeTopicPersistenceInfo(\n+                topic, builder.build(), expectedVersionOfLedgersNode, new Callback<Version>() {\n+                    @Override\n+                    public void operationFinished(Object ctx, Version newVersion) {\n+                        // Finally, all done\n+                        topicInfo.ledgerRangesVersion = newVersion;\n+                        topicInfos.put(topic, topicInfo);\n+                        cb.operationFinished(ctx, null);\n+                    }\n+                    @Override\n+                    public void operationFailed(Object ctx, PubSubException exception) {\n+                        cb.operationFailed(ctx, exception);\n+                    }\n+                }, ctx);\n+                return;\n+            }\n+        }, ctx);\n     }\n \n     /**\n@@ -781,6 +915,71 @@ public void acquiredTopic(ByteString topic, Callback<Void> callback, Object ctx)\n         queuer.pushAndMaybeRun(topic, new AcquireOp(topic, callback, ctx));\n     }\n \n+    /**\n+     * Change ledger to write for a topic.\n+     */\n+    class ChangeLedgerOp extends TopicOpQueuer.AsynchronousOp<Void> {\n+\n+        public ChangeLedgerOp(ByteString topic, Callback<Void> cb, Object ctx) {\n+            queuer.super(topic, cb, ctx);\n+        }\n+\n+        @Override\n+        public void run() {\n+            TopicInfo topicInfo = topicInfos.get(topic);\n+            if (null == topicInfo) {\n+                logger.error(\"Weired! hub server doesn't own topic \" + topic.toStringUtf8()\n+                           + \" when changing ledger to write.\");\n+                cb.operationFailed(ctx, new PubSubException.ServerNotResponsibleForTopicException(\"\"));\n+                return;\n+            }\n+            closeLastTopicLedgerAndOpenNewOne(topicInfo);\n+        }\n+\n+        private void closeLastTopicLedgerAndOpenNewOne(final TopicInfo topicInfo) {\n+            final long ledgerId = topicInfo.currentLedgerRange.handle.getId();\n+            topicInfo.currentLedgerRange.handle.asyncClose(new CloseCallback() {\n+                AtomicBoolean processed = new AtomicBoolean(false);\n+                @Override\n+                public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n+                    if (!processed.compareAndSet(false, true)) {\n+                        return;\n+                    }\n+                    if (BKException.Code.OK != rc) {\n+                        BKException bke = BKException.create(rc);\n+                        logger.error(\"Could not close ledger \" + ledgerId\n+                                   + \" while changing ledger of topic \" + topic.toStringUtf8(), bke);\n+                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(bke));\n+                        return;\n+                    }\n+                    // update last range\n+                    LedgerRange lastRange = LedgerRange.newBuilder().setLedgerId(ledgerId)\n+                                            .setEndSeqIdIncluded(topicInfo.lastSeqIdPushed).build();\n+\n+                    topicInfo.currentLedgerRange.range = lastRange;\n+                    // put current ledger to ledger ranges\n+                    topicInfo.ledgerRanges.put(topicInfo.lastSeqIdPushed.getLocalComponent(),\n+                                               topicInfo.currentLedgerRange);\n+                    logger.info(\"Closed written ledger \" + ledgerId + \" for topic \"\n+                              + topic.toStringUtf8() + \" to change ledger.\");\n+                    openNewTopicLedger(topic, topicInfo.ledgerRangesVersion,\n+                                       topicInfo, true, cb, ctx);\n+                }\n+            }, ctx);\n+        }\n+\n+    }\n+\n+    /**\n+     * Change ledger to write for a topic.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     */\n+    protected void changeLedger(ByteString topic, Callback<Void> cb, Object ctx) {\n+        queuer.pushAndMaybeRun(topic, new ChangeLedgerOp(topic, cb, ctx));\n+    }\n+\n     public void closeLedger(LedgerHandle lh) {\n         // try {\n         // lh.asyncClose(noOpCloseCallback, null);"},{"sha":"e3031e634f5a788ad32e4e9ca912d0397346c317","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"modified","additions":218,"deletions":4,"changes":222,"blob_url":"https://github.com/apache/bookkeeper/blob/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/ec17d0be6a1a655a40ae4e56abff3e121f7d6f20/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=ec17d0be6a1a655a40ae4e56abff3e121f7d6f20","patch":"@@ -26,6 +26,7 @@\n \n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.hedwig.protocol.PubSubProtocol;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -34,15 +35,22 @@\n import com.google.protobuf.ByteString;\n import org.apache.hedwig.HelperMethods;\n import org.apache.hedwig.StubCallback;\n+import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.meta.MetadataManagerFactory;\n import org.apache.hedwig.server.topics.TopicManager;\n import org.apache.hedwig.server.topics.TrivialOwnAllTopicManager;\n import org.apache.hedwig.util.ConcurrencyUtils;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class TestBookkeeperPersistenceManagerWhiteBox extends TestCase {\n \n+    protected static Logger logger =\n+        LoggerFactory.getLogger(TestBookkeeperPersistenceManagerWhiteBox.class);\n+\n     BookKeeperTestBase bktb;\n     private final int numBookies = 3;\n     BookkeeperPersistenceManager bkpm;\n@@ -91,6 +99,7 @@ public void testEmptyDirtyLedger() throws Exception {\n         assertEquals(0, bkpm.topicInfos.get(topic).ledgerRanges.size());\n     }\n \n+    @Test\n     public void testNonEmptyDirtyLedger() throws Exception {\n \n         Random r = new Random();\n@@ -112,18 +121,165 @@ public void testNonEmptyDirtyLedger() throws Exception {\n             bkpm.persistMessage(new PersistRequest(topic, messages.get(index), persistCallback, null));\n             assertEquals(index + 1, ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());\n \n+            index++;\n             // once in every 10 times, give up ledger\n             if (r.nextInt(10) == 9) {\n-                // Make the bkpm lose its memory\n-                bkpm.topicInfos.clear();\n-                numPrevLedgers++;\n+                // should not release topic when the message is last message\n+                // otherwise when we call scan, bookkeeper persistence manager doesn't own the topic\n+                if (index < messages.size()) {\n+                    // Make the bkpm lose its memory\n+                    bkpm.topicInfos.clear();\n+                    numPrevLedgers++;\n+                }\n             }\n+        }\n+\n+        // Lets scan now\n+        StubScanCallback scanCallback = new StubScanCallback();\n+        bkpm.scanMessages(new RangeScanRequest(topic, 1, NUM_MESSAGES_TO_TEST, Long.MAX_VALUE, scanCallback, null));\n+        for (int i = 0; i < messages.size(); i++) {\n+            Message scannedMessage = ConcurrencyUtils.take(scanCallback.queue).left();\n+            assertTrue(messages.get(i).getBody().equals(scannedMessage.getBody()));\n+            assertEquals(i + 1, scannedMessage.getMsgId().getLocalComponent());\n+        }\n+        assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());\n+\n+    }\n+\n+    static final long maxEntriesPerLedger = 10;\n+\n+    class ChangeLedgerServerConfiguration extends ServerConfiguration {\n+        @Override\n+        public long getMaxEntriesPerLedger() {\n+            return maxEntriesPerLedger;\n+        }\n+    }\n+\n+    @Test\n+    public void testSyncChangeLedgers() throws Exception {\n+        int NUM_MESSAGES_TO_TEST = 101;\n+        int SIZE_OF_MESSAGES_TO_TEST = 100;\n+        int index = 0;\n+        List<Message> messages = HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,\n+                                 SIZE_OF_MESSAGES_TO_TEST);\n+\n+        bkpm = new BookkeeperPersistenceManager(bktb.bk, mm, tm,\n+                                                new ChangeLedgerServerConfiguration(), scheduler);\n+\n+        // acquire the topic\n+        StubCallback<Void> stubCallback = new StubCallback<Void>();\n+        bkpm.acquiredTopic(topic, stubCallback, null);\n+        assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n+        assertEquals(0, bkpm.topicInfos.get(topic).ledgerRanges.size());\n+\n+        while (index < messages.size()) {\n+            logger.debug(\"Persist message {}\", (index + 1));\n+            StubCallback<MessageSeqId> persistCallback = new StubCallback<MessageSeqId>();\n+            bkpm.persistMessage(new PersistRequest(topic, messages.get(index), persistCallback, null));\n+            assertEquals(index + 1, ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());\n+\n             index++;\n+            if (index % maxEntriesPerLedger == 1) {\n+                assertEquals(index / maxEntriesPerLedger, bkpm.topicInfos.get(topic).ledgerRanges.size());\n+            }\n         }\n+        assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger, bkpm.topicInfos.get(topic).ledgerRanges.size());\n \n-        // ensure the bkpm has the topic before scanning\n+        // Lets scan now\n+        StubScanCallback scanCallback = new StubScanCallback();\n+        bkpm.scanMessages(new RangeScanRequest(topic, 1, NUM_MESSAGES_TO_TEST, Long.MAX_VALUE, scanCallback, null));\n+        for (int i = 0; i < messages.size(); i++) {\n+            Message scannedMessage = ConcurrencyUtils.take(scanCallback.queue).left();\n+            assertTrue(messages.get(i).getBody().equals(scannedMessage.getBody()));\n+            assertEquals(i + 1, scannedMessage.getMsgId().getLocalComponent());\n+        }\n+        assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());\n+\n+        // Make the bkpm lose its memory\n+        bkpm.topicInfos.clear();\n+\n+        // acquire the topic again\n+        stubCallback = new StubCallback<Void>();\n+        bkpm.acquiredTopic(topic, stubCallback, null);\n+        assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n+        assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger + 1, bkpm.topicInfos.get(topic).ledgerRanges.size());\n+    }\n+\n+    class OrderCheckingCallback extends StubCallback<MessageSeqId> {\n+        long curMsgId;\n+        int numMessages;\n+        int numProcessed;\n+        int numSuccess;\n+        int numFailed;\n+\n+        OrderCheckingCallback(long startMsgId, int numMessages) {\n+            this.curMsgId = startMsgId;\n+            this.numMessages = numMessages;\n+            numProcessed = numSuccess = numFailed = 0;\n+        }\n+\n+        @Override\n+        public void operationFailed(Object ctx, final PubSubException exception) {\n+            synchronized (this) {\n+                ++numFailed;\n+                ++numProcessed;\n+                if (numProcessed == numMessages) {\n+                    MessageSeqId.Builder seqIdBuilder =\n+                        MessageSeqId.newBuilder().setLocalComponent(curMsgId);\n+                    super.operationFinished(ctx, seqIdBuilder.build());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, final MessageSeqId seqId) {\n+            synchronized(this) {\n+                long msgId = seqId.getLocalComponent();\n+                if (msgId == curMsgId) {\n+                    ++curMsgId;\n+                }\n+                ++numSuccess;\n+                ++numProcessed;\n+                if (numProcessed == numMessages) {\n+                    MessageSeqId.Builder seqIdBuilder =\n+                        MessageSeqId.newBuilder().setLocalComponent(curMsgId);\n+                    super.operationFinished(ctx, seqIdBuilder.build());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAsyncChangeLedgers() throws Exception {\n+        int NUM_MESSAGES_TO_TEST = 101;\n+        int SIZE_OF_MESSAGES_TO_TEST = 100;\n+        List<Message> messages = HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,\n+                                 SIZE_OF_MESSAGES_TO_TEST);\n+\n+        bkpm = new BookkeeperPersistenceManager(bktb.bk, mm, tm,\n+                                                new ChangeLedgerServerConfiguration(), scheduler);\n+\n+        // acquire the topic\n         StubCallback<Void> stubCallback = new StubCallback<Void>();\n         bkpm.acquiredTopic(topic, stubCallback, null);\n+        assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n+        assertEquals(0, bkpm.topicInfos.get(topic).ledgerRanges.size());\n+\n+        OrderCheckingCallback persistCallback =\n+            new OrderCheckingCallback(1, NUM_MESSAGES_TO_TEST);\n+        for (Message message : messages) {\n+            bkpm.persistMessage(new PersistRequest(topic, message, persistCallback, null));\n+        }\n+        assertEquals(NUM_MESSAGES_TO_TEST + 1,\n+                     ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());\n+        assertEquals(NUM_MESSAGES_TO_TEST, persistCallback.numSuccess);\n+        assertEquals(0, persistCallback.numFailed);\n+        assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger,\n+                     bkpm.topicInfos.get(topic).ledgerRanges.size());\n+\n+        // ensure the bkpm has the topic before scanning\n+        stubCallback = new StubCallback<Void>();\n+        bkpm.acquiredTopic(topic, stubCallback, null);\n \n         // Lets scan now\n         StubScanCallback scanCallback = new StubScanCallback();\n@@ -140,6 +296,64 @@ public void testNonEmptyDirtyLedger() throws Exception {\n         }\n         assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());\n \n+        // Make the bkpm lose its memory\n+        bkpm.topicInfos.clear();\n+\n+        // acquire the topic again\n+        stubCallback = new StubCallback<Void>();\n+        bkpm.acquiredTopic(topic, stubCallback, null);\n+        assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n+        assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger + 1,\n+                     bkpm.topicInfos.get(topic).ledgerRanges.size());\n+    }\n+\n+    class ChangeLedgerCallback extends OrderCheckingCallback {\n+        boolean tearDown = false;\n+        ChangeLedgerCallback(long startMsgId, int numMessages) {\n+            super(startMsgId, numMessages);\n+        }\n+\n+        @Override\n+        public void operationFinished(Object ctx, final MessageSeqId msgId) {\n+            super.operationFinished(ctx, msgId);\n+            // shutdown bookie server when changing ledger\n+            // so following requests should fail\n+            if (msgId.getLocalComponent() >= maxEntriesPerLedger && !tearDown) {\n+                try {\n+                    bktb.tearDownOneBookieServer();\n+                    bktb.tearDownOneBookieServer();\n+                } catch (Exception e) {\n+                    logger.error(\"Failed to tear down bookie server.\");\n+                }\n+                tearDown = true;\n+            }\n+        }\n     }\n \n+    @Test\n+    public void testChangeLedgerFailure() throws Exception {\n+        int NUM_MESSAGES_TO_TEST = 101;\n+        int SIZE_OF_MESSAGES_TO_TEST = 100;\n+        List<Message> messages = HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,\n+                                 SIZE_OF_MESSAGES_TO_TEST);\n+\n+        bkpm = new BookkeeperPersistenceManager(bktb.bk, mm, tm,\n+                                                new ChangeLedgerServerConfiguration(), scheduler);\n+\n+        // acquire the topic\n+        StubCallback<Void> stubCallback = new StubCallback<Void>();\n+        bkpm.acquiredTopic(topic, stubCallback, null);\n+        assertNull(ConcurrencyUtils.take(stubCallback.queue).right());\n+        assertEquals(0, bkpm.topicInfos.get(topic).ledgerRanges.size());\n+\n+        ChangeLedgerCallback persistCallback =\n+            new ChangeLedgerCallback(1, NUM_MESSAGES_TO_TEST);\n+        for (Message message : messages) {\n+            bkpm.persistMessage(new PersistRequest(topic, message, persistCallback, null));\n+        }\n+        assertEquals(maxEntriesPerLedger + 1,\n+                     ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());\n+        assertEquals(maxEntriesPerLedger, persistCallback.numSuccess);\n+        assertEquals(NUM_MESSAGES_TO_TEST - maxEntriesPerLedger, persistCallback.numFailed);\n+    }\n }"}]}

