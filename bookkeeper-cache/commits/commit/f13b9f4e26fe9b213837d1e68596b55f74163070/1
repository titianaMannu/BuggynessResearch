{"sha":"f13b9f4e26fe9b213837d1e68596b55f74163070","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmMTNiOWY0ZTI2ZmU5YjIxMzgzN2QxZTY4NTk2YjU1Zjc0MTYzMDcw","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-07-18T15:00:47Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-07-18T15:00:47Z"},"message":"BOOKKEEPER-2: bookkeeper does not put enough meta-data in to do recovery properly (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1362974 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"70f20720ddf11986f21ed001ba5c8e468671e7fb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/70f20720ddf11986f21ed001ba5c8e468671e7fb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f13b9f4e26fe9b213837d1e68596b55f74163070","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f13b9f4e26fe9b213837d1e68596b55f74163070","html_url":"https://github.com/apache/bookkeeper/commit/f13b9f4e26fe9b213837d1e68596b55f74163070","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f13b9f4e26fe9b213837d1e68596b55f74163070/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"e60f542937a51dd3bb05b770a989478625c734af","url":"https://api.github.com/repos/apache/bookkeeper/commits/e60f542937a51dd3bb05b770a989478625c734af","html_url":"https://github.com/apache/bookkeeper/commit/e60f542937a51dd3bb05b770a989478625c734af"}],"stats":{"total":676,"additions":597,"deletions":79},"files":[{"sha":"5b9845f20d1df64d67c9b19eb9f4e1ab86bd6b46","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -54,6 +54,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-328: Bookie DeathWatcher is missing thread name (Rakesh via sijie)\n \n+        BOOKKEEPER-2: bookkeeper does not put enough meta-data in to do recovery properly (ivank via sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"e4e5809863a98c2654b07ef81e5aca0a5c8fdbb3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":28,"deletions":43,"changes":71,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -37,7 +37,6 @@\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n@@ -51,7 +50,6 @@\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.data.Stat;\n import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n@@ -76,16 +74,6 @@\n      */\n     private Random rand = new Random();\n \n-    /*\n-     * For now, assume that all ledgers were created with the same DigestType\n-     * and password. In the future, this admin tool will need to know for each\n-     * ledger, what was the DigestType and password used to create it before it\n-     * can open it. These values will come from System properties, though hard\n-     * coded defaults are defined here.\n-     */\n-    private DigestType DIGEST_TYPE;\n-    private byte[] PASSWD;\n-\n     /**\n      * Constructor that takes in a ZooKeeper servers connect string so we know\n      * how to connect to ZooKeeper to retrieve information about the BookKeeper\n@@ -147,9 +135,6 @@ public void process(WatchedEvent event) {\n         bookiesPath = conf.getZkAvailableBookiesPath();\n         // Create the BookKeeper client instance\n         bkc = new BookKeeper(conf, zk);\n-\n-        DIGEST_TYPE = conf.getBookieRecoveryDigestType();\n-        PASSWD = conf.getBookieRecoveryPasswd();\n     }\n \n     /**\n@@ -165,31 +150,38 @@ public void close() throws InterruptedException, BKException {\n     }\n \n     /**\n-     * Method to get the input ledger's digest type. For now, this is just a\n-     * placeholder function since there is no way we can get this information\n-     * easily. In the future, BookKeeper should store this ledger metadata\n-     * somewhere such that an admin tool can access it.\n+     * Open a ledger as an administrator. This means that no digest password\n+     * checks are done. Otherwise, the call is identical to BookKeeper#asyncOpenLedger\n+     *\n+     * @param lId\n+     *          ledger identifier\n+     * @param cb\n+     *          Callback which will receive a LedgerHandle object\n+     * @param ctx\n+     *          optional context object, to be passwd to the callback (can be null)\n      *\n-     * @param ledgerId\n-     *            LedgerId we are retrieving the digestType for.\n-     * @return DigestType for the input ledger\n+     * @see BookKeeper#asyncOpenLedger\n      */\n-    private DigestType getLedgerDigestType(long ledgerId) {\n-        return DIGEST_TYPE;\n+    public void asyncOpenLedger(final long lId, final OpenCallback cb, final Object ctx) {\n+        new LedgerOpenOp(bkc, lId, cb, ctx).initiate();\n     }\n \n     /**\n-     * Method to get the input ledger's password. For now, this is just a\n-     * placeholder function since there is no way we can get this information\n-     * easily. In the future, BookKeeper should store this ledger metadata\n-     * somewhere such that an admin tool can access it.\n+     * Open a ledger as an administrator without recovering the ledger. This means\n+     * that no digest password  checks are done. Otherwise, the call is identical\n+     * to BookKeeper#asyncOpenLedgerNoRecovery\n      *\n-     * @param ledgerId\n-     *            LedgerId we are retrieving the password for.\n-     * @return Password for the input ledger\n+     * @param lId\n+     *          ledger identifier\n+     * @param cb\n+     *          Callback which will receive a LedgerHandle object\n+     * @param ctx\n+     *          optional context object, to be passwd to the callback (can be null)\n+     *\n+     * @see BookKeeper#asyncOpenLedgerNoRecovery\n      */\n-    private byte[] getLedgerPasswd(long ledgerId) {\n-        return PASSWD;\n+    public void asyncOpenLedgerNoRecovery(final long lId, final OpenCallback cb, final Object ctx) {\n+        new LedgerOpenOp(bkc, lId, cb, ctx).initiateWithoutRecovery();\n     }\n \n     // Object used for calling async methods and waiting for them to complete.\n@@ -430,15 +422,8 @@ private void recoverLedger(final InetSocketAddress bookieSrc, final long lId,\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Recovering ledger : \" + lId);\n         }\n-        /*\n-         * For the current ledger, open it to retrieve the LedgerHandle. This\n-         * will contain the LedgerMetadata indicating which bookie servers the\n-         * ledger fragments are stored on. Check if any of the ledger fragments\n-         * for the current ledger are stored on the input dead bookie.\n-         */\n-        final DigestType digestType = getLedgerDigestType(lId);\n-        final byte[] passwd = getLedgerPasswd(lId);\n-        bkc.asyncOpenLedgerNoRecovery(lId, digestType, passwd, new OpenCallback() {\n+\n+        asyncOpenLedgerNoRecovery(lId, new OpenCallback() {\n             @Override\n             public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                 if (rc != Code.OK.intValue()) {\n@@ -463,7 +448,7 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                         } catch (Exception ie) {\n                             LOG.warn(\"Error closing non recovery ledger handle for ledger \" + lId, ie);\n                         }\n-                        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+                        asyncOpenLedger(lId, new OpenCallback() {\n                             @Override\n                             public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n                                 if (newrc != Code.OK.intValue()) {"},{"sha":"2753680f23a556109fdec840f9fa01b7e599873c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -116,6 +116,13 @@ private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skip\n         ByteBuffer dataReceivedBuffer = dataReceived.toByteBuffer();\n         byte[] digest;\n \n+        if ((METADATA_LENGTH + macCodeLength) > dataReceived.readableBytes()) {\n+            logger.error(\"Data received is smaller than the minimum for this digest type. \"\n+                    + \" Either the packet it corrupt, or the wrong digest is configured. \"\n+                    + \" Digest type: {}, Packet Length: {}\",\n+                    this.getClass().getName(), dataReceived.readableBytes());\n+            throw new BKDigestMatchException();\n+        }\n         update(dataReceivedBuffer.array(), dataReceivedBuffer.position(), METADATA_LENGTH);\n \n         int offset = METADATA_LENGTH + macCodeLength;"},{"sha":"26ebad4945b9814133d87f9777f09e3f1532010c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -21,7 +21,6 @@\n \n package org.apache.bookkeeper.client;\n \n-import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n@@ -71,7 +70,7 @@\n \n     LedgerCreateOp(BookKeeper bk, int ensembleSize, int quorumSize, DigestType digestType, byte[] passwd, CreateCallback cb, Object ctx) {\n         this.bk = bk;\n-        this.metadata = new LedgerMetadata(ensembleSize, quorumSize);\n+        this.metadata = new LedgerMetadata(ensembleSize, quorumSize, digestType, passwd);\n         this.digestType = digestType;\n         this.passwd = passwd;\n         this.cb = cb;"},{"sha":"55dcbd80c76f0ce795b987cfb8bf6d295ca3585b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":52,"deletions":5,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -27,12 +27,13 @@\n import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n+import java.util.Arrays;\n \n import org.apache.bookkeeper.versioning.Version;\n import com.google.protobuf.TextFormat;\n+import com.google.protobuf.ByteString;\n import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat;\n import org.apache.bookkeeper.util.StringUtils;\n-import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -69,7 +70,12 @@\n     ArrayList<InetSocketAddress> currentEnsemble;\n     volatile Version version = null;\n \n-    public LedgerMetadata(int ensembleSize, int quorumSize) {\n+    private boolean hasPassword = false;\n+    private LedgerMetadataFormat.DigestType digestType;\n+    private byte[] password;\n+\n+    public LedgerMetadata(int ensembleSize, int quorumSize,\n+                          BookKeeper.DigestType digestType, byte[] password) {\n         this.ensembleSize = ensembleSize;\n         this.quorumSize = quorumSize;\n \n@@ -81,10 +87,16 @@ public LedgerMetadata(int ensembleSize, int quorumSize) {\n         this.state = LedgerMetadataFormat.State.OPEN;\n         this.lastEntryId = LedgerHandle.INVALID_ENTRY_ID;\n         this.metadataFormatVersion = CURRENT_METADATA_FORMAT_VERSION;\n-    };\n+\n+        this.digestType = digestType.equals(BookKeeper.DigestType.MAC) ?\n+            LedgerMetadataFormat.DigestType.HMAC : LedgerMetadataFormat.DigestType.CRC32;\n+        this.password = Arrays.copyOf(password, password.length);\n+        this.hasPassword = true;\n+    }\n \n     private LedgerMetadata() {\n-        this(0, 0);\n+        this(0, 0, BookKeeper.DigestType.MAC, new byte[] {});\n+        this.hasPassword = false;\n     }\n \n     /**\n@@ -106,6 +118,28 @@ public int getQuorumSize() {\n         return quorumSize;\n     }\n \n+    /**\n+     * In versions 4.1.0 and below, the digest type and password were not\n+     * stored in the metadata.\n+     *\n+     * @return whether the password has been stored in the metadata\n+     */\n+    boolean hasPassword() {\n+        return hasPassword;\n+    }\n+\n+    byte[] getPassword() {\n+        return Arrays.copyOf(password, password.length);\n+    }\n+\n+    BookKeeper.DigestType getDigestType() {\n+        if (digestType.equals(LedgerMetadataFormat.DigestType.HMAC)) {\n+            return BookKeeper.DigestType.MAC;\n+        } else {\n+            return BookKeeper.DigestType.CRC32;\n+        }\n+    }\n+\n     public long getLastEntryId() {\n         return lastEntryId;\n     }\n@@ -185,6 +219,11 @@ long getNextEnsembleChange(long entryId) {\n         LedgerMetadataFormat.Builder builder = LedgerMetadataFormat.newBuilder();\n         builder.setQuorumSize(quorumSize).setEnsembleSize(ensembleSize).setLength(length)\n             .setState(state).setLastEntryId(lastEntryId);\n+\n+        if (hasPassword) {\n+            builder.setDigestType(digestType).setPassword(ByteString.copyFrom(password));\n+        }\n+\n         for (Map.Entry<Long, ArrayList<InetSocketAddress>> entry : ensembles.entrySet()) {\n             LedgerMetadataFormat.Segment.Builder segmentBuilder = LedgerMetadataFormat.Segment.newBuilder();\n             segmentBuilder.setFirstEntryId(entry.getKey());\n@@ -288,6 +327,12 @@ public static LedgerMetadata parseConfig(byte[] bytes, Version version) throws I\n         lc.state = data.getState();\n         lc.lastEntryId = data.getLastEntryId();\n \n+        if (data.hasPassword()) {\n+            lc.digestType = data.getDigestType();\n+            lc.password = data.getPassword().toByteArray();\n+            lc.hasPassword = true;\n+        }\n+\n         for (LedgerMetadataFormat.Segment s : data.getSegmentList()) {\n             ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n             for (String member : s.getEnsembleMemberList()) {\n@@ -370,7 +415,9 @@ boolean resolveConflict(LedgerMetadata newMeta) {\n             ensembleSize != newMeta.ensembleSize ||\n             quorumSize != newMeta.quorumSize ||\n             length != newMeta.length ||\n-            state != newMeta.state) {\n+            state != newMeta.state ||\n+            !digestType.equals(newMeta.digestType) ||\n+            !Arrays.equals(password, newMeta.password)) {\n             return false;\n         }\n         if (state == LedgerMetadataFormat.State.CLOSED"},{"sha":"520f0d2f809ca4bdcdd714bc1590a7a36c37366f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":42,"deletions":4,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -21,7 +21,7 @@\n \n package org.apache.bookkeeper.client;\n \n-import java.io.IOException;\n+import java.util.Arrays;\n import java.security.GeneralSecurityException;\n \n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n@@ -46,7 +46,8 @@\n     LedgerHandle lh;\n     final byte[] passwd;\n     final DigestType digestType;\n-    boolean doRecovery;\n+    boolean doRecovery = true;\n+    boolean administrativeOpen = false;\n \n     /**\n      * Constructor.\n@@ -58,16 +59,25 @@\n      * @param cb\n      * @param ctx\n      */\n-    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd, \n+    public LedgerOpenOp(BookKeeper bk, long ledgerId, DigestType digestType, byte[] passwd,\n                         OpenCallback cb, Object ctx) {\n         this.bk = bk;\n         this.ledgerId = ledgerId;\n         this.passwd = passwd;\n         this.cb = cb;\n         this.ctx = ctx;\n         this.digestType = digestType;\n+    }\n \n-        this.doRecovery = true;\n+    public LedgerOpenOp(BookKeeper bk, long ledgerId, OpenCallback cb, Object ctx) {\n+        this.bk = bk;\n+        this.ledgerId = ledgerId;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+\n+        this.passwd = bk.getConf().getBookieRecoveryPasswd();\n+        this.digestType = bk.getConf().getBookieRecoveryDigestType();\n+        this.administrativeOpen = true;\n     }\n \n     /**\n@@ -97,6 +107,34 @@ public void operationComplete(int rc, LedgerMetadata metadata) {\n             cb.openComplete(rc, null, this.ctx);\n             return;\n         }\n+\n+        final byte[] passwd;\n+        final DigestType digestType;\n+\n+        /* For an administrative open, the default passwords\n+         * are read from the configuration, but if the metadata\n+         * already contains passwords, use these instead. */\n+        if (administrativeOpen && metadata.hasPassword()) {\n+            passwd = metadata.getPassword();\n+            digestType = metadata.getDigestType();\n+        } else {\n+            passwd = this.passwd;\n+            digestType = this.digestType;\n+\n+            if (metadata.hasPassword()) {\n+                if (!Arrays.equals(passwd, metadata.getPassword())) {\n+                    LOG.error(\"Provided passwd does not match that in metadata\");\n+                    cb.openComplete(BKException.Code.UnauthorizedAccessException, null, this.ctx);\n+                    return;\n+                }\n+                if (digestType != metadata.getDigestType()) {\n+                    LOG.error(\"Provided digest does not match that in metadata\");\n+                    cb.openComplete(BKException.Code.DigestMatchException, null, this.ctx);\n+                    return;\n+                }\n+            }\n+        }\n+\n         // get the ledger metadata back\n         try {\n             lh = new ReadOnlyLedgerHandle(bk, ledgerId, metadata, digestType, passwd);"},{"sha":"b69ff1d56f1e8d8733c2a4db7cf2d920dfac6b17","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","status":"modified","additions":205,"deletions":7,"changes":212,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DataFormats.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -40,6 +40,14 @@ public static void registerAllExtensions(\n         getSegmentOrBuilderList();\n     org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.SegmentOrBuilder getSegmentOrBuilder(\n         int index);\n+    \n+    // optional .LedgerMetadataFormat.DigestType digestType = 7;\n+    boolean hasDigestType();\n+    org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType getDigestType();\n+    \n+    // optional bytes password = 8;\n+    boolean hasPassword();\n+    com.google.protobuf.ByteString getPassword();\n   }\n   public static final class LedgerMetadataFormat extends\n       com.google.protobuf.GeneratedMessage\n@@ -141,6 +149,75 @@ private State(int index, int value) {\n       // @@protoc_insertion_point(enum_scope:LedgerMetadataFormat.State)\n     }\n     \n+    public enum DigestType\n+        implements com.google.protobuf.ProtocolMessageEnum {\n+      CRC32(0, 1),\n+      HMAC(1, 2),\n+      ;\n+      \n+      public static final int CRC32_VALUE = 1;\n+      public static final int HMAC_VALUE = 2;\n+      \n+      \n+      public final int getNumber() { return value; }\n+      \n+      public static DigestType valueOf(int value) {\n+        switch (value) {\n+          case 1: return CRC32;\n+          case 2: return HMAC;\n+          default: return null;\n+        }\n+      }\n+      \n+      public static com.google.protobuf.Internal.EnumLiteMap<DigestType>\n+          internalGetValueMap() {\n+        return internalValueMap;\n+      }\n+      private static com.google.protobuf.Internal.EnumLiteMap<DigestType>\n+          internalValueMap =\n+            new com.google.protobuf.Internal.EnumLiteMap<DigestType>() {\n+              public DigestType findValueByNumber(int number) {\n+                return DigestType.valueOf(number);\n+              }\n+            };\n+      \n+      public final com.google.protobuf.Descriptors.EnumValueDescriptor\n+          getValueDescriptor() {\n+        return getDescriptor().getValues().get(index);\n+      }\n+      public final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptorForType() {\n+        return getDescriptor();\n+      }\n+      public static final com.google.protobuf.Descriptors.EnumDescriptor\n+          getDescriptor() {\n+        return org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.getDescriptor().getEnumTypes().get(1);\n+      }\n+      \n+      private static final DigestType[] VALUES = {\n+        CRC32, HMAC, \n+      };\n+      \n+      public static DigestType valueOf(\n+          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n+        if (desc.getType() != getDescriptor()) {\n+          throw new java.lang.IllegalArgumentException(\n+            \"EnumValueDescriptor is not for this type.\");\n+        }\n+        return VALUES[desc.getIndex()];\n+      }\n+      \n+      private final int index;\n+      private final int value;\n+      \n+      private DigestType(int index, int value) {\n+        this.index = index;\n+        this.value = value;\n+      }\n+      \n+      // @@protoc_insertion_point(enum_scope:LedgerMetadataFormat.DigestType)\n+    }\n+    \n     public interface SegmentOrBuilder\n         extends com.google.protobuf.MessageOrBuilder {\n       \n@@ -670,13 +747,35 @@ public int getSegmentCount() {\n       return segment_.get(index);\n     }\n     \n+    // optional .LedgerMetadataFormat.DigestType digestType = 7;\n+    public static final int DIGESTTYPE_FIELD_NUMBER = 7;\n+    private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType digestType_;\n+    public boolean hasDigestType() {\n+      return ((bitField0_ & 0x00000020) == 0x00000020);\n+    }\n+    public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType getDigestType() {\n+      return digestType_;\n+    }\n+    \n+    // optional bytes password = 8;\n+    public static final int PASSWORD_FIELD_NUMBER = 8;\n+    private com.google.protobuf.ByteString password_;\n+    public boolean hasPassword() {\n+      return ((bitField0_ & 0x00000040) == 0x00000040);\n+    }\n+    public com.google.protobuf.ByteString getPassword() {\n+      return password_;\n+    }\n+    \n     private void initFields() {\n       quorumSize_ = 0;\n       ensembleSize_ = 0;\n       length_ = 0L;\n       lastEntryId_ = 0L;\n       state_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State.OPEN;\n       segment_ = java.util.Collections.emptyList();\n+      digestType_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.CRC32;\n+      password_ = com.google.protobuf.ByteString.EMPTY;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -730,6 +829,12 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       for (int i = 0; i < segment_.size(); i++) {\n         output.writeMessage(6, segment_.get(i));\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        output.writeEnum(7, digestType_.getNumber());\n+      }\n+      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n+        output.writeBytes(8, password_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -763,6 +868,14 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(6, segment_.get(i));\n       }\n+      if (((bitField0_ & 0x00000020) == 0x00000020)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeEnumSize(7, digestType_.getNumber());\n+      }\n+      if (((bitField0_ & 0x00000040) == 0x00000040)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(8, password_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -904,6 +1017,10 @@ public Builder clear() {\n         } else {\n           segmentBuilder_.clear();\n         }\n+        digestType_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.CRC32;\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        password_ = com.google.protobuf.ByteString.EMPTY;\n+        bitField0_ = (bitField0_ & ~0x00000080);\n         return this;\n       }\n       \n@@ -971,6 +1088,14 @@ public Builder clone() {\n         } else {\n           result.segment_ = segmentBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {\n+          to_bitField0_ |= 0x00000020;\n+        }\n+        result.digestType_ = digestType_;\n+        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {\n+          to_bitField0_ |= 0x00000040;\n+        }\n+        result.password_ = password_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -1028,6 +1153,12 @@ public Builder mergeFrom(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataF\n             }\n           }\n         }\n+        if (other.hasDigestType()) {\n+          setDigestType(other.getDigestType());\n+        }\n+        if (other.hasPassword()) {\n+          setPassword(other.getPassword());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -1118,6 +1249,22 @@ public Builder mergeFrom(\n               addSegment(subBuilder.buildPartial());\n               break;\n             }\n+            case 56: {\n+              int rawValue = input.readEnum();\n+              org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType value = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.valueOf(rawValue);\n+              if (value == null) {\n+                unknownFields.mergeVarintField(7, rawValue);\n+              } else {\n+                bitField0_ |= 0x00000040;\n+                digestType_ = value;\n+              }\n+              break;\n+            }\n+            case 66: {\n+              bitField0_ |= 0x00000080;\n+              password_ = input.readBytes();\n+              break;\n+            }\n           }\n         }\n       }\n@@ -1418,6 +1565,54 @@ public Builder removeSegment(int index) {\n         return segmentBuilder_;\n       }\n       \n+      // optional .LedgerMetadataFormat.DigestType digestType = 7;\n+      private org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType digestType_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.CRC32;\n+      public boolean hasDigestType() {\n+        return ((bitField0_ & 0x00000040) == 0x00000040);\n+      }\n+      public org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType getDigestType() {\n+        return digestType_;\n+      }\n+      public Builder setDigestType(org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000040;\n+        digestType_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearDigestType() {\n+        bitField0_ = (bitField0_ & ~0x00000040);\n+        digestType_ = org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.DigestType.CRC32;\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // optional bytes password = 8;\n+      private com.google.protobuf.ByteString password_ = com.google.protobuf.ByteString.EMPTY;\n+      public boolean hasPassword() {\n+        return ((bitField0_ & 0x00000080) == 0x00000080);\n+      }\n+      public com.google.protobuf.ByteString getPassword() {\n+        return password_;\n+      }\n+      public Builder setPassword(com.google.protobuf.ByteString value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000080;\n+        password_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearPassword() {\n+        bitField0_ = (bitField0_ & ~0x00000080);\n+        password_ = getDefaultInstance().getPassword();\n+        onChanged();\n+        return this;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:LedgerMetadataFormat)\n     }\n     \n@@ -1448,16 +1643,19 @@ public Builder removeSegment(int index) {\n       descriptor;\n   static {\n     java.lang.String[] descriptorData = {\n-      \"\\n src/main/proto/DataFormats.proto\\\"\\260\\002\\n\\024L\" +\n+      \"\\n src/main/proto/DataFormats.proto\\\"\\233\\003\\n\\024L\" +\n       \"edgerMetadataFormat\\022\\022\\n\\nquorumSize\\030\\001 \\002(\\005\\022\" +\n       \"\\024\\n\\014ensembleSize\\030\\002 \\002(\\005\\022\\016\\n\\006length\\030\\003 \\002(\\003\\022\\023\\n\" +\n       \"\\013lastEntryId\\030\\004 \\001(\\003\\0220\\n\\005state\\030\\005 \\002(\\0162\\033.Ledg\" +\n       \"erMetadataFormat.State:\\004OPEN\\022.\\n\\007segment\\030\" +\n-      \"\\006 \\003(\\0132\\035.LedgerMetadataFormat.Segment\\0327\\n\\007\" +\n-      \"Segment\\022\\026\\n\\016ensembleMember\\030\\001 \\003(\\t\\022\\024\\n\\014first\" +\n-      \"EntryId\\030\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\\004OPEN\\020\\001\\022\\017\\n\\013IN_R\" +\n-      \"ECOVERY\\020\\002\\022\\n\\n\\006CLOSED\\020\\003B\\037\\n\\033org.apache.book\" +\n-      \"keeper.protoH\\001\"\n+      \"\\006 \\003(\\0132\\035.LedgerMetadataFormat.Segment\\0224\\n\\n\" +\n+      \"digestType\\030\\007 \\001(\\0162 .LedgerMetadataFormat.\" +\n+      \"DigestType\\022\\020\\n\\010password\\030\\010 \\001(\\014\\0327\\n\\007Segment\\022\" +\n+      \"\\026\\n\\016ensembleMember\\030\\001 \\003(\\t\\022\\024\\n\\014firstEntryId\\030\" +\n+      \"\\002 \\002(\\003\\\".\\n\\005State\\022\\010\\n\\004OPEN\\020\\001\\022\\017\\n\\013IN_RECOVERY\\020\",\n+      \"\\002\\022\\n\\n\\006CLOSED\\020\\003\\\"!\\n\\nDigestType\\022\\t\\n\\005CRC32\\020\\001\\022\\010\" +\n+      \"\\n\\004HMAC\\020\\002B\\037\\n\\033org.apache.bookkeeper.protoH\" +\n+      \"\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -1469,7 +1667,7 @@ public Builder removeSegment(int index) {\n           internal_static_LedgerMetadataFormat_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_LedgerMetadataFormat_descriptor,\n-              new java.lang.String[] { \"QuorumSize\", \"EnsembleSize\", \"Length\", \"LastEntryId\", \"State\", \"Segment\", },\n+              new java.lang.String[] { \"QuorumSize\", \"EnsembleSize\", \"Length\", \"LastEntryId\", \"State\", \"Segment\", \"DigestType\", \"Password\", },\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.class,\n               org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.Builder.class);\n           internal_static_LedgerMetadataFormat_Segment_descriptor ="},{"sha":"c861bde5e60cc20b3175753c07c3073bdd0f6d55","filename":"bookkeeper-server/src/main/proto/DataFormats.proto","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/proto/DataFormats.proto","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/main/proto/DataFormats.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/proto/DataFormats.proto?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -36,7 +36,14 @@ message LedgerMetadataFormat {\n \n     message Segment {\n         repeated string ensembleMember = 1;\n-        required int64 firstEntryId = 2; \n+        required int64 firstEntryId = 2;\n     }\n     repeated Segment segment = 6;\n+\n+    enum DigestType {\n+        CRC32 = 1;\n+        HMAC = 2;\n+    }\n+    optional DigestType digestType = 7;\n+    optional bytes password = 8;\n }\n\\ No newline at end of file"},{"sha":"b2d03c4b014f8171cbdd4838415c7514059d5db9","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":70,"deletions":8,"changes":78,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -21,14 +21,11 @@\n *\n */\n \n-import java.util.Enumeration;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.test.BaseTestCase;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.WatchedEvent;\n@@ -41,9 +38,15 @@\n /**\n  * Tests of the main BookKeeper client\n  */\n-public class BookKeeperTest extends BookKeeperClusterTestCase {\n-    public BookKeeperTest() {\n+public class BookKeeperTest extends BaseTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(BookKeeperTest.class);\n+\n+    DigestType digestType;\n+\n+    public BookKeeperTest(DigestType digestType) {\n         super(4);\n+\n+        this.digestType = digestType;\n     }\n \n     @Test\n@@ -57,7 +60,7 @@ public void testConstructionZkDelay() throws Exception {\n         l.await();\n \n         BookKeeper bkc = new BookKeeper(conf);\n-        bkc.createLedger(DigestType.CRC32, \"testPasswd\".getBytes()).close();\n+        bkc.createLedger(digestType, \"testPasswd\".getBytes()).close();\n         bkc.close();\n     }\n \n@@ -85,4 +88,63 @@ public void process(WatchedEvent event) {\n             // correct behaviour\n         }\n     }\n-}\n\\ No newline at end of file\n+\n+    /**\n+     * Test that bookkeeper is not able to open ledgers if\n+     * it provides the wrong password or wrong digest\n+     */\n+    @Test\n+    public void testBookkeeperPassword() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString());\n+        BookKeeper bkc = new BookKeeper(conf);\n+\n+        DigestType digestCorrect = digestType;\n+        byte[] passwdCorrect = \"AAAAAAA\".getBytes();\n+        DigestType digestBad = digestType == DigestType.MAC ? DigestType.CRC32 : DigestType.MAC;\n+        byte[] passwdBad = \"BBBBBBB\".getBytes();\n+\n+\n+        LedgerHandle lh = null;\n+        try {\n+            lh = bkc.createLedger(digestCorrect, passwdCorrect);\n+            long id = lh.getId();\n+            for (int i = 0; i < 100; i++) {\n+                lh.addEntry(\"foobar\".getBytes());\n+            }\n+            lh.close();\n+\n+            // try open with bad passwd\n+            try {\n+                bkc.openLedger(id, digestCorrect, passwdBad);\n+                fail(\"Shouldn't be able to open with bad passwd\");\n+            } catch (BKException.BKUnauthorizedAccessException bke) {\n+                // correct behaviour\n+            }\n+\n+            // try open with bad digest\n+            try {\n+                bkc.openLedger(id, digestBad, passwdCorrect);\n+                fail(\"Shouldn't be able to open with bad digest\");\n+            } catch (BKException.BKDigestMatchException bke) {\n+                // correct behaviour\n+            }\n+\n+            // try open with both bad\n+            try {\n+                bkc.openLedger(id, digestBad, passwdBad);\n+                fail(\"Shouldn't be able to open with bad passwd and digest\");\n+            } catch (BKException.BKUnauthorizedAccessException bke) {\n+                // correct behaviour\n+            }\n+\n+            // try open with both correct\n+            bkc.openLedger(id, digestCorrect, passwdCorrect).close();\n+        } finally {\n+            if (lh != null) {\n+                lh.close();\n+            }\n+            bkc.close();\n+        }\n+    }\n+}"},{"sha":"79f0a0cd37d89fa23e2b9b013e5a6d7d7ebfcc4a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":179,"deletions":7,"changes":186,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -32,7 +32,6 @@\n import java.util.HashMap;\n import java.util.Collections;\n import java.util.Random;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.jboss.netty.buffer.ChannelBuffer;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -41,16 +40,10 @@\n import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.LedgerEntry;\n-import org.apache.bookkeeper.client.LedgerHandle;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.client.BookKeeperAdmin;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.junit.After;\n@@ -90,6 +83,7 @@ public void recoverComplete(int rc, Object ctx) {\n \n     // Objects to use for this jUnit test.\n     DigestType digestType;\n+    String ledgerManagerFactory;\n     SyncObject sync;\n     BookieRecoverCallback bookieRecoverCb;\n     BookKeeperAdmin bkAdmin;\n@@ -98,6 +92,7 @@ public void recoverComplete(int rc, Object ctx) {\n     public BookieRecoveryTest(String ledgerManagerFactory, DigestType digestType) {\n         super(3);\n         this.digestType = digestType;\n+        this.ledgerManagerFactory = ledgerManagerFactory;\n         LOG.info(\"Using ledger manager \" + ledgerManagerFactory);\n         // set ledger manager\n         baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n@@ -759,4 +754,181 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             }\n         }\n     }\n+\n+    @Test\n+    public void recoverWithoutPasswordInConf() throws Exception {\n+        byte[] passwdCorrect = \"AAAAAA\".getBytes();\n+        byte[] passwdBad = \"BBBBBB\".getBytes();\n+        DigestType digestCorrect = digestType;\n+        DigestType digestBad = (digestType == DigestType.MAC) ? DigestType.CRC32 : DigestType.MAC;\n+\n+        LedgerHandle lh = bkc.createLedger(3, 2, digestCorrect, passwdCorrect);\n+        long ledgerId = lh.getId();\n+        for (int i = 0; i < 100; i++) {\n+            lh.addEntry(\"foobar\".getBytes());\n+        }\n+        lh.close();\n+\n+        InetSocketAddress bookieSrc = bs.get(0).getLocalAddress();\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+        startNewBookie();\n+\n+        // Check that entries are missing\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertFalse(\"Should be entries missing\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+\n+        // Try to recover with bad password in conf\n+        // This is fine, because it only falls back to the configured\n+        // password if the password info is missing from the metadata\n+        ClientConfiguration adminConf = new ClientConfiguration();\n+        adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        adminConf.setBookieRecoveryDigestType(digestCorrect);\n+        adminConf.setBookieRecoveryPasswd(passwdBad);\n+\n+        BookKeeperAdmin bka = new BookKeeperAdmin(adminConf);\n+        bka.recoverBookieData(bookieSrc, null);\n+        bka.close();\n+\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertTrue(\"Should be back to fully replication\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+\n+        bookieSrc = bs.get(0).getLocalAddress();\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+        startNewBookie();\n+\n+        // Check that entries are missing\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertFalse(\"Should be entries missing\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+\n+        // Try to recover with no password in conf\n+        adminConf = new ClientConfiguration();\n+        adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+\n+        bka = new BookKeeperAdmin(adminConf);\n+        bka.recoverBookieData(bookieSrc, null);\n+        bka.close();\n+\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertTrue(\"Should be back to fully replication\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+    }\n+\n+    /**\n+     * Test that when we try to recover a ledger which doesn't have\n+     * the password stored in the configuration, we don't succeed\n+     */\n+    @Test\n+    public void ensurePasswordUsedForOldLedgers() throws Exception {\n+        // stop all bookies\n+        // and wipe the ledger layout so we can use an old client\n+        zkUtil.getZooKeeperClient().delete(\"/ledgers/LAYOUT\", -1);\n+\n+        byte[] passwdCorrect = \"AAAAAA\".getBytes();\n+        byte[] passwdBad = \"BBBBBB\".getBytes();\n+        DigestType digestCorrect = digestType;\n+        DigestType digestBad = digestCorrect == DigestType.MAC ? DigestType.CRC32 : DigestType.MAC;\n+\n+        org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType digestCorrect410\n+            = org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType.valueOf(digestType.toString());\n+\n+        org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration c\n+            = new org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration();\n+        c.setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setLedgerManagerType(\n+                    ledgerManagerFactory.equals(\"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\") ?\n+                    \"flat\" : \"hierarchical\");\n+\n+        // create client to set up layout, close it, restart bookies, and open a new client.\n+        // the new client is necessary to ensure that it has all the restarted bookies in the\n+        // its available bookie list\n+        org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper bkc41\n+            = new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);\n+        bkc41.close();\n+        restartBookies();\n+        bkc41 = new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);\n+\n+        org.apache.bk_v4_1_0.bookkeeper.client.LedgerHandle lh41\n+            = bkc41.createLedger(3, 2, digestCorrect410, passwdCorrect);\n+        long ledgerId = lh41.getId();\n+        for (int i = 0; i < 100; i++) {\n+            lh41.addEntry(\"foobar\".getBytes());\n+        }\n+        lh41.close();\n+        bkc41.close();\n+\n+        // Startup a new bookie server\n+        int newBookiePort = startNewBookie();\n+        int removeIndex = 0;\n+        InetSocketAddress bookieSrc = bs.get(removeIndex).getLocalAddress();\n+        bs.get(removeIndex).shutdown();\n+        bs.remove(removeIndex);\n+\n+        // Check that entries are missing\n+        LedgerHandle lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertFalse(\"Should be entries missing\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+\n+        // Try to recover with bad password in conf\n+        // if the digest type is MAC\n+        // for CRC32, the password is only checked\n+        // when adding new entries, which recovery will\n+        // never do\n+        ClientConfiguration adminConf;\n+        BookKeeperAdmin bka;\n+        if (digestCorrect == DigestType.MAC) {\n+            adminConf = new ClientConfiguration();\n+            adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+            adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+            adminConf.setBookieRecoveryDigestType(digestCorrect);\n+            adminConf.setBookieRecoveryPasswd(passwdBad);\n+\n+            bka = new BookKeeperAdmin(adminConf);\n+            try {\n+                bka.recoverBookieData(bookieSrc, null);\n+                fail(\"Shouldn't be able to recover with wrong password\");\n+            } catch (BKException bke) {\n+                // correct behaviour\n+            } finally {\n+                bka.close();\n+            }\n+        }\n+\n+        // Try to recover with bad digest in conf\n+        adminConf = new ClientConfiguration();\n+        adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n+        adminConf.setBookieRecoveryDigestType(digestBad);\n+        adminConf.setBookieRecoveryPasswd(passwdCorrect);\n+\n+        bka = new BookKeeperAdmin(adminConf);\n+        try {\n+            bka.recoverBookieData(bookieSrc, null);\n+            fail(\"Shouldn't be able to recover with wrong digest\");\n+        } catch (BKException bke) {\n+            // correct behaviour\n+        } finally {\n+            bka.close();\n+        }\n+\n+        // Check that entries are still missing\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertFalse(\"Should be entries missing\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+\n+        adminConf.setBookieRecoveryDigestType(digestCorrect);\n+        adminConf.setBookieRecoveryPasswd(passwdCorrect);\n+\n+        bka = new BookKeeperAdmin(adminConf);\n+        bka.recoverBookieData(bookieSrc, null);\n+        bka.close();\n+\n+        lh = bkc.openLedgerNoRecovery(ledgerId, digestCorrect, passwdCorrect);\n+        assertTrue(\"Should have recovered everything\", verifyFullyReplicated(lh, 100));\n+        lh.close();\n+    }\n }"},{"sha":"265dfc77d612bc218255339e9dcb73194507924b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/f13b9f4e26fe9b213837d1e68596b55f74163070/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=f13b9f4e26fe9b213837d1e68596b55f74163070","patch":"@@ -21,7 +21,6 @@\n \n package org.apache.bookkeeper.meta;\n \n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -33,6 +32,7 @@\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.meta.ActiveLedgerManager.GarbageCollector;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.slf4j.Logger;\n@@ -56,7 +56,8 @@ public GcLedgersTest(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n     private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n         final AtomicInteger expected = new AtomicInteger(numLedgers);\n         for (int i=0; i<numLedgers; i++) {\n-            getLedgerManager().createLedger(new LedgerMetadata(1, 1), new GenericCallback<Long>() {\n+            getLedgerManager().createLedger(new LedgerMetadata(1, 1, DigestType.MAC, \"\".getBytes()),\n+                new GenericCallback<Long>() {\n                 @Override\n                 public void operationComplete(int rc, Long ledgerId) {\n                     if (rc == BKException.Code.OK) {"}]}

