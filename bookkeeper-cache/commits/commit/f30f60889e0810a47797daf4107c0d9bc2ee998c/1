{"sha":"f30f60889e0810a47797daf4107c0d9bc2ee998c","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmMzBmNjA4ODllMDgxMGE0Nzc5N2RhZjQxMDdjMGQ5YmMyZWU5OThj","commit":{"author":{"name":"Govind Menon","email":"govindappumenon@gmail.com","date":"2017-04-04T01:22:07Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-04-04T01:22:07Z"},"message":"BOOKKEEPER-1018: Revert \": Allow client to select older V2 protocol (no…\n\n… protobuf)\"\n\nThis reverts commit 9001e300ce0d5d2655d437e3eaa52f91487caed6.\n\nI broke trunk - not exactly sure how - I will fix it and put up the PR again. For now I'm reverting the commit.\n\nAuthor: Govind Menon <govindappumenon@gmail.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #124 from govind-menon/BOOKKEEPER-1018-Revert","tree":{"sha":"8179e3bd52a8c6f6cc21882a325842123d197e8a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8179e3bd52a8c6f6cc21882a325842123d197e8a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f30f60889e0810a47797daf4107c0d9bc2ee998c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f30f60889e0810a47797daf4107c0d9bc2ee998c","html_url":"https://github.com/apache/bookkeeper/commit/f30f60889e0810a47797daf4107c0d9bc2ee998c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f30f60889e0810a47797daf4107c0d9bc2ee998c/comments","author":{"login":"govind-menon","id":2053016,"node_id":"MDQ6VXNlcjIwNTMwMTY=","avatar_url":"https://avatars.githubusercontent.com/u/2053016?v=4","gravatar_id":"","url":"https://api.github.com/users/govind-menon","html_url":"https://github.com/govind-menon","followers_url":"https://api.github.com/users/govind-menon/followers","following_url":"https://api.github.com/users/govind-menon/following{/other_user}","gists_url":"https://api.github.com/users/govind-menon/gists{/gist_id}","starred_url":"https://api.github.com/users/govind-menon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/govind-menon/subscriptions","organizations_url":"https://api.github.com/users/govind-menon/orgs","repos_url":"https://api.github.com/users/govind-menon/repos","events_url":"https://api.github.com/users/govind-menon/events{/privacy}","received_events_url":"https://api.github.com/users/govind-menon/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"9001e300ce0d5d2655d437e3eaa52f91487caed6","url":"https://api.github.com/repos/apache/bookkeeper/commits/9001e300ce0d5d2655d437e3eaa52f91487caed6","html_url":"https://github.com/apache/bookkeeper/commit/9001e300ce0d5d2655d437e3eaa52f91487caed6"}],"stats":{"total":470,"additions":134,"deletions":336},"files":[{"sha":"ee137c004d269f440c639f08efcedae6258c28c4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":1,"deletions":22,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=f30f60889e0810a47797daf4107c0d9bc2ee998c","patch":"@@ -57,7 +57,7 @@\n     protected final static String CLIENT_WRITEBUFFER_HIGH_WATER_MARK = \"clientWriteBufferHighWaterMark\";\n     protected final static String CLIENT_CONNECT_TIMEOUT_MILLIS = \"clientConnectTimeoutMillis\";\n     protected final static String NUM_CHANNELS_PER_BOOKIE = \"numChannelsPerBookie\";\n-    protected final static String USE_V2_WIRE_PROTOCOL = \"useV2WireProtocol\";\n+\n     // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n@@ -435,27 +435,6 @@ public ClientConfiguration setNumChannelsPerBookie(int numChannelsPerBookie) {\n         return this;\n     }\n \n-    /**\n-     * Use older Bookkeeper wire protocol (no protobuf)\n-     *\n-     * @return whether or not to use older Bookkeeper wire protocol (no protobuf)\n-     */\n-    public boolean getUseV2WireProtocol() {\n-        return getBoolean(USE_V2_WIRE_PROTOCOL, false);\n-    }\n-\n-    /**\n-     * Set whether or not to use older Bookkeeper wire protocol (no protobuf)\n-     *\n-     * @param useV2WireProtocol\n-     *          whether or not to use older Bookkeeper wire protocol (no protobuf)\n-     * @return client configuration.\n-     */\n-    public ClientConfiguration setUseV2WireProtocol(boolean useV2WireProtocol) {\n-        setProperty(USE_V2_WIRE_PROTOCOL, useV2WireProtocol);\n-        return this;\n-    }\n-\n     /**\n      * Get zookeeper servers to connect\n      *"},{"sha":"75dced5152806bd46037db11a9a9f6f4000afd16","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"modified","additions":0,"deletions":8,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java?ref=f30f60889e0810a47797daf4107c0d9bc2ee998c","patch":"@@ -322,14 +322,6 @@ public void writeRequested(ChannelHandlerContext ctx,\n                     } else {\n                         waitingForAuth.add(e);\n                     }\n-                } else if (e.getMessage() instanceof BookieProtocol.Request) {\n-                    // let auth messages through, queue the rest\n-                    BookieProtocol.Request req = (BookieProtocol.Request)e.getMessage();\n-                    if (BookkeeperProtocol.OperationType.AUTH.getNumber() == req.getOpCode()) {\n-                        super.writeRequested(ctx, e);\n-                    } else {\n-                        waitingForAuth.add(e);\n-                    }\n                 } // else just drop\n             }\n         }"},{"sha":"2ce5ed891a21a17f0fae808ee73b13fda86a0cd5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":0,"deletions":3,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=f30f60889e0810a47797daf4107c0d9bc2ee998c","patch":"@@ -140,9 +140,6 @@ short getFlags() {\n      * by the auth providers themselves.\n      */\n     public static final byte AUTH = 3;\n-    public static final byte READ_LAC = 4;\n-    public static final byte WRITE_LAC = 5;\n-    public static final byte GET_BOOKIE_INFO = 6;\n \n     /**\n      * The error code that indicates success"},{"sha":"f6e9e8f7b053386ade3a4fd0c99492ed4231bb92","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":133,"deletions":303,"changes":436,"blob_url":"https://github.com/apache/bookkeeper/blob/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/f30f60889e0810a47797daf4107c0d9bc2ee998c/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=f30f60889e0810a47797daf4107c0d9bc2ee998c","patch":"@@ -21,10 +21,8 @@\n import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n import java.util.Collections;\n-import java.util.Collection;\n import java.util.Queue;\n import java.util.Set;\n-import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -100,7 +98,7 @@\n import com.google.protobuf.ByteString;\n import com.google.protobuf.ExtensionRegistry;\n import java.net.SocketAddress;\n-\n+import java.util.Collection;\n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n import org.jboss.netty.channel.ChannelFactory;\n import org.apache.bookkeeper.client.ClientConnectionPeer;\n@@ -149,8 +147,6 @@\n     private final OpStatsLogger getBookieInfoOpLogger;\n     private final OpStatsLogger getBookieInfoTimeoutOpLogger;\n \n-    private final boolean useV2WireProtocol;\n-\n     /**\n      * The following member variables do not need to be concurrent, or volatile\n      * because they are always updated under a lock\n@@ -206,7 +202,6 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.addEntryTimeout = conf.getAddEntryTimeout();\n         this.readEntryTimeout = conf.getReadEntryTimeout();\n         this.getBookieInfoTimeout = conf.getBookieInfoTimeout();\n-        this.useV2WireProtocol = conf.getUseV2WireProtocol();\n \n         this.authProviderFactory = authProviderFactory;\n         this.extRegistry = extRegistry;\n@@ -474,45 +469,33 @@ public void operationComplete(ChannelFuture future) throws Exception {\n      */\n     void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n-        Object request = null;\n-        CompletionKey completion = null;\n-        if (useV2WireProtocol) {\n-            completion = new V2CompletionKey(ledgerId, entryId, OperationType.ADD_ENTRY);\n-            request = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n-                    (short) options, masterKey, toSend);\n-\n+        final long txnId = getTxnId();\n+        final int entrySize = toSend.readableBytes();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n+        completionObjects.put(completionKey,\n+                new AddCompletion(this, addEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                  scheduleTimeout(completionKey, addEntryTimeout)));\n \n-        } else {\n-            final long txnId = getTxnId();\n-            completion = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n-            // Build the request and calculate the total size to be included in the packet.\n-            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                    .setVersion(ProtocolVersion.VERSION_THREE)\n-                    .setOperation(OperationType.ADD_ENTRY)\n-                    .setTxnId(txnId);\n-\n-            AddRequest.Builder addBuilder = AddRequest.newBuilder()\n-                    .setLedgerId(ledgerId)\n-                    .setEntryId(entryId)\n-                    .setMasterKey(ByteString.copyFrom(masterKey))\n-                    .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n-\n-            if (((short) options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n-                addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n-            }\n-            request = Request.newBuilder()\n-                    .setHeader(headerBuilder)\n-                    .setAddRequest(addBuilder)\n-                    .build();\n-        }\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.ADD_ENTRY)\n+                .setTxnId(txnId);\n \n-        final Object addRequest = request;\n-        final CompletionKey completionKey = completion;\n+        AddRequest.Builder addBuilder = AddRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId)\n+                .setMasterKey(ByteString.copyFrom(masterKey))\n+                .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n \n-        completionObjects.put(completionKey, new AddCompletion(this,\n-                addEntryOpLogger, cb, ctx, ledgerId, entryId, scheduleTimeout(completion, addEntryTimeout)));\n+        if (((short)options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n+            addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n+        }\n \n-        final int entrySize = toSend.readableBytes();\n+        final Request addRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setAddRequest(addBuilder)\n+                .build();\n \n         final Channel c = channel;\n         if (c == null) {\n@@ -548,52 +531,35 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n                                         final long entryId,\n                                         ReadEntryCallback cb, Object ctx) {\n-        Object request = null;\n-        CompletionKey completion = null;\n-        if (useV2WireProtocol) {\n-            completion = new V2CompletionKey(ledgerId, entryId, OperationType.READ_ENTRY);\n-            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n-                    BookieProtocol.FLAG_DO_FENCING, masterKey);\n-        } else {\n-            final long txnId = getTxnId();\n-            final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n-            completionObjects.put(completionKey,\n-                    new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n-                            scheduleTimeout(completionKey, readEntryTimeout)));\n-\n-            // Build the request and calculate the total size to be included in the packet.\n-            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                    .setVersion(ProtocolVersion.VERSION_THREE)\n-                    .setOperation(OperationType.READ_ENTRY)\n-                    .setTxnId(txnId);\n-\n-            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n-                    .setLedgerId(ledgerId)\n-                    .setEntryId(entryId)\n-                    .setMasterKey(ByteString.copyFrom(masterKey))\n-                    .setFlag(ReadRequest.Flag.FENCE_LEDGER);\n-\n-            final Request readRequest = Request.newBuilder()\n-                    .setHeader(headerBuilder)\n-                    .setReadRequest(readBuilder)\n-                    .build();\n-        }\n-\n-        final CompletionKey completionKey = completion;\n-        if (completionObjects.putIfAbsent(completionKey, new ReadCompletion(this, readEntryOpLogger, cb,\n-                ctx, ledgerId, entryId, scheduleTimeout(completionKey, readEntryTimeout))) != null) {\n-            // We cannot have more than 1 pending read on the same ledger/entry in the v2 protocol\n-            cb.readEntryComplete(BKException.Code.BookieHandleNotAvailableException, ledgerId, entryId, null, ctx);\n-            return;\n-        }\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+        completionObjects.put(completionKey,\n+                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                   scheduleTimeout(completionKey, readEntryTimeout)));\n+\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_ENTRY)\n+                .setTxnId(txnId);\n+\n+        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId)\n+                .setMasterKey(ByteString.copyFrom(masterKey))\n+                .setFlag(ReadRequest.Flag.FENCE_LEDGER);\n+\n+        final Request readRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadRequest(readBuilder)\n+                .build();\n \n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadKey(completionKey);\n             return;\n         }\n \n-        final Object readRequest = request;\n         try {\n             ChannelFuture future = c.write(readRequest);\n             future.addListener(new ChannelFutureListener() {\n@@ -620,34 +586,22 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {\n-        Object request = null;\n-        CompletionKey completion = null;\n-        if (useV2WireProtocol) {\n-            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                    ledgerId, (long) 0, (short) 0);\n-            completion = new V2CompletionKey(ledgerId, (long) 0, OperationType.READ_LAC);\n-        } else {\n-            final long txnId = getTxnId();\n-            final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_LAC);\n-\n-            // Build the request and calculate the total size to be included in the packet.\n-            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                    .setVersion(ProtocolVersion.VERSION_THREE)\n-                    .setOperation(OperationType.READ_LAC)\n-                    .setTxnId(txnId);\n-            ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()\n-                    .setLedgerId(ledgerId);\n-            request = Request.newBuilder()\n-                    .setHeader(headerBuilder)\n-                    .setReadLacRequest(readLacBuilder)\n-                    .build();\n-        }\n-        final Object readLacRequest = request;\n-        final CompletionKey completionKey = completion;\n-\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_LAC);\n         completionObjects.put(completionKey,\n                 new ReadLacCompletion(readLacOpLogger, cb, ctx, ledgerId,\n                         scheduleTimeout(completionKey, readEntryTimeout)));\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_LAC)\n+                .setTxnId(txnId);\n+        ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()\n+                .setLedgerId(ledgerId);\n+        final Request readLacRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadLacRequest(readLacBuilder)\n+                .build();\n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadLacKey(completionKey);\n@@ -678,37 +632,27 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     }\n \n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n-        Object request = null;\n-        CompletionKey completion = null;\n-        if (useV2WireProtocol) {\n-            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                    ledgerId, entryId, (short) 0);\n-            completion = new V2CompletionKey(ledgerId, entryId, OperationType.READ_ENTRY);\n-        } else {\n-            final long txnId = getTxnId();\n-            completion = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n+        completionObjects.put(completionKey,\n+                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                                   scheduleTimeout(completionKey, readEntryTimeout)));\n \n-            // Build the request and calculate the total size to be included in the packet.\n-            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n-                    .setVersion(ProtocolVersion.VERSION_THREE)\n-                    .setOperation(OperationType.READ_ENTRY)\n-                    .setTxnId(txnId);\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_ENTRY)\n+                .setTxnId(txnId);\n \n-            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n-                    .setLedgerId(ledgerId)\n-                    .setEntryId(entryId);\n+        ReadRequest.Builder readBuilder = ReadRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId);\n \n-            final Request readRequest = Request.newBuilder()\n-                    .setHeader(headerBuilder)\n-                    .setReadRequest(readBuilder)\n-                    .build();\n-        }\n-        final Object readRequest = request;\n-        final CompletionKey completionKey = completion;\n+        final Request readRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadRequest(readBuilder)\n+                .build();\n \n-        completionObjects.put(completionKey,\n-                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n-                        scheduleTimeout(completionKey, readEntryTimeout)));\n         final Channel c = channel;\n         if (c == null) {\n             errorOutReadKey(completionKey);\n@@ -859,7 +803,6 @@ void errorOutReadKey(final CompletionKey key) {\n     }\n \n     void errorOutReadKey(final CompletionKey key, final int rc) {\n-        LOG.info(\"Removing completion key: {}\", key);\n         final ReadCompletion readCompletion = (ReadCompletion)completionObjects.remove(key);\n         if (null == readCompletion) {\n             return;\n@@ -892,7 +835,6 @@ void errorOutWriteLacKey(final CompletionKey key) {\n     }\n \n     void errorOutWriteLacKey(final CompletionKey key, final int rc) {\n-        LOG.info(\"Removing completion key: {}\", key);\n         final WriteLacCompletion writeLacCompletion = (WriteLacCompletion)completionObjects.remove(key);\n         if (null == writeLacCompletion) {\n             return;\n@@ -917,7 +859,6 @@ void errorOutReadLacKey(final CompletionKey key) {\n     }\n \n     void errorOutReadLacKey(final CompletionKey key, final int rc) {\n-        LOG.info(\"Removing completion key: {}\", key);\n         final ReadLacCompletion readLacCompletion = (ReadLacCompletion)completionObjects.remove(key);\n         if (null == readLacCompletion) {\n             return;\n@@ -1117,101 +1058,12 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n      */\n     @Override\n     public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-\n-        if (e.getMessage() instanceof BookieProtocol.Response) {\n-            BookieProtocol.Response response = (BookieProtocol.Response) e.getMessage();\n-            readV2Response(response);\n-        } else if (e.getMessage() instanceof Response) {\n-            Response response = (Response) e.getMessage();\n-            readV3Response(response);\n-        } else {\n+        if (!(e.getMessage() instanceof Response)) {\n             ctx.sendUpstream(e);\n+            return;\n         }\n-    }\n-\n-    private void readV2Response(final BookieProtocol.Response response) {\n-        final long ledgerId = response.ledgerId;\n-        final long entryId = response.entryId;\n-\n-        final OperationType operationType = getOperationType(response.getOpCode());\n-        final StatusCode status = getStatusCodeFromErrorCode(response.errorCode);\n-\n-        final CompletionValue completionValue = completionObjects.remove(new V2CompletionKey(ledgerId, entryId, operationType));\n-\n-        if (null == completionValue) {\n-            // Unexpected response, so log it. The txnId should have been present.\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \" + operationType\n-                        + \" and ledger:entry : \" + ledgerId + \":\" + entryId);\n-            }\n-        } else {\n-            long orderingKey = completionValue.ledgerId;\n-\n-            executor.submitOrdered(orderingKey, new SafeRunnable() {\n-                @Override\n-                public void safeRun() {\n-                    switch (operationType) {\n-                        case ADD_ENTRY: {\n-                            handleAddResponse(ledgerId, entryId, status, completionValue);\n-                        }\n-                        case READ_ENTRY: {\n-                            BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;\n-                            handleReadResponse(ledgerId, entryId, status, readResponse.getData(), completionValue);\n-                        }\n-                        default:\n-                            LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\", operationType, addr);\n-                            break;\n-                    }\n-                }\n-            });\n-        }\n-    }\n \n-    private StatusCode getStatusCodeFromErrorCode(int errorCode) {\n-        switch (errorCode) {\n-            case BookieProtocol.EOK:\n-                return StatusCode.EOK;\n-            case BookieProtocol.ENOLEDGER:\n-                return StatusCode.ENOLEDGER;\n-            case BookieProtocol.ENOENTRY:\n-                return StatusCode.ENOENTRY;\n-            case BookieProtocol.EBADREQ:\n-                return StatusCode.EBADREQ;\n-            case BookieProtocol.EIO:\n-                return StatusCode.EIO;\n-            case BookieProtocol.EUA:\n-                return StatusCode.EUA;\n-            case BookieProtocol.EBADVERSION:\n-                return StatusCode.EBADVERSION;\n-            case BookieProtocol.EFENCED:\n-                return StatusCode.EFENCED;\n-            case BookieProtocol.EREADONLY:\n-                return StatusCode.EREADONLY;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid error code: \" + errorCode);\n-        }\n-    }\n-\n-    private OperationType getOperationType(byte opCode) {\n-        switch (opCode) {\n-            case BookieProtocol.ADDENTRY:\n-                return  OperationType.ADD_ENTRY;\n-            case BookieProtocol.READENTRY:\n-                return OperationType.READ_ENTRY;\n-            case BookieProtocol.AUTH:\n-                return OperationType.AUTH;\n-            case BookieProtocol.READ_LAC:\n-                return OperationType.READ_LAC;\n-            case BookieProtocol.WRITE_LAC:\n-                return OperationType.WRITE_LAC;\n-            case BookieProtocol.GET_BOOKIE_INFO:\n-                return OperationType.GET_BOOKIE_INFO;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid operation type\");\n-        }\n-    }\n-\n-    private void readV3Response(final Response response) {\n+        final Response response = (Response) e.getMessage();\n         final BKPacketHeader header = response.getHeader();\n \n         final CompletionValue completionValue = completionObjects.remove(newCompletionKey(header.getTxnId(),\n@@ -1230,51 +1082,21 @@ private void readV3Response(final Response response) {\n                 public void safeRun() {\n                     OperationType type = header.getOperation();\n                     switch (type) {\n-                        case ADD_ENTRY: {\n-                            AddResponse addResponse = response.getAddResponse();\n-                            StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();\n-                            handleAddResponse(addResponse.getLedgerId(), addResponse.getEntryId(), status, completionValue);\n+                        case ADD_ENTRY:\n+                            handleAddResponse(response, completionValue);\n                             break;\n-                        }\n-                        case READ_ENTRY: {\n-                            ReadResponse readResponse = response.getReadResponse();\n-                            StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n-                            ChannelBuffer buffer = ChannelBuffers.buffer(0);\n-                            if (readResponse.hasBody()) {\n-                                buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n-                            }\n-                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, completionValue);\n+                        case READ_ENTRY:\n+                            handleReadResponse(response, completionValue);\n                             break;\n-                        }\n-                        case WRITE_LAC: {\n-                            WriteLacResponse writeLacResponse = response.getWriteLacResponse();\n-                            StatusCode status = response.getStatus() == StatusCode.EOK ? writeLacResponse.getStatus() : response.getStatus();\n-                            handleWriteLacResponse(writeLacResponse.getLedgerId(), status, completionValue);\n+                        case WRITE_LAC:\n+                            handleWriteLacResponse(response.getWriteLacResponse(), completionValue);\n                             break;\n-                        }\n-                        case READ_LAC: {\n-                            ReadLacResponse readLacResponse = response.getReadLacResponse();\n-                            ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n-                            ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n-                            StatusCode status = response.getStatus() == StatusCode.EOK ? readLacResponse.getStatus() : response.getStatus();\n-                            // Thread.dumpStack();\n-\n-                            if (readLacResponse.hasLacBody()) {\n-                                lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n-                            }\n-\n-                            if (readLacResponse.hasLastEntryBody()) {\n-                                lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n-                            }\n-                            handleReadLacResponse(readLacResponse.getLedgerId(), status, lacBuffer, lastEntryBuffer, completionValue);\n+                        case READ_LAC:\n+                            handleReadLacResponse(response.getReadLacResponse(), completionValue);\n                             break;\n-                        }\n-                        case GET_BOOKIE_INFO: {\n-                            GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();\n-                            StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();\n-                            handleGetBookieInfoResponse(getBookieInfoResponse.getFreeDiskSpace(), getBookieInfoResponse.getTotalDiskCapacity(), status, completionValue);\n+                        case GET_BOOKIE_INFO:\n+                            handleGetBookieInfoResponse(response, completionValue);\n                             break;\n-                        }\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n                                       type, addr);\n@@ -1292,10 +1114,13 @@ public String toString() {\n         }\n     }\n \n-    void handleWriteLacResponse(long ledgerId, StatusCode status, CompletionValue completionValue) {\n+    void handleWriteLacResponse(WriteLacResponse writeLacResponse, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         WriteLacCompletion plc = (WriteLacCompletion)completionValue;\n \n+        long ledgerId = writeLacResponse.getLedgerId();\n+        StatusCode status = writeLacResponse.getStatus();\n+\n         LOG.debug(\"Got response for writeLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n \n         // convert to BKException code\n@@ -1308,9 +1133,14 @@ void handleWriteLacResponse(long ledgerId, StatusCode status, CompletionValue co\n         plc.cb.writeLacComplete(rcToRet, ledgerId, addr, plc.ctx);\n     }\n \n- void handleAddResponse(long ledgerId, long entryId, StatusCode status, CompletionValue completionValue) {\n+ void handleAddResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of an AddCompletion object when we reach here.\n         AddCompletion ac = (AddCompletion)completionValue;\n+        AddResponse addResponse = response.getAddResponse();\n+\n+        long ledgerId = addResponse.getLedgerId();\n+        long entryId = addResponse.getEntryId();\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? addResponse.getStatus() : response.getStatus();\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n@@ -1330,10 +1160,25 @@ void handleAddResponse(long ledgerId, long entryId, StatusCode status, Completio\n         ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n-    void handleReadLacResponse(long ledgerId, StatusCode status, ChannelBuffer lacBuffer, ChannelBuffer lastEntryBuffer, CompletionValue completionValue) {\n+    void handleReadLacResponse(ReadLacResponse readLacResponse, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         ReadLacCompletion glac = (ReadLacCompletion)completionValue;\n \n+        long ledgerId = readLacResponse.getLedgerId();\n+        StatusCode status = readLacResponse.getStatus();\n+        ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n+        ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n+\n+       // Thread.dumpStack();\n+\n+        if (readLacResponse.hasLacBody()) {\n+            lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n+        }\n+\n+        if (readLacResponse.hasLastEntryBody()) {\n+            lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n+        }\n+\n         LOG.debug(\"Got response for readLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n         // convert to BKException code\n         Integer rcToRet = statusCodeToExceptionCode(status);\n@@ -1345,10 +1190,20 @@ void handleReadLacResponse(long ledgerId, StatusCode status, ChannelBuffer lacBu\n         glac.cb.readLacComplete(rcToRet, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), glac.ctx);\n     }\n \n-    void handleReadResponse(long ledgerId, long entryId, StatusCode status, ChannelBuffer buffer, CompletionValue completionValue) {\n+    void handleReadResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n+        ReadResponse readResponse = response.getReadResponse();\n+\n+        long ledgerId = readResponse.getLedgerId();\n+        long entryId = readResponse.getEntryId();\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n \n+        ChannelBuffer buffer = ChannelBuffers.buffer(0);\n+\n+        if (readResponse.hasBody()) {\n+            buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n+        }\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n@@ -1367,9 +1222,15 @@ void handleReadResponse(long ledgerId, long entryId, StatusCode status, ChannelB\n         rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer.slice(), rc.ctx);\n     }\n \n-    void handleGetBookieInfoResponse(long freeDiskSpace, long totalDiskCapacity,  StatusCode status, CompletionValue completionValue) {\n+    void handleGetBookieInfoResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of a GetBookieInfoCompletion object when we reach here.\n         GetBookieInfoCompletion rc = (GetBookieInfoCompletion)completionValue;\n+        GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();\n+\n+        long freeDiskSpace = getBookieInfoResponse.hasFreeDiskSpace() ? getBookieInfoResponse.getFreeDiskSpace() : 0L;\n+        long totalDiskCapacity = getBookieInfoResponse.hasTotalDiskCapacity() ? getBookieInfoResponse.getTotalDiskCapacity() : 0L;\n+\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();\n \n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read metadata request from bookie: {} rc {}\", addr, rc);\n@@ -1695,35 +1556,4 @@ private long getTxnId() {\n         return txnIdGenerator.incrementAndGet();\n     }\n \n-    private class V2CompletionKey extends CompletionKey {\n-        final long ledgerId;\n-        final long entryId;\n-\n-\n-        public V2CompletionKey(long ledgerId, long entryId, OperationType operationType) {\n-            super(0, operationType);\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n-\n-        }\n-\n-        @Override\n-        public boolean equals(Object object) {\n-            if (!(object instanceof V2CompletionKey)) {\n-                return  false;\n-            }\n-            V2CompletionKey that = (V2CompletionKey) object;\n-            return  this.entryId == that.entryId && this.ledgerId == that.ledgerId;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(ledgerId, entryId);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"%d:%d %s\", ledgerId, entryId, operationType);\n-        }\n-    }\n }"}]}

