{"sha":"f3731732ce984f41b8530939254706f9e597583d","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmMzczMTczMmNlOTg0ZjQxYjg1MzA5MzkyNTQ3MDZmOWU1OTc1ODNk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-07-20T18:06:30Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2013-07-20T18:06:30Z"},"message":"BOOKKEEPER-610: Make SyncThread use an executor (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1505175 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5380345e4065d4650eb4856a47f355f82a9554b1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/5380345e4065d4650eb4856a47f355f82a9554b1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f3731732ce984f41b8530939254706f9e597583d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f3731732ce984f41b8530939254706f9e597583d","html_url":"https://github.com/apache/bookkeeper/commit/f3731732ce984f41b8530939254706f9e597583d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f3731732ce984f41b8530939254706f9e597583d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4d66c36cf8825ab3f9f4a389bddfb924a0df9107","url":"https://api.github.com/repos/apache/bookkeeper/commits/4d66c36cf8825ab3f9f4a389bddfb924a0df9107","html_url":"https://github.com/apache/bookkeeper/commit/4d66c36cf8825ab3f9f4a389bddfb924a0df9107"}],"stats":{"total":499,"additions":420,"deletions":79},"files":[{"sha":"52433a3ec24bd42a07e1c5287eb35b1ed147b1ec","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/f3731732ce984f41b8530939254706f9e597583d/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/f3731732ce984f41b8530939254706f9e597583d/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=f3731732ce984f41b8530939254706f9e597583d","patch":"@@ -118,6 +118,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n \n+      BOOKKEEPER-610: Make SyncThread use an executor (ivank via sijie)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"59f5921d1a46043c71d696d710b4722f956a658b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","status":"modified","additions":78,"deletions":79,"changes":157,"blob_url":"https://github.com/apache/bookkeeper/blob/f3731732ce984f41b8530939254706f9e597583d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/f3731732ce984f41b8530939254706f9e597583d/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java?ref=f3731732ce984f41b8530939254706f9e597583d","patch":"@@ -21,8 +21,12 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.util.concurrent.atomic.AtomicBoolean;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.Executors;\n \n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n \n@@ -53,12 +57,10 @@\n  * for manual recovery in critical disaster.\n  * </p>\n  */\n-class SyncThread extends Thread {\n+class SyncThread {\n     static Logger LOG = LoggerFactory.getLogger(SyncThread.class);\n \n-    volatile boolean running = true;\n-    // flag to ensure sync thread will not be interrupted during flush\n-    final AtomicBoolean flushing = new AtomicBoolean(false);\n+    final ScheduledExecutorService executor;\n     final int flushInterval;\n     final LedgerStorage ledgerStorage;\n     final LedgerDirsListener dirsListener;\n@@ -68,48 +70,78 @@ public SyncThread(ServerConfiguration conf,\n                       LedgerDirsListener dirsListener,\n                       LedgerStorage ledgerStorage,\n                       CheckpointSource checkpointSource) {\n-        super(\"SyncThread\");\n         this.dirsListener = dirsListener;\n         this.ledgerStorage = ledgerStorage;\n         this.checkpointSource = checkpointSource;\n-\n+        ThreadFactoryBuilder tfb = new ThreadFactoryBuilder()\n+            .setNameFormat(\"SyncThread-\" + conf.getBookiePort() + \"-%d\");\n+        this.executor = Executors.newSingleThreadScheduledExecutor(tfb.build());\n         flushInterval = conf.getFlushInterval();\n         LOG.debug(\"Flush Interval : {}\", flushInterval);\n     }\n \n-    /**\n-     * flush data up to given logMark and roll log if success\n-     * @param checkpoint\n-     */\n+    void start() {\n+        executor.scheduleAtFixedRate(new Runnable() {\n+                public void run() {\n+                    try {\n+                        synchronized (suspensionLock) {\n+                            while (suspended) {\n+                                try {\n+                                    suspensionLock.wait();\n+                                } catch (InterruptedException e) {\n+                                    Thread.currentThread().interrupt();\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                        checkpoint(checkpointSource.newCheckpoint());\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Exception in SyncThread\", t);\n+                        dirsListener.fatalError();\n+                    }\n+                }\n+            }, flushInterval, flushInterval, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void flush() {\n+        Checkpoint checkpoint = checkpointSource.newCheckpoint();\n+        try {\n+            ledgerStorage.flush();\n+        } catch (NoWritableLedgerDirException e) {\n+            LOG.error(\"No writeable ledger directories\", e);\n+            dirsListener.allDisksFull();\n+            return;\n+        } catch (IOException e) {\n+            LOG.error(\"Exception flushing ledgers\", e);\n+            return;\n+        }\n+\n+        try {\n+            checkpointSource.checkpointComplete(checkpoint, false);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception marking checkpoint as complete\", e);\n+            dirsListener.allDisksFull();\n+        }\n+    }\n+\n     @VisibleForTesting\n     public void checkpoint(Checkpoint checkpoint) {\n-        boolean flushFailed = false;\n         try {\n-            if (running) {\n-                checkpoint = ledgerStorage.checkpoint(checkpoint);\n-            } else {\n-                ledgerStorage.flush();\n-            }\n+            checkpoint = ledgerStorage.checkpoint(checkpoint);\n         } catch (NoWritableLedgerDirException e) {\n-            LOG.error(\"No writeable ledger directories\");\n-            flushFailed = true;\n-            flushing.set(false);\n+            LOG.error(\"No writeable ledger directories\", e);\n             dirsListener.allDisksFull();\n+            return;\n         } catch (IOException e) {\n-            LOG.error(\"Exception flushing Ledger\", e);\n-            flushFailed = true;\n+            LOG.error(\"Exception flushing ledgers\", e);\n+            return;\n         }\n \n-        // if flush failed, we should not roll last mark, otherwise we would\n-        // have some ledgers are not flushed and their journal entries were lost\n-        if (!flushFailed) {\n-            try {\n-                checkpointSource.checkpointComplete(checkpoint, running);\n-            } catch (IOException e) {\n-                flushing.set(false);\n-                LOG.error(\"Marking checkpoint as complete failed\", e);\n-                dirsListener.allDisksFull();\n-            }\n+        try {\n+            checkpointSource.checkpointComplete(checkpoint, true);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception marking checkpoint as complete\", e);\n+            dirsListener.allDisksFull();\n         }\n     }\n \n@@ -137,56 +169,23 @@ public void resumeSync() {\n         }\n     }\n \n-    @Override\n-    public void run() {\n-        try {\n-            while(running) {\n-                synchronized (this) {\n+    // shutdown sync thread\n+    void shutdown() throws InterruptedException {\n+        executor.submit(new Runnable() {\n+                public void run() {\n                     try {\n-                        wait(flushInterval);\n-                    } catch (InterruptedException e) {\n-                        Thread.currentThread().interrupt();\n-                        continue;\n+                        flush();\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Exception flushing ledgers at shutdown\", t);\n                     }\n                 }\n-\n-                synchronized (suspensionLock) {\n-                    while (suspended) {\n-                        try {\n-                            suspensionLock.wait();\n-                        } catch (InterruptedException e) {\n-                            Thread.currentThread().interrupt();\n-                            continue;\n-                        }\n-                    }\n-                }\n-\n-                // try to mark flushing flag to check if interrupted\n-                if (!flushing.compareAndSet(false, true)) {\n-                    // set flushing flag failed, means flushing is true now\n-                    // indicates another thread wants to interrupt sync thread to exit\n-                    break;\n-                }\n-                checkpoint(checkpointSource.newCheckpoint());\n-\n-                flushing.set(false);\n-            }\n-        } catch (Throwable t) {\n-            LOG.error(\"Exception in SyncThread\", t);\n-            flushing.set(false);\n-            dirsListener.fatalError();\n-        }\n-    }\n-\n-    // shutdown sync thread\n-    void shutdown() throws InterruptedException {\n-        // Wake up and finish sync thread\n-        running = false;\n-        // make a checkpoint when shutdown\n-        if (flushing.compareAndSet(false, true)) {\n-            // it is safe to interrupt itself now\n-            this.interrupt();\n+            });\n+        executor.shutdown();\n+        long start = MathUtils.now();\n+        while (!executor.awaitTermination(5, TimeUnit.MINUTES)) {\n+            long now = MathUtils.now();\n+            LOG.info(\"SyncThread taking a long time to shutdown. Has taken {}\"\n+                    + \" seconds so far\", now - start);\n         }\n-        this.join();\n     }\n }"},{"sha":"e8ff4705fc06c5834646139610edcd2cd649bf08","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","status":"added","additions":340,"deletions":0,"changes":340,"blob_url":"https://github.com/apache/bookkeeper/blob/f3731732ce984f41b8530939254706f9e597583d/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/f3731732ce984f41b8530939254706f9e597583d/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java?ref=f3731732ce984f41b8530939254706f9e597583d","patch":"@@ -0,0 +1,340 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Test;\n+import org.junit.Before;\n+import org.junit.After;\n+\n+import static org.junit.Assert.*;\n+\n+public class TestSyncThread {\n+    static Logger LOG = LoggerFactory.getLogger(TestSyncThread.class);\n+\n+    ExecutorService executor = null;\n+\n+    @Before\n+    public void setupExecutor() {\n+        executor = Executors.newSingleThreadExecutor();\n+    }\n+\n+    @After\n+    public void teardownExecutor() {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+            executor = null;\n+        }\n+    }\n+\n+    /**\n+     * Test that if a flush is taking a long time,\n+     * the sync thread will not shutdown until it\n+     * has finished.\n+     */\n+    @Test(timeout=60000)\n+    public void testSyncThreadLongShutdown() throws Exception {\n+        int flushInterval = 100;\n+        ServerConfiguration conf = new ServerConfiguration().setFlushInterval(flushInterval);\n+        CheckpointSource checkpointSource = new DummyCheckpointSource();\n+        LedgerDirsListener listener = new DummyLedgerDirsListener();\n+\n+        final CountDownLatch checkpointCalledLatch = new CountDownLatch(1);\n+        final CountDownLatch checkpointLatch = new CountDownLatch(1);\n+\n+        final CountDownLatch flushCalledLatch = new CountDownLatch(1);\n+        final CountDownLatch flushLatch = new CountDownLatch(1);\n+        final AtomicBoolean failedSomewhere = new AtomicBoolean(false);\n+        LedgerStorage storage = new DummyLedgerStorage() {\n+                @Override\n+                public void flush() throws IOException {\n+                    flushCalledLatch.countDown();\n+                    try {\n+                        flushLatch.await();\n+                    } catch (InterruptedException ie) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.error(\"Interrupted in flush thread\", ie);\n+                        failedSomewhere.set(true);\n+                    }\n+                }\n+\n+                @Override\n+                public Checkpoint checkpoint(Checkpoint checkpoint)\n+                        throws IOException {\n+                    checkpointCalledLatch.countDown();\n+                    try {\n+                        checkpointLatch.await();\n+                    } catch (InterruptedException ie) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.error(\"Interrupted in checkpoint thread\", ie);\n+                        failedSomewhere.set(true);\n+                    }\n+                    return checkpoint;\n+                }\n+            };\n+\n+        final SyncThread t = new SyncThread(conf, listener, storage, checkpointSource);\n+        t.start();\n+        assertTrue(\"Checkpoint should have been called\",\n+                   checkpointCalledLatch.await(10, TimeUnit.SECONDS));\n+        Future<Boolean> done = executor.submit(new Callable<Boolean>() {\n+                public Boolean call() {\n+                    try {\n+                        t.shutdown();\n+                    } catch (InterruptedException ie) {\n+                        Thread.currentThread().interrupt();\n+                        LOG.error(\"Interrupted shutting down sync thread\", ie);\n+                        failedSomewhere.set(true);\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+            });\n+        checkpointLatch.countDown();\n+        assertFalse(\"Shutdown shouldn't have finished\", done.isDone());\n+        assertTrue(\"Flush should have been called\",\n+                   flushCalledLatch.await(10, TimeUnit.SECONDS));\n+\n+        assertFalse(\"Shutdown shouldn't have finished\", done.isDone());\n+        flushLatch.countDown();\n+\n+        assertTrue(\"Shutdown should have finished successfully\", done.get(10, TimeUnit.SECONDS));\n+        assertFalse(\"Shouldn't have failed anywhere\", failedSomewhere.get());\n+    }\n+\n+    /**\n+     * Test that sync thread suspension works.\n+     * i.e. when we suspend the syncthread, nothing\n+     * will be synced.\n+     */\n+    @Test(timeout=60000)\n+    public void testSyncThreadSuspension() throws Exception {\n+        int flushInterval = 100;\n+        ServerConfiguration conf = new ServerConfiguration().setFlushInterval(flushInterval);\n+        CheckpointSource checkpointSource = new DummyCheckpointSource();\n+        LedgerDirsListener listener = new DummyLedgerDirsListener();\n+\n+        final AtomicInteger checkpointCount = new AtomicInteger(0);\n+        LedgerStorage storage = new DummyLedgerStorage() {\n+                @Override\n+                public Checkpoint checkpoint(Checkpoint checkpoint)\n+                        throws IOException {\n+                    checkpointCount.incrementAndGet();\n+                    return checkpoint;\n+                }\n+            };\n+        final SyncThread t = new SyncThread(conf, listener, storage, checkpointSource);\n+        t.start();\n+        while (checkpointCount.get() == 0) {\n+            Thread.sleep(flushInterval);\n+        }\n+        t.suspendSync();\n+        Thread.sleep(flushInterval);\n+        int count = checkpointCount.get();\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Checkpoint count shouldn't change\", count, checkpointCount.get());\n+        }\n+        t.resumeSync();\n+        int i = 0;\n+        while (checkpointCount.get() == count) {\n+            Thread.sleep(flushInterval);\n+            i++;\n+            if (i > 100) {\n+                fail(\"Checkpointing never resumed\");\n+            }\n+        }\n+        t.shutdown();\n+    }\n+\n+    /**\n+     * Test that if the ledger storage throws a\n+     * runtime exception, the bookie will be told\n+     * to shutdown.\n+     */\n+    @Test(timeout=60000)\n+    public void testSyncThreadShutdownOnError() throws Exception {\n+        int flushInterval = 100;\n+        ServerConfiguration conf = new ServerConfiguration().setFlushInterval(flushInterval);\n+        CheckpointSource checkpointSource = new DummyCheckpointSource();\n+        final CountDownLatch fatalLatch = new CountDownLatch(1);\n+        LedgerDirsListener listener = new DummyLedgerDirsListener() {\n+                @Override\n+                public void fatalError() {\n+                    fatalLatch.countDown();\n+                }\n+            };\n+\n+        LedgerStorage storage = new DummyLedgerStorage() {\n+                @Override\n+                public Checkpoint checkpoint(Checkpoint checkpoint)\n+                        throws IOException {\n+                    throw new RuntimeException(\"Fatal error in sync thread\");\n+                }\n+            };\n+        final SyncThread t = new SyncThread(conf, listener, storage, checkpointSource);\n+        t.start();\n+        assertTrue(\"Should have called fatal error\", fatalLatch.await(10, TimeUnit.SECONDS));\n+        t.shutdown();\n+    }\n+\n+    /**\n+     * Test that if the ledger storage throws\n+     * a disk full exception, the owner of the sync\n+     * thread will be notified.\n+     */\n+    @Test(timeout=60000)\n+    public void testSyncThreadDisksFull() throws Exception {\n+        int flushInterval = 100;\n+        ServerConfiguration conf = new ServerConfiguration().setFlushInterval(flushInterval);\n+        CheckpointSource checkpointSource = new DummyCheckpointSource();\n+        final CountDownLatch diskFullLatch = new CountDownLatch(1);\n+        LedgerDirsListener listener = new DummyLedgerDirsListener() {\n+                @Override\n+                public void allDisksFull() {\n+                    diskFullLatch.countDown();\n+                }\n+            };\n+\n+        LedgerStorage storage = new DummyLedgerStorage() {\n+                @Override\n+                public Checkpoint checkpoint(Checkpoint checkpoint)\n+                        throws IOException {\n+                    throw new NoWritableLedgerDirException(\"Disk full error in sync thread\");\n+                }\n+            };\n+        final SyncThread t = new SyncThread(conf, listener, storage, checkpointSource);\n+        t.start();\n+        assertTrue(\"Should have disk full error\", diskFullLatch.await(10, TimeUnit.SECONDS));\n+        t.shutdown();\n+    }\n+\n+    private static class DummyCheckpointSource implements CheckpointSource {\n+        @Override\n+        public Checkpoint newCheckpoint() {\n+            return Checkpoint.MAX;\n+        }\n+\n+        @Override\n+        public void checkpointComplete(Checkpoint checkpoint, boolean compact)\n+                throws IOException {\n+        }\n+    }\n+    private static class DummyLedgerStorage implements LedgerStorage {\n+        @Override\n+        public void start() {\n+        }\n+\n+        @Override\n+        public void shutdown() throws InterruptedException {\n+        }\n+\n+        @Override\n+        public boolean ledgerExists(long ledgerId) throws IOException {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean setFenced(long ledgerId) throws IOException {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isFenced(long ledgerId) throws IOException {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setMasterKey(long ledgerId, byte[] masterKey)\n+                throws IOException {\n+        }\n+\n+        @Override\n+        public byte[] readMasterKey(long ledgerId)\n+                throws IOException, BookieException {\n+            return new byte[0];\n+        }\n+\n+        @Override\n+        public long addEntry(ByteBuffer entry) throws IOException {\n+            return 1L;\n+        }\n+\n+        @Override\n+        public ByteBuffer getEntry(long ledgerId, long entryId)\n+                throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+        }\n+\n+        @Override\n+        public Checkpoint checkpoint(Checkpoint checkpoint)\n+                throws IOException {\n+            return checkpoint;\n+        }\n+\n+        @Override\n+        public BKMBeanInfo getJMXBean() { return null; }\n+    }\n+\n+    private static class DummyLedgerDirsListener\n+        implements LedgerDirsManager.LedgerDirsListener {\n+        @Override\n+        public void diskFailed(File disk) {\n+        }\n+\n+        @Override\n+        public void diskFull(File disk) {\n+        }\n+\n+        @Override\n+        public void allDisksFull() {\n+        }\n+\n+        @Override\n+        public void fatalError() {\n+        }\n+    }\n+}"}]}

