{"sha":"f633075dd0b0cae6c50db0f7284798089a9cf83b","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmNjMzMDc1ZGQwYjBjYWU2YzUwZGIwZjcyODQ3OTgwODlhOWNmODNi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-02T16:14:59Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-11-02T16:14:59Z"},"message":"BOOKKEEPER-368 Implementing multiplexing java client. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1405028 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3d5154ddbd6de68250913dba7c44e6ce7a3be449","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3d5154ddbd6de68250913dba7c44e6ce7a3be449"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f633075dd0b0cae6c50db0f7284798089a9cf83b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f633075dd0b0cae6c50db0f7284798089a9cf83b","html_url":"https://github.com/apache/bookkeeper/commit/f633075dd0b0cae6c50db0f7284798089a9cf83b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f633075dd0b0cae6c50db0f7284798089a9cf83b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"0658723fdbcfeceddc983b770d78b01602a64f06","url":"https://api.github.com/repos/apache/bookkeeper/commits/0658723fdbcfeceddc983b770d78b01602a64f06","html_url":"https://github.com/apache/bookkeeper/commit/0658723fdbcfeceddc983b770d78b01602a64f06"}],"stats":{"total":2892,"additions":2541,"deletions":351},"files":[{"sha":"8021c8221cc44d0f9325ccdb91b127096cabc4c5","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -224,6 +224,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-369: re-factor hedwig cpp client to provide better interface to support both one-subscription-per-channel and multiple-subscriptions-per-channel. (sijie via ivank)\n \n+        BOOKKEEPER-368: Implementing multiplexing java client. (sijie via ivank)\n+\n Release 4.1.0 - 2012-06-07\n \n   Non-backward compatible changes:"},{"sha":"977d173429c686074d2fd3df9258d59d0589645b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -42,6 +42,7 @@\n     protected static final String TIMEOUT_THREAD_RUN_INTERVAL = \"timeout_thread_run_interval\";\n     protected static final String SSL_ENABLED = \"ssl_enabled\";\n     protected static final String SUBSCRIPTION_MESSAGE_BOUND = \"subscription_message_bound\";\n+    protected static final String MULTIPLEXING_ENABLED = \"multiplexing_enabled\";\n \n     // Singletons we want to instantiate only once per ClientConfiguration\n     protected HedwigSocketAddress myDefaultServerAddress = null;\n@@ -139,6 +140,14 @@ public boolean isSSLEnabled() {\n         return conf.getBoolean(SSL_ENABLED, false);\n     }\n \n+    /**\n+     * This parameter is a boolean flag indicating if multiplexing subscription\n+     * channels.\n+     */\n+    public boolean isMultiplexingEnabled() {\n+        return conf.getBoolean(MULTIPLEXING_ENABLED, false);\n+    }\n+\n     /**\n      * The maximum number of messages the hub will queue for subscriptions\n      * created using this configuration. The hub will always queue the most"},{"sha":"e2c685f91d687e8b709653af50b6fe3dcefa0231","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -23,6 +23,8 @@\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.channel.Channel;\n \n+import com.google.protobuf.ByteString;\n+\n import org.apache.hedwig.client.api.MessageHandler;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.data.TopicSubscriber;\n@@ -34,6 +36,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n \n@@ -60,6 +63,20 @@ protected SubscribeResponseHandler(ClientConfiguration cfg,\n      */\n     public abstract void handleSubscribeMessage(PubSubResponse response);\n \n+    /**\n+     * Handle a subscription event delivered by the server.\n+     *\n+     * @param topic\n+     *          Topic Name\n+     * @param subscriberId\n+     *          Subscriber Id\n+     * @param event\n+     *          Subscription Event describes its status\n+     */\n+    public abstract void handleSubscriptionEvent(ByteString topic,\n+                                                 ByteString subscriberId,\n+                                                 SubscriptionEvent event);\n+\n     /**\n      * Method called when a message arrives for a subscribe Channel and we want\n      * to deliver it asynchronously via the registered MessageHandler (should"},{"sha":"a50b4275798f9fa1d5c39dff9e84ee385e59ca17","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -29,6 +29,7 @@\n import org.apache.hedwig.client.api.Client;\n import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.client.netty.impl.simple.SimpleHChannelManager;\n+import org.apache.hedwig.client.netty.impl.multiplex.MultiplexHChannelManager;\n \n /**\n  * This is a top level Hedwig Client class that encapsulates the common\n@@ -73,8 +74,11 @@ protected HedwigClientImpl(ClientConfiguration cfg) {\n     protected HedwigClientImpl(ClientConfiguration cfg, ChannelFactory socketFactory) {\n         this.cfg = cfg;\n         this.socketFactory = socketFactory;\n-        channelManager = new SimpleHChannelManager(cfg, socketFactory);\n-\n+        if (cfg.isMultiplexingEnabled()) {\n+            channelManager = new MultiplexHChannelManager(cfg, socketFactory);\n+        } else {\n+            channelManager = new SimpleHChannelManager(cfg, socketFactory);\n+        }\n         pub = new HedwigPublisher(this);\n         sub = new HedwigSubscriber(this);\n     }"},{"sha":"fedbbf255d6038e64e925b6eb49857dc74ada38c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","status":"modified","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/HChannelHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -43,7 +43,9 @@\n import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse;\n import static org.apache.hedwig.util.VarArgs.va;\n \n @ChannelPipelineCoverage(\"all\")\n@@ -119,6 +121,27 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex\n             return;\n         }\n \n+        // Process Subscription Events\n+        if (response.hasResponseBody()) {\n+            ResponseBody resp = response.getResponseBody();\n+            // A special subscription event indicates the state of a subscriber\n+            if (resp.hasSubscriptionEvent()) {\n+                if (null == subHandler) {\n+                    logger.error(\"Received subscription event from a non-subscription channel : {}\",\n+                                 response); \n+                } else {\n+                    SubscriptionEventResponse eventResp = resp.getSubscriptionEvent();\n+                    logger.debug(\"Received subscription event {} for (topic:{}, subscriber:{}).\",\n+                                 va(eventResp.getEvent(), response.getTopic(),\n+                                    response.getSubscriberId()));\n+                    subHandler.handleSubscriptionEvent(response.getTopic(),\n+                                                       response.getSubscriberId(),\n+                                                       eventResp.getEvent());\n+                }\n+                return;\n+            }\n+        }\n+\n         // Response is an ack to a prior PubSubRequest so first retrieve the\n         // PubSub data for this txn.\n         PubSubData pubSubData = txn2PubSubData.remove(response.getTxnId());"},{"sha":"3c434fc587fdc4bb6953c73553d846c7cef5f81c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","status":"added","additions":298,"deletions":0,"changes":298,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexHChannelManager.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFactory;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.exceptions.NoResponseHandlerException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.CleanupChannelMap;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.client.netty.impl.HChannelImpl;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+\n+/**\n+ * Multiplex HChannel Manager which establish a connection for multi subscriptions.\n+ */\n+public class MultiplexHChannelManager extends AbstractHChannelManager {\n+\n+    static final Logger logger = LoggerFactory.getLogger(MultiplexHChannelManager.class);\n+\n+    // Find which HChannel that a given TopicSubscriber used.\n+    protected final CleanupChannelMap<InetSocketAddress> subscriptionChannels;\n+\n+    // Concurrent Map to store Message handler for each topic + sub id combination.\n+    // Store it here instead of in SubscriberResponseHandler as we don't want to lose the handler\n+    // user set when connection is recovered\n+    protected final ConcurrentMap<TopicSubscriber, MessageHandler> topicSubscriber2MessageHandler\n+        = new ConcurrentHashMap<TopicSubscriber, MessageHandler>();\n+\n+    // PipelineFactory to create subscription netty channels to the appropriate server\n+    private final ClientChannelPipelineFactory subscriptionChannelPipelineFactory;\n+\n+    public MultiplexHChannelManager(ClientConfiguration cfg,\n+                                    ChannelFactory socketFactory) {\n+        super(cfg, socketFactory);\n+        subscriptionChannels = new CleanupChannelMap<InetSocketAddress>();\n+        subscriptionChannelPipelineFactory =\n+            new MultiplexSubscriptionChannelPipelineFactory(cfg, this);\n+    }\n+\n+    @Override\n+    protected ClientChannelPipelineFactory getSubscriptionChannelPipelineFactory() {\n+        return subscriptionChannelPipelineFactory;\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(Channel channel) {\n+        // store the channel connected to target host for future usage\n+        InetSocketAddress host = NetUtils.getHostFromChannel(channel);\n+        HChannel newHChannel = new HChannelImpl(host, channel, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        return storeSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    @Override\n+    protected HChannel createAndStoreSubscriptionChannel(InetSocketAddress host) {\n+        HChannel newHChannel = new HChannelImpl(host, this,\n+                                                getSubscriptionChannelPipelineFactory());\n+        return storeSubscriptionChannel(host, newHChannel);\n+    }\n+\n+    private HChannel storeSubscriptionChannel(InetSocketAddress host,\n+                                              HChannel newHChannel) {\n+        // here, we guarantee there is only one channel used to communicate with target\n+        // host.\n+        return subscriptionChannels.addChannel(host, newHChannel);\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannel(InetSocketAddress host) {\n+        return subscriptionChannels.getChannel(host);\n+    }\n+\n+    protected HChannel getSubscriptionChannel(TopicSubscriber subscriber) {\n+        InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+        if (null == host) {\n+            // we don't know where is the owner of the topic\n+            return null;\n+        } else {\n+            return getSubscriptionChannel(host);\n+        }\n+    }\n+\n+    @Override\n+    protected HChannel getSubscriptionChannelByTopicSubscriber(TopicSubscriber subscriber) {\n+        InetSocketAddress host = topic2Host.get(subscriber.getTopic());\n+        if (null == host) {\n+            // we don't know where is the topic\n+            return null;\n+        } else {\n+            // we had know which server owned the topic\n+            HChannel channel = getSubscriptionChannel(host);\n+            if (null == channel) {\n+                // create a channel to connect to sepcified host\n+                channel = createAndStoreSubscriptionChannel(host);\n+            }\n+            return channel;\n+        }\n+    }\n+\n+    @Override\n+    protected void onSubscriptionChannelDisconnected(InetSocketAddress host,\n+                                                     Channel channel) {\n+        HChannel hChannel = subscriptionChannels.getChannel(host);\n+        if (null == hChannel) {\n+            return;\n+        }\n+        Channel underlyingChannel = hChannel.getChannel();\n+        if (null == underlyingChannel ||\n+            !underlyingChannel.equals(channel)) {\n+            return;\n+        }\n+        logger.info(\"Subscription Channel {} disconnected from {}.\",\n+                    va(channel, host));\n+        // remove existed channel\n+        if (subscriptionChannels.removeChannel(host, hChannel)) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel);\n+                channelHandler.getSubscribeResponseHandler()\n+                              .onChannelDisconnected(host, channel);\n+            } catch (NoResponseHandlerException nrhe) {\n+                logger.warn(\"No Channel Handler found for channel {} when it disconnected.\",\n+                            channel);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SubscribeResponseHandler getSubscribeResponseHandler(TopicSubscriber topicSubscriber) {\n+        HChannel hChannel = getSubscriptionChannel(topicSubscriber);\n+        if (null == hChannel) {\n+            return null;\n+        }\n+        Channel channel = hChannel.getChannel();\n+        if (null == channel) {\n+            return null;\n+        }\n+        try {\n+            HChannelHandler channelHandler =\n+                HChannelImpl.getHChannelHandlerFromChannel(channel);\n+            return channelHandler.getSubscribeResponseHandler();\n+        } catch (NoResponseHandlerException nrhe) {\n+            logger.warn(\"No Channel Handler found for channel {}, topic subscriber {}.\",\n+                        channel, topicSubscriber);\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void startDelivery(TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, messageHandler, false);\n+    }\n+\n+    protected void restartDelivery(TopicSubscriber topicSubscriber)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        startDelivery(topicSubscriber, null, true);\n+    }\n+\n+    private void startDelivery(TopicSubscriber topicSubscriber,\n+                               MessageHandler messageHandler,\n+                               boolean restart)\n+        throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        // Make sure we know about this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        MessageHandler existedMsgHandler = topicSubscriber2MessageHandler.get(topicSubscriber);\n+        if (restart) {\n+            // restart using existing msg handler \n+            messageHandler = existedMsgHandler;\n+        } else {\n+            // some has started delivery but not stop it\n+            if (null != existedMsgHandler) {\n+                throw new AlreadyStartDeliveryException(\"A message handler has been started for topic subscriber \" + topicSubscriber);\n+            }\n+            if (messageHandler != null) {\n+                if (null != topicSubscriber2MessageHandler.putIfAbsent(topicSubscriber, messageHandler)) {\n+                    throw new AlreadyStartDeliveryException(\"Someone is also starting delivery for topic subscriber \" + topicSubscriber);\n+                }\n+            }\n+        }\n+\n+        // tell subscribe response handler to start delivering messages for topicSubscriber\n+        subscribeResponseHandler.startDelivery(topicSubscriber, messageHandler);\n+    }\n+\n+    public void stopDelivery(TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        // Make sure we know that this topic subscription on the client side\n+        // exists. The assumption is that the client should have in memory the\n+        // Channel created for the TopicSubscriber once the server has sent\n+        // an ack response to the initial subscribe request.\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.error(\"Client is not yet subscribed to {}.\", topicSubscriber);\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \"\n+                                                   + topicSubscriber);\n+        }\n+\n+        // tell subscribe response handler to stop delivering messages for a given topic subscriber\n+        topicSubscriber2MessageHandler.remove(topicSubscriber);\n+        subscribeResponseHandler.stopDelivery(topicSubscriber);\n+    }\n+                            \n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        SubscribeResponseHandler subscribeResponseHandler =\n+            getSubscribeResponseHandler(topicSubscriber);\n+        if (null == subscribeResponseHandler ||\n+            !subscribeResponseHandler.hasSubscription(topicSubscriber)) {\n+            logger.warn(\"Trying to close a subscription when we don't have a subscription channel cached for {}\",\n+                        topicSubscriber);\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+        subscribeResponseHandler.asyncCloseSubscription(topicSubscriber, callback, context);\n+    }\n+\n+    @Override\n+    protected void checkTimeoutRequestsOnSubscriptionChannels() {\n+        // timeout task may be started before constructing subscriptionChannels\n+        if (null == subscriptionChannels) {\n+            return;\n+        }\n+        for (HChannel channel : subscriptionChannels.getChannels()) {\n+            try {\n+                HChannelHandler channelHandler =\n+                    HChannelImpl.getHChannelHandlerFromChannel(channel.getChannel());\n+                channelHandler.checkTimeoutRequests();\n+            } catch (NoResponseHandlerException nrhe) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void closeSubscriptionChannels() {\n+        subscriptionChannels.close();\n+    }\n+\n+}"},{"sha":"c066ca1536e05cd1fcac64b0f8db5f0b31d7c679","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","status":"added","additions":622,"deletions":0,"changes":622,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscribeResponseHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,622 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+import org.jboss.netty.channel.ChannelFutureListener;\n+\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.data.MessageConsumeData;\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.client.handlers.SubscribeResponseHandler;\n+import org.apache.hedwig.client.netty.HChannelManager;\n+import org.apache.hedwig.client.netty.HChannel;\n+import org.apache.hedwig.client.netty.NetUtils;\n+import org.apache.hedwig.client.netty.FilterableMessageHandler;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientAlreadySubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n+import org.apache.hedwig.exceptions.PubSubException.UnexpectedConditionException;\n+import org.apache.hedwig.filter.ClientMessageFilter;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.MessageIdUtils;\n+import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n+import org.apache.hedwig.util.Callback;\n+import org.apache.hedwig.util.SubscriptionListener;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+public class MultiplexSubscribeResponseHandler extends SubscribeResponseHandler {\n+\n+    private static Logger logger =\n+        LoggerFactory.getLogger(MultiplexSubscribeResponseHandler.class);\n+\n+    class ActiveSubscriber implements SubscriptionListener {\n+        private final TopicSubscriber topicSubscriber;\n+        private final PubSubData op;\n+        private final SubscriptionPreferences preferences;\n+\n+        // the underlying netty channel to send request\n+        private final Channel channel;\n+\n+        // Counter for the number of consumed messages so far to buffer up before we\n+        // send the Consume message back to the server along with the last/largest\n+        // message seq ID seen so far in that batch.\n+        private int numConsumedMessagesInBuffer = 0;\n+        private MessageSeqId lastMessageSeqId;\n+\n+        // Message Handler\n+        private MessageHandler msgHandler;\n+\n+        // Queue used for subscribes when the MessageHandler hasn't been registered\n+        // yet but we've already received subscription messages from the server.\n+        // This will be lazily created as needed.\n+        private Queue<Message> msgQueue = new LinkedList<Message>();\n+\n+        ActiveSubscriber(TopicSubscriber ts, PubSubData op,\n+                        SubscriptionPreferences preferences,\n+                        Channel channel) {\n+            this.topicSubscriber = ts;\n+            this.op = op;\n+            this.preferences = preferences;\n+            this.channel = channel;\n+        }\n+\n+        PubSubData getPubSubData() {\n+            return this.op;\n+        }\n+\n+        TopicSubscriber getTopicSubscriber() {\n+            return this.topicSubscriber;\n+        }\n+\n+        synchronized boolean updateLastMessageSeqId(MessageSeqId seqId) {\n+            if (null != lastMessageSeqId &&\n+                seqId.getLocalComponent() <= lastMessageSeqId.getLocalComponent()) {\n+                return false;\n+            }\n+            ++numConsumedMessagesInBuffer;\n+            lastMessageSeqId = seqId;\n+            if (numConsumedMessagesInBuffer >= cfg.getConsumedMessagesBufferSize()) {\n+                numConsumedMessagesInBuffer = 0;\n+                lastMessageSeqId = null;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        synchronized void startDelivery(MessageHandler messageHandler)\n+        throws AlreadyStartDeliveryException, ClientNotSubscribedException {\n+            if (null != this.msgHandler) {\n+                throw new AlreadyStartDeliveryException(\"A message handler \" + msgHandler \n+                    + \" has been started for \" + topicSubscriber);\n+            }\n+            if (null != messageHandler && messageHandler instanceof FilterableMessageHandler) {\n+                FilterableMessageHandler filterMsgHandler =\n+                    (FilterableMessageHandler) messageHandler;\n+                if (filterMsgHandler.hasMessageFilter()) {\n+                    if (null == preferences) {\n+                        // no preferences means talking to an old version hub server\n+                        logger.warn(\"Start delivering messages with filter but no subscription \"\n+                                  + \"preferences found. It might due to talking to an old version\"\n+                                  + \" hub server.\");\n+                        // use the original message handler.\n+                        messageHandler = filterMsgHandler.getMessageHandler();\n+                    } else {\n+                        // pass subscription preferences to message filter\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Start delivering messages with filter on {}, preferences: {}\",\n+                                         va(topicSubscriber,\n+                                            SubscriptionStateUtils.toString(preferences)));\n+                        }\n+                        ClientMessageFilter msgFilter = filterMsgHandler.getMessageFilter();\n+                        msgFilter.setSubscriptionPreferences(topicSubscriber.getTopic(),\n+                                                             topicSubscriber.getSubscriberId(),\n+                                                             preferences);\n+                    }\n+                }\n+            }\n+\n+            this.msgHandler = messageHandler;\n+            // Once the MessageHandler is registered, see if we have any queued up\n+            // subscription messages sent to us already from the server. If so,\n+            // consume those first. Do this only if the MessageHandler registered is\n+            // not null (since that would be the HedwigSubscriber.stopDelivery\n+            // call).\n+            if (null == msgHandler) {\n+                return;\n+            }\n+            if (msgQueue.size() > 0) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Consuming {} queued up messages for {}\",\n+                                 va(msgQueue.size(), topicSubscriber));\n+                }\n+                for (Message message : msgQueue) {\n+                    asyncMessageDeliver(message);\n+                }\n+                // Now we can remove the queued up messages since they are all\n+                // consumed.\n+                msgQueue.clear();\n+            }\n+        }\n+\n+        synchronized void stopDelivery() {\n+            this.msgHandler = null;\n+        }\n+\n+        synchronized void handleMessage(Message message) {\n+            if (null != msgHandler) {\n+                asyncMessageDeliver(message);\n+            } else {\n+                // MessageHandler has not yet been registered so queue up these\n+                // messages for the Topic Subscription. Make the initial lazy\n+                // creation of the message queue thread safe just so we don't\n+                // run into a race condition where two simultaneous threads process\n+                // a received message and both try to create a new instance of\n+                // the message queue. Performance overhead should be okay\n+                // because the delivery of the topic has not even started yet\n+                // so these messages are not consumed and just buffered up here.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Message {} has arrived but no MessageHandler provided for {}\"\n+                                 + \" yet so queueing up the message.\",\n+                                 va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                                    topicSubscriber));\n+                }\n+                msgQueue.add(message);\n+            }\n+        }\n+\n+        synchronized void asyncMessageDeliver(Message message) {\n+            if (null == msgHandler) {\n+                logger.error(\"No message handler found to deliver message {} to {}.\",\n+                             va(MessageIdUtils.msgIdToReadableString(message.getMsgId()),\n+                                topicSubscriber));\n+                return;\n+            }\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Call the client app's MessageHandler asynchronously to deliver the message {} to {}\",\n+                             va(message, topicSubscriber));\n+            }\n+            MessageConsumeData messageConsumeData =\n+                new MessageConsumeData(topicSubscriber, message);\n+            msgHandler.deliver(topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(),\n+                               message, sChannelManager.getConsumeCallback(),\n+                               messageConsumeData);\n+        }\n+\n+        void consume(final MessageSeqId messageSeqId) {\n+            PubSubRequest.Builder pubsubRequestBuilder =\n+                NetUtils.buildConsumeRequest(sChannelManager.nextTxnId(),\n+                                             topicSubscriber, messageSeqId);  \n+\n+            // For Consume requests, we will send them from the client in a fire and\n+            // forget manner. We are not expecting the server to send back an ack\n+            // response so no need to register this in the ResponseHandler. There\n+            // are no callbacks to invoke since this isn't a client initiated\n+            // action. Instead, just have a future listener that will log an error\n+            // message if there was a problem writing the consume request.\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                             va(NetUtils.getHostFromChannel(channel),\n+                                messageSeqId, topicSubscriber));\n+            }\n+            ChannelFuture future = channel.write(pubsubRequestBuilder.build());\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                        logger.error(\"Error writing a Consume request to host: {} with messageSeqId: {} for {}\",\n+                                     va(host, messageSeqId, topicSubscriber));\n+                    }\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void processEvent(ByteString topic, ByteString subscriberId,\n+                                 SubscriptionEvent event) {\n+            switch (event) {\n+            // for all cases we need to resubscribe for the subscription\n+            case TOPIC_MOVED:\n+                sChannelManager.clearHostForTopic(topic, NetUtils.getHostFromChannel(channel));\n+                resubscribeIfNecessary(event);\n+                break;\n+            case SUBSCRIPTION_FORCED_CLOSED:\n+                resubscribeIfNecessary(event);\n+                break;\n+            default:\n+                logger.error(\"Receive unknown subscription event {} for {}.\",\n+                             va(event, topicSubscriber));\n+            }\n+        }\n+\n+        private void resubscribeIfNecessary(SubscriptionEvent event) {\n+            // if subscriber has been changed, we don't need to resubscribe\n+            if (!subscriptions.remove(topicSubscriber, this)) {\n+                return;\n+            }\n+            if (!op.options.getEnableResubscribe()) {\n+                sChannelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n+                    topicSubscriber.getTopic(), topicSubscriber.getSubscriberId(), event);\n+                return;\n+            }\n+            // Since the connection to the server host that was responsible\n+            // for the topic died, we are not sure about the state of that\n+            // server. Resend the original subscribe request data to the default\n+            // server host/VIP. Also clear out all of the servers we've\n+            // contacted or attempted to from this request as we are starting a\n+            // \"fresh\" subscribe request.\n+            op.clearServersList();\n+            // Set a new type of VoidCallback for this async call. We need this\n+            // hook so after the resubscribe has completed, delivery for\n+            // that topic subscriber should also be restarted (if it was that\n+            // case before the channel disconnect).\n+            final long retryWaitTime = cfg.getSubscribeReconnectRetryWaitTime();\n+            ResubscribeCallback resubscribeCb =\n+                new ResubscribeCallback(topicSubscriber, op,\n+                                        sChannelManager, retryWaitTime);\n+            op.setCallback(resubscribeCb);\n+            op.context = null;\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Resubscribe {} with origSubData {}\",\n+                             va(topicSubscriber, op));\n+            }\n+            // resubmit the request\n+            sChannelManager.submitOp(op);\n+        }\n+    }\n+\n+    protected final ReentrantReadWriteLock disconnectLock =\n+        new ReentrantReadWriteLock();\n+\n+    // the underlying subscription channel\n+    volatile HChannel hChannel;\n+    InetSocketAddress host; \n+    protected final ConcurrentMap<TopicSubscriber, ActiveSubscriber> subscriptions\n+        = new ConcurrentHashMap<TopicSubscriber, ActiveSubscriber>();\n+    private final MultiplexHChannelManager sChannelManager;\n+\n+    protected MultiplexSubscribeResponseHandler(ClientConfiguration cfg,\n+                                                HChannelManager channelManager) {\n+        super(cfg, channelManager);\n+        sChannelManager = (MultiplexHChannelManager) channelManager;\n+    }\n+\n+    protected HChannelManager getHChannelManager() {\n+        return this.sChannelManager;\n+    }\n+\n+    protected ClientConfiguration getConfiguration() {\n+        return cfg;\n+    }\n+\n+    private ActiveSubscriber getActiveSubscriber(TopicSubscriber ts) {\n+        return subscriptions.get(ts);\n+    }\n+\n+    @Override\n+    public void handleResponse(PubSubResponse response, PubSubData pubSubData,\n+                               Channel channel) throws Exception {\n+        if (null == hChannel) {\n+            host = NetUtils.getHostFromChannel(channel);\n+            hChannel = sChannelManager.getSubscriptionChannel(host);\n+            if (null == hChannel ||\n+                !channel.equals(hChannel.getChannel())) {\n+                PubSubException pse =\n+                    new UnexpectedConditionException(\"Failed to get subscription channel of \" + host);\n+                pubSubData.getCallback().operationFailed(pubSubData.context, pse);\n+                return;\n+            }\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe response: {}, pubSubData: {}, host: {}.\",\n+                         va(response, pubSubData, NetUtils.getHostFromChannel(channel)));\n+        }\n+        switch (response.getStatusCode()) {\n+        case SUCCESS:\n+            TopicSubscriber ts = new TopicSubscriber(pubSubData.topic,\n+                                                     pubSubData.subscriberId);\n+            SubscriptionPreferences preferences = null;\n+            if (response.hasResponseBody()) {\n+                ResponseBody respBody = response.getResponseBody(); \n+                if (respBody.hasSubscribeResponse()) {\n+                    SubscribeResponse resp = respBody.getSubscribeResponse();\n+                    if (resp.hasPreferences()) {\n+                        preferences = resp.getPreferences();\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Receive subscription preferences for {} : {}\",\n+                                         va(ts,\n+                                            SubscriptionStateUtils.toString(preferences)));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ActiveSubscriber ss = new ActiveSubscriber(ts, pubSubData, preferences,\n+                                                       channel);\n+\n+            boolean success = false;\n+            // Store the Subscribe state\n+            disconnectLock.readLock().lock();\n+            try {\n+                ActiveSubscriber oldSS = subscriptions.putIfAbsent(ts, ss);\n+                if (null != oldSS) {\n+                    logger.warn(\"Subscribe {} has existed in channel {}.\",\n+                                va(ts, channel));\n+                    success = false;\n+                } else {\n+                    logger.debug(\"Succeed to add subscription {} in channel {}.\",\n+                                 va(ts, channel));\n+                    success = true;\n+                }\n+            } finally {\n+                disconnectLock.readLock().unlock();\n+            }\n+            if (success) {\n+                // Response was success so invoke the callback's operationFinished\n+                // method.\n+                pubSubData.getCallback().operationFinished(pubSubData.context, null);\n+            } else {\n+                ClientAlreadySubscribedException exception =\n+                    new ClientAlreadySubscribedException(\"Client is already subscribed for \" + ts);\n+                pubSubData.getCallback().operationFailed(pubSubData.context, exception);\n+            }\n+            break;\n+        case CLIENT_ALREADY_SUBSCRIBED:\n+            // For Subscribe requests, the server says that the client is\n+            // already subscribed to it.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ClientAlreadySubscribedException(\n+                                                     \"Client is already subscribed for topic: \" + pubSubData.topic.toStringUtf8() + \", subscriberId: \"\n+                                                     + pubSubData.subscriberId.toStringUtf8()));\n+            break;\n+        case SERVICE_DOWN:\n+            // Response was service down failure so just invoke the callback's\n+            // operationFailed method.\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a SERVICE_DOWN status\"));\n+            break;\n+        case NOT_RESPONSIBLE_FOR_TOPIC:\n+            // Redirect response so we'll need to repost the original Subscribe\n+            // Request\n+            handleRedirectResponse(response, pubSubData, channel);\n+            break;\n+        default:\n+            // Consider all other status codes as errors, operation failed\n+            // cases.\n+            logger.error(\"Unexpected error response from server for PubSubResponse: \" + response);\n+            pubSubData.getCallback().operationFailed(pubSubData.context, new ServiceDownException(\n+                                                     \"Server responded with a status code of: \" + response.getStatusCode()));\n+            break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleSubscribeMessage(PubSubResponse response) {\n+        Message message = response.getMessage();\n+        TopicSubscriber ts = new TopicSubscriber(response.getTopic(),\n+                                                 response.getSubscriberId());\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Handling a Subscribe message in response: {}, {}\",\n+                         va(response, ts));\n+        }\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found receiving its message {}.\",\n+                         va(ts, MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.handleMessage(message);\n+    }\n+\n+    @Override\n+    protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n+                                       Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.error(\"Subscriber {} is not found delivering its message {}.\",\n+                         va(topicSubscriber,\n+                            MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        ss.asyncMessageDeliver(message);\n+    }\n+\n+    @Override\n+    protected void messageConsumed(TopicSubscriber topicSubscriber,\n+                                   Message message) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consumed its message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(message.getMsgId())));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Message has been successfully consumed by the client app : {}, {}\",\n+                         va(message, topicSubscriber));\n+        }\n+        // For consume response to server, there is a config param on how many\n+        // messages to consume and buffer up before sending the consume request.\n+        // We just need to keep a count of the number of messages consumed\n+        // and the largest/latest msg ID seen so far in this batch. Messages\n+        // should be delivered in order and without gaps. Do this only if\n+        // auto-sending of consume messages is enabled.\n+        if (cfg.isAutoSendConsumeMessageEnabled()) {\n+            // Update these variables only if we are auto-sending consume\n+            // messages to the server. Otherwise the onus is on the client app\n+            // to call the Subscriber consume API to let the server know which\n+            // messages it has successfully consumed.\n+            if (ss.updateLastMessageSeqId(message.getMsgId())) {\n+                // Send the consume request and reset the consumed messages buffer\n+                // variables. We will use the same Channel created from the\n+                // subscribe request for the TopicSubscriber.\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Consume message {} when reaching consumed message buffer limit.\",\n+                                 message.getMsgId());\n+                }\n+                ss.consume(message.getMsgId());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                        SubscriptionEvent event) {\n+        TopicSubscriber ts = new TopicSubscriber(topic, subscriberId);\n+        ActiveSubscriber ss = getActiveSubscriber(ts);\n+        if (null == ss) {\n+            logger.warn(\"No subscription {} found receiving subscription event {}.\",\n+                        va(ts, event));\n+            return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Received subscription event {} for ({}).\",\n+                         va(event, ts));\n+        }\n+        ss.processEvent(topic, subscriberId, event);\n+    }\n+\n+    @Override\n+    public void startDelivery(final TopicSubscriber topicSubscriber,\n+                              MessageHandler messageHandler)\n+    throws ClientNotSubscribedException, AlreadyStartDeliveryException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Start delivering message for {} using message handler {}\",\n+                         va(topicSubscriber, messageHandler));\n+        }\n+        ss.startDelivery(messageHandler); \n+    }\n+\n+    @Override\n+    public void stopDelivery(final TopicSubscriber topicSubscriber)\n+    throws ClientNotSubscribedException {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            throw new ClientNotSubscribedException(\"Client is not yet subscribed to \" + topicSubscriber);\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Stop delivering messages for {}\", topicSubscriber);\n+        }\n+        ss.stopDelivery();\n+    }\n+\n+    @Override\n+    public boolean hasSubscription(TopicSubscriber topicSubscriber) {\n+        return subscriptions.containsKey(topicSubscriber);\n+    }\n+\n+    @Override\n+    public void asyncCloseSubscription(final TopicSubscriber topicSubscriber,\n+                                       final Callback<ResponseBody> callback,\n+                                       final Object context) {\n+        final ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss || null == hChannel) {\n+            logger.debug(\"No subscription {} found when closing its subscription from {}.\",\n+                         va(topicSubscriber, hChannel));\n+            callback.operationFinished(context, (ResponseBody)null);\n+            return;\n+        }\n+        Callback<ResponseBody> closeCb = new Callback<ResponseBody>() {\n+            @Override\n+            public void operationFinished(Object ctx, ResponseBody respBody) {\n+                disconnectLock.readLock().lock();\n+                try {\n+                    subscriptions.remove(topicSubscriber, ss);\n+                } finally {\n+                    disconnectLock.readLock().unlock();\n+                }\n+                callback.operationFinished(context, null);\n+            }\n+\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                callback.operationFailed(context, exception);\n+            }\n+        };\n+        PubSubData closeOp = new PubSubData(topicSubscriber.getTopic(), null,\n+                                            topicSubscriber.getSubscriberId(),\n+                                            OperationType.CLOSESUBSCRIPTION,\n+                                            null, closeCb, context);\n+        hChannel.submitOp(closeOp);\n+    }\n+\n+    @Override\n+    public void consume(final TopicSubscriber topicSubscriber,\n+                        final MessageSeqId messageSeqId) {\n+        ActiveSubscriber ss = getActiveSubscriber(topicSubscriber);\n+        if (null == ss) {\n+            logger.warn(\"Subscriber {} is not found consuming message {}.\",\n+                        va(topicSubscriber,\n+                           MessageIdUtils.msgIdToReadableString(messageSeqId)));\n+            return;\n+        }\n+        ss.consume(messageSeqId); \n+    }\n+\n+    @Override\n+    public void onChannelDisconnected(InetSocketAddress host, Channel channel) {\n+        disconnectLock.writeLock().lock();\n+        try {\n+            onDisconnect(host);\n+        } finally {\n+            disconnectLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private void onDisconnect(InetSocketAddress host) {\n+        for (ActiveSubscriber ss : subscriptions.values()) {\n+            onDisconnect(ss, host);\n+        }\n+    }\n+\n+    private void onDisconnect(ActiveSubscriber ss, InetSocketAddress host) {\n+        TopicSubscriber ts = ss.getTopicSubscriber();\n+        logger.info(\"Subscription channel for ({}) is disconnected.\", ts);\n+        ss.processEvent(ts.getTopic(), ts.getSubscriberId(),\n+                        SubscriptionEvent.TOPIC_MOVED);\n+    }\n+\n+}"},{"sha":"c43108a90f140d7a4eb5ef9c6ecf46d4140b6608","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/MultiplexSubscriptionChannelPipelineFactory.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.handlers.AbstractResponseHandler;\n+import org.apache.hedwig.client.handlers.CloseSubscriptionResponseHandler;\n+import org.apache.hedwig.client.netty.impl.AbstractHChannelManager;\n+import org.apache.hedwig.client.netty.impl.ClientChannelPipelineFactory;\n+import org.apache.hedwig.client.netty.impl.HChannelHandler;\n+import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n+\n+public class MultiplexSubscriptionChannelPipelineFactory extends ClientChannelPipelineFactory {\n+\n+    public MultiplexSubscriptionChannelPipelineFactory(ClientConfiguration cfg,\n+                                                       MultiplexHChannelManager channelManager) {\n+        super(cfg, channelManager);\n+    }\n+\n+    @Override\n+    protected Map<OperationType, AbstractResponseHandler> createResponseHandlers() {\n+        Map<OperationType, AbstractResponseHandler> handlers =\n+            new HashMap<OperationType, AbstractResponseHandler>();\n+        handlers.put(OperationType.SUBSCRIBE,\n+                     new MultiplexSubscribeResponseHandler(cfg, channelManager));\n+        handlers.put(OperationType.CLOSESUBSCRIPTION,\n+                     new CloseSubscriptionResponseHandler(cfg, channelManager));\n+        return handlers;\n+    }\n+\n+}"},{"sha":"cd7ff80fa479e8cb8bd41434d83acdb36d0c7f63","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/ResubscribeCallback.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/ResubscribeCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/ResubscribeCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/multiplex/ResubscribeCallback.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,94 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty.impl.multiplex;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hedwig.client.data.PubSubData;\n+import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.client.exceptions.AlreadyStartDeliveryException;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.exceptions.PubSubException.ClientNotSubscribedException;\n+import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n+import org.apache.hedwig.util.Callback;\n+import static org.apache.hedwig.util.VarArgs.va;\n+\n+/**\n+ * This class is used when a Subscribe channel gets disconnected and we attempt\n+ * to resubmit subscribe requests existed in that channel. Once the resubscribe\n+ * the topic is completed, we need to restart delivery for that topic.\n+ */\n+class ResubscribeCallback implements Callback<ResponseBody> {\n+\n+    private static Logger logger = LoggerFactory.getLogger(ResubscribeCallback.class);\n+\n+    // Private member variables\n+    private final TopicSubscriber origTopicSubscriber;\n+    private final PubSubData origSubData;\n+    private final MultiplexHChannelManager channelManager;\n+    private final long retryWaitTime;\n+\n+    // Constructor\n+    ResubscribeCallback(TopicSubscriber origTopicSubscriber,\n+                        PubSubData origSubData,\n+                        MultiplexHChannelManager channelManager,\n+                        long retryWaitTime) {\n+        this.origTopicSubscriber = origTopicSubscriber;\n+        this.origSubData = origSubData;\n+        this.channelManager = channelManager;\n+        this.retryWaitTime = retryWaitTime;\n+    }\n+\n+    @Override\n+    public void operationFinished(Object ctx, ResponseBody resultOfOperation) {\n+        if (logger.isDebugEnabled())\n+            logger.debug(\"Resubscribe succeeded for origSubData: \" + origSubData);\n+        // Now we want to restart delivery for the subscription channel only\n+        // if delivery was started at the time the original subscribe channel\n+        // was disconnected.\n+        try {\n+            channelManager.restartDelivery(origTopicSubscriber);\n+        } catch (ClientNotSubscribedException e) {\n+            // This exception should never be thrown here but just in case,\n+            // log an error and just keep retrying the subscribe request.\n+            logger.error(\"Subscribe was successful but error starting delivery for {} : {}\",\n+                         va(origTopicSubscriber, e.getMessage()));\n+            retrySubscribeRequest();\n+        } catch (AlreadyStartDeliveryException asde) {\n+            // should not reach here\n+        }\n+    }\n+\n+    @Override\n+    public void operationFailed(Object ctx, PubSubException exception) {\n+        // If the resubscribe fails, just keep retrying the subscribe\n+        // request. There isn't a way to flag to the application layer that\n+        // a topic subscription has failed. So instead, we'll just keep\n+        // retrying in the background until success.\n+        logger.error(\"Resubscribe failed with error: \" + exception.getMessage());\n+        retrySubscribeRequest();\n+    }\n+\n+    private void retrySubscribeRequest() {\n+        origSubData.clearServersList();\n+        logger.debug(\"Resubmit subscribe request for {} in {} ms later.\",\n+                     va(origTopicSubscriber, retryWaitTime));\n+        channelManager.submitOpAfterDelay(origSubData, retryWaitTime);\n+    }\n+}"},{"sha":"2f96d0b77f34471d469ca9a45fddf72e5d0da82c","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","status":"modified","additions":32,"deletions":4,"changes":36,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/impl/simple/SimpleSubscribeResponseHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -246,6 +246,21 @@ public void handleSubscribeMessage(PubSubResponse response) {\n         }\n     }\n \n+    @Override\n+    public void handleSubscriptionEvent(ByteString topic, ByteString subscriberId,\n+                                        SubscriptionEvent event) {\n+        Channel channel;\n+        synchronized (this) {\n+            channel = subscribeChannel;\n+        }\n+        if (null == channel) {\n+            logger.warn(\"No subscription channel found when receiving subscription event {} for (topic:{}, subscriber:{}).\",\n+                        va(event, topic, subscriberId));\n+            return;\n+        }\n+        processSubscriptionEvent(event, NetUtils.getHostFromChannel(channel), channel);\n+    }\n+\n     @Override\n     protected void asyncMessageDeliver(TopicSubscriber topicSubscriber,\n                                        Message message) {\n@@ -488,7 +503,20 @@ public void onChannelDisconnected(InetSocketAddress host,\n         if (origTopicSubscriber == null) {\n             return;\n         }\n-        sChannelManager.clearHostForTopic(origTopicSubscriber.getTopic(), host);\n+        processSubscriptionEvent(SubscriptionEvent.TOPIC_MOVED, host, channel);\n+    }\n+\n+    private void processSubscriptionEvent(final SubscriptionEvent event, InetSocketAddress host,\n+                                          final Channel channel) {\n+        if (SubscriptionEvent.TOPIC_MOVED != event &&\n+            SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED != event) {\n+            logger.warn(\"Ignore subscription event {} received from channel {}.\",\n+                        event, channel);\n+            return;\n+        }\n+        if (SubscriptionEvent.TOPIC_MOVED == event) {\n+            sChannelManager.clearHostForTopic(origTopicSubscriber.getTopic(), host);\n+        }\n         // clear subscription status\n         sChannelManager.asyncCloseSubscription(origTopicSubscriber, new Callback<ResponseBody>() {\n \n@@ -530,10 +558,10 @@ private void finish() {\n                                  origTopicSubscriber, origSubData);\n                     sChannelManager.submitOpToDefaultServer(origSubData);\n                 } else {\n-                    logger.info(\"Subscription channel for ({}) is disconnected.\",\n-                                origTopicSubscriber);\n+                    logger.info(\"Subscription channel {} for ({}) is disconnected.\",\n+                                channel, origTopicSubscriber);\n                     sChannelManager.getSubscriptionEventEmitter().emitSubscriptionEvent(\n-                        origSubData.topic, origSubData.subscriberId, SubscriptionEvent.TOPIC_MOVED);\n+                        origSubData.topic, origSubData.subscriberId, event);\n                 }\n             }\n         }, null);"},{"sha":"137d6fc1213d9a9cdc9df929a3d5957fac7a4618","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":660,"deletions":154,"changes":814,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -8949,6 +8949,355 @@ public Builder clearSubscriberId() {\n     // @@protoc_insertion_point(class_scope:Hedwig.UnsubscribeRequest)\n   }\n   \n+  public interface CloseSubscriptionRequestOrBuilder\n+      extends com.google.protobuf.MessageOrBuilder {\n+    \n+    // required bytes subscriberId = 2;\n+    boolean hasSubscriberId();\n+    com.google.protobuf.ByteString getSubscriberId();\n+  }\n+  public static final class CloseSubscriptionRequest extends\n+      com.google.protobuf.GeneratedMessage\n+      implements CloseSubscriptionRequestOrBuilder {\n+    // Use CloseSubscriptionRequest.newBuilder() to construct.\n+    private CloseSubscriptionRequest(Builder builder) {\n+      super(builder);\n+    }\n+    private CloseSubscriptionRequest(boolean noInit) {}\n+    \n+    private static final CloseSubscriptionRequest defaultInstance;\n+    public static CloseSubscriptionRequest getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+    \n+    public CloseSubscriptionRequest getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+    \n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+    }\n+    \n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n+    }\n+    \n+    private int bitField0_;\n+    // required bytes subscriberId = 2;\n+    public static final int SUBSCRIBERID_FIELD_NUMBER = 2;\n+    private com.google.protobuf.ByteString subscriberId_;\n+    public boolean hasSubscriberId() {\n+      return ((bitField0_ & 0x00000001) == 0x00000001);\n+    }\n+    public com.google.protobuf.ByteString getSubscriberId() {\n+      return subscriberId_;\n+    }\n+    \n+    private void initFields() {\n+      subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n+    }\n+    private byte memoizedIsInitialized = -1;\n+    public final boolean isInitialized() {\n+      byte isInitialized = memoizedIsInitialized;\n+      if (isInitialized != -1) return isInitialized == 1;\n+      \n+      if (!hasSubscriberId()) {\n+        memoizedIsInitialized = 0;\n+        return false;\n+      }\n+      memoizedIsInitialized = 1;\n+      return true;\n+    }\n+    \n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        output.writeBytes(2, subscriberId_);\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+    \n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+    \n+      size = 0;\n+      if (((bitField0_ & 0x00000001) == 0x00000001)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeBytesSize(2, subscriberId_);\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+    \n+    private static final long serialVersionUID = 0L;\n+    @java.lang.Override\n+    protected java.lang.Object writeReplace()\n+        throws java.io.ObjectStreamException {\n+      return super.writeReplace();\n+    }\n+    \n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    \n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+    \n+    @java.lang.Override\n+    protected Builder newBuilderForType(\n+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {\n+      Builder builder = new Builder(parent);\n+      return builder;\n+    }\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder>\n+       implements org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequestOrBuilder {\n+      public static final com.google.protobuf.Descriptors.Descriptor\n+          getDescriptor() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+      }\n+      \n+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+          internalGetFieldAccessorTable() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n+      }\n+      \n+      // Construct using org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.newBuilder()\n+      private Builder() {\n+        maybeForceBuilderInitialization();\n+      }\n+      \n+      private Builder(BuilderParent parent) {\n+        super(parent);\n+        maybeForceBuilderInitialization();\n+      }\n+      private void maybeForceBuilderInitialization() {\n+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n+        }\n+      }\n+      private static Builder create() {\n+        return new Builder();\n+      }\n+      \n+      public Builder clear() {\n+        super.clear();\n+        subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        return this;\n+      }\n+      \n+      public Builder clone() {\n+        return create().mergeFrom(buildPartial());\n+      }\n+      \n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDescriptor();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest getDefaultInstanceForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDefaultInstance();\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest build() {\n+        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return result;\n+      }\n+      \n+      private org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = buildPartial();\n+        if (!result.isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return result;\n+      }\n+      \n+      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest buildPartial() {\n+        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = new org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest(this);\n+        int from_bitField0_ = bitField0_;\n+        int to_bitField0_ = 0;\n+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n+          to_bitField0_ |= 0x00000001;\n+        }\n+        result.subscriberId_ = subscriberId_;\n+        result.bitField0_ = to_bitField0_;\n+        onBuilt();\n+        return result;\n+      }\n+      \n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest) {\n+          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+      \n+      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest other) {\n+        if (other == org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDefaultInstance()) return this;\n+        if (other.hasSubscriberId()) {\n+          setSubscriberId(other.getSubscriberId());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+      \n+      public final boolean isInitialized() {\n+        if (!hasSubscriberId()) {\n+          \n+          return false;\n+        }\n+        return true;\n+      }\n+      \n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              onChanged();\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                onChanged();\n+                return this;\n+              }\n+              break;\n+            }\n+            case 18: {\n+              bitField0_ |= 0x00000001;\n+              subscriberId_ = input.readBytes();\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      \n+      private int bitField0_;\n+      \n+      // required bytes subscriberId = 2;\n+      private com.google.protobuf.ByteString subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n+      public boolean hasSubscriberId() {\n+        return ((bitField0_ & 0x00000001) == 0x00000001);\n+      }\n+      public com.google.protobuf.ByteString getSubscriberId() {\n+        return subscriberId_;\n+      }\n+      public Builder setSubscriberId(com.google.protobuf.ByteString value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  bitField0_ |= 0x00000001;\n+        subscriberId_ = value;\n+        onChanged();\n+        return this;\n+      }\n+      public Builder clearSubscriberId() {\n+        bitField0_ = (bitField0_ & ~0x00000001);\n+        subscriberId_ = getDefaultInstance().getSubscriberId();\n+        onChanged();\n+        return this;\n+      }\n+      \n+      // @@protoc_insertion_point(builder_scope:Hedwig.CloseSubscriptionRequest)\n+    }\n+    \n+    static {\n+      defaultInstance = new CloseSubscriptionRequest(true);\n+      defaultInstance.initFields();\n+    }\n+    \n+    // @@protoc_insertion_point(class_scope:Hedwig.CloseSubscriptionRequest)\n+  }\n+  \n   public interface StopDeliveryRequestOrBuilder\n       extends com.google.protobuf.MessageOrBuilder {\n     \n@@ -9647,64 +9996,60 @@ public Builder clearSubscriberId() {\n     // @@protoc_insertion_point(class_scope:Hedwig.StartDeliveryRequest)\n   }\n   \n-  public interface CloseSubscriptionRequestOrBuilder\n+  public interface SubscriptionEventResponseOrBuilder\n       extends com.google.protobuf.MessageOrBuilder {\n     \n-    // required bytes subscriberId = 2;\n-    boolean hasSubscriberId();\n-    com.google.protobuf.ByteString getSubscriberId();\n+    // optional .Hedwig.SubscriptionEvent event = 1;\n+    boolean hasEvent();\n+    org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent getEvent();\n   }\n-  public static final class CloseSubscriptionRequest extends\n+  public static final class SubscriptionEventResponse extends\n       com.google.protobuf.GeneratedMessage\n-      implements CloseSubscriptionRequestOrBuilder {\n-    // Use CloseSubscriptionRequest.newBuilder() to construct.\n-    private CloseSubscriptionRequest(Builder builder) {\n+      implements SubscriptionEventResponseOrBuilder {\n+    // Use SubscriptionEventResponse.newBuilder() to construct.\n+    private SubscriptionEventResponse(Builder builder) {\n       super(builder);\n     }\n-    private CloseSubscriptionRequest(boolean noInit) {}\n+    private SubscriptionEventResponse(boolean noInit) {}\n     \n-    private static final CloseSubscriptionRequest defaultInstance;\n-    public static CloseSubscriptionRequest getDefaultInstance() {\n+    private static final SubscriptionEventResponse defaultInstance;\n+    public static SubscriptionEventResponse getDefaultInstance() {\n       return defaultInstance;\n     }\n     \n-    public CloseSubscriptionRequest getDefaultInstanceForType() {\n+    public SubscriptionEventResponse getDefaultInstanceForType() {\n       return defaultInstance;\n     }\n     \n     public static final com.google.protobuf.Descriptors.Descriptor\n         getDescriptor() {\n-      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_SubscriptionEventResponse_descriptor;\n     }\n     \n     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n         internalGetFieldAccessorTable() {\n-      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n+      return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_SubscriptionEventResponse_fieldAccessorTable;\n     }\n     \n     private int bitField0_;\n-    // required bytes subscriberId = 2;\n-    public static final int SUBSCRIBERID_FIELD_NUMBER = 2;\n-    private com.google.protobuf.ByteString subscriberId_;\n-    public boolean hasSubscriberId() {\n+    // optional .Hedwig.SubscriptionEvent event = 1;\n+    public static final int EVENT_FIELD_NUMBER = 1;\n+    private org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent event_;\n+    public boolean hasEvent() {\n       return ((bitField0_ & 0x00000001) == 0x00000001);\n     }\n-    public com.google.protobuf.ByteString getSubscriberId() {\n-      return subscriberId_;\n+    public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent getEvent() {\n+      return event_;\n     }\n     \n     private void initFields() {\n-      subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n+      event_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent.TOPIC_MOVED;\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n       byte isInitialized = memoizedIsInitialized;\n       if (isInitialized != -1) return isInitialized == 1;\n       \n-      if (!hasSubscriberId()) {\n-        memoizedIsInitialized = 0;\n-        return false;\n-      }\n       memoizedIsInitialized = 1;\n       return true;\n     }\n@@ -9713,7 +10058,7 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n                         throws java.io.IOException {\n       getSerializedSize();\n       if (((bitField0_ & 0x00000001) == 0x00000001)) {\n-        output.writeBytes(2, subscriberId_);\n+        output.writeEnum(1, event_.getNumber());\n       }\n       getUnknownFields().writeTo(output);\n     }\n@@ -9726,7 +10071,7 @@ public int getSerializedSize() {\n       size = 0;\n       if (((bitField0_ & 0x00000001) == 0x00000001)) {\n         size += com.google.protobuf.CodedOutputStream\n-          .computeBytesSize(2, subscriberId_);\n+          .computeEnumSize(1, event_.getNumber());\n       }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n@@ -9740,41 +10085,41 @@ public int getSerializedSize() {\n       return super.writeReplace();\n     }\n     \n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         com.google.protobuf.ByteString data)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(data).buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         com.google.protobuf.ByteString data,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(data, extensionRegistry)\n                .buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(byte[] data)\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(byte[] data)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(data).buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         byte[] data,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(data, extensionRegistry)\n                .buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(java.io.InputStream input)\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(java.io.InputStream input)\n         throws java.io.IOException {\n       return newBuilder().mergeFrom(input).buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         java.io.InputStream input,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         throws java.io.IOException {\n       return newBuilder().mergeFrom(input, extensionRegistry)\n                .buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseDelimitedFrom(java.io.InputStream input)\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseDelimitedFrom(java.io.InputStream input)\n         throws java.io.IOException {\n       Builder builder = newBuilder();\n       if (builder.mergeDelimitedFrom(input)) {\n@@ -9783,7 +10128,7 @@ public int getSerializedSize() {\n         return null;\n       }\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseDelimitedFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseDelimitedFrom(\n         java.io.InputStream input,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         throws java.io.IOException {\n@@ -9794,12 +10139,12 @@ public int getSerializedSize() {\n         return null;\n       }\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         com.google.protobuf.CodedInputStream input)\n         throws java.io.IOException {\n       return newBuilder().mergeFrom(input).buildParsed();\n     }\n-    public static org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest parseFrom(\n+    public static org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse parseFrom(\n         com.google.protobuf.CodedInputStream input,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         throws java.io.IOException {\n@@ -9809,7 +10154,7 @@ public int getSerializedSize() {\n     \n     public static Builder newBuilder() { return Builder.create(); }\n     public Builder newBuilderForType() { return newBuilder(); }\n-    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest prototype) {\n+    public static Builder newBuilder(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse prototype) {\n       return newBuilder().mergeFrom(prototype);\n     }\n     public Builder toBuilder() { return newBuilder(this); }\n@@ -9822,18 +10167,18 @@ protected Builder newBuilderForType(\n     }\n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder>\n-       implements org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequestOrBuilder {\n+       implements org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder {\n       public static final com.google.protobuf.Descriptors.Descriptor\n           getDescriptor() {\n-        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_SubscriptionEventResponse_descriptor;\n       }\n       \n       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n           internalGetFieldAccessorTable() {\n-        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n+        return org.apache.hedwig.protocol.PubSubProtocol.internal_static_Hedwig_SubscriptionEventResponse_fieldAccessorTable;\n       }\n       \n-      // Construct using org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.newBuilder()\n+      // Construct using org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.newBuilder()\n       private Builder() {\n         maybeForceBuilderInitialization();\n       }\n@@ -9852,7 +10197,7 @@ private static Builder create() {\n       \n       public Builder clear() {\n         super.clear();\n-        subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n+        event_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent.TOPIC_MOVED;\n         bitField0_ = (bitField0_ & ~0x00000001);\n         return this;\n       }\n@@ -9863,67 +10208,63 @@ public Builder clone() {\n       \n       public com.google.protobuf.Descriptors.Descriptor\n           getDescriptorForType() {\n-        return org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDescriptor();\n+        return org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDescriptor();\n       }\n       \n-      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest getDefaultInstanceForType() {\n-        return org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDefaultInstance();\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse getDefaultInstanceForType() {\n+        return org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance();\n       }\n       \n-      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest build() {\n-        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = buildPartial();\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse build() {\n+        org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse result = buildPartial();\n         if (!result.isInitialized()) {\n           throw newUninitializedMessageException(result);\n         }\n         return result;\n       }\n       \n-      private org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest buildParsed()\n+      private org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse buildParsed()\n           throws com.google.protobuf.InvalidProtocolBufferException {\n-        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = buildPartial();\n+        org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse result = buildPartial();\n         if (!result.isInitialized()) {\n           throw newUninitializedMessageException(\n             result).asInvalidProtocolBufferException();\n         }\n         return result;\n       }\n       \n-      public org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest buildPartial() {\n-        org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest result = new org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest(this);\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse buildPartial() {\n+        org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse result = new org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse(this);\n         int from_bitField0_ = bitField0_;\n         int to_bitField0_ = 0;\n         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {\n           to_bitField0_ |= 0x00000001;\n         }\n-        result.subscriberId_ = subscriberId_;\n+        result.event_ = event_;\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n       }\n       \n       public Builder mergeFrom(com.google.protobuf.Message other) {\n-        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest) {\n-          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest)other);\n+        if (other instanceof org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse) {\n+          return mergeFrom((org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse)other);\n         } else {\n           super.mergeFrom(other);\n           return this;\n         }\n       }\n       \n-      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest other) {\n-        if (other == org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.getDefaultInstance()) return this;\n-        if (other.hasSubscriberId()) {\n-          setSubscriberId(other.getSubscriberId());\n+      public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse other) {\n+        if (other == org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance()) return this;\n+        if (other.hasEvent()) {\n+          setEvent(other.getEvent());\n         }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n       \n       public final boolean isInitialized() {\n-        if (!hasSubscriberId()) {\n-          \n-          return false;\n-        }\n         return true;\n       }\n       \n@@ -9950,9 +10291,15 @@ public Builder mergeFrom(\n               }\n               break;\n             }\n-            case 18: {\n-              bitField0_ |= 0x00000001;\n-              subscriberId_ = input.readBytes();\n+            case 8: {\n+              int rawValue = input.readEnum();\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent value = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent.valueOf(rawValue);\n+              if (value == null) {\n+                unknownFields.mergeVarintField(1, rawValue);\n+              } else {\n+                bitField0_ |= 0x00000001;\n+                event_ = value;\n+              }\n               break;\n             }\n           }\n@@ -9961,39 +10308,39 @@ public Builder mergeFrom(\n       \n       private int bitField0_;\n       \n-      // required bytes subscriberId = 2;\n-      private com.google.protobuf.ByteString subscriberId_ = com.google.protobuf.ByteString.EMPTY;\n-      public boolean hasSubscriberId() {\n+      // optional .Hedwig.SubscriptionEvent event = 1;\n+      private org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent event_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent.TOPIC_MOVED;\n+      public boolean hasEvent() {\n         return ((bitField0_ & 0x00000001) == 0x00000001);\n       }\n-      public com.google.protobuf.ByteString getSubscriberId() {\n-        return subscriberId_;\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent getEvent() {\n+        return event_;\n       }\n-      public Builder setSubscriberId(com.google.protobuf.ByteString value) {\n+      public Builder setEvent(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent value) {\n         if (value == null) {\n-    throw new NullPointerException();\n-  }\n-  bitField0_ |= 0x00000001;\n-        subscriberId_ = value;\n+          throw new NullPointerException();\n+        }\n+        bitField0_ |= 0x00000001;\n+        event_ = value;\n         onChanged();\n         return this;\n       }\n-      public Builder clearSubscriberId() {\n+      public Builder clearEvent() {\n         bitField0_ = (bitField0_ & ~0x00000001);\n-        subscriberId_ = getDefaultInstance().getSubscriberId();\n+        event_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent.TOPIC_MOVED;\n         onChanged();\n         return this;\n       }\n       \n-      // @@protoc_insertion_point(builder_scope:Hedwig.CloseSubscriptionRequest)\n+      // @@protoc_insertion_point(builder_scope:Hedwig.SubscriptionEventResponse)\n     }\n     \n     static {\n-      defaultInstance = new CloseSubscriptionRequest(true);\n+      defaultInstance = new SubscriptionEventResponse(true);\n       defaultInstance.initFields();\n     }\n     \n-    // @@protoc_insertion_point(class_scope:Hedwig.CloseSubscriptionRequest)\n+    // @@protoc_insertion_point(class_scope:Hedwig.SubscriptionEventResponse)\n   }\n   \n   public interface PubSubResponseOrBuilder\n@@ -11890,6 +12237,11 @@ public Builder clearPreferences() {\n     boolean hasSubscribeResponse();\n     org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse getSubscribeResponse();\n     org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponseOrBuilder getSubscribeResponseOrBuilder();\n+    \n+    // optional .Hedwig.SubscriptionEventResponse subscriptionEvent = 3;\n+    boolean hasSubscriptionEvent();\n+    org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse getSubscriptionEvent();\n+    org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder getSubscriptionEventOrBuilder();\n   }\n   public static final class ResponseBody extends\n       com.google.protobuf.GeneratedMessage\n@@ -11946,9 +12298,23 @@ public boolean hasSubscribeResponse() {\n       return subscribeResponse_;\n     }\n     \n+    // optional .Hedwig.SubscriptionEventResponse subscriptionEvent = 3;\n+    public static final int SUBSCRIPTIONEVENT_FIELD_NUMBER = 3;\n+    private org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse subscriptionEvent_;\n+    public boolean hasSubscriptionEvent() {\n+      return ((bitField0_ & 0x00000004) == 0x00000004);\n+    }\n+    public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse getSubscriptionEvent() {\n+      return subscriptionEvent_;\n+    }\n+    public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder getSubscriptionEventOrBuilder() {\n+      return subscriptionEvent_;\n+    }\n+    \n     private void initFields() {\n       publishResponse_ = org.apache.hedwig.protocol.PubSubProtocol.PublishResponse.getDefaultInstance();\n       subscribeResponse_ = org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse.getDefaultInstance();\n+      subscriptionEvent_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance();\n     }\n     private byte memoizedIsInitialized = -1;\n     public final boolean isInitialized() {\n@@ -11974,6 +12340,9 @@ public void writeTo(com.google.protobuf.CodedOutputStream output)\n       if (((bitField0_ & 0x00000002) == 0x00000002)) {\n         output.writeMessage(2, subscribeResponse_);\n       }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        output.writeMessage(3, subscriptionEvent_);\n+      }\n       getUnknownFields().writeTo(output);\n     }\n     \n@@ -11991,6 +12360,10 @@ public int getSerializedSize() {\n         size += com.google.protobuf.CodedOutputStream\n           .computeMessageSize(2, subscribeResponse_);\n       }\n+      if (((bitField0_ & 0x00000004) == 0x00000004)) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(3, subscriptionEvent_);\n+      }\n       size += getUnknownFields().getSerializedSize();\n       memoizedSerializedSize = size;\n       return size;\n@@ -12109,6 +12482,7 @@ private void maybeForceBuilderInitialization() {\n         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {\n           getPublishResponseFieldBuilder();\n           getSubscribeResponseFieldBuilder();\n+          getSubscriptionEventFieldBuilder();\n         }\n       }\n       private static Builder create() {\n@@ -12129,6 +12503,12 @@ public Builder clear() {\n           subscribeResponseBuilder_.clear();\n         }\n         bitField0_ = (bitField0_ & ~0x00000002);\n+        if (subscriptionEventBuilder_ == null) {\n+          subscriptionEvent_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance();\n+        } else {\n+          subscriptionEventBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000004);\n         return this;\n       }\n       \n@@ -12183,6 +12563,14 @@ public Builder clone() {\n         } else {\n           result.subscribeResponse_ = subscribeResponseBuilder_.build();\n         }\n+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {\n+          to_bitField0_ |= 0x00000004;\n+        }\n+        if (subscriptionEventBuilder_ == null) {\n+          result.subscriptionEvent_ = subscriptionEvent_;\n+        } else {\n+          result.subscriptionEvent_ = subscriptionEventBuilder_.build();\n+        }\n         result.bitField0_ = to_bitField0_;\n         onBuilt();\n         return result;\n@@ -12205,6 +12593,9 @@ public Builder mergeFrom(org.apache.hedwig.protocol.PubSubProtocol.ResponseBody\n         if (other.hasSubscribeResponse()) {\n           mergeSubscribeResponse(other.getSubscribeResponse());\n         }\n+        if (other.hasSubscriptionEvent()) {\n+          mergeSubscriptionEvent(other.getSubscriptionEvent());\n+        }\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n@@ -12260,6 +12651,15 @@ public Builder mergeFrom(\n               setSubscribeResponse(subBuilder.buildPartial());\n               break;\n             }\n+            case 26: {\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder subBuilder = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.newBuilder();\n+              if (hasSubscriptionEvent()) {\n+                subBuilder.mergeFrom(getSubscriptionEvent());\n+              }\n+              input.readMessage(subBuilder, extensionRegistry);\n+              setSubscriptionEvent(subBuilder.buildPartial());\n+              break;\n+            }\n           }\n         }\n       }\n@@ -12446,6 +12846,96 @@ public Builder clearSubscribeResponse() {\n         return subscribeResponseBuilder_;\n       }\n       \n+      // optional .Hedwig.SubscriptionEventResponse subscriptionEvent = 3;\n+      private org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse subscriptionEvent_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance();\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder> subscriptionEventBuilder_;\n+      public boolean hasSubscriptionEvent() {\n+        return ((bitField0_ & 0x00000004) == 0x00000004);\n+      }\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse getSubscriptionEvent() {\n+        if (subscriptionEventBuilder_ == null) {\n+          return subscriptionEvent_;\n+        } else {\n+          return subscriptionEventBuilder_.getMessage();\n+        }\n+      }\n+      public Builder setSubscriptionEvent(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse value) {\n+        if (subscriptionEventBuilder_ == null) {\n+          if (value == null) {\n+            throw new NullPointerException();\n+          }\n+          subscriptionEvent_ = value;\n+          onChanged();\n+        } else {\n+          subscriptionEventBuilder_.setMessage(value);\n+        }\n+        bitField0_ |= 0x00000004;\n+        return this;\n+      }\n+      public Builder setSubscriptionEvent(\n+          org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder builderForValue) {\n+        if (subscriptionEventBuilder_ == null) {\n+          subscriptionEvent_ = builderForValue.build();\n+          onChanged();\n+        } else {\n+          subscriptionEventBuilder_.setMessage(builderForValue.build());\n+        }\n+        bitField0_ |= 0x00000004;\n+        return this;\n+      }\n+      public Builder mergeSubscriptionEvent(org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse value) {\n+        if (subscriptionEventBuilder_ == null) {\n+          if (((bitField0_ & 0x00000004) == 0x00000004) &&\n+              subscriptionEvent_ != org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance()) {\n+            subscriptionEvent_ =\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.newBuilder(subscriptionEvent_).mergeFrom(value).buildPartial();\n+          } else {\n+            subscriptionEvent_ = value;\n+          }\n+          onChanged();\n+        } else {\n+          subscriptionEventBuilder_.mergeFrom(value);\n+        }\n+        bitField0_ |= 0x00000004;\n+        return this;\n+      }\n+      public Builder clearSubscriptionEvent() {\n+        if (subscriptionEventBuilder_ == null) {\n+          subscriptionEvent_ = org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.getDefaultInstance();\n+          onChanged();\n+        } else {\n+          subscriptionEventBuilder_.clear();\n+        }\n+        bitField0_ = (bitField0_ & ~0x00000004);\n+        return this;\n+      }\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder getSubscriptionEventBuilder() {\n+        bitField0_ |= 0x00000004;\n+        onChanged();\n+        return getSubscriptionEventFieldBuilder().getBuilder();\n+      }\n+      public org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder getSubscriptionEventOrBuilder() {\n+        if (subscriptionEventBuilder_ != null) {\n+          return subscriptionEventBuilder_.getMessageOrBuilder();\n+        } else {\n+          return subscriptionEvent_;\n+        }\n+      }\n+      private com.google.protobuf.SingleFieldBuilder<\n+          org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder> \n+          getSubscriptionEventFieldBuilder() {\n+        if (subscriptionEventBuilder_ == null) {\n+          subscriptionEventBuilder_ = new com.google.protobuf.SingleFieldBuilder<\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder, org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponseOrBuilder>(\n+                  subscriptionEvent_,\n+                  getParentForChildren(),\n+                  isClean());\n+          subscriptionEvent_ = null;\n+        }\n+        return subscriptionEventBuilder_;\n+      }\n+      \n       // @@protoc_insertion_point(builder_scope:Hedwig.ResponseBody)\n     }\n     \n@@ -15961,6 +16451,11 @@ public Builder clearNumTopics() {\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_Hedwig_UnsubscribeRequest_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_Hedwig_StopDeliveryRequest_descriptor;\n   private static\n@@ -15972,10 +16467,10 @@ public Builder clearNumTopics() {\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_Hedwig_StartDeliveryRequest_fieldAccessorTable;\n   private static com.google.protobuf.Descriptors.Descriptor\n-    internal_static_Hedwig_CloseSubscriptionRequest_descriptor;\n+    internal_static_Hedwig_SubscriptionEventResponse_descriptor;\n   private static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n-      internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable;\n+      internal_static_Hedwig_SubscriptionEventResponse_fieldAccessorTable;\n   private static com.google.protobuf.Descriptors.Descriptor\n     internal_static_Hedwig_PubSubResponse_descriptor;\n   private static\n@@ -16088,56 +16583,59 @@ public Builder clearNumTopics() {\n       \"(\\010:\\004true\\\"K\\n\\016ConsumeRequest\\022\\024\\n\\014subscriber\" +\n       \"Id\\030\\002 \\002(\\014\\022#\\n\\005msgId\\030\\003 \\002(\\0132\\024.Hedwig.Message\" +\n       \"SeqId\\\"*\\n\\022UnsubscribeRequest\\022\\024\\n\\014subscribe\" +\n-      \"rId\\030\\002 \\002(\\014\\\"+\\n\\023StopDeliveryRequest\\022\\024\\n\\014subs\" +\n-      \"criberId\\030\\002 \\002(\\014\\\",\\n\\024StartDeliveryRequest\\022\\024\",\n-      \"\\n\\014subscriberId\\030\\002 \\002(\\014\\\"0\\n\\030CloseSubscriptio\" +\n-      \"nRequest\\022\\024\\n\\014subscriberId\\030\\002 \\002(\\014\\\"\\377\\001\\n\\016PubSu\" +\n-      \"bResponse\\0220\\n\\017protocolVersion\\030\\001 \\002(\\0162\\027.Hed\" +\n-      \"wig.ProtocolVersion\\022&\\n\\nstatusCode\\030\\002 \\002(\\0162\" +\n-      \"\\022.Hedwig.StatusCode\\022\\r\\n\\005txnId\\030\\003 \\002(\\004\\022\\021\\n\\tst\" +\n-      \"atusMsg\\030\\004 \\001(\\t\\022 \\n\\007message\\030\\005 \\001(\\0132\\017.Hedwig.\" +\n-      \"Message\\022\\r\\n\\005topic\\030\\006 \\001(\\014\\022\\024\\n\\014subscriberId\\030\\007\" +\n-      \" \\001(\\014\\022*\\n\\014responseBody\\030\\010 \\001(\\0132\\024.Hedwig.Resp\" +\n-      \"onseBody\\\"?\\n\\017PublishResponse\\022,\\n\\016published\" +\n-      \"MsgId\\030\\001 \\002(\\0132\\024.Hedwig.MessageSeqId\\\"I\\n\\021Sub\",\n-      \"scribeResponse\\0224\\n\\013preferences\\030\\002 \\001(\\0132\\037.He\" +\n-      \"dwig.SubscriptionPreferences\\\"v\\n\\014Response\" +\n-      \"Body\\0220\\n\\017publishResponse\\030\\001 \\001(\\0132\\027.Hedwig.P\" +\n-      \"ublishResponse\\0224\\n\\021subscribeResponse\\030\\002 \\001(\" +\n-      \"\\0132\\031.Hedwig.SubscribeResponse\\\"N\\n\\021Subscrip\" +\n-      \"tionState\\022#\\n\\005msgId\\030\\001 \\002(\\0132\\024.Hedwig.Messag\" +\n-      \"eSeqId\\022\\024\\n\\014messageBound\\030\\002 \\001(\\r\\\"r\\n\\020Subscrip\" +\n-      \"tionData\\022(\\n\\005state\\030\\001 \\001(\\0132\\031.Hedwig.Subscri\" +\n-      \"ptionState\\0224\\n\\013preferences\\030\\002 \\001(\\0132\\037.Hedwig\" +\n-      \".SubscriptionPreferences\\\"k\\n\\013LedgerRange\\022\",\n-      \"\\020\\n\\010ledgerId\\030\\001 \\002(\\004\\022.\\n\\020endSeqIdIncluded\\030\\002 \" +\n-      \"\\001(\\0132\\024.Hedwig.MessageSeqId\\022\\032\\n\\022startSeqIdI\" +\n-      \"ncluded\\030\\003 \\001(\\004\\\"3\\n\\014LedgerRanges\\022#\\n\\006ranges\\030\" +\n-      \"\\001 \\003(\\0132\\023.Hedwig.LedgerRange\\\":\\n\\013ManagerMet\" +\n-      \"a\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016managerVersion\" +\n-      \"\\030\\003 \\002(\\r\\\".\\n\\013HubInfoData\\022\\020\\n\\010hostname\\030\\002 \\002(\\t\\022\" +\n-      \"\\r\\n\\005czxid\\030\\003 \\002(\\004\\\" \\n\\013HubLoadData\\022\\021\\n\\tnumTopi\" +\n-      \"cs\\030\\002 \\002(\\004*\\\"\\n\\017ProtocolVersion\\022\\017\\n\\013VERSION_O\" +\n-      \"NE\\020\\001*\\207\\001\\n\\rOperationType\\022\\013\\n\\007PUBLISH\\020\\000\\022\\r\\n\\tS\" +\n-      \"UBSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\\013UNSUBSCRIBE\\020\\003\",\n-      \"\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rSTOP_DELIVERY\\020\\005\\022\" +\n-      \"\\025\\n\\021CLOSESUBSCRIPTION\\020\\006*D\\n\\021SubscriptionEv\" +\n-      \"ent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032SUBSCRIPTION_FOR\" +\n-      \"CED_CLOSED\\020\\002*\\205\\004\\n\\nStatusCode\\022\\013\\n\\007SUCCESS\\020\\000\" +\n-      \"\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\\n\\rNO_SUCH_TOPI\" +\n-      \"C\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUBSCRIBED\\020\\223\\003\\022\\032\\n\\025\" +\n-      \"CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\\n\\021COULD_NOT_CO\" +\n-      \"NNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\\036\\n\\031NOT_RESPONS\" +\n-      \"IBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVICE_DOWN\\020\\366\\003\\022\\024\\n\\017\" +\n-      \"UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVALID_MESSAGE_FI\",\n-      \"LTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\\036\\n\\031NO_TOPIC_PE\" +\n-      \"RSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC_PERSISTENCE_I\" +\n-      \"NFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCRIPTION_STATE\\020\\213\" +\n-      \"\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EXISTS\\020\\214\\004\\022\\030\\n\\023NO_\" +\n-      \"TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOPIC_OWNER_INFO_\" +\n-      \"EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_CONDITION\\020\\330\\004\\022\\016\\n\\t\" +\n-      \"COMPOSITE\\020\\274\\005B\\036\\n\\032org.apache.hedwig.protoc\" +\n-      \"olH\\001\"\n+      \"rId\\030\\002 \\002(\\014\\\"0\\n\\030CloseSubscriptionRequest\\022\\024\\n\" +\n+      \"\\014subscriberId\\030\\002 \\002(\\014\\\"+\\n\\023StopDeliveryReque\",\n+      \"st\\022\\024\\n\\014subscriberId\\030\\002 \\002(\\014\\\",\\n\\024StartDeliver\" +\n+      \"yRequest\\022\\024\\n\\014subscriberId\\030\\002 \\002(\\014\\\"E\\n\\031Subscr\" +\n+      \"iptionEventResponse\\022(\\n\\005event\\030\\001 \\001(\\0162\\031.Hed\" +\n+      \"wig.SubscriptionEvent\\\"\\377\\001\\n\\016PubSubResponse\" +\n+      \"\\0220\\n\\017protocolVersion\\030\\001 \\002(\\0162\\027.Hedwig.Proto\" +\n+      \"colVersion\\022&\\n\\nstatusCode\\030\\002 \\002(\\0162\\022.Hedwig.\" +\n+      \"StatusCode\\022\\r\\n\\005txnId\\030\\003 \\002(\\004\\022\\021\\n\\tstatusMsg\\030\\004\" +\n+      \" \\001(\\t\\022 \\n\\007message\\030\\005 \\001(\\0132\\017.Hedwig.Message\\022\\r\" +\n+      \"\\n\\005topic\\030\\006 \\001(\\014\\022\\024\\n\\014subscriberId\\030\\007 \\001(\\014\\022*\\n\\014r\" +\n+      \"esponseBody\\030\\010 \\001(\\0132\\024.Hedwig.ResponseBody\\\"\",\n+      \"?\\n\\017PublishResponse\\022,\\n\\016publishedMsgId\\030\\001 \\002\" +\n+      \"(\\0132\\024.Hedwig.MessageSeqId\\\"I\\n\\021SubscribeRes\" +\n+      \"ponse\\0224\\n\\013preferences\\030\\002 \\001(\\0132\\037.Hedwig.Subs\" +\n+      \"criptionPreferences\\\"\\264\\001\\n\\014ResponseBody\\0220\\n\\017\" +\n+      \"publishResponse\\030\\001 \\001(\\0132\\027.Hedwig.PublishRe\" +\n+      \"sponse\\0224\\n\\021subscribeResponse\\030\\002 \\001(\\0132\\031.Hedw\" +\n+      \"ig.SubscribeResponse\\022<\\n\\021subscriptionEven\" +\n+      \"t\\030\\003 \\001(\\0132!.Hedwig.SubscriptionEventRespon\" +\n+      \"se\\\"N\\n\\021SubscriptionState\\022#\\n\\005msgId\\030\\001 \\002(\\0132\\024\" +\n+      \".Hedwig.MessageSeqId\\022\\024\\n\\014messageBound\\030\\002 \\001\",\n+      \"(\\r\\\"r\\n\\020SubscriptionData\\022(\\n\\005state\\030\\001 \\001(\\0132\\031.\" +\n+      \"Hedwig.SubscriptionState\\0224\\n\\013preferences\\030\" +\n+      \"\\002 \\001(\\0132\\037.Hedwig.SubscriptionPreferences\\\"k\" +\n+      \"\\n\\013LedgerRange\\022\\020\\n\\010ledgerId\\030\\001 \\002(\\004\\022.\\n\\020endSe\" +\n+      \"qIdIncluded\\030\\002 \\001(\\0132\\024.Hedwig.MessageSeqId\\022\" +\n+      \"\\032\\n\\022startSeqIdIncluded\\030\\003 \\001(\\004\\\"3\\n\\014LedgerRan\" +\n+      \"ges\\022#\\n\\006ranges\\030\\001 \\003(\\0132\\023.Hedwig.LedgerRange\" +\n+      \"\\\":\\n\\013ManagerMeta\\022\\023\\n\\013managerImpl\\030\\002 \\002(\\t\\022\\026\\n\\016\" +\n+      \"managerVersion\\030\\003 \\002(\\r\\\".\\n\\013HubInfoData\\022\\020\\n\\010h\" +\n+      \"ostname\\030\\002 \\002(\\t\\022\\r\\n\\005czxid\\030\\003 \\002(\\004\\\" \\n\\013HubLoadD\",\n+      \"ata\\022\\021\\n\\tnumTopics\\030\\002 \\002(\\004*\\\"\\n\\017ProtocolVersio\" +\n+      \"n\\022\\017\\n\\013VERSION_ONE\\020\\001*\\207\\001\\n\\rOperationType\\022\\013\\n\\007\" +\n+      \"PUBLISH\\020\\000\\022\\r\\n\\tSUBSCRIBE\\020\\001\\022\\013\\n\\007CONSUME\\020\\002\\022\\017\\n\" +\n+      \"\\013UNSUBSCRIBE\\020\\003\\022\\022\\n\\016START_DELIVERY\\020\\004\\022\\021\\n\\rST\" +\n+      \"OP_DELIVERY\\020\\005\\022\\025\\n\\021CLOSESUBSCRIPTION\\020\\006*D\\n\\021\" +\n+      \"SubscriptionEvent\\022\\017\\n\\013TOPIC_MOVED\\020\\001\\022\\036\\n\\032SU\" +\n+      \"BSCRIPTION_FORCED_CLOSED\\020\\002*\\205\\004\\n\\nStatusCod\" +\n+      \"e\\022\\013\\n\\007SUCCESS\\020\\000\\022\\026\\n\\021MALFORMED_REQUEST\\020\\221\\003\\022\\022\" +\n+      \"\\n\\rNO_SUCH_TOPIC\\020\\222\\003\\022\\036\\n\\031CLIENT_ALREADY_SUB\" +\n+      \"SCRIBED\\020\\223\\003\\022\\032\\n\\025CLIENT_NOT_SUBSCRIBED\\020\\224\\003\\022\\026\",\n+      \"\\n\\021COULD_NOT_CONNECT\\020\\225\\003\\022\\017\\n\\nTOPIC_BUSY\\020\\226\\003\\022\" +\n+      \"\\036\\n\\031NOT_RESPONSIBLE_FOR_TOPIC\\020\\365\\003\\022\\021\\n\\014SERVI\" +\n+      \"CE_DOWN\\020\\366\\003\\022\\024\\n\\017UNCERTAIN_STATE\\020\\367\\003\\022\\033\\n\\026INVA\" +\n+      \"LID_MESSAGE_FILTER\\020\\370\\003\\022\\020\\n\\013BAD_VERSION\\020\\210\\004\\022\" +\n+      \"\\036\\n\\031NO_TOPIC_PERSISTENCE_INFO\\020\\211\\004\\022\\\"\\n\\035TOPIC\" +\n+      \"_PERSISTENCE_INFO_EXISTS\\020\\212\\004\\022\\032\\n\\025NO_SUBSCR\" +\n+      \"IPTION_STATE\\020\\213\\004\\022\\036\\n\\031SUBSCRIPTION_STATE_EX\" +\n+      \"ISTS\\020\\214\\004\\022\\030\\n\\023NO_TOPIC_OWNER_INFO\\020\\215\\004\\022\\034\\n\\027TOP\" +\n+      \"IC_OWNER_INFO_EXISTS\\020\\216\\004\\022\\031\\n\\024UNEXPECTED_CO\" +\n+      \"NDITION\\020\\330\\004\\022\\016\\n\\tCOMPOSITE\\020\\274\\005B\\036\\n\\032org.apache\",\n+      \".hedwig.protocolH\\001\"\n     };\n     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n@@ -16248,112 +16746,120 @@ public Builder clearNumTopics() {\n               new java.lang.String[] { \"SubscriberId\", },\n               org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest.class,\n               org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest.Builder.class);\n-          internal_static_Hedwig_StopDeliveryRequest_descriptor =\n+          internal_static_Hedwig_CloseSubscriptionRequest_descriptor =\n             getDescriptor().getMessageTypes().get(12);\n+          internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_Hedwig_CloseSubscriptionRequest_descriptor,\n+              new java.lang.String[] { \"SubscriberId\", },\n+              org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.class,\n+              org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.Builder.class);\n+          internal_static_Hedwig_StopDeliveryRequest_descriptor =\n+            getDescriptor().getMessageTypes().get(13);\n           internal_static_Hedwig_StopDeliveryRequest_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_StopDeliveryRequest_descriptor,\n               new java.lang.String[] { \"SubscriberId\", },\n               org.apache.hedwig.protocol.PubSubProtocol.StopDeliveryRequest.class,\n               org.apache.hedwig.protocol.PubSubProtocol.StopDeliveryRequest.Builder.class);\n           internal_static_Hedwig_StartDeliveryRequest_descriptor =\n-            getDescriptor().getMessageTypes().get(13);\n+            getDescriptor().getMessageTypes().get(14);\n           internal_static_Hedwig_StartDeliveryRequest_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_StartDeliveryRequest_descriptor,\n               new java.lang.String[] { \"SubscriberId\", },\n               org.apache.hedwig.protocol.PubSubProtocol.StartDeliveryRequest.class,\n               org.apache.hedwig.protocol.PubSubProtocol.StartDeliveryRequest.Builder.class);\n-          internal_static_Hedwig_CloseSubscriptionRequest_descriptor =\n-            getDescriptor().getMessageTypes().get(14);\n-          internal_static_Hedwig_CloseSubscriptionRequest_fieldAccessorTable = new\n+          internal_static_Hedwig_SubscriptionEventResponse_descriptor =\n+            getDescriptor().getMessageTypes().get(15);\n+          internal_static_Hedwig_SubscriptionEventResponse_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n-              internal_static_Hedwig_CloseSubscriptionRequest_descriptor,\n-              new java.lang.String[] { \"SubscriberId\", },\n-              org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.class,\n-              org.apache.hedwig.protocol.PubSubProtocol.CloseSubscriptionRequest.Builder.class);\n+              internal_static_Hedwig_SubscriptionEventResponse_descriptor,\n+              new java.lang.String[] { \"Event\", },\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.class,\n+              org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse.Builder.class);\n           internal_static_Hedwig_PubSubResponse_descriptor =\n-            getDescriptor().getMessageTypes().get(15);\n+            getDescriptor().getMessageTypes().get(16);\n           internal_static_Hedwig_PubSubResponse_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_PubSubResponse_descriptor,\n               new java.lang.String[] { \"ProtocolVersion\", \"StatusCode\", \"TxnId\", \"StatusMsg\", \"Message\", \"Topic\", \"SubscriberId\", \"ResponseBody\", },\n               org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse.class,\n               org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse.Builder.class);\n           internal_static_Hedwig_PublishResponse_descriptor =\n-            getDescriptor().getMessageTypes().get(16);\n+            getDescriptor().getMessageTypes().get(17);\n           internal_static_Hedwig_PublishResponse_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_PublishResponse_descriptor,\n               new java.lang.String[] { \"PublishedMsgId\", },\n               org.apache.hedwig.protocol.PubSubProtocol.PublishResponse.class,\n               org.apache.hedwig.protocol.PubSubProtocol.PublishResponse.Builder.class);\n           internal_static_Hedwig_SubscribeResponse_descriptor =\n-            getDescriptor().getMessageTypes().get(17);\n+            getDescriptor().getMessageTypes().get(18);\n           internal_static_Hedwig_SubscribeResponse_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_SubscribeResponse_descriptor,\n               new java.lang.String[] { \"Preferences\", },\n               org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse.class,\n               org.apache.hedwig.protocol.PubSubProtocol.SubscribeResponse.Builder.class);\n           internal_static_Hedwig_ResponseBody_descriptor =\n-            getDescriptor().getMessageTypes().get(18);\n+            getDescriptor().getMessageTypes().get(19);\n           internal_static_Hedwig_ResponseBody_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_ResponseBody_descriptor,\n-              new java.lang.String[] { \"PublishResponse\", \"SubscribeResponse\", },\n+              new java.lang.String[] { \"PublishResponse\", \"SubscribeResponse\", \"SubscriptionEvent\", },\n               org.apache.hedwig.protocol.PubSubProtocol.ResponseBody.class,\n               org.apache.hedwig.protocol.PubSubProtocol.ResponseBody.Builder.class);\n           internal_static_Hedwig_SubscriptionState_descriptor =\n-            getDescriptor().getMessageTypes().get(19);\n+            getDescriptor().getMessageTypes().get(20);\n           internal_static_Hedwig_SubscriptionState_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_SubscriptionState_descriptor,\n               new java.lang.String[] { \"MsgId\", \"MessageBound\", },\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState.class,\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionState.Builder.class);\n           internal_static_Hedwig_SubscriptionData_descriptor =\n-            getDescriptor().getMessageTypes().get(20);\n+            getDescriptor().getMessageTypes().get(21);\n           internal_static_Hedwig_SubscriptionData_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_SubscriptionData_descriptor,\n               new java.lang.String[] { \"State\", \"Preferences\", },\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData.class,\n               org.apache.hedwig.protocol.PubSubProtocol.SubscriptionData.Builder.class);\n           internal_static_Hedwig_LedgerRange_descriptor =\n-            getDescriptor().getMessageTypes().get(21);\n+            getDescriptor().getMessageTypes().get(22);\n           internal_static_Hedwig_LedgerRange_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_LedgerRange_descriptor,\n               new java.lang.String[] { \"LedgerId\", \"EndSeqIdIncluded\", \"StartSeqIdIncluded\", },\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRange.class,\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRange.Builder.class);\n           internal_static_Hedwig_LedgerRanges_descriptor =\n-            getDescriptor().getMessageTypes().get(22);\n+            getDescriptor().getMessageTypes().get(23);\n           internal_static_Hedwig_LedgerRanges_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_LedgerRanges_descriptor,\n               new java.lang.String[] { \"Ranges\", },\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges.class,\n               org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges.Builder.class);\n           internal_static_Hedwig_ManagerMeta_descriptor =\n-            getDescriptor().getMessageTypes().get(23);\n+            getDescriptor().getMessageTypes().get(24);\n           internal_static_Hedwig_ManagerMeta_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_ManagerMeta_descriptor,\n               new java.lang.String[] { \"ManagerImpl\", \"ManagerVersion\", },\n               org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.class,\n               org.apache.hedwig.protocol.PubSubProtocol.ManagerMeta.Builder.class);\n           internal_static_Hedwig_HubInfoData_descriptor =\n-            getDescriptor().getMessageTypes().get(24);\n+            getDescriptor().getMessageTypes().get(25);\n           internal_static_Hedwig_HubInfoData_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_HubInfoData_descriptor,\n               new java.lang.String[] { \"Hostname\", \"Czxid\", },\n               org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.class,\n               org.apache.hedwig.protocol.PubSubProtocol.HubInfoData.Builder.class);\n           internal_static_Hedwig_HubLoadData_descriptor =\n-            getDescriptor().getMessageTypes().get(25);\n+            getDescriptor().getMessageTypes().get(26);\n           internal_static_Hedwig_HubLoadData_fieldAccessorTable = new\n             com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n               internal_static_Hedwig_HubLoadData_descriptor,"},{"sha":"5a9cdf78f10ab893e547c206b555855d121e2e6c","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,11 +17,15 @@\n  */\n package org.apache.hedwig.protoextensions;\n \n+import com.google.protobuf.ByteString;\n+\n import org.apache.hedwig.exceptions.PubSubException;\n import org.apache.hedwig.protocol.PubSubProtocol.ProtocolVersion;\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEventResponse;\n \n public class PubSubResponseUtils {\n \n@@ -47,4 +51,18 @@ public static PubSubResponse getResponseForException(PubSubException e, long txn\n         return getBasicBuilder(e.getCode()).setStatusMsg(e.getMessage()).setTxnId(txnId).build();\n     }\n \n+    public static PubSubResponse getResponseForSubscriptionEvent(ByteString topic,\n+                                                                 ByteString subscriberId,\n+                                                                 SubscriptionEvent event) {\n+        SubscriptionEventResponse.Builder eventBuilder =\n+            SubscriptionEventResponse.newBuilder().setEvent(event);\n+        ResponseBody.Builder respBuilder =\n+            ResponseBody.newBuilder().setSubscriptionEvent(eventBuilder);\n+        PubSubResponse response = PubSubResponse.newBuilder()\n+                                  .setProtocolVersion(ProtocolVersion.VERSION_ONE)\n+                                  .setStatusCode(StatusCode.SUCCESS).setTxnId(0)\n+                                  .setTopic(topic).setSubscriberId(subscriberId)\n+                                  .setResponseBody(respBuilder).build();\n+        return response;\n+    }\n }"},{"sha":"289da06a2cf6d7b1133820aee75347ecf1921ba7","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -178,6 +178,9 @@ message UnsubscribeRequest{\n     required bytes subscriberId = 2;\n }\n \n+message CloseSubscriptionRequest {\n+    required bytes subscriberId = 2;\n+}\n \n message StopDeliveryRequest{\n     required bytes subscriberId = 2;\n@@ -195,16 +198,16 @@ enum SubscriptionEvent {\n     SUBSCRIPTION_FORCED_CLOSED = 2;\n }\n \n-message CloseSubscriptionRequest {\n-    required bytes subscriberId = 2;\n+// a response carries an event for a subscription sent to client\n+message SubscriptionEventResponse {\n+    optional SubscriptionEvent event = 1;\n }\n \n message PubSubResponse{\n     required ProtocolVersion protocolVersion = 1;\n     required StatusCode statusCode = 2;\n     required uint64 txnId = 3;\n-    \n-    \n+\n     optional string statusMsg = 4;\n     //in case of a status code of NOT_RESPONSIBLE_FOR_TOPIC, the status\n     //message will contain the name of the host actually responsible \n@@ -231,6 +234,7 @@ message SubscribeResponse {\n message ResponseBody {\n     optional PublishResponse publishResponse = 1;\n     optional SubscribeResponse subscribeResponse = 2;\n+    optional SubscriptionEventResponse subscriptionEvent = 3;\n }\n \n "},{"sha":"0fac986bdae6e78138cc7b803c3ad24b0b9d23ff","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":25,"deletions":5,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -46,6 +46,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.StatusCode;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionPreferences;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.common.UnexpectedError;\n import org.apache.hedwig.server.netty.ServerStats;\n@@ -411,9 +412,25 @@ public void setNotConnected(SubscriptionEvent event) {\n             if (null != event &&\n                 (SubscriptionEvent.TOPIC_MOVED == event ||\n                  SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED == event)) {\n-                // for we need to close the underlying when topic moved\n-                // or subscription forced closed.\n-                deliveryEndPoint.close();\n+                // we should not close the channel now after enabling multiplexing\n+                PubSubResponse response = PubSubResponseUtils.getResponseForSubscriptionEvent(\n+                    topic, subscriberId, event\n+                );\n+                deliveryEndPoint.send(response, new DeliveryCallback() {\n+                    @Override\n+                    public void sendingFinished() {\n+                        // do nothing now\n+                    }\n+                    @Override\n+                    public void transientErrorOnSend() {\n+                        // do nothing now\n+                    }\n+                    @Override\n+                    public void permanentErrorOnSend() {\n+                        // if channel is broken, close the channel\n+                        deliveryEndPoint.close();\n+                    }\n+                });\n             }\n             // uninitialize filter\n             this.filter.uninitialize();\n@@ -527,8 +544,11 @@ public void messageScanned(Object ctx, Message message) {\n              * The method below will invoke our sendingFinished() method when\n              * done\n              */\n-            PubSubResponse response = PubSubResponse.newBuilder().setProtocolVersion(ProtocolVersion.VERSION_ONE)\n-                                      .setStatusCode(StatusCode.SUCCESS).setTxnId(0).setMessage(message).build();\n+            PubSubResponse response = PubSubResponse.newBuilder()\n+                                      .setProtocolVersion(ProtocolVersion.VERSION_ONE)\n+                                      .setStatusCode(StatusCode.SUCCESS).setTxnId(0)\n+                                      .setMessage(message).setTopic(topic)\n+                                      .setSubscriberId(subscriberId).build();\n \n             deliveryEndPoint.send(response, //\n                                   // callback ="},{"sha":"2fb6822900981dae25698149f81765e99d35cdef","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -156,8 +156,9 @@ public void operationFinished(Object ctx, SubscriptionData subData) {\n                     logger.error(errMsg, re);\n                     PubSubException pse = new PubSubException.InvalidMessageFilterException(errMsg, re);\n                     subStats.incrementFailedOps();\n-                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()))\n-                    .addListener(ChannelFutureListener.CLOSE);\n+                    // we should not close the subscription channel, just response error\n+                    // client decide to close it or not.\n+                    channel.write(PubSubResponseUtils.getResponseForException(pse, request.getTxnId()));\n                     return;\n                 } catch (Throwable t) {\n                     String errMsg = \"Failed to instantiate message filter for (topic:\" + topic.toStringUtf8()"},{"sha":"53edf4576d61550d2b3e3f21b275db20182f24b8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","status":"modified","additions":58,"deletions":19,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscriptionChannelManager.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.hedwig.server.handlers;\n \n+import java.util.HashSet;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n \n import org.slf4j.Logger;\n@@ -26,41 +28,53 @@\n import org.jboss.netty.channel.ChannelFutureListener;\n \n import org.apache.hedwig.client.data.TopicSubscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubResponse;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionEvent;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n import org.apache.hedwig.util.Callback;\n import static org.apache.hedwig.util.VarArgs.va;\n \n public class SubscriptionChannelManager implements ChannelDisconnectListener {\n \n     static Logger logger = LoggerFactory.getLogger(SubscriptionChannelManager.class);\n \n-    private static ChannelFutureListener CLOSE_OLD_CHANNEL_LISTENER =\n-    new ChannelFutureListener() {\n+    static class CloseSubscriptionListener implements ChannelFutureListener {\n+\n+        final TopicSubscriber ts;\n+\n+        CloseSubscriptionListener(TopicSubscriber topicSubscriber) {\n+            this.ts = topicSubscriber;\n+        }\n+\n         @Override\n         public void operationComplete(ChannelFuture future) throws Exception {\n             if (!future.isSuccess()) {\n-                logger.warn(\"Failed to close old subscription channel.\");\n+                logger.warn(\"Failed to write response to close old subscription {}.\", ts);\n             } else {\n-                logger.debug(\"Close old subscription channel succeed.\");\n+                logger.debug(\"Close old subscription {} succeed.\", ts);\n             }\n         }\n     };\n \n     final ConcurrentHashMap<TopicSubscriber, Channel> sub2Channel;\n-    final ConcurrentHashMap<Channel, TopicSubscriber> channel2sub;\n+    final ConcurrentHashMap<Channel, Set<TopicSubscriber>> channel2sub;\n \n     public SubscriptionChannelManager() {\n         sub2Channel = new ConcurrentHashMap<TopicSubscriber, Channel>();\n-        channel2sub = new ConcurrentHashMap<Channel, TopicSubscriber>();\n+        channel2sub = new ConcurrentHashMap<Channel, Set<TopicSubscriber>>();\n     }\n \n     @Override\n     public void channelDisconnected(Channel channel) {\n         // Evils of synchronized programming: there is a race between a channel\n         // getting disconnected, and us adding it to the maps when a subscribe\n         // succeeds\n+        Set<TopicSubscriber> topicSubs;\n         synchronized (channel) {\n-            TopicSubscriber topicSub = channel2sub.remove(channel);\n-            if (topicSub != null) {\n+            topicSubs = channel2sub.remove(channel);\n+        }\n+        if (topicSubs != null) {\n+            for (TopicSubscriber topicSub : topicSubs) {\n                 logger.info(\"Subscription channel {} for {} is disconnected.\",\n                             va(channel.getRemoteAddress(), topicSub));\n                 // remove entry only currently mapped to given value.\n@@ -93,15 +107,30 @@ public Channel put(TopicSubscriber topicSub, Channel channel, boolean forceAttac\n         // to the 2 maps\n         synchronized (channel) {\n             Channel oldChannel = sub2Channel.putIfAbsent(topicSub, channel);\n-            if (null != oldChannel) {\n+            // if a subscribe request send from same channel,\n+            // we treated it a success action.\n+            if (null != oldChannel && !oldChannel.equals(channel)) {\n                 boolean subSuccess = false;\n                 if (forceAttach) {\n-                    // it is safe to close old channel here since new channel will be put\n-                    // in sub2Channel / channel2Sub so there is no race between channel\n-                    // getting disconnected and it.\n-                    ChannelFuture future = oldChannel.close();\n-                    future.addListener(CLOSE_OLD_CHANNEL_LISTENER);\n-                    logger.info(\"Subscribe request for ({}) from channel ({}) kills old channel ({}).\",\n+                    // it is safe to close old subscription here since the new subscription\n+                    // has come from other channel succeed.\n+                    synchronized (oldChannel) {\n+                        Set<TopicSubscriber> oldTopicSubs = channel2sub.get(oldChannel);\n+                        if (null != oldTopicSubs) {\n+                            if (!oldTopicSubs.remove(topicSub)) {\n+                                logger.warn(\"Failed to remove old subscription ({}) due to it isn't on channel ({}).\",\n+                                            va(topicSub, oldChannel));\n+                            } else if (oldTopicSubs.isEmpty()) {\n+                                channel2sub.remove(oldChannel);\n+                            }\n+                        }\n+                    }\n+                    PubSubResponse resp = PubSubResponseUtils.getResponseForSubscriptionEvent(\n+                        topicSub.getTopic(), topicSub.getSubscriberId(),\n+                        SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED\n+                    );\n+                    oldChannel.write(resp).addListener(new CloseSubscriptionListener(topicSub));\n+                    logger.info(\"Subscribe request for ({}) from channel ({}) closes old subscripiton on channel ({}).\",\n                                 va(topicSub, channel, oldChannel));\n                     // try replace the oldChannel\n                     // if replace failure, it migth caused because channelDisconnect callback\n@@ -125,7 +154,12 @@ public Channel put(TopicSubscriber topicSub, Channel channel, boolean forceAttac\n             }\n             // channel2sub is just a cache, so we can add to it\n             // without synchronization\n-            channel2sub.put(channel, topicSub);\n+            Set<TopicSubscriber> topicSubs = channel2sub.get(channel);\n+            if (null == topicSubs) {\n+                topicSubs = new HashSet<TopicSubscriber>();\n+                channel2sub.put(channel, topicSubs); \n+            }\n+            topicSubs.add(topicSub);\n             return null;\n         }\n     }\n@@ -140,9 +174,14 @@ public Channel put(TopicSubscriber topicSub, Channel channel, boolean forceAttac\n      */\n     public void remove(TopicSubscriber topicSub, Channel channel) {\n         synchronized (channel) {\n-            if (!channel2sub.remove(channel, topicSub)) {\n-                logger.warn(\"Failed to remove subscription ({}) due to it isn't on channel ({}).\",\n-                            va(topicSub, channel));\n+            Set<TopicSubscriber> topicSubs = channel2sub.get(channel);\n+            if (null != topicSubs) {\n+                if (!topicSubs.remove(topicSub)) {\n+                    logger.warn(\"Failed to remove subscription ({}) due to it isn't on channel ({}).\",\n+                                va(topicSub, channel));\n+                } else if (topicSubs.isEmpty()) {\n+                    channel2sub.remove(channel);\n+                }\n             }\n             if (!sub2Channel.remove(topicSub, channel)) {\n                 logger.warn(\"Failed to remove channel ({}) due to it isn't ({})'s channel.\","},{"sha":"10f08890bb7a25d264aa1265169cd2688ca8192b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ChannelTracker.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -88,7 +88,15 @@ public synchronized void subscribeSucceeded(TopicSubscriber topicSubscriber, Cha\n \n     }\n \n-    public synchronized void aboutToUnsubscribe(ByteString topic, ByteString subscriberId) {\n+    public void aboutToCloseSubscription(ByteString topic, ByteString subscriberId) {\n+        removeSubscriber(topic, subscriberId);\n+    } \n+\n+    public void aboutToUnsubscribe(ByteString topic, ByteString subscriberId) {\n+        removeSubscriber(topic, subscriberId);\n+    }\n+\n+    private synchronized void removeSubscriber(ByteString topic, ByteString subscriberId) {\n         TopicSubscriber topicSub = new TopicSubscriber(topic, subscriberId);\n \n         Channel channel = topicSub2Channel.remove(topicSub);"},{"sha":"f6e7f85d4237ae28894770761426884b65fbda56","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -106,7 +106,8 @@ protected void initializeHandlers() {\n         handlers.put(OperationType.CONSUME, new ProxyConsumeHandler(client.getSubscriber()));\n         handlers.put(OperationType.STOP_DELIVERY, new ProxyStopDeliveryHandler(client.getSubscriber(), tracker));\n         handlers.put(OperationType.START_DELIVERY, new ProxyStartDeliveryHandler(client.getSubscriber(), tracker));\n-\n+        handlers.put(OperationType.CLOSESUBSCRIPTION,\n+                     new ProxyCloseSubscriptionHandler(client.getSubscriber(), tracker));\n     }\n \n     protected void initializeNetty() {"},{"sha":"c1ef43538d09d3dc93d093312d104aebd156e2ca","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyCloseSubscriptionHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,70 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.proxy;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.channel.Channel;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.exceptions.PubSubException;\n+import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n+import org.apache.hedwig.protoextensions.PubSubResponseUtils;\n+import org.apache.hedwig.server.handlers.Handler;\n+import org.apache.hedwig.server.netty.UmbrellaHandler;\n+import org.apache.hedwig.util.Callback;\n+\n+public class ProxyCloseSubscriptionHandler implements Handler {\n+\n+    static final Logger logger = LoggerFactory.getLogger(ProxyCloseSubscriptionHandler.class);\n+\n+    Subscriber subscriber;\n+    ChannelTracker tracker;\n+\n+    public ProxyCloseSubscriptionHandler(Subscriber subscriber, ChannelTracker tracker) {\n+        this.subscriber = subscriber;\n+        this.tracker = tracker;\n+    }\n+\n+    @Override\n+    public void handleRequest(final PubSubRequest request, final Channel channel) {\n+\n+        if (!request.hasCloseSubscriptionRequest()) {\n+            UmbrellaHandler.sendErrorResponseToMalformedRequest(channel, request.getTxnId(),\n+                    \"Missing close subscription request data\");\n+            return;\n+        }\n+\n+        final ByteString topic = request.getTopic();\n+        final ByteString subscriberId = request.getCloseSubscriptionRequest().getSubscriberId();\n+\n+        subscriber.asyncCloseSubscription(topic, subscriberId, new Callback<Void>() {\n+            @Override\n+            public void operationFailed(Object ctx, PubSubException exception) {\n+                channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId()));\n+            }\n+\n+            @Override\n+            public void operationFinished(Object ctx, Void result) {\n+                tracker.aboutToCloseSubscription(topic, subscriberId);         \n+                channel.write(PubSubResponseUtils.getSuccessResponse(request.getTxnId()));\n+            }\n+        }, null);\n+    }\n+}"},{"sha":"6cc6a1783cadc9ffebdd384e680f4073bc91357a","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","status":"modified","additions":24,"deletions":2,"changes":26,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/TestPubSubClient.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.hedwig.client;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n@@ -27,6 +29,9 @@\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n \n import com.google.protobuf.ByteString;\n import org.apache.hedwig.client.api.MessageHandler;\n@@ -47,6 +52,7 @@\n import org.apache.hedwig.util.ConcurrencyUtils;\n import org.apache.hedwig.util.SubscriptionListener;\n \n+@RunWith(Parameterized.class)\n public class TestPubSubClient extends PubSubServerStandAloneTestBase {\n \n     private static final int RETENTION_SECS_VALUE = 10;\n@@ -150,11 +156,27 @@ public void run() {\n         }\n     }\n \n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { { true }, { false } });\n+    }\n+\n+    protected boolean isMultiplexingEnabled;\n+\n+    public TestPubSubClient(boolean isMultiplexingEnabled) {\n+        this.isMultiplexingEnabled = isMultiplexingEnabled;\n+    }\n+\n     @Override\n     @Before\n     public void setUp() throws Exception {\n         super.setUp();\n-        client = new HedwigClient(new ClientConfiguration());\n+        client = new HedwigClient(new ClientConfiguration() {\n+            @Override\n+            public boolean isMultiplexingEnabled() {\n+                return TestPubSubClient.this.isMultiplexingEnabled;\n+            }\n+        });\n         publisher = client.getPublisher();\n         subscriber = client.getSubscriber();\n     }\n@@ -509,7 +531,7 @@ public void testSyncSubscribeForceAttach() throws Exception {\n         SynchronousQueue<Boolean> consumeQueue2 = new SynchronousQueue<Boolean>();\n         subscriber2.startDelivery(topic, subscriberId, new TestMessageHandler(consumeQueue2));\n \n-        assertEquals(SubscriptionEvent.TOPIC_MOVED, eventQueue.take());\n+        assertEquals(SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED, eventQueue.take());\n         assertTrue(eventQueue2.isEmpty());\n \n         // Now publish some messages for the topic to be consumed by the"},{"sha":"bf74df1ee5fc156b7545462946359a1a993669e6","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestCloseSubscription.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/bookkeeper/blob/0658723fdbcfeceddc983b770d78b01602a64f06/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestCloseSubscription.java","raw_url":"https://github.com/apache/bookkeeper/raw/0658723fdbcfeceddc983b770d78b01602a64f06/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestCloseSubscription.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestCloseSubscription.java?ref=0658723fdbcfeceddc983b770d78b01602a64f06","patch":"@@ -1,153 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hedwig.client.netty;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import static org.junit.Assert.*;\n-\n-import com.google.protobuf.ByteString;\n-\n-import org.apache.hedwig.client.api.MessageHandler;\n-import org.apache.hedwig.client.api.Publisher;\n-import org.apache.hedwig.client.api.Subscriber;\n-import org.apache.hedwig.client.conf.ClientConfiguration;\n-import org.apache.hedwig.client.data.PubSubData;\n-import org.apache.hedwig.exceptions.PubSubException;\n-import org.apache.hedwig.protocol.PubSubProtocol.Message;\n-import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.ResponseBody;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n-import org.apache.hedwig.server.HedwigHubTestBase;\n-import org.apache.hedwig.util.Callback;\n-\n-/**\n- * TODO: it is a temp test for close subscription request. after\n- * multiplexing channel manager is implemented, remove this test.\n- */\n-public class TestCloseSubscription extends HedwigHubTestBase {\n-\n-    @Override\n-    @Before\n-    public void setUp() throws Exception {\n-        numServers = 1;\n-        super.setUp();\n-    }\n-\n-    @Test\n-    public void testCloseSubscriptionRequest() throws Exception {\n-        HedwigClientImpl client = new HedwigClientImpl(new ClientConfiguration());\n-        Publisher pub = client.getPublisher();\n-        Subscriber sub = client.getSubscriber();\n-\n-        ByteString topic = ByteString.copyFromUtf8(\"testCloseSubscriptionRequest\"); \n-        ByteString subid = ByteString.copyFromUtf8(\"mysubid\");\n-        sub.subscribe(topic, subid, CreateOrAttach.CREATE);\n-\n-        final int X = 20;\n-        final AtomicInteger expected = new AtomicInteger(1);\n-        final CountDownLatch firstLatch = new CountDownLatch(1);\n-        final CountDownLatch secondLatch = new CountDownLatch(1);\n-        sub.startDelivery(topic, subid, new MessageHandler() {\n-            @Override\n-            public synchronized void deliver(ByteString topic, ByteString subscriberId,\n-                                             Message msg,\n-                                             Callback<Void> callback, Object context) {\n-                try {\n-                    int value = Integer.valueOf(msg.getBody().toStringUtf8());\n-                    logger.debug(\"Received message {},\", value);\n-\n-                    if (value == expected.get()) {\n-                        expected.incrementAndGet();\n-                    } else {\n-                        // error condition\n-                        logger.error(\"Did not receive expected value, expected {}, got {}\",\n-                                     expected.get(), value);\n-                        expected.set(0);\n-                        firstLatch.countDown();\n-                        secondLatch.countDown();\n-                    }\n-                    if (expected.get() == X+1) {\n-                        firstLatch.countDown();\n-                    }\n-                    if (expected.get() > X+1) {\n-                        secondLatch.countDown();\n-                    }\n-                    callback.operationFinished(context, null);\n-                } catch (Exception e) {\n-                    logger.error(\"Received bad message\", e);\n-                    firstLatch.countDown();\n-                    secondLatch.countDown();\n-                }\n-            }\n-        });\n-\n-        // first publish \n-        for (int i=1; i<=X; i++) {\n-            pub.publish(topic, Message.newBuilder().setBody(\n-                               ByteString.copyFromUtf8(String.valueOf(i))).build());\n-        }\n-\n-        assertTrue(\"Timed out waiting for messages \" + (X+1),\n-                   firstLatch.await(10, TimeUnit.SECONDS));\n-        assertEquals(\"Should be expected messages with only \" + (X+1), X+1, expected.get());\n-\n-        final CountDownLatch closeSubLatch = new CountDownLatch(1);\n-        Callback<ResponseBody> closeCb = new Callback<ResponseBody>() {\n-            @Override\n-            public void operationFinished(Object ctx, ResponseBody respBody) {\n-                closeSubLatch.countDown();\n-            }\n-            @Override\n-            public void operationFailed(Object ctx, PubSubException exception) {\n-                closeSubLatch.countDown();\n-            }\n-        };\n-\n-        PubSubData pubSubData = new PubSubData(topic, null, subid,\n-                                               OperationType.CLOSESUBSCRIPTION,\n-                                               SubscriptionOptions.newBuilder().build(),\n-                                               closeCb, null);\n-        client.getHChannelManager().submitOp(pubSubData);\n-        closeSubLatch.await(10, TimeUnit.SECONDS);\n-\n-        // second publish\n-        for (int i=X+1; i<=2*X; i++) {\n-            pub.publish(topic, Message.newBuilder().setBody(\n-                               ByteString.copyFromUtf8(String.valueOf(i))).build());\n-        }\n-\n-        assertFalse(\"Receive more messages than \" + X,\n-                    secondLatch.await(3, TimeUnit.SECONDS));\n-        assertEquals(\"Should be expected message with \" + (X + 1),\n-                     X + 1, expected.get());\n-\n-        sub.stopDelivery(topic, subid);\n-        sub.closeSubscription(topic, subid);\n-\n-        client.close();\n-    }\n-\n-    \n-\n-}"},{"sha":"7567106922cbf51b8a0b935c209366c314dd7d5b","filename":"hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","status":"added","additions":431,"deletions":0,"changes":431,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/client/netty/TestMultiplexing.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.client.netty;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.server.HedwigHubTestBase;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+import org.apache.hedwig.util.Callback;\n+\n+public class TestMultiplexing extends HedwigHubTestBase {\n+\n+    private static final int DEFAULT_MSG_WINDOW_SIZE = 10;\n+\n+    protected class TestServerConfiguration extends HubServerConfiguration {\n+        TestServerConfiguration(int serverPort, int sslServerPort) {\n+            super(serverPort, sslServerPort);\n+        }\n+        @Override\n+        public int getDefaultMessageWindowSize() {\n+            return DEFAULT_MSG_WINDOW_SIZE;\n+        }\n+    }\n+\n+    class TestMessageHandler implements MessageHandler {\n+\n+        int expected;\n+        final int numMsgsAtFirstRun;\n+        final int numMsgsAtSecondRun;\n+        final CountDownLatch firstLatch;\n+        final CountDownLatch secondLatch;\n+        final boolean receiveSecondRun;\n+\n+        public TestMessageHandler(int start, int numMsgsAtFirstRun,\n+                                  boolean receiveSecondRun,\n+                                  int numMsgsAtSecondRun) {\n+            expected = start;\n+            this.numMsgsAtFirstRun = numMsgsAtFirstRun;\n+            this.numMsgsAtSecondRun = numMsgsAtSecondRun;\n+            this.receiveSecondRun = receiveSecondRun;\n+            firstLatch = new CountDownLatch(1);\n+            secondLatch = new CountDownLatch(1);\n+        }\n+\n+        @Override\n+        public synchronized void deliver(ByteString topic, ByteString subscriberId,\n+                                         Message msg,\n+                                         Callback<Void> callback, Object context) {\n+            try {\n+                int value = Integer.valueOf(msg.getBody().toStringUtf8());\n+                logger.debug(\"Received message {}.\", value);\n+\n+                if (value == expected) {\n+                    ++expected;\n+                } else {\n+                    // error condition\n+                    logger.error(\"Did not receive expected value, expected {}, got {}\",\n+                                 expected, value);\n+                    expected = 0;\n+                    firstLatch.countDown();\n+                    secondLatch.countDown();\n+                }\n+                if (numMsgsAtFirstRun + 1 == expected) {\n+                    firstLatch.countDown();\n+                }\n+                if (receiveSecondRun) {\n+                    if (numMsgsAtFirstRun + numMsgsAtSecondRun + 1 == expected) {\n+                        secondLatch.countDown();\n+                    }\n+                } else {\n+                    if (numMsgsAtFirstRun + 1 < expected) {\n+                        secondLatch.countDown();\n+                    }\n+                }\n+                callback.operationFinished(context, null);\n+                subscriber.consume(topic, subscriberId, msg.getMsgId());\n+            } catch (Throwable t) {\n+                logger.error(\"Received bad message.\", t);\n+                firstLatch.countDown();\n+                secondLatch.countDown();\n+            }\n+        }\n+\n+        public void checkFirstRun() throws Exception {\n+            assertTrue(\"Timed out waiting for messages \" + (numMsgsAtFirstRun + 1),\n+                       firstLatch.await(10, TimeUnit.SECONDS));\n+            assertEquals(\"Should be expected messages with \" + (numMsgsAtFirstRun + 1),\n+                         numMsgsAtFirstRun + 1, expected);\n+        }\n+\n+        public void checkSecondRun() throws Exception {\n+            if (receiveSecondRun) {\n+                assertTrue(\"Timed out waiting for messages \"\n+                           + (numMsgsAtFirstRun + numMsgsAtSecondRun + 1),\n+                           secondLatch.await(10, TimeUnit.SECONDS));\n+                assertEquals(\"Should be expected messages with \"\n+                             + (numMsgsAtFirstRun + numMsgsAtSecondRun + 1),\n+                             numMsgsAtFirstRun + numMsgsAtSecondRun + 1, expected);\n+            } else {\n+                assertFalse(\"Receive more messages than \" + numMsgsAtFirstRun,\n+                            secondLatch.await(3, TimeUnit.SECONDS));\n+                assertEquals(\"Should be expected messages with ony \" + (numMsgsAtFirstRun + 1),\n+                             numMsgsAtFirstRun + 1, expected);\n+            }\n+        }\n+    }\n+\n+    class ThrottleMessageHandler implements MessageHandler {\n+\n+        int expected;\n+        final int numMsgs;\n+        final int numMsgsThrottle;\n+        final CountDownLatch throttleLatch;\n+        final CountDownLatch nonThrottleLatch;\n+        final boolean enableThrottle;\n+\n+        public ThrottleMessageHandler(int start, int numMsgs,\n+                                      boolean enableThrottle,\n+                                      int numMsgsThrottle) {\n+            expected = start;\n+            this.numMsgs = numMsgs;\n+            this.enableThrottle = enableThrottle;\n+            this.numMsgsThrottle = numMsgsThrottle;\n+            throttleLatch = new CountDownLatch(1);\n+            nonThrottleLatch = new CountDownLatch(1);\n+        }\n+\n+        @Override\n+        public synchronized void deliver(ByteString topic, ByteString subscriberId,\n+                                         Message msg,\n+                                         Callback<Void> callback, Object context) {\n+            try {\n+                int value = Integer.valueOf(msg.getBody().toStringUtf8());\n+                logger.debug(\"Received message {}.\", value);\n+\n+                if (value == expected) {\n+                    ++expected;\n+                } else {\n+                    // error condition\n+                    logger.error(\"Did not receive expected value, expected {}, got {}\",\n+                                 expected, value);\n+                    expected = 0;\n+                    throttleLatch.countDown();\n+                    nonThrottleLatch.countDown();\n+                }\n+                if (expected == numMsgsThrottle + 2) {\n+                    throttleLatch.countDown();\n+                }\n+                if (expected == numMsgs + 1) {\n+                    nonThrottleLatch.countDown();\n+                }\n+                callback.operationFinished(context, null);\n+                if (enableThrottle) {\n+                    if (expected > numMsgsThrottle + 1) {\n+                        subscriber.consume(topic, subscriberId, msg.getMsgId());\n+                    }\n+                } else {\n+                    subscriber.consume(topic, subscriberId, msg.getMsgId());\n+                }\n+            } catch (Throwable t) {\n+                logger.error(\"Received bad message.\", t);\n+                throttleLatch.countDown();\n+                nonThrottleLatch.countDown();\n+            }\n+        }\n+\n+        public void checkThrottle() throws Exception {\n+            if (enableThrottle) {\n+                assertFalse(\"Received more messages than throttle value \" + numMsgsThrottle,\n+                            throttleLatch.await(3, TimeUnit.SECONDS));\n+                assertEquals(\"Should be expected messages with only \" + (numMsgsThrottle + 1),\n+                             numMsgsThrottle + 1, expected);\n+            } else {\n+                assertTrue(\"Should not be throttled.\", throttleLatch.await(10, TimeUnit.SECONDS));\n+                assertTrue(\"Timed out waiting for messages \" + (numMsgs + 1),\n+                           nonThrottleLatch.await(10, TimeUnit.SECONDS));\n+                assertEquals(\"Should be expected messages with \" + (numMsgs + 1),\n+                             numMsgs + 1, expected);\n+            }\n+        }\n+\n+        public void checkAfterThrottle() throws Exception {\n+            if (enableThrottle) {\n+                assertTrue(\"Timed out waiting for messages \" + (numMsgs + 1),\n+                           nonThrottleLatch.await(10, TimeUnit.SECONDS));\n+                assertEquals(\"Should be expected messages with \" + (numMsgs + 1),\n+                             numMsgs + 1, expected);\n+            }\n+        }\n+    }\n+\n+    HedwigClient client;\n+    Publisher publisher;\n+    Subscriber subscriber;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        numServers = 1;\n+        super.setUp();\n+        client = new HedwigClient(new ClientConfiguration() {\n+            @Override\n+            public boolean isMultiplexingEnabled() {\n+                return true;\n+            }\n+            @Override\n+            public boolean isAutoSendConsumeMessageEnabled() {\n+                return false;\n+            }\n+        });\n+        publisher = client.getPublisher();\n+        subscriber = client.getSubscriber();\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        client.close();\n+        super.tearDown();\n+    }\n+\n+    @Override\n+    protected ServerConfiguration getServerConfiguration(int port, int sslPort) {\n+        return new TestServerConfiguration(port, sslPort);\n+    }\n+\n+    @Test\n+    public void testStopDelivery() throws Exception {\n+        ByteString topic1 = ByteString.copyFromUtf8(\"testStopDelivery-1\");\n+        ByteString topic2 = ByteString.copyFromUtf8(\"testStopDelivery-2\");\n+        ByteString subid1 = ByteString.copyFromUtf8(\"mysubid-1\");\n+        ByteString subid2 = ByteString.copyFromUtf8(\"mysubid-2\");\n+\n+        final int X = 20;\n+\n+        TestMessageHandler csHandler11 =\n+            new TestMessageHandler(1, X, true, X);\n+        TestMessageHandler csHandler12 =\n+            new TestMessageHandler(1, X, false, 0);\n+        TestMessageHandler csHandler21 =\n+            new TestMessageHandler(1, X, false, 0);\n+        TestMessageHandler csHandler22 =\n+            new TestMessageHandler(1, X, true, X);\n+\n+        subscriber.subscribe(topic1, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic1, subid2, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid2, CreateOrAttach.CREATE);\n+\n+        // start deliveries\n+        subscriber.startDelivery(topic1, subid1, csHandler11);\n+        subscriber.startDelivery(topic1, subid2, csHandler12);\n+        subscriber.startDelivery(topic2, subid1, csHandler21);\n+        subscriber.startDelivery(topic2, subid2, csHandler22);\n+\n+        // first publish\n+        for (int i = 1; i<=X; i++) {\n+            publisher.publish(topic1, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            publisher.publish(topic2, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+\n+        csHandler11.checkFirstRun();\n+        csHandler12.checkFirstRun();\n+        csHandler21.checkFirstRun();\n+        csHandler22.checkFirstRun();\n+\n+        // stop delivery for <topic1, subscriber2> and <topic2, subscriber1>\n+        subscriber.stopDelivery(topic1, subid2);\n+        subscriber.stopDelivery(topic2, subid1);\n+\n+        // second publish\n+        for (int i = X+1; i<=2*X; i++) {\n+            publisher.publish(topic1, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            publisher.publish(topic2, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+\n+        csHandler11.checkSecondRun();\n+        csHandler22.checkSecondRun();\n+        csHandler12.checkSecondRun();\n+        csHandler21.checkSecondRun();\n+    }\n+\n+    @Test\n+    public void testCloseSubscription() throws Exception {\n+        ByteString topic1 = ByteString.copyFromUtf8(\"testCloseSubscription-1\");\n+        ByteString topic2 = ByteString.copyFromUtf8(\"testCloseSubscription-2\");\n+        ByteString subid1 = ByteString.copyFromUtf8(\"mysubid-1\");\n+        ByteString subid2 = ByteString.copyFromUtf8(\"mysubid-2\");\n+\n+        final int X = 20;\n+\n+        TestMessageHandler csHandler11 =\n+            new TestMessageHandler(1, X, true, X);\n+        TestMessageHandler csHandler12 =\n+            new TestMessageHandler(1, X, false, 0);\n+        TestMessageHandler csHandler21 =\n+            new TestMessageHandler(1, X, false, 0);\n+        TestMessageHandler csHandler22 =\n+            new TestMessageHandler(1, X, true, X);\n+\n+        subscriber.subscribe(topic1, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic1, subid2, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid2, CreateOrAttach.CREATE);\n+\n+        // start deliveries\n+        subscriber.startDelivery(topic1, subid1, csHandler11);\n+        subscriber.startDelivery(topic1, subid2, csHandler12);\n+        subscriber.startDelivery(topic2, subid1, csHandler21);\n+        subscriber.startDelivery(topic2, subid2, csHandler22);\n+\n+        // first publish\n+        for (int i = 1; i<=X; i++) {\n+            publisher.publish(topic1, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            publisher.publish(topic2, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+\n+        csHandler11.checkFirstRun();\n+        csHandler12.checkFirstRun();\n+        csHandler21.checkFirstRun();\n+        csHandler22.checkFirstRun();\n+\n+        // close subscription for <topic1, subscriber2> and <topic2, subscriber1>\n+        subscriber.closeSubscription(topic1, subid2);\n+        subscriber.closeSubscription(topic2, subid1);\n+\n+        // second publish\n+        for (int i = X+1; i<=2*X; i++) {\n+            publisher.publish(topic1, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            publisher.publish(topic2, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+\n+        csHandler11.checkSecondRun();\n+        csHandler22.checkSecondRun();\n+        csHandler12.checkSecondRun();\n+        csHandler21.checkSecondRun();\n+    }\n+\n+    @Test\n+    public void testThrottle() throws Exception {\n+        ByteString topic1 = ByteString.copyFromUtf8(\"testThrottle-1\");\n+        ByteString topic2 = ByteString.copyFromUtf8(\"testThrottle-2\");\n+        ByteString subid1 = ByteString.copyFromUtf8(\"mysubid-1\");\n+        ByteString subid2 = ByteString.copyFromUtf8(\"mysubid-2\");\n+\n+        final int X = DEFAULT_MSG_WINDOW_SIZE;\n+\n+        ThrottleMessageHandler csHandler11 =\n+            new ThrottleMessageHandler(1, 3*X, false, X);\n+        ThrottleMessageHandler csHandler12 =\n+            new ThrottleMessageHandler(1, 3*X, true, X);\n+        ThrottleMessageHandler csHandler21 =\n+            new ThrottleMessageHandler(1, 3*X, true, X);\n+        ThrottleMessageHandler csHandler22 =\n+            new ThrottleMessageHandler(1, 3*X, false, X);\n+\n+        subscriber.subscribe(topic1, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic1, subid2, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid1, CreateOrAttach.CREATE);\n+        subscriber.subscribe(topic2, subid2, CreateOrAttach.CREATE);\n+\n+        // start deliveries\n+        subscriber.startDelivery(topic1, subid1, csHandler11);\n+        subscriber.startDelivery(topic1, subid2, csHandler12);\n+        subscriber.startDelivery(topic2, subid1, csHandler21);\n+        subscriber.startDelivery(topic2, subid2, csHandler22);\n+\n+        // publish\n+        for (int i = 1; i<=3*X; i++) {\n+            publisher.publish(topic1, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+            publisher.publish(topic2, Message.newBuilder().setBody(\n+                                      ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+\n+        csHandler11.checkThrottle();\n+        csHandler12.checkThrottle();\n+        csHandler21.checkThrottle();\n+        csHandler22.checkThrottle();\n+\n+        // consume messages to not throttle them\n+        for (int i=1; i<=X; i++) {\n+            MessageSeqId seqId =\n+                MessageSeqId.newBuilder().setLocalComponent(i).build();\n+            subscriber.consume(topic1, subid2, seqId);\n+            subscriber.consume(topic2, subid1, seqId);\n+        }\n+\n+        csHandler11.checkAfterThrottle();\n+        csHandler22.checkAfterThrottle();\n+        csHandler12.checkAfterThrottle();\n+        csHandler21.checkAfterThrottle();\n+    }\n+}"},{"sha":"0ac945ac6c7149055ff36aeb0bbe5044a3e7183c","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -166,6 +166,11 @@ protected ClientConfiguration getClientConfiguration(int serverPort, int sslServ\n         return new RegionClientConfiguration(serverPort, sslServerPort);\n     }\n \n+    // Method to get a ClientConfiguration for the Cross Region Hedwig Client.\n+    protected ClientConfiguration getRegionClientConfiguration() {\n+        return new ClientConfiguration();\n+    }\n+\n     @Override\n     @Before\n     public void setUp() throws Exception {\n@@ -237,7 +242,8 @@ protected void startRegion(int i) throws Exception {\n                     getServerConfiguration(initialServerPort\n                                            + (j + i * numServersPerRegion),\n                                            initialSSLServerPort + (j + i * numServersPerRegion),\n-                                           regionName));\n+                                           regionName),\n+                    getRegionClientConfiguration());\n             serversList.add(s);\n             s.start();\n         }"},{"sha":"c5fc3ca56333ea9431cdcc4009946c9e7caddaf5","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/TestThrottlingDelivery.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.hedwig.server.delivery;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n@@ -25,6 +27,9 @@\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.assertEquals;\n@@ -44,6 +49,7 @@\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.util.Callback;\n \n+@RunWith(Parameterized.class)\n public class TestThrottlingDelivery extends HedwigHubTestBase {\n \n     private static final int DEFAULT_MESSAGE_WINDOW_SIZE = 10;\n@@ -85,6 +91,11 @@ void setMessageWindowSize(int messageWindowSize) {\n         public boolean isAutoSendConsumeMessageEnabled() {\n             return false;\n         }\n+\n+        @Override\n+        public boolean isMultiplexingEnabled() {\n+            return isMultiplexingEnabled;\n+        }\n     }\n \n     private void throttleX(Publisher pub, final Subscriber sub,\n@@ -154,6 +165,17 @@ public synchronized void deliver(ByteString topic, ByteString subscriberId,\n         sub.closeSubscription(topic, subid);\n     }\n \n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { { false }, { true } });\n+    }\n+\n+    protected boolean isMultiplexingEnabled;\n+\n+    public TestThrottlingDelivery(boolean isMultiplexingEnabled) {\n+        this.isMultiplexingEnabled = isMultiplexingEnabled;\n+    }\n+\n     @Override\n     @Before\n     public void setUp() throws Exception {"},{"sha":"d7beb908438ef3c0efdf67a283de1a496a2520ca","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/handlers/TestSubUnsubHandler.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.hedwig.server.handlers;\n \n+import java.util.HashSet;\n+import java.util.Set;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import org.junit.Test;\n@@ -107,7 +109,9 @@ public void testSuccessCase() {\n         assertEquals(StatusCode.SUCCESS, ((PubSubResponse) channel.getMessagesWritten().get(0)).getStatusCode());\n \n         // make sure the channel was put in the maps\n-        assertEquals(new TopicSubscriber(topic, subscriberId),\n+        Set<TopicSubscriber> topicSubs = new HashSet<TopicSubscriber>();\n+        topicSubs.add(new TopicSubscriber(topic, subscriberId));\n+        assertEquals(topicSubs,\n                      subChannelMgr.channel2sub.get(channel));\n         assertEquals(channel,\n                      subChannelMgr.sub2Channel.get(new TopicSubscriber(topic, subscriberId)));"},{"sha":"bb0de09a4e1e96146b521c0bc096bd25011e7824","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","status":"modified","additions":17,"deletions":2,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -80,13 +80,22 @@\n \n     @Parameters\n     public static Collection<Object[]> configs() {\n-        return Arrays.asList(new Object[][] { { Mode.PROXY }, { Mode.REGULAR }, { Mode.SSL }});\n+        return Arrays.asList(new Object[][] {\n+                                { Mode.PROXY, false },\n+                                { Mode.PROXY, true },\n+                                { Mode.REGULAR, false },\n+                                { Mode.REGULAR, true },\n+                                { Mode.SSL, false },\n+                                { Mode.SSL, true }\n+                             });\n     }\n \n     protected Mode mode;\n+    protected boolean isMultiplexingEnabled;\n \n-    public TestHedwigHub(Mode mode) {\n+    public TestHedwigHub(Mode mode, boolean isMultiplexingEnabled) {\n         this.mode = mode;\n+        this.isMultiplexingEnabled = isMultiplexingEnabled;\n     }\n \n     protected HedwigProxy proxy;\n@@ -182,6 +191,7 @@ public void run() {\n     }\n \n     class TestClientConfiguration extends ClientConfiguration {\n+\n         @Override\n         public InetSocketAddress getDefaultServerHost() {\n             if (mode == Mode.PROXY) {\n@@ -198,6 +208,11 @@ public boolean isSSLEnabled() {\n             else\n                 return false;\n         }\n+\n+        @Override\n+        public boolean isMultiplexingEnabled() {\n+            return isMultiplexingEnabled;\n+        }\n     }\n \n     // ClientConfiguration to use for this test."},{"sha":"8b82e939a3eabf65f150bf18629cdba4fe54472a","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"modified","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/f633075dd0b0cae6c50db0f7284798089a9cf83b/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=f633075dd0b0cae6c50db0f7284798089a9cf83b","patch":"@@ -17,24 +17,31 @@\n  */\n package org.apache.hedwig.server.integration;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Map;\n import java.util.Random;\n import java.util.concurrent.SynchronousQueue;\n \n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n \n import com.google.protobuf.ByteString;\n import org.apache.hedwig.client.HedwigClient;\n import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.server.HedwigRegionTestBase;\n import org.apache.hedwig.server.common.ServerConfiguration;\n import org.apache.hedwig.server.integration.TestHedwigHub.TestCallback;\n import org.apache.hedwig.server.integration.TestHedwigHub.TestMessageHandler;\n \n+@RunWith(Parameterized.class)\n public class TestHedwigRegion extends HedwigRegionTestBase {\n \n     // SynchronousQueues to verify async calls\n@@ -54,12 +61,35 @@ public NewRegionServerConfiguration(int serverPort, int sslServerPort,\n         public int getRetryRemoteSubscribeThreadRunInterval() {\n             return TEST_RETRY_REMOTE_SUBSCRIBE_INTERVAL_VALUE;\n         }\n+\n+    }\n+\n+    protected class NewRegionClientConfiguration extends ClientConfiguration {\n+        @Override\n+        public boolean isMultiplexingEnabled() {\n+            return isMultiplexingEnabled;\n+        }\n     }\n \n     protected ServerConfiguration getServerConfiguration(int serverPort, int sslServerPort, String regionName) {\n         return new NewRegionServerConfiguration(serverPort, sslServerPort, regionName);\n     }\n \n+    protected ClientConfiguration getRegionClientConfiguration() {\n+        return new NewRegionClientConfiguration();\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { { false }, { true } });\n+    }\n+\n+    protected boolean isMultiplexingEnabled;\n+\n+    public TestHedwigRegion(boolean isMultiplexingEnabled) {\n+        this.isMultiplexingEnabled = isMultiplexingEnabled;\n+    }\n+\n     @Override\n     @Before\n     public void setUp() throws Exception {"}]}

