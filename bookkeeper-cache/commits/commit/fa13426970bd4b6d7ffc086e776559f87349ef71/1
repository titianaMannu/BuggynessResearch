{"sha":"fa13426970bd4b6d7ffc086e776559f87349ef71","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmYTEzNDI2OTcwYmQ0YjZkN2ZmYzA4NmU3NzY1NTlmODczNDllZjcx","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-12-24T04:50:02Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-12-24T04:50:02Z"},"message":"BOOKKEEPER-463: Refactor garbage collection code for ease to plugin different GC algorithm. (Fangmin, ivank, fpj via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1425585 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bbfbdced00c1898c7bdbd4a7bf87d3d15bb18f1d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/bbfbdced00c1898c7bdbd4a7bf87d3d15bb18f1d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fa13426970bd4b6d7ffc086e776559f87349ef71","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fa13426970bd4b6d7ffc086e776559f87349ef71","html_url":"https://github.com/apache/bookkeeper/commit/fa13426970bd4b6d7ffc086e776559f87349ef71","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fa13426970bd4b6d7ffc086e776559f87349ef71/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"a3da8c74c4226b7d92e9d0eba9591334351afa45","url":"https://api.github.com/repos/apache/bookkeeper/commits/a3da8c74c4226b7d92e9d0eba9591334351afa45","html_url":"https://github.com/apache/bookkeeper/commit/a3da8c74c4226b7d92e9d0eba9591334351afa45"}],"stats":{"total":1370,"additions":735,"deletions":635},"files":[{"sha":"b53ed7293225cedbc8210beff0d5eba2d8edfae4","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -270,6 +270,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-490: add documentation for MetaStore interface (sijie, ivank via sijie)\n \n+        BOOKKEEPER-463: Refactor garbage collection code for ease to plugin different GC algorithm. (Fangmin, ivank, fpj via sijie)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"638e7e36fd04e20e3aef13a0132e7a8b917f2771","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":9,"deletions":12,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -39,7 +39,7 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.apache.bookkeeper.meta.ActiveLedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n@@ -82,8 +82,8 @@\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n-    final LedgerManagerFactory activeLedgerManagerFactory;\n-    final ActiveLedgerManager activeLedgerManager;\n+    final LedgerManagerFactory ledgerManagerFactory;\n+    final LedgerManager ledgerManager;\n     final LedgerStorage ledgerStorage;\n     final Journal journal;\n \n@@ -478,17 +478,14 @@ public Bookie(ServerConfiguration conf)\n         this.conf = conf;\n         this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n         this.ledgerDirsManager = new LedgerDirsManager(conf);\n-\n         // instantiate zookeeper client to initialize ledger manager\n         this.zk = instantiateZookeeperClient(conf);\n         checkEnvironment(this.zk);\n-\n-        activeLedgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n-        activeLedgerManager = activeLedgerManagerFactory.newActiveLedgerManager();\n-\n+        ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n+        LOG.info(\"instantiate ledger manager {}\", ledgerManagerFactory.getClass().getName());\n+        ledgerManager = ledgerManagerFactory.newLedgerManager();\n         syncThread = new SyncThread(conf);\n-        ledgerStorage = new InterleavedLedgerStorage(conf, activeLedgerManager,\n-                ledgerDirsManager);\n+        ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager, ledgerDirsManager);\n         handles = new HandleFactoryImpl(ledgerStorage);\n         // instantiate the journal\n         journal = new Journal(conf, ledgerDirsManager);\n@@ -910,8 +907,8 @@ synchronized int shutdown(int exitCode) {\n \n                 // close Ledger Manager\n                 try {\n-                    activeLedgerManager.close();\n-                    activeLedgerManagerFactory.uninitialize();\n+                    ledgerManager.close();\n+                    ledgerManagerFactory.uninitialize();\n                 } catch (IOException ie) {\n                     LOG.error(\"Failed to close active ledger manager : \", ie);\n                 }"},{"sha":"bfe69a4c3656b3bb82d2be7e9224b17f5b3ca492","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -0,0 +1,51 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+/**\n+ * This is the garbage collector interface, garbage collector implementers\n+ * need to extends this class to remove the deleted ledgers.\n+ */\n+public interface GarbageCollector {\n+    /**\n+     * Do the garbage collector work\n+     *\n+     * @param garbageCleaner\n+     *          cleaner used to clean selected garbages\n+     */\n+    public abstract void gc(GarbageCleaner garbageCleaner);\n+\n+    /**\n+     * A interface used to define customised garbage cleaner\n+     */\n+    public interface GarbageCleaner {\n+\n+        /**\n+         * Clean a specific ledger\n+         *\n+         * @param ledgerId\n+         *          Ledger ID to be cleaned\n+         */\n+        public void clean(final long ledgerId) ;\n+    }\n+\n+}"},{"sha":"0f55d3208eb36c60f6c15579d44ef5b34a247b28","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":31,"deletions":19,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -32,9 +32,11 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n+import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.ActiveLedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.util.SnapshotMap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -71,8 +73,7 @@\n \n     // Ledger Cache Handle\n     final LedgerCache ledgerCache;\n-\n-    final ActiveLedgerManager activeLedgerManager;\n+    final SnapshotMap<Long, Boolean> activeLedgers;\n \n     // flag to ensure gc thread will not be interrupted during compaction\n     // to reduce the risk getting entry log corrupted\n@@ -83,6 +84,9 @@\n     // track the last scanned successfully log id\n     long scannedLogId = 0;\n \n+    final GarbageCollector garbageCollector;\n+    final GarbageCleaner garbageCleaner;\n+\n     /**\n      * A scanner wrapper to check whether a ledger is alive in an entry log file\n      */\n@@ -114,19 +118,37 @@ public void process(long ledgerId, long offset, ByteBuffer entry)\n      * @throws IOException\n      */\n     public GarbageCollectorThread(ServerConfiguration conf,\n-                                  LedgerCache ledgerCache,\n+                                  final LedgerCache ledgerCache,\n                                   EntryLogger entryLogger,\n-                                  ActiveLedgerManager activeLedgerManager,\n-                                  EntryLogScanner scanner)\n+                                  SnapshotMap<Long, Boolean> activeLedgers,\n+                                  EntryLogScanner scanner,\n+                                  LedgerManager ledgerManager)\n         throws IOException {\n         super(\"GarbageCollectorThread\");\n \n         this.ledgerCache = ledgerCache;\n         this.entryLogger = entryLogger;\n-        this.activeLedgerManager = activeLedgerManager;\n+        this.activeLedgers = activeLedgers;\n         this.scanner = scanner;\n \n         this.gcWaitTime = conf.getGcWaitTime();\n+\n+        this.garbageCleaner = new GarbageCollector.GarbageCleaner() {\n+            @Override\n+            public void clean(long ledgerId) {\n+                try {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"delete ledger : \" + ledgerId);\n+                    }\n+                    ledgerCache.deleteLedger(ledgerId);\n+                } catch (IOException e) {\n+                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n+                }\n+            }\n+        };\n+\n+        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, activeLedgers);\n+\n         // compaction parameters\n         minorCompactionThreshold = conf.getMinorCompactionThreshold();\n         minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;\n@@ -223,17 +245,7 @@ public void run() {\n      * Do garbage collection ledger index files\n      */\n     private void doGcLedgers() {\n-        activeLedgerManager.garbageCollectLedgers(\n-        new ActiveLedgerManager.GarbageCollector() {\n-            @Override\n-            public void gc(long ledgerId) {\n-                try {\n-                    ledgerCache.deleteLedger(ledgerId);\n-                } catch (IOException e) {\n-                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n-                }\n-            }\n-        });\n+        garbageCollector.gc(garbageCleaner);\n     }\n \n     /**\n@@ -245,7 +257,7 @@ private void doGcEntryLogs() {\n             EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n             for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n                 // Remove the entry log ledger from the set if it isn't active.\n-                if (!activeLedgerManager.containsActiveLedger(entryLogLedger)) {\n+                if (!activeLedgers.containsKey(entryLogLedger)) {\n                     meta.removeLedger(entryLogLedger);\n                 }\n             }"},{"sha":"5d8ca80b0b53e7ea246fb575ef7f62ffa704541b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":13,"deletions":6,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -26,8 +26,10 @@\n \n import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.ActiveLedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.util.SnapshotMap;\n+import org.apache.zookeeper.ZooKeeper;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -42,6 +44,10 @@\n \n     EntryLogger entryLogger;\n     LedgerCache ledgerCache;\n+\n+    // A sorted map to stored all active ledger ids\n+    protected final SnapshotMap<Long, Boolean> activeLedgers;\n+\n     // This is the thread that garbage collects the entry logs that do not\n     // contain any active ledgers in them; and compacts the entry logs that\n     // has lower remaining percentage to reclaim disk space.\n@@ -51,15 +57,16 @@\n     private volatile boolean somethingWritten = false;\n \n     InterleavedLedgerStorage(ServerConfiguration conf,\n-            ActiveLedgerManager activeLedgerManager,\n-            LedgerDirsManager ledgerDirsManager) throws IOException {\n+            LedgerManager ledgerManager, LedgerDirsManager ledgerDirsManager)\n+\t\t\tthrows IOException {\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n         entryLogger = new EntryLogger(conf, ledgerDirsManager);\n-        ledgerCache = new LedgerCacheImpl(conf, activeLedgerManager, ledgerDirsManager);\n+        ledgerCache = new LedgerCacheImpl(conf, activeLedgers, ledgerDirsManager);\n         gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n-                activeLedgerManager, new EntryLogCompactionScanner());\n+                activeLedgers, new EntryLogCompactionScanner(), ledgerManager);\n     }\n \n-    @Override    \n+    @Override\n     public void start() {\n         gcThread.start();\n     }"},{"sha":"9db9af4e468f602ae5c811e553b022772fc3abe6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -35,7 +35,7 @@\n import java.util.Map.Entry;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.apache.bookkeeper.meta.ActiveLedgerManager;\n+import org.apache.bookkeeper.util.SnapshotMap;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -54,7 +54,8 @@\n     private LedgerDirsManager ledgerDirsManager;\n     final private AtomicBoolean shouldRelocateIndexFile = new AtomicBoolean(false);\n \n-    public LedgerCacheImpl(ServerConfiguration conf, ActiveLedgerManager alm, LedgerDirsManager ledgerDirsManager)\n+    public LedgerCacheImpl(ServerConfiguration conf, SnapshotMap<Long, Boolean> activeLedgers,\n+            LedgerDirsManager ledgerDirsManager)\n             throws IOException {\n         this.ledgerDirsManager = ledgerDirsManager;\n         this.openFileLimit = conf.getOpenFileLimit();\n@@ -69,7 +70,7 @@ public LedgerCacheImpl(ServerConfiguration conf, ActiveLedgerManager alm, Ledger\n         }\n         LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n         LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n-        activeLedgerManager = alm;\n+        this.activeLedgers = activeLedgers;\n         // Retrieve all of the active ledgers.\n         getActiveLedgers();\n         ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());\n@@ -90,7 +91,7 @@ public LedgerCacheImpl(ServerConfiguration conf, ActiveLedgerManager alm, Ledger\n \n     // Manage all active ledgers in LedgerManager\n     // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n-    final ActiveLedgerManager activeLedgerManager;\n+    final SnapshotMap<Long, Boolean> activeLedgers;\n \n     final int openFileLimit;\n     final int pageSize;\n@@ -257,7 +258,7 @@ FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n                     // A new ledger index file has been created for this Bookie.\n                     // Add this new ledger to the set of active ledgers.\n                     LOG.debug(\"New ledger index file created for ledgerId: {}\", ledger);\n-                    activeLedgerManager.addActiveLedger(ledger, true);\n+                    activeLedgers.put(ledger, true);\n                 }\n                 evictFileInfoIfNecessary();\n                 fi = new FileInfo(lf, masterKey);\n@@ -697,7 +698,7 @@ private void getActiveLedgers() throws IOException {\n                                         }\n                                     }\n                                 }\n-                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n+                                activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);\n                             }\n                         }\n                     }\n@@ -739,7 +740,7 @@ public void deleteLedger(long ledgerId) throws IOException {\n         }\n \n         // Remove it from the active ledger manager\n-        activeLedgerManager.removeActiveLedger(ledgerId);\n+        activeLedgers.remove(ledgerId);\n \n         // Now remove it from all the other lists and maps.\n         // These data structures need to be synchronized first before removing entries."},{"sha":"6ed2c0b6411d14652908741f53b62ee9a5822d64","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -0,0 +1,108 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n+import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n+import org.apache.bookkeeper.util.SnapshotMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Garbage collector implementation using scan and compare.\n+ *\n+ * <p>\n+ * Garbage collection is processed as below:\n+ * <ul>\n+ * <li> fetch all existing ledgers from zookeeper or metastore according to\n+ * the LedgerManager, called <b>globalActiveLedgers</b>\n+ * <li> fetch all active ledgers from bookie server, said <b>bkActiveLedgers</b>\n+ * <li> loop over <b>bkActiveLedgers</b> to find those ledgers that are not in\n+ * <b>globalActiveLedgers</b>, do garbage collection on them.\n+ * </ul>\n+ * </p>\n+ */\n+public class ScanAndCompareGarbageCollector implements GarbageCollector{\n+\n+    static final Logger LOG = LoggerFactory.getLogger(ScanAndCompareGarbageCollector.class);\n+    private SnapshotMap<Long, Boolean> activeLedgers;\n+    private LedgerManager ledgerManager;\n+\n+    public ScanAndCompareGarbageCollector(LedgerManager ledgerManager, SnapshotMap<Long, Boolean> activeLedgers) {\n+        this.ledgerManager = ledgerManager;\n+        this.activeLedgers = activeLedgers;\n+    }\n+\n+    @Override\n+    public void gc(GarbageCleaner garbageCleaner) {\n+        // create a snapshot first\n+        NavigableMap<Long, Boolean> bkActiveLedgersSnapshot =\n+                this.activeLedgers.snapshot();\n+        LedgerRangeIterator ledgerRangeIterator = ledgerManager.getLedgerRanges();\n+        try {\n+            // Empty global active ledgers, need to remove all local active ledgers.\n+            if (!ledgerRangeIterator.hasNext()) {\n+                for (Long bkLid : bkActiveLedgersSnapshot.keySet()) {\n+                    // remove it from current active ledger\n+                    bkActiveLedgersSnapshot.remove(bkLid);\n+                    garbageCleaner.clean(bkLid);\n+                }\n+            }\n+            while(ledgerRangeIterator.hasNext()) {\n+                LedgerRange lRange = ledgerRangeIterator.next();\n+                Map<Long, Boolean> subBkActiveLedgers = null;\n+                Long start = lRange.start();\n+                Long end = lRange.end();\n+                if (end != LedgerRange.NOLIMIT) {\n+                    subBkActiveLedgers = bkActiveLedgersSnapshot.subMap(start,\n+                            true, end, true);\n+                } else {\n+                    if (start != LedgerRange.NOLIMIT) {\n+                        subBkActiveLedgers = bkActiveLedgersSnapshot.tailMap(start);\n+                    } else {\n+                        subBkActiveLedgers = bkActiveLedgersSnapshot;\n+                    }\n+                }\n+                Set<Long> globalActiveLedgers = lRange.getLedgers();\n+                LOG.debug(\"All active ledgers for hash node {}, Current active ledgers from Bookie for hash node {}\",\n+                        globalActiveLedgers, subBkActiveLedgers.keySet());\n+                for (Long bkLid : subBkActiveLedgers.keySet()) {\n+                    if (!globalActiveLedgers.contains(bkLid)) {\n+                        // remove it from current active ledger\n+                        subBkActiveLedgers.remove(bkLid);\n+                        garbageCleaner.clean(bkLid);\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            // ignore exception, collecting garbage next time\n+            LOG.warn(\"Exception when iterating over the metadata {}\", e);\n+        }\n+    }\n+}\n+\n+"},{"sha":"05bb1abdf5bdb97d5762124a7ff72d8c5793a918","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerDeleteOp.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -23,6 +23,7 @@\n \n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n+import org.apache.bookkeeper.versioning.Version;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -65,7 +66,7 @@\n     public void initiate() {\n         // Asynchronously delete the ledger from meta manager\n         // When this completes, it will invoke the callback method below.\n-        bk.getLedgerManager().deleteLedger(ledgerId, this);\n+        bk.getLedgerManager().removeLedgerMetadata(ledgerId, Version.ANY, this);\n     }\n \n     /**"},{"sha":"78cb244222e9aacdf2278a68d433fd7e540e619d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":56,"deletions":150,"changes":206,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -21,7 +21,6 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-import java.util.Map;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.client.LedgerMetadata;\n@@ -32,6 +31,7 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.util.ZkUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -47,17 +47,14 @@\n /**\n  * Abstract ledger manager based on zookeeper, which provides common methods such as query zk nodes.\n  */\n-abstract class AbstractZkLedgerManager implements LedgerManager, ActiveLedgerManager {\n+abstract class AbstractZkLedgerManager implements LedgerManager {\n \n     static Logger LOG = LoggerFactory.getLogger(AbstractZkLedgerManager.class);\n \n     protected final AbstractConfiguration conf;\n     protected final ZooKeeper zk;\n     protected final String ledgerRootPath;\n \n-    // A sorted map to stored all active ledger ids\n-    protected final SnapshotMap<Long, Boolean> activeLedgers;\n-\n     /**\n      * ZooKeeper-based Ledger Manager Constructor\n      *\n@@ -70,8 +67,6 @@ protected AbstractZkLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n         this.conf = conf;\n         this.zk = zk;\n         this.ledgerRootPath = conf.getZkLedgersRootPath();\n-\n-        activeLedgers = new SnapshotMap<Long, Boolean>();\n     }\n \n     /**\n@@ -93,9 +88,32 @@ protected AbstractZkLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n      */\n     protected abstract long getLedgerId(String ledgerPath) throws IOException;\n \n+    /**\n+     * Removes ledger metadata from ZooKeeper if version matches.\n+     *\n+     * @param   ledgerId    ledger identifier\n+     * @param   version     local version of metadata znode\n+     * @param   cb          callback object\n+     */\n     @Override\n-    public void deleteLedger(final long ledgerId, final GenericCallback<Void> cb) {\n-        zk.delete(getLedgerPath(ledgerId), -1, new VoidCallback() {\n+    public void removeLedgerMetadata(final long ledgerId, final Version version,\n+            final GenericCallback<Void> cb) {\n+        int znodeVersion = -1;\n+        if (Version.NEW == version) {\n+            LOG.error(\"Request to delete ledger {} metadata with version set to the initial one\", ledgerId);\n+            cb.operationComplete(BKException.Code.MetadataVersionException, (Void)null);\n+            return;\n+        } else if (Version.ANY != version) {\n+            if (!(version instanceof ZkVersion)) {\n+                LOG.info(\"Not an instance of ZKVersion: {}\", ledgerId);\n+                cb.operationComplete(BKException.Code.MetadataVersionException, (Void)null);\n+                return;\n+            } else {\n+                znodeVersion = ((ZkVersion)version).getZnodeVersion();\n+            }\n+        }\n+\n+        zk.delete(getLedgerPath(ledgerId), znodeVersion, new VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 int bkRc;\n@@ -173,112 +191,6 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n         }, null);\n     }\n \n-    /**\n-     * Get all the ledgers in a single zk node\n-     *\n-     * @param nodePath\n-     *          Zookeeper node path\n-     * @param getLedgersCallback\n-     *          callback function to process ledgers in a single node\n-     */\n-    protected void asyncGetLedgersInSingleNode(final String nodePath, final GenericCallback<HashSet<Long>> getLedgersCallback) {\n-        // First sync ZK to make sure we're reading the latest active/available ledger nodes.\n-        zk.sync(nodePath, new AsyncCallback.VoidCallback() {\n-            @Override\n-            public void processResult(int rc, String path, Object ctx) {\n-                LOG.debug(\"Sync node path {} return : {}\", path, rc);\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"ZK error syncing the ledgers node when getting children: \", KeeperException\n-                            .create(KeeperException.Code.get(rc), path));\n-                    getLedgersCallback.operationComplete(rc, null);\n-                    return;\n-                }\n-                // Sync has completed successfully so now we can poll ZK\n-                // and read in the latest set of active ledger nodes.\n-                doAsyncGetLedgersInSingleNode(nodePath, getLedgersCallback);\n-            }\n-        }, null);\n-    }\n-\n-    private void doAsyncGetLedgersInSingleNode(final String nodePath,\n-                                               final GenericCallback<HashSet<Long>> getLedgersCallback) {\n-        zk.getChildren(nodePath, false, new AsyncCallback.ChildrenCallback() {\n-            @Override\n-            public void processResult(int rc, String path, Object ctx, List<String> ledgerNodes) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"Error polling ZK for the available ledger nodes: \", KeeperException\n-                            .create(KeeperException.Code.get(rc), path));\n-                    getLedgersCallback.operationComplete(rc, null);\n-                    return;\n-                }\n-                LOG.debug(\"Retrieved current set of ledger nodes: {}\", ledgerNodes);\n-                // Convert the ZK retrieved ledger nodes to a HashSet for easier comparisons.\n-                HashSet<Long> allActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f);\n-                for (String ledgerNode : ledgerNodes) {\n-                    if (isSpecialZnode(ledgerNode)) {\n-                        continue;\n-                    }\n-                    try {\n-                        // convert the node path to ledger id according to different ledger manager implementation\n-                        allActiveLedgers.add(getLedgerId(path + \"/\" + ledgerNode));\n-                    } catch (IOException ie) {\n-                        LOG.warn(\"Error extracting ledgerId from ZK ledger node: \" + ledgerNode);\n-                        // This is a pretty bad error as it indicates a ledger node in ZK\n-                        // has an incorrect format. For now just continue and consider\n-                        // this as a non-existent ledger.\n-                        continue;\n-                    }\n-                }\n-\n-                getLedgersCallback.operationComplete(rc, allActiveLedgers);\n-\n-            }\n-        }, null);\n-    }\n-\n-    private static class GetLedgersCtx {\n-        int rc;\n-        boolean done = false;\n-        HashSet<Long> ledgers = null;\n-    }\n-\n-    /**\n-     * Get all the ledgers in a single zk node\n-     *\n-     * @param nodePath\n-     *          Zookeeper node path\n-     * @throws IOException\n-     * @throws InterruptedException\n-     */\n-    protected HashSet<Long> getLedgersInSingleNode(final String nodePath)\n-        throws IOException, InterruptedException {\n-        final GetLedgersCtx ctx = new GetLedgersCtx();\n-        LOG.debug(\"Try to get ledgers of node : {}\", nodePath);\n-        asyncGetLedgersInSingleNode(nodePath, new GenericCallback<HashSet<Long>>() {\n-                @Override\n-                public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n-                    synchronized (ctx) {\n-                        if (Code.OK.intValue() == rc) {\n-                            ctx.ledgers = zkActiveLedgers;\n-                        }\n-                        ctx.rc = rc;\n-                        ctx.done = true;\n-                        ctx.notifyAll();\n-                    }\n-                }\n-            });\n-\n-        synchronized (ctx) {\n-            while (ctx.done == false) {\n-                ctx.wait();\n-            }\n-        }\n-        if (Code.OK.intValue() != ctx.rc) {\n-            throw new IOException(\"Error on getting ledgers from node \" + nodePath);\n-        }\n-        return ctx.ledgers;\n-    }\n-\n     /**\n      * Process ledgers in a single zk node.\n      *\n@@ -309,14 +221,15 @@ protected void asyncProcessLedgersInSingleNode(\n             final String path, final Processor<Long> processor,\n             final AsyncCallback.VoidCallback finalCb, final Object ctx,\n             final int successRc, final int failureRc) {\n-        asyncGetLedgersInSingleNode(path, new GenericCallback<HashSet<Long>>() {\n+        ZkUtils.getChildrenInSingleNode(zk, path, new GenericCallback<List<String>>() {\n             @Override\n-            public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n+            public void operationComplete(int rc, List<String> ledgerNodes) {\n                 if (Code.OK.intValue() != rc) {\n                     finalCb.processResult(failureRc, null, ctx);\n                     return;\n                 }\n \n+                Set<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, path);\n                 LOG.debug(\"Processing ledgers: {}\", zkActiveLedgers);\n \n                 // no ledgers found, return directly\n@@ -353,43 +266,36 @@ protected boolean isSpecialZnode(String znode) {\n         return false;\n     }\n \n-    @Override\n-    public void close() {\n-    }\n-\n-    @Override\n-    public void addActiveLedger(long ledgerId, boolean active) {\n-        activeLedgers.put(ledgerId, active);\n-    }\n-\n-    @Override\n-    public void removeActiveLedger(long ledgerId) {\n-        activeLedgers.remove(ledgerId);\n-    }\n-\n-    @Override\n-    public boolean containsActiveLedger(long ledgerId) {\n-        return activeLedgers.containsKey(ledgerId);\n-    }\n-\n     /**\n-     * Do garbage collecting comparing hosted ledgers and zk ledgers\n+     * Convert the ZK retrieved ledger nodes to a HashSet for easier comparisons.\n      *\n-     * @param gc\n-     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n-     * @param bkActiveLedgers\n-     *          Active ledgers hosted in bookie server\n-     * @param zkAllLedgers\n-     *          All ledgers stored in zookeeper\n+     * @param ledgerNodes\n+     *          zk ledger nodes\n+     * @param path\n+     *          the prefix path of the ledger nodes\n+     * @return ledger id hash set\n      */\n-    void doGc(GarbageCollector gc, Map<Long, Boolean> bkActiveLedgers, Set<Long> zkAllLedgers) {\n-        // remove any active ledgers that doesn't exist in zk\n-        for (Long bkLid : bkActiveLedgers.keySet()) {\n-            if (!zkAllLedgers.contains(bkLid)) {\n-                // remove it from current active ledger\n-                bkActiveLedgers.remove(bkLid);\n-                gc.gc(bkLid);\n+    protected Set<Long> ledgerListToSet(List<String> ledgerNodes, String path) {\n+        Set<Long> zkActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f);\n+        for (String ledgerNode : ledgerNodes) {\n+            if (isSpecialZnode(ledgerNode)) {\n+                continue;\n+            }\n+            try {\n+                // convert the node path to ledger id according to different ledger manager implementation\n+                zkActiveLedgers.add(getLedgerId(path + \"/\" + ledgerNode));\n+            } catch (IOException e) {\n+                LOG.warn(\"Error extracting ledgerId from ZK ledger node: \" + ledgerNode);\n+                // This is a pretty bad error as it indicates a ledger node in ZK\n+                // has an incorrect format. For now just continue and consider\n+                // this as a non-existent ledger.\n+                continue;\n             }\n         }\n+        return zkActiveLedgers;\n+    }\n+\n+    @Override\n+    public void close() {\n     }\n }"},{"sha":"542b4986359391b88bbaa65e65db20fd9bf24da0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/bookkeeper/blob/a3da8c74c4226b7d92e9d0eba9591334351afa45/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/a3da8c74c4226b7d92e9d0eba9591334351afa45/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ActiveLedgerManager.java?ref=a3da8c74c4226b7d92e9d0eba9591334351afa45","patch":"@@ -1,84 +0,0 @@\n-package org.apache.bookkeeper.meta;\n-\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import java.io.Closeable;\n-\n-/**\n- * ActiveLedgerManager takes responsibility of active ledger management in bookie side.\n- *\n- * <ul>\n- * <li>How to manager active ledgers (so know how to do garbage collection)\n- * <li>How to garbage collect inactive/deleted ledgers\n- * </ul>\n- */\n-public interface ActiveLedgerManager extends Closeable {\n-\n-    /**\n-     * Add active ledger\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     * @param active\n-     *          Status of ledger\n-     */\n-    public void addActiveLedger(long ledgerId, boolean active);\n-\n-    /**\n-     * Remove active ledger\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     */\n-    public void removeActiveLedger(long ledgerId);\n-\n-    /**\n-     * Is Ledger ledgerId in active ledgers set\n-     *\n-     * @param ledgerId\n-     *          Ledger ID\n-     * @return true if the ledger is in active ledgers set, otherwise return false\n-     */\n-    public boolean containsActiveLedger(long ledgerId);\n-\n-    /**\n-     * Garbage Collector which handles ledger deletion in server side\n-     */\n-    public static interface GarbageCollector {\n-        /**\n-         * garbage collecting a specific ledger\n-         *\n-         * @param ledgerId\n-         *          Ledger ID to be garbage collected\n-         */\n-        public void gc(long ledgerId);\n-    }\n-\n-    /**\n-     * Garbage collecting all inactive/deleted ledgers\n-     * <p>\n-     * GarbageCollector#gc is triggered each time we found a ledger could be garbage collected.\n-     * After method finished, all those inactive ledgers should be garbage collected.\n-     * </p>\n-     *\n-     * @param gc garbage collector\n-     */\n-    public void garbageCollectLedgers(GarbageCollector gc);\n-\n-}"},{"sha":"6cd38ff08a62fd8d2333ecffa9b402efb1437f5c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"modified","additions":25,"deletions":34,"changes":59,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -19,15 +19,14 @@\n  */\n \n import java.io.IOException;\n-import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.zookeeper.AsyncCallback;\n@@ -47,18 +46,6 @@\n  * All ledgers' metadata are put in a single zk node, created using zk sequential node.\n  * Each ledger node is prefixed with 'L'.\n  * </p>\n- * <p>\n- * All actived ledgers found in bookie server side is managed in a hash map.\n- * </p>\n- * <p>\n- * Garbage collection in FlatLedgerManager is procssed as below:\n- * <ul>\n- * <li> fetch all existed ledgers from zookeeper, said <b>zkActiveLedgers</b>\n- * <li> fetch all active ledgers from bookie server, said <b>bkActiveLedgers</b>\n- * <li> loop over <b>bkActiveLedgers</b> to find those ledgers aren't existed in\n- * <b>zkActiveLedgers</b>, do garbage collection on them.\n- * </ul>\n- * </p>\n  */\n class FlatLedgerManager extends AbstractZkLedgerManager {\n \n@@ -80,8 +67,7 @@\n     public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n         super(conf, zk);\n \n-        ledgerPrefix = ledgerRootPath + \"/\"\n-                + BookKeeperConstants.LEDGER_NODE_PREFIX;\n+        ledgerPrefix = ledgerRootPath + \"/\" + StringUtils.LEDGER_NODE_PREFIX;\n     }\n \n     @Override\n@@ -139,24 +125,29 @@ public void asyncProcessLedgers(final Processor<Long> processor,\n     }\n \n     @Override\n-    public void garbageCollectLedgers(GarbageCollector gc) {\n-        if (null == zk) {\n-            LOG.warn(\"Skip garbage collecting ledgers because there is no ZooKeeper handle.\");\n-            return;\n-        }\n-        try {\n-            // create a snapshot first\n-            Map<Long, Boolean> bkActiveLedgers = activeLedgers.snapshot();\n-            Set<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"All active ledgers from ZK: {}. Current active ledgers from Bookie: {}.\",\n-                    zkActiveLedgers, bkActiveLedgers.keySet());\n+    public LedgerRangeIterator getLedgerRanges() {\n+        return new LedgerRangeIterator() {\n+            // single iterator, can visit only one time\n+            boolean hasMoreElement = true;\n+            @Override\n+            public boolean hasNext() {\n+                return hasMoreElement;\n             }\n-            doGc(gc, bkActiveLedgers, zkActiveLedgers);\n-        } catch (IOException ie) {\n-            LOG.warn(\"Error during garbage collecting ledgers from \" + ledgerRootPath, ie);\n-        } catch (InterruptedException inte) {\n-            LOG.warn(\"Interrupted during garbage collecting ledgers from \" + ledgerRootPath, inte);\n-        }\n+            @Override\n+            public LedgerRange next() throws IOException {\n+                if (!hasMoreElement) {\n+                    throw new NoSuchElementException();\n+                }\n+                hasMoreElement = false;\n+                Set<Long> zkActiveLedgers;\n+                try {\n+                    zkActiveLedgers = ledgerListToSet(\n+                            ZkUtils.getChildrenInSingleNode(zk, ledgerRootPath), ledgerRootPath);\n+                } catch (InterruptedException e) {\n+                    throw new IOException(\"Error when get child nodes from zk\", e);\n+                }\n+                return new LedgerRange(zkActiveLedgers);\n+            }\n+        };\n     }\n }"},{"sha":"658883724e726b4740422b4c8e2af26a4b75f010","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManagerFactory.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -68,11 +68,6 @@ public LedgerManager newLedgerManager() {\n         return new FlatLedgerManager(conf, zk);\n     }\n \n-    @Override\n-    public ActiveLedgerManager newActiveLedgerManager() {\n-        return new FlatLedgerManager(conf, zk);\n-    }\n-\n     @Override\n     public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n             throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {"},{"sha":"aee9795093059a302555b12d4288a22003f9f0bc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":102,"deletions":113,"changes":215,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -22,16 +22,15 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.Set;\n-import java.util.Map;\n-import java.util.NavigableMap;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n-import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.zookeeper.AsyncCallback;\n@@ -58,25 +57,7 @@\n  * <pre>(ledgersRootPath)/level1/level2/L(level3)</pre>\n  * E.g Ledger 0000000001 is split into 3 parts <i>00</i>, <i>0000</i>, <i>0001</i>, which is stored in\n  * <i>(ledgersRootPath)/00/0000/L0001</i>. So each znode could have at most 10000 ledgers, which avoids\n- * failed to get children list of a too big znode during garbage collection.\n- * <p>\n- * All actived ledgers found in bookie server is managed in a sorted map, which ease us to pick\n- * up all actived ledgers belongs to (level1, level2).\n- * </p>\n- * <p>\n- * Garbage collection in HierarchicalLedgerManager is processed node by node as below:\n- * <ul>\n- * fetching all level1 nodes, by calling zk#getChildren(ledgerRootPath).\n- * <ul>\n- * for each level1 node, fetching their level2 nodes, by calling zk#getChildren(ledgerRootPath + \"/\" + level1)\n- * <li> fetch all existed ledgers from zookeeper in level1/level2 node, said <b>zkActiveLedgers</b>\n- * <li> fetch all active ledgers from bookie server in level1/level2, said <b>bkActiveLedgers</b>\n- * <li> loop over <b>bkActiveLedgers</b> to find those ledgers aren't existed in <b>zkActiveLedgers</b>, do garbage collection on them.\n- * </ul>\n- * </ul>\n- * Since garbage collection is running in background, HierarchicalLedgerManager did gc on single hash\n- * node at a time to avoid consuming too much resources.\n- * </p>\n+ * errors during garbage collection due to lists of children that are too long.\n  */\n class HierarchicalLedgerManager extends AbstractZkLedgerManager {\n \n@@ -196,15 +177,7 @@ private long getLedgerIdFromGenPath(String nodeName) throws IOException {\n \n     @Override\n     public String getLedgerPath(long ledgerId) {\n-        String ledgerIdStr = StringUtils.getZKStringId(ledgerId);\n-        // do 2-4-4 split\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(ledgerRootPath).append(\"/\").append(\n-                ledgerIdStr.substring(0, 2)).append(\"/\").append(\n-                ledgerIdStr.substring(2, 6)).append(\"/\").append(\n-                BookKeeperConstants.LEDGER_NODE_PREFIX).append(\n-                ledgerIdStr.substring(6, 10));\n-        return sb.toString();\n+        return ledgerRootPath + StringUtils.getHierarchicalLedgerPath(ledgerId);\n     }\n \n     @Override\n@@ -213,26 +186,12 @@ public long getLedgerId(String pathName) throws IOException {\n             throw new IOException(\"it is not a valid hashed path name : \" + pathName);\n         }\n         String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n-        String[] hierarchicalParts = hierarchicalPath.split(\"/\");\n-        if (hierarchicalParts.length != 3) {\n-            throw new IOException(\"it is not a valid hierarchical path name : \" + pathName);\n-        }\n-        hierarchicalParts[2] = hierarchicalParts[2]\n-                .substring(BookKeeperConstants.LEDGER_NODE_PREFIX.length());\n-        return getLedgerId(hierarchicalParts);\n+        return StringUtils.stringToHierarchicalLedgerId(hierarchicalPath);\n     }\n \n     // get ledger from all level nodes\n     private long getLedgerId(String...levelNodes) throws IOException {\n-        try {\n-            StringBuilder sb = new StringBuilder();\n-            for (String node : levelNodes) {\n-                sb.append(node);\n-            }\n-            return Long.parseLong(sb.toString());\n-        } catch (NumberFormatException e) {\n-            throw new IOException(e);\n-        }\n+        return StringUtils.stringToHierarchicalLedgerId(levelNodes);\n     }\n \n     //\n@@ -333,71 +292,6 @@ public void processResult(int rc, String path, Object ctx,\n         }, null);\n     }\n \n-    @Override\n-    public void garbageCollectLedgers(GarbageCollector gc) {\n-        if (null == zk) {\n-            LOG.warn(\"Skip garbage collecting ledgers because there is no ZooKeeper handle.\");\n-            return;\n-        }\n-        // create a snapshot before garbage collection\n-        NavigableMap<Long, Boolean> snapshot = activeLedgers.snapshot();\n-        try {\n-            List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n-            for (String l1Node : l1Nodes) {\n-                if (isSpecialZnode(l1Node)) {\n-                    continue;\n-                }\n-                try {\n-                    List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + l1Node, null);\n-                    for (String l2Node : l2Nodes) {\n-                        doGcByLevel(gc, l1Node, l2Node, snapshot);\n-                    }\n-                } catch (Exception e) {\n-                    LOG.warn(\"Exception during garbage collecting ledgers for \" + l1Node\n-                             + \" of \" + ledgerRootPath, e);\n-                }\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Exception during garbage collecting inactive/deleted ledgers\", e);\n-        }\n-    }\n-\n-    /**\n-     * Garbage collection a single node level1/level2\n-     *\n-     * @param gc\n-     *          Garbage collector\n-     * @param level1\n-     *          1st level node name\n-     * @param level2\n-     *          2nd level node name\n-     * @param snapshot\n-     *          Snapshot of the active ledgers map.\n-     * @throws IOException\n-     * @throws InterruptedException\n-     */\n-    void doGcByLevel(GarbageCollector gc, final String level1, final String level2,\n-                     NavigableMap snapshot)\n-        throws IOException, InterruptedException {\n-\n-        StringBuilder nodeBuilder = new StringBuilder();\n-        nodeBuilder.append(ledgerRootPath).append(\"/\")\n-                   .append(level1).append(\"/\").append(level2);\n-        String nodePath = nodeBuilder.toString();\n-\n-        Set<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n-        // get hosted ledgers in /level1/level2\n-        long startLedgerId = getStartLedgerIdByLevel(level1, level2);\n-        long endLedgerId = getEndLedgerIdByLevel(level1, level2);\n-        Map<Long, Boolean> bkActiveLedgers = snapshot.subMap(startLedgerId, true, endLedgerId, true);\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"For hash node: \" + level1 + \"/\" + level2 + \": All active ledgers from ZK: \"\n-                      + zkActiveLedgers + \". Current active ledgers from Bookie: \"+ bkActiveLedgers);\n-        }\n-\n-        doGc(gc, bkActiveLedgers, zkActiveLedgers);\n-    }\n-\n     /**\n      * Process list one by one in asynchronize way. Process will be stopped immediately\n      * when error occurred.\n@@ -474,4 +368,99 @@ public final void run() {\n     protected boolean isSpecialZnode(String znode) {\n         return IDGEN_ZNODE.equals(znode) || super.isSpecialZnode(znode);\n     }\n+\n+    @Override\n+    public LedgerRangeIterator getLedgerRanges() {\n+        return new HierarchicalLedgerRangeIterator();\n+    }\n+\n+    /**\n+     * Iterator through each metadata bucket with hierarchical mode\n+     */\n+    private class HierarchicalLedgerRangeIterator implements LedgerRangeIterator {\n+        private Iterator<String> l1NodesIter = null;\n+        private Iterator<String> l2NodesIter = null;\n+        private String curL1Nodes = \"\";\n+        private boolean hasMoreElement = true;\n+\n+        /**\n+         * iterate next level1 znode\n+         *\n+         * @return false if have visited all level1 nodes\n+         * @throws InterruptedException/KeeperException if error occurs reading zookeeper children\n+         */\n+        private boolean nextL1Node() throws KeeperException, InterruptedException {\n+            l2NodesIter = null;\n+            while (l2NodesIter == null) {\n+                if (l1NodesIter.hasNext()) {\n+                    curL1Nodes = l1NodesIter.next();\n+                } else {\n+                    return false;\n+                }\n+                if (isSpecialZnode(curL1Nodes)) {\n+                    continue;\n+                }\n+                List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + curL1Nodes, null);\n+                l2NodesIter = l2Nodes.iterator();\n+                if (!l2NodesIter.hasNext()) {\n+                    l2NodesIter = null;\n+                    continue;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException {\n+            try {\n+                if (l1NodesIter == null) {\n+                    l1NodesIter = zk.getChildren(ledgerRootPath, null).iterator();\n+                    hasMoreElement = nextL1Node();\n+                } else if (!l2NodesIter.hasNext()) {\n+                    hasMoreElement = nextL1Node();\n+                }\n+            } catch (Exception e) {\n+                throw new IOException(\"Error when check more elements\", e);\n+            }\n+            return hasMoreElement;\n+        }\n+\n+        @Override\n+        public LedgerRange next() throws IOException {\n+            if (!hasMoreElement) {\n+                throw new NoSuchElementException();\n+            }\n+            return getLedgerRangeByLevel(curL1Nodes, l2NodesIter.next());\n+        }\n+\n+        /**\n+         * Get a single node level1/level2\n+         *\n+         * @param level1\n+         *          1st level node name\n+         * @param level2\n+         *          2nd level node name\n+         * @throws IOException\n+         */\n+        LedgerRange getLedgerRangeByLevel(final String level1, final String level2)\n+                throws IOException {\n+            StringBuilder nodeBuilder = new StringBuilder();\n+            nodeBuilder.append(ledgerRootPath).append(\"/\")\n+                       .append(level1).append(\"/\").append(level2);\n+            String nodePath = nodeBuilder.toString();\n+            List<String> ledgerNodes = null;\n+            try {\n+                ledgerNodes = ZkUtils.getChildrenInSingleNode(zk, nodePath);\n+            } catch (InterruptedException e) {\n+                throw new IOException(\"Error when get child nodes from zk\", e);\n+            }\n+            Set<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, nodePath);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"All active ledgers from ZK for hash node \"\n+                          + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n+            }\n+            return new LedgerRange(zkActiveLedgers,\n+                    getStartLedgerIdByLevel(level1, level2), getEndLedgerIdByLevel(level1, level2));\n+        }\n+    }\n }"},{"sha":"974a3249d7937bc2a950a6f751cef33640fef23c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -68,11 +68,6 @@ public LedgerManager newLedgerManager() {\n         return new HierarchicalLedgerManager(conf, zk);\n     }\n \n-    @Override\n-    public ActiveLedgerManager newActiveLedgerManager() {\n-        return new HierarchicalLedgerManager(conf, zk);\n-    }\n-\n     @Override\n     public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n             throws KeeperException, InterruptedException, ReplicationException.CompatibilityException{"},{"sha":"5c5ecf8725f0ec7439cf50a4380d9f1ded2133fd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","status":"modified","additions":96,"deletions":6,"changes":102,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -19,11 +19,15 @@\n  */\n \n import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Set;\n \n import org.apache.zookeeper.AsyncCallback;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.versioning.Version;\n \n /**\n  * LedgerManager takes responsibility of ledger management in client side.\n@@ -41,18 +45,25 @@\n      *        Metadata provided when creating a new ledger\n      * @param cb\n      *        Callback when creating a new ledger.\n+     *        {@link BKException.Code.ZKException} return code when can't generate\n+     *        or extract new ledger id\n      */\n-    public abstract void createLedger(LedgerMetadata metadata, GenericCallback<Long> cb);\n+    public void createLedger(LedgerMetadata metadata, GenericCallback<Long> cb);\n \n     /**\n-     * Delete a specified ledger by ledgerId.\n+     * Remove a specified ledger metadata by ledgerId and version.\n      *\n      * @param ledgerId\n      *          Ledger Id\n+     * @param version\n+     *          Ledger metadata version\n      * @param cb\n-     *          Callback when deleted ledger.\n+     *          Callback when removed ledger metadata.\n+     *          {@link BKException.Code.MetadataVersionException} return code when version doesn't match,\n+     *          {@link BKException.Code.NoSuchLedgerExistsException} return code when ledger doesn't exist,\n+     *          {@link BKException.Code.ZKException} return code when other issues happen.\n      */\n-    public abstract void deleteLedger(long ledgerId, GenericCallback<Void> cb);\n+    public void removeLedgerMetadata(long ledgerId, Version version, GenericCallback<Void> vb);\n \n     /**\n      * Read ledger metadata of a specified ledger.\n@@ -61,8 +72,10 @@\n      *          Ledger Id\n      * @param readCb\n      *          Callback when read ledger metadata.\n+     *          {@link BKException.Code.NoSuchLedgerExistsException} return code when ledger doesn't exist,\n+     *          {@link BKException.Code.ZKException} return code when other issues happen.\n      */\n-    public abstract void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb);\n+    public void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb);\n \n     /**\n      * Write ledger metadata.\n@@ -73,8 +86,10 @@\n      *          Ledger Metadata to write\n      * @param cb\n      *          Callback when finished writing ledger metadata.\n+     *          {@link BKException.Code.MetadataVersionException} return code when version doesn't match,\n+     *          {@link BKException.Code.ZKException} return code when other issues happen.\n      */\n-    public abstract void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata, GenericCallback<Void> cb);\n+    public void writeLedgerMetadata(long ledgerId, LedgerMetadata metadata, GenericCallback<Void> cb);\n \n     /**\n      * Loop to process all ledgers.\n@@ -99,4 +114,79 @@\n      */\n     public void asyncProcessLedgers(Processor<Long> processor, AsyncCallback.VoidCallback finalCb,\n                                     Object context, int successRc, int failureRc);\n+\n+    /**\n+     * Loop to scan a range of metadata from metadata storage\n+     *\n+     * @return will return a iterator of the Ranges\n+     */\n+    public LedgerRangeIterator getLedgerRanges();\n+\n+    /*\n+     * Used to represent the Ledgers range returned from the\n+     * current scan.\n+     */\n+    public static class LedgerRange {\n+        // ledger start and end ranges\n+        private final long start;\n+        private final long end;\n+        public final static long NOLIMIT = -1;\n+\n+        // returned ledgers\n+        private Set<Long> ledgers;\n+\n+        public LedgerRange(Set<Long> ledgers) {\n+            this(ledgers, NOLIMIT, NOLIMIT);\n+        }\n+\n+        public LedgerRange(Set<Long> ledgers, long start) {\n+            this(ledgers, start, NOLIMIT);\n+        }\n+\n+        public LedgerRange(Set<Long> ledgers, long start, long end) {\n+            this.ledgers = ledgers;\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        public Long start() {\n+            return this.start;\n+        }\n+\n+        public Long end() {\n+            return this.end;\n+        }\n+\n+        public Set<Long> getLedgers() {\n+            return this.ledgers;\n+        }\n+    }\n+\n+    /**\n+     * Interface of the ledger meta range iterator from\n+     * storage (e.g. in ZooKeeper or other key/value store)\n+     */\n+    interface LedgerRangeIterator {\n+\n+        /**\n+         * @return true if there are records in the ledger metadata store. false\n+         * only when there are indeed no records in ledger metadata store.\n+         * @throws IOException thrown when there is any problem accessing the ledger\n+         * metadata store. It is critical that it doesn't return false in the case\n+         * in the case it fails to access the ledger metadata store. Otherwise it\n+         * will end up deleting all ledgers by accident.\n+         */\n+        public boolean hasNext() throws IOException;\n+\n+        /**\n+         * Get the next element.\n+         *\n+         * @return the next element.\n+         * @throws IOException thrown when there is a problem accessing the ledger\n+         * metadata store. It is critical that it doesn't return false in the case\n+         * in the case it fails to access the ledger metadata store. Otherwise it\n+         * will end up deleting all ledgers by accident.\n+         */\n+        public LedgerRange next() throws IOException;\n+    }\n }"},{"sha":"70fdda044b4287ab6387351b637744ad92ae7775","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"modified","additions":1,"deletions":9,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -76,15 +76,7 @@ public abstract LedgerManagerFactory initialize(final AbstractConfiguration conf\n     public abstract LedgerManager newLedgerManager();\n \n     /**\n-     * return active ledger manager for server side to manage active ledgers.\n-     *\n-     * @return active ledger manager\n-     * @see ActiveLedgerManager\n-     */\n-    public abstract ActiveLedgerManager newActiveLedgerManager();\n-\n-    /**\n-     * Return a ledger underreplication manager, which is used to \n+     * Return a ledger underreplication manager, which is used to\n      * mark ledgers as unreplicated, and to retrieve a ledger which\n      * is underreplicated so that it can be rereplicated.\n      *"},{"sha":"106dac5a45c81e850e273fb004e7ca7aa1eed490","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","status":"modified","additions":60,"deletions":150,"changes":210,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -17,20 +17,17 @@\n  */\n package org.apache.bookkeeper.meta;\n \n-import static org.apache.bookkeeper.metastore.MetastoreScannableTable.EMPTY_END_KEY;\n import static org.apache.bookkeeper.metastore.MetastoreTable.ALL_FIELDS;\n import static org.apache.bookkeeper.metastore.MetastoreTable.NON_FIELDS;\n \n-import java.io.Closeable;\n import java.io.IOException;\n import java.util.Iterator;\n-import java.util.Map;\n-import java.util.NavigableMap;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.CountDownLatch;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n@@ -43,7 +40,6 @@\n import org.apache.bookkeeper.metastore.MetastoreException;\n import org.apache.bookkeeper.metastore.MetastoreFactory;\n import org.apache.bookkeeper.metastore.MetastoreScannableTable;\n-import org.apache.bookkeeper.metastore.MetastoreScannableTable.Order;\n import org.apache.bookkeeper.metastore.MetastoreTableItem;\n import org.apache.bookkeeper.metastore.Value;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -171,16 +167,25 @@ public synchronized T getResult() {\n         }\n     }\n \n-    static abstract class AbstractMsLedgerManager implements Closeable {\n-\n+    static class MsLedgerManager implements LedgerManager {\n         final ZooKeeper zk;\n         final AbstractConfiguration conf;\n \n         final MetaStore metastore;\n         final MetastoreScannableTable ledgerTable;\n         final int maxEntriesPerScan;\n \n-        AbstractMsLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n+        static final String IDGEN_ZNODE = \"ms-idgen\";\n+        static final String IDGENERATION_PREFIX = \"/\" + IDGEN_ZNODE + \"/ID-\";\n+\n+        // Path to generate global id\n+        private final String idGenPath;\n+\n+        // we use this to prevent long stack chains from building up in\n+        // callbacks\n+        ScheduledExecutorService scheduler;\n+\n+        MsLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n             this.conf = conf;\n             this.zk = zk;\n             this.metastore = metastore;\n@@ -194,29 +199,7 @@ public synchronized T getResult() {\n             }\n             // configuration settings\n             maxEntriesPerScan = conf.getMetastoreMaxEntriesPerScan();\n-        }\n-\n-        @Override\n-        public void close() {\n-            ledgerTable.close();\n-        }\n-\n-    }\n \n-    static class MsLedgerManager extends AbstractMsLedgerManager implements LedgerManager {\n-\n-        static final String IDGEN_ZNODE = \"ms-idgen\";\n-        static final String IDGENERATION_PREFIX = \"/\" + IDGEN_ZNODE + \"/ID-\";\n-\n-        // Path to generate global id\n-        private final String idGenPath;\n-\n-        // we use this to prevent long stack chains from building up in\n-        // callbacks\n-        ScheduledExecutorService scheduler;\n-\n-        MsLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n-            super(conf, zk, metastore);\n             this.idGenPath = conf.getZkLedgersRootPath() + IDGENERATION_PREFIX;\n             this.scheduler = Executors.newSingleThreadScheduledExecutor();\n         }\n@@ -228,7 +211,7 @@ public void close() {\n             } catch (Exception e) {\n                 LOG.warn(\"Error when closing MsLedgerManager : \", e);\n             }\n-            super.close();\n+            ledgerTable.close();\n         }\n \n         @Override\n@@ -305,7 +288,8 @@ private long getLedgerIdFromGenPath(String nodeName) throws IOException {\n         }\n \n         @Override\n-        public void deleteLedger(final long ledgerId, final GenericCallback<Void> cb) {\n+        public void removeLedgerMetadata(final long ledgerId, final Version version,\n+                                         final GenericCallback<Void> cb) {\n             MetastoreCallback<Void> msCallback = new MetastoreCallback<Void>() {\n                 @Override\n                 public void complete(int rc, Void value, Object ctx) {\n@@ -321,7 +305,7 @@ public void complete(int rc, Void value, Object ctx) {\n                     cb.operationComplete(bkRc, (Void) null);\n                 }\n             };\n-            ledgerTable.remove(ledgerId2Key(ledgerId), Version.ANY, msCallback, null);\n+            ledgerTable.remove(ledgerId2Key(ledgerId), version, msCallback, null);\n         }\n \n         @Override\n@@ -475,129 +459,60 @@ public void processResult(int rc, String path, Object ctx) {\n             };\n             cursor.asyncReadEntries(maxEntriesPerScan, msCallback, null);\n         }\n-    }\n-\n-    static class MsActiveLedgerManager extends AbstractMsLedgerManager implements ActiveLedgerManager {\n \n-        // A sorted map to stored all active ledger ids\n-        protected final SnapshotMap<Long, Boolean> activeLedgers;\n-\n-        MsActiveLedgerManager(final AbstractConfiguration conf, final ZooKeeper zk, final MetaStore metastore) {\n-            super(conf, zk, metastore);\n-            activeLedgers = new SnapshotMap<Long, Boolean>();\n-        }\n-\n-        @Override\n-        public void addActiveLedger(long ledgerId, boolean active) {\n-            activeLedgers.put(ledgerId, active);\n-        }\n-\n-        @Override\n-        public void removeActiveLedger(long ledgerId) {\n-            activeLedgers.remove(ledgerId);\n-        }\n-\n-        @Override\n-        public boolean containsActiveLedger(long ledgerId) {\n-            return activeLedgers.containsKey(ledgerId);\n-        }\n-\n-        @Override\n-        public void garbageCollectLedgers(GarbageCollector gc) {\n-            LOG.debug(\"Start garbage collect ledgers.\");\n-            NavigableMap<Long, Boolean> snapshot = activeLedgers.snapshot();\n-            Long nextLedger = 0L;\n-            int numRetries = 3;\n-            do {\n-                nextLedger = doGcLedgers(nextLedger, snapshot, gc);\n-            } while (null != nextLedger && --numRetries > 0);\n-            LOG.debug(\"End garbage collect ledgers.\");\n-        }\n-\n-        /**\n-         * Do garbage collection starting from <code>startLedger</code>.\n-         *\n-         * @param startLedgerId\n-         *            Start Ledger id\n-         * @param snapshot\n-         *            Current snapshot of active ledgers\n-         * @param gc\n-         *            Garbage collector\n-         * @return null if finished scanning all ledgers, the next ledger id to\n-         *         scan\n-         */\n-        private Long doGcLedgers(Long startLedgerId, NavigableMap<Long, Boolean> snapshot, GarbageCollector gc) {\n-            final SyncResult<MetastoreCursor> result = new SyncResult<MetastoreCursor>();\n-            MetastoreCallback<MetastoreCursor> openCursorCb = new MetastoreCallback<MetastoreCursor>() {\n-                @Override\n-                public void complete(int rc, MetastoreCursor cursor, Object ctx) {\n-                    result.complete(rc, cursor);\n-                }\n-            };\n-            ledgerTable.openCursor(ledgerId2Key(startLedgerId), true, EMPTY_END_KEY, true, Order.ASC, NON_FIELDS,\n-                    openCursorCb, null);\n-            result.block();\n-            if (MSException.Code.OK.getCode() != result.getRetCode()) {\n-                LOG.warn(\"Failed to open metastore cursor to run garbage collection : \",\n-                        MSException.create(MSException.Code.get(result.getRetCode())));\n-                // failed to open a cursor, not continue until next gc\n-                return null;\n+        class MSLedgerRangeIterator implements LedgerRangeIterator {\n+            final CountDownLatch openCursorLatch = new CountDownLatch(1);\n+            MetastoreCursor cursor = null;\n+\n+            MSLedgerRangeIterator() {\n+                MetastoreCallback<MetastoreCursor> openCursorCb = new MetastoreCallback<MetastoreCursor>() {\n+                    @Override\n+                    public void complete(int rc, MetastoreCursor newCursor, Object ctx) {\n+                        if (MSException.Code.OK.getCode() != rc) {\n+                            LOG.error(\"Error opening cursor for ledger range iterator {}\", rc);\n+                        } else {\n+                            cursor = newCursor;\n+                        }\n+                        openCursorLatch.countDown();\n+                    }\n+                };\n+                ledgerTable.openCursor(NON_FIELDS, openCursorCb, null);\n             }\n \n-            MetastoreCursor cursor = result.getResult();\n-\n-            while (cursor.hasMoreEntries()) {\n-                Iterator<MetastoreTableItem> entries;\n+            @Override\n+            public boolean hasNext() {\n                 try {\n-                    entries = cursor.readEntries(maxEntriesPerScan);\n-                } catch (MSException mse) {\n-                    LOG.warn(\"Exception when garbage collecting deleted ledgers : \", mse);\n-                    return startLedgerId;\n+                    openCursorLatch.await();\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupted waiting for cursor to open\", ie);\n+                    Thread.currentThread().interrupt();\n+                    return false;\n                 }\n-\n-                if (!entries.hasNext()) {\n-                    continue;\n+                if (cursor == null) {\n+                    return false;\n                 }\n+                return cursor.hasMoreEntries();\n+            }\n \n-                SortedSet<Long> msActiveLedgers = entries2Ledgers(entries);\n-\n-                Long endLedgerId = msActiveLedgers.last();\n-                Map<Long, Boolean> bkActiveLedgers = snapshot.subMap(startLedgerId, true, endLedgerId, true);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"All active ledgers from Metastore between {} and {} : {}\", new Object[] { startLedgerId,\n-                            endLedgerId, msActiveLedgers });\n-                    LOG.debug(\"Current active ledgers from Bookie between {} and {} : {}\", new Object[] {\n-                            startLedgerId, endLedgerId, bkActiveLedgers });\n+            @Override\n+            public LedgerRange next() throws IOException {\n+                try {\n+                    Set<Long> ledgerIds = new TreeSet<Long>();\n+                    Iterator<MetastoreTableItem> iter = cursor.readEntries(maxEntriesPerScan);\n+                    while (iter.hasNext()) {\n+                        ledgerIds.add(key2LedgerId(iter.next().getKey()));\n+                    }\n+                    return new LedgerRange(ledgerIds);\n+                } catch (MSException mse) {\n+                    LOG.error(\"Exception occurred reading from metastore\", mse);\n+                    throw new IOException(\"Couldn't read from metastore\", mse);\n                 }\n-                doGc(gc, bkActiveLedgers, msActiveLedgers);\n-                // move the pointer\n-                startLedgerId = endLedgerId + 1;\n             }\n-            doGc(gc, snapshot.tailMap(startLedgerId), new TreeSet<Long>());\n-            return null;\n         }\n \n-        /**\n-         * Do garbage collecting comparing hosted ledgers and metastore ledgers\n-         *\n-         * @param gc\n-         *            Garbage collector to do garbage collection when found\n-         *            inactive/deleted ledgers\n-         * @param bkActiveLedgers\n-         *            Active ledgers hosted in bookie server\n-         * @param msAllLedgers\n-         *            All ledgers stored in metastore\n-         */\n-        void doGc(GarbageCollector gc, Map<Long, Boolean> bkActiveLedgers, Set<Long> msAllLedgers) {\n-            // remove any active ledgers that doesn't exist in zk\n-            for (Long bkLid : bkActiveLedgers.keySet()) {\n-                if (!msAllLedgers.contains(bkLid)) {\n-                    // remove it from current active ledger\n-                    LOG.debug(\"gc ledger: {}\", bkLid);\n-                    bkActiveLedgers.remove(bkLid);\n-                    gc.gc(bkLid);\n-                }\n-            }\n+        @Override\n+        public LedgerRangeIterator getLedgerRanges() {\n+            return new MSLedgerRangeIterator();\n         }\n     }\n \n@@ -606,11 +521,6 @@ public LedgerManager newLedgerManager() {\n         return new MsLedgerManager(conf, zk, metastore);\n     }\n \n-    @Override\n-    public ActiveLedgerManager newActiveLedgerManager() {\n-        return new MsActiveLedgerManager(conf, zk, metastore);\n-    }\n-\n     @Override\n     public LedgerUnderreplicationManager newLedgerUnderreplicationManager() throws KeeperException,\n             InterruptedException, ReplicationException.CompatibilityException {"},{"sha":"a665476b89ef74341c36892b02ad7eca5d4a6b65","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","status":"renamed","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -1,4 +1,4 @@\n-package org.apache.bookkeeper.meta;\n+package org.apache.bookkeeper.util;\n \n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -18,7 +18,6 @@\n  * limitations under the License.\n  */\n \n-import java.io.IOException;\n import java.util.concurrent.ConcurrentSkipListMap;\n import java.util.concurrent.ConcurrentHashMap;\n \n@@ -29,7 +28,7 @@\n /**\n  * A snapshotable map.\n  */\n-class SnapshotMap<K, V> {\n+public class SnapshotMap<K, V> {\n     // stores recent updates\n     volatile Map<K, V> updates;\n     volatile Map<K, V> updatesToMerge;","previous_filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java"},{"sha":"b6ea86eb47eef847e808f81c307eccfa0dc274b9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":60,"deletions":2,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -20,8 +20,6 @@\n \n import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.UnknownHostException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n \n /**\n  * Provided utilites for parsing network addresses, ledger-id from node paths\n@@ -30,6 +28,9 @@\n  */\n public class StringUtils {\n \n+    // Ledger Node Prefix\n+    static public final String LEDGER_NODE_PREFIX = \"L\";\n+\n     /**\n      * Parses address into IP and port.\n      *\n@@ -68,4 +69,61 @@ public static String getZKStringId(long id) {\n         return String.format(\"%010d\", id);\n     }\n \n+    /**\n+     * Get the hierarchical ledger path according to the ledger id\n+     *\n+     * @param ledgerId\n+     *          ledger id\n+     * @return the hierarchical path\n+     */\n+    public static String getHierarchicalLedgerPath(long ledgerId) {\n+        String ledgerIdStr = getZKStringId(ledgerId);\n+        // do 2-4-4 split\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"/\")\n+          .append(ledgerIdStr.substring(0, 2)).append(\"/\")\n+          .append(ledgerIdStr.substring(2, 6)).append(\"/\")\n+          .append(LEDGER_NODE_PREFIX)\n+          .append(ledgerIdStr.substring(6, 10));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Parse the hierarchical ledger path to its ledger id\n+     *\n+     * @param hierarchicalLedgerPath\n+     * @return the ledger id\n+     * @throws IOException\n+     */\n+    public static long stringToHierarchicalLedgerId(String hierarchicalLedgerPath)\n+            throws IOException {\n+        String[] hierarchicalParts = hierarchicalLedgerPath.split(\"/\");\n+        if (hierarchicalParts.length != 3) {\n+            throw new IOException(\"it is not a valid hierarchical path name : \" + hierarchicalLedgerPath);\n+        }\n+        hierarchicalParts[2] =\n+            hierarchicalParts[2].substring(LEDGER_NODE_PREFIX.length());\n+        return stringToHierarchicalLedgerId(hierarchicalParts);\n+    }\n+\n+    /**\n+     * Get ledger id\n+     *\n+     * @param levelNodes\n+     *          level of the ledger path\n+     * @return ledger id\n+     * @throws IOException\n+     */\n+    public static long stringToHierarchicalLedgerId(String...levelNodes) throws IOException {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            for (String node : levelNodes) {\n+                sb.append(node);\n+            }\n+            return Long.parseLong(sb.toString());\n+        } catch (NumberFormatException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n }"},{"sha":"05b3d62f4b84965d8aa06e880fd0a0a8b9349eea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","status":"modified","additions":90,"deletions":2,"changes":92,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -25,6 +25,7 @@\n import java.io.IOException;\n import java.util.List;\n \n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.AsyncCallback;\n@@ -33,12 +34,14 @@\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Provided utilites for zookeeper access, etc.\n  */\n public class ZkUtils {\n-\n+    private static final Logger LOG = LoggerFactory.getLogger(ZkUtils.class);\n     /**\n      * Create zookeeper path recursively\n      *\n@@ -94,10 +97,95 @@ public void processResult(int rc, String path, Object ctx, String name) {\n \n     }\n \n+    private static class GetChildrenCtx {\n+        int rc;\n+        boolean done = false;\n+        List<String> children = null;\n+    }\n+\n+    /**\n+     * Sync get all children under single zk node\n+     *\n+     * @param zk\n+     *          zookeeper client\n+     * @param node\n+     *          node path\n+     * @return direct children\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+    public static List<String> getChildrenInSingleNode(final ZooKeeper zk, final String node)\n+            throws InterruptedException, IOException {\n+        final GetChildrenCtx ctx = new GetChildrenCtx();\n+        getChildrenInSingleNode(zk, node, new GenericCallback<List<String>>() {\n+            @Override\n+            public void operationComplete(int rc, List<String> ledgers) {\n+                synchronized (ctx) {\n+                    if (Code.OK.intValue() == rc) {\n+                        ctx.children = ledgers;\n+                    }\n+                    ctx.rc = rc;\n+                    ctx.done = true;\n+                    ctx.notifyAll();\n+                }\n+            }\n+        });\n+\n+        synchronized (ctx) {\n+            while (ctx.done == false) {\n+                ctx.wait();\n+            }\n+        }\n+        if (Code.OK.intValue() != ctx.rc) {\n+            throw new IOException(\"Error on getting children from node \" + node);\n+        }\n+        return ctx.children;\n+\n+    }\n+\n+    /**\n+     * Async get direct children under single node\n+     *\n+     * @param zk\n+     *          zookeeper client\n+     * @param node\n+     *          node path\n+     * @param cb\n+     *          callback function\n+     */\n+    public static void getChildrenInSingleNode(final ZooKeeper zk, final String node,\n+            final GenericCallback<List<String>> cb) {\n+        zk.sync(node, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"ZK error syncing nodes when getting children: \", KeeperException\n+                            .create(KeeperException.Code.get(rc), path));\n+                    cb.operationComplete(rc, null);\n+                    return;\n+                }\n+                zk.getChildren(node, false, new AsyncCallback.ChildrenCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx, List<String> nodes) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"Error polling ZK for the available nodes: \", KeeperException\n+                                    .create(KeeperException.Code.get(rc), path));\n+                            cb.operationComplete(rc, null);\n+                            return;\n+                        }\n+\n+                        cb.operationComplete(rc, nodes);\n+\n+                    }\n+                }, null);\n+            }\n+        }, null);\n+    }\n+\n     /**\n      * Get new ZooKeeper client. Waits till the connection is complete. If\n      * connection is not successful within timeout, then throws back exception.\n-     * \n+     *\n      * @param servers\n      *            ZK servers connection string.\n      * @param timeout"},{"sha":"4e7fc26a0de72904b1351f656a4ee761af8ff2dc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -27,9 +27,9 @@\n \n import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.ActiveLedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.bookkeeper.util.SnapshotMap;\n import org.apache.commons.io.FileUtils;\n import org.junit.After;\n import org.junit.Assert;\n@@ -47,7 +47,7 @@\n public class LedgerCacheTest extends TestCase {\n     static Logger LOG = LoggerFactory.getLogger(LedgerCacheTest.class);\n \n-    ActiveLedgerManager activeLedgerManager;\n+    SnapshotMap<Long, Boolean> activeLedgers;\n     LedgerManagerFactory ledgerManagerFactory;\n     LedgerCache ledgerCache;\n     ServerConfiguration conf;\n@@ -75,15 +75,14 @@ public void setUp() throws Exception {\n \n         ledgerManagerFactory =\n             LedgerManagerFactory.newLedgerManagerFactory(conf, null);\n-        activeLedgerManager = ledgerManagerFactory.newActiveLedgerManager();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n         ledgerCache = ((InterleavedLedgerStorage) bookie.ledgerStorage).ledgerCache;\n     }\n \n     @Override\n     @After\n     public void tearDown() throws Exception {\n         bookie.ledgerStorage.shutdown();\n-        activeLedgerManager.close();\n         ledgerManagerFactory.uninitialize();\n         FileUtils.deleteDirectory(txnDir);\n         FileUtils.deleteDirectory(ledgerDir);\n@@ -94,7 +93,7 @@ private void newLedgerCache() throws IOException {\n             ledgerCache.close();\n         }\n         ledgerCache = ((InterleavedLedgerStorage) bookie.ledgerStorage).ledgerCache = new LedgerCacheImpl(\n-                conf, activeLedgerManager, bookie.getLedgerDirsManager());\n+                conf, activeLedgers, bookie.getLedgerDirsManager());\n     }\n \n     @Test"},{"sha":"6e15f9fd9852bada31cf583efaacfb99b6029b37","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":12,"deletions":8,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -30,11 +30,13 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.apache.bookkeeper.bookie.GarbageCollector;\n+import org.apache.bookkeeper.bookie.ScanAndCompareGarbageCollector;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.meta.ActiveLedgerManager.GarbageCollector;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.versioning.Version;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -61,7 +63,7 @@ private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n                 @Override\n                 public void operationComplete(int rc, Long ledgerId) {\n                     if (rc == BKException.Code.OK) {\n-                        getActiveLedgerManager().addActiveLedger(ledgerId, true);\n+                        activeLedgers.put(ledgerId, true);\n                         createdLedgers.add(ledgerId);\n                     }\n                     synchronized (expected) {\n@@ -102,7 +104,8 @@ public void testGarbageCollectLedgers() throws Exception {\n         for (int i=0; i<numRemovedLedgers; i++) {\n             long ledgerId = tmpList.get(i);\n             synchronized (removedLedgers) {\n-                getLedgerManager().deleteLedger(ledgerId, new GenericCallback<Void>() {\n+                getLedgerManager().removeLedgerMetadata(ledgerId, Version.ANY,\n+                    new GenericCallback<Void>() {\n                         @Override\n                         public void operationComplete(int rc, Void result) {\n                             synchronized (removedLedgers) {\n@@ -118,14 +121,15 @@ public void operationComplete(int rc, Void result) {\n         final CountDownLatch inGcProgress = new CountDownLatch(1);\n         final CountDownLatch createLatch = new CountDownLatch(1);\n         final CountDownLatch endLatch = new CountDownLatch(2);\n-\n+        final GarbageCollector garbageCollector =\n+                new ScanAndCompareGarbageCollector(getLedgerManager(), activeLedgers);\n         Thread gcThread = new Thread() {\n             @Override\n             public void run() {\n-                getActiveLedgerManager().garbageCollectLedgers(new GarbageCollector() {\n+                garbageCollector.gc(new GarbageCollector.GarbageCleaner() {\n                     boolean paused = false;\n                     @Override\n-                    public void gc(long ledgerId) {\n+                    public void clean(long ledgerId) {\n                         if (!paused) {\n                             inGcProgress.countDown();\n                             try {\n@@ -165,10 +169,10 @@ public void run() {\n \n         // test ledgers\n         for (Long ledger : removedLedgers) {\n-            assertFalse(getActiveLedgerManager().containsActiveLedger(ledger));\n+            assertFalse(activeLedgers.containsKey(ledger));\n         }\n         for (Long ledger : createdLedgers) {\n-            assertTrue(getActiveLedgerManager().containsActiveLedger(ledger));\n+            assertTrue(activeLedgers.containsKey(ledger));\n         }\n     }\n }"},{"sha":"f8fa5f010c05e2ac17ac79e2d0dc72f6bf12c538","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":3,"deletions":14,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/fa13426970bd4b6d7ffc086e776559f87349ef71/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java?ref=fa13426970bd4b6d7ffc086e776559f87349ef71","patch":"@@ -24,8 +24,8 @@\n import java.util.Arrays;\n import java.util.Collection;\n \n-import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.SnapshotMap;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -36,8 +36,6 @@\n import org.junit.runners.Parameterized;\n import org.junit.runners.Parameterized.Parameters;\n \n-import junit.framework.TestCase;\n-\n /**\n  * Test case to run over serveral ledger managers\n  */\n@@ -47,10 +45,11 @@\n \n     LedgerManagerFactory ledgerManagerFactory;\n     LedgerManager ledgerManager = null;\n-    ActiveLedgerManager activeLedgerManager = null;\n+    SnapshotMap<Long, Boolean> activeLedgers = null;\n \n     public LedgerManagerTestCase(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n         super(0);\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n         baseConf.setLedgerManagerFactoryClass(lmFactoryCls);\n     }\n \n@@ -61,13 +60,6 @@ public LedgerManager getLedgerManager() {\n         return ledgerManager;\n     }\n \n-    public ActiveLedgerManager getActiveLedgerManager() {\n-        if (null == activeLedgerManager) {\n-            activeLedgerManager = ledgerManagerFactory.newActiveLedgerManager();\n-        }\n-        return activeLedgerManager;\n-    }\n-\n     @Parameters\n     public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] {\n@@ -89,9 +81,6 @@ public void tearDown() throws Exception {\n         if (null != ledgerManager) {\n             ledgerManager.close();\n         }\n-        if (null != activeLedgerManager) {\n-            activeLedgerManager.close();\n-        }\n         ledgerManagerFactory.uninitialize();\n         super.tearDown();\n     }"}]}

