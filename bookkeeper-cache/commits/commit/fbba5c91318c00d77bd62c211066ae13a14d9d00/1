{"sha":"fbba5c91318c00d77bd62c211066ae13a14d9d00","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmYmJhNWM5MTMxOGMwMGQ3N2JkNjJjMjExMDY2YWUxM2ExNGQ5ZDAw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-17T10:41:45Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-08-17T10:41:45Z"},"message":"BOOKKEEPER-247: Detection of under replication (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1374195 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a046d86a5783f309011b0669169d81687f8fd1f5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a046d86a5783f309011b0669169d81687f8fd1f5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fbba5c91318c00d77bd62c211066ae13a14d9d00","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fbba5c91318c00d77bd62c211066ae13a14d9d00","html_url":"https://github.com/apache/bookkeeper/commit/fbba5c91318c00d77bd62c211066ae13a14d9d00","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fbba5c91318c00d77bd62c211066ae13a14d9d00/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f4daacff80da6802528320f5a920e1989cf20fac","url":"https://api.github.com/repos/apache/bookkeeper/commits/f4daacff80da6802528320f5a920e1989cf20fac","html_url":"https://github.com/apache/bookkeeper/commit/f4daacff80da6802528320f5a920e1989cf20fac"}],"stats":{"total":782,"additions":778,"deletions":4},"files":[{"sha":"abadef125d87c5b4c000110cada018dcbe451557","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -84,6 +84,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-246: Recording of underreplication of ledger entries (ivank)\n \n+        BOOKKEEPER-247: Detection of under replication (ivank)\n+\n       hedwig-server:\n \n         BOOKKEEPER-250: Need a ledger manager like interface to manage metadata operations in Hedwig (sijie via ivank)"},{"sha":"892383a78dd105fb96fc2f500902edfc37248998","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":13,"deletions":2,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n /**\n  * This interface determins how entries are distributed among bookies.\n@@ -62,4 +61,16 @@\n     }\n \n     public QuorumCoverageSet getCoverageSet();\n+    \n+    /**\n+     * Whether entry presents on given bookie index\n+     * \n+     * @param entryId\n+     *            - entryId to check the presence on given bookie index\n+     * @param bookieIndex\n+     *            - bookie index on which it need to check the possible presence\n+     *            of the entry\n+     * @return true if it has entry otherwise false.\n+     */\n+    public boolean hasEntry(long entryId, int bookieIndex);\n }"},{"sha":"930dc41bd0a4b469e16a5f4be4734d66938bf71a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"added","additions":274,"deletions":0,"changes":274,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -0,0 +1,274 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.Enumeration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.Map;\n+\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ *Checks the complete ledger and finds the UnderReplicated fragments if any\n+ */\n+public class LedgerChecker {\n+    private static Logger LOG = LoggerFactory.getLogger(LedgerChecker.class);\n+\n+    public final BookieClient bookieClient;\n+\n+    static class InvalidFragmentException extends Exception {\n+        private static final long serialVersionUID = 1467201276417062353L;\n+    }\n+\n+    /**\n+     * This will collect all the entry read call backs and finally it will give\n+     * call back to previous call back API which is waiting for it once it meets\n+     * the expected call backs from down\n+     */\n+    private static class ReadManyEntriesCallback implements ReadEntryCallback {\n+        AtomicBoolean completed = new AtomicBoolean(false);\n+        final AtomicLong numEntries;\n+        final LedgerFragment fragment;\n+        final GenericCallback<LedgerFragment> cb;\n+\n+        ReadManyEntriesCallback(long numEntries, LedgerFragment fragment,\n+                GenericCallback<LedgerFragment> cb) {\n+            this.numEntries = new AtomicLong(numEntries);\n+            this.fragment = fragment;\n+            this.cb = cb;\n+        }\n+\n+        public void readEntryComplete(int rc, long ledgerId, long entryId,\n+                ChannelBuffer buffer, Object ctx) {\n+            if (rc == BKException.Code.OK) {\n+                if (numEntries.decrementAndGet() == 0\n+                        && !completed.getAndSet(true)) {\n+                    cb.operationComplete(rc, fragment);\n+                }\n+            } else if (!completed.getAndSet(true)) {\n+                cb.operationComplete(rc, fragment);\n+            }\n+        }\n+    }\n+\n+    public LedgerChecker(BookKeeper bkc) {\n+        bookieClient = bkc.getBookieClient();\n+    }\n+\n+    private void verifyLedgerFragment(LedgerFragment fragment,\n+            GenericCallback<LedgerFragment> cb) throws InvalidFragmentException {\n+        long firstStored = fragment.getFirstStoredEntryId();\n+        long lastStored = fragment.getLastStoredEntryId();\n+\n+        if (firstStored == LedgerHandle.INVALID_ENTRY_ID) {\n+            if (lastStored != LedgerHandle.INVALID_ENTRY_ID) {\n+                throw new InvalidFragmentException();\n+            }\n+            cb.operationComplete(BKException.Code.OK, fragment);\n+            return;\n+        }\n+        if (firstStored == lastStored) {\n+            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(1,\n+                    fragment, cb);\n+            bookieClient.readEntry(fragment.getAddress(), fragment\n+                    .getLedgerId(), firstStored, manycb, null);\n+        } else {\n+            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(2,\n+                    fragment, cb);\n+            bookieClient.readEntry(fragment.getAddress(), fragment\n+                    .getLedgerId(), firstStored, manycb, null);\n+            bookieClient.readEntry(fragment.getAddress(), fragment\n+                    .getLedgerId(), lastStored, manycb, null);\n+        }\n+    }\n+\n+    /**\n+     * Callback for checking whether an entry exists or not.\n+     * It is used to differentiate the cases where it has been written\n+     * but now cannot be read, and where it never has been written.\n+     */\n+    private static class EntryExistsCallback implements ReadEntryCallback {\n+        AtomicBoolean entryMayExist = new AtomicBoolean(false);\n+        final AtomicInteger numReads;\n+        final GenericCallback<Boolean> cb;\n+\n+        EntryExistsCallback(int numReads,\n+                            GenericCallback<Boolean> cb) {\n+            this.numReads = new AtomicInteger(numReads);\n+            this.cb = cb;\n+        }\n+\n+        public void readEntryComplete(int rc, long ledgerId, long entryId,\n+                                      ChannelBuffer buffer, Object ctx) {\n+            if (rc != BKException.Code.NoSuchEntryException) {\n+                entryMayExist.set(true);\n+            }\n+\n+            if (numReads.decrementAndGet() == 0) {\n+                cb.operationComplete(rc, entryMayExist.get());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This will collect all the fragment read call backs and finally it will\n+     * give call back to above call back API which is waiting for it once it\n+     * meets the expected call backs from down\n+     */\n+    private static class FullLedgerCallback implements\n+            GenericCallback<LedgerFragment> {\n+        final Set<LedgerFragment> badFragments;\n+        final AtomicLong numFragments;\n+        final GenericCallback<Set<LedgerFragment>> cb;\n+\n+        FullLedgerCallback(long numFragments,\n+                GenericCallback<Set<LedgerFragment>> cb) {\n+            badFragments = new HashSet<LedgerFragment>();\n+            this.numFragments = new AtomicLong(numFragments);\n+            this.cb = cb;\n+        }\n+\n+        public void operationComplete(int rc, LedgerFragment result) {\n+            if (rc != BKException.Code.OK) {\n+                badFragments.add(result);\n+            }\n+            if (numFragments.decrementAndGet() == 0) {\n+                cb.operationComplete(BKException.Code.OK, badFragments);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check that all the fragments in the passed in ledger, and report those\n+     * which are missing.\n+     */\n+    public void checkLedger(LedgerHandle lh,\n+                            final GenericCallback<Set<LedgerFragment>> cb) {\n+        // build a set of all fragment replicas\n+        final Set<LedgerFragment> fragments = new HashSet<LedgerFragment>();\n+\n+        Long curEntryId = null;\n+        ArrayList<InetSocketAddress> curEnsemble = null;\n+        for (Map.Entry<Long, ArrayList<InetSocketAddress>> e : lh\n+                .getLedgerMetadata().getEnsembles().entrySet()) {\n+            if (curEntryId != null) {\n+                for (int i = 0; i < curEnsemble.size(); i++) {\n+                    fragments.add(new LedgerFragment(lh.getId(), curEntryId, e\n+                            .getKey() - 1, i, curEnsemble, lh\n+                            .getDistributionSchedule()));\n+                }\n+            }\n+            curEntryId = e.getKey();\n+            curEnsemble = e.getValue();\n+        }\n+\n+        /* Checking the last segment of the ledger can be complicated in some cases.\n+         * In the case that the ledger is closed, we can just check the fragments of\n+         * the segment as normal.\n+         * In the case that the ledger is open, but enough entries have been written,\n+         * for lastAddConfirmed to be set above the start entry of the segment, we\n+         * can also check as normal.\n+         * However, if lastAddConfirmed cannot be trusted, such as when it's lower than\n+         * the first entry id, or not set at all, we cannot be sure if there has been\n+         * data written to the segment. For this reason, we have to send a read request\n+         * to the bookies which should have the first entry. If they respond with\n+         * NoSuchEntry we can assume it was never written. If they respond with anything\n+         * else, we must assume the entry has been written, so we run the check.\n+         */\n+        if (curEntryId != null) {\n+            long lastEntry = lh.getLastAddConfirmed();\n+\n+            if (lastEntry < curEntryId) {\n+                lastEntry = curEntryId;\n+            }\n+\n+            final Set<LedgerFragment> finalSegmentFragments = new HashSet<LedgerFragment>();\n+            for (int i = 0; i < curEnsemble.size(); i++) {\n+                finalSegmentFragments.add(new LedgerFragment(lh.getId(), curEntryId,\n+                                                  lastEntry, i, curEnsemble,\n+                                                  lh.getDistributionSchedule()));\n+            }\n+\n+            // Check for the case that no last confirmed entry has\n+            // been set.\n+            if (curEntryId == lastEntry) {\n+                final long entryToRead = curEntryId;\n+\n+                EntryExistsCallback eecb\n+                    = new EntryExistsCallback(lh.getLedgerMetadata().getQuorumSize(),\n+                                              new GenericCallback<Boolean>() {\n+                                                  public void operationComplete(int rc, Boolean result) {\n+                                                      if (result) {\n+                                                          fragments.addAll(finalSegmentFragments);\n+                                                      }\n+                                                      checkFragments(fragments, cb);\n+                                                  }\n+                                              });\n+\n+                for (int i = 0; i < lh.getLedgerMetadata().getQuorumSize(); i++) {\n+                    int bi = lh.getDistributionSchedule().getBookieIndex(entryToRead, i);\n+                    InetSocketAddress addr = curEnsemble.get(bi);\n+                    bookieClient.readEntry(addr, lh.getId(),\n+                                           entryToRead, eecb, null);\n+                }\n+                return;\n+            } else {\n+                fragments.addAll(finalSegmentFragments);\n+            }\n+        }\n+\n+        checkFragments(fragments, cb);\n+    }\n+\n+    private void checkFragments(Set<LedgerFragment> fragments,\n+                                GenericCallback<Set<LedgerFragment>> cb) {\n+        if (fragments.size() == 0) { // no fragments to verify\n+            cb.operationComplete(BKException.Code.OK, fragments);\n+            return;\n+        }\n+\n+        // verify all the collected fragment replicas\n+        FullLedgerCallback allFragmentsCb = new FullLedgerCallback(fragments\n+                .size(), cb);\n+        for (LedgerFragment r : fragments) {\n+            LOG.debug(\"Checking fragment {}\", r);\n+            try {\n+                verifyLedgerFragment(r, allFragmentsCb);\n+            } catch (InvalidFragmentException ife) {\n+                LOG.error(\"Invalid fragment found : {}\", r);\n+                allFragmentsCb.operationComplete(\n+                        BKException.Code.IncorrectParameterException, r);\n+            }\n+        }\n+    }\n+}"},{"sha":"b0e6c79983ff815ea105ff5d4492b312d69af1a9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragment.java?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -0,0 +1,112 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.List;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Represents the entries of a segment of a ledger which are stored on a single\n+ * bookie in the segments bookie ensemble.\n+ * \n+ * Used for checking and recovery\n+ */\n+public class LedgerFragment {\n+    final int bookieIndex;\n+    final List<InetSocketAddress> ensemble;\n+    final long firstEntryId;\n+    final long lastEntryId;\n+    final long ledgerId;\n+    final DistributionSchedule schedule;\n+\n+    LedgerFragment(long ledgerId, long firstEntryId, long lastEntryId,\n+            int bookieIndex, List<InetSocketAddress> ensemble,\n+            DistributionSchedule schedule) {\n+        this.ledgerId = ledgerId;\n+        this.firstEntryId = firstEntryId;\n+        this.lastEntryId = lastEntryId;\n+        this.bookieIndex = bookieIndex;\n+        this.ensemble = ensemble;\n+        this.schedule = schedule;\n+    }\n+\n+    long getLedgerId() {\n+        return ledgerId;\n+    }\n+\n+    /**\n+     * Gets the failedBookie address\n+     */\n+    public InetSocketAddress getAddress() {\n+        return ensemble.get(bookieIndex);\n+    }\n+\n+    /**\n+     * Gets the first stored entry id of the fragment in failed bookie.\n+     * \n+     * @return entryId\n+     */\n+    public long getFirstStoredEntryId() {\n+        long firstEntry = firstEntryId;\n+\n+        for (int i = 0; i < ensemble.size() && firstEntry <= lastEntryId; i++) {\n+            if (schedule.hasEntry(firstEntry, bookieIndex)) {\n+                return firstEntry;\n+            } else {\n+                firstEntry++;\n+            }\n+        }\n+        return LedgerHandle.INVALID_ENTRY_ID;\n+    }\n+\n+    /**\n+     * Gets the last stored entry id of the fragment in failed bookie.\n+     * \n+     * @return entryId\n+     */\n+    public long getLastStoredEntryId() {\n+        long lastEntry = lastEntryId;\n+        for (int i = 0; i < ensemble.size() && lastEntry >= firstEntryId; i++) {\n+            if (schedule.hasEntry(lastEntry, bookieIndex)) {\n+                return lastEntry;\n+            } else {\n+                lastEntry--;\n+            }\n+        }\n+        return LedgerHandle.INVALID_ENTRY_ID;\n+    }\n+\n+    /**\n+     * Gets the ensemble of fragment\n+     * \n+     * @return\n+     */\n+    public List<InetSocketAddress> getEnsemble() {\n+        return this.ensemble;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Fragment(LedgerID: %d, FirstEntryID: %d[%d], \"\n+                + \"LastEntryID: %d[%d], Host: %s)\", ledgerId, firstEntryId,\n+                getFirstStoredEntryId(), lastEntryId, getLastStoredEntryId(),\n+                getAddress());\n+    }\n+}\n\\ No newline at end of file"},{"sha":"a8f0a870e5b5b152808c5c5979ecb09066e1c670","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,6 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n import org.apache.bookkeeper.util.MathUtils;\n \n@@ -87,4 +86,9 @@ public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n     public QuorumCoverageSet getCoverageSet() {\n         return new RRQuorumCoverageSet();\n     }\n+    \n+    @Override\n+    public boolean hasEntry(long entryId, int bookieIndex) {\n+        return getReplicaIndex(entryId, bookieIndex) != -1;\n+    }\n }"},{"sha":"6ab07f917f655c9c4614cfeee0a1990196f1f7dd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"added","additions":371,"deletions":0,"changes":371,"blob_url":"https://github.com/apache/bookkeeper/blob/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/fbba5c91318c00d77bd62c211066ae13a14d9d00/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=fbba5c91318c00d77bd62c211066ae13a14d9d00","patch":"@@ -0,0 +1,371 @@\n+/**\n+ * \n+ * Licensed to the Apache Software Foundation (ASF) under one \n+ * or more contributor license agreements.  See the NOTICE file \n+ * distributed with this work for additional information \n+ * regarding copyright ownership.  The ASF licenses this file \n+ * to you under the Apache License, Version 2.0 (the \n+ * \"License\"); you may not use this file except in compliance \n+ * with the License.  You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0 \n+ * \n+ * Unless required by applicable law or agreed to in writing, \n+ * software distributed under the License is distributed on an \n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n+ * KIND, either express or implied.  See the License for the \n+ * specific language governing permissions and limitations \n+ * under the License. \n+ * \n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests the functionality of LedgerChecker. This Ledger checker should be able\n+ * to detect the correct underReplicated fragment\n+ */\n+public class TestLedgerChecker extends BookKeeperClusterTestCase {\n+    private static final byte[] TEST_LEDGER_ENTRY_DATA = \"TestCheckerData\"\n+            .getBytes();\n+    private static final byte[] TEST_LEDGER_PASSWORD = \"testpasswd\".getBytes();\n+    static Logger LOG = LoggerFactory.getLogger(TestLedgerChecker.class);\n+\n+    public TestLedgerChecker() {\n+        super(3);\n+    }\n+\n+    class CheckerCallback implements GenericCallback<Set<LedgerFragment>> {\n+        private Set<LedgerFragment> result = null;\n+        private CountDownLatch latch = new CountDownLatch(1);\n+\n+        public void operationComplete(int rc, Set<LedgerFragment> result) {\n+            this.result = result;\n+            latch.countDown();\n+        }\n+\n+        Set<LedgerFragment> waitAndGetResult() throws InterruptedException {\n+            latch.await();\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Tests that the LedgerChecker should detect the underReplicated fragments\n+     * on multiple Bookie crashes\n+     */\n+    @Test\n+    public void testChecker() throws Exception {\n+\n+        LedgerHandle lh = bkc.createLedger(BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        startNewBookie();\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        }\n+        InetSocketAddress replicaToKill = lh.getLedgerMetadata().getEnsembles()\n+                .get(0L).get(0);\n+        LOG.info(\"Killing {}\", replicaToKill);\n+        killBookie(replicaToKill);\n+\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        }\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        for (LedgerFragment r : result) {\n+            LOG.info(\"unreplicated fragment: {}\", r);\n+        }\n+        assertEquals(\"Should have one missing fragment\", 1, result.size());\n+        assertEquals(\"Fragment should be missing from first replica\", result\n+                .iterator().next().getAddress(), replicaToKill);\n+\n+        InetSocketAddress replicaToKill2 = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L).get(1);\n+        LOG.info(\"Killing {}\", replicaToKill2);\n+        killBookie(replicaToKill2);\n+\n+        result = getUnderReplicatedFragments(lh);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        for (LedgerFragment r : result) {\n+            LOG.info(\"unreplicated fragment: {}\", r);\n+        }\n+        assertEquals(\"Should have three missing fragments\", 3, result.size());\n+    }\n+\n+    /**\n+     * Tests that ledger checker should pick the fragment as bad only if any of\n+     * the fragment entries not meeting the quorum.\n+     */\n+    // /////////////////////////////////////////////////////\n+    // /////////Ensemble = 3, Quorum = 2 ///////////////////\n+    // /Sample Ledger meta data should look like////////////\n+    // /0 a b c /////*entry present in a,b. Now kill c//////\n+    // /1 a b d ////////////////////////////////////////////\n+    // /Here even though one BK failed at this stage, //////\n+    // /we don't have any missed entries. Quorum satisfied//\n+    // /So, there should not be any missing replicas.///////\n+    // /////////////////////////////////////////////////////\n+    @Test(timeout = 3000)\n+    public void testShouldNotGetTheFragmentIfThereIsNoMissedEntry()\n+            throws Exception {\n+\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+\n+        // Entry should have added in first 2 Bookies.\n+\n+        // Kill the 3rd BK from ensemble.\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(2);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+\n+        startNewBookie();\n+\n+        LOG.info(\"Ensembles after first entry :\"\n+                + lh.getLedgerMetadata().getEnsembles());\n+\n+        // Adding one more entry. Here enseble should be reformed.\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+\n+        LOG.info(\"Ensembles after second entry :\"\n+                + lh.getLedgerMetadata().getEnsembles());\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+\n+        assertNotNull(\"Result shouldn't be null\", result);\n+\n+        for (LedgerFragment r : result) {\n+            LOG.info(\"unreplicated fragment: {}\", r);\n+        }\n+\n+        assertEquals(\"Should not have any missing fragment\", 0, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should give two fragments when 2 bookies failed\n+     * in same ensemble when ensemble = 3, quorum = 2\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldGetTwoFrgamentsIfTwoBookiesFailedInSameEnsemble()\n+            throws Exception {\n+\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        startNewBookie();\n+        startNewBookie();\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+\n+        InetSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n+        killBookie(firstEnsemble, firstBookieFromEnsemble);\n+\n+        InetSocketAddress secondBookieFromEnsemble = firstEnsemble.get(1);\n+        killBookie(firstEnsemble, secondBookieFromEnsemble);\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+\n+        assertNotNull(\"Result shouldn't be null\", result);\n+\n+        for (LedgerFragment r : result) {\n+            LOG.info(\"unreplicated fragment: {}\", r);\n+        }\n+\n+        assertEquals(\"There should be 2 fragments\", 2, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should not get any underReplicated fragments, if\n+     * corresponding ledger does not exists.\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldNotGetAnyFragmentIfNoLedgerPresent()\n+            throws Exception {\n+\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        InetSocketAddress firstBookieFromEnsemble = firstEnsemble.get(0);\n+        killBookie(firstBookieFromEnsemble);\n+        startNewBookie();\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        bkc.deleteLedger(lh.getId());\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+\n+        assertEquals(\"There should be 0 fragments. But returned fragments are \"\n+                + result, 0, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should get failed ensemble number of fragments\n+     * if ensemble bookie failures on next entry\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldGetFailedEnsembleNumberOfFgmntsIfEnsembleBookiesFailedOnNextWrite()\n+            throws Exception {\n+\n+        startNewBookie();\n+        startNewBookie();\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        for (int i = 0; i < 3; i++) {\n+            lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        }\n+\n+        // Kill all three bookies\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        for (InetSocketAddress bkAddr : firstEnsemble) {\n+            killBookie(firstEnsemble, bkAddr);\n+        }\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+\n+        assertNotNull(\"Result shouldn't be null\", result);\n+\n+        for (LedgerFragment r : result) {\n+            LOG.info(\"unreplicated fragment: {}\", r);\n+        }\n+\n+        assertEquals(\"There should be 3 fragments\", 3, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should not get any fragments as underReplicated\n+     * if Ledger itself is empty\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldNotGetAnyFragmentWithEmptyLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 0 fragments. But returned fragments are \"\n+                + result, 0, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should get all fragments if ledger is empty\n+     * but all bookies in the ensemble are down.\n+     * In this case, there's no way to tell whether data was written or not.\n+     * In this case, there'll only be two fragments, as quorum is 2 and we only\n+     * suspect that the first entry of the ledger could exist.\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldGet2FragmentsWithEmptyLedgerButBookiesDead() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 2, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        for (InetSocketAddress b : lh.getLedgerMetadata().getEnsembles().get(0L)) {\n+            killBookie(b);\n+        }\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 2 fragments.\", 2, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker should one fragment as underReplicated\n+     * if there is an open ledger with single entry written.\n+     */\n+    @Test(timeout = 3000)\n+    public void testShouldGetOneFragmentWithSingleEntryOpenedLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(0);\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+\n+        startNewBookie();\n+\n+        //Open ledger separately for Ledger checker.\n+        LedgerHandle lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 1 fragment. But returned fragments are \"\n+                + result, 1, result.size());\n+    }\n+\n+    /**\n+     * Tests that LedgerChecker correctly identifies missing fragments\n+     * when a single entry is written after an ensemble change.\n+     * This is important, as the last add confirmed may be less than the\n+     * first entry id of the final segment.\n+     */\n+    @Test(timeout = 3000)\n+    public void testSingleEntryAfterEnsembleChange() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+        }\n+        ArrayList<InetSocketAddress> firstEnsemble = lh.getLedgerMetadata()\n+                .getEnsembles().get(0L);\n+        InetSocketAddress lastBookieFromEnsemble = firstEnsemble.get(\n+                lh.getDistributionSchedule().getBookieIndex(lh.getLastAddPushed(), 0));\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+        startNewBookie();\n+\n+        lh.addEntry(TEST_LEDGER_ENTRY_DATA);\n+\n+        lastBookieFromEnsemble = firstEnsemble.get(\n+                lh.getDistributionSchedule().getBookieIndex(lh.getLastAddPushed(), 1));\n+        LOG.info(\"Killing \" + lastBookieFromEnsemble + \" from ensemble=\"\n+                + firstEnsemble);\n+        killBookie(lastBookieFromEnsemble);\n+\n+        //Open ledger separately for Ledger checker.\n+        LedgerHandle lh1 =bkc.openLedgerNoRecovery(lh.getId(), BookKeeper.DigestType.CRC32,\n+                TEST_LEDGER_PASSWORD);\n+\n+        Set<LedgerFragment> result = getUnderReplicatedFragments(lh1);\n+        assertNotNull(\"Result shouldn't be null\", result);\n+        assertEquals(\"There should be 3 fragment. But returned fragments are \"\n+                + result, 3, result.size());\n+    }\n+\n+    private Set<LedgerFragment> getUnderReplicatedFragments(LedgerHandle lh)\n+            throws InterruptedException {\n+        LedgerChecker checker = new LedgerChecker(bkc);\n+        CheckerCallback cb = new CheckerCallback();\n+        checker.checkLedger(lh, cb);\n+        Set<LedgerFragment> result = cb.waitAndGetResult();\n+        return result;\n+    }\n+\n+    private void killBookie(ArrayList<InetSocketAddress> firstEnsemble,\n+            InetSocketAddress ensemble) throws InterruptedException {\n+        LOG.info(\"Killing \" + ensemble + \" from ensemble=\" + firstEnsemble);\n+        killBookie(ensemble);\n+    }\n+\n+}"}]}

