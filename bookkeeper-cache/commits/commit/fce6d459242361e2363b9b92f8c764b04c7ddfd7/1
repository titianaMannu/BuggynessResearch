{"sha":"fce6d459242361e2363b9b92f8c764b04c7ddfd7","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmY2U2ZDQ1OTI0MjM2MWUyMzYzYjliOTJmOGM3NjRiMDRjN2RkZmQ3","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-06-15T17:05:45Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2013-06-15T17:05:45Z"},"message":"BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1493400 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b5fcc31ee0fd2641043e244371bbb90feffb6339","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b5fcc31ee0fd2641043e244371bbb90feffb6339"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fce6d459242361e2363b9b92f8c764b04c7ddfd7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fce6d459242361e2363b9b92f8c764b04c7ddfd7","html_url":"https://github.com/apache/bookkeeper/commit/fce6d459242361e2363b9b92f8c764b04c7ddfd7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fce6d459242361e2363b9b92f8c764b04c7ddfd7/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"5ef7f760d8ccf2bc765e77891447ed050926f4a3","url":"https://api.github.com/repos/apache/bookkeeper/commits/5ef7f760d8ccf2bc765e77891447ed050926f4a3","html_url":"https://github.com/apache/bookkeeper/commit/5ef7f760d8ccf2bc765e77891447ed050926f4a3"}],"stats":{"total":567,"additions":494,"deletions":73},"files":[{"sha":"a94a51049fec578a232fa60b20757ce6a2482034","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -92,6 +92,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-627: LedgerDirsMonitor is missing thread name (rakesh via fpj)\n \n+      BOOKKEEPER-618: Better resolution of bookie address (ivank via fpj)\n+\n     NEW FEATURE:\n \n       BOOKKEEPER-562: Ability to tell if a ledger is closed or not (fpj)"},{"sha":"686e5cce491fd55155bb02fb3e4c340f72900e8f","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -25,6 +25,23 @@\n # Port that bookie server listen on\n bookiePort=3181\n \n+# Set the network interface that the bookie should listen on.\n+# If not set, the bookie will listen on all interfaces.\n+#listeningInterface=eth0\n+\n+# Whether the bookie allowed to use a loopback interface as its primary\n+# interface(i.e. the interface it uses to establish its identity)?\n+# By default, loopback interfaces are not allowed as the primary\n+# interface.\n+# Using a loopback interface as the primary interface usually indicates\n+# a configuration error. For example, its fairly common in some VPS setups\n+# to not configure a hostname, or to have the hostname resolve to\n+# 127.0.0.1. If this is the case, then all bookies in the cluster will\n+# establish their identities as 127.0.0.1:3181, and only one will be able\n+# to join the cluster. For VPSs configured like this, you should explicitly\n+# set the listening interface.\n+#allowLoopback=false\n+\n # Directory Bookkeeper outputs its write ahead log\n journalDirectory=/tmp/bk-txn\n "},{"sha":"1d4dbe859ecf3f3f8d3da976d50bc78b5dcef8a8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":16,"deletions":4,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -57,6 +57,7 @@\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.net.DNS;\n import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n@@ -347,8 +348,20 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n      */\n     public static InetSocketAddress getBookieAddress(ServerConfiguration conf)\n             throws UnknownHostException {\n-        return new InetSocketAddress(InetAddress.getLocalHost()\n-                .getHostAddress(), conf.getBookiePort());\n+        String iface = conf.getListeningInterface();\n+        if (iface == null) {\n+            iface = \"default\";\n+        }\n+        InetSocketAddress addr = new InetSocketAddress(\n+                DNS.getDefaultHost(iface),\n+                conf.getBookiePort());\n+        if (addr.getAddress().isLoopbackAddress()\n+            && !conf.getAllowLoopback()) {\n+            throw new UnknownHostException(\"Trying to listen on loopback address, \"\n+                    + addr + \" but this is forbidden by default \"\n+                    + \"(see ServerConfiguration#getAllowLoopback())\");\n+        }\n+        return addr;\n     }\n \n     private String getInstanceId(ZooKeeper zk) throws KeeperException,\n@@ -410,8 +423,7 @@ public Bookie(ServerConfiguration conf)\n     }\n \n     private String getMyId() throws UnknownHostException {\n-        return InetAddress.getLocalHost().getHostAddress() + \":\"\n-                + conf.getBookiePort();\n+        return StringUtils.addrToString(Bookie.getBookieAddress(conf));\n     }\n \n     void readJournal() throws IOException, BookieException {"},{"sha":"2e5330bf5ac5b1a1a2c7dafe9aac02de702ee137","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -267,7 +267,7 @@ long getNextEnsembleChange(long entryId) {\n             LedgerMetadataFormat.Segment.Builder segmentBuilder = LedgerMetadataFormat.Segment.newBuilder();\n             segmentBuilder.setFirstEntryId(entry.getKey());\n             for (InetSocketAddress addr : entry.getValue()) {\n-                segmentBuilder.addEnsembleMember(addr.getAddress().getHostAddress() + \":\" + addr.getPort());\n+                segmentBuilder.addEnsembleMember(StringUtils.addrToString(addr));\n             }\n             builder.addSegment(segmentBuilder.build());\n         }"},{"sha":"8fdfb1e113c6eab406fb743c29506cf26ab40cf5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -48,6 +48,9 @@\n     protected final static String MAX_BACKUP_JOURNALS = \"journalMaxBackups\";\n     // Bookie Parameters\n     protected final static String BOOKIE_PORT = \"bookiePort\";\n+    protected final static String LISTENING_INTERFACE = \"listeningInterface\";\n+    protected final static String ALLOW_LOOPBACK = \"allowLoopback\";\n+\n     protected final static String JOURNAL_DIR = \"journalDirectory\";\n     protected final static String LEDGER_DIRS = \"ledgerDirectories\";\n     // NIO Parameters\n@@ -283,6 +286,64 @@ public ServerConfiguration setBookiePort(int port) {\n         return this;\n     }\n \n+    /**\n+     * Get the network interface that the bookie should\n+     * listen for connections on. If this is null, then the bookie\n+     * will listen for connections on all interfaces.\n+     *\n+     * @return the network interface to listen on, e.g. eth0, or\n+     *         null if none is specified\n+     */\n+    public String getListeningInterface() {\n+        return this.getString(LISTENING_INTERFACE);\n+    }\n+\n+    /**\n+     * Set the network interface that the bookie should listen on.\n+     * If not set, the bookie will listen on all interfaces.\n+     *\n+     * @param iface the interface to listen on\n+     */\n+    public ServerConfiguration setListeningInterface(String iface) {\n+        this.setProperty(LISTENING_INTERFACE, iface);\n+        return this;\n+    }\n+\n+    /**\n+     * Is the bookie allowed to use a loopback interface as its primary\n+     * interface(i.e. the interface it uses to establish its identity)?\n+     *\n+     * By default, loopback interfaces are not allowed as the primary\n+     * interface.\n+     *\n+     * Using a loopback interface as the primary interface usually indicates\n+     * a configuration error. For example, its fairly common in some VPS setups\n+     * to not configure a hostname, or to have the hostname resolve to\n+     * 127.0.0.1. If this is the case, then all bookies in the cluster will\n+     * establish their identities as 127.0.0.1:3181, and only one will be able\n+     * to join the cluster. For VPSs configured like this, you should explicitly\n+     * set the listening interface.\n+     *\n+     * @see #setListeningInterface(String)\n+     * @return whether a loopback interface can be used as the primary interface\n+     */\n+    public boolean getAllowLoopback() {\n+        return this.getBoolean(ALLOW_LOOPBACK, false);\n+    }\n+\n+    /**\n+     * Configure the bookie to allow loopback interfaces to be used\n+     * as the primary bookie interface.\n+     *\n+     * @see #getAllowLoopback\n+     * @param allow whether to allow loopback interfaces\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setAllowLoopback(boolean allow) {\n+        this.setProperty(ALLOW_LOOPBACK, allow);\n+        return this;\n+    }\n+\n     /**\n      * Get dir name to store journal files\n      *"},{"sha":"c1a410eb5360c045f6ead3d9687f55cb0d21005f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -23,6 +23,8 @@\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.util.net.DNS;\n+\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n@@ -114,7 +116,7 @@ public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc\n \n         LockDataFormat.Builder lockDataBuilder = LockDataFormat.newBuilder();\n         try {\n-            lockDataBuilder.setBookieId(InetAddress.getLocalHost().getHostAddress().toString());\n+            lockDataBuilder.setBookieId(DNS.getDefaultHost(\"default\"));\n         } catch (UnknownHostException uhe) {\n             // if we cant get the address, ignore. it's optional\n             // in the data structure in any case"},{"sha":"d095cfc981cb55ee98b0b2cbbbcb520745408e64","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":8,"deletions":13,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -65,7 +65,7 @@\n     Object suspensionLock = new Object();\n     boolean suspended = false;\n \n-    InetSocketAddress localAddress = null;\n+    final InetSocketAddress bindAddress;\n \n     BookieNettyServer(ServerConfiguration conf, Bookie bookie)\n             throws IOException, KeeperException, InterruptedException, BookieException  {\n@@ -77,7 +77,12 @@\n         serverChannelFactory = new NioServerSocketChannelFactory(\n                 Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-boss-%d\").build()),\n                 Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-worker-%d\").build()));\n-\n+        if (conf.getListeningInterface() == null) {\n+            // listen on all interfaces\n+            bindAddress = new InetSocketAddress(conf.getBookiePort());\n+        } else {\n+            bindAddress = Bookie.getBookieAddress(conf);\n+        }\n     }\n \n     boolean isRunning() {\n@@ -101,24 +106,14 @@ void resumeProcessing() {\n         }\n     }\n \n-    InetSocketAddress getLocalAddress() {\n-        if (localAddress != null) {\n-            return localAddress;\n-        } else {\n-            return new InetSocketAddress(conf.getBookiePort());\n-        }\n-    }\n-\n     void start() {\n         ServerBootstrap bootstrap = new ServerBootstrap(serverChannelFactory);\n         bootstrap.setPipelineFactory(new BookiePipelineFactory());\n         bootstrap.setOption(\"child.tcpNoDelay\", conf.getServerTcpNoDelay());\n         bootstrap.setOption(\"child.soLinger\", 2);\n \n-        Channel listen = bootstrap.bind(new InetSocketAddress(conf.getBookiePort()));\n+        Channel listen = bootstrap.bind(bindAddress);\n \n-        assert(listen.getLocalAddress() instanceof InetSocketAddress);\n-        localAddress = (InetSocketAddress)listen.getLocalAddress();\n         allChannels.add(listen);\n         isRunning.set(true);\n     }"},{"sha":"320889acd8926faae4e26887557f0f4544b8636b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -100,12 +100,9 @@ public void start() throws IOException, UnavailableException {\n         registerJMX();\n     }\n \n-    public InetSocketAddress getLocalAddress() {\n-        try {\n-            return Bookie.getBookieAddress(conf);\n-        } catch (UnknownHostException uhe) {\n-            return nettyServer.getLocalAddress();\n-        }\n+    @VisibleForTesting\n+    public InetSocketAddress getLocalAddress() throws UnknownHostException {\n+        return Bookie.getBookieAddress(conf);\n     }\n \n     @VisibleForTesting"},{"sha":"4897883036c0c7fb8e96501d72fae6f48ead06ee","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -149,6 +149,7 @@ private void runBookies(ServerConfiguration baseConf) throws IOException,\n                                   + ZooKeeperDefaultPort);\n             bsConfs[i].setJournalDirName(tmpDirs[i].getPath());\n             bsConfs[i].setLedgerDirNames(new String[] { tmpDirs[i].getPath() });\n+            bsConfs[i].setAllowLoopback(true);\n \n             bs[i] = new BookieServer(bsConfs[i]);\n             bs[i].start();"},{"sha":"cc182f73efaec8d21f3e95b981dcfcae18842325","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","status":"added","additions":356,"deletions":0,"changes":356,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/net/DNS.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+// This code has been copied from hadoop-common 2.0.4-alpha\n+package org.apache.bookkeeper.util.net;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.LinkedHashSet;\n+import java.util.Vector;\n+\n+import javax.naming.NamingException;\n+import javax.naming.directory.Attributes;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+\n+/**\n+ *\n+ * A class that provides direct and reverse lookup functionalities, allowing\n+ * the querying of specific network interfaces or nameservers.\n+ *\n+ *\n+ */\n+public class DNS {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DNS.class);\n+\n+  /**\n+   * The cached hostname -initially null.\n+   */\n+\n+  private static final String cachedHostname = resolveLocalHostname();\n+  private static final String cachedHostAddress = resolveLocalHostIPAddress();\n+  private static final String LOCALHOST = \"localhost\";\n+\n+  /**\n+   * Returns the hostname associated with the specified IP address by the\n+   * provided nameserver.\n+   *\n+   * Loopback addresses\n+   * @param hostIp The address to reverse lookup\n+   * @param ns The host name of a reachable DNS server\n+   * @return The host name associated with the provided IP\n+   * @throws NamingException If a NamingException is encountered\n+   */\n+  public static String reverseDns(InetAddress hostIp, String ns)\n+    throws NamingException {\n+    //\n+    // Builds the reverse IP lookup form\n+    // This is formed by reversing the IP numbers and appending in-addr.arpa\n+    //\n+    String[] parts = hostIp.getHostAddress().split(\"\\\\.\");\n+    String reverseIP = parts[3] + \".\" + parts[2] + \".\" + parts[1] + \".\"\n+      + parts[0] + \".in-addr.arpa\";\n+\n+    DirContext ictx = new InitialDirContext();\n+    Attributes attribute;\n+    try {\n+      attribute = ictx.getAttributes(\"dns://\"               // Use \"dns:///\" if the default\n+                         + ((ns == null) ? \"\" : ns) +\n+                         // nameserver is to be used\n+                         \"/\" + reverseIP, new String[] { \"PTR\" });\n+    } finally {\n+      ictx.close();\n+    }\n+\n+    return attribute.get(\"PTR\").get().toString();\n+  }\n+\n+  /**\n+   * @return NetworkInterface for the given subinterface name (eg eth0:0)\n+   *    or null if no interface with the given name can be found\n+   */\n+  private static NetworkInterface getSubinterface(String strInterface)\n+      throws SocketException {\n+    Enumeration<NetworkInterface> nifs =\n+      NetworkInterface.getNetworkInterfaces();\n+\n+    while (nifs.hasMoreElements()) {\n+      Enumeration<NetworkInterface> subNifs =\n+        nifs.nextElement().getSubInterfaces();\n+\n+      while (subNifs.hasMoreElements()) {\n+        NetworkInterface nif = subNifs.nextElement();\n+        if (nif.getName().equals(strInterface)) {\n+          return nif;\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * @param nif network interface to get addresses for\n+   * @return set containing addresses for each subinterface of nif,\n+   *    see below for the rationale for using an ordered set\n+   */\n+  private static LinkedHashSet<InetAddress> getSubinterfaceInetAddrs(\n+      NetworkInterface nif) {\n+    LinkedHashSet<InetAddress> addrs = new LinkedHashSet<InetAddress>();\n+    Enumeration<NetworkInterface> subNifs = nif.getSubInterfaces();\n+    while (subNifs.hasMoreElements()) {\n+      NetworkInterface subNif = subNifs.nextElement();\n+      addrs.addAll(Collections.list(subNif.getInetAddresses()));\n+    }\n+    return addrs;\n+  }\n+\n+  /**\n+   * Like {@link DNS#getIPs(String, boolean), but returns all\n+   * IPs associated with the given interface and its subinterfaces.\n+   */\n+  public static String[] getIPs(String strInterface)\n+      throws UnknownHostException {\n+    return getIPs(strInterface, true);\n+  }\n+\n+  /**\n+   * Returns all the IPs associated with the provided interface, if any, in\n+   * textual form.\n+   *\n+   * @param strInterface\n+   *            The name of the network interface or sub-interface to query\n+   *            (eg eth0 or eth0:0) or the string \"default\"\n+   * @param returnSubinterfaces\n+   *            Whether to return IPs associated with subinterfaces of\n+   *            the given interface\n+   * @return A string vector of all the IPs associated with the provided\n+   *         interface. The local host IP is returned if the interface\n+   *         name \"default\" is specified or there is an I/O error looking\n+   *         for the given interface.\n+   * @throws UnknownHostException\n+   *             If the given interface is invalid\n+   *\n+   */\n+  public static String[] getIPs(String strInterface,\n+      boolean returnSubinterfaces) throws UnknownHostException {\n+    if (\"default\".equals(strInterface)) {\n+      return new String[] { cachedHostAddress };\n+    }\n+    NetworkInterface netIf;\n+    try {\n+      netIf = NetworkInterface.getByName(strInterface);\n+      if (netIf == null) {\n+        netIf = getSubinterface(strInterface);\n+      }\n+    } catch (SocketException e) {\n+      LOG.warn(\"I/O error finding interface \" + strInterface +\n+          \": \" + e.getMessage());\n+      return new String[] { cachedHostAddress };\n+    }\n+    if (netIf == null) {\n+      throw new UnknownHostException(\"No such interface \" + strInterface);\n+    }\n+\n+    // NB: Using a LinkedHashSet to preserve the order for callers\n+    // that depend on a particular element being 1st in the array.\n+    // For example, getDefaultIP always returns the first element.\n+    LinkedHashSet<InetAddress> allAddrs = new LinkedHashSet<InetAddress>();\n+    allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n+    if (!returnSubinterfaces) {\n+      allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n+    }\n+\n+    String ips[] = new String[allAddrs.size()];\n+    int i = 0;\n+    for (InetAddress addr : allAddrs) {\n+      ips[i++] = addr.getHostAddress();\n+    }\n+    return ips;\n+  }\n+\n+\n+  /**\n+   * Returns the first available IP address associated with the provided\n+   * network interface or the local host IP if \"default\" is given.\n+   *\n+   * @param strInterface\n+   *            The name of the network interface or subinterface to query\n+   *             (e.g. eth0 or eth0:0) or the string \"default\"\n+   * @return The IP address in text form, the local host IP is returned\n+   *         if the interface name \"default\" is specified\n+   * @throws UnknownHostException\n+   *             If the given interface is invalid\n+   */\n+  public static String getDefaultIP(String strInterface)\n+    throws UnknownHostException {\n+    String[] ips = getIPs(strInterface);\n+    return ips[0];\n+  }\n+\n+  /**\n+   * Returns all the host names associated by the provided nameserver with the\n+   * address bound to the specified network interface\n+   *\n+   * @param strInterface\n+   *            The name of the network interface or subinterface to query\n+   *            (e.g. eth0 or eth0:0)\n+   * @param nameserver\n+   *            The DNS host name\n+   * @return A string vector of all host names associated with the IPs tied to\n+   *         the specified interface\n+   * @throws UnknownHostException if the given interface is invalid\n+   */\n+  public static String[] getHosts(String strInterface, String nameserver)\n+    throws UnknownHostException {\n+    String[] ips = getIPs(strInterface);\n+    Vector<String> hosts = new Vector<String>();\n+    for (int ctr = 0; ctr < ips.length; ctr++) {\n+      try {\n+        hosts.add(reverseDns(InetAddress.getByName(ips[ctr]),\n+                             nameserver));\n+      } catch (UnknownHostException ignored) {\n+      } catch (NamingException ignored) {\n+      }\n+    }\n+    if (hosts.isEmpty()) {\n+      LOG.warn(\"Unable to determine hostname for interface \" + strInterface);\n+      return new String[] { cachedHostname };\n+    } else {\n+      return hosts.toArray(new String[hosts.size()]);\n+    }\n+  }\n+\n+\n+  /**\n+   * Determine the local hostname; retrieving it from cache if it is known\n+   * If we cannot determine our host name, return \"localhost\"\n+   * @return the local hostname or \"localhost\"\n+   */\n+  private static String resolveLocalHostname() {\n+    String localhost;\n+    try {\n+      localhost = InetAddress.getLocalHost().getCanonicalHostName();\n+    } catch (UnknownHostException e) {\n+      LOG.warn(\"Unable to determine local hostname \"\n+          + \"-falling back to \\\"\" + LOCALHOST + \"\\\"\", e);\n+      localhost = LOCALHOST;\n+    }\n+    return localhost;\n+  }\n+\n+\n+  /**\n+   * Get the IPAddress of the local host as a string.\n+   * This will be a loop back value if the local host address cannot be\n+   * determined.\n+   * If the loopback address of \"localhost\" does not resolve, then the system's\n+   * network is in such a state that nothing is going to work. A message is\n+   * logged at the error level and a null pointer returned, a pointer\n+   * which will trigger failures later on the application\n+   * @return the IPAddress of the local host or null for a serious problem.\n+   */\n+  private static String resolveLocalHostIPAddress() {\n+    String address;\n+      try {\n+        address = InetAddress.getLocalHost().getHostAddress();\n+      } catch (UnknownHostException e) {\n+        LOG.warn(\"Unable to determine address of the host\"\n+                + \"-falling back to \\\"\" + LOCALHOST + \"\\\" address\", e);\n+        try {\n+          address = InetAddress.getByName(LOCALHOST).getHostAddress();\n+        } catch (UnknownHostException noLocalHostAddressException) {\n+          //at this point, deep trouble\n+          LOG.error(\"Unable to determine local loopback address \"\n+                  + \"of \\\"\" + LOCALHOST + \"\\\" \" +\n+                  \"-this system's network configuration is unsupported\", e);\n+          address = null;\n+        }\n+      }\n+    return address;\n+  }\n+\n+  /**\n+   * Returns all the host names associated by the default nameserver with the\n+   * address bound to the specified network interface\n+   *\n+   * @param strInterface\n+   *            The name of the network interface to query (e.g. eth0)\n+   * @return The list of host names associated with IPs bound to the network\n+   *         interface\n+   * @throws UnknownHostException\n+   *             If one is encountered while querying the default interface\n+   *\n+   */\n+  public static String[] getHosts(String strInterface)\n+    throws UnknownHostException {\n+    return getHosts(strInterface, null);\n+  }\n+\n+  /**\n+   * Returns the default (first) host name associated by the provided\n+   * nameserver with the address bound to the specified network interface\n+   *\n+   * @param strInterface\n+   *            The name of the network interface to query (e.g. eth0)\n+   * @param nameserver\n+   *            The DNS host name\n+   * @return The default host names associated with IPs bound to the network\n+   *         interface\n+   * @throws UnknownHostException\n+   *             If one is encountered while querying the default interface\n+   */\n+  public static String getDefaultHost(String strInterface, String nameserver)\n+    throws UnknownHostException {\n+    if (\"default\".equals(strInterface)) {\n+      return cachedHostname;\n+    }\n+\n+    if (\"default\".equals(nameserver)) {\n+      return getDefaultHost(strInterface);\n+    }\n+\n+    String[] hosts = getHosts(strInterface, nameserver);\n+    return hosts[0];\n+  }\n+\n+  /**\n+   * Returns the default (first) host name associated by the default\n+   * nameserver with the address bound to the specified network interface\n+   *\n+   * @param strInterface\n+   *            The name of the network interface to query (e.g. eth0).\n+   *            Must not be null.\n+   * @return The default host name associated with IPs bound to the network\n+   *         interface\n+   * @throws UnknownHostException\n+   *             If one is encountered while querying the default interface\n+   */\n+  public static String getDefaultHost(String strInterface)\n+    throws UnknownHostException {\n+    return getDefaultHost(strInterface, null);\n+  }\n+\n+}"},{"sha":"a1592ac660d1aeebd8dec59014a0f013f2c87f37","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestLedgerChecker.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -454,7 +454,7 @@ public void testClosedSingleEntryLedger() throws Exception {\n     }\n \n     private void killBookie(ArrayList<InetSocketAddress> firstEnsemble,\n-            InetSocketAddress ensemble) throws InterruptedException {\n+            InetSocketAddress ensemble) throws Exception {\n         LOG.info(\"Killing \" + ensemble + \" from ensemble=\" + firstEnsemble);\n         killBookie(ensemble);\n     }"},{"sha":"1182733ecbd4bf7d31bf634ed7c67ac3ebc84ac1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -55,7 +55,7 @@ public TestPerChannelBookieClient() {\n      * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-485}.\n      */\n     @Test(timeout=60000)\n-    public void testConnectCloseRace() {\n+    public void testConnectCloseRace() throws Exception {\n         ClientSocketChannelFactory channelFactory\n             = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n                                                 Executors.newCachedThreadPool());\n@@ -85,7 +85,7 @@ public void operationComplete(int rc, Void result) {\n      * correctly, this causes the netty channel to get orphaned.\n      */\n     @Test(timeout=60000)\n-    public void testConnectRace() {\n+    public void testConnectRace() throws Exception {\n         GenericCallback<Void> nullop = new GenericCallback<Void>() {\n             @Override\n             public void operationComplete(int rc, Void result) {\n@@ -111,4 +111,4 @@ public void operationComplete(int rc, Void result) {\n         channelFactory.releaseExternalResources();\n         executor.shutdown();\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"6a0589c3362ca6f355f971bd2cafbc58dfaa5358","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","status":"modified","additions":3,"deletions":5,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorBookieTest.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -253,17 +253,15 @@ private void stopAuditorElectors() throws Exception {\n         }\n     }\n \n-    private BookieServer verifyAuditor() throws KeeperException,\n-            InterruptedException {\n+    private BookieServer verifyAuditor() throws Exception {\n         List<BookieServer> auditors = getAuditorBookie();\n         Assert.assertEquals(\"Multiple Bookies acting as Auditor!\", 1, auditors\n                 .size());\n         LOG.debug(\"Bookie running as Auditor:\" + auditors.get(0));\n         return auditors.get(0);\n     }\n \n-    private List<BookieServer> getAuditorBookie() throws KeeperException,\n-            InterruptedException {\n+    private List<BookieServer> getAuditorBookie() throws Exception {\n         List<BookieServer> auditors = new LinkedList<BookieServer>();\n         byte[] data = zkc.getData(electionPath, false, null);\n         Assert.assertNotNull(\"Auditor election failed\", data);\n@@ -286,7 +284,7 @@ private void shutdownBookie(BookieServer bkServer) throws Exception {\n     }\n \n     private BookieServer waitForNewAuditor(BookieServer auditor)\n-            throws InterruptedException, KeeperException {\n+            throws Exception {\n         BookieServer newAuditor = null;\n         int retryCount = 8;\n         while (retryCount > 0) {"},{"sha":"5cb2524c6d4b4b6ef2717b81e9ae5aaefbd027db","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -321,8 +321,7 @@ private void doLedgerRereplication(Long... ledgerIds)\n         }\n     }\n \n-    private String shutdownBookie(int bkShutdownIndex) throws IOException,\n-            InterruptedException {\n+    private String shutdownBookie(int bkShutdownIndex) throws Exception {\n         BookieServer bkServer = bs.get(bkShutdownIndex);\n         String bookieAddr = StringUtils.addrToString(bkServer.getLocalAddress());\n         LOG.debug(\"Shutting down bookie:\" + bookieAddr);"},{"sha":"d2e21200d136496b9bbafdaf738642fc5fd3d510","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/BookieAutoRecoveryTest.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -358,7 +358,7 @@ private int getReplicaIndexInLedger(LedgerHandle lh,\n \n     private void verifyLedgerEnsembleMetadataAfterReplication(\n             BookieServer newBookieServer, LedgerHandle lh,\n-            int ledgerReplicaIndex) throws BKException, InterruptedException {\n+            int ledgerReplicaIndex) throws Exception {\n         LedgerHandle openLedger = bkc\n                 .openLedger(lh.getId(), digestType, PASSWD);\n "},{"sha":"0630fa3be13696feeefe836ff85906f7b8142ccb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/TestReplicationWorker.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -529,7 +529,7 @@ public void testRWZKSessionLost() throws Exception {\n     }\n \n     private void killAllBookies(LedgerHandle lh, InetSocketAddress excludeBK)\n-            throws InterruptedException {\n+            throws Exception {\n         // Killing all bookies except newly replicated bookie\n         Set<Entry<Long, ArrayList<InetSocketAddress>>> entrySet = LedgerHandleAdapter\n                 .getLedgerMetadata(lh).getEnsembles().entrySet();"},{"sha":"7f9c757d929e75b8567c0af339a06aa3992b1a1e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":16,"deletions":35,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/fce6d459242361e2363b9b92f8c764b04c7ddfd7/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=fce6d459242361e2363b9b92f8c764b04c7ddfd7","patch":"@@ -175,7 +175,7 @@ protected void stopBKCluster() throws Exception {\n         }\n     }\n \n-    protected ServerConfiguration newServerConfiguration() throws IOException {\n+    protected ServerConfiguration newServerConfiguration() throws Exception {\n         File f = File.createTempFile(\"bookie\", \"test\");\n         tmpDirs.add(f);\n         f.delete();\n@@ -191,6 +191,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         conf.setBookiePort(port);\n         conf.setZkServers(zkServers);\n         conf.setJournalDirName(journalDir.getPath());\n+        conf.setAllowLoopback(true);\n         String[] ledgerDirNames = new String[ledgerDirs.length];\n         for (int i=0; i<ledgerDirs.length; i++) {\n             ledgerDirNames[i] = ledgerDirs[i].getPath();\n@@ -202,7 +203,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n     /**\n      * Get bookie address for bookie at index\n      */\n-    public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n+    public InetSocketAddress getBookie(int index) throws Exception {\n         if (bs.size() <= index || index < 0) {\n             throw new IllegalArgumentException(\"Invalid index, there are only \" + bs.size()\n                                                + \" bookies. Asked for \" + index);\n@@ -219,7 +220,7 @@ public InetSocketAddress getBookie(int index) throws IllegalArgumentException {\n      * @return the configuration of killed bookie\n      * @throws InterruptedException\n      */\n-    public ServerConfiguration killBookie(InetSocketAddress addr) throws InterruptedException {\n+    public ServerConfiguration killBookie(InetSocketAddress addr) throws Exception {\n         BookieServer toRemove = null;\n         int toRemoveIndex = 0;\n         for (BookieServer server : bs) {\n@@ -248,7 +249,7 @@ public ServerConfiguration killBookie(InetSocketAddress addr) throws Interrupted\n      * @throws InterruptedException\n      * @throws IOException\n      */\n-    public ServerConfiguration killBookie(int index) throws InterruptedException, IOException {\n+    public ServerConfiguration killBookie(int index) throws Exception {\n         if (index >= bs.size()) {\n             throw new IOException(\"Bookie does not exist\");\n         }\n@@ -271,7 +272,7 @@ public ServerConfiguration killBookie(int index) throws InterruptedException, IO\n      * @throws IOException\n      */\n     public CountDownLatch sleepBookie(InetSocketAddress addr, final int seconds)\n-            throws InterruptedException, IOException {\n+            throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n                 final CountDownLatch l = new CountDownLatch(1);\n@@ -306,7 +307,7 @@ public void run() {\n      * @throws IOException\n      */\n     public void sleepBookie(InetSocketAddress addr, final CountDownLatch l)\n-            throws InterruptedException, IOException {\n+            throws Exception {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n                 Thread sleeper = new Thread() {\n@@ -337,8 +338,7 @@ public void run() {\n      * @throws BookieException\n      */\n     public void restartBookies()\n-            throws InterruptedException, IOException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         restartBookies(null);\n     }\n \n@@ -354,8 +354,7 @@ public void restartBookies()\n      * @throws BookieException\n      */\n     public void restartBookies(ServerConfiguration newConf)\n-            throws InterruptedException, IOException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         // shut down bookie server\n         for (BookieServer server : bs) {\n             server.shutdown();\n@@ -384,8 +383,7 @@ public void restartBookies(ServerConfiguration newConf)\n      * @throws IOException\n      */\n     public int startNewBookie()\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         ServerConfiguration conf = newServerConfiguration();\n         bsConfs.add(conf);\n         bs.add(startBookie(conf));\n@@ -402,8 +400,7 @@ public int startNewBookie()\n      *\n      */\n     protected BookieServer startBookie(ServerConfiguration conf)\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         BookieServer server = new BookieServer(conf);\n         server.start();\n \n@@ -430,8 +427,7 @@ protected BookieServer startBookie(ServerConfiguration conf)\n      * recovery for this bookie, if isAutoRecoveryEnabled is true.\n      */\n     protected BookieServer startBookie(ServerConfiguration conf, final Bookie b)\n-            throws IOException, InterruptedException, KeeperException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            throws Exception {\n         BookieServer server = new BookieServer(conf) {\n             @Override\n             protected Bookie newBookie(ServerConfiguration conf) {\n@@ -486,9 +482,7 @@ public boolean isAutoRecoveryEnabled() {\n     }\n \n     private void startAutoRecovery(BookieServer bserver,\n-            ServerConfiguration conf) throws CompatibilityException,\n-            KeeperException, InterruptedException, IOException,\n-            UnavailableException {\n+                                   ServerConfiguration conf) throws Exception {\n         if (isAutoRecoveryEnabled()) {\n             AutoRecoveryMain autoRecoveryProcess = new AutoRecoveryMain(conf);\n             autoRecoveryProcess.start();\n@@ -498,7 +492,7 @@ private void startAutoRecovery(BookieServer bserver,\n         }\n     }\n \n-    private void stopAutoRecoveryService(BookieServer toRemove) {\n+    private void stopAutoRecoveryService(BookieServer toRemove) throws Exception {\n         AutoRecoveryMain autoRecoveryMain = autoRecoveryProcesses\n                 .remove(toRemove);\n         if (null != autoRecoveryMain && isAutoRecoveryEnabled()) {\n@@ -512,21 +506,8 @@ private void stopAutoRecoveryService(BookieServer toRemove) {\n      * Will starts the auto recovery process for the bookie servers. One auto\n      * recovery process per each bookie server, if isAutoRecoveryEnabled is\n      * enabled.\n-     *\n-     * @throws CompatibilityException\n-     *             - Compatibility error\n-     * @throws KeeperException\n-     *             - ZK exception\n-     * @throws InterruptedException\n-     *             - interrupted exception\n-     * @throws IOException\n-     *             - IOException\n-     * @throws UnavailableException\n-     *             - replication service has become unavailable\n      */\n-    public void startReplicationService() throws CompatibilityException,\n-            KeeperException, InterruptedException, IOException,\n-            UnavailableException {\n+    public void startReplicationService() throws Exception {\n         int index = -1;\n         for (BookieServer bserver : bs) {\n             startAutoRecovery(bserver, bsConfs.get(++index));\n@@ -537,7 +518,7 @@ public void startReplicationService() throws CompatibilityException,\n      * Will stops all the auto recovery processes for the bookie cluster, if\n      * isAutoRecoveryEnabled is true.\n      */\n-    public void stopReplicationService() {\n+    public void stopReplicationService() throws Exception{\n         if(false == isAutoRecoveryEnabled()){\n             return;\n         }"}]}

