{"sha":"fd5bb2bce8585ef49ba01d853241a4ee36d487e2","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmZDViYjJiY2U4NTg1ZWY0OWJhMDFkODUzMjQxYTRlZTM2ZDQ4N2Uy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T11:29:03Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T11:29:03Z"},"message":"BOOKKEEPER-168: Message bounding on subscriptions (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1300510 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"26d5da074ab3cd7150b1f5305a21c214b1167e36","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/26d5da074ab3cd7150b1f5305a21c214b1167e36"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","html_url":"https://github.com/apache/bookkeeper/commit/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","url":"https://api.github.com/repos/apache/bookkeeper/commits/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","html_url":"https://github.com/apache/bookkeeper/commit/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5"}],"stats":{"total":13551,"additions":7147,"deletions":6404},"files":[{"sha":"e5b59f5cd00f9900214ba3edd7ead9d5a1a652b1","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -86,6 +86,8 @@ Trunk (unreleased changes)\n \n         BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n \n+        BOOKKEEPER-168: Message bounding on subscriptions (ivank)\n+\n       bookkeeper-benchmark/\n \tBOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n "},{"sha":"1f41d3f046c6e7af4327abf8cc2e124043832e3d","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -47,6 +47,15 @@ namespace Hedwig {\n     static const std::string SYNC_REQUEST_TIMEOUT;\n     static const std::string SUBSCRIBER_AUTOCONSUME;\n     static const std::string NUM_DISPATCH_THREADS;\n+    /**\n+     * The maximum number of messages the hub will queue for subscriptions\n+     * created using this configuration. The hub will always queue the most\n+     * recent messages. If there are enough publishes to the topic to hit\n+     * the bound, then the oldest messages are dropped from the queue.\n+     *\n+     * A bound of 0 disabled the bound completely.\n+     */\n+    static const std::string SUBSCRIPTION_MESSAGE_BOUND;\n \n   public:\n     Configuration() {};"},{"sha":"fc8da58414320019ca0b888af55d626e7eb1328c","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -34,6 +34,8 @@ namespace Hedwig {\n   public:\n     virtual void subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode) = 0;\n     virtual void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) = 0;\n+    virtual void subscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options) = 0;\n+    virtual void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options, const OperationCallbackPtr& callback) = 0;\n     \n     virtual void unsubscribe(const std::string& topic, const std::string& subscriberId) = 0;\n     virtual void asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback) = 0;  "},{"sha":"4b55f9ab8c1075a3e3db525d69123f435e165915","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -38,6 +38,7 @@ const std::string Configuration::RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME = \"hedwig.c\n const std::string Configuration::SYNC_REQUEST_TIMEOUT = \"hedwig.cpp.sync_request_timeout\";\n const std::string Configuration::SUBSCRIBER_AUTOCONSUME = \"hedwig.cpp.subscriber_autoconsume\";\n const std::string Configuration::NUM_DISPATCH_THREADS = \"hedwig.cpp.num_dispatch_threads\";\n+const std::string Configuration::SUBSCRIPTION_MESSAGE_BOUND = \"hedwig.cpp.subscription_message_bound\";\n \n Client::Client(const Configuration& conf) {\n   LOG4CXX_DEBUG(logger, \"Client::Client (\" << this << \")\");"},{"sha":"42fa2adf44224925fb8269017a5efb6470837463","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":9,"deletions":6,"changes":15,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -38,14 +38,14 @@ PubSubDataPtr PubSubData::forPublishRequest(long txnid, const std::string& topic\n   return ptr;\n }\n \n-PubSubDataPtr PubSubData::forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback, SubscribeRequest::CreateOrAttach mode) {\n+PubSubDataPtr PubSubData::forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback, const SubscriptionOptions& options) {\n   PubSubDataPtr ptr(new PubSubData());\n   ptr->type = SUBSCRIBE;\n   ptr->txnid = txnid;\n   ptr->subscriberid = subscriberid;\n   ptr->topic = topic;\n   ptr->callback = callback;\n-  ptr->mode = mode;\n+  ptr->options = options;\n   return ptr;  \n }\n \n@@ -69,7 +69,7 @@ PubSubDataPtr PubSubData::forConsumeRequest(long txnid, const std::string& subsc\n   return ptr;  \n }\n \n-PubSubData::PubSubData() : shouldClaim(false) {  \n+PubSubData::PubSubData() : shouldClaim(false), messageBound(0) {  \n }\n \n PubSubData::~PubSubData() {\n@@ -116,7 +116,10 @@ const PubSubRequestPtr PubSubData::getRequest() {\n \n     Hedwig::SubscribeRequest* subreq = request->mutable_subscriberequest();\n     subreq->set_subscriberid(subscriberid);\n-    subreq->set_createorattach(mode);\n+    subreq->set_createorattach(options.createorattach());\n+    if (options.messagebound() > 0) {\n+      subreq->set_messagebound(options.messagebound());\n+    }\n   } else if (type == CONSUME) {\n     LOG4CXX_DEBUG(logger, \"Creating consume request\");\n \n@@ -164,6 +167,6 @@ const std::string& PubSubData::getSubscriberId() const {\n   return subscriberid;\n }\n \n-SubscribeRequest::CreateOrAttach PubSubData::getMode() const {\n-  return mode;\n+const SubscriptionOptions& PubSubData::getSubscriptionOptions() const {\n+  return options;\n }"},{"sha":"d9d2ffdef79c75baab5c9446f296984ba7e2050f","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -62,7 +62,8 @@ namespace Hedwig {\n   public:\n     // to be used for publish\n     static PubSubDataPtr forPublishRequest(long txnid, const std::string& topic, const std::string& body, const OperationCallbackPtr& callback);\n-    static PubSubDataPtr forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback, SubscribeRequest::CreateOrAttach mode);\n+    static PubSubDataPtr forSubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic,\n+\t\t\t\t\t     const OperationCallbackPtr& callback, const SubscriptionOptions& options);\n     static PubSubDataPtr forUnsubscribeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const OperationCallbackPtr& callback);\n     static PubSubDataPtr forConsumeRequest(long txnid, const std::string& subscriberid, const std::string& topic, const MessageSeqId msgid);\n \n@@ -76,11 +77,12 @@ namespace Hedwig {\n     const MessageSeqId getMessageSeqId() const;\n \n     void setShouldClaim(bool shouldClaim);\n+    void setMessageBound(int messageBound);\n \n     const PubSubRequestPtr getRequest();\n     void setCallback(const OperationCallbackPtr& callback);\n     OperationCallbackPtr& getCallback();\n-    SubscribeRequest::CreateOrAttach getMode() const;\n+    const SubscriptionOptions& getSubscriptionOptions() const;\n \n     void addTriedServer(HostAddress& h);\n     bool hasTriedServer(HostAddress& h);\n@@ -95,8 +97,9 @@ namespace Hedwig {\n     std::string topic;\n     std::string body;\n     bool shouldClaim;\n+    int messageBound;\n     OperationCallbackPtr callback;\n-    SubscribeRequest::CreateOrAttach mode;\n+    SubscriptionOptions options;\n     MessageSeqId msgid;\n     std::tr1::unordered_set<HostAddress, HostAddressHash > triedservers;\n   };"},{"sha":"6f7d02e41e10ac18ffdb6d008a1341a9504f432d","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":23,"deletions":2,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -36,6 +36,7 @@ const int DEFAULT_SUBSCRIBER_CONSUME_RETRY_WAIT_TIME = 5000;\n const int DEFAULT_MAX_MESSAGE_QUEUE_SIZE = 10;\n const int DEFAULT_RECONNECT_SUBSCRIBE_RETRY_WAIT_TIME = 5000;\n const bool DEFAULT_SUBSCRIBER_AUTOCONSUME = true;\n+const int DEFAULT_SUBSCRIPTION_MESSAGE_BOUND = 0;\n \n SubscriberWriteCallback::SubscriberWriteCallback(const ClientImplPtr& client, const PubSubDataPtr& data) : client(client), data(data) {}\n \n@@ -298,17 +299,37 @@ SubscriberImpl::~SubscriberImpl()\n \n \n void SubscriberImpl::subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode) {\n+  SubscriptionOptions options;\n+  options.set_createorattach(mode);\n+  subscribe(topic, subscriberId, options);\n+}\n+\n+void SubscriberImpl::subscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options) {\n   SyncOperationCallback* cb = new SyncOperationCallback(client->getConfiguration().getInt(Configuration::SYNC_REQUEST_TIMEOUT, \n \t\t\t\t\t\t\t\t\t\t\t  DEFAULT_SYNC_REQUEST_TIMEOUT));\n   OperationCallbackPtr callback(cb);\n-  asyncSubscribe(topic, subscriberId, mode, callback);\n+  asyncSubscribe(topic, subscriberId, options, callback);\n   cb->wait();\n   \n   cb->throwExceptionIfNeeded();  \n }\n \n void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback) {\n-  PubSubDataPtr data = PubSubData::forSubscribeRequest(client->counter().next(), subscriberId, topic, callback, mode);\n+  SubscriptionOptions options;\n+  options.set_createorattach(mode);\n+  asyncSubscribe(topic, subscriberId, options, callback);\n+}\n+\n+void SubscriberImpl::asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options, const OperationCallbackPtr& callback) {\n+  SubscriptionOptions options2 = options;\n+\n+  if (!options2.has_messagebound()) {\n+    int messageBound = client->getConfiguration().getInt(Configuration::SUBSCRIPTION_MESSAGE_BOUND,\n+\t\t\t\t\t\t\t DEFAULT_SUBSCRIPTION_MESSAGE_BOUND);\n+    options2.set_messagebound(messageBound);\n+  }\n+\n+  PubSubDataPtr data = PubSubData::forSubscribeRequest(client->counter().next(), subscriberId, topic, callback, options2);\n \n   SubscriberClientChannelHandlerPtr handler(new SubscriberClientChannelHandler(client, *this, data));\n   ChannelHandlerPtr baseptr = handler;"},{"sha":"508a4957d60586258c05698de776cae98757d2a9","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -145,6 +145,8 @@ namespace Hedwig {\n \n     void subscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode);\n     void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscribeRequest::CreateOrAttach mode, const OperationCallbackPtr& callback);\n+    void subscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options);\n+    void asyncSubscribe(const std::string& topic, const std::string& subscriberId, const SubscriptionOptions& options, const OperationCallbackPtr& callback);\n     \n     void unsubscribe(const std::string& topic, const std::string& subscriberId);\n     void asyncUnsubscribe(const std::string& topic, const std::string& subscriberId, const OperationCallbackPtr& callback);"},{"sha":"5651e25269f5e9962fd6bd0f1c1196127095dc56","filename":"hedwig-client/src/main/cpp/log4cpp.conf","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/bookkeeper/blob/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5/hedwig-client/src/main/cpp/log4cpp.conf","raw_url":"https://github.com/apache/bookkeeper/raw/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5/hedwig-client/src/main/cpp/log4cpp.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/log4cpp.conf?ref=c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","patch":"@@ -1,49 +0,0 @@\n-#\n-# \n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-# \n-#   http://www.apache.org/licenses/LICENSE-2.0\n-# \n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-# \n-#\n-\n-log4j.appender.rootAppender=org.apache.log4j.ConsoleAppender\n-log4j.appender.rootAppender.layout=org.apache.log4j.BasicLayout\n-\n-#log4j.appender.hedwig=org.apache.log4j.RollingFileAppender\n-log4j.appender.hedwig=org.apache.log4j.ConsoleAppender\n-#log4j.appender.hedwig.fileName=./testLog.log\n-log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwig.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %t %c %p - %m%n\n-log4j.appender.hedwig.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwig.layout.ConversionPattern=%.5m%n\n-\n-log4j.appender.hedwigtest=org.apache.log4j.ConsoleAppender\n-#log4j.appender.hedwig.fileName=./testLog.log\n-log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwigtest.layout.ConversionPattern=[%d{%H:%M:%S.%l}] %c %p - %m%n\n-log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n-log4j.appender.hedwigtest.layout.ConversionPattern=%.5m%n\n-\n-# category\n-log4j.category.hedwig=DEBUG, hedwig\n-log4j.rootCategory=DEBUG\n-\n-log4j.category.hedwig.channel=ERROR\n-log4j.category.hedwig.util=ERROR\n-log4j.category.hedwigtest.servercontrol=ERROR\n-\n-log4j.category.hedwigtest=DEBUG, hedwigtest\n-log4j.rootCategory=DEBUG"},{"sha":"13ee220ba72082ca9de48a7c7390894f5c1edc25","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -38,12 +38,12 @@ log4j.appender.hedwigtest.layout=org.apache.log4j.PatternLayout\n log4j.appender.hedwigtest.layout.ConversionPattern=%.5m%n\n \n # category\n-log4j.category.hedwig=DEBUG, hedwig\n-log4j.rootCategory=DEBUG\n+log4j.category.hedwig=INFO, hedwig\n+log4j.rootCategory=INFO\n \n #log4j.category.hedwig.channel=ERROR\n log4j.category.hedwig.util=ERROR\n log4j.category.hedwigtest.servercontrol=ERROR\n \n-log4j.category.hedwigtest=DEBUG, hedwigtest\n-log4j.rootCategory=DEBUG\n+log4j.category.hedwigtest=INFO, hedwigtest\n+log4j.rootCategory=INFO"},{"sha":"0851eaf83ee83b12ae968d561d50f040868cc6b5","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"modified","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -19,6 +19,8 @@\n \n cd `dirname $0`;\n \n+export LOG4CXX_CONF=`pwd`/log4cxx.conf\n+\n source network-delays.sh\n source server-control.sh\n \n@@ -57,6 +59,41 @@ EOF\n     exit $RESULT\n }\n \n+singletest() {\n+    if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n+\tsetup_delays $HEDWIG_NETWORK_DELAY\n+    fi\n+\n+    stop_cluster;\n+    start_cluster;\n+\n+    ../test/hedwigtest $1\n+    RESULT=$?\n+    stop_cluster;\n+\n+    if [ \"z$HEDWIG_NETWORK_DELAY\" != \"z\" ]; then\n+\tclear_delays\n+    else\n+\tcat <<EOF\n+\n+The environment variable HEDWIG_NETWORK_DELAY is not set, so the tests were run directly \n+with a localhost server. This isn't quite realistic as usually there will be some delay between \n+the client and the hedwig server. Set HEDWIG_NETWORK_DELAY to the number of milliseconds you want\n+to delay the packets between the server and client. \n+\n+ $ export HEDWIG_NETWORK_DELAY=500\n+\n+Requires root privileges.\n+\n+WARNING!!! This will modify your traffic shaping and firewall rules. If you do run with delays, \n+check your firewall rules afterwards.\n+\n+EOF\n+    fi\n+\n+    exit $RESULT\n+}\n+\n case \"$1\" in\n     start-cluster)\n \tstart_cluster\n@@ -73,13 +110,19 @@ case \"$1\" in\n     all)\n \tall\n \t;;\n+    singletest)\n+\tsingletest $2\n+\t;;\n     *)\n \tcat <<EOF\n Usage: tester.sh [command]\n \n tester.sh all\n    Run through the tests, setting up and cleaning up all prerequisites.\n \n+tester.sh singletest <name>\n+   Run a single test\n+\n tester.sh start-cluster\n    Start a hedwig cluster\n "},{"sha":"00cdd356b5f72676900a27665543af75fa7950ff","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -17,7 +17,7 @@\n #\n \n bin_PROGRAMS = hedwigtest\n-hedwigtest_SOURCES = main.cpp utiltest.cpp pubsubdatatest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp\n+hedwigtest_SOURCES = main.cpp utiltest.cpp pubsubdatatest.cpp publishtest.cpp subscribetest.cpp pubsubtest.cpp messageboundtest.cpp\n hedwigtest_CPPFLAGS = -I$(top_srcdir)/inc $(DEPS_CFLAGS) $(TESTDEPS_CFLAGS) $(BOOST_CPPFLAGS) \n hedwigtest_LDADD = $(DEPS_LIBS) $(TESTDEPS_LIBS) -L$(top_builddir)/lib -lhedwig01 \n hedwigtest_LDFLAGS = -no-undefined $(BOOST_ASIO_LIB) $(BOOST_LDFLAGS) $(BOOST_THREAD_LIB)"},{"sha":"fbb1737d1099d65cb799836dfdaafc7f06c513d9","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -68,6 +68,7 @@ int main( int argc, char **argv)\n     registry.addRegistry(\"Subscribe\");\n     registry.addRegistry(\"Publish\"); \n     registry.addRegistry(\"PubSub\");\n+    registry.addRegistry(\"MessageBound\");\n     \n     runner.addTest( registry.makeTest() );\n   }"},{"sha":"5fe3995fd710feb4a063d21631db4cab7f7f2d48","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"modified","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -27,6 +27,7 @@\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.protocol.PubSubProtocol.MessageSeqId;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.util.Callback;\n \n /**\n@@ -82,6 +83,52 @@ public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach\n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n                                Object context);\n \n+\n+    /**\n+     * Subscribe to the given topic for the inputted subscriberId.\n+     *\n+     * @param topic\n+     *            Topic name of the subscription\n+     * @param subscriberId\n+     *            ID of the subscriber\n+     * @param options\n+     *            Options to pass to the subscription. Can contain attach mode.\n+     * @throws CouldNotConnectException\n+     *             If we are not able to connect to the server host\n+     * @throws ClientAlreadySubscribedException\n+     *             If client is already subscribed to the topic\n+     * @throws ServiceDownException\n+     *             If unable to subscribe to topic\n+     * @throws InvalidSubscriberIdException\n+     *             If the subscriberId is not valid. We may want to set aside\n+     *             certain formats of subscriberId's for different purposes.\n+     *             e.g. local vs. hub subscriber\n+     */\n+    public void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+        InvalidSubscriberIdException;\n+\n+    /**\n+     * Subscribe to the given topic asynchronously for the inputted subscriberId\n+     * disregarding if the topic has been created yet or not.\n+     *\n+     * @param topic\n+     *            Topic name of the subscription\n+     * @param subscriberId\n+     *            ID of the subscriber\n+     * @param options\n+     *            Options to pass to the subscription. Can contain attach mode.\n+     * @param callback\n+     *            Callback to invoke when the subscribe request to the server\n+     *            has actually gone through. This will have to deal with error\n+     *            conditions on the async subscribe request.\n+     * @param context\n+     *            Calling context that the Callback needs since this is done\n+     *            asynchronously.\n+     */\n+    public void asyncSubscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options,\n+                               Callback<Void> callback, Object context);\n+\n     /**\n      * Unsubscribe from a topic that the subscriberId user has previously\n      * subscribed to."},{"sha":"fa2c6d6df41ab5164366d59bef579d25e2eb0c34","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -41,6 +41,7 @@\n     protected static final String SERVER_ACK_RESPONSE_TIMEOUT = \"server_ack_response_timeout\";\n     protected static final String TIMEOUT_THREAD_RUN_INTERVAL = \"timeout_thread_run_interval\";\n     protected static final String SSL_ENABLED = \"ssl_enabled\";\n+    protected static final String SUBSCRIPTION_MESSAGE_BOUND = \"subscription_message_bound\";\n \n     // Singletons we want to instantiate only once per ClientConfiguration\n     protected HedwigSocketAddress myDefaultServerAddress = null;\n@@ -138,6 +139,18 @@ public boolean isSSLEnabled() {\n         return conf.getBoolean(SSL_ENABLED, false);\n     }\n \n+    /**\n+     * The maximum number of messages the hub will queue for subscriptions\n+     * created using this configuration. The hub will always queue the most\n+     * recent messages. If there are enough publishes to the topic to hit\n+     * the bound, then the oldest messages are dropped from the queue.\n+     *\n+     * A bound of 0 disabled the bound completely. This is the default.\n+     */\n+    public int getSubscriptionMessageBound() {\n+        return conf.getInt(SUBSCRIPTION_MESSAGE_BOUND, 0);\n+    }\n+\n     // Validate that the configuration properties are valid.\n     public void validate() throws ConfigurationException {\n         if (isSSLEnabled() && getDefaultServerHedwigSocketAddress().getSSLSocketAddress() == null) {"},{"sha":"8460de00012ed26fadae2210912cea0e9ea2986f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"modified","additions":9,"deletions":10,"changes":19,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -22,7 +22,7 @@\n import com.google.protobuf.ByteString;\n import org.apache.hedwig.protocol.PubSubProtocol.Message;\n import org.apache.hedwig.protocol.PubSubProtocol.OperationType;\n-import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.util.Callback;\n \n /**\n@@ -45,10 +45,8 @@\n     // Enum to indicate what type of operation this PubSub request data object\n     // is for.\n     public final OperationType operationType;\n-    // Enum for subscribe requests to indicate if this is a CREATE, ATTACH, or\n-    // CREATE_OR_ATTACH subscription request. For non-subscribe requests,\n-    // this will be null.\n-    public final CreateOrAttach createOrAttach;\n+    // Options for the subscription\n+    public final SubscriptionOptions options;\n     // These two variables are not final since we might override them\n     // in the case of a Subscribe reconnect.\n     public Callback<Void> callback;\n@@ -84,13 +82,13 @@\n \n     // Constructor for all types of PubSub request data to send to the server\n     public PubSubData(final ByteString topic, final Message msg, final ByteString subscriberId,\n-                      final OperationType operationType, final CreateOrAttach createOrAttach, final Callback<Void> callback,\n-                      final Object context) {\n+                      final OperationType operationType, final SubscriptionOptions options,\n+                      final Callback<Void> callback, final Object context) {\n         this.topic = topic;\n         this.msg = msg;\n         this.subscriberId = subscriberId;\n         this.operationType = operationType;\n-        this.createOrAttach = createOrAttach;\n+        this.options = options;\n         this.callback = callback;\n         this.context = context;\n     }\n@@ -117,8 +115,9 @@ public String toString() {\n             sb.append(COMMA).append(\"SubscriberId: \" + subscriberId.toStringUtf8());\n         if (operationType != null)\n             sb.append(COMMA).append(\"Operation Type: \" + operationType.toString());\n-        if (createOrAttach != null)\n-            sb.append(COMMA).append(\"Create Or Attach: \" + createOrAttach.toString());\n+        if (options != null)\n+            sb.append(COMMA).append(\"Create Or Attach: \" + options.getCreateOrAttach().toString())\n+                .append(COMMA).append(\"Message Bound: \" + options.getMessageBound());\n         if (triedServers != null && triedServers.size() > 0) {\n             sb.append(COMMA).append(\"Tried Servers: \");\n             for (ByteString triedServer : triedServers) {"},{"sha":"15162b0c1bcf5dbcfaacab50b50530dfaa93f709","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":36,"deletions":14,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -48,6 +48,7 @@\n import org.apache.hedwig.protocol.PubSubProtocol.PubSubRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest;\n import org.apache.hedwig.protocol.PubSubProtocol.UnsubscribeRequest;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n import org.apache.hedwig.protoextensions.SubscriptionStateUtils;\n import org.apache.hedwig.util.Callback;\n@@ -80,16 +81,17 @@ public HedwigSubscriber(HedwigClientImpl client) {\n     // two flows are very similar. The assumption is that the input\n     // OperationType is either SUBSCRIBE or UNSUBSCRIBE.\n     private void subUnsub(ByteString topic, ByteString subscriberId, OperationType operationType,\n-                          CreateOrAttach createOrAttach) throws CouldNotConnectException, ClientAlreadySubscribedException,\n+                          SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException,\n         ClientNotSubscribedException, ServiceDownException {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Calling a sync subUnsub request for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n                          + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n-                         + createOrAttach);\n-        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, createOrAttach, null, null);\n+                         + options.getCreateOrAttach() + \", messageBound: \" + options.getMessageBound());\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, options, null, null);\n         synchronized (pubSubData) {\n             PubSubCallback pubSubCallback = new PubSubCallback(pubSubData);\n-            asyncSubUnsub(topic, subscriberId, pubSubCallback, null, operationType, createOrAttach);\n+            asyncSubUnsub(topic, subscriberId, pubSubCallback, null, operationType, options);\n             try {\n                 while (!pubSubData.isDone)\n                     pubSubData.wait();\n@@ -133,14 +135,14 @@ else if (failureException instanceof ServiceDownException)\n     // flows are very similar. The assumption is that the input OperationType is\n     // either SUBSCRIBE or UNSUBSCRIBE.\n     private void asyncSubUnsub(ByteString topic, ByteString subscriberId, Callback<Void> callback, Object context,\n-                               OperationType operationType, CreateOrAttach createOrAttach) {\n+                               OperationType operationType, SubscriptionOptions options) {\n         if (logger.isDebugEnabled())\n             logger.debug(\"Calling an async subUnsub request for topic: \" + topic.toStringUtf8() + \", subscriberId: \"\n                          + subscriberId.toStringUtf8() + \", operationType: \" + operationType + \", createOrAttach: \"\n-                         + createOrAttach);\n+                         + options.getCreateOrAttach() + \", messageBound: \" + options.getMessageBound());\n         // Check if we know which server host is the master for the topic we are\n         // subscribing to.\n-        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, createOrAttach, callback,\n+        PubSubData pubSubData = new PubSubData(topic, null, subscriberId, operationType, options, callback,\n                                                context);\n         if (client.topic2Host.containsKey(topic)) {\n             InetSocketAddress host = client.topic2Host.get(topic);\n@@ -175,10 +177,17 @@ private void asyncSubUnsub(ByteString topic, ByteString subscriberId, Callback<V\n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n         InvalidSubscriberIdException {\n-        subscribe(topic, subscriberId, mode, false);\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        subscribe(topic, subscriberId, options, false);\n     }\n \n-    protected void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, boolean isHub)\n+    public void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+         InvalidSubscriberIdException {\n+        subscribe(topic, subscriberId, options, false);\n+    }\n+\n+    protected void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options, boolean isHub)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n         InvalidSubscriberIdException {\n         // Validate that the format of the subscriberId is valid either as a\n@@ -188,7 +197,7 @@ protected void subscribe(ByteString topic, ByteString subscriberId, CreateOrAtta\n                                                    + \", isHub: \" + isHub);\n         }\n         try {\n-            subUnsub(topic, subscriberId, OperationType.SUBSCRIBE, mode);\n+            subUnsub(topic, subscriberId, OperationType.SUBSCRIBE, options);\n         } catch (ClientNotSubscribedException e) {\n             logger.error(\"Unexpected Exception thrown: \" + e.toString());\n             // This exception should never be thrown here. But just in case,\n@@ -200,10 +209,17 @@ protected void subscribe(ByteString topic, ByteString subscriberId, CreateOrAtta\n \n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n                                Object context) {\n-        asyncSubscribe(topic, subscriberId, mode, callback, context, false);\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        asyncSubscribe(topic, subscriberId, options, callback, context, false);\n     }\n \n-    protected void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode,\n+    public void asyncSubscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options,\n+                               Callback<Void> callback, Object context) {\n+        asyncSubscribe(topic, subscriberId, options, callback, context, false);\n+    }\n+\n+    protected void asyncSubscribe(ByteString topic, ByteString subscriberId,\n+                                  SubscriptionOptions options,\n                                   Callback<Void> callback, Object context, boolean isHub) {\n         // Validate that the format of the subscriberId is valid either as a\n         // local or hub subscriber.\n@@ -212,7 +228,7 @@ protected void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateO\n                                          \"SubscriberId passed is not valid: \" + subscriberId.toStringUtf8() + \", isHub: \" + isHub)));\n             return;\n         }\n-        asyncSubUnsub(topic, subscriberId, callback, context, OperationType.SUBSCRIBE, mode);\n+        asyncSubUnsub(topic, subscriberId, callback, context, OperationType.SUBSCRIBE, options);\n     }\n \n     public void unsubscribe(ByteString topic, ByteString subscriberId) throws CouldNotConnectException,\n@@ -333,11 +349,17 @@ protected void doSubUnsub(PubSubData pubSubData, Channel channel) {\n             // Create the SubscribeRequest\n             SubscribeRequest.Builder subscribeRequestBuilder = SubscribeRequest.newBuilder();\n             subscribeRequestBuilder.setSubscriberId(pubSubData.subscriberId);\n-            subscribeRequestBuilder.setCreateOrAttach(pubSubData.createOrAttach);\n+            subscribeRequestBuilder.setCreateOrAttach(pubSubData.options.getCreateOrAttach());\n             // For now, all subscribes should wait for all cross-regional\n             // subscriptions to be established before returning.\n             subscribeRequestBuilder.setSynchronous(true);\n \n+            if (pubSubData.options.getMessageBound() > 0) {\n+                subscribeRequestBuilder.setMessageBound(pubSubData.options.getMessageBound());\n+            } else if (cfg.getSubscriptionMessageBound() > 0) {\n+                subscribeRequestBuilder.setMessageBound(cfg.getSubscriptionMessageBound());\n+            }\n+\n             // Set the SubscribeRequest into the outer PubSubRequest\n             pubsubRequestBuilder.setSubscribeRequest(subscribeRequestBuilder);\n         } else {"},{"sha":"92f409d30e95f60512e764df8294005239ca1eda","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":6428,"deletions":6272,"changes":12700,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2"},{"sha":"b845c403e4af434c6b6e723c77bbcd03d9fe07de","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -96,6 +96,12 @@ message SubscribeRequest{\n \t\n \t// wait for cross-regional subscriptions to be established before returning\n \toptional bool synchronous = 4 [default = false];\n+\toptional uint32 messageBound = 5;\n+}\n+\n+message SubscriptionOptions {\n+    optional SubscribeRequest.CreateOrAttach createOrAttach = 2 [default = CREATE_OR_ATTACH];\n+    optional uint32 messageBound = 3 [default = 0];\n }\n \n message ConsumeRequest{\n@@ -162,6 +168,7 @@ enum StatusCode{\n     \n message SubscriptionState {\n     required MessageSeqId msgId = 1;\n+    optional uint32 messageBound = 2;\n }\n \n message LedgerRange{"},{"sha":"95ee04c831227b16bfde8465140c8df8606a2134","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":165,"deletions":34,"changes":199,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -20,6 +20,8 @@\n import java.io.IOException;\n import java.util.Enumeration;\n import java.util.Iterator;\n+import java.util.Set;\n+import java.util.HashSet;\n import java.util.Map;\n import java.util.TreeMap;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -120,6 +122,7 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n          * include the current ledger\n          */\n         TreeMap<Long, InMemoryLedgerRange> ledgerRanges = new TreeMap<Long, InMemoryLedgerRange>();\n+        int ledgerRangesZnodeVersion = -1;\n \n         /**\n          * This is the handle of the current ledger that is being used to write\n@@ -131,6 +134,9 @@ public InMemoryLedgerRange(LedgerRange range, long startSeqId) {\n          * Flag to release topic when encountering unrecoverable exceptions\n          */\n         AtomicBoolean doRelease = new AtomicBoolean(false);\n+\n+        final static int UNLIMITED = 0;\n+        int messageBound = UNLIMITED;\n     }\n \n     Map<ByteString, TopicInfo> topicInfos = new ConcurrentHashMap<ByteString, TopicInfo>();\n@@ -308,29 +314,123 @@ public void deliveredUntil(ByteString topic, Long seqId) {\n         // Nothing to do here. this is just a hint that we cannot use.\n     }\n \n+    class UpdateLedgerOp extends TopicOpQueuer.AsynchronousOp<Void> {\n+        private long ledgerDeleted;\n+\n+        public UpdateLedgerOp(ByteString topic, final Callback<Void> cb, final Object ctx, final long ledgerDeleted) {\n+            queuer.super(topic, cb, ctx);\n+            this.ledgerDeleted = ledgerDeleted;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final TopicInfo topicInfo = topicInfos.get(topic);\n+            if (topicInfo == null) {\n+                logger.error(\"Server is not responsible for topic!\");\n+                return;\n+            }\n+            boolean needsUpdate = false;\n+            LedgerRanges.Builder builder = LedgerRanges.newBuilder();\n+            final Set<Long> keysToRemove = new HashSet<Long>();\n+            for (Map.Entry<Long, InMemoryLedgerRange> e : topicInfo.ledgerRanges.entrySet()) {\n+                if (e.getValue().range.getLedgerId() == ledgerDeleted) {\n+                    needsUpdate = true;\n+                    keysToRemove.add(e.getKey());\n+                } else {\n+                    builder.addRanges(e.getValue().range);\n+                }\n+            }\n+            builder.addRanges(topicInfo.currentLedgerRange.range);\n+\n+            if (needsUpdate) {\n+                final LedgerRanges newRanges = builder.build();\n+                updateLedgerRangesNode(topic, newRanges, topicInfo.ledgerRangesZnodeVersion,\n+                                       new Callback<Integer>() {\n+                                           public void operationFinished(Object ctx, Integer newVersion) {\n+                                               // Finally, all done\n+                                               for (Long k : keysToRemove) {\n+                                                   topicInfo.ledgerRanges.remove(k);\n+                                               }\n+                                               topicInfo.ledgerRangesZnodeVersion = newVersion;\n+                                               cb.operationFinished(ctx, null);\n+                                           }\n+                                           public void operationFailed(Object ctx, PubSubException exception) {\n+                                               cb.operationFailed(ctx, exception);\n+                                           }\n+                                       }, ctx);\n+            } else {\n+                cb.operationFinished(ctx, null);\n+            }\n+        }\n+    }\n+\n+    class ConsumeUntilOp extends TopicOpQueuer.SynchronousOp {\n+        private final long seqId;\n+\n+        public ConsumeUntilOp(ByteString topic, long seqId) {\n+            queuer.super(topic);\n+            this.seqId = seqId;\n+        }\n+\n+        @Override\n+        public void runInternal() {\n+            TopicInfo topicInfo = topicInfos.get(topic);\n+            if (topicInfo == null) {\n+                logger.error(\"Server is not responsible for topic!\");\n+                return;\n+            }\n+\n+            for (Long endSeqIdIncluded : topicInfo.ledgerRanges.keySet()) {\n+                if (endSeqIdIncluded <= seqId) {\n+                    // This ledger's message entries have all been consumed already\n+                    // so it is safe to delete it from BookKeeper.\n+                    long ledgerId = topicInfo.ledgerRanges.get(endSeqIdIncluded).range.getLedgerId();\n+                    try {\n+                        bk.deleteLedger(ledgerId);\n+                        Callback<Void> cb = new Callback<Void>() {\n+                            public void operationFinished(Object ctx, Void result) {\n+                                // do nothing, op is async to stop other ops\n+                                // occurring on the topic during the update\n+                            }\n+                            public void operationFailed(Object ctx, PubSubException exception) {\n+                                logger.error(\"Failed to update ledger znode\", exception);\n+                            }\n+                        };\n+                        queuer.pushAndMaybeRun(topic, new UpdateLedgerOp(topic, cb, null, ledgerId));\n+                    } catch (Exception e) {\n+                        // For now, just log an exception error message. In the\n+                        // future, we can have more complicated retry logic to\n+                        // delete a consumed ledger. The next time the ledger\n+                        // garbage collection job runs, we'll once again try to\n+                        // delete this ledger.\n+                        logger.error(\"Exception while deleting consumed ledgerId: \" + ledgerId, e);\n+                    }\n+                } else\n+                    break;\n+            }\n+        }\n+    }\n+\n     public void consumedUntil(ByteString topic, Long seqId) {\n+        queuer.pushAndMaybeRun(topic, new ConsumeUntilOp(topic, Math.max(seqId, getMinSeqIdForTopic(topic))));\n+    }\n+\n+    public void consumeToBound(ByteString topic) {\n         TopicInfo topicInfo = topicInfos.get(topic);\n-        if (topicInfo == null) {\n-            logger.error(\"Server is not responsible for topic!\");\n+\n+        if (topicInfo == null || topicInfo.messageBound == topicInfo.UNLIMITED) {\n             return;\n         }\n-        for (Long endSeqIdIncluded : topicInfo.ledgerRanges.keySet()) {\n-            if (endSeqIdIncluded <= seqId) {\n-                // This ledger's message entries have all been consumed already\n-                // so it is safe to delete it from BookKeeper.\n-                long ledgerId = topicInfo.ledgerRanges.get(endSeqIdIncluded).range.getLedgerId();\n-                try {\n-                    bk.deleteLedger(ledgerId);\n-                } catch (Exception e) {\n-                    // For now, just log an exception error message. In the\n-                    // future, we can have more complicated retry logic to\n-                    // delete a consumed ledger. The next time the ledger\n-                    // garbage collection job runs, we'll once again try to\n-                    // delete this ledger.\n-                    logger.error(\"Exception while deleting consumed ledgerId: \" + ledgerId, e);\n-                }\n-            } else\n-                break;\n+        queuer.pushAndMaybeRun(topic, new ConsumeUntilOp(topic, getMinSeqIdForTopic(topic)));\n+    }\n+\n+    public long getMinSeqIdForTopic(ByteString topic) {\n+        TopicInfo topicInfo = topicInfos.get(topic);\n+\n+        if (topicInfo == null || topicInfo.messageBound == topicInfo.UNLIMITED) {\n+            return Long.MIN_VALUE;\n+        } else {\n+            return (topicInfo.lastSeqIdPushed.getLocalComponent() - topicInfo.messageBound) + 1;\n         }\n     }\n \n@@ -345,7 +445,7 @@ public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) throws ServerNotRe\n     }\n \n     public long getSeqIdAfterSkipping(ByteString topic, long seqId, int skipAmount) {\n-        return seqId + skipAmount;\n+        return Math.max(seqId + skipAmount, getMinSeqIdForTopic(topic));\n     }\n \n     public class PersistOp extends TopicOpQueuer.SynchronousOp {\n@@ -615,7 +715,7 @@ public void safeReadComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> s\n                             LedgerRange lr = LedgerRange.newBuilder().setLedgerId(ledgerId)\n                                              .setEndSeqIdIncluded(lastMessage.getMsgId()).build();\n                             topicInfo.ledgerRanges.put(lr.getEndSeqIdIncluded().getLocalComponent(),\n-                                                       new InMemoryLedgerRange(lr, prevLedgerEnd + 1, lh));\n+                                    new InMemoryLedgerRange(lr, prevLedgerEnd + 1, lh));\n \n                             logger.info(\"Recovered unclosed ledger: \" + ledgerId + \" for topic: \"\n                                         + topic.toStringUtf8() + \" with \" + numEntriesInLastLedger + \" entries\");\n@@ -673,33 +773,40 @@ public void safeCreateComplete(int rc, LedgerHandle lh, Object ctx) {\n                     }\n                     builder.addRanges(lastRange);\n \n-                    writeTopicLedgersNode(topic, builder.build().toByteArray(), expectedVersionOfLedgersNode,\n-                                          topicInfo);\n+                    updateLedgerRangesNode(topic, builder.build(), expectedVersionOfLedgersNode,\n+                                           new Callback<Integer>() {\n+                                               public void operationFinished(Object ctx, Integer newVersion) {\n+                                                   // Finally, all done\n+                                                   topicInfo.ledgerRangesZnodeVersion = newVersion;\n+                                                   topicInfos.put(topic, topicInfo);\n+                                                   cb.operationFinished(ctx, null);\n+                                               }\n+                                               public void operationFailed(Object ctx, PubSubException exception) {\n+                                                   cb.operationFailed(ctx, exception);\n+                                               }\n+                                           }, ctx);\n                     return;\n                 }\n             }, ctx);\n         }\n+    }\n \n-        void writeTopicLedgersNode(final ByteString topic, byte[] data, int expectedVersion, final TopicInfo topicInfo) {\n-            final String zNodePath = ledgersPath(topic);\n+    public void updateLedgerRangesNode(final ByteString topic, LedgerRanges ranges,\n+                                       int version, final Callback<Integer> callback, Object ctx) {\n+        final String zNodePath = ledgersPath(topic);\n \n-            zk.setData(zNodePath, data, expectedVersion, new SafeAsyncZKCallback.StatCallback() {\n+        zk.setData(zNodePath, ranges.toByteArray(), version, new SafeAsyncZKCallback.StatCallback() {\n                 @Override\n                 public void safeProcessResult(int rc, String path, Object ctx, Stat stat) {\n                     if (rc != KeeperException.Code.OK.intValue()) {\n                         KeeperException ke = ZkUtils.logErrorAndCreateZKException(\n-                                                 \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n-                        cb.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n+                                \"Could not write ledgers node for topic: \" + topic.toStringUtf8(), path, rc);\n+                        callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke));\n                         return;\n                     }\n-\n-                    // Finally, all done\n-                    topicInfos.put(topic, topicInfo);\n-                    cb.operationFinished(ctx, null);\n+                    callback.operationFinished(ctx, stat.getVersion());\n                 }\n             }, ctx);\n-\n-        }\n     }\n \n     /**\n@@ -761,4 +868,28 @@ public void lostTopic(ByteString topic) {\n         queuer.pushAndMaybeRun(topic, new ReleaseOp(topic));\n     }\n \n+    class SetMessageBoundOp extends TopicOpQueuer.SynchronousOp {\n+        final int bound;\n+\n+        public SetMessageBoundOp(ByteString topic, int bound) {\n+            queuer.super(topic);\n+            this.bound = bound;\n+        }\n+\n+        @Override\n+        public void runInternal() {\n+            TopicInfo topicInfo = topicInfos.get(topic);\n+            if (topicInfo != null) {\n+                topicInfo.messageBound = bound;\n+            }\n+        }\n+    }\n+\n+    public void setMessageBound(ByteString topic, Integer bound) {\n+        queuer.pushAndMaybeRun(topic, new SetMessageBoundOp(topic, bound));\n+    }\n+\n+    public void clearMessageBound(ByteString topic) {\n+        queuer.pushAndMaybeRun(topic, new SetMessageBoundOp(topic, TopicInfo.UNLIMITED));\n+    }\n }"},{"sha":"4eff5930fa06d48c3c506321da3615ff4ba0cb25","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -398,6 +398,18 @@ public void consumedUntil(ByteString topic, Long seqId) {\n         }\n     }\n \n+    public void setMessageBound(ByteString topic, Integer bound) {\n+        // noop; Maybe implement later\n+    }\n+\n+    public void clearMessageBound(ByteString topic) {\n+        // noop; Maybe implement later\n+    }\n+\n+    public void consumeToBound(ByteString topic) {\n+        // noop; Maybe implement later\n+    }\n+\n     @Override\n     protected void finalize() throws Throwable {\n         if (driver.equals(\"org.apache.derby.jdbc.EmbeddedDriver\")) {"},{"sha":"0ee0a9bc7af95d5d3c79f2da9240caf1d3ee3810","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -88,4 +88,7 @@\n      */\n     public void consumedUntil(ByteString topic, Long seqId);\n \n+    public void setMessageBound(ByteString topic, Integer bound);\n+    public void clearMessageBound(ByteString topic);\n+    public void consumeToBound(ByteString topic);\n }"},{"sha":"5782bba46a3f8a8c207da43711393ed99c69a9e0","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -250,6 +250,18 @@ public void consumedUntil(ByteString topic, Long seqId) {\n         realPersistenceManager.consumedUntil(topic, seqId);\n     }\n \n+    public void setMessageBound(ByteString topic, Integer bound) {\n+        realPersistenceManager.setMessageBound(topic, bound);\n+    }\n+\n+    public void clearMessageBound(ByteString topic) {\n+        realPersistenceManager.clearMessageBound(topic);\n+    }\n+\n+    public void consumeToBound(ByteString topic) {\n+        realPersistenceManager.consumeToBound(topic);\n+    }\n+\n     /**\n      * ========================================================================\n      * BEGINNING OF CODE FOR THE CACHE MAINTAINER THREAD"},{"sha":"70552516fab84719da35326ac8fe2381b0fb009a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","status":"modified","additions":18,"deletions":2,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -26,6 +26,7 @@\n import org.apache.hedwig.exceptions.PubSubException.CouldNotConnectException;\n import org.apache.hedwig.exceptions.PubSubException.ServiceDownException;\n import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n import org.apache.hedwig.util.Callback;\n \n /**\n@@ -46,13 +47,28 @@ public HedwigHubSubscriber(HedwigClientImpl client) {\n     public void subscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode)\n             throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n         InvalidSubscriberIdException {\n-        subscribe(topic, subscriberId, mode, true);\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        subscribe(topic, subscriberId, options);\n     }\n \n     @Override\n     public void asyncSubscribe(ByteString topic, ByteString subscriberId, CreateOrAttach mode, Callback<Void> callback,\n                                Object context) {\n-        asyncSubscribe(topic, subscriberId, mode, callback, context, true);\n+        SubscriptionOptions options = SubscriptionOptions.newBuilder().setCreateOrAttach(mode).build();\n+        asyncSubscribe(topic, subscriberId, options, callback, context);\n+    }\n+\n+    @Override\n+    public void subscribe(ByteString topic, ByteString subscriberId, SubscriptionOptions options)\n+            throws CouldNotConnectException, ClientAlreadySubscribedException, ServiceDownException,\n+        InvalidSubscriberIdException {\n+        subscribe(topic, subscriberId, options, true);\n+    }\n+\n+    @Override\n+    public void asyncSubscribe(ByteString topic, ByteString subscriberId,\n+                               SubscriptionOptions options, Callback<Void> callback, Object context) {\n+        asyncSubscribe(topic, subscriberId, options, callback, context, true);\n     }\n \n     @Override"},{"sha":"ba841af50cbe265f31c505453523d48fecbc24ad","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":41,"deletions":7,"changes":48,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -111,6 +111,7 @@ public void run() {\n             for (ByteString topic : top2sub2seq.keySet()) {\n                 final Map<ByteString, InMemorySubscriptionState> topicSubscriptions = top2sub2seq.get(topic);\n                 long minConsumedMessage = Long.MAX_VALUE;\n+                boolean hasBound = true;\n                 // Loop through all subscribers to the current topic to find the\n                 // minimum consumed message id. The consume pointers are\n                 // persisted lazily so we'll use the stale in-memory value\n@@ -119,20 +120,20 @@ public void run() {\n                 for (InMemorySubscriptionState curSubscription : topicSubscriptions.values()) {\n                     if (curSubscription.getSubscriptionState().getMsgId().getLocalComponent() < minConsumedMessage)\n                         minConsumedMessage = curSubscription.getSubscriptionState().getMsgId().getLocalComponent();\n+                    hasBound = hasBound && curSubscription.getSubscriptionState().hasMessageBound();\n                 }\n                 boolean callPersistenceManager = true;\n                 // Don't call the PersistenceManager if nobody is subscribed to\n                 // the topic yet, or the consume pointer has not changed since\n                 // the last time, or if this is the initial subscription.\n                 if (topicSubscriptions.isEmpty()\n-                        || (topic2MinConsumedMessagesMap.containsKey(topic) && topic2MinConsumedMessagesMap.get(topic) == minConsumedMessage)\n-                        || minConsumedMessage == 0) {\n-                    callPersistenceManager = false;\n-                }\n-                // Pass the new consume pointers to the PersistenceManager.\n-                if (callPersistenceManager) {\n+                    || (topic2MinConsumedMessagesMap.containsKey(topic)\n+                        && topic2MinConsumedMessagesMap.get(topic) == minConsumedMessage)\n+                    || minConsumedMessage == 0) {\n                     topic2MinConsumedMessagesMap.put(topic, minConsumedMessage);\n                     pm.consumedUntil(topic, minConsumedMessage);\n+                } else if (hasBound) {\n+                    pm.consumeToBound(topic);\n                 }\n             }\n         }\n@@ -198,6 +199,8 @@ public void operationFinished(Object ctx, Void voidObj) {\n                     } else {\n                         cb2.operationFinished(ctx, null);\n                     }\n+\n+                    updateMessageBound(topic);\n                 }\n \n             }, ctx);\n@@ -360,7 +363,12 @@ public void run() {\n             }\n \n             // now the hard case, this is a brand new subscription, must record\n-            final SubscriptionState newState = SubscriptionState.newBuilder().setMsgId(consumeSeqId).build();\n+            SubscriptionState.Builder stateBuilder = SubscriptionState.newBuilder().setMsgId(consumeSeqId);\n+            if (subRequest.hasMessageBound()) {\n+                stateBuilder = stateBuilder.setMessageBound(subRequest.getMessageBound());\n+            }\n+            final SubscriptionState newState = stateBuilder.build();\n+\n             createSubscriptionState(topic, subscriberId, newState, new Callback<Void>() {\n                 @Override\n                 public void operationFailed(Object ctx, PubSubException exception) {\n@@ -406,6 +414,9 @@ private void finish() {\n                         @Override\n                         public void operationFinished(Object ctx, Void resultOfOperation) {\n                             topicSubscriptions.put(subscriberId, new InMemorySubscriptionState(newState));\n+\n+                            updateMessageBound(topic);\n+\n                             cb.operationFinished(ctx, consumeSeqId);\n                         }\n \n@@ -421,6 +432,27 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n         }\n     }\n \n+    public void updateMessageBound(ByteString topic) {\n+        final Map<ByteString, InMemorySubscriptionState> topicSubscriptions = top2sub2seq.get(topic);\n+        if (topicSubscriptions == null) {\n+            return;\n+        }\n+        int maxBound = Integer.MIN_VALUE;\n+        for (Map.Entry<ByteString, InMemorySubscriptionState> e : topicSubscriptions.entrySet()) {\n+            if (!e.getValue().getSubscriptionState().hasMessageBound()) {\n+                maxBound = Integer.MIN_VALUE;\n+                break;\n+            } else {\n+                maxBound = Math.max(maxBound, e.getValue().getSubscriptionState().getMessageBound());\n+            }\n+        }\n+        if (maxBound == Integer.MIN_VALUE) {\n+            pm.clearMessageBound(topic);\n+        } else {\n+            pm.setMessageBound(topic, maxBound);\n+        }\n+    }\n+\n     @Override\n     public void serveSubscribeRequest(ByteString topic, SubscribeRequest subRequest, MessageSeqId consumeSeqId,\n                                       Callback<MessageSeqId> callback, Object ctx) {\n@@ -508,6 +540,8 @@ public void operationFinished(Object ctx, Void resultOfOperation) {\n                     if (!SubscriptionStateUtils.isHubSubscriber(subscriberId)\n                             && topic2LocalCounts.get(topic).decrementAndGet() == 0)\n                         notifyUnsubcribe(topic);\n+\n+                    updateMessageBound(topic);\n                     cb.operationFinished(ctx, null);\n                 }\n             }, ctx);"},{"sha":"dec7ca773ccd2d2bf05d1de7e0617fcaf968cc49","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","status":"added","additions":241,"deletions":0,"changes":241,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -0,0 +1,241 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hedwig.server.persistence;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.hedwig.client.HedwigClient;\n+import org.apache.hedwig.client.api.MessageHandler;\n+import com.google.protobuf.ByteString;\n+import org.apache.hedwig.protocol.PubSubProtocol.Message;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach;\n+import org.apache.hedwig.protocol.PubSubProtocol.SubscriptionOptions;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRange;\n+import org.apache.hedwig.protocol.PubSubProtocol.LedgerRanges;\n+\n+import org.apache.hedwig.client.api.Client;\n+import org.apache.hedwig.client.api.Subscriber;\n+import org.apache.hedwig.client.api.Publisher;\n+import org.apache.hedwig.client.conf.ClientConfiguration;\n+import org.apache.hedwig.util.Callback;\n+\n+import org.apache.hedwig.server.HedwigHubTestBase;\n+import org.apache.hedwig.server.common.ServerConfiguration;\n+\n+public class MessageBoundedPersistenceTest extends HedwigHubTestBase {\n+    protected static Logger logger = LoggerFactory.getLogger(MessageBoundedPersistenceTest.class);\n+\n+    protected class SmallReadAheadServerConfiguration\n+        extends HedwigHubTestBase.HubServerConfiguration {\n+        SmallReadAheadServerConfiguration(int serverPort, int sslServerPort) {\n+            super(serverPort, sslServerPort);\n+        }\n+        public long getMaximumCacheSize() {\n+            return 1;\n+        }\n+\n+        public int getReadAheadCount() {\n+            return 1;\n+        }\n+\n+        public int getMessagesConsumedThreadRunInterval() {\n+            return 1000; // run every second\n+        }\n+    }\n+\n+    protected ServerConfiguration getServerConfiguration(int serverPort, int sslServerPort) {\n+        return new SmallReadAheadServerConfiguration(serverPort, sslServerPort);\n+    }\n+\n+    private class MessageBoundClientConfiguration extends ClientConfiguration {\n+        final int messageBound;\n+\n+        public MessageBoundClientConfiguration(int bound) {\n+            this.messageBound = bound;\n+        }\n+\n+        public MessageBoundClientConfiguration() {\n+            this(5);\n+        }\n+\n+        public int getSubscriptionMessageBound() {\n+            return messageBound;\n+        }\n+    }\n+\n+    private void sendXExpectLastY(Publisher pub, Subscriber sub,\n+                                  ByteString topic, ByteString subid,\n+                                  final int X, final int Y) throws Exception {\n+        for (int i = 0; i < X; i++) {\n+            pub.publish(topic, Message.newBuilder().setBody(\n+                                ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+        sub.subscribe(topic, subid, CreateOrAttach.ATTACH);\n+\n+        final AtomicInteger expected = new AtomicInteger(X - Y);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        sub.startDelivery(topic, subid, new MessageHandler () {\n+                synchronized public void deliver(ByteString topic, ByteString subscriberId,\n+                                    Message msg, Callback<Void> callback,\n+                                    Object context) {\n+                    try {\n+                        int value = Integer.valueOf(msg.getBody().toStringUtf8());\n+\n+                        if (value == expected.get()) {\n+                            expected.incrementAndGet();\n+                        } else {\n+                            // error condition\n+                            logger.error(\"Did not receive expected value, expected {}, got {}\",\n+                                         expected.get(), value);\n+                            expected.set(0);\n+                            latch.countDown();\n+                        }\n+                        if (expected.get() == X) {\n+                            latch.countDown();\n+                        }\n+                        callback.operationFinished(context, null);\n+                    } catch (Exception e) {\n+                        logger.error(\"Received bad message\", e);\n+                        latch.countDown();// will error on match\n+                    }\n+                }\n+            });\n+        assertTrue(\"Timed out waiting for messages Y is \" + Y\n+                + \" expected is currently \" + expected.get(), latch.await(10, TimeUnit.SECONDS));\n+        assertEquals(\"Should be expected message with \" + X, X, expected.get());\n+\n+        sub.stopDelivery(topic, subid);\n+        sub.closeSubscription(topic, subid);\n+    }\n+\n+    @Test\n+    public void testBasicBounding() throws Exception {\n+        Client client = new HedwigClient(new MessageBoundClientConfiguration(5));\n+        Publisher pub = client.getPublisher();\n+        Subscriber sub = client.getSubscriber();\n+\n+        ByteString topic = ByteString.copyFromUtf8(\"basicBoundingTopic\");\n+        ByteString subid = ByteString.copyFromUtf8(\"basicBoundingSubId\");\n+        sub.subscribe(topic, subid, CreateOrAttach.CREATE);\n+        sub.closeSubscription(topic, subid);\n+\n+        sendXExpectLastY(pub, sub, topic, subid, 1000, 5);\n+\n+        client.close();\n+    }\n+\n+    @Test\n+    public void testMultipleSubscribers() throws Exception {\n+        ByteString topic = ByteString.copyFromUtf8(\"multiSubTopic\");\n+\n+        Client client = new HedwigClient(new ClientConfiguration());\n+        Publisher pub = client.getPublisher();\n+        Subscriber sub = client.getSubscriber();\n+\n+        SubscriptionOptions options5 = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE).setMessageBound(5).build();\n+        SubscriptionOptions options20 = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE).setMessageBound(20).build();\n+        SubscriptionOptions optionsUnbounded = SubscriptionOptions.newBuilder()\n+            .setCreateOrAttach(CreateOrAttach.CREATE).build();\n+\n+        ByteString subid5 = ByteString.copyFromUtf8(\"bound5SubId\");\n+        ByteString subid20 = ByteString.copyFromUtf8(\"bound20SubId\");\n+        ByteString subidUnbounded = ByteString.copyFromUtf8(\"noboundSubId\");\n+\n+        sub.subscribe(topic, subid5, options5);\n+        sub.closeSubscription(topic, subid5);\n+        sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n+\n+        sub.subscribe(topic, subid20, options20);\n+        sub.closeSubscription(topic, subid20);\n+        sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n+\n+        sub.subscribe(topic, subidUnbounded, optionsUnbounded);\n+        sub.closeSubscription(topic, subidUnbounded);\n+\n+        sendXExpectLastY(pub, sub, topic, subidUnbounded, 10000, 10000);\n+        sub.unsubscribe(topic, subidUnbounded);\n+\n+        sendXExpectLastY(pub, sub, topic, subid20, 1000, 20);\n+        sub.unsubscribe(topic, subid20);\n+\n+        sendXExpectLastY(pub, sub, topic, subid5, 1000, 5);\n+        sub.unsubscribe(topic, subid5);\n+\n+        client.close();\n+    }\n+\n+    @Test\n+    public void testLedgerGC() throws Exception {\n+        Client client = new HedwigClient(new MessageBoundClientConfiguration());\n+        Publisher pub = client.getPublisher();\n+        Subscriber sub = client.getSubscriber();\n+\n+        String ledgersPath = \"/hedwig/standalone/topics/testGCTopic/ledgers\";\n+        ByteString topic = ByteString.copyFromUtf8(\"testGCTopic\");\n+        ByteString subid = ByteString.copyFromUtf8(\"testGCSubId\");\n+        sub.subscribe(topic, subid, CreateOrAttach.CREATE_OR_ATTACH);\n+        sub.closeSubscription(topic, subid);\n+\n+        for (int i = 1; i <= 100; i++) {\n+            pub.publish(topic, Message.newBuilder().setBody(\n+                                ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+        LedgerRanges r = LedgerRanges.parseFrom(bktb.getZooKeeperClient().getData(ledgersPath, false, null));\n+        assertEquals(\"Should only have 1 ledger yet\", 1, r.getRangesList().size());\n+        long firstLedger = r.getRangesList().get(0).getLedgerId();\n+\n+        stopHubServers();\n+        startHubServers();\n+\n+        pub.publish(topic, Message.newBuilder().setBody(\n+                            ByteString.copyFromUtf8(String.valueOf(0xdeadbeef))).build());\n+\n+        r = LedgerRanges.parseFrom(bktb.getZooKeeperClient().getData(ledgersPath, false, null));\n+        assertEquals(\"Should have 2 ledgers after restart\", 2, r.getRangesList().size());\n+\n+        for (int i = 100; i <= 200; i++) {\n+            pub.publish(topic, Message.newBuilder().setBody(\n+                                ByteString.copyFromUtf8(String.valueOf(i))).build());\n+        }\n+        Thread.sleep(5000); // give GC a chance to happen\n+\n+        r = LedgerRanges.parseFrom(bktb.getZooKeeperClient().getData(ledgersPath, false, null));\n+        long secondLedger = r.getRangesList().get(0).getLedgerId();\n+\n+        assertEquals(\"Should only have 1 ledger after GC\", 1, r.getRangesList().size());\n+\n+        // ensure original ledger doesn't exist\n+        String firstLedgerPath = String.format(\"/ledgers/L%010d\", firstLedger);\n+        String secondLedgerPath = String.format(\"/ledgers/L%010d\", secondLedger);\n+        assertNull(\"Ledger should not exist\", bktb.getZooKeeperClient().exists(firstLedgerPath, false));\n+        assertNotNull(\"Ledger should exist\", bktb.getZooKeeperClient().exists(secondLedgerPath, false));\n+\n+        client.close();\n+    }\n+}"},{"sha":"fecf86184a7472c2211590f4ef3f81e9761bb14e","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=fd5bb2bce8585ef49ba01d853241a4ee36d487e2","patch":"@@ -42,6 +42,18 @@ public void consumedUntil(ByteString topic, Long seqId) {\n         // noop\n     }\n \n+    public void setMessageBound(ByteString topic, Integer bound) {\n+        // noop\n+    }\n+\n+    public void clearMessageBound(ByteString topic) {\n+        // noop\n+    }\n+\n+    public void consumeToBound(ByteString topic) {\n+        // noop\n+    }\n+\n     protected static class ArrayListMessageFactory implements Factory<List<Message>> {\n         static ArrayListMessageFactory instance = new ArrayListMessageFactory();\n "}]}

