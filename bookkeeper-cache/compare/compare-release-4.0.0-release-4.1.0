{"url":"https://api.github.com/repos/apache/bookkeeper/compare/release-4.0.0...release-4.1.0","html_url":"https://github.com/apache/bookkeeper/compare/release-4.0.0...release-4.1.0","permalink_url":"https://github.com/apache/bookkeeper/compare/apache:92e28b6...apache:d867700","diff_url":"https://github.com/apache/bookkeeper/compare/release-4.0.0...release-4.1.0.diff","patch_url":"https://github.com/apache/bookkeeper/compare/release-4.0.0...release-4.1.0.patch","base_commit":{"sha":"92e28b6e79a3f0ec02b662ea90c0a0d41b9dfc84","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5MmUyOGI2ZTc5YTNmMGVjMDJiNjYyZWE5MGMwYTBkNDFiOWRmYzg0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T20:02:11Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T20:02:11Z"},"message":"BookKeeper 4.0.0 release.\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.0.0@1209674 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4e9f8b741674f0f4d772ea92214a73ab4bbe4e6d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4e9f8b741674f0f4d772ea92214a73ab4bbe4e6d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/92e28b6e79a3f0ec02b662ea90c0a0d41b9dfc84","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/92e28b6e79a3f0ec02b662ea90c0a0d41b9dfc84","html_url":"https://github.com/apache/bookkeeper/commit/92e28b6e79a3f0ec02b662ea90c0a0d41b9dfc84","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/92e28b6e79a3f0ec02b662ea90c0a0d41b9dfc84/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"b868541df524007163cc349d121f780012d5498f","url":"https://api.github.com/repos/apache/bookkeeper/commits/b868541df524007163cc349d121f780012d5498f","html_url":"https://github.com/apache/bookkeeper/commit/b868541df524007163cc349d121f780012d5498f"},{"sha":"02507b7ec53cdc72adda5365f2624bcc1696be74","url":"https://api.github.com/repos/apache/bookkeeper/commits/02507b7ec53cdc72adda5365f2624bcc1696be74","html_url":"https://github.com/apache/bookkeeper/commit/02507b7ec53cdc72adda5365f2624bcc1696be74"}]},"merge_base_commit":{"sha":"814f0ab6b4d43a35992e995c8abd804326ec633b","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MTRmMGFiNmI0ZDQzYTM1OTkyZTk5NWM4YWJkODA0MzI2ZWM2MzNi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T11:52:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T11:52:01Z"},"message":"Preparing for release 4.0.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208396 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ceb1a66301c5faa48e81f2a4fa2886f1baac41fd","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ceb1a66301c5faa48e81f2a4fa2886f1baac41fd"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/814f0ab6b4d43a35992e995c8abd804326ec633b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/814f0ab6b4d43a35992e995c8abd804326ec633b","html_url":"https://github.com/apache/bookkeeper/commit/814f0ab6b4d43a35992e995c8abd804326ec633b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/814f0ab6b4d43a35992e995c8abd804326ec633b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f2e9d4ca08e6ce254c61e0a27a04a7b2f95c6642","url":"https://api.github.com/repos/apache/bookkeeper/commits/f2e9d4ca08e6ce254c61e0a27a04a7b2f95c6642","html_url":"https://github.com/apache/bookkeeper/commit/f2e9d4ca08e6ce254c61e0a27a04a7b2f95c6642"}]},"status":"diverged","ahead_by":121,"behind_by":13,"total_commits":121,"commits":[{"sha":"5b90ba75a5cfa13a77297fd488024cd05ce07420","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1YjkwYmE3NWE1Y2ZhMTNhNzcyOTdmZDQ4ODAyNGNkMDVjZTA3NDIw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T11:59:57Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T11:59:57Z"},"message":"Fixing CHANGES.txt for new trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208398 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d3d842e9a12fb2460999991db3cf1c4f2ac05b4e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d3d842e9a12fb2460999991db3cf1c4f2ac05b4e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5b90ba75a5cfa13a77297fd488024cd05ce07420","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5b90ba75a5cfa13a77297fd488024cd05ce07420","html_url":"https://github.com/apache/bookkeeper/commit/5b90ba75a5cfa13a77297fd488024cd05ce07420","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5b90ba75a5cfa13a77297fd488024cd05ce07420/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"814f0ab6b4d43a35992e995c8abd804326ec633b","url":"https://api.github.com/repos/apache/bookkeeper/commits/814f0ab6b4d43a35992e995c8abd804326ec633b","html_url":"https://github.com/apache/bookkeeper/commit/814f0ab6b4d43a35992e995c8abd804326ec633b"}]},{"sha":"9794cc0c6d8531c1a6540db660e55add2469d019","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5Nzk0Y2MwYzZkODUzMWMxYTY1NDBkYjY2MGU1NWFkZDI0NjlkMDE5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T12:01:55Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T12:01:55Z"},"message":"Bumping version number for trunk: 4.0.0 -> 4.1.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208399 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fb21a0df69cead3e80a8fb3c3da8f50e4087a7a7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/fb21a0df69cead3e80a8fb3c3da8f50e4087a7a7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9794cc0c6d8531c1a6540db660e55add2469d019","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9794cc0c6d8531c1a6540db660e55add2469d019","html_url":"https://github.com/apache/bookkeeper/commit/9794cc0c6d8531c1a6540db660e55add2469d019","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9794cc0c6d8531c1a6540db660e55add2469d019/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"5b90ba75a5cfa13a77297fd488024cd05ce07420","url":"https://api.github.com/repos/apache/bookkeeper/commits/5b90ba75a5cfa13a77297fd488024cd05ce07420","html_url":"https://github.com/apache/bookkeeper/commit/5b90ba75a5cfa13a77297fd488024cd05ce07420"}]},{"sha":"3bc2bdb0d0f38b004fa95a58e8b02104005c663b","node_id":"MDY6Q29tbWl0MTU3NTk1NjozYmMyYmRiMGQwZjM4YjAwNGZhOTVhNThlOGIwMjEwNDAwNWM2NjNi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T15:42:14Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T15:42:14Z"},"message":"BOOKKEEPER-66: use IPv4 for builds (mmorel via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208472 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d7b0aa7171f6dc6fe795c42180147f6fa8059070","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d7b0aa7171f6dc6fe795c42180147f6fa8059070"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3bc2bdb0d0f38b004fa95a58e8b02104005c663b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3bc2bdb0d0f38b004fa95a58e8b02104005c663b","html_url":"https://github.com/apache/bookkeeper/commit/3bc2bdb0d0f38b004fa95a58e8b02104005c663b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3bc2bdb0d0f38b004fa95a58e8b02104005c663b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9794cc0c6d8531c1a6540db660e55add2469d019","url":"https://api.github.com/repos/apache/bookkeeper/commits/9794cc0c6d8531c1a6540db660e55add2469d019","html_url":"https://github.com/apache/bookkeeper/commit/9794cc0c6d8531c1a6540db660e55add2469d019"}]},{"sha":"63b032331f28fe434ea37d7cb2e515609298b7ed","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2M2IwMzIzMzFmMjhmZTQzNGVhMzdkN2NiMmU1MTU2MDkyOThiN2Vk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T16:18:45Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-11-30T16:18:45Z"},"message":"BOOKKEEPER-132: Sign artifacts before deploying to maven (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1208487 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"42ca1fb4433a7c53208f9396eb02a6340f4b8e8b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/42ca1fb4433a7c53208f9396eb02a6340f4b8e8b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/63b032331f28fe434ea37d7cb2e515609298b7ed","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/63b032331f28fe434ea37d7cb2e515609298b7ed","html_url":"https://github.com/apache/bookkeeper/commit/63b032331f28fe434ea37d7cb2e515609298b7ed","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/63b032331f28fe434ea37d7cb2e515609298b7ed/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3bc2bdb0d0f38b004fa95a58e8b02104005c663b","url":"https://api.github.com/repos/apache/bookkeeper/commits/3bc2bdb0d0f38b004fa95a58e8b02104005c663b","html_url":"https://github.com/apache/bookkeeper/commit/3bc2bdb0d0f38b004fa95a58e8b02104005c663b"}]},{"sha":"86844d7303f62a8e2361ca56d83ba2d47e5c77b8","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4Njg0NGQ3MzAzZjYyYThlMjM2MWNhNTZkODNiYTJkNDdlNWM3N2I4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-01T21:08:08Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-01T21:08:08Z"},"message":"BOOKKEEPER-131: Fix zookeeper test dependency (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1209237 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3f357f1b537084468c7c1d4fa089b76a375ad180","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3f357f1b537084468c7c1d4fa089b76a375ad180"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/86844d7303f62a8e2361ca56d83ba2d47e5c77b8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/86844d7303f62a8e2361ca56d83ba2d47e5c77b8","html_url":"https://github.com/apache/bookkeeper/commit/86844d7303f62a8e2361ca56d83ba2d47e5c77b8","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/86844d7303f62a8e2361ca56d83ba2d47e5c77b8/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"63b032331f28fe434ea37d7cb2e515609298b7ed","url":"https://api.github.com/repos/apache/bookkeeper/commits/63b032331f28fe434ea37d7cb2e515609298b7ed","html_url":"https://github.com/apache/bookkeeper/commit/63b032331f28fe434ea37d7cb2e515609298b7ed"}]},{"sha":"dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkY2ZlNGJjYzUxMjNlYjcwYTUzNjZiYmYzYjQ5MzFkOGQyM2Y5ZTQ4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-01T22:26:46Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-01T22:26:46Z"},"message":"BOOKKEEPER-134: Delete superfluous lib directories (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1209276 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"540305d2206f69c933ed158634efe7ae6b5b9b28","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/540305d2206f69c933ed158634efe7ae6b5b9b28"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","html_url":"https://github.com/apache/bookkeeper/commit/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"86844d7303f62a8e2361ca56d83ba2d47e5c77b8","url":"https://api.github.com/repos/apache/bookkeeper/commits/86844d7303f62a8e2361ca56d83ba2d47e5c77b8","html_url":"https://github.com/apache/bookkeeper/commit/86844d7303f62a8e2361ca56d83ba2d47e5c77b8"}]},{"sha":"213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyMTNkYjVkNmE2ZDU1YjViMDkzNzc2YTRjNTRmYTVjOGZmZWQ1ZjBk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T18:22:43Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T18:22:43Z"},"message":"Reverting BOOKKEEPER-130: Add developer KEYS file to svn (ivank) \n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1209621 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"df59c498098c8aa4311b80f31fe669bdca5eae44","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/df59c498098c8aa4311b80f31fe669bdca5eae44"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","html_url":"https://github.com/apache/bookkeeper/commit/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","url":"https://api.github.com/repos/apache/bookkeeper/commits/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48","html_url":"https://github.com/apache/bookkeeper/commit/dcfe4bcc5123eb70a5366bbf3b4931d8d23f9e48"}]},{"sha":"d006007ccf86f924d0773e267675a52e98314710","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkMDA2MDA3Y2NmODZmOTI0ZDA3NzNlMjY3Njc1YTUyZTk4MzE0NzEw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T19:33:43Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T19:33:43Z"},"message":"BOOKKEEPER-138: NOTICE.txt is invalid (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1209650 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"96f4b96cec08d0a2d7503e4aff89a2dd5d820009","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/96f4b96cec08d0a2d7503e4aff89a2dd5d820009"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d006007ccf86f924d0773e267675a52e98314710","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d006007ccf86f924d0773e267675a52e98314710","html_url":"https://github.com/apache/bookkeeper/commit/d006007ccf86f924d0773e267675a52e98314710","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d006007ccf86f924d0773e267675a52e98314710/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","url":"https://api.github.com/repos/apache/bookkeeper/commits/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d","html_url":"https://github.com/apache/bookkeeper/commit/213db5d6a6d55b5b093776a4c54fa5c8ffed5f0d"}]},{"sha":"1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxYzkwYmViNTlhNmFhOTRmMThjYTZiNWNhMWY5NGEwZGI1ZTBjYzE0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T19:58:59Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-02T19:58:59Z"},"message":"BOOKKEEPER-139: Binary packages do not carry NOTICE.txt (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1209671 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5ce62d86e1932970a9600465c5abe0cb61380b74","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/5ce62d86e1932970a9600465c5abe0cb61380b74"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","html_url":"https://github.com/apache/bookkeeper/commit/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"d006007ccf86f924d0773e267675a52e98314710","url":"https://api.github.com/repos/apache/bookkeeper/commits/d006007ccf86f924d0773e267675a52e98314710","html_url":"https://github.com/apache/bookkeeper/commit/d006007ccf86f924d0773e267675a52e98314710"}]},{"sha":"9eb549d4c308963af0be3288a59b0c4c39cbb5e6","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5ZWI1NDlkNGMzMDg5NjNhZjBiZTMyODhhNTliMGM0YzM5Y2JiNWU2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-16T11:43:31Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-16T11:43:31Z"},"message":"BOOKKEEPER-142: Parsing last log id is wrong, which may make entry log files overwritten (Sijie Gou via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1215098 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"38676d52e0abd8db81a1445f862bb0ae3a501e3b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/38676d52e0abd8db81a1445f862bb0ae3a501e3b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9eb549d4c308963af0be3288a59b0c4c39cbb5e6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9eb549d4c308963af0be3288a59b0c4c39cbb5e6","html_url":"https://github.com/apache/bookkeeper/commit/9eb549d4c308963af0be3288a59b0c4c39cbb5e6","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9eb549d4c308963af0be3288a59b0c4c39cbb5e6/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","url":"https://api.github.com/repos/apache/bookkeeper/commits/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14","html_url":"https://github.com/apache/bookkeeper/commit/1c90beb59a6aa94f18ca6b5ca1f94a0db5e0cc14"}]},{"sha":"015097021c1a2d2860643fda7fcb3e8a0d191442","node_id":"MDY6Q29tbWl0MTU3NTk1NjowMTUwOTcwMjFjMWEyZDI4NjA2NDNmZGE3ZmNiM2U4YTBkMTkxNDQy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-16T14:32:58Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-16T14:32:58Z"},"message":"BOOKKEEPER-141: Run extracting ledger id from entry log files in GC thread to speed up bookie restart (Sijie Gou via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1215156 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e58e2c4ad7e38e2b67a7a0a9b7685490f7eb17e0","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e58e2c4ad7e38e2b67a7a0a9b7685490f7eb17e0"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/015097021c1a2d2860643fda7fcb3e8a0d191442","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/015097021c1a2d2860643fda7fcb3e8a0d191442","html_url":"https://github.com/apache/bookkeeper/commit/015097021c1a2d2860643fda7fcb3e8a0d191442","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/015097021c1a2d2860643fda7fcb3e8a0d191442/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9eb549d4c308963af0be3288a59b0c4c39cbb5e6","url":"https://api.github.com/repos/apache/bookkeeper/commits/9eb549d4c308963af0be3288a59b0c4c39cbb5e6","html_url":"https://github.com/apache/bookkeeper/commit/9eb549d4c308963af0be3288a59b0c4c39cbb5e6"}]},{"sha":"8f755ed13f193ad6491fdca1794d834f3d3d4dcc","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4Zjc1NWVkMTNmMTkzYWQ2NDkxZmRjYTE3OTRkODM0ZjNkM2Q0ZGNj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-21T16:43:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-21T16:43:23Z"},"message":"BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1221798 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0bc707992820f86936e45d818023b629fd31b58b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0bc707992820f86936e45d818023b629fd31b58b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","html_url":"https://github.com/apache/bookkeeper/commit/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"015097021c1a2d2860643fda7fcb3e8a0d191442","url":"https://api.github.com/repos/apache/bookkeeper/commits/015097021c1a2d2860643fda7fcb3e8a0d191442","html_url":"https://github.com/apache/bookkeeper/commit/015097021c1a2d2860643fda7fcb3e8a0d191442"}]},{"sha":"0975f069d90748eb43fcec7622d3961b0446ea28","node_id":"MDY6Q29tbWl0MTU3NTk1NjowOTc1ZjA2OWQ5MDc0OGViNDNmY2VjNzYyMmQzOTYxYjA0NDZlYTI4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-22T17:35:48Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2011-12-22T17:35:48Z"},"message":"BOOKKEEPER-133: Hub server should update subscription state to zookeeper when losing topic or shutting down (Sijie Gou via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1222365 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"be4b1c194d6d82acfe62272e905cf5b3e1a05b65","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/be4b1c194d6d82acfe62272e905cf5b3e1a05b65"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0975f069d90748eb43fcec7622d3961b0446ea28","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0975f069d90748eb43fcec7622d3961b0446ea28","html_url":"https://github.com/apache/bookkeeper/commit/0975f069d90748eb43fcec7622d3961b0446ea28","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0975f069d90748eb43fcec7622d3961b0446ea28/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"8f755ed13f193ad6491fdca1794d834f3d3d4dcc","url":"https://api.github.com/repos/apache/bookkeeper/commits/8f755ed13f193ad6491fdca1794d834f3d3d4dcc","html_url":"https://github.com/apache/bookkeeper/commit/8f755ed13f193ad6491fdca1794d834f3d3d4dcc"}]},{"sha":"e32715ad96558a9941910dd6ae91fc1c646baeb6","node_id":"MDY6Q29tbWl0MTU3NTk1NjplMzI3MTVhZDk2NTU4YTk5NDE5MTBkZDZhZTkxZmMxYzY0NmJhZWI2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-01-11T14:46:29Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-01-11T14:46:29Z"},"message":"BOOKKEEPER-148: Jenkins build is failing (ivank via fpj)\n\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1230070 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"12742b9a0819527a0c37d7f7ac9ef343aed503d2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/12742b9a0819527a0c37d7f7ac9ef343aed503d2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e32715ad96558a9941910dd6ae91fc1c646baeb6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e32715ad96558a9941910dd6ae91fc1c646baeb6","html_url":"https://github.com/apache/bookkeeper/commit/e32715ad96558a9941910dd6ae91fc1c646baeb6","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e32715ad96558a9941910dd6ae91fc1c646baeb6/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"0975f069d90748eb43fcec7622d3961b0446ea28","url":"https://api.github.com/repos/apache/bookkeeper/commits/0975f069d90748eb43fcec7622d3961b0446ea28","html_url":"https://github.com/apache/bookkeeper/commit/0975f069d90748eb43fcec7622d3961b0446ea28"}]},{"sha":"0d43f404ea145a35d46371967975f9590649a033","node_id":"MDY6Q29tbWl0MTU3NTk1NjowZDQzZjQwNGVhMTQ1YTM1ZDQ2MzcxOTY3OTc1Zjk1OTA2NDlhMDMz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-13T17:06:41Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-13T17:06:41Z"},"message":"BOOKKEEPER-40: BookieClientTest fails intermittantly (fpj via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1231187 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ae4c7445c876fb4cad1a5d352fd83632b7bcc3c7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ae4c7445c876fb4cad1a5d352fd83632b7bcc3c7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0d43f404ea145a35d46371967975f9590649a033","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0d43f404ea145a35d46371967975f9590649a033","html_url":"https://github.com/apache/bookkeeper/commit/0d43f404ea145a35d46371967975f9590649a033","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0d43f404ea145a35d46371967975f9590649a033/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e32715ad96558a9941910dd6ae91fc1c646baeb6","url":"https://api.github.com/repos/apache/bookkeeper/commits/e32715ad96558a9941910dd6ae91fc1c646baeb6","html_url":"https://github.com/apache/bookkeeper/commit/e32715ad96558a9941910dd6ae91fc1c646baeb6"}]},{"sha":"c7c8af741a2f532b554dcdabf85237c23ea14aaa","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjN2M4YWY3NDFhMmY1MzJiNTU0ZGNkYWJmODUyMzdjMjNlYTE0YWFh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-17T15:52:16Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-17T15:52:16Z"},"message":"BOOKKEEPER-150: Entry is lost when recovering a ledger with not enough bookies. (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1232448 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8187c27471a8edbc2602f76a136e0c30fa79a5d2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/8187c27471a8edbc2602f76a136e0c30fa79a5d2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c7c8af741a2f532b554dcdabf85237c23ea14aaa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c7c8af741a2f532b554dcdabf85237c23ea14aaa","html_url":"https://github.com/apache/bookkeeper/commit/c7c8af741a2f532b554dcdabf85237c23ea14aaa","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c7c8af741a2f532b554dcdabf85237c23ea14aaa/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"0d43f404ea145a35d46371967975f9590649a033","url":"https://api.github.com/repos/apache/bookkeeper/commits/0d43f404ea145a35d46371967975f9590649a033","html_url":"https://github.com/apache/bookkeeper/commit/0d43f404ea145a35d46371967975f9590649a033"}]},{"sha":"cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjZGNmYmI1MmNiZjhmMGU2ZjE3ZDU2ZDcxODVjZjBkMDRjOWM4NTZi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-18T12:09:48Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-18T12:09:48Z"},"message":"BOOKKEEPER-95: extends zookeeper JMX to monitor and manage bookie server (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1232852 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e17276b1ecde9592bf1ac4a4209f1256fcebab7f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e17276b1ecde9592bf1ac4a4209f1256fcebab7f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","html_url":"https://github.com/apache/bookkeeper/commit/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c7c8af741a2f532b554dcdabf85237c23ea14aaa","url":"https://api.github.com/repos/apache/bookkeeper/commits/c7c8af741a2f532b554dcdabf85237c23ea14aaa","html_url":"https://github.com/apache/bookkeeper/commit/c7c8af741a2f532b554dcdabf85237c23ea14aaa"}]},{"sha":"f56e596d70c66dac170008ffbe19489eee05be08","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmNTZlNTk2ZDcwYzY2ZGFjMTcwMDA4ZmZiZTE5NDg5ZWVlMDViZTA4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-18T14:11:46Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-01-18T14:11:46Z"},"message":"BOOKKEEPER-153: Ledger can't be opened or closed due to zero-length metadata (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1232890 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a6996565bccf8e92200c75e1e03630737ad7ec4c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a6996565bccf8e92200c75e1e03630737ad7ec4c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f56e596d70c66dac170008ffbe19489eee05be08","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f56e596d70c66dac170008ffbe19489eee05be08","html_url":"https://github.com/apache/bookkeeper/commit/f56e596d70c66dac170008ffbe19489eee05be08","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f56e596d70c66dac170008ffbe19489eee05be08/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","url":"https://api.github.com/repos/apache/bookkeeper/commits/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b","html_url":"https://github.com/apache/bookkeeper/commit/cdcfbb52cbf8f0e6f17d56d7185cf0d04c9c856b"}]},{"sha":"7e12629ed7a2006e4805dac0e5c006324a52d5db","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3ZTEyNjI5ZWQ3YTIwMDZlNDgwNWRhYzBlNWMwMDYzMjRhNTJkNWRi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T11:06:32Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T11:06:32Z"},"message":"BOOKKEEPER-23: Timeout requests (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1239068 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"eb0d55ddde8d5a721e80a972b23dd0628eb74726","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/eb0d55ddde8d5a721e80a972b23dd0628eb74726"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7e12629ed7a2006e4805dac0e5c006324a52d5db","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7e12629ed7a2006e4805dac0e5c006324a52d5db","html_url":"https://github.com/apache/bookkeeper/commit/7e12629ed7a2006e4805dac0e5c006324a52d5db","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7e12629ed7a2006e4805dac0e5c006324a52d5db/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f56e596d70c66dac170008ffbe19489eee05be08","url":"https://api.github.com/repos/apache/bookkeeper/commits/f56e596d70c66dac170008ffbe19489eee05be08","html_url":"https://github.com/apache/bookkeeper/commit/f56e596d70c66dac170008ffbe19489eee05be08"}]},{"sha":"5a7f4991610ad60d277830b72dc5d890c63a0f07","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1YTdmNDk5MTYxMGFkNjBkMjc3ODMwYjcyZGM1ZDg5MGM2M2EwZjA3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T11:58:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T11:58:17Z"},"message":"BOOKKEEPER-98: collect add/read statistics on bookie server (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1239096 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cb13099af00a3c1145c5c438da9719087dc07266","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cb13099af00a3c1145c5c438da9719087dc07266"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5a7f4991610ad60d277830b72dc5d890c63a0f07","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5a7f4991610ad60d277830b72dc5d890c63a0f07","html_url":"https://github.com/apache/bookkeeper/commit/5a7f4991610ad60d277830b72dc5d890c63a0f07","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5a7f4991610ad60d277830b72dc5d890c63a0f07/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"7e12629ed7a2006e4805dac0e5c006324a52d5db","url":"https://api.github.com/repos/apache/bookkeeper/commits/7e12629ed7a2006e4805dac0e5c006324a52d5db","html_url":"https://github.com/apache/bookkeeper/commit/7e12629ed7a2006e4805dac0e5c006324a52d5db"}]},{"sha":"d5fc00dc6b0a888b68131b7dff7309687c96d07e","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkNWZjMDBkYzZiMGE4ODhiNjgxMzFiN2RmZjczMDk2ODdjOTZkMDdl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T12:01:49Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-01T12:01:49Z"},"message":"Removing file accidentally added in r1239096\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1239098 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6d190177dac751683e0837f95b6678304dd3916d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6d190177dac751683e0837f95b6678304dd3916d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d5fc00dc6b0a888b68131b7dff7309687c96d07e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d5fc00dc6b0a888b68131b7dff7309687c96d07e","html_url":"https://github.com/apache/bookkeeper/commit/d5fc00dc6b0a888b68131b7dff7309687c96d07e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d5fc00dc6b0a888b68131b7dff7309687c96d07e/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"5a7f4991610ad60d277830b72dc5d890c63a0f07","url":"https://api.github.com/repos/apache/bookkeeper/commits/5a7f4991610ad60d277830b72dc5d890c63a0f07","html_url":"https://github.com/apache/bookkeeper/commit/5a7f4991610ad60d277830b72dc5d890c63a0f07"}]},{"sha":"835d963cb26d0a5d5b1cc79a0faf185b49673d16","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MzVkOTYzY2IyNmQwYTVkNWIxY2M3OWEwZmFmMTg1YjQ5NjczZDE2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-01T15:19:57Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-01T15:19:57Z"},"message":"BOOKKEEPER-157. For small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1239167 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"76085aa440080c3de0159c916fa20f02175046ce","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/76085aa440080c3de0159c916fa20f02175046ce"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16","html_url":"https://github.com/apache/bookkeeper/commit/835d963cb26d0a5d5b1cc79a0faf185b49673d16","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"d5fc00dc6b0a888b68131b7dff7309687c96d07e","url":"https://api.github.com/repos/apache/bookkeeper/commits/d5fc00dc6b0a888b68131b7dff7309687c96d07e","html_url":"https://github.com/apache/bookkeeper/commit/d5fc00dc6b0a888b68131b7dff7309687c96d07e"}]},{"sha":"cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjZmUzZTY1MGI2OWIyYjU5OWRkNWIyZjI3ZjIxNjRhZjM4YzdhMmJl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-07T10:03:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-07T10:03:17Z"},"message":"BOOKKEEPER-161: PerChannelBookieClient tries to reuse HashedWheelTimer, throws Exception (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241404 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9f48b9c2b23bf572ca5dcce5725851153a732c43","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9f48b9c2b23bf572ca5dcce5725851153a732c43"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","html_url":"https://github.com/apache/bookkeeper/commit/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"835d963cb26d0a5d5b1cc79a0faf185b49673d16","url":"https://api.github.com/repos/apache/bookkeeper/commits/835d963cb26d0a5d5b1cc79a0faf185b49673d16","html_url":"https://github.com/apache/bookkeeper/commit/835d963cb26d0a5d5b1cc79a0faf185b49673d16"}]},{"sha":"3272204448bf210d03377ba822d01419ad197a17","node_id":"MDY6Q29tbWl0MTU3NTk1NjozMjcyMjA0NDQ4YmYyMTBkMDMzNzdiYTgyMmQwMTQxOWFkMTk3YTE3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:40:19Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:40:19Z"},"message":"BOOKKEEPER-167: PerChannelBookieClient doesn't use ClientConfiguration (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241854 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"62493aef335dcaa36a55a4e9462a07a3b2c7e8e3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/62493aef335dcaa36a55a4e9462a07a3b2c7e8e3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3272204448bf210d03377ba822d01419ad197a17","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3272204448bf210d03377ba822d01419ad197a17","html_url":"https://github.com/apache/bookkeeper/commit/3272204448bf210d03377ba822d01419ad197a17","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3272204448bf210d03377ba822d01419ad197a17/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","url":"https://api.github.com/repos/apache/bookkeeper/commits/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be","html_url":"https://github.com/apache/bookkeeper/commit/cfe3e650b69b2b599dd5b2f27f2164af38c7a2be"}]},{"sha":"bd2efa12f1f63afa90723ce405caebafb4afd6be","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZDJlZmExMmYxZjYzYWZhOTA3MjNjZTQwNWNhZWJhZmI0YWZkNmJl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:40:43Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:40:43Z"},"message":"BOOKKEEPER-156: BookieJournalRollingTest failing (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241855 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f212240d29be185d88e087887b929bf275cefd88","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f212240d29be185d88e087887b929bf275cefd88"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/bd2efa12f1f63afa90723ce405caebafb4afd6be","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/bd2efa12f1f63afa90723ce405caebafb4afd6be","html_url":"https://github.com/apache/bookkeeper/commit/bd2efa12f1f63afa90723ce405caebafb4afd6be","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/bd2efa12f1f63afa90723ce405caebafb4afd6be/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3272204448bf210d03377ba822d01419ad197a17","url":"https://api.github.com/repos/apache/bookkeeper/commits/3272204448bf210d03377ba822d01419ad197a17","html_url":"https://github.com/apache/bookkeeper/commit/3272204448bf210d03377ba822d01419ad197a17"}]},{"sha":"a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","node_id":"MDY6Q29tbWl0MTU3NTk1NjphM2M5Yzk1M2RiNDliYzFlYzNkNzJmMDEyMTJlNmNiY2Q1OGNjNWQz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:49:10Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T10:49:10Z"},"message":"BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241858 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0f35da1b4e5785c402908d9172cd9baaf3246559","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0f35da1b4e5785c402908d9172cd9baaf3246559"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","html_url":"https://github.com/apache/bookkeeper/commit/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"bd2efa12f1f63afa90723ce405caebafb4afd6be","url":"https://api.github.com/repos/apache/bookkeeper/commits/bd2efa12f1f63afa90723ce405caebafb4afd6be","html_url":"https://github.com/apache/bookkeeper/commit/bd2efa12f1f63afa90723ce405caebafb4afd6be"}]},{"sha":"beca5951f73cb9c39be10a4166a90dee9fff3c1c","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZWNhNTk1MWY3M2NiOWMzOWJlMTBhNDE2NmE5MGRlZTlmZmYzYzFj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T14:54:29Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-08T14:54:29Z"},"message":"BOOKKEEPER-165: Add versioning support for journal files (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1241922 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"496c20256ef3a2ab3aef4771bac079d703d219f7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/496c20256ef3a2ab3aef4771bac079d703d219f7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c","html_url":"https://github.com/apache/bookkeeper/commit/beca5951f73cb9c39be10a4166a90dee9fff3c1c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","url":"https://api.github.com/repos/apache/bookkeeper/commits/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3","html_url":"https://github.com/apache/bookkeeper/commit/a3c9c953db49bc1ec3d72f01212e6cbcd58cc5d3"}]},{"sha":"c65d6ada34215ee3a5466c495d565d745857c435","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjNjVkNmFkYTM0MjE1ZWUzYTU0NjZjNDk1ZDU2NWQ3NDU4NTdjNDM1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-09T17:14:29Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-09T17:14:29Z"},"message":"BOOKKEEPER-137: Do not create Ledger index files until absolutely necessary. (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1242404 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3f53fe162a136968ec19a642394a9c9d423fd850","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3f53fe162a136968ec19a642394a9c9d423fd850"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c65d6ada34215ee3a5466c495d565d745857c435","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c65d6ada34215ee3a5466c495d565d745857c435","html_url":"https://github.com/apache/bookkeeper/commit/c65d6ada34215ee3a5466c495d565d745857c435","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c65d6ada34215ee3a5466c495d565d745857c435/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"beca5951f73cb9c39be10a4166a90dee9fff3c1c","url":"https://api.github.com/repos/apache/bookkeeper/commits/beca5951f73cb9c39be10a4166a90dee9fff3c1c","html_url":"https://github.com/apache/bookkeeper/commit/beca5951f73cb9c39be10a4166a90dee9fff3c1c"}]},{"sha":"29a472598083e522645f918ec602dd91d800f0d5","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyOWE0NzI1OTgwODNlNTIyNjQ1ZjkxOGVjNjAyZGQ5MWQ4MDBmMGQ1","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-13T10:19:17Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-13T10:19:17Z"},"message":"BOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1243462 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7d7b35a8f3edaf9b21b1c5b1b2cc1043664b13ab","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7d7b35a8f3edaf9b21b1c5b1b2cc1043664b13ab"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/29a472598083e522645f918ec602dd91d800f0d5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5","html_url":"https://github.com/apache/bookkeeper/commit/29a472598083e522645f918ec602dd91d800f0d5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"c65d6ada34215ee3a5466c495d565d745857c435","url":"https://api.github.com/repos/apache/bookkeeper/commits/c65d6ada34215ee3a5466c495d565d745857c435","html_url":"https://github.com/apache/bookkeeper/commit/c65d6ada34215ee3a5466c495d565d745857c435"}]},{"sha":"5a3b29d05abd71c6e5d1b3045abafd434db15f24","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1YTNiMjlkMDVhYmQ3MWM2ZTVkMWIzMDQ1YWJhZmQ0MzRkYjE1ZjI0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-13T14:46:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-13T14:46:38Z"},"message":"BOOKKEEPER-152: Can't recover a ledger whose current ensemble contain failed bookie. (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1243539 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e8099ca4f7243d4f58df205cc8f3ad0546f84763","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e8099ca4f7243d4f58df205cc8f3ad0546f84763"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24","html_url":"https://github.com/apache/bookkeeper/commit/5a3b29d05abd71c6e5d1b3045abafd434db15f24","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"29a472598083e522645f918ec602dd91d800f0d5","url":"https://api.github.com/repos/apache/bookkeeper/commits/29a472598083e522645f918ec602dd91d800f0d5","html_url":"https://github.com/apache/bookkeeper/commit/29a472598083e522645f918ec602dd91d800f0d5"}]},{"sha":"3defe9e5110472da995789b5ae14c286f58f1293","node_id":"MDY6Q29tbWl0MTU3NTk1NjozZGVmZTllNTExMDQ3MmRhOTk1Nzg5YjVhZTE0YzI4NmY1OGYxMjkz","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-02-15T09:58:37Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-02-15T09:58:37Z"},"message":"BOOKKEEPER-171: ServerConfiguration can't use more than one directory for ledgers\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1244421 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"58c95a78c7011c0d1ca02112e66559670074bc5a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/58c95a78c7011c0d1ca02112e66559670074bc5a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3defe9e5110472da995789b5ae14c286f58f1293","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3defe9e5110472da995789b5ae14c286f58f1293","html_url":"https://github.com/apache/bookkeeper/commit/3defe9e5110472da995789b5ae14c286f58f1293","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3defe9e5110472da995789b5ae14c286f58f1293/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"5a3b29d05abd71c6e5d1b3045abafd434db15f24","url":"https://api.github.com/repos/apache/bookkeeper/commits/5a3b29d05abd71c6e5d1b3045abafd434db15f24","html_url":"https://github.com/apache/bookkeeper/commit/5a3b29d05abd71c6e5d1b3045abafd434db15f24"}]},{"sha":"633a23b3a20b27a551328be2efe5f057be3c99e2","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2MzNhMjNiM2EyMGIyN2E1NTEzMjhiZTJlZmU1ZjA1N2JlM2M5OWUy","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-15T15:11:53Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-15T15:11:53Z"},"message":"BOOKKEEPER-170: Bookie constructor starts a number of threads. (ivank via fpj)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1244528 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"127bd4fb912ac837d8554453eaa0d3908d7326ee","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/127bd4fb912ac837d8554453eaa0d3908d7326ee"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/633a23b3a20b27a551328be2efe5f057be3c99e2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/633a23b3a20b27a551328be2efe5f057be3c99e2","html_url":"https://github.com/apache/bookkeeper/commit/633a23b3a20b27a551328be2efe5f057be3c99e2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/633a23b3a20b27a551328be2efe5f057be3c99e2/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"3defe9e5110472da995789b5ae14c286f58f1293","url":"https://api.github.com/repos/apache/bookkeeper/commits/3defe9e5110472da995789b5ae14c286f58f1293","html_url":"https://github.com/apache/bookkeeper/commit/3defe9e5110472da995789b5ae14c286f58f1293"}]},{"sha":"bad375aa35a2c17c466d2be7481e7d16220d59b0","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiYWQzNzVhYTM1YTJjMTdjNDY2ZDJiZTc0ODFlN2QxNjIyMGQ1OWIw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-17T10:18:00Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-17T10:18:00Z"},"message":"BOOKKEEPER-169: bookie hangs on reading header when encountering partial header index file (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1245369 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"da458bc6e691dd6f8b5d12496c73d0d5aad2eb77","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/da458bc6e691dd6f8b5d12496c73d0d5aad2eb77"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/bad375aa35a2c17c466d2be7481e7d16220d59b0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/bad375aa35a2c17c466d2be7481e7d16220d59b0","html_url":"https://github.com/apache/bookkeeper/commit/bad375aa35a2c17c466d2be7481e7d16220d59b0","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/bad375aa35a2c17c466d2be7481e7d16220d59b0/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"633a23b3a20b27a551328be2efe5f057be3c99e2","url":"https://api.github.com/repos/apache/bookkeeper/commits/633a23b3a20b27a551328be2efe5f057be3c99e2","html_url":"https://github.com/apache/bookkeeper/commit/633a23b3a20b27a551328be2efe5f057be3c99e2"}]},{"sha":"014bcd501c14141facd0e3eb4bb488ccba3a2b7d","node_id":"MDY6Q29tbWl0MTU3NTk1NjowMTRiY2Q1MDFjMTQxNDFmYWNkMGUzZWI0YmI0ODhjY2JhM2EyYjdk","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-17T11:50:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-17T11:50:23Z"},"message":"BOOKKEEPER-174: Bookie can't start when replaying entries whose ledger were deleted and garbage collected. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1245411 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"69bfea457f46215764d306387a2c5de3dc86373d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/69bfea457f46215764d306387a2c5de3dc86373d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/014bcd501c14141facd0e3eb4bb488ccba3a2b7d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/014bcd501c14141facd0e3eb4bb488ccba3a2b7d","html_url":"https://github.com/apache/bookkeeper/commit/014bcd501c14141facd0e3eb4bb488ccba3a2b7d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/014bcd501c14141facd0e3eb4bb488ccba3a2b7d/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"bad375aa35a2c17c466d2be7481e7d16220d59b0","url":"https://api.github.com/repos/apache/bookkeeper/commits/bad375aa35a2c17c466d2be7481e7d16220d59b0","html_url":"https://github.com/apache/bookkeeper/commit/bad375aa35a2c17c466d2be7481e7d16220d59b0"}]},{"sha":"110d36673bcc393853aaab4bb423d785daa947c7","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxMTBkMzY2NzNiY2MzOTM4NTNhYWFiNGJiNDIzZDc4NWRhYTk0N2M3","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-24T17:10:20Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-02-24T17:10:20Z"},"message":"BOOKKEEPER-172: Upgrade framework for filesystem layouts (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1293342 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b8ed3e41a6d2189eda49f9b2edf7baf0d14c4c57","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b8ed3e41a6d2189eda49f9b2edf7baf0d14c4c57"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/110d36673bcc393853aaab4bb423d785daa947c7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/110d36673bcc393853aaab4bb423d785daa947c7","html_url":"https://github.com/apache/bookkeeper/commit/110d36673bcc393853aaab4bb423d785daa947c7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/110d36673bcc393853aaab4bb423d785daa947c7/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"014bcd501c14141facd0e3eb4bb488ccba3a2b7d","url":"https://api.github.com/repos/apache/bookkeeper/commits/014bcd501c14141facd0e3eb4bb488ccba3a2b7d","html_url":"https://github.com/apache/bookkeeper/commit/014bcd501c14141facd0e3eb4bb488ccba3a2b7d"}]},{"sha":"9523193456992a2edd36106120a8a9f246af6995","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5NTIzMTkzNDU2OTkyYTJlZGQzNjEwNjEyMGE4YTlmMjQ2YWY2OTk1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:08:01Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:08:01Z"},"message":"BOOKKEEPER-177: Index file is lost or some index pages aren't flushed. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1293369 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6a3d9916efc8f4d5f346df97493d096f206ac2c9","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6a3d9916efc8f4d5f346df97493d096f206ac2c9"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9523193456992a2edd36106120a8a9f246af6995","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9523193456992a2edd36106120a8a9f246af6995","html_url":"https://github.com/apache/bookkeeper/commit/9523193456992a2edd36106120a8a9f246af6995","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9523193456992a2edd36106120a8a9f246af6995/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"110d36673bcc393853aaab4bb423d785daa947c7","url":"https://api.github.com/repos/apache/bookkeeper/commits/110d36673bcc393853aaab4bb423d785daa947c7","html_url":"https://github.com/apache/bookkeeper/commit/110d36673bcc393853aaab4bb423d785daa947c7"}]},{"sha":"2ec70d4dbf2266b17bdb99975f974f30afa65593","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyZWM3MGQ0ZGJmMjI2NmIxN2JkYjk5OTc1Zjk3NGYzMGFmYTY1NTkz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:20:56Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T18:20:56Z"},"message":"BOOKKEEPER-178: Delay ledger directory creation until the ledger index file was created (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1293372 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a81b267dbd3d863b7185e09c3c7f7845b51643e7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a81b267dbd3d863b7185e09c3c7f7845b51643e7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/2ec70d4dbf2266b17bdb99975f974f30afa65593","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/2ec70d4dbf2266b17bdb99975f974f30afa65593","html_url":"https://github.com/apache/bookkeeper/commit/2ec70d4dbf2266b17bdb99975f974f30afa65593","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/2ec70d4dbf2266b17bdb99975f974f30afa65593/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9523193456992a2edd36106120a8a9f246af6995","url":"https://api.github.com/repos/apache/bookkeeper/commits/9523193456992a2edd36106120a8a9f246af6995","html_url":"https://github.com/apache/bookkeeper/commit/9523193456992a2edd36106120a8a9f246af6995"}]},{"sha":"9366322bfe3461a44a8b0444e66cd774ea1ac7d8","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5MzY2MzIyYmZlMzQ2MWE0NGE4YjA0NDRlNjZjZDc3NGVhMWFjN2Q4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T19:07:57Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-02-24T19:07:57Z"},"message":"BOOKKEEPER-113: NPE In BookKeeper test (fpj via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1293383 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9e4303493549ba49fb724c494bc7f24064ef79be","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9e4303493549ba49fb724c494bc7f24064ef79be"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9366322bfe3461a44a8b0444e66cd774ea1ac7d8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9366322bfe3461a44a8b0444e66cd774ea1ac7d8","html_url":"https://github.com/apache/bookkeeper/commit/9366322bfe3461a44a8b0444e66cd774ea1ac7d8","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9366322bfe3461a44a8b0444e66cd774ea1ac7d8/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"2ec70d4dbf2266b17bdb99975f974f30afa65593","url":"https://api.github.com/repos/apache/bookkeeper/commits/2ec70d4dbf2266b17bdb99975f974f30afa65593","html_url":"https://github.com/apache/bookkeeper/commit/2ec70d4dbf2266b17bdb99975f974f30afa65593"}]},{"sha":"76818a6aadd4aa40a45aca6f5b0acba79cd42515","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3NjgxOGE2YWFkZDRhYTQwYTQ1YWNhNmY1YjBhY2JhNzljZDQyNTE1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-01T14:10:17Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-01T14:10:17Z"},"message":"BOOKKEEPER-74: Bookkeeper Persistence Manager should give up topic on error (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1295571 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"befb9ed4b93345341687e710085437d357f1dfdf","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/befb9ed4b93345341687e710085437d357f1dfdf"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/76818a6aadd4aa40a45aca6f5b0acba79cd42515","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/76818a6aadd4aa40a45aca6f5b0acba79cd42515","html_url":"https://github.com/apache/bookkeeper/commit/76818a6aadd4aa40a45aca6f5b0acba79cd42515","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/76818a6aadd4aa40a45aca6f5b0acba79cd42515/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9366322bfe3461a44a8b0444e66cd774ea1ac7d8","url":"https://api.github.com/repos/apache/bookkeeper/commits/9366322bfe3461a44a8b0444e66cd774ea1ac7d8","html_url":"https://github.com/apache/bookkeeper/commit/9366322bfe3461a44a8b0444e66cd774ea1ac7d8"}]},{"sha":"431554da9e2598c73edfbaf671e87cfd9ae94716","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0MzE1NTRkYTllMjU5OGM3M2VkZmJhZjY3MWU4N2NmZDlhZTk0NzE2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-01T14:58:08Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-01T14:58:08Z"},"message":"BOOKKEEPER-176: HierarchicalBookieFailureTest Hung (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1295604 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a7e3bf2aa8733b885973034e23c849ea5c0c886e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a7e3bf2aa8733b885973034e23c849ea5c0c886e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/431554da9e2598c73edfbaf671e87cfd9ae94716","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/431554da9e2598c73edfbaf671e87cfd9ae94716","html_url":"https://github.com/apache/bookkeeper/commit/431554da9e2598c73edfbaf671e87cfd9ae94716","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/431554da9e2598c73edfbaf671e87cfd9ae94716/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"76818a6aadd4aa40a45aca6f5b0acba79cd42515","url":"https://api.github.com/repos/apache/bookkeeper/commits/76818a6aadd4aa40a45aca6f5b0acba79cd42515","html_url":"https://github.com/apache/bookkeeper/commit/76818a6aadd4aa40a45aca6f5b0acba79cd42515"}]},{"sha":"e911559291b6ae9aa310a695fb4174796921ac81","node_id":"MDY6Q29tbWl0MTU3NTk1NjplOTExNTU5MjkxYjZhZTlhYTMxMGE2OTVmYjQxNzQ3OTY5MjFhYzgx","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-08T11:13:23Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-08T11:13:23Z"},"message":"BOOKKEEPER-160: bookie server needs to do compaction over entry log files to reclaim disk space (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1298357 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0c4e8295bf23fed6a611de9656735774832176a4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0c4e8295bf23fed6a611de9656735774832176a4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e911559291b6ae9aa310a695fb4174796921ac81","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e911559291b6ae9aa310a695fb4174796921ac81","html_url":"https://github.com/apache/bookkeeper/commit/e911559291b6ae9aa310a695fb4174796921ac81","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e911559291b6ae9aa310a695fb4174796921ac81/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"431554da9e2598c73edfbaf671e87cfd9ae94716","url":"https://api.github.com/repos/apache/bookkeeper/commits/431554da9e2598c73edfbaf671e87cfd9ae94716","html_url":"https://github.com/apache/bookkeeper/commit/431554da9e2598c73edfbaf671e87cfd9ae94716"}]},{"sha":"cb8296636b961253f9586f535db285bfafa54a8a","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjYjgyOTY2MzZiOTYxMjUzZjk1ODZmNTM1ZGIyODViZmFmYTU0YThh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-08T18:24:51Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-08T18:24:51Z"},"message":"BOOKKEEPER-180: bookie server doesn't quit when running out of disk space (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1298492 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b0aeeaa054afbb1064b1395386d79464f9884487","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b0aeeaa054afbb1064b1395386d79464f9884487"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cb8296636b961253f9586f535db285bfafa54a8a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8296636b961253f9586f535db285bfafa54a8a","html_url":"https://github.com/apache/bookkeeper/commit/cb8296636b961253f9586f535db285bfafa54a8a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8296636b961253f9586f535db285bfafa54a8a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e911559291b6ae9aa310a695fb4174796921ac81","url":"https://api.github.com/repos/apache/bookkeeper/commits/e911559291b6ae9aa310a695fb4174796921ac81","html_url":"https://github.com/apache/bookkeeper/commit/e911559291b6ae9aa310a695fb4174796921ac81"}]},{"sha":"028a6d5360637417141f7f819a404e8e71117f9b","node_id":"MDY6Q29tbWl0MTU3NTk1NjowMjhhNmQ1MzYwNjM3NDE3MTQxZjdmODE5YTQwNGU4ZTcxMTE3Zjli","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-09T13:48:20Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-03-09T13:48:20Z"},"message":"BOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1298825 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7071337c81eb3d1f33583a21a873a07b021108c1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7071337c81eb3d1f33583a21a873a07b021108c1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/028a6d5360637417141f7f819a404e8e71117f9b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/028a6d5360637417141f7f819a404e8e71117f9b","html_url":"https://github.com/apache/bookkeeper/commit/028a6d5360637417141f7f819a404e8e71117f9b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/028a6d5360637417141f7f819a404e8e71117f9b/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"cb8296636b961253f9586f535db285bfafa54a8a","url":"https://api.github.com/repos/apache/bookkeeper/commits/cb8296636b961253f9586f535db285bfafa54a8a","html_url":"https://github.com/apache/bookkeeper/commit/cb8296636b961253f9586f535db285bfafa54a8a"}]},{"sha":"8207445ea25bef37e3369e749913acc0d597d9b2","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4MjA3NDQ1ZWEyNWJlZjM3ZTMzNjllNzQ5OTEzYWNjMGQ1OTdkOWIy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-09T14:27:40Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-09T14:27:40Z"},"message":"Set benchmark script to executable (BOOKKEEPER-158)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1298847 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9a56b4c22cd70220407236ec50e6f1854eb5d996","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9a56b4c22cd70220407236ec50e6f1854eb5d996"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8207445ea25bef37e3369e749913acc0d597d9b2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8207445ea25bef37e3369e749913acc0d597d9b2","html_url":"https://github.com/apache/bookkeeper/commit/8207445ea25bef37e3369e749913acc0d597d9b2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8207445ea25bef37e3369e749913acc0d597d9b2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"028a6d5360637417141f7f819a404e8e71117f9b","url":"https://api.github.com/repos/apache/bookkeeper/commits/028a6d5360637417141f7f819a404e8e71117f9b","html_url":"https://github.com/apache/bookkeeper/commit/028a6d5360637417141f7f819a404e8e71117f9b"}]},{"sha":"c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjNmNjN2NjYTNhODU2MDNjOGU5MzViYTZkMDZmYmYzZDhkN2E3ZWI1","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-13T06:31:36Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-13T06:31:36Z"},"message":"BOOKKEEPER-163: Prevent incorrect NoSuchLedgerException for readLastConfirmed. (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1299984 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6dbc0c9a54c4e1dcf680f6457f1ad5982339748b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6dbc0c9a54c4e1dcf680f6457f1ad5982339748b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","html_url":"https://github.com/apache/bookkeeper/commit/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"8207445ea25bef37e3369e749913acc0d597d9b2","url":"https://api.github.com/repos/apache/bookkeeper/commits/8207445ea25bef37e3369e749913acc0d597d9b2","html_url":"https://github.com/apache/bookkeeper/commit/8207445ea25bef37e3369e749913acc0d597d9b2"}]},{"sha":"fd5bb2bce8585ef49ba01d853241a4ee36d487e2","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmZDViYjJiY2U4NTg1ZWY0OWJhMDFkODUzMjQxYTRlZTM2ZDQ4N2Uy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T11:29:03Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T11:29:03Z"},"message":"BOOKKEEPER-168: Message bounding on subscriptions (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1300510 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"26d5da074ab3cd7150b1f5305a21c214b1167e36","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/26d5da074ab3cd7150b1f5305a21c214b1167e36"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","html_url":"https://github.com/apache/bookkeeper/commit/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","url":"https://api.github.com/repos/apache/bookkeeper/commits/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5","html_url":"https://github.com/apache/bookkeeper/commit/c6cc7cca3a85603c8e935ba6d06fbf3d8d7a7eb5"}]},{"sha":"e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","node_id":"MDY6Q29tbWl0MTU3NTk1NjplOGExZGVjM2ZiZWE5YjJmOGM1OWMzMmUyZjE4OWQ2MGMxODY0Njg4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T16:11:54Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-14T16:11:54Z"},"message":"BOOKKEEPER-185: Remove bookkeeper-server dependency on hadoop-common (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1300616 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c38647e41c831501b27f6cc7e93e44b2340bc569","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c38647e41c831501b27f6cc7e93e44b2340bc569"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","html_url":"https://github.com/apache/bookkeeper/commit/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"fd5bb2bce8585ef49ba01d853241a4ee36d487e2","url":"https://api.github.com/repos/apache/bookkeeper/commits/fd5bb2bce8585ef49ba01d853241a4ee36d487e2","html_url":"https://github.com/apache/bookkeeper/commit/fd5bb2bce8585ef49ba01d853241a4ee36d487e2"}]},{"sha":"a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","node_id":"MDY6Q29tbWl0MTU3NTk1NjphNGJkZWQ5ODVjYTEzNDZhMTdlZTBkY2YwOGZlOWRjZDU3MGRjZmI3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-15T09:37:43Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-15T09:37:43Z"},"message":"BOOKKEEPER-184: CompactionTest failing on Jenkins (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1300862 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ab0b317c5b73203ce7da15ff1a269bac84b30afe","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ab0b317c5b73203ce7da15ff1a269bac84b30afe"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","html_url":"https://github.com/apache/bookkeeper/commit/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","url":"https://api.github.com/repos/apache/bookkeeper/commits/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688","html_url":"https://github.com/apache/bookkeeper/commit/e8a1dec3fbea9b2f8c59c32e2f189d60c1864688"}]},{"sha":"33bef6356dfcf14928314e14c20ae73de80bdf99","node_id":"MDY6Q29tbWl0MTU3NTk1NjozM2JlZjYzNTZkZmNmMTQ5MjgzMTRlMTRjMjBhZTczZGU4MGJkZjk5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-16T09:41:45Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-16T09:41:45Z"},"message":"BOOKKEEPER-182: Entry log file is overwritten when fail to read lastLogId. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1301395 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c7ac5f039aedf3c7f5a6f0a1af36d7df3202139e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c7ac5f039aedf3c7f5a6f0a1af36d7df3202139e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/33bef6356dfcf14928314e14c20ae73de80bdf99","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/33bef6356dfcf14928314e14c20ae73de80bdf99","html_url":"https://github.com/apache/bookkeeper/commit/33bef6356dfcf14928314e14c20ae73de80bdf99","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/33bef6356dfcf14928314e14c20ae73de80bdf99/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","url":"https://api.github.com/repos/apache/bookkeeper/commits/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7","html_url":"https://github.com/apache/bookkeeper/commit/a4bded985ca1346a17ee0dcf08fe9dcd570dcfb7"}]},{"sha":"0663029788d504f38e98fd79e625a466bb4780c9","node_id":"MDY6Q29tbWl0MTU3NTk1NjowNjYzMDI5Nzg4ZDUwNGYzOGU5OGZkNzllNjI1YTQ2NmJiNDc4MGM5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-19T12:04:51Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-19T12:04:51Z"},"message":"BOOKKEEPER-96: extends zookeeper JMX to monitor and manage hedwig server (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302392 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f5c0a55c2ee08ed777fb66973ed902cb11f3aedb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f5c0a55c2ee08ed777fb66973ed902cb11f3aedb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0663029788d504f38e98fd79e625a466bb4780c9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0663029788d504f38e98fd79e625a466bb4780c9","html_url":"https://github.com/apache/bookkeeper/commit/0663029788d504f38e98fd79e625a466bb4780c9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0663029788d504f38e98fd79e625a466bb4780c9/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"33bef6356dfcf14928314e14c20ae73de80bdf99","url":"https://api.github.com/repos/apache/bookkeeper/commits/33bef6356dfcf14928314e14c20ae73de80bdf99","html_url":"https://github.com/apache/bookkeeper/commit/33bef6356dfcf14928314e14c20ae73de80bdf99"}]},{"sha":"3abac4eb86d64286d057d73024a177ef300283b0","node_id":"MDY6Q29tbWl0MTU3NTk1NjozYWJhYzRlYjg2ZDY0Mjg2ZDA1N2Q3MzAyNGExNzdlZjMwMDI4M2Iw","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-19T14:02:15Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-19T14:02:15Z"},"message":"BOOKKEEPER-186: Bookkeeper throttling - permits is not released when read has failed from all replicas (Rakesh R via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302458 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ceed841fad9a8f97800d8db9ebe87d32ef27e9d2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ceed841fad9a8f97800d8db9ebe87d32ef27e9d2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3abac4eb86d64286d057d73024a177ef300283b0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3abac4eb86d64286d057d73024a177ef300283b0","html_url":"https://github.com/apache/bookkeeper/commit/3abac4eb86d64286d057d73024a177ef300283b0","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3abac4eb86d64286d057d73024a177ef300283b0/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"0663029788d504f38e98fd79e625a466bb4780c9","url":"https://api.github.com/repos/apache/bookkeeper/commits/0663029788d504f38e98fd79e625a466bb4780c9","html_url":"https://github.com/apache/bookkeeper/commit/0663029788d504f38e98fd79e625a466bb4780c9"}]},{"sha":"841e7dc187b17e6cf4c437fc211f9e285191dd7c","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4NDFlN2RjMTg3YjE3ZTZjZjRjNDM3ZmMyMTFmOWUyODUxOTFkZDdj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T11:51:03Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T11:51:03Z"},"message":"BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302851 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"956bd659fab11190e5b04fe258b5bb5ff05f6154","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/956bd659fab11190e5b04fe258b5bb5ff05f6154"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","html_url":"https://github.com/apache/bookkeeper/commit/841e7dc187b17e6cf4c437fc211f9e285191dd7c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3abac4eb86d64286d057d73024a177ef300283b0","url":"https://api.github.com/repos/apache/bookkeeper/commits/3abac4eb86d64286d057d73024a177ef300283b0","html_url":"https://github.com/apache/bookkeeper/commit/3abac4eb86d64286d057d73024a177ef300283b0"}]},{"sha":"7199719beebe79325a93ef57a1140c2ed50c26e9","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3MTk5NzE5YmVlYmU3OTMyNWE5M2VmNTdhMTE0MGMyZWQ1MGMyNmU5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T13:09:07Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-20T13:09:07Z"},"message":"BOOKKEEPER-175: Bookie code is very coupled (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1302870 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"40f6b80b9f4f9d7dfe5a6f4063ae733c1394b94e","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/40f6b80b9f4f9d7dfe5a6f4063ae733c1394b94e"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7199719beebe79325a93ef57a1140c2ed50c26e9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7199719beebe79325a93ef57a1140c2ed50c26e9","html_url":"https://github.com/apache/bookkeeper/commit/7199719beebe79325a93ef57a1140c2ed50c26e9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7199719beebe79325a93ef57a1140c2ed50c26e9/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"841e7dc187b17e6cf4c437fc211f9e285191dd7c","url":"https://api.github.com/repos/apache/bookkeeper/commits/841e7dc187b17e6cf4c437fc211f9e285191dd7c","html_url":"https://github.com/apache/bookkeeper/commit/841e7dc187b17e6cf4c437fc211f9e285191dd7c"}]},{"sha":"f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmM2E0MDRlNGU2YjBkMGMyYTBiMmE4M2QzOGNkZWRhZmYwNjgzZTY4","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-21T05:13:23Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-21T05:13:23Z"},"message":"BOOKKEEPER-188: Garbage collection code is in the wrong place (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1303286 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ab99eddca713678fbef4e75b5457d1f16f131193","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ab99eddca713678fbef4e75b5457d1f16f131193"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","html_url":"https://github.com/apache/bookkeeper/commit/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"7199719beebe79325a93ef57a1140c2ed50c26e9","url":"https://api.github.com/repos/apache/bookkeeper/commits/7199719beebe79325a93ef57a1140c2ed50c26e9","html_url":"https://github.com/apache/bookkeeper/commit/7199719beebe79325a93ef57a1140c2ed50c26e9"}]},{"sha":"3d32544c0b2b1cd5b184531846a451f518486c7d","node_id":"MDY6Q29tbWl0MTU3NTk1NjozZDMyNTQ0YzBiMmIxY2Q1YjE4NDUzMTg0NmE0NTFmNTE4NDg2Yzdk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-21T05:40:55Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-21T05:40:55Z"},"message":"BOOKKEEPER-189: AbstractZkLedgerManager doesn't disregard cookies (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1303291 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"244e8aa0249846045e000b3c768f1a2631b3c0d8","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/244e8aa0249846045e000b3c768f1a2631b3c0d8"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3d32544c0b2b1cd5b184531846a451f518486c7d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3d32544c0b2b1cd5b184531846a451f518486c7d","html_url":"https://github.com/apache/bookkeeper/commit/3d32544c0b2b1cd5b184531846a451f518486c7d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3d32544c0b2b1cd5b184531846a451f518486c7d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","url":"https://api.github.com/repos/apache/bookkeeper/commits/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68","html_url":"https://github.com/apache/bookkeeper/commit/f3a404e4e6b0d0c2a0b2a83d38cdedaff0683e68"}]},{"sha":"6d56d60831a63fe9520ce156686d0cb1142e44f5","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ZDU2ZDYwODMxYTYzZmU5NTIwY2UxNTY2ODZkMGNiMTE0MmU0NGY1","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-28T21:57:40Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-28T21:57:40Z"},"message":"BOOKKEEPER-195: HierarchicalLedgerManager doesn't consider idgen as a \"specialNode\" (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1306616 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1976ec691bc2e664c1d96051cf1eebbce379e386","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1976ec691bc2e664c1d96051cf1eebbce379e386"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6d56d60831a63fe9520ce156686d0cb1142e44f5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6d56d60831a63fe9520ce156686d0cb1142e44f5","html_url":"https://github.com/apache/bookkeeper/commit/6d56d60831a63fe9520ce156686d0cb1142e44f5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6d56d60831a63fe9520ce156686d0cb1142e44f5/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3d32544c0b2b1cd5b184531846a451f518486c7d","url":"https://api.github.com/repos/apache/bookkeeper/commits/3d32544c0b2b1cd5b184531846a451f518486c7d","html_url":"https://github.com/apache/bookkeeper/commit/3d32544c0b2b1cd5b184531846a451f518486c7d"}]},{"sha":"c805430253c6e6bb4341ad51b406ceabeafcd4e8","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjODA1NDMwMjUzYzZlNmJiNDM0MWFkNTFiNDA2Y2VhYmVhZmNkNGU4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T12:07:13Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T12:07:13Z"},"message":"BOOKKEEPER-97: collect pub/sub/consume statistics on hub server (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1306798 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"691c1298cc367b504c03099f2d38fe45d21d820b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/691c1298cc367b504c03099f2d38fe45d21d820b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c805430253c6e6bb4341ad51b406ceabeafcd4e8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c805430253c6e6bb4341ad51b406ceabeafcd4e8","html_url":"https://github.com/apache/bookkeeper/commit/c805430253c6e6bb4341ad51b406ceabeafcd4e8","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c805430253c6e6bb4341ad51b406ceabeafcd4e8/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"6d56d60831a63fe9520ce156686d0cb1142e44f5","url":"https://api.github.com/repos/apache/bookkeeper/commits/6d56d60831a63fe9520ce156686d0cb1142e44f5","html_url":"https://github.com/apache/bookkeeper/commit/6d56d60831a63fe9520ce156686d0cb1142e44f5"}]},{"sha":"48304c7c07513a15d26cb61f311c9f4b998fd8fc","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0ODMwNGM3YzA3NTEzYTE1ZDI2Y2I2MWYzMTFjOWY0Yjk5OGZkOGZj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T13:18:34Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T13:18:34Z"},"message":"BOOKKEEPER-190: Add entries would fail when number of open ledgers reaches more than openFileLimit. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1306839 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ac46a913712c60854893555ebeb094aac827e95d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ac46a913712c60854893555ebeb094aac827e95d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/48304c7c07513a15d26cb61f311c9f4b998fd8fc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/48304c7c07513a15d26cb61f311c9f4b998fd8fc","html_url":"https://github.com/apache/bookkeeper/commit/48304c7c07513a15d26cb61f311c9f4b998fd8fc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/48304c7c07513a15d26cb61f311c9f4b998fd8fc/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c805430253c6e6bb4341ad51b406ceabeafcd4e8","url":"https://api.github.com/repos/apache/bookkeeper/commits/c805430253c6e6bb4341ad51b406ceabeafcd4e8","html_url":"https://github.com/apache/bookkeeper/commit/c805430253c6e6bb4341ad51b406ceabeafcd4e8"}]},{"sha":"83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4M2U4NjcyYTEwZmFiMDUwYTViYmNjMWJlZWI5YTIxMGMxYjJiOTBi","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T13:41:21Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-29T13:41:21Z"},"message":"BOOKKEEPER-194: Get correct latency for addEntry operations for JMX. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1306857 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7ba9d90997ffd331f8bf38471370cfd2cc907ae6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7ba9d90997ffd331f8bf38471370cfd2cc907ae6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","html_url":"https://github.com/apache/bookkeeper/commit/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"48304c7c07513a15d26cb61f311c9f4b998fd8fc","url":"https://api.github.com/repos/apache/bookkeeper/commits/48304c7c07513a15d26cb61f311c9f4b998fd8fc","html_url":"https://github.com/apache/bookkeeper/commit/48304c7c07513a15d26cb61f311c9f4b998fd8fc"}]},{"sha":"4b32e049dca4a1a8eea4bfb2325aee2de629b132","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0YjMyZTA0OWRjYTRhMWE4ZWVhNGJmYjIzMjVhZWUyZGU2MjliMTMy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-30T11:00:20Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-03-30T11:00:20Z"},"message":"BOOKKEEPER-166: Bookie will not recover its journal if the length prefix of an entry is truncated (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307353 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b5c3c204070989819d9c9e5ae0cc5c15879c5f38","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b5c3c204070989819d9c9e5ae0cc5c15879c5f38"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4b32e049dca4a1a8eea4bfb2325aee2de629b132","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4b32e049dca4a1a8eea4bfb2325aee2de629b132","html_url":"https://github.com/apache/bookkeeper/commit/4b32e049dca4a1a8eea4bfb2325aee2de629b132","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4b32e049dca4a1a8eea4bfb2325aee2de629b132/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","url":"https://api.github.com/repos/apache/bookkeeper/commits/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b","html_url":"https://github.com/apache/bookkeeper/commit/83e8672a10fab050a5bbcc1beeb9a210c1b2b90b"}]},{"sha":"30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","node_id":"MDY6Q29tbWl0MTU3NTk1NjozMGM2OGIwYmViZmYxZTBhMDEyZGQ4MWU4ZjA1ZWJiZjgzYjRmZjVm","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:13:07Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:13:07Z"},"message":"BOOKKEEPER-193: Ledger is garbage collected by mistake. (sijie, ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307725 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c05919c31a2d605ed4643776e4491811c4661705","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c05919c31a2d605ed4643776e4491811c4661705"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","html_url":"https://github.com/apache/bookkeeper/commit/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b32e049dca4a1a8eea4bfb2325aee2de629b132","url":"https://api.github.com/repos/apache/bookkeeper/commits/4b32e049dca4a1a8eea4bfb2325aee2de629b132","html_url":"https://github.com/apache/bookkeeper/commit/4b32e049dca4a1a8eea4bfb2325aee2de629b132"}]},{"sha":"235bc1fec4d60567d113202b44f6fb4c1616d1ce","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyMzViYzFmZWM0ZDYwNTY3ZDExMzIwMmI0NGY2ZmI0YzE2MTZkMWNl","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:31:54Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T07:31:54Z"},"message":"BOOKKEEPER-198: replaying entries of deleted ledgers would exhaust ledger cache. (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307732 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"eff98c8549f9a2db3397f72b40e32b45c8955369","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/eff98c8549f9a2db3397f72b40e32b45c8955369"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/235bc1fec4d60567d113202b44f6fb4c1616d1ce","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/235bc1fec4d60567d113202b44f6fb4c1616d1ce","html_url":"https://github.com/apache/bookkeeper/commit/235bc1fec4d60567d113202b44f6fb4c1616d1ce","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/235bc1fec4d60567d113202b44f6fb4c1616d1ce/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","url":"https://api.github.com/repos/apache/bookkeeper/commits/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f","html_url":"https://github.com/apache/bookkeeper/commit/30c68b0bebff1e0a012dd81e8f05ebbf83b4ff5f"}]},{"sha":"682a23fb23c8de7756d5ef226fd6e97dd8d4e561","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ODJhMjNmYjIzYzhkZTc3NTZkNWVmMjI2ZmQ2ZTk3ZGQ4ZDRlNTYx","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T08:58:51Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-03-31T08:58:51Z"},"message":"BOOKKEEPER-112: Bookie Recovery on an open ledger will cause LedgerHandle#close on that ledger to fail (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1307743 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ba890e7a88896051ca2206d43c03c8103f6b9760","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ba890e7a88896051ca2206d43c03c8103f6b9760"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","html_url":"https://github.com/apache/bookkeeper/commit/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"235bc1fec4d60567d113202b44f6fb4c1616d1ce","url":"https://api.github.com/repos/apache/bookkeeper/commits/235bc1fec4d60567d113202b44f6fb4c1616d1ce","html_url":"https://github.com/apache/bookkeeper/commit/235bc1fec4d60567d113202b44f6fb4c1616d1ce"}]},{"sha":"47244dd77fb291ec95d5da4c96751ea92bc2d516","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0NzI0NGRkNzdmYjI5MWVjOTVkNWRhNGM5Njc1MWVhOTJiYzJkNTE2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-02T10:38:18Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-02T10:38:18Z"},"message":"BOOKKEEPER-135: Fencing does not check the ledger masterPasswd (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1308294 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"04dcf6e583b23dc7db7dae0a998389027fa4cdfb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/04dcf6e583b23dc7db7dae0a998389027fa4cdfb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/47244dd77fb291ec95d5da4c96751ea92bc2d516","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/47244dd77fb291ec95d5da4c96751ea92bc2d516","html_url":"https://github.com/apache/bookkeeper/commit/47244dd77fb291ec95d5da4c96751ea92bc2d516","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/47244dd77fb291ec95d5da4c96751ea92bc2d516/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"682a23fb23c8de7756d5ef226fd6e97dd8d4e561","url":"https://api.github.com/repos/apache/bookkeeper/commits/682a23fb23c8de7756d5ef226fd6e97dd8d4e561","html_url":"https://github.com/apache/bookkeeper/commit/682a23fb23c8de7756d5ef226fd6e97dd8d4e561"}]},{"sha":"f694716e289c448ab89cab5fa81ea0946f9d9193","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmNjk0NzE2ZTI4OWM0NDhhYjg5Y2FiNWZhODFlYTA5NDZmOWQ5MTkz","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-03T16:02:44Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-03T16:02:44Z"},"message":"BOOKKEEPER-207: BenchBookie doesn't run correctly (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1309007 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5f5f468380a64c8c6d99037c43d84ae28088fd0b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/5f5f468380a64c8c6d99037c43d84ae28088fd0b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f694716e289c448ab89cab5fa81ea0946f9d9193","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f694716e289c448ab89cab5fa81ea0946f9d9193","html_url":"https://github.com/apache/bookkeeper/commit/f694716e289c448ab89cab5fa81ea0946f9d9193","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f694716e289c448ab89cab5fa81ea0946f9d9193/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"47244dd77fb291ec95d5da4c96751ea92bc2d516","url":"https://api.github.com/repos/apache/bookkeeper/commits/47244dd77fb291ec95d5da4c96751ea92bc2d516","html_url":"https://github.com/apache/bookkeeper/commit/47244dd77fb291ec95d5da4c96751ea92bc2d516"}]},{"sha":"8f02fb64ec9612af8422f23ed7908d7f6ccf5332","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4ZjAyZmI2NGVjOTYxMmFmODQyMmYyM2VkNzkwOGQ3ZjZjY2Y1MzMy","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-09T09:42:01Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-09T09:42:01Z"},"message":"BOOKKEEPER-212: Bookie stops responding when creating and deleting many ledgers (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1311177 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d5d335a9b91f41e63d23c394e93a4da28cafda83","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d5d335a9b91f41e63d23c394e93a4da28cafda83"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8f02fb64ec9612af8422f23ed7908d7f6ccf5332","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8f02fb64ec9612af8422f23ed7908d7f6ccf5332","html_url":"https://github.com/apache/bookkeeper/commit/8f02fb64ec9612af8422f23ed7908d7f6ccf5332","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8f02fb64ec9612af8422f23ed7908d7f6ccf5332/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"f694716e289c448ab89cab5fa81ea0946f9d9193","url":"https://api.github.com/repos/apache/bookkeeper/commits/f694716e289c448ab89cab5fa81ea0946f9d9193","html_url":"https://github.com/apache/bookkeeper/commit/f694716e289c448ab89cab5fa81ea0946f9d9193"}]},{"sha":"df5789843b6624ebda9c6e839458cdfbc3ed7d84","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkZjU3ODk4NDNiNjYyNGViZGE5YzZlODM5NDU4Y2RmYmMzZWQ3ZDg0","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-10T03:21:55Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-10T03:21:55Z"},"message":"BOOKKEEPER-211: Bookie fails to to start (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1311564 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"78ef3d97664d619221735f7773ac6109a62edbdb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/78ef3d97664d619221735f7773ac6109a62edbdb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/df5789843b6624ebda9c6e839458cdfbc3ed7d84","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/df5789843b6624ebda9c6e839458cdfbc3ed7d84","html_url":"https://github.com/apache/bookkeeper/commit/df5789843b6624ebda9c6e839458cdfbc3ed7d84","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/df5789843b6624ebda9c6e839458cdfbc3ed7d84/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"8f02fb64ec9612af8422f23ed7908d7f6ccf5332","url":"https://api.github.com/repos/apache/bookkeeper/commits/8f02fb64ec9612af8422f23ed7908d7f6ccf5332","html_url":"https://github.com/apache/bookkeeper/commit/8f02fb64ec9612af8422f23ed7908d7f6ccf5332"}]},{"sha":"22bb0534ceebb3e9044b727177146fc220683b81","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyMmJiMDUzNGNlZWJiM2U5MDQ0YjcyNzE3NzE0NmZjMjIwNjgzYjgx","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-10T23:05:23Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-10T23:05:23Z"},"message":"BOOKKEEPER-200: Fix format and comments (fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1312034 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b6f537760257b4334cf31306c4ae4a12e9bffacb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b6f537760257b4334cf31306c4ae4a12e9bffacb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/22bb0534ceebb3e9044b727177146fc220683b81","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/22bb0534ceebb3e9044b727177146fc220683b81","html_url":"https://github.com/apache/bookkeeper/commit/22bb0534ceebb3e9044b727177146fc220683b81","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/22bb0534ceebb3e9044b727177146fc220683b81/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"df5789843b6624ebda9c6e839458cdfbc3ed7d84","url":"https://api.github.com/repos/apache/bookkeeper/commits/df5789843b6624ebda9c6e839458cdfbc3ed7d84","html_url":"https://github.com/apache/bookkeeper/commit/df5789843b6624ebda9c6e839458cdfbc3ed7d84"}]},{"sha":"8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4YTFhZDRjMzIwOGFkMGU1YjU0NmFiOGU1NzM4MTMyNjk4ZmE1NmY1","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-16T02:29:19Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-16T02:29:19Z"},"message":"BOOKKEEPER-197: HedwigConsole uses the same file to load bookkeeper client config and hub server config (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1326464 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ae2fbcb9d29d1d74c1db7e3254744d7c977153e2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ae2fbcb9d29d1d74c1db7e3254744d7c977153e2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","html_url":"https://github.com/apache/bookkeeper/commit/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"22bb0534ceebb3e9044b727177146fc220683b81","url":"https://api.github.com/repos/apache/bookkeeper/commits/22bb0534ceebb3e9044b727177146fc220683b81","html_url":"https://github.com/apache/bookkeeper/commit/22bb0534ceebb3e9044b727177146fc220683b81"}]},{"sha":"3d834bd3798f22a43dc434d4b809a5c22731da38","node_id":"MDY6Q29tbWl0MTU3NTk1NjozZDgzNGJkMzc5OGYyMmE0M2RjNDM0ZDRiODA5YTVjMjI3MzFkYTM4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-16T14:11:51Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-16T14:11:51Z"},"message":"BOOKKEEPER-216: Bookie doesn't exit with right exit code (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1326624 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"684a6e75baa1c4231c8bc4cd6fbce32629b59554","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/684a6e75baa1c4231c8bc4cd6fbce32629b59554"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3d834bd3798f22a43dc434d4b809a5c22731da38","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3d834bd3798f22a43dc434d4b809a5c22731da38","html_url":"https://github.com/apache/bookkeeper/commit/3d834bd3798f22a43dc434d4b809a5c22731da38","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3d834bd3798f22a43dc434d4b809a5c22731da38/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","url":"https://api.github.com/repos/apache/bookkeeper/commits/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5","html_url":"https://github.com/apache/bookkeeper/commit/8a1ad4c3208ad0e5b546ab8e5738132698fa56f5"}]},{"sha":"4a94ce1d8184f5f38def015d80777a8113b96690","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0YTk0Y2UxZDgxODRmNWYzOGRlZjAxNWQ4MDc3N2E4MTEzYjk2Njkw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-17T10:18:55Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-17T10:18:55Z"},"message":"BOOKKEEPER-196: Define interface between bookie and ledger storage (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1327027 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b2c6b7d9002a1b3be1b337629abd2f8315e8daa5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/b2c6b7d9002a1b3be1b337629abd2f8315e8daa5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4a94ce1d8184f5f38def015d80777a8113b96690","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4a94ce1d8184f5f38def015d80777a8113b96690","html_url":"https://github.com/apache/bookkeeper/commit/4a94ce1d8184f5f38def015d80777a8113b96690","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4a94ce1d8184f5f38def015d80777a8113b96690/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3d834bd3798f22a43dc434d4b809a5c22731da38","url":"https://api.github.com/repos/apache/bookkeeper/commits/3d834bd3798f22a43dc434d4b809a5c22731da38","html_url":"https://github.com/apache/bookkeeper/commit/3d834bd3798f22a43dc434d4b809a5c22731da38"}]},{"sha":"cf846eb5f57af19f68ccad42edda7551c852041d","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjZjg0NmViNWY1N2FmMTlmNjhjY2FkNDJlZGRhNzU1MWM4NTIwNDFk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-17T11:16:26Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-17T11:16:26Z"},"message":"BOOKKEEPER-218: Provide journal manager to manage journal related operations (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1327045 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"11c27988bbab8bb6fe012065eedbc7dc6e384830","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/11c27988bbab8bb6fe012065eedbc7dc6e384830"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cf846eb5f57af19f68ccad42edda7551c852041d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cf846eb5f57af19f68ccad42edda7551c852041d","html_url":"https://github.com/apache/bookkeeper/commit/cf846eb5f57af19f68ccad42edda7551c852041d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cf846eb5f57af19f68ccad42edda7551c852041d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4a94ce1d8184f5f38def015d80777a8113b96690","url":"https://api.github.com/repos/apache/bookkeeper/commits/4a94ce1d8184f5f38def015d80777a8113b96690","html_url":"https://github.com/apache/bookkeeper/commit/4a94ce1d8184f5f38def015d80777a8113b96690"}]},{"sha":"b5c0791d38a093936016a7989c35363063cdb202","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiNWMwNzkxZDM4YTA5MzkzNjAxNmE3OTg5YzM1MzYzMDYzY2RiMjAy","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-19T01:02:01Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-19T01:02:01Z"},"message":"BOOKKEEPER-213: PerChannelBookieClient calls the wrong errorOut function when encountering an exception (Aniruddha via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1327761 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c52d188879844b0d39468c094ff73afbe3376778","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/c52d188879844b0d39468c094ff73afbe3376778"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b5c0791d38a093936016a7989c35363063cdb202","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b5c0791d38a093936016a7989c35363063cdb202","html_url":"https://github.com/apache/bookkeeper/commit/b5c0791d38a093936016a7989c35363063cdb202","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b5c0791d38a093936016a7989c35363063cdb202/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"cf846eb5f57af19f68ccad42edda7551c852041d","url":"https://api.github.com/repos/apache/bookkeeper/commits/cf846eb5f57af19f68ccad42edda7551c852041d","html_url":"https://github.com/apache/bookkeeper/commit/cf846eb5f57af19f68ccad42edda7551c852041d"}]},{"sha":"57a62a1c3ce151e1354a2a4ed212e9e8965928bf","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1N2E2MmExYzNjZTE1MWUxMzU0YTJhNGVkMjEyZTllODk2NTkyOGJm","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-20T09:19:08Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-20T09:19:08Z"},"message":"BOOKKEEPER-168: Message bounding on subscriptions (ivank) [missing test]\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1328270 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4a8b164b2c669ef41539b7b0d8b8880091ae118a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4a8b164b2c669ef41539b7b0d8b8880091ae118a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/57a62a1c3ce151e1354a2a4ed212e9e8965928bf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/57a62a1c3ce151e1354a2a4ed212e9e8965928bf","html_url":"https://github.com/apache/bookkeeper/commit/57a62a1c3ce151e1354a2a4ed212e9e8965928bf","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/57a62a1c3ce151e1354a2a4ed212e9e8965928bf/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"b5c0791d38a093936016a7989c35363063cdb202","url":"https://api.github.com/repos/apache/bookkeeper/commits/b5c0791d38a093936016a7989c35363063cdb202","html_url":"https://github.com/apache/bookkeeper/commit/b5c0791d38a093936016a7989c35363063cdb202"}]},{"sha":"2f25ef611dd2c8ea2c94b48af09f183d74b6167e","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyZjI1ZWY2MTFkZDJjOGVhMmM5NGI0OGFmMDlmMTgzZDc0YjYxNjdl","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-20T17:18:36Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-04-20T17:18:36Z"},"message":"BOOKKEEPER-173: Uncontrolled number of threads in bookkeeper (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1328452 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"caea203aa7cd47fb5368c63d6d58ae61c6b8dfcf","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/caea203aa7cd47fb5368c63d6d58ae61c6b8dfcf"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/2f25ef611dd2c8ea2c94b48af09f183d74b6167e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/2f25ef611dd2c8ea2c94b48af09f183d74b6167e","html_url":"https://github.com/apache/bookkeeper/commit/2f25ef611dd2c8ea2c94b48af09f183d74b6167e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/2f25ef611dd2c8ea2c94b48af09f183d74b6167e/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"57a62a1c3ce151e1354a2a4ed212e9e8965928bf","url":"https://api.github.com/repos/apache/bookkeeper/commits/57a62a1c3ce151e1354a2a4ed212e9e8965928bf","html_url":"https://github.com/apache/bookkeeper/commit/57a62a1c3ce151e1354a2a4ed212e9e8965928bf"}]},{"sha":"4e9ee8d75582a66f3e11d78dea280afbb864db7e","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0ZTllZThkNzU1ODJhNjZmM2UxMWQ3OGRlYTI4MGFmYmI4NjRkYjdl","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-24T17:37:54Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-24T17:37:54Z"},"message":"BOOKKEEPER-56: Race condition of message handler in connection recovery in Hedwig client (sijie & Gavin Li via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1329883 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1584a6bee7551f0a349e388627ef1cba1d25a174","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1584a6bee7551f0a349e388627ef1cba1d25a174"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/4e9ee8d75582a66f3e11d78dea280afbb864db7e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/4e9ee8d75582a66f3e11d78dea280afbb864db7e","html_url":"https://github.com/apache/bookkeeper/commit/4e9ee8d75582a66f3e11d78dea280afbb864db7e","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/4e9ee8d75582a66f3e11d78dea280afbb864db7e/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"2f25ef611dd2c8ea2c94b48af09f183d74b6167e","url":"https://api.github.com/repos/apache/bookkeeper/commits/2f25ef611dd2c8ea2c94b48af09f183d74b6167e","html_url":"https://github.com/apache/bookkeeper/commit/2f25ef611dd2c8ea2c94b48af09f183d74b6167e"}]},{"sha":"7f9005baadbbf312db857be6c3d3c095fe800c54","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3ZjkwMDViYWFkYmJmMzEyZGI4NTdiZTZjM2QzYzA5NWZlODAwYzU0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-24T17:42:06Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-04-24T17:42:06Z"},"message":"BOOKKEEPER-217: NPE in hedwig client when enable DEBUG (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1329886 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dd50dcac97a5c5b6e9876849e91af2c260a99172","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dd50dcac97a5c5b6e9876849e91af2c260a99172"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7f9005baadbbf312db857be6c3d3c095fe800c54","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7f9005baadbbf312db857be6c3d3c095fe800c54","html_url":"https://github.com/apache/bookkeeper/commit/7f9005baadbbf312db857be6c3d3c095fe800c54","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7f9005baadbbf312db857be6c3d3c095fe800c54/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"4e9ee8d75582a66f3e11d78dea280afbb864db7e","url":"https://api.github.com/repos/apache/bookkeeper/commits/4e9ee8d75582a66f3e11d78dea280afbb864db7e","html_url":"https://github.com/apache/bookkeeper/commit/4e9ee8d75582a66f3e11d78dea280afbb864db7e"}]},{"sha":"f7c1ad57ead301df4d3326b5d8c8950964387fa9","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmN2MxYWQ1N2VhZDMwMWRmNGQzMzI2YjVkOGM4OTUwOTY0Mzg3ZmE5","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-28T08:11:14Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-28T08:11:14Z"},"message":"BOOKKEEPER-56: Race condition of message handler in connection recovery in Hedwig client (added AlreadyStartDeliveryException file missed in r1329883) (sijie & Gavin Li via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1331704 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"78724d36e0aef711e54bc2c6f2956278354ad178","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/78724d36e0aef711e54bc2c6f2956278354ad178"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f7c1ad57ead301df4d3326b5d8c8950964387fa9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f7c1ad57ead301df4d3326b5d8c8950964387fa9","html_url":"https://github.com/apache/bookkeeper/commit/f7c1ad57ead301df4d3326b5d8c8950964387fa9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f7c1ad57ead301df4d3326b5d8c8950964387fa9/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"7f9005baadbbf312db857be6c3d3c095fe800c54","url":"https://api.github.com/repos/apache/bookkeeper/commits/7f9005baadbbf312db857be6c3d3c095fe800c54","html_url":"https://github.com/apache/bookkeeper/commit/7f9005baadbbf312db857be6c3d3c095fe800c54"}]},{"sha":"6d50e72732aa741d3a620c4b3ec04593c68f1b62","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ZDUwZTcyNzMyYWE3NDFkM2E2MjBjNGIzZWMwNDU5M2M2OGYxYjYy","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-28T09:11:28Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-04-28T09:11:28Z"},"message":"BOOKKEEPER-231: ZKUtil.killServer not closing the FileTxnSnapLog from ZK. (Uma Maheswara Rao G via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1331720 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"65996ded8c8f53d927f1e60629192b40d80c6d98","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/65996ded8c8f53d927f1e60629192b40d80c6d98"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6d50e72732aa741d3a620c4b3ec04593c68f1b62","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6d50e72732aa741d3a620c4b3ec04593c68f1b62","html_url":"https://github.com/apache/bookkeeper/commit/6d50e72732aa741d3a620c4b3ec04593c68f1b62","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6d50e72732aa741d3a620c4b3ec04593c68f1b62/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"f7c1ad57ead301df4d3326b5d8c8950964387fa9","url":"https://api.github.com/repos/apache/bookkeeper/commits/f7c1ad57ead301df4d3326b5d8c8950964387fa9","html_url":"https://github.com/apache/bookkeeper/commit/f7c1ad57ead301df4d3326b5d8c8950964387fa9"}]},{"sha":"268bdb8c6b5f642967329a99ec1dce5ba0af46d7","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyNjhiZGI4YzZiNWY2NDI5NjczMjlhOTllYzFkY2U1YmEwYWY0NmQ3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-04T18:11:43Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-04T18:11:43Z"},"message":"BOOKKEEPER-228: Fix the bugs in BK benchmark (umamaheswararao via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1334107 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3c75fe54ee0597f8cfbda31a21de13dd6002eac1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3c75fe54ee0597f8cfbda31a21de13dd6002eac1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/268bdb8c6b5f642967329a99ec1dce5ba0af46d7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/268bdb8c6b5f642967329a99ec1dce5ba0af46d7","html_url":"https://github.com/apache/bookkeeper/commit/268bdb8c6b5f642967329a99ec1dce5ba0af46d7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/268bdb8c6b5f642967329a99ec1dce5ba0af46d7/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"6d50e72732aa741d3a620c4b3ec04593c68f1b62","url":"https://api.github.com/repos/apache/bookkeeper/commits/6d50e72732aa741d3a620c4b3ec04593c68f1b62","html_url":"https://github.com/apache/bookkeeper/commit/6d50e72732aa741d3a620c4b3ec04593c68f1b62"}]},{"sha":"6fc326ebd647afbbcc0beab6764b5d3748e50088","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ZmMzMjZlYmQ2NDdhZmJiY2MwYmVhYjY3NjRiNWQzNzQ4ZTUwMDg4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-07T16:48:07Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-07T16:48:07Z"},"message":"BOOKKEEPER-232: AsyncBK tests failing (umamaheswararao via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335117 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6c2230adc65d2bd2da6b1dbca3b595cbaa8149d5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6c2230adc65d2bd2da6b1dbca3b595cbaa8149d5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6fc326ebd647afbbcc0beab6764b5d3748e50088","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6fc326ebd647afbbcc0beab6764b5d3748e50088","html_url":"https://github.com/apache/bookkeeper/commit/6fc326ebd647afbbcc0beab6764b5d3748e50088","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6fc326ebd647afbbcc0beab6764b5d3748e50088/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"268bdb8c6b5f642967329a99ec1dce5ba0af46d7","url":"https://api.github.com/repos/apache/bookkeeper/commits/268bdb8c6b5f642967329a99ec1dce5ba0af46d7","html_url":"https://github.com/apache/bookkeeper/commit/268bdb8c6b5f642967329a99ec1dce5ba0af46d7"}]},{"sha":"a7d658179db3226dc33d53f4d25afd64ea90c061","node_id":"MDY6Q29tbWl0MTU3NTk1NjphN2Q2NTgxNzlkYjMyMjZkYzMzZDUzZjRkMjVhZmQ2NGVhOTBjMDYx","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-08T07:35:47Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-08T07:35:47Z"},"message":"BOOKKEEPER-229: Deleted entry log files would be garbage collected again and again. (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335367 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e6da36b026d653c255b2eb2ee3f26912aca8e2bd","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/e6da36b026d653c255b2eb2ee3f26912aca8e2bd"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a7d658179db3226dc33d53f4d25afd64ea90c061","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a7d658179db3226dc33d53f4d25afd64ea90c061","html_url":"https://github.com/apache/bookkeeper/commit/a7d658179db3226dc33d53f4d25afd64ea90c061","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a7d658179db3226dc33d53f4d25afd64ea90c061/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"6fc326ebd647afbbcc0beab6764b5d3748e50088","url":"https://api.github.com/repos/apache/bookkeeper/commits/6fc326ebd647afbbcc0beab6764b5d3748e50088","html_url":"https://github.com/apache/bookkeeper/commit/6fc326ebd647afbbcc0beab6764b5d3748e50088"}]},{"sha":"36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","node_id":"MDY6Q29tbWl0MTU3NTk1NjozNmE0YTQxOTBjMzQyZDdiM2ExZDU4NTljNTQ1Y2ExZmMxYjcxM2Nm","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T07:16:05Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T07:16:05Z"},"message":"BOOKKEEPER-241: Add documentation for bookie entry log compaction (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335947 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7ce6c6803cce03086873f7534f5a8ff8cc8f7ad1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/7ce6c6803cce03086873f7534f5a8ff8cc8f7ad1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","html_url":"https://github.com/apache/bookkeeper/commit/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"a7d658179db3226dc33d53f4d25afd64ea90c061","url":"https://api.github.com/repos/apache/bookkeeper/commits/a7d658179db3226dc33d53f4d25afd64ea90c061","html_url":"https://github.com/apache/bookkeeper/commit/a7d658179db3226dc33d53f4d25afd64ea90c061"}]},{"sha":"3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","node_id":"MDY6Q29tbWl0MTU3NTk1NjozZTIyNGM0YjZkNGEwZDkzMTcwNjBmN2ZlMGQzNTE5ZmNjYzY4ZjVh","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T07:43:50Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T07:43:50Z"},"message":"BOOKKEEPER-215: Deadlock occurs under high load (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335958 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"89696a33e81e1d1a58b41949824bd8c5dae6dcf1","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/89696a33e81e1d1a58b41949824bd8c5dae6dcf1"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","html_url":"https://github.com/apache/bookkeeper/commit/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","url":"https://api.github.com/repos/apache/bookkeeper/commits/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf","html_url":"https://github.com/apache/bookkeeper/commit/36a4a4190c342d7b3a1d5859c545ca1fc1b713cf"}]},{"sha":"9efe73998fe1ee72ffae95f3e1b1e65884019710","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5ZWZlNzM5OThmZTFlZTcyZmZhZTk1ZjNlMWIxZTY1ODg0MDE5NzEw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T08:17:34Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T08:17:34Z"},"message":"BOOKKEEPER-242: Bookkeeper not able to connect other zookeeper when shutdown the zookeeper server where the BK has connected. (sijie & rakeshr via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335973 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ecd48e109d24a4881a743ae2b59177755a71b975","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ecd48e109d24a4881a743ae2b59177755a71b975"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9efe73998fe1ee72ffae95f3e1b1e65884019710","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9efe73998fe1ee72ffae95f3e1b1e65884019710","html_url":"https://github.com/apache/bookkeeper/commit/9efe73998fe1ee72ffae95f3e1b1e65884019710","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9efe73998fe1ee72ffae95f3e1b1e65884019710/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","url":"https://api.github.com/repos/apache/bookkeeper/commits/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a","html_url":"https://github.com/apache/bookkeeper/commit/3e224c4b6d4a0d9317060f7fe0d3519fccc68f5a"}]},{"sha":"47ee081e6796ec84c774167dca67c3fd3ceda170","node_id":"MDY6Q29tbWl0MTU3NTk1Njo0N2VlMDgxZTY3OTZlYzg0Yzc3NDE2N2RjYTY3YzNmZDNjZWRhMTcw","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T08:39:33Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-09T08:39:33Z"},"message":"BOOKKEEPER-234: EntryLogger will throw NPE, if any dir does not exist or IO Errors. (umamaheswararao via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1335996 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ead9c1bbbe808ec2d2c722cac79768491d7643e7","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/ead9c1bbbe808ec2d2c722cac79768491d7643e7"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/47ee081e6796ec84c774167dca67c3fd3ceda170","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/47ee081e6796ec84c774167dca67c3fd3ceda170","html_url":"https://github.com/apache/bookkeeper/commit/47ee081e6796ec84c774167dca67c3fd3ceda170","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/47ee081e6796ec84c774167dca67c3fd3ceda170/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"9efe73998fe1ee72ffae95f3e1b1e65884019710","url":"https://api.github.com/repos/apache/bookkeeper/commits/9efe73998fe1ee72ffae95f3e1b1e65884019710","html_url":"https://github.com/apache/bookkeeper/commit/9efe73998fe1ee72ffae95f3e1b1e65884019710"}]},{"sha":"d368d86e287ef982fa70e069001e30124ee22b48","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkMzY4ZDg2ZTI4N2VmOTgyZmE3MGUwNjkwMDFlMzAxMjRlZTIyYjQ4","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:00:38Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:00:38Z"},"message":"BOOKKEEPER-235: Bad syncing in entrylogger degrades performance for many concurrent ledgers (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1336083 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dbb07efb8f9fdb2300eff64152b8e91047d8e604","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dbb07efb8f9fdb2300eff64152b8e91047d8e604"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d368d86e287ef982fa70e069001e30124ee22b48","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d368d86e287ef982fa70e069001e30124ee22b48","html_url":"https://github.com/apache/bookkeeper/commit/d368d86e287ef982fa70e069001e30124ee22b48","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d368d86e287ef982fa70e069001e30124ee22b48/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"47ee081e6796ec84c774167dca67c3fd3ceda170","url":"https://api.github.com/repos/apache/bookkeeper/commits/47ee081e6796ec84c774167dca67c3fd3ceda170","html_url":"https://github.com/apache/bookkeeper/commit/47ee081e6796ec84c774167dca67c3fd3ceda170"}]},{"sha":"5f25edeba1cbf5de489e1f5a3070188f0163b51b","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZjI1ZWRlYmExY2JmNWRlNDg5ZTFmNWEzMDcwMTg4ZjAxNjNiNTFi","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:20:54Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-09T11:20:54Z"},"message":"BOOKKEEPER-236: Benchmarking improvements from latest round of benchmarking (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1336100 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dd4cba52c820af66bb97474cc6439ef985ce9d96","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dd4cba52c820af66bb97474cc6439ef985ce9d96"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b","html_url":"https://github.com/apache/bookkeeper/commit/5f25edeba1cbf5de489e1f5a3070188f0163b51b","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"d368d86e287ef982fa70e069001e30124ee22b48","url":"https://api.github.com/repos/apache/bookkeeper/commits/d368d86e287ef982fa70e069001e30124ee22b48","html_url":"https://github.com/apache/bookkeeper/commit/d368d86e287ef982fa70e069001e30124ee22b48"}]},{"sha":"c32edf860040ebba19c6c57d226b12cd487a00d2","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMzJlZGY4NjAwNDBlYmJhMTljNmM1N2QyMjZiMTJjZDQ4N2EwMGQy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-10T09:57:39Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-10T09:57:39Z"},"message":"BOOKKEEPER-245: Intermittent failures in PersistanceManager tests (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1336569 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"05c43918726da589d5959783faad018331118e72","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/05c43918726da589d5959783faad018331118e72"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c32edf860040ebba19c6c57d226b12cd487a00d2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c32edf860040ebba19c6c57d226b12cd487a00d2","html_url":"https://github.com/apache/bookkeeper/commit/c32edf860040ebba19c6c57d226b12cd487a00d2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c32edf860040ebba19c6c57d226b12cd487a00d2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"5f25edeba1cbf5de489e1f5a3070188f0163b51b","url":"https://api.github.com/repos/apache/bookkeeper/commits/5f25edeba1cbf5de489e1f5a3070188f0163b51b","html_url":"https://github.com/apache/bookkeeper/commit/5f25edeba1cbf5de489e1f5a3070188f0163b51b"}]},{"sha":"3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","node_id":"MDY6Q29tbWl0MTU3NTk1NjozYTJmZGM2ODNlYjdjODg4MWU0Y2U5NjA4YmIxZDdjMzU0OGUyN2Q0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-10T12:47:37Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-10T12:47:37Z"},"message":"BOOKKEEPER-224: Fix findbugs in bookkeeper-server component (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1336645 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"eeabf4c8aa5b953cf70d4d029627d228b253dd3b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/eeabf4c8aa5b953cf70d4d029627d228b253dd3b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","html_url":"https://github.com/apache/bookkeeper/commit/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c32edf860040ebba19c6c57d226b12cd487a00d2","url":"https://api.github.com/repos/apache/bookkeeper/commits/c32edf860040ebba19c6c57d226b12cd487a00d2","html_url":"https://github.com/apache/bookkeeper/commit/c32edf860040ebba19c6c57d226b12cd487a00d2"}]},{"sha":"eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYWY2Y2Y5ODVhZTdjYTRhNGY2MmRhMmRlM2VjYjU2OWNjYzVkM2Y3","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-15T10:04:56Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-15T10:04:56Z"},"message":"BOOKKEEPER-145: Put notice and license file for distributed binaries in SVN (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1338616 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1cb760e39938e1e02fac1c6b76f83adec84b2b5c","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1cb760e39938e1e02fac1c6b76f83adec84b2b5c"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","html_url":"https://github.com/apache/bookkeeper/commit/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","url":"https://api.github.com/repos/apache/bookkeeper/commits/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4","html_url":"https://github.com/apache/bookkeeper/commit/3a2fdc683eb7c8881e4ce9608bb1d7c3548e27d4"}]},{"sha":"ba0ab04216f94411bae27a52670c9c8b4da03476","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiYTBhYjA0MjE2Zjk0NDExYmFlMjdhNTI2NzBjOWM4YjRkYTAzNDc2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-15T10:28:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-15T10:28:38Z"},"message":"BOOKKEEPER-209: Typo in ServerConfiguration for READAHEAD_ENABLED (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1338630 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f31c3e4d88b3acf4a69171a62fc85b3ad4ec59e3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/f31c3e4d88b3acf4a69171a62fc85b3ad4ec59e3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ba0ab04216f94411bae27a52670c9c8b4da03476","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ba0ab04216f94411bae27a52670c9c8b4da03476","html_url":"https://github.com/apache/bookkeeper/commit/ba0ab04216f94411bae27a52670c9c8b4da03476","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ba0ab04216f94411bae27a52670c9c8b4da03476/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","url":"https://api.github.com/repos/apache/bookkeeper/commits/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7","html_url":"https://github.com/apache/bookkeeper/commit/eaf6cf985ae7ca4a4f62da2de3ecb569ccc5d3f7"}]},{"sha":"132849503c0547d4d89d50cd14f700302b391ee2","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxMzI4NDk1MDNjMDU0N2Q0ZDg5ZDUwY2QxNGY3MDAzMDJiMzkxZWUy","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T14:05:02Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T14:05:02Z"},"message":"BOOKKEEPER-224: Fix findbugs in bookkeeper-server component [missing changes] (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1339607 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"aa56185d3a6e4757a9bbacdc2feb109af930035d","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/aa56185d3a6e4757a9bbacdc2feb109af930035d"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/132849503c0547d4d89d50cd14f700302b391ee2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/132849503c0547d4d89d50cd14f700302b391ee2","html_url":"https://github.com/apache/bookkeeper/commit/132849503c0547d4d89d50cd14f700302b391ee2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/132849503c0547d4d89d50cd14f700302b391ee2/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"ba0ab04216f94411bae27a52670c9c8b4da03476","url":"https://api.github.com/repos/apache/bookkeeper/commits/ba0ab04216f94411bae27a52670c9c8b4da03476","html_url":"https://github.com/apache/bookkeeper/commit/ba0ab04216f94411bae27a52670c9c8b4da03476"}]},{"sha":"f05021f1e9e8461182f082b9ab7819b71703655c","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmMDUwMjFmMWU5ZTg0NjExODJmMDgyYjlhYjc4MTliNzE3MDM2NTVj","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T15:56:34Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T15:56:34Z"},"message":"BOOKKEEPER-254: Bump zookeeper version in poms (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1339672 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"913d683504a8bb83f4b727888d9ff74a6250c004","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/913d683504a8bb83f4b727888d9ff74a6250c004"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f05021f1e9e8461182f082b9ab7819b71703655c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f05021f1e9e8461182f082b9ab7819b71703655c","html_url":"https://github.com/apache/bookkeeper/commit/f05021f1e9e8461182f082b9ab7819b71703655c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f05021f1e9e8461182f082b9ab7819b71703655c/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"132849503c0547d4d89d50cd14f700302b391ee2","url":"https://api.github.com/repos/apache/bookkeeper/commits/132849503c0547d4d89d50cd14f700302b391ee2","html_url":"https://github.com/apache/bookkeeper/commit/132849503c0547d4d89d50cd14f700302b391ee2"}]},{"sha":"73dc3481846fdc0c97944c6a7c6ce0cef17ee938","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3M2RjMzQ4MTg0NmZkYzBjOTc5NDRjNmE3YzZjZTBjZWYxN2VlOTM4","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T16:32:05Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T16:32:05Z"},"message":"BOOKKEEPER-72: Fix warnings issued by FindBugs (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1339691 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"83113a499d4258321dc2b9ab24c584d0f80d46f3","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/83113a499d4258321dc2b9ab24c584d0f80d46f3"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/73dc3481846fdc0c97944c6a7c6ce0cef17ee938","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/73dc3481846fdc0c97944c6a7c6ce0cef17ee938","html_url":"https://github.com/apache/bookkeeper/commit/73dc3481846fdc0c97944c6a7c6ce0cef17ee938","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/73dc3481846fdc0c97944c6a7c6ce0cef17ee938/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"f05021f1e9e8461182f082b9ab7819b71703655c","url":"https://api.github.com/repos/apache/bookkeeper/commits/f05021f1e9e8461182f082b9ab7819b71703655c","html_url":"https://github.com/apache/bookkeeper/commit/f05021f1e9e8461182f082b9ab7819b71703655c"}]},{"sha":"1c2141183dd3422c85314b64e7b538c8faacd283","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxYzIxNDExODNkZDM0MjJjODUzMTRiNjRlN2I1MzhjOGZhYWNkMjgz","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T16:38:00Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T16:38:00Z"},"message":"BOOKKEEPER-238: Add log4j.properties in conf/ for bin packages (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1339698 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"981084a43979b5f115ee5c110962faa5ffdbe0c2","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/981084a43979b5f115ee5c110962faa5ffdbe0c2"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1c2141183dd3422c85314b64e7b538c8faacd283","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1c2141183dd3422c85314b64e7b538c8faacd283","html_url":"https://github.com/apache/bookkeeper/commit/1c2141183dd3422c85314b64e7b538c8faacd283","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1c2141183dd3422c85314b64e7b538c8faacd283/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"73dc3481846fdc0c97944c6a7c6ce0cef17ee938","url":"https://api.github.com/repos/apache/bookkeeper/commits/73dc3481846fdc0c97944c6a7c6ce0cef17ee938","html_url":"https://github.com/apache/bookkeeper/commit/73dc3481846fdc0c97944c6a7c6ce0cef17ee938"}]},{"sha":"24e7fb03f6c9e3666aa83cc174b5088926eae3d1","node_id":"MDY6Q29tbWl0MTU3NTk1NjoyNGU3ZmIwM2Y2YzllMzY2NmFhODNjYzE3NGI1MDg4OTI2ZWFlM2Qx","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T17:07:44Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-17T17:07:44Z"},"message":"BOOKKEEPER-251: Noise error message printed when scanning entry log files those have been garbage collected. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1339715 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fbb72bbb4971a095d2faeea1ad81732b3897dd3a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/fbb72bbb4971a095d2faeea1ad81732b3897dd3a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/24e7fb03f6c9e3666aa83cc174b5088926eae3d1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/24e7fb03f6c9e3666aa83cc174b5088926eae3d1","html_url":"https://github.com/apache/bookkeeper/commit/24e7fb03f6c9e3666aa83cc174b5088926eae3d1","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/24e7fb03f6c9e3666aa83cc174b5088926eae3d1/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"1c2141183dd3422c85314b64e7b538c8faacd283","url":"https://api.github.com/repos/apache/bookkeeper/commits/1c2141183dd3422c85314b64e7b538c8faacd283","html_url":"https://github.com/apache/bookkeeper/commit/1c2141183dd3422c85314b64e7b538c8faacd283"}]},{"sha":"67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2N2NiY2RkN2EyZDE2NjhjOWJiYTBkNDVkNmVhMzIzNWU0YmQxMWUz","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-24T05:12:56Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-24T05:12:56Z"},"message":"BOOKKEEPER-263: ZK ledgers root path is hard coded (Aniruddha via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342145 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"95af2580f638dae801d3aa7a936d0ac3f7814942","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/95af2580f638dae801d3aa7a936d0ac3f7814942"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","html_url":"https://github.com/apache/bookkeeper/commit/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"24e7fb03f6c9e3666aa83cc174b5088926eae3d1","url":"https://api.github.com/repos/apache/bookkeeper/commits/24e7fb03f6c9e3666aa83cc174b5088926eae3d1","html_url":"https://github.com/apache/bookkeeper/commit/24e7fb03f6c9e3666aa83cc174b5088926eae3d1"}]},{"sha":"c59b7b8a285e5d4da72aea1232a29f31610c2306","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjNTliN2I4YTI4NWU1ZDRkYTcyYWVhMTIzMmEyOWYzMTYxMGMyMzA2","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-25T09:48:05Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-25T09:48:05Z"},"message":"BOOKKEEPER-146: TestConcurrentTopicAcquisition sometimes hangs (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342550 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dbccb44cea89f28853217fe35482b8a77e37db0b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/dbccb44cea89f28853217fe35482b8a77e37db0b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c59b7b8a285e5d4da72aea1232a29f31610c2306","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c59b7b8a285e5d4da72aea1232a29f31610c2306","html_url":"https://github.com/apache/bookkeeper/commit/c59b7b8a285e5d4da72aea1232a29f31610c2306","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c59b7b8a285e5d4da72aea1232a29f31610c2306/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","url":"https://api.github.com/repos/apache/bookkeeper/commits/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3","html_url":"https://github.com/apache/bookkeeper/commit/67cbcdd7a2d1668c9bba0d45d6ea3235e4bd11e3"}]},{"sha":"7ed489997c11c891f91b9fe0659c803a87d57489","node_id":"MDY6Q29tbWl0MTU3NTk1Njo3ZWQ0ODk5OTdjMTFjODkxZjkxYjlmZTA2NTljODAzYTg3ZDU3NDg5","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-25T13:30:38Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-25T13:30:38Z"},"message":"BOOKKEEPER-266: Review versioning documentation (ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342617 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"451d33021518f846c7751aa863ff10f8c4effd33","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/451d33021518f846c7751aa863ff10f8c4effd33"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/7ed489997c11c891f91b9fe0659c803a87d57489","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/7ed489997c11c891f91b9fe0659c803a87d57489","html_url":"https://github.com/apache/bookkeeper/commit/7ed489997c11c891f91b9fe0659c803a87d57489","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/7ed489997c11c891f91b9fe0659c803a87d57489/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"c59b7b8a285e5d4da72aea1232a29f31610c2306","url":"https://api.github.com/repos/apache/bookkeeper/commits/c59b7b8a285e5d4da72aea1232a29f31610c2306","html_url":"https://github.com/apache/bookkeeper/commit/c59b7b8a285e5d4da72aea1232a29f31610c2306"}]},{"sha":"cc28541520136968edd3258861e88c5433c5e154","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjYzI4NTQxNTIwMTM2OTY4ZWRkMzI1ODg2MWU4OGM1NDMzYzVlMTU0","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-25T14:38:23Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-25T14:38:23Z"},"message":"BOOKKEEPER-265: Review JMX documentation (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342646 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fdaaf2c08f61c8cd4b77fc07ca7ae1d7f2ecd4bb","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/fdaaf2c08f61c8cd4b77fc07ca7ae1d7f2ecd4bb"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/cc28541520136968edd3258861e88c5433c5e154","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/cc28541520136968edd3258861e88c5433c5e154","html_url":"https://github.com/apache/bookkeeper/commit/cc28541520136968edd3258861e88c5433c5e154","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/cc28541520136968edd3258861e88c5433c5e154/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"7ed489997c11c891f91b9fe0659c803a87d57489","url":"https://api.github.com/repos/apache/bookkeeper/commits/7ed489997c11c891f91b9fe0659c803a87d57489","html_url":"https://github.com/apache/bookkeeper/commit/7ed489997c11c891f91b9fe0659c803a87d57489"}]},{"sha":"a1eac18799ddc640bd42e6c038a31e1e26769056","node_id":"MDY6Q29tbWl0MTU3NTk1NjphMWVhYzE4Nzk5ZGRjNjQwYmQ0MmU2YzAzOGEzMWUxZTI2NzY5MDU2","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-25T15:13:44Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-25T15:13:44Z"},"message":"BOOKKEEPER-260: Define constant for -1 (invalid entry id) (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342678 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a598a5582c1388ac1a962cfb29d975cc968e498a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a598a5582c1388ac1a962cfb29d975cc968e498a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/a1eac18799ddc640bd42e6c038a31e1e26769056","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/a1eac18799ddc640bd42e6c038a31e1e26769056","html_url":"https://github.com/apache/bookkeeper/commit/a1eac18799ddc640bd42e6c038a31e1e26769056","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/a1eac18799ddc640bd42e6c038a31e1e26769056/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"cc28541520136968edd3258861e88c5433c5e154","url":"https://api.github.com/repos/apache/bookkeeper/commits/cc28541520136968edd3258861e88c5433c5e154","html_url":"https://github.com/apache/bookkeeper/commit/cc28541520136968edd3258861e88c5433c5e154"}]},{"sha":"1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","node_id":"MDY6Q29tbWl0MTU3NTk1NjoxZGRlM2U1MTkxZTUxYTZmNjQ4YzBkMTZiMTRlY2MxZTAyZmNmZjBh","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-26T17:16:45Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-26T17:16:45Z"},"message":"BOOKKEEPER-258: CompactionTest failed (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1342933 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4608596a0ad764637060c91115ea41a85a3fefd5","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4608596a0ad764637060c91115ea41a85a3fefd5"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","html_url":"https://github.com/apache/bookkeeper/commit/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"a1eac18799ddc640bd42e6c038a31e1e26769056","url":"https://api.github.com/repos/apache/bookkeeper/commits/a1eac18799ddc640bd42e6c038a31e1e26769056","html_url":"https://github.com/apache/bookkeeper/commit/a1eac18799ddc640bd42e6c038a31e1e26769056"}]},{"sha":"bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiZmQwOWRkMGJiNWNiMmQ3ODZkMGY0MTNmMmM2YmM4MjQzZDA2ZDU0","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T20:47:00Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T20:47:00Z"},"message":"BOOKKEEPER-269: Review documentation for hedwig console client (sijie via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1343973 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a907ac0a960a13e7495a984732074799c7972848","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/a907ac0a960a13e7495a984732074799c7972848"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","html_url":"https://github.com/apache/bookkeeper/commit/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","url":"https://api.github.com/repos/apache/bookkeeper/commits/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a","html_url":"https://github.com/apache/bookkeeper/commit/1dde3e5191e51a6f648c0d16b14ecc1e02fcff0a"}]},{"sha":"0cb40cf90f13eedd54392ec954feadf8df28dede","node_id":"MDY6Q29tbWl0MTU3NTk1NjowY2I0MGNmOTBmMTNlZWRkNTQzOTJlYzk1NGZlYWRmOGRmMjhkZWRl","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:00:26Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:00:26Z"},"message":"BOOKKEEPER-270: Review documentation on bookie cookie (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1343981 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0f3fde715de7d127db6b3142d7e55680629eafa4","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/0f3fde715de7d127db6b3142d7e55680629eafa4"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0cb40cf90f13eedd54392ec954feadf8df28dede","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0cb40cf90f13eedd54392ec954feadf8df28dede","html_url":"https://github.com/apache/bookkeeper/commit/0cb40cf90f13eedd54392ec954feadf8df28dede","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0cb40cf90f13eedd54392ec954feadf8df28dede/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","url":"https://api.github.com/repos/apache/bookkeeper/commits/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54","html_url":"https://github.com/apache/bookkeeper/commit/bfd09dd0bb5cb2d786d0f413f2c6bc8243d06d54"}]},{"sha":"f97ac5b415294aafb7e788c3569636882fa7ee4c","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmOTdhYzViNDE1Mjk0YWFmYjdlNzg4YzM1Njk2MzY4ODJmYTdlZTRj","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:02:04Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:02:04Z"},"message":"BOOKKEEPER-270: Review documentation on bookie cookie (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1343986 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4ed3ab242a53b61ec76a1419b90bd6d9161a4727","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/4ed3ab242a53b61ec76a1419b90bd6d9161a4727"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/f97ac5b415294aafb7e788c3569636882fa7ee4c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/f97ac5b415294aafb7e788c3569636882fa7ee4c","html_url":"https://github.com/apache/bookkeeper/commit/f97ac5b415294aafb7e788c3569636882fa7ee4c","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/f97ac5b415294aafb7e788c3569636882fa7ee4c/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"0cb40cf90f13eedd54392ec954feadf8df28dede","url":"https://api.github.com/repos/apache/bookkeeper/commits/0cb40cf90f13eedd54392ec954feadf8df28dede","html_url":"https://github.com/apache/bookkeeper/commit/0cb40cf90f13eedd54392ec954feadf8df28dede"}]},{"sha":"887546e7937db1c45e42b7ca49b3c82d790adca9","node_id":"MDY6Q29tbWl0MTU3NTk1Njo4ODc1NDZlNzkzN2RiMWM0NWU0MmI3Y2E0OWIzYzgyZDc5MGFkY2E5","commit":{"author":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:12:38Z"},"committer":{"name":"Flavio Paiva Junqueira","email":"fpj@apache.org","date":"2012-05-29T21:12:38Z"},"message":"BOOKKEEPER-271: Review documentation for message bounding (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1343996 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d0fb9bdf1dff1a4415b6c524c0d3e87c5f26ec86","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/d0fb9bdf1dff1a4415b6c524c0d3e87c5f26ec86"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/887546e7937db1c45e42b7ca49b3c82d790adca9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/887546e7937db1c45e42b7ca49b3c82d790adca9","html_url":"https://github.com/apache/bookkeeper/commit/887546e7937db1c45e42b7ca49b3c82d790adca9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/887546e7937db1c45e42b7ca49b3c82d790adca9/comments","author":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"committer":{"login":"fpj","id":572920,"node_id":"MDQ6VXNlcjU3MjkyMA==","avatar_url":"https://avatars.githubusercontent.com/u/572920?v=4","gravatar_id":"","url":"https://api.github.com/users/fpj","html_url":"https://github.com/fpj","followers_url":"https://api.github.com/users/fpj/followers","following_url":"https://api.github.com/users/fpj/following{/other_user}","gists_url":"https://api.github.com/users/fpj/gists{/gist_id}","starred_url":"https://api.github.com/users/fpj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fpj/subscriptions","organizations_url":"https://api.github.com/users/fpj/orgs","repos_url":"https://api.github.com/users/fpj/repos","events_url":"https://api.github.com/users/fpj/events{/privacy}","received_events_url":"https://api.github.com/users/fpj/received_events","type":"User","site_admin":false},"parents":[{"sha":"f97ac5b415294aafb7e788c3569636882fa7ee4c","url":"https://api.github.com/repos/apache/bookkeeper/commits/f97ac5b415294aafb7e788c3569636882fa7ee4c","html_url":"https://github.com/apache/bookkeeper/commit/f97ac5b415294aafb7e788c3569636882fa7ee4c"}]},{"sha":"d68727ddd09dc0646af2748c3531e8844fdcaaf4","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkNjg3MjdkZGQwOWRjMDY0NmFmMjc0OGMzNTMxZTg4NDRmZGNhYWY0","commit":{"author":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-30T15:13:11Z"},"committer":{"name":"Ivan Brendan Kelly","email":"ivank@apache.org","date":"2012-05-30T15:13:11Z"},"message":"BOOKKEEPER-273: LedgerHandle.deleteLedger() should be idempotent (Matteo Merli via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1344301 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"74d7add41a925b008c0e372dd2006837801a94ae","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/74d7add41a925b008c0e372dd2006837801a94ae"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d68727ddd09dc0646af2748c3531e8844fdcaaf4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d68727ddd09dc0646af2748c3531e8844fdcaaf4","html_url":"https://github.com/apache/bookkeeper/commit/d68727ddd09dc0646af2748c3531e8844fdcaaf4","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d68727ddd09dc0646af2748c3531e8844fdcaaf4/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"887546e7937db1c45e42b7ca49b3c82d790adca9","url":"https://api.github.com/repos/apache/bookkeeper/commits/887546e7937db1c45e42b7ca49b3c82d790adca9","html_url":"https://github.com/apache/bookkeeper/commit/887546e7937db1c45e42b7ca49b3c82d790adca9"}]},{"sha":"687de61ce5077451957307a37c2feecdfb1ed8b5","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2ODdkZTYxY2U1MDc3NDUxOTU3MzA3YTM3YzJmZWVjZGZiMWVkOGI1","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T02:22:21Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T02:22:21Z"},"message":"Preparing for release 4.1.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1344538 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6d3023323d358cc50e54cc080ab79515167ceaf6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6d3023323d358cc50e54cc080ab79515167ceaf6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/687de61ce5077451957307a37c2feecdfb1ed8b5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/687de61ce5077451957307a37c2feecdfb1ed8b5","html_url":"https://github.com/apache/bookkeeper/commit/687de61ce5077451957307a37c2feecdfb1ed8b5","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/687de61ce5077451957307a37c2feecdfb1ed8b5/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"d68727ddd09dc0646af2748c3531e8844fdcaaf4","url":"https://api.github.com/repos/apache/bookkeeper/commits/d68727ddd09dc0646af2748c3531e8844fdcaaf4","html_url":"https://github.com/apache/bookkeeper/commit/d68727ddd09dc0646af2748c3531e8844fdcaaf4"}]},{"sha":"65c74c3c0c604a46962607eae2c4efbe343fb107","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2NWM3NGMzYzBjNjA0YTQ2OTYyNjA3ZWFlMmM0ZWZiZTM0M2ZiMTA3","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T02:24:18Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T02:24:18Z"},"message":"Branching for 4.1 releases\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1344540 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6d3023323d358cc50e54cc080ab79515167ceaf6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/6d3023323d358cc50e54cc080ab79515167ceaf6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/65c74c3c0c604a46962607eae2c4efbe343fb107","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/65c74c3c0c604a46962607eae2c4efbe343fb107","html_url":"https://github.com/apache/bookkeeper/commit/65c74c3c0c604a46962607eae2c4efbe343fb107","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/65c74c3c0c604a46962607eae2c4efbe343fb107/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"687de61ce5077451957307a37c2feecdfb1ed8b5","url":"https://api.github.com/repos/apache/bookkeeper/commits/687de61ce5077451957307a37c2feecdfb1ed8b5","html_url":"https://github.com/apache/bookkeeper/commit/687de61ce5077451957307a37c2feecdfb1ed8b5"}]},{"sha":"fb9d5f35a4edf2d241362a579de759c79598c0e7","node_id":"MDY6Q29tbWl0MTU3NTk1NjpmYjlkNWYzNWE0ZWRmMmQyNDEzNjJhNTc5ZGU3NTljNzk1OThjMGU3","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T05:27:12Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T05:27:12Z"},"message":"Preparing for release 4.1.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1344566 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"06219519f19bfa775f2fc7f939a7b0adadfa44e6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/06219519f19bfa775f2fc7f939a7b0adadfa44e6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/fb9d5f35a4edf2d241362a579de759c79598c0e7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/fb9d5f35a4edf2d241362a579de759c79598c0e7","html_url":"https://github.com/apache/bookkeeper/commit/fb9d5f35a4edf2d241362a579de759c79598c0e7","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/fb9d5f35a4edf2d241362a579de759c79598c0e7/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"65c74c3c0c604a46962607eae2c4efbe343fb107","url":"https://api.github.com/repos/apache/bookkeeper/commits/65c74c3c0c604a46962607eae2c4efbe343fb107","html_url":"https://github.com/apache/bookkeeper/commit/65c74c3c0c604a46962607eae2c4efbe343fb107"}]},{"sha":"6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","node_id":"MDY6Q29tbWl0MTU3NTk1Njo2MDAzMDgxZmE2ODZiMWUxYTJmZDM3YjQ5ZjQzYjVmZjVjNTUyZDhm","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T05:28:31Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-05-31T05:28:31Z"},"message":"BookKeeper 4.1.0 release.\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.1.0@1344567 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"06219519f19bfa775f2fc7f939a7b0adadfa44e6","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/06219519f19bfa775f2fc7f939a7b0adadfa44e6"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","html_url":"https://github.com/apache/bookkeeper/commit/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"fb9d5f35a4edf2d241362a579de759c79598c0e7","url":"https://api.github.com/repos/apache/bookkeeper/commits/fb9d5f35a4edf2d241362a579de759c79598c0e7","html_url":"https://github.com/apache/bookkeeper/commit/fb9d5f35a4edf2d241362a579de759c79598c0e7"}]},{"sha":"c1024f84c8502c77ef42dad1123a87e3dbd629fc","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjMTAyNGY4NGM4NTAyYzc3ZWY0MmRhZDExMjNhODdlM2RiZDYyOWZj","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T06:21:07Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T06:21:07Z"},"message":"BOOKKEEPER-281: BKClient is failing when zkclient connection delays (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1346253 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9eaecaf0bef2e78dc1025d6a47642f3622e8da21","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/9eaecaf0bef2e78dc1025d6a47642f3622e8da21"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c1024f84c8502c77ef42dad1123a87e3dbd629fc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c1024f84c8502c77ef42dad1123a87e3dbd629fc","html_url":"https://github.com/apache/bookkeeper/commit/c1024f84c8502c77ef42dad1123a87e3dbd629fc","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c1024f84c8502c77ef42dad1123a87e3dbd629fc/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"fb9d5f35a4edf2d241362a579de759c79598c0e7","url":"https://api.github.com/repos/apache/bookkeeper/commits/fb9d5f35a4edf2d241362a579de759c79598c0e7","html_url":"https://github.com/apache/bookkeeper/commit/fb9d5f35a4edf2d241362a579de759c79598c0e7"}]},{"sha":"9268e6194fadbf2829dd74ebb652d9b39e4a3c10","node_id":"MDY6Q29tbWl0MTU3NTk1Njo5MjY4ZTYxOTRmYWRiZjI4MjlkZDc0ZWJiNjUyZDliMzllNGEzYzEw","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T06:56:06Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T06:56:06Z"},"message":"BOOKKEEPER-279: LocalBookKeeper is failing intermittently due to zkclient connection establishment delay (Rakesh R via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1346258 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"160f9471725d34c5aadf4364c27ccbe87390755a","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/160f9471725d34c5aadf4364c27ccbe87390755a"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/9268e6194fadbf2829dd74ebb652d9b39e4a3c10","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/9268e6194fadbf2829dd74ebb652d9b39e4a3c10","html_url":"https://github.com/apache/bookkeeper/commit/9268e6194fadbf2829dd74ebb652d9b39e4a3c10","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/9268e6194fadbf2829dd74ebb652d9b39e4a3c10/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"c1024f84c8502c77ef42dad1123a87e3dbd629fc","url":"https://api.github.com/repos/apache/bookkeeper/commits/c1024f84c8502c77ef42dad1123a87e3dbd629fc","html_url":"https://github.com/apache/bookkeeper/commit/c1024f84c8502c77ef42dad1123a87e3dbd629fc"}]},{"sha":"5f9184d615aa383a89366bc8f7a1ca46211324c9","node_id":"MDY6Q29tbWl0MTU3NTk1Njo1ZjkxODRkNjE1YWEzODNhODkzNjZiYzhmN2ExY2E0NjIxMTMyNGM5","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T10:11:18Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T10:11:18Z"},"message":"BOOKKEEPER-285: TestZkSubscriptionManager quits due to NPE, so other tests are not run in hedwig server. (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1346328 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3e9692541ede5c7948993725430fb2008ceed80f","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/3e9692541ede5c7948993725430fb2008ceed80f"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/5f9184d615aa383a89366bc8f7a1ca46211324c9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9184d615aa383a89366bc8f7a1ca46211324c9","html_url":"https://github.com/apache/bookkeeper/commit/5f9184d615aa383a89366bc8f7a1ca46211324c9","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9184d615aa383a89366bc8f7a1ca46211324c9/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"9268e6194fadbf2829dd74ebb652d9b39e4a3c10","url":"https://api.github.com/repos/apache/bookkeeper/commits/9268e6194fadbf2829dd74ebb652d9b39e4a3c10","html_url":"https://github.com/apache/bookkeeper/commit/9268e6194fadbf2829dd74ebb652d9b39e4a3c10"}]},{"sha":"397fdcebbf14e3dc2524e77f4e2175a861638489","node_id":"MDY6Q29tbWl0MTU3NTk1NjozOTdmZGNlYmJmMTRlM2RjMjUyNGU3N2Y0ZTIxNzVhODYxNjM4NDg5","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T11:18:36Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-05T11:18:36Z"},"message":"BOOKKEEPER-286: Compilation warning (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1346343 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"76a1649a6fbe35736eea096fc191f198259e1858","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/76a1649a6fbe35736eea096fc191f198259e1858"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/397fdcebbf14e3dc2524e77f4e2175a861638489","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/397fdcebbf14e3dc2524e77f4e2175a861638489","html_url":"https://github.com/apache/bookkeeper/commit/397fdcebbf14e3dc2524e77f4e2175a861638489","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/397fdcebbf14e3dc2524e77f4e2175a861638489/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"5f9184d615aa383a89366bc8f7a1ca46211324c9","url":"https://api.github.com/repos/apache/bookkeeper/commits/5f9184d615aa383a89366bc8f7a1ca46211324c9","html_url":"https://github.com/apache/bookkeeper/commit/5f9184d615aa383a89366bc8f7a1ca46211324c9"}]},{"sha":"c4f3b36fd9186377ea894c72af5c10743c0a7fa0","node_id":"MDY6Q29tbWl0MTU3NTk1NjpjNGYzYjM2ZmQ5MTg2Mzc3ZWE4OTRjNzJhZjVjMTA3NDNjMGE3ZmEw","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-06T16:36:25Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-06T16:36:25Z"},"message":"BOOKKEEPER-287: NoSuchElementException in LedgerCacheImpl (sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1346976 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cb08088361df5c92f9b5e812ec7297c5690ba390","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cb08088361df5c92f9b5e812ec7297c5690ba390"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/c4f3b36fd9186377ea894c72af5c10743c0a7fa0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/c4f3b36fd9186377ea894c72af5c10743c0a7fa0","html_url":"https://github.com/apache/bookkeeper/commit/c4f3b36fd9186377ea894c72af5c10743c0a7fa0","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/c4f3b36fd9186377ea894c72af5c10743c0a7fa0/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"397fdcebbf14e3dc2524e77f4e2175a861638489","url":"https://api.github.com/repos/apache/bookkeeper/commits/397fdcebbf14e3dc2524e77f4e2175a861638489","html_url":"https://github.com/apache/bookkeeper/commit/397fdcebbf14e3dc2524e77f4e2175a861638489"}]},{"sha":"0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","node_id":"MDY6Q29tbWl0MTU3NTk1NjowZjcyNGU1Y2EyM2UwZGUyZWI3ZmVlODI4OGIyZDNiOTE1M2MyM2Iy","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T06:37:46Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T06:37:46Z"},"message":" svn merge -c 1346253,1346258,1346328,1346343,1346976 https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1 \n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.1.0@1347417 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cb08088361df5c92f9b5e812ec7297c5690ba390","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/cb08088361df5c92f9b5e812ec7297c5690ba390"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","html_url":"https://github.com/apache/bookkeeper/commit/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","url":"https://api.github.com/repos/apache/bookkeeper/commits/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f","html_url":"https://github.com/apache/bookkeeper/commit/6003081fa686b1e1a2fd37b49f43b5ff5c552d8f"},{"sha":"c4f3b36fd9186377ea894c72af5c10743c0a7fa0","url":"https://api.github.com/repos/apache/bookkeeper/commits/c4f3b36fd9186377ea894c72af5c10743c0a7fa0","html_url":"https://github.com/apache/bookkeeper/commit/c4f3b36fd9186377ea894c72af5c10743c0a7fa0"}]},{"sha":"b3a35d651aa79595738f41c0b3aead641d40af5d","node_id":"MDY6Q29tbWl0MTU3NTk1NjpiM2EzNWQ2NTFhYTc5NTk1NzM4ZjQxYzBiM2FlYWQ2NDFkNDBhZjVk","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T14:17:55Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T14:17:55Z"},"message":"BOOKKEEPER-288: NOTICE files don't have the correct year (ivank via sijie)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1347629 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"24064582f27e019ff02d8e8e8c8523e8b3ba075b","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/24064582f27e019ff02d8e8e8c8523e8b3ba075b"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/b3a35d651aa79595738f41c0b3aead641d40af5d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/b3a35d651aa79595738f41c0b3aead641d40af5d","html_url":"https://github.com/apache/bookkeeper/commit/b3a35d651aa79595738f41c0b3aead641d40af5d","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/b3a35d651aa79595738f41c0b3aead641d40af5d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"c4f3b36fd9186377ea894c72af5c10743c0a7fa0","url":"https://api.github.com/repos/apache/bookkeeper/commits/c4f3b36fd9186377ea894c72af5c10743c0a7fa0","html_url":"https://github.com/apache/bookkeeper/commit/c4f3b36fd9186377ea894c72af5c10743c0a7fa0"}]},{"sha":"ebe0731175c8c19d60bf4f014eeff5db81784e74","node_id":"MDY6Q29tbWl0MTU3NTk1NjplYmUwNzMxMTc1YzhjMTlkNjBiZjRmMDE0ZWVmZjVkYjgxNzg0ZTc0","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T14:23:42Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T14:23:42Z"},"message":"update release date for release 4.1.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1@1347636 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1e56c9cc63670f37761960dcb2007ca106f81eea","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1e56c9cc63670f37761960dcb2007ca106f81eea"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/ebe0731175c8c19d60bf4f014eeff5db81784e74","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/ebe0731175c8c19d60bf4f014eeff5db81784e74","html_url":"https://github.com/apache/bookkeeper/commit/ebe0731175c8c19d60bf4f014eeff5db81784e74","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/ebe0731175c8c19d60bf4f014eeff5db81784e74/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"b3a35d651aa79595738f41c0b3aead641d40af5d","url":"https://api.github.com/repos/apache/bookkeeper/commits/b3a35d651aa79595738f41c0b3aead641d40af5d","html_url":"https://github.com/apache/bookkeeper/commit/b3a35d651aa79595738f41c0b3aead641d40af5d"}]},{"sha":"d867700500eed6404c2f2f54f1ebe7b385d067ab","node_id":"MDY6Q29tbWl0MTU3NTk1NjpkODY3NzAwNTAwZWVkNjQwNGMyZjJmNTRmMWViZTdiMzg1ZDA2N2Fi","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T15:24:59Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2012-06-07T15:24:59Z"},"message":"svn merge -c 1347629,1347636  https://svn.apache.org/repos/asf/zookeeper/bookkeeper/branches/branch-4.1\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/tags/release-4.1.0@1347677 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1e56c9cc63670f37761960dcb2007ca106f81eea","url":"https://api.github.com/repos/apache/bookkeeper/git/trees/1e56c9cc63670f37761960dcb2007ca106f81eea"},"url":"https://api.github.com/repos/apache/bookkeeper/git/commits/d867700500eed6404c2f2f54f1ebe7b385d067ab","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/bookkeeper/commits/d867700500eed6404c2f2f54f1ebe7b385d067ab","html_url":"https://github.com/apache/bookkeeper/commit/d867700500eed6404c2f2f54f1ebe7b385d067ab","comments_url":"https://api.github.com/repos/apache/bookkeeper/commits/d867700500eed6404c2f2f54f1ebe7b385d067ab/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","url":"https://api.github.com/repos/apache/bookkeeper/commits/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2","html_url":"https://github.com/apache/bookkeeper/commit/0f724e5ca23e0de2eb7fee8288b2d3b9153c23b2"},{"sha":"ebe0731175c8c19d60bf4f014eeff5db81784e74","url":"https://api.github.com/repos/apache/bookkeeper/commits/ebe0731175c8c19d60bf4f014eeff5db81784e74","html_url":"https://github.com/apache/bookkeeper/commit/ebe0731175c8c19d60bf4f014eeff5db81784e74"}]}],"files":[{"sha":"8de8daba3e1b6cf737f0bba3f2461fa7c22546ad","filename":"CHANGES.txt","status":"modified","additions":320,"deletions":83,"changes":403,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/CHANGES.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/CHANGES.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/CHANGES.txt?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -1,166 +1,403 @@\n+Release 4.1.0 - 2012-06-07\n+\n+  Non-backward compatible changes:\n+\n+    BUGFIXES:\n+\n+    IMPROVEMENTS:\n+\n+  Backward compatible changes:\n+\n+    BUGFIXES:\n+\n+      BOOKKEEPER-145: Put notice and license file for distributed binaries in SVN (ivank)\n+\n+      BOOKKEEPER-254: Bump zookeeper version in poms (ivank)\n+\n+      BOOKKEEPER-72: Fix warnings issued by FindBugs (ivank)\n+\n+      BOOKKEEPER-238: Add log4j.properties in conf/ for bin packages (ivank)\n+\n+      bookkeeper-server/\n+\n+        BOOKKEEPER-142: Parsing last log id is wrong, which may make entry log files overwritten (Sijie Gou via ivank)\n+\n+        BOOKKEEPER-141: Run extracting ledger id from entry log files in GC thread to speed up bookie restart (Sijie Gou via ivank)\n+\n+        BOOKKEEPER-148: Jenkins build is failing (ivank via fpj)\n+\n+        BOOKKEEPER-40: BookieClientTest fails intermittantly (fpj via ivank)\n+\n+\tBOOKKEEPER-150: Entry is lost when recovering a ledger with not enough bookies. (Sijie Guo via ivank)\n+\n+        BOOKKEEPER-153: Ledger can't be opened or closed due to zero-length metadata (Sijie Guo via ivank)\n+\n+        BOOKKEEPER-23: Timeout requests (ivank)\n+\n+        BOOKKEEPER-161: PerChannelBookieClient tries to reuse HashedWheelTimer, throws Exception (ivank)\n+\n+        BOOKKEEPER-167: PerChannelBookieClient doesn't use ClientConfiguration (Sijie Guo via ivank)\n+\n+        BOOKKEEPER-156: BookieJournalRollingTest failing (Sijie Guo via ivank)\n+\n+\tBOOKKEEPER-162: LedgerHandle.readLastConfirmed does not work (fpj)\n+\n+        BOOKKEEPER-152: Can't recover a ledger whose current ensemble contain failed bookie. (ivank)\n+\n+        BOOKKEEPER-171: ServerConfiguration can't use more than one directory for ledgers. (ivank via sijie)\n+\t\n+\tBOOKKEEPER-170: Bookie constructor starts a number of threads. (ivank via fpj)\n+\n+        BOOKKEEPER-169: bookie hangs on reading header when encountering partial header index file (sijie via ivank)\n+\n+        BOOKKEEPER-174: Bookie can't start when replaying entries whose ledger were deleted and garbage collected. (sijie via ivank)\n+\n+        BOOKKEEPER-177: Index file is lost or some index pages aren't flushed. (sijie via ivank)\n+\n+        BOOKKEEPER-113: NPE In BookKeeper test (fpj via ivank)\n+\n+\tBOOKKEEPER-176: HierarchicalBookieFailureTest Hung (ivank via fpj)\n+\n+        BOOKKEEPER-180: bookie server doesn't quit when running out of disk space (sijie via ivank)\n+\n+        BOOKKEEPER-185: Remove bookkeeper-server dependency on hadoop-common (ivank)\n+\n+        BOOKKEEPER-184: CompactionTest failing on Jenkins (sijie via ivank)\n+\n+        BOOKKEEPER-182: Entry log file is overwritten when fail to read lastLogId. (sijie via ivank)\n+\n+        BOOKKEEPER-186: Bookkeeper throttling - permits is not released when read has failed from all replicas (Rakesh R via sijie)\n+\n+        BOOKKEEPER-189: AbstractZkLedgerManager doesn't disregard cookies (ivank via sijie)\n+\n+        BOOKKEEPER-195: HierarchicalLedgerManager doesn't consider idgen as a \"specialNode\" (ivank)\n+\n+        BOOKKEEPER-190: Add entries would fail when number of open ledgers reaches more than openFileLimit. (sijie via ivank)\n+\n+        BOOKKEEPER-194: Get correct latency for addEntry operations for JMX. (sijie via ivank)\n+\n+        BOOKKEEPER-166: Bookie will not recover its journal if the length prefix of an entry is truncated (ivank)\n+\n+        BOOKKEEPER-193: Ledger is garbage collected by mistake. (sijie, ivank via sijie)\n+\n+        BOOKKEEPER-198: replaying entries of deleted ledgers would exhaust ledger cache. (sijie)\n+\n+        BOOKKEEPER-112: Bookie Recovery on an open ledger will cause LedgerHandle#close on that ledger to fail (sijie)\n+\n+        BOOKKEEPER-135: Fencing does not check the ledger masterPasswd (ivank)\n+\n+\tBOOKKEEPER-212: Bookie stops responding when creating and deleting many ledgers (sijie via fpj)\n+\n+        BOOKKEEPER-211: Bookie fails to to start (sijie)\n+\n+\tBOOKKEEPER-200: Fix format and comments (fpj)\n+\n+        BOOKKEEPER-216: Bookie doesn't exit with right exit code (sijie via ivank)\n+\n+        BOOKKEEPER-196: Define interface between bookie and ledger storage (ivank)\n+\n+        BOOKKEEPER-213: PerChannelBookieClient calls the wrong errorOut function when encountering an exception (Aniruddha via sijie)\n+\n+        BOOKKEEPER-231: ZKUtil.killServer not closing the FileTxnSnapLog from ZK. (Uma Maheswara Rao G via sijie)\n+\n+        BOOKKEEPER-232: AsyncBK tests failing (umamaheswararao via ivank)\n+\n+\tBOOKKEEPER-229: Deleted entry log files would be garbage collected again and again. (sijie via fpj)\n+\n+        BOOKKEEPER-242: Bookkeeper not able to connect other zookeeper when shutdown the zookeeper server where the BK has connected. (sijie & rakeshr via ivank)\n+\n+        BOOKKEEPER-234: EntryLogger will throw NPE, if any dir does not exist or IO Errors. (umamaheswararao via ivank)\n+\n+\tBOOKKEEPER-235: Bad syncing in entrylogger degrades performance for many concurrent ledgers (ivank via fpj)\n+\n+        BOOKKEEPER-224: Fix findbugs in bookkeeper-server component (ivank)\n+\n+        BOOKKEEPER-251: Noise error message printed when scanning entry log files those have been garbage collected. (sijie via ivank)\n+\n+        BOOKKEEPER-266: Review versioning documentation (ivank)\n+\n+        BOOKKEEPER-258: CompactionTest failed (ivank via sijie)\n+\n+        BOOKKEEPER-273: LedgerHandle.deleteLedger() should be idempotent (Matteo Merli via ivank)\n+\n+        BOOKKEEPER-281: BKClient is failing when zkclient connection delays (ivank via sijie)\n+\n+        BOOKKEEPER-279: LocalBookKeeper is failing intermittently due to zkclient connection establishment delay (Rakesh R via sijie)\n+\n+        BOOKKEEPER-286: Compilation warning (ivank via sijie)\n+\n+        BOOKKEEPER-287: NoSuchElementException in LedgerCacheImpl (sijie)\n+\n+        BOOKKEEPER-288: NOTICE files don't have the correct year (ivank via sijie)\n+\n+      hedwig-client/\n+\n+        BOOKKEEPER-217: NPE in hedwig client when enable DEBUG (sijie via ivank)\n+\n+      hedwig-server/\n+      \n+        BOOKKEEPER-140: Hub server doesn't subscribe remote region correctly when a region is down. (Sijie Gou via ivank)\n+\n+        BOOKKEEPER-133: Hub server should update subscription state to zookeeper when losing topic or shutting down (Sijie Gou via ivank)\n+\n+        BOOKKEEPER-74: Bookkeeper Persistence Manager should give up topic on error (sijie via ivank)\n+\n+        BOOKKEEPER-163: Prevent incorrect NoSuchLedgerException for readLastConfirmed. (ivank via sijie)\n+\n+        BOOKKEEPER-197: HedwigConsole uses the same file to load bookkeeper client config and hub server config (sijie)\n+\n+        BOOKKEEPER-56: Race condition of message handler in connection recovery in Hedwig client (sijie & Gavin Li via ivank)\n+\n+        BOOKKEEPER-215: Deadlock occurs under high load (sijie via ivank)\n+\n+        BOOKKEEPER-245: Intermittent failures in PersistanceManager tests (ivank)\n+\n+        BOOKKEEPER-209: Typo in ServerConfiguration for READAHEAD_ENABLED (ivank)\n+\n+        BOOKKEEPER-146: TestConcurrentTopicAcquisition sometimes hangs (ivank)\n+\n+        BOOKKEEPER-285: TestZkSubscriptionManager quits due to NPE, so other tests are not run in hedwig server. (sijie)\n+\n+      bookkeeper-benchmark/\n+\t\n+\tBOOKKEEPER-207: BenchBookie doesn't run correctly (ivank via fpj)\n+\n+        BOOKKEEPER-228: Fix the bugs in BK benchmark (umamaheswararao via ivank)\n+\n+    IMPROVEMENTS:\n+\n+\tBOOKKEEPER-265: Review JMX documentation (sijie via fpj)\n+\n+      bookkeeper-server/\n+\n+        BOOKKEEPER-95: extends zookeeper JMX to monitor and manage bookie server (Sijie Guo via ivank)\n+\n+        BOOKKEEPER-98: collect add/read statistics on bookie server (Sijie Guo via ivank)\n+\n+\tBOOKKEEPER-157:\tFor small packets, increasing number of bookies actually degrades performance. (ivank via fpj)\n+\n+        BOOKKEEPER-165: Add versioning support for journal files (ivank)\n+\n+        BOOKKEEPER-137: Do not create Ledger index files until absolutely necessary. (ivank)\n+\n+\tBOOKKEEPER-172: Upgrade framework for filesystem layouts (ivank via fpj)\n+\n+        BOOKKEEPER-178: Delay ledger directory creation until the ledger index file was created (sijie via ivank)\n+\n+        BOOKKEEPER-160: bookie server needs to do compaction over entry log files to reclaim disk space (sijie via ivank)\n+\n+        BOOKKEEPER-187: Create well defined interface for LedgerCache (ivank)\n+\n+        BOOKKEEPER-175: Bookie code is very coupled (ivank)\n+\n+        BOOKKEEPER-188: Garbage collection code is in the wrong place (ivank via sijie)\n+\n+        BOOKKEEPER-218: Provide journal manager to manage journal related operations (sijie)\n+\n+\tBOOKKEEPER-173: Uncontrolled number of threads in bookkeeper (sijie via fpj)\n+\n+\tBOOKKEEPER-241: Add documentation for bookie entry log compaction (sijie via fpj)\n+\n+\tBOOKKEEPER-263: ZK ledgers root path is hard coded (Aniruddha via sijie)\n+\n+\tBOOKKEEPER-260: Define constant for -1 (invalid entry id) (ivank via fpj)\n+\n+\tBOOKKEEPER-270: Review documentation on bookie cookie (ivank via fpj)\n+\n+      hedwig-server/\n+\n+        BOOKKEEPER-77: Add a console client for hedwig (Sijie Guo via ivank)\n+\n+        BOOKKEEPER-168: Message bounding on subscriptions (ivank)\n+\n+        BOOKKEEPER-96: extends zookeeper JMX to monitor and manage hedwig server (sijie via ivank)\n+\n+        BOOKKEEPER-97: collect pub/sub/consume statistics on hub server (sijie via ivank)\n+\n+\tBOOKKEEPER-269: Review documentation for hedwig console client (sijie via fpj)\n+\t\n+      hedwig-client/\n+\n+\tBOOKKEEPER-271: Review documentation for message bounding (ivank via fpj)\n+\n+      bookkeeper-benchmark/\n+\tBOOKKEEPER-158: Move latest benchmarking code into trunk (ivank via fpj)\n+\n+\tBOOKKEEPER-236: Benchmarking improvements from latest round of benchmarking (ivank via fpj)\n+\n Release 4.0.0 - 2011-11-30\n \n-Non-backward compatible changes:\n+  Non-backward compatible changes:\n \n-BUGFIXES:\n+    BUGFIXES:\n \n- BOOKKEEPER-89: Bookkeeper API changes for initial Bookkeeper release (ivank)\n+      BOOKKEEPER-89: Bookkeeper API changes for initial Bookkeeper release (ivank)\n \n- BOOKKEEPER-108: add configuration support for BK (Sijie via ivank)\n+      BOOKKEEPER-108: add configuration support for BK (Sijie via ivank)\n \n- BOOKKEEPER-90: Hedwig API changes for initial Bookkeeper release (ivank via fpj)\n+      BOOKKEEPER-90: Hedwig API changes for initial Bookkeeper release (ivank via fpj)\n \n-Backward compatible changes:\n+  Backward compatible changes:\n \n-BUGFIXES:\n+    BUGFIXES:\n \n- BOOKKEEPER-124: build has RAT failures (ivank)\n+      BOOKKEEPER-124: build has RAT failures (ivank)\n \n- BOOKKEEPER-121: Review Hedwig client documentation (breed via ivank)\n- \n- BOOKKEEPER-127: Make poms use official zookeeper 3.4.0 (ivank)\n+      BOOKKEEPER-121: Review Hedwig client documentation (breed via ivank)\n+\n+      BOOKKEEPER-127: Make poms use official zookeeper 3.4.0 (ivank)\n \n- BOOKKEEPER-120: Review BookKeeper client documentation (ivank)\n+      BOOKKEEPER-120: Review BookKeeper client documentation (ivank)\n  \n- BOOKKEEPER-122: Review BookKeeper server documentation (fpj & ivank)\n+      BOOKKEEPER-122: Review BookKeeper server documentation (fpj & ivank)\n  \n- BOOKKEEPER-130: Add developer KEYS file to svn (ivank)\n+      BOOKKEEPER-66: use IPv4 for builds (mmorel via ivank)\n+\n+      BOOKKEEPER-132: Sign artifacts before deploying to maven (ivank)\n+\n+      BOOKKEEPER-131: Fix zookeeper test dependency (ivank)\n+\n+      BOOKKEEPER-134: Delete superfluous lib directories (ivank)\n+\n+      BOOKKEEPER-138: NOTICE.txt is invalid (ivank)\n+\n+      BOOKKEEPER-139: Binary packages do not carry NOTICE.txt (ivank)\n \n- bookkeeper-server/\n+      bookkeeper-server/\n \n-  BOOKKEEPER-1: Static variable makes tests fail (fpj via ivank)\n+        BOOKKEEPER-1: Static variable makes tests fail (fpj via ivank)\n \n-  BOOKKEEPER-19: BookKeeper doesn't support more than 2Gig of memory (ivan via fpj)\n+        BOOKKEEPER-19: BookKeeper doesn't support more than 2Gig of memory (ivan via fpj)\n \n-  BOOKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n+        BOOKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n \n-  BOOKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n+        BOOKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n \n-  BOOKKEEPER-30: Test are too noisy (ivank via fpj)\n+        BOOKKEEPER-30: Test are too noisy (ivank via fpj)\n \n-  BOOKKEEPER-11: Read from open ledger (fpj via ivank)\n+        BOOKKEEPER-11: Read from open ledger (fpj via ivank)\n \n-  BOOKKEEPER-27: mvn site failed with unresolved dependencies (ivank via fpj)\n+        BOOKKEEPER-27: mvn site failed with unresolved dependencies (ivank via fpj)\n   \n-  BOOKKEEPER-29: BookieRecoveryTest fails intermittently (fpj via ivank)\n+        BOOKKEEPER-29: BookieRecoveryTest fails intermittently (fpj via ivank)\n \n-  BOOKKEEPER-33: Add length and offset parameter to addEntry (ivank via fpj)\n+        BOOKKEEPER-33: Add length and offset parameter to addEntry (ivank via fpj)\n \n-  BOOKKEEPER-29: BookieRecoveryTest fails intermittently (ivank, fpj via fpj)\n+        BOOKKEEPER-29: BookieRecoveryTest fails intermittently (ivank, fpj via fpj)\n \n-  BOOKKEEPER-38: Bookie Server doesn't exit when its zookeeper session is expired. So the process is hang there. (Sijie Guo via breed)\n+        BOOKKEEPER-38: Bookie Server doesn't exit when its zookeeper session is expired. So the process is hang there. (Sijie Guo via breed)\n \n-  BOOKKEEPER-58: Changes introduced in BK-38 cause BookieClientTest to hang indefinitely. (ivank)\n+        BOOKKEEPER-58: Changes introduced in BK-38 cause BookieClientTest to hang indefinitely. (ivank)\n \n-  BOOKKEEPER-18: maven build is unstable (mmorel, ivank via ivank)\n+        BOOKKEEPER-18: maven build is unstable (mmorel, ivank via ivank)\n \n-  BOOKKEEPER-57: NullPointException at bookie.zk@EntryLogger (xulei via ivank)\n+        BOOKKEEPER-57: NullPointException at bookie.zk@EntryLogger (xulei via ivank)\n \n-  BOOKKEEPER-59: Race condition in netty code allocates and orphans resources (BK-5 revisited) (ivank via fpj)\n+        BOOKKEEPER-59: Race condition in netty code allocates and orphans resources (BK-5 revisited) (ivank via fpj)\n   \n-  BOOKKEEPER-68: Conditional setData (fpj via ivank)\n+        BOOKKEEPER-68: Conditional setData (fpj via ivank)\n \n-  BOOKKEEPER-86: bookkeeper-benchmark fails to compile after BOOKKEEPER-68 (ivank via breed)\n+        BOOKKEEPER-86: bookkeeper-benchmark fails to compile after BOOKKEEPER-68 (ivank via breed)\n \n-  BOOKKEEPER-61: BufferedChannel read endless when the remaining bytes of file is less than the capacity of read buffer (Sijie Guo via breed)\n+        BOOKKEEPER-61: BufferedChannel read endless when the remaining bytes of file is less than the capacity of read buffer (Sijie Guo via breed)\n \n-  BOOKKEEPER-84: Add versioning for ZK metadata (ivank via breed)\n+        BOOKKEEPER-84: Add versioning for ZK metadata (ivank via breed)\n \n-  BOOKKEEPER-92: using wrong context object in readLastConfirmedComplete callback (Sijie Guo via ivank)\n+        BOOKKEEPER-92: using wrong context object in readLastConfirmedComplete callback (Sijie Guo via ivank)\n  \n-  BOOKKEEPER-94: Double callbacks in readLastConfirmedOp which fails readLastConfirmed operation even received enough valid responses. (Sijie Guo via ivank)\n+        BOOKKEEPER-94: Double callbacks in readLastConfirmedOp which fails readLastConfirmed operation even received enough valid responses. (Sijie Guo via ivank)\n \n-  BOOKKEEPER-83: Added versioning and flags to the bookie protocol (ivank)\n+        BOOKKEEPER-83: Added versioning and flags to the bookie protocol (ivank)\n \n-  BOOKKEEPER-93: bookkeeper doesn't work correctly on OpenLedgerNoRecovery (Sijie Guo via ivank)\n+        BOOKKEEPER-93: bookkeeper doesn't work correctly on OpenLedgerNoRecovery (Sijie Guo via ivank)\n \n-  BOOKKEEPER-103: ledgerId and entryId is parsed wrong when addEntry (Sijie Guo via ivank)\n+        BOOKKEEPER-103: ledgerId and entryId is parsed wrong when addEntry (Sijie Guo via ivank)\n \n-  BOOKKEEPER-50: NullPointException at LedgerDescriptor#cmpMasterKey (Sijie Guo via ivank)\n+        BOOKKEEPER-50: NullPointException at LedgerDescriptor#cmpMasterKey (Sijie Guo via ivank)\n \n-  BOOKKEEPER-82: support journal rolling (Sijie Guo via fpj)\n+        BOOKKEEPER-82: support journal rolling (Sijie Guo via fpj)\n \n-  BOOKKEEPER-106: recoveryBookieData can select a recovery bookie which is already in the ledgers ensemble (ivank via fpj)\n+        BOOKKEEPER-106: recoveryBookieData can select a recovery bookie which is already in the ledgers ensemble (ivank via fpj)\n \n-  BOOKKEEPER-101: Add Fencing to Bookkeeper (ivank)\n+        BOOKKEEPER-101: Add Fencing to Bookkeeper (ivank)\n \n-  BOOKKEEPER-104: Add versioning between bookie and its filesystem layout (ivank)\n+        BOOKKEEPER-104: Add versioning between bookie and its filesystem layout (ivank)\n \n-  BOOKKEEPER-81: disk space of garbage collected entry logger files isn't reclaimed util process quit (Sijie Guo via fpj)\n+        BOOKKEEPER-81: disk space of garbage collected entry logger files isn't reclaimed util process quit (Sijie Guo via fpj)\n \n-  BOOKKEEPER-91: Bookkeeper and hedwig clients should not use log4j directly (ivank via fpj)\n+        BOOKKEEPER-91: Bookkeeper and hedwig clients should not use log4j directly (ivank via fpj)\n \n-  BOOKKEEPER-115: LocalBookKeeper fails after BOOKKEEPER-108 (ivank)\n+        BOOKKEEPER-115: LocalBookKeeper fails after BOOKKEEPER-108 (ivank)\n \n-  BOOKKEEPER-114: add a shutdown hook to shut down bookie server safely. (Sijie via ivank)\n+        BOOKKEEPER-114: add a shutdown hook to shut down bookie server safely. (Sijie via ivank)\n \n-  BOOKKEEPER-39: Bookie server failed to restart because of too many ledgers (more than ~50,000 ledgers) (Sijie via ivank)\n+        BOOKKEEPER-39: Bookie server failed to restart because of too many ledgers (more than ~50,000 ledgers) (Sijie via ivank)\n \n-  BOOKKEEPER-125: log4j still used in some places (ivank)\n+        BOOKKEEPER-125: log4j still used in some places (ivank)\n \n-  BOOKKEEPER-62: Bookie can not start when encountering corrupted records (breed via ivank)\n+        BOOKKEEPER-62: Bookie can not start when encountering corrupted records (breed via ivank)\n \n-  BOOKKEEPER-111: Document bookie recovery feature (ivank)\n+        BOOKKEEPER-111: Document bookie recovery feature (ivank)\n \n-  BOOKKEEPER-129: ZK_TIMEOUT typo in client/server configuration (Sijie via ivank)\n+        BOOKKEEPER-129: ZK_TIMEOUT typo in client/server configuration (Sijie via ivank)\n \n-  BOOKKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n+        BOOKKEEPER-22: Exception in LedgerCache causes addEntry request to fail (fpj via fpj)\n \n-  BOOKKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n+        BOOKKEEPER-5: Issue with Netty in BookKeeper (fpj and ivank via fpj)\n \n- hedwig-server/\n+      hedwig-server/\n \n-  BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)\n+        BOOKKEEPER-43: NullPointException when releasing topic (Sijie Guo via breed)\n   \n-  BOOKKEEPER-51: NullPointException at FIFODeliveryManager#deliveryPtrs (xulei via ivank)\n+        BOOKKEEPER-51: NullPointException at FIFODeliveryManager#deliveryPtrs (xulei via ivank)\n \n-  BOOKKEEPER-63: Hedwig PubSubServer must wait for its Zookeeper client to be connected upon startup (mmorel via ivank)\n+        BOOKKEEPER-63: Hedwig PubSubServer must wait for its Zookeeper client to be connected upon startup (mmorel via ivank)\n \n-  BOOKKEEPER-100: Some hedwig tests have build errors (dferro via ivank)\n+        BOOKKEEPER-100: Some hedwig tests have build errors (dferro via ivank)\n \n-  BOOKKEEPER-69: ServerRedirectLoopException when a machine (hosts bookie server & hub server) reboot, which is caused by race condition of topic manager (Sijie, ivank via ivank)\n+        BOOKKEEPER-69: ServerRedirectLoopException when a machine (hosts bookie server & hub server) reboot, which is caused by race condition of topic manager (Sijie, ivank via ivank)\n \n- hedwig-client/\n+      hedwig-client/\n  \n-  BOOKKEEPER-52: Message sequence confuse due to the subscribeMsgQueue@SubscribeResponseHandler (xulei via ivank)\n+        BOOKKEEPER-52: Message sequence confuse due to the subscribeMsgQueue@SubscribeResponseHandler (xulei via ivank)\n \n-  BOOKKEEPER-88: derby doesn't like - in the topic names (breed via ivank)\n+        BOOKKEEPER-88: derby doesn't like - in the topic names (breed via ivank)\n \n-  BOOKKEEPER-71: hedwig c++ client does not build . (ivank)\n+        BOOKKEEPER-71: hedwig c++ client does not build . (ivank)\n \n-  BOOKKEEPER-107: memory leak in HostAddress of hedwig c++ client (Sijie Guo via ivank)\n+        BOOKKEEPER-107: memory leak in HostAddress of hedwig c++ client (Sijie Guo via ivank)\n  \n-  BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n+        BOOKKEEPER-80: subscription msg queue race condition in hedwig c++ client (Sijie Guo via ivank)\n \n-  BOOKKEEPER-87: TestHedwigHub exhausts direct buffer memory with netty 3.2.4.Final (ivank via fpj)  \n+        BOOKKEEPER-87: TestHedwigHub exhausts direct buffer memory with netty 3.2.4.Final (ivank via fpj)  \n \n-  BOOKKEEPER-79: randomly startDelivery/stopDelivery will core dump in c++ hedwig client (Sijie Guo via ivank)\n+        BOOKKEEPER-79: randomly startDelivery/stopDelivery will core dump in c++ hedwig client (Sijie Guo via ivank)\n \n-  BOOKKEEPER-118: Hedwig client doesn't kill and remove old subscription channel after redirection. (Sijie Guo via ivank)\n+        BOOKKEEPER-118: Hedwig client doesn't kill and remove old subscription channel after redirection. (Sijie Guo via ivank)\n \n-  BOOKKEEPER-117: Support multi threads in hedwig cpp client to leverage multi-core hardware (Sijie Guo via ivank)\n+        BOOKKEEPER-117: Support multi threads in hedwig cpp client to leverage multi-core hardware (Sijie Guo via ivank)\n \n-  BOOKKEEPER-53: race condition of outstandingMsgSet@SubscribeResponseHandler (fpj via breed)\n+        BOOKKEEPER-53: race condition of outstandingMsgSet@SubscribeResponseHandler (fpj via breed)\n \n-IMPROVEMENTS:\n+    IMPROVEMENTS:\n \n- BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)\n+      BOOKKEEPER-28: Create useful startup scripts for bookkeeper and hedwig (ivank)\n \n- BOOKKEEPER-26: Indentation is all messed up in the BookKeeper code (ivank via fpj)\n+      BOOKKEEPER-26: Indentation is all messed up in the BookKeeper code (ivank via fpj)\n \n- BOOKKEEPER-41: Generation of packages for distribution (ivank via fpj)\n+      BOOKKEEPER-41: Generation of packages for distribution (ivank via fpj)\n \n- BOOKKEEPER-65: fix dependencies on incompatible versions of netty (mmorel via ivank)\n+      BOOKKEEPER-65: fix dependencies on incompatible versions of netty (mmorel via ivank)\n \n- BOOKKEEPER-102: Make bookkeeper use ZK from temporary repo (ivank)\n+      BOOKKEEPER-102: Make bookkeeper use ZK from temporary repo (ivank)\n \n- BOOKKEEPER-128: pom and script modifications required for generating release packages (ivank)\n+      BOOKKEEPER-128: pom and script modifications required for generating release packages (ivank)\n \n- hedwig-client/\n+      hedwig-client/\n \n-  BOOKKEEPER-44: Reuse publish channel to default server to avoid too many connect requests to default server when lots of producers came in same time (Sijie Guo via breed)\n+        BOOKKEEPER-44: Reuse publish channel to default server to avoid too many connect requests to default server when lots of producers came in same time (Sijie Guo via breed)\n \n-  BOOKKEEPER-109: Add documentation to describe how bookies flushes data (Sijie Guo via fpj)\n+        BOOKKEEPER-109: Add documentation to describe how bookies flushes data (Sijie Guo via fpj)\n \n-  BOOKKEEPER-119: Keys in configuration have inconsistent style (ivank via fpj)\n+        BOOKKEEPER-119: Keys in configuration have inconsistent style (ivank via fpj)\n "},{"sha":"9dad3ecab03eb53d3e1f4f2b3ce9d21d8af3c159","filename":"KEYS","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/KEYS","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/KEYS","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/KEYS?ref=814f0ab6b4d43a35992e995c8abd804326ec633b","patch":"@@ -1,47 +0,0 @@\n-This file contains the PGP keys of various developers.\n-\n-Users: pgp < KEYS\n-       gpg --import KEYS\n-Developers: \n-        pgp -kxa <your name> and append it to this file.\n-        (pgpk -ll <your name> && pgpk -xa <your name>) >> this file.\n-        (gpg --list-sigs <your name>\n-             && gpg --armor --export <your name>) >> this file.\n-\n-pub   2048R/6067EBC2 2011-11-03 [expires: 2014-11-29]\n-uid                  Ivan Kelly <ivank@apache.org>\n-sig 3        6067EBC2 2011-11-30  Ivan Kelly <ivank@apache.org>\n-sub   2048R/B2292F42 2011-11-03 [expires: 2014-11-29]\n-sig          6067EBC2 2011-11-30  Ivan Kelly <ivank@apache.org>\n-\n------BEGIN PGP PUBLIC KEY BLOCK-----\n-Version: GnuPG/MacGPG2 v2.0.17 (Darwin)\n-Comment: GPGTools - http://gpgtools.org\n-\n-mQENBE6y4bEBCADHaQI4UXOaHfjrXOmdhigMD5wMIFAPmxckvk56mojOqdXblQl5\n-Qvpym4YPL8uV/ASCe8W19PxmUJGio5myM9+LYyZNPyR1LaB4M+9up/md5gN7WtqI\n-XopoQLcL19OC7fBAYNmTkMkkR5qIyqofsiP7ypdO8gG3F5Smc6z92/S5IWZ8TvbF\n-Rvz75QZygrNO0I6LZtTwJ2UR5JttPyYsx6mG+YSZ56Tri0BEzgHR+pcnAsd4uxeY\n-al0fKe45UAF/Iu7QDyQrVDaqrLNlgdGrMlhIccnxQGfBHIf1PM9akU8EKs/NQSrF\n-nN1AXg+pIlgpqRE2Bb0RxibiaGd2FfZGRUCVABEBAAG0HUl2YW4gS2VsbHkgPGl2\n-YW5rQGFwYWNoZS5vcmc+iQE+BBMBAgAoAhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIe\n-AQIXgAUCTtYLoQUJBcbEcAAKCRCPvUtpYGfrwtqzB/0VosSarn0zumYoP2b7qGIg\n-BhMdu/JA7KcL6mFDDcFR6Oo8EJxwJZXOwqMrY8Dssdg5dku2P5nXNu3hwvEG0qnB\n-daeXZ3BFUNeyztFETtGHbpbyAB/DpxL0B7e1VsfZrCskWfyiUiiHj0MbUaZpI0jp\n-sevkx6EVjgcVdzcyYG4HDnLJzf0h21b1xSPasBseK+Hxl5Rrcenl6XZ/BYFCKwi5\n-6RIE7HuAb0PWXwUG1Be2V293ZhxI7WN4Qhi+GZOPhHzhr34tH7d6h+9O/abWyoAh\n-ObMF83O47MS2lG9upd6GF15qEaV6lMyrRGpEBMgBuIY91fQ1mD3wWO4UVVJ+Tq/S\n-uQENBE6y4bEBCADCyRCWrKKjof1Cj7XUjwzZWAUvN/lgpitzJ4lfHDBAbZPxtfDi\n-CPoagRqnF1/Z3polZMu1mf/JWwqQH9cyWeUgeTd1wvW/e1irN6FSO855Ua/PerYa\n-8hXau/+kMR0zxU9FWBcF4K9USzJeBY4ie5rsbL1/JZrhQ5VACRcMfOZLaAG35aA7\n-qOeQEGBCrRV8FJzpKA9gTFUtLOMGvEDmhnwx3AjjJpWNqnEjtCe+wPOj/IUSwnxe\n-X2jnpB48noCH3xTZYXXPIRmOx9GDaZDC1EqTK5tkGS3YfK7adGKHyYDy2zzpb4w+\n-5eOsmYwBJPv3vLRG5x2udwUi3h6tsIqxh8P/ABEBAAGJASUEGAECAA8CGwwFAk7W\n-C/MFCQXGxMIACgkQj71LaWBn68JXWQgAhAE7FixrHrwFYK95KU6SFycTQJvlIDaR\n-xuZ6r9+5aw1jtkmfQX/4bGbXmw2YLQzK5FfrJhKKitZp9XBv7wRa1C760oDaQW1T\n-Q0jLUHgHu/6XMVq2HnwM12z+ECO1l+LE6pj7O+MxCCUWB5MwEQQExttSgzLRdjdk\n-+YY3C2LYwrbPn/CHpsMTRZXJUvo3DOP5d6ClHSaBmDJoq56F2EFEVedaUusKy6d0\n-XR/FMqJv5rN8GRi/iPDjZjUP/lOV2n6WSBlo1jrwCJXBcGkq2nucE/dd/BS+MOhz\n-nLwrrqeEtCSCxzJxNxz0z6rWNyX4zik1kJaTfhZQT7yGDHwkxOusGg==\n-=0Vye\n------END PGP PUBLIC KEY BLOCK-----"},{"sha":"d645695673349e3947e8e5ae42332d0ac3164cd7","filename":"LICENSE","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/LICENSE","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/LICENSE","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/LICENSE?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","previous_filename":"LICENSE.txt"},{"sha":"ba13c0384cacab43fe6c1afa9d65cbdf5f59a1ab","filename":"NOTICE","status":"added","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/NOTICE","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/NOTICE","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/NOTICE?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,6 @@\n+Apache BookKeeper\n+Copyright 2011-2012 The Apache Software Foundation\n+\n+This product includes software developed at\n+The Apache Software Foundation (http://www.apache.org/).\n+"},{"sha":"2cbefade9d4b38b410ffdf724e56d68aaed19b9c","filename":"NOTICE.txt","status":"removed","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/NOTICE.txt","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/NOTICE.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/NOTICE.txt?ref=814f0ab6b4d43a35992e995c8abd804326ec633b","patch":"@@ -1,2 +0,0 @@\n-Copyright (c) 2010 Yahoo! Inc.  All rights reserved.\n-"},{"sha":"3158aac140f83444b9bf0698c044a75b78ebaaae","filename":"bookkeeper-benchmark/bin/benchmark","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/bin/benchmark","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/bin/benchmark","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/bin/benchmark?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,131 @@\n+#!/usr/bin/env bash\n+#\n+#/**\n+# * Copyright 2007 The Apache Software Foundation\n+# *\n+# * Licensed to the Apache Software Foundation (ASF) under one\n+# * or more contributor license agreements.  See the NOTICE file\n+# * distributed with this work for additional information\n+# * regarding copyright ownership.  The ASF licenses this file\n+# * to you under the Apache License, Version 2.0 (the\n+# * \"License\"); you may not use this file except in compliance\n+# * with the License.  You may obtain a copy of the License at\n+# *\n+# *     http://www.apache.org/licenses/LICENSE-2.0\n+# *\n+# * Unless required by applicable law or agreed to in writing, software\n+# * distributed under the License is distributed on an \"AS IS\" BASIS,\n+# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# * See the License for the specific language governing permissions and\n+# * limitations under the License.\n+# */\n+\n+# check if net.ipv6.bindv6only is set to 1\n+bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n+if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n+then\n+  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n+  echo \"For more info (the following page also applies to bookkeeper): http://wiki.apache.org/hadoop/HadoopIPv6\"\n+  exit 1\n+fi\n+\n+BINDIR=`dirname \"$0\"`\n+BENCH_HOME=`cd $BINDIR/..;pwd`\n+\n+RELEASE_JAR=`ls $BENCH_HOME/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1` \n+if [ $? == 0 ]; then\n+    BENCHMARK_JAR=$RELEASE_JAR\n+fi\n+\n+BUILT_JAR=`ls $BENCH_HOME/target/bookkeeper-benchmark-*.jar 2> /dev/null | tail -1`\n+if [ $? != 0 ] && [ ! -e \"$BENCHMARK_JAR\" ]; then \n+    echo \"\\nCouldn't find benchmark jar.\";\n+    echo \"Make sure you've run 'mvn package'\\n\";\n+    exit 1;\n+elif [ -e \"$BUILT_JAR\" ]; then\n+    BENCHMARK_JAR=$BUILT_JAR\n+fi\n+\n+benchmark_help() {\n+    cat <<EOF\n+Usage: $0 <command>\n+where command is one of:\n+    writes              Benchmark throughput and latency for writes\n+    reads               Benchmark throughput and latency for reads\n+    bookie              Benchmark an individual bookie\n+    help                This help message\n+\n+use -help with individual commands for more options. For example,\n+   $0 writes -help\n+\n+or command is the full name of a class with a defined main() method.\n+\n+Environment variables:\n+   BENCHMARK_LOG_CONF        Log4j configuration file (default: conf/log4j.properties)\n+   BENCHMARK_EXTRA_OPTS      Extra options to be passed to the jvm\n+   BENCHMARK_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n+\n+EOF\n+}\n+\n+add_maven_deps_to_classpath() {\n+    MVN=\"mvn\"\n+    if [ \"$MAVEN_HOME\" != \"\" ]; then\n+\tMVN=${MAVEN_HOME}/bin/mvn\n+    fi\n+    \n+    # Need to generate classpath from maven pom. This is costly so generate it\n+    # and cache it. Save the file into our target dir so a mvn clean will get\n+    # clean it up and force us create a new one.\n+    f=\"${BENCH_HOME}/target/cached_classpath.txt\"\n+    if [ ! -f \"${f}\" ]\n+    then\n+\t${MVN} -f \"${BENCH_HOME}/pom.xml\" dependency:build-classpath -Dmdep.outputFile=\"${f}\" &> /dev/null\n+    fi\n+    BENCHMARK_CLASSPATH=${CLASSPATH}:`cat \"${f}\"`\n+}\n+\n+if [ -d \"$BENCH_HOME/lib\" ]; then\n+    for i in $BENCH_HOME/lib/*.jar; do\n+\tBENCHMARK_CLASSPATH=$BENCHMARK_CLASSPATH:$i\n+    done\n+else\n+    add_maven_deps_to_classpath\n+fi\n+\n+# if no args specified, show usage\n+if [ $# = 0 ]; then\n+    benchmark_help;\n+    exit 1;\n+fi\n+\n+# get arguments\n+COMMAND=$1\n+shift\n+\n+BENCHMARK_CLASSPATH=\"$BENCHMARK_JAR:$BENCHMARK_CLASSPATH:$BENCHMARK_EXTRA_CLASSPATH\"\n+BENCHMARK_LOG_CONF=${BENCHMARK_LOG_CONF:-$BENCH_HOME/conf/log4j.properties}\n+\n+if [ \"$BENCHMARK_LOG_CONF\" != \"\" ]; then\n+    BENCHMARK_CLASSPATH=\"`dirname $BENCHMARK_LOG_CONF`:$BENCHMARK_CLASSPATH\"\n+    OPTS=\"$OPTS -Dlog4j.configuration=`basename $BENCHMARK_LOG_CONF`\"\n+fi\n+OPTS=\"-cp $BENCHMARK_CLASSPATH $OPTS $BENCHMARK_EXTRA_OPTS\"\n+\n+OPTS=\"$OPTS $BENCHMARK_EXTRA_OPTS\"\n+\n+# Disable ipv6 as it can cause issues\n+OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n+\n+if [ $COMMAND == \"writes\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchThroughputLatency $@\n+elif [ $COMMAND == \"reads\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchReadThroughputLatency $@\n+elif [ $COMMAND == \"bookie\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.benchmark.BenchBookie $@\n+elif [ $COMMAND == \"help\" ]; then\n+    benchmark_help;\n+else\n+    exec java $OPTS $COMMAND $@\n+fi\n+"},{"sha":"79e0db26a66e74fd6f6908e1e27962e34e5d9c04","filename":"bookkeeper-benchmark/conf/log4j.properties","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/conf/log4j.properties?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,73 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+#\n+# Bookkeeper Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=ERROR, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+log4j.logger.org.apache.bookkeeper.benchmark=INFO\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"c4ab7e616ada8631200fabd4c0c41998b7992b6d","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":39,"deletions":11,"changes":50,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -22,7 +22,7 @@\n   <parent>\n     <artifactId>bookkeeper</artifactId>\n     <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.0.0-SNAPSHOT</version>\n+    <version>4.1.0</version>\n   </parent>\n   <groupId>org.apache.bookkeeper</groupId>\n   <artifactId>bookkeeper-benchmark</artifactId>\n@@ -31,6 +31,17 @@\n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n   </properties>\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-assembly-plugin</artifactId>\n+        <version>2.2.1</version>\n+        <configuration>\n+\t  <skipAssembly>true</skipAssembly>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n   <dependencies>\n     <dependency>\n       <groupId>junit</groupId>\n@@ -50,18 +61,30 @@\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n-    \t<groupId>org.apache.zookeeper</groupId>\n-    \t<artifactId>zookeeper</artifactId>\n-    \t<version>3.4.0</version>\n-    \t<type>jar</type>\n-    \t<scope>compile</scope>\n+       <groupId>org.apache.hadoop</groupId>\n+       <artifactId>hadoop-common</artifactId>\n+       <version>0.23.1</version>\n+       <scope>compile</scope>\n     </dependency>\n     <dependency>\n-    \t<groupId>org.apache.zookeeper</groupId>\n-    \t<artifactId>zookeeper-test</artifactId>\n-    \t<version>3.4.0</version>\n-    \t<type>jar</type>\n-    \t<scope>compile</scope>\n+       <groupId>org.apache.hadoop</groupId>\n+       <artifactId>hadoop-hdfs</artifactId>\n+       <version>0.23.1</version>\n+       <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.zookeeper</groupId>\n+      <artifactId>zookeeper</artifactId>\n+      <version>3.4.3</version>\n+      <type>jar</type>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.zookeeper</groupId>\n+      <artifactId>zookeeper</artifactId>\n+      <version>3.4.3</version>\n+      <type>test-jar</type>\n+      <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.jboss.netty</groupId>\n@@ -106,5 +129,10 @@\n \t</exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>commons-cli</groupId>\n+      <artifactId>commons-cli</artifactId>\n+      <version>1.2</version>\n+    </dependency>\n   </dependencies>\n </project>"},{"sha":"0831c0a653ef1e62752b4832a60c2ec0e04ee089","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"added","additions":215,"deletions":0,"changes":215,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.Executors;\n+\n+import java.io.IOException;\n+\n+import org.apache.zookeeper.KeeperException;\n+\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.jboss.netty.buffer.ChannelBuffers;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BenchBookie {\n+    static Logger LOG = LoggerFactory.getLogger(BenchBookie.class);\n+\n+    static class LatencyCallback implements WriteCallback {\n+        boolean complete;\n+        @Override\n+        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n+                InetSocketAddress addr, Object ctx) {\n+            if (rc != 0) {\n+                LOG.error(\"Got error \" + rc);\n+            }\n+            complete = true;\n+            notifyAll();\n+        }\n+        synchronized public void resetComplete() {\n+            complete = false;\n+        }\n+        synchronized public void waitForComplete() throws InterruptedException {\n+            while(!complete) {\n+                wait();\n+            }\n+        }\n+    }\n+\n+    static class ThroughputCallback implements WriteCallback {\n+        int count;\n+        int waitingCount = Integer.MAX_VALUE;\n+        synchronized public void writeComplete(int rc, long ledgerId, long entryId,\n+                InetSocketAddress addr, Object ctx) {\n+            if (rc != 0) {\n+                LOG.error(\"Got error \" + rc);\n+            }\n+            count++;\n+            if (count >= waitingCount) {\n+                notifyAll();\n+            }\n+        }\n+        synchronized public void waitFor(int count) throws InterruptedException {\n+            while(this.count < count) {\n+                waitingCount = count;\n+                wait(1000);\n+            }\n+            waitingCount = Integer.MAX_VALUE;\n+        }\n+    }\n+\n+    private static long getValidLedgerId(String zkServers)\n+            throws IOException, BKException, KeeperException, InterruptedException {\n+        BookKeeper bkc = null;\n+        LedgerHandle lh = null;\n+        long id = 0;\n+        try {\n+            bkc =new BookKeeper(zkServers);\n+            lh = bkc.createLedger(1, 1, BookKeeper.DigestType.CRC32,\n+                                  new byte[20]);\n+            id = lh.getId();\n+            return id;\n+        } finally {\n+            if (lh != null) { lh.close(); }\n+            if (bkc != null) { bkc.close(); }\n+        }\n+    }\n+    /**\n+     * @param args\n+     * @throws InterruptedException\n+     */\n+    public static void main(String[] args)\n+            throws InterruptedException, ParseException, IOException,\n+            BKException, KeeperException {\n+        Options options = new Options();\n+        options.addOption(\"host\", true, \"Hostname or IP of bookie to benchmark\");\n+        options.addOption(\"port\", true, \"Port of bookie to benchmark (default 3181)\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, (default \\\"localhost:2181\\\")\");\n+        options.addOption(\"size\", true, \"Size of message to send, in bytes (default 1024)\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\") || !cmd.hasOption(\"host\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"BenchBookie <options>\", options);\n+            System.exit(-1);\n+        }\n+\n+        String addr = cmd.getOptionValue(\"host\");\n+        int port = Integer.valueOf(cmd.getOptionValue(\"port\", \"3181\"));\n+        int size = Integer.valueOf(cmd.getOptionValue(\"size\", \"1024\"));\n+        String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n+\n+\n+\n+        ClientSocketChannelFactory channelFactory\n+            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                                                .newCachedThreadPool());\n+        OrderedSafeExecutor executor = new OrderedSafeExecutor(1);\n+\n+        ClientConfiguration conf = new ClientConfiguration();\n+        BookieClient bc = new BookieClient(conf, channelFactory, executor);\n+        LatencyCallback lc = new LatencyCallback();\n+\n+        ThroughputCallback tc = new ThroughputCallback();\n+        int warmUpCount = 999;\n+\n+        long ledger = getValidLedgerId(servers);\n+        for(long entry = 0; entry < warmUpCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n+        }\n+        LOG.info(\"Waiting for warmup\");\n+        tc.waitFor(warmUpCount);\n+\n+        ledger = getValidLedgerId(servers);\n+        LOG.info(\"Benchmarking latency\");\n+        int entryCount = 5000;\n+        long startTime = System.nanoTime();\n+        for(long entry = 0; entry < entryCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            lc.resetComplete();\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+                        entry, toSend, lc, null, BookieProtocol.FLAG_NONE);\n+            lc.waitForComplete();\n+        }\n+        long endTime = System.nanoTime();\n+        LOG.info(\"Latency: \" + (((double)(endTime-startTime))/((double)entryCount))/1000000.0);\n+\n+        entryCount = 50000;\n+\n+        ledger = getValidLedgerId(servers);\n+        LOG.info(\"Benchmarking throughput\");\n+        startTime = System.currentTimeMillis();\n+        tc = new ThroughputCallback();\n+        for(long entry = 0; entry < entryCount; entry++) {\n+            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            toSend.resetReaderIndex();\n+            toSend.resetWriterIndex();\n+            toSend.writeLong(ledger);\n+            toSend.writeLong(entry);\n+            toSend.writerIndex(toSend.capacity());\n+            bc.addEntry(new InetSocketAddress(addr, port), ledger, new byte[20],\n+                        entry, toSend, tc, null, BookieProtocol.FLAG_NONE);\n+        }\n+        tc.waitFor(entryCount);\n+        endTime = System.currentTimeMillis();\n+        LOG.info(\"Throughput: \" + ((long)entryCount)*1000/(endTime-startTime));\n+\n+        bc.close();\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+\n+}"},{"sha":"846b7c12b3aa6626268e1f636c8bd198a296cb8e","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","status":"added","additions":271,"deletions":0,"changes":271,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher.Event;\n+\n+import java.util.Enumeration;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BenchReadThroughputLatency {\n+    static Logger LOG = LoggerFactory.getLogger(BenchReadThroughputLatency.class);\n+\n+    private static final Pattern LEDGER_PATTERN = Pattern.compile(\"L([0-9]+)$\");\n+\n+    private static final Comparator<String> ZK_LEDGER_COMPARE = new Comparator<String>() {\n+        public int compare(String o1, String o2) {\n+            try {\n+                Matcher m1 = LEDGER_PATTERN.matcher(o1);\n+                Matcher m2 = LEDGER_PATTERN.matcher(o2);\n+                if (m1.find() && m2.find()) {\n+                    return Integer.valueOf(m1.group(1))\n+                        - Integer.valueOf(m2.group(1));\n+                } else {\n+                    return o1.compareTo(o2);\n+                }\n+            } catch (Throwable t) {\n+                return o1.compareTo(o2);\n+            }\n+        }\n+    };\n+\n+    private static void readLedger(ClientConfiguration conf, long ledgerId, byte[] passwd) {\n+        LOG.info(\"Reading ledger {}\", ledgerId);\n+        BookKeeper bk = null;\n+        long time = 0;\n+        long entriesRead = 0;\n+        long lastRead = 0;\n+        int nochange = 0;\n+\n+        long absoluteLimit = 5000000;\n+        LedgerHandle lh = null;\n+        try {\n+            bk = new BookKeeper(conf);\n+            while (true) {\n+                lh = bk.openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, \n+                                             passwd);\n+                long lastConfirmed = Math.min(lh.getLastAddConfirmed(), absoluteLimit);\n+                if (lastConfirmed == lastRead) {\n+                    nochange++;\n+                    if (nochange == 10) {\n+                        break;\n+                    } else {\n+                        Thread.sleep(1000);\n+                        continue;\n+                    }\n+                } else {\n+                    nochange = 0;\n+                }\n+                long starttime = System.nanoTime();\n+\n+                while (lastRead < lastConfirmed) {\n+                    long nextLimit = lastRead + 100000;\n+                    long readTo = Math.min(nextLimit, lastConfirmed);\n+                    Enumeration<LedgerEntry> entries = lh.readEntries(lastRead+1, readTo);\n+                    lastRead = readTo;\n+                    while (entries.hasMoreElements()) {\n+                        LedgerEntry e = entries.nextElement();\n+                        entriesRead++;\n+                        if ((entriesRead % 10000) == 0) {\n+                            LOG.info(\"{} entries read\", entriesRead);\n+                        }\n+                    }\n+                }\n+                long endtime = System.nanoTime();\n+                time += endtime - starttime;\n+\n+                lh.close();\n+                lh = null;\n+                Thread.sleep(1000);\n+            }\n+        } catch (InterruptedException ie) {\n+            // ignore\n+        } catch (Exception e ) {\n+            LOG.error(\"Exception in reader\", e);\n+        } finally {\n+            LOG.info(\"Read {} in {}ms\", entriesRead, time/1000/1000);\n+\n+            try {\n+                if (lh != null) {\n+                    lh.close();\n+                }\n+                if (bk != null) {\n+                    bk.close();\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Exception closing stuff\", e);\n+            }\n+        }\n+    }\n+\n+    private static void usage(Options options) {\n+        HelpFormatter formatter = new HelpFormatter();\n+        formatter.printHelp(\"BenchReadThroughputLatency <options>\", options);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Options options = new Options();\n+        options.addOption(\"ledger\", true, \"Ledger to read. If empty, read all ledgers which come available. \" \n+                          + \" Cannot be used with -listen\");\n+        options.addOption(\"listen\", true, \"Listen for creation of <arg> ledgers, and read each one fully\");\n+        options.addOption(\"password\", true, \"Password used to access ledgers (default 'benchPasswd')\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\")) {\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n+        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n+        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n+        if (cmd.hasOption(\"ledger\") && cmd.hasOption(\"listen\")) {\n+            LOG.error(\"Cannot used -ledger and -listen together\");\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final AtomicInteger ledger = new AtomicInteger(0);\n+        final AtomicInteger numLedgers = new AtomicInteger(0);\n+        if (cmd.hasOption(\"ledger\")) {\n+            ledger.set(Integer.valueOf(cmd.getOptionValue(\"ledger\")));\n+        } else if (cmd.hasOption(\"listen\")) {\n+            numLedgers.set(Integer.valueOf(cmd.getOptionValue(\"listen\")));\n+        } else {\n+            LOG.error(\"You must use -ledger or -listen\");\n+            usage(options);\n+            System.exit(-1);\n+        }\n+\n+        final CountDownLatch shutdownLatch = new CountDownLatch(1);\n+        final CountDownLatch connectedLatch = new CountDownLatch(1);\n+        final String nodepath = String.format(\"/ledgers/L%010d\", ledger.get());\n+\n+        final ClientConfiguration conf = new ClientConfiguration();\n+        conf.setReadTimeout(sockTimeout).setZkServers(servers);\n+\n+\n+        final ZooKeeper zk = new ZooKeeper(servers, 3000, new Watcher() {\n+                public void process(WatchedEvent event) {\n+                    if (event.getState() == Event.KeeperState.SyncConnected\n+                            && event.getType() == Event.EventType.None) {\n+                        connectedLatch.countDown();\n+                    }\n+                }\n+            });\n+        try {\n+            zk.register(new Watcher() {\n+                    public void process(WatchedEvent event) {\n+                        try {\n+                            if (event.getState() == Event.KeeperState.SyncConnected \n+                                && event.getType() == Event.EventType.None) {\n+                                connectedLatch.countDown();\n+                            } else if (event.getType() == Event.EventType.NodeCreated\n+                                       && event.getPath().equals(nodepath)) {\n+                                readLedger(conf, ledger.get(), passwd);\n+                                shutdownLatch.countDown();\n+                            } else if (event.getType() == Event.EventType.NodeChildrenChanged) {\n+                                if (numLedgers.get() < 0) {\n+                                    return;\n+                                }\n+                                List<String> children = zk.getChildren(\"/ledgers\", true);\n+                                List<String> ledgers = new ArrayList<String>();\n+                                for (String child : children) {\n+                                    if (LEDGER_PATTERN.matcher(child).find()) {\n+                                        ledgers.add(child);\n+                                    }\n+                                }\n+                                Collections.sort(ledgers, ZK_LEDGER_COMPARE);\n+                                String last = ledgers.get(ledgers.size() - 1);\n+                                final Matcher m = LEDGER_PATTERN.matcher(last);\n+                                if (m.find()) {\n+                                    int ledgersLeft = numLedgers.decrementAndGet();\n+                                    Thread t = new Thread() {\n+                                            public void run() {\n+                                                readLedger(conf, Long.valueOf(m.group(1)), passwd);\n+                                            }\n+                                        };\n+                                    t.start();\n+                                    if (ledgersLeft <= 0) {\n+                                        shutdownLatch.countDown();\n+                                    }\n+                                } else {\n+                                    LOG.error(\"Cant file ledger id in {}\", last);\n+                                }\n+                            } else {\n+                                LOG.warn(\"Unknown event {}\", event);\n+                            }\n+                        } catch (Exception e) {\n+                            LOG.error(\"Exception in watcher\", e);\n+                        }\n+                    }\n+                });\n+            connectedLatch.await();\n+            if (ledger.get() != 0) {\n+                if (zk.exists(nodepath, true) != null) {\n+                    readLedger(conf, ledger.get(), passwd);\n+                    shutdownLatch.countDown();\n+                } else {\n+                    LOG.info(\"Watching for creation of\" + nodepath);\n+                }\n+            } else {\n+                zk.getChildren(\"/ledgers\", true);\n+            }\n+            shutdownLatch.await();\n+            LOG.info(\"Shutting down\");\n+        } finally {\n+            zk.close();\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"59cc32ea590fcb4fd57f4be195b83c3db76bbcb7","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","status":"added","additions":447,"deletions":0,"changes":447,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,447 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BenchThroughputLatency implements AddCallback, Runnable {\n+    static Logger LOG = LoggerFactory.getLogger(BenchThroughputLatency.class);\n+\n+    BookKeeper bk;\n+    LedgerHandle lh[];\n+    AtomicLong counter;\n+\n+    Semaphore sem;\n+    int numberOfLedgers = 1;\n+    final int sendLimit;\n+    final long latencies[];\n+\n+    static class Context {\n+        long localStartTime;\n+        long id;\n+\n+        Context(long id, long time){\n+            this.id = id;\n+            this.localStartTime = time;\n+        }\n+    }\n+\n+    public BenchThroughputLatency(int ensemble, int qSize, byte[] passwd,\n+            int numberOfLedgers, int sendLimit, ClientConfiguration conf)\n+            throws KeeperException, IOException, InterruptedException {\n+        this.sem = new Semaphore(conf.getThrottleValue());\n+        bk = new BookKeeper(conf);\n+        this.counter = new AtomicLong(0);\n+        this.numberOfLedgers = numberOfLedgers;\n+        this.sendLimit = sendLimit;\n+        this.latencies = new long[sendLimit];\n+        try{\n+            lh = new LedgerHandle[this.numberOfLedgers];\n+\n+            for(int i = 0; i < this.numberOfLedgers; i++) {\n+                lh[i] = bk.createLedger(ensemble, qSize, BookKeeper.DigestType.CRC32,\n+                                        passwd);\n+                LOG.info(\"Ledger Handle: \" + lh[i].getId());\n+            }\n+        } catch (BKException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    Random rand = new Random();\n+    public void close() throws InterruptedException, BKException {\n+        for(int i = 0; i < numberOfLedgers; i++) {\n+            lh[i].close();\n+        }\n+        bk.close();\n+    }\n+\n+    long previous = 0;\n+    byte bytes[];\n+\n+    void setEntryData(byte data[]) {\n+        bytes = data;\n+    }\n+\n+    int lastLedger = 0;\n+    private int getRandomLedger() {\n+         return rand.nextInt(numberOfLedgers);\n+    }\n+\n+    int latencyIndex = -1;\n+    AtomicLong completedRequests = new AtomicLong(0);\n+\n+    long duration = -1;\n+    synchronized public long getDuration() {\n+        return duration;\n+    }\n+\n+    public void run() {\n+        LOG.info(\"Running...\");\n+        long start = previous = System.currentTimeMillis();\n+\n+        int sent = 0;\n+\n+        Thread reporter = new Thread() {\n+                public void run() {\n+                    try {\n+                        while(true) {\n+                            Thread.sleep(1000);\n+                            LOG.info(\"ms: {} req: {}\", System.currentTimeMillis(), completedRequests.getAndSet(0));\n+                        }\n+                    } catch (InterruptedException ie) {\n+                        LOG.info(\"Caught interrupted exception, going away\");\n+                    }\n+                }\n+            };\n+        reporter.start();\n+        long beforeSend = System.nanoTime();\n+\n+        while(!Thread.currentThread().isInterrupted() && sent < sendLimit) {\n+            try {\n+                sem.acquire();\n+                if (sent == 10000) {\n+                    long afterSend = System.nanoTime();\n+                    long time = afterSend - beforeSend;\n+                    LOG.info(\"Time to send first batch: {}s {}ns \",\n+                             time/1000/1000/1000, time);\n+                }\n+            } catch (InterruptedException e) {\n+                break;\n+            }\n+\n+            final int index = getRandomLedger();\n+            LedgerHandle h = lh[index];\n+            if (h == null) {\n+                LOG.error(\"Handle \" + index + \" is null!\");\n+            } else {\n+                long nanoTime = System.nanoTime();\n+                lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));\n+                counter.incrementAndGet();\n+            }\n+            sent++;\n+        }\n+        LOG.info(\"Sent: \"  + sent);\n+        try {\n+            int i = 0;\n+            while(this.counter.get() > 0) {\n+                Thread.sleep(1000);\n+                i++;\n+                if (i > 30) {\n+                    break;\n+                }\n+            }\n+        } catch(InterruptedException e) {\n+            LOG.error(\"Interrupted while waiting\", e);\n+        }\n+        synchronized(this) {\n+            duration = System.currentTimeMillis() - start;\n+        }\n+        throughput = sent*1000/getDuration();\n+\n+        reporter.interrupt();\n+        try {\n+            reporter.join();\n+        } catch (InterruptedException ie) {\n+            // ignore\n+        }\n+        LOG.info(\"Finished processing in ms: \" + getDuration() + \" tp = \" + throughput);\n+    }\n+\n+    long throughput = -1;\n+    public long getThroughput() {\n+        return throughput;\n+    }\n+\n+    long threshold = 20000;\n+    long runningAverageCounter = 0;\n+    long totalTime = 0;\n+    @Override\n+    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+        Context context = (Context) ctx;\n+\n+        // we need to use the id passed in the context in the case of\n+        // multiple ledgers, and it works even with one ledger\n+        entryId = context.id;\n+        long newTime = System.nanoTime() - context.localStartTime;\n+\n+        sem.release();\n+        counter.decrementAndGet();\n+\n+        if (rc == 0) {\n+            latencies[(int)entryId] = newTime;\n+            completedRequests.incrementAndGet();\n+        }\n+    }\n+\n+    public static void main(String[] args)\n+            throws KeeperException, IOException, InterruptedException, ParseException, BKException {\n+        Options options = new Options();\n+        options.addOption(\"time\", true, \"Running time (seconds), default 60\");\n+        options.addOption(\"entrysize\", true, \"Entry size (bytes), default 1024\");\n+        options.addOption(\"ensemble\", true, \"Ensemble size, default 3\");\n+        options.addOption(\"quorum\", true, \"Quorum size, default 2\");\n+        options.addOption(\"throttle\", true, \"Max outstanding requests, default 10000\");\n+        options.addOption(\"ledgers\", true, \"Number of ledgers, default 1\");\n+        options.addOption(\"zookeeper\", true, \"Zookeeper ensemble, default \\\"localhost:2181\\\"\");\n+        options.addOption(\"password\", true, \"Password used to create ledgers (default 'benchPasswd')\");\n+        options.addOption(\"coordnode\", true, \"Coordination znode for multi client benchmarks (optional)\");\n+        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n+        options.addOption(\"sockettimeout\", true, \"Socket timeout for bookkeeper client. In seconds. Default 5\");\n+        options.addOption(\"skipwarmup\", false, \"Skip warm up, default false\");\n+        options.addOption(\"sendlimit\", true, \"Max number of entries to send. Default 20000000\");\n+        options.addOption(\"help\", false, \"This message\");\n+\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n+\n+        if (cmd.hasOption(\"help\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"BenchThroughputLatency <options>\", options);\n+            System.exit(-1);\n+        }\n+\n+        long runningTime = Long.valueOf(cmd.getOptionValue(\"time\", \"60\"));\n+        String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n+        int entrysize = Integer.valueOf(cmd.getOptionValue(\"entrysize\", \"1024\"));\n+\n+        int ledgers = Integer.valueOf(cmd.getOptionValue(\"ledgers\", \"1\"));\n+        int ensemble = Integer.valueOf(cmd.getOptionValue(\"ensemble\", \"3\"));\n+        int quorum = Integer.valueOf(cmd.getOptionValue(\"quorum\", \"2\"));\n+        int throttle = Integer.valueOf(cmd.getOptionValue(\"throttle\", \"10000\"));\n+        int sendLimit = Integer.valueOf(cmd.getOptionValue(\"sendlimit\", \"20000000\"));\n+\n+        final int sockTimeout = Integer.valueOf(cmd.getOptionValue(\"sockettimeout\", \"5\"));\n+\n+        String coordinationZnode = cmd.getOptionValue(\"coordnode\");\n+        final byte[] passwd = cmd.getOptionValue(\"password\", \"benchPasswd\").getBytes();\n+\n+        Timer timeouter = new Timer();\n+        if (cmd.hasOption(\"timeout\")) {\n+            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n+\n+            timeouter.schedule(new TimerTask() {\n+                    public void run() {\n+                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n+                        System.exit(-1);\n+                    }\n+                }, timeout);\n+        }\n+\n+        LOG.warn(\"(Parameters received) running time: \" + runningTime +\n+                \", entry size: \" + entrysize + \", ensemble size: \" + ensemble +\n+                \", quorum size: \" + quorum +\n+                \", throttle: \" + throttle +\n+                \", number of ledgers: \" + ledgers +\n+                \", zk servers: \" + servers);\n+\n+        long totalTime = runningTime*1000;\n+\n+        // Do a warmup run\n+        Thread thread;\n+\n+        byte data[] = new byte[entrysize];\n+        Arrays.fill(data, (byte)'x');\n+\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setThrottleValue(throttle).setReadTimeout(sockTimeout).setZkServers(servers);\n+\n+        if (!cmd.hasOption(\"skipwarmup\")) {\n+            long throughput;\n+            LOG.info(\"Starting warmup\");\n+\n+            throughput = warmUp(data, ledgers, ensemble, quorum, passwd, conf);\n+            LOG.info(\"Warmup tp: \" + throughput);\n+            LOG.info(\"Warmup phase finished\");\n+        }\n+\n+\n+        // Now do the benchmark\n+        BenchThroughputLatency bench = new BenchThroughputLatency(ensemble, quorum, passwd,\n+                                                                  ledgers, sendLimit, conf);\n+        bench.setEntryData(data);\n+        thread = new Thread(bench);\n+        ZooKeeper zk = null;\n+\n+        if (coordinationZnode != null) {\n+            final CountDownLatch connectLatch = new CountDownLatch(1);\n+            zk = new ZooKeeper(servers, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n+                zk.close();\n+                System.exit(-1);\n+            }\n+\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            LOG.info(\"Waiting for \" + coordinationZnode);\n+            if (zk.exists(coordinationZnode, new Watcher() {\n+                @Override\n+                public void process(WatchedEvent event) {\n+                    if (event.getType() == EventType.NodeCreated) {\n+                        latch.countDown();\n+                    }\n+                }}) != null) {\n+                latch.countDown();\n+            }\n+            latch.await();\n+            LOG.info(\"Coordination znode created\");\n+        }\n+        thread.start();\n+        Thread.sleep(totalTime);\n+        thread.interrupt();\n+        thread.join();\n+\n+        LOG.info(\"Calculating percentiles\");\n+\n+        int numlat = 0;\n+        for(int i = 0; i < bench.latencies.length; i++) {\n+            if (bench.latencies[i] > 0) {\n+                numlat++;\n+            }\n+        }\n+        int numcompletions = numlat;\n+        numlat = Math.min(bench.sendLimit, numlat);\n+        long[] latency = new long[numlat];\n+        int j =0;\n+        for(int i = 0; i < bench.latencies.length && j < numlat; i++) {\n+            if (bench.latencies[i] > 0) {\n+                latency[j++] = bench.latencies[i];\n+            }\n+        }\n+        Arrays.sort(latency);\n+\n+        long tp = (long)((double)(numcompletions*1000.0)/(double)bench.getDuration());\n+\n+        LOG.info(numcompletions + \" completions in \" + bench.getDuration() + \" seconds: \" + tp + \" ops/sec\");\n+\n+        if (zk != null) {\n+            zk.create(coordinationZnode + \"/worker-\",\n+                      (\"tp \" + tp + \" duration \" + bench.getDuration()).getBytes(),\n+                      ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);\n+            zk.close();\n+        }\n+\n+        // dump the latencies for later debugging (it will be sorted by entryid)\n+        OutputStream fos = new BufferedOutputStream(new FileOutputStream(\"latencyDump.dat\"));\n+\n+        for(Long l: latency) {\n+            fos.write((Long.toString(l)+\"\\t\"+(l/1000000)+ \"ms\\n\").getBytes());\n+        }\n+        fos.flush();\n+        fos.close();\n+\n+        // now get the latencies\n+        LOG.info(\"99th percentile latency: {}\", percentile(latency, 99));\n+        LOG.info(\"95th percentile latency: {}\", percentile(latency, 95));\n+\n+        bench.close();\n+        timeouter.cancel();\n+    }\n+\n+    private static double percentile(long[] latency, int percentile) {\n+        int size = latency.length;\n+        int sampleSize = (size * percentile) / 100;\n+        long total = 0;\n+        int count = 0;\n+        for(int i = 0; i < sampleSize; i++) {\n+            total += latency[i];\n+            count++;\n+        }\n+        return ((double)total/(double)count)/1000000.0;\n+    }\n+\n+    private static long warmUp(byte[] data, int ledgers, int ensemble, int qSize,\n+                               byte[] passwd, ClientConfiguration conf)\n+            throws KeeperException, IOException, InterruptedException, BKException {\n+        final CountDownLatch connectLatch = new CountDownLatch(1);\n+        final int bookies;\n+        String bookieRegistrationPath = conf.getZkAvailableBookiesPath();\n+        ZooKeeper zk = null;\n+        try {\n+            final String servers = conf.getZkServers();\n+            zk = new ZooKeeper(servers, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + servers);\n+                throw new IOException(\"Couldn't connect to zookeeper \" + servers);\n+            }\n+            bookies = zk.getChildren(bookieRegistrationPath, false).size();\n+        } finally {\n+            if (zk != null) {\n+                zk.close();\n+            }\n+        }\n+\n+        BenchThroughputLatency warmup = new BenchThroughputLatency(bookies, bookies, passwd,\n+                ledgers, 50000, conf);\n+        warmup.setEntryData(data);\n+        Thread thread = new Thread(warmup);\n+        thread.start();\n+        thread.join();\n+        warmup.close();\n+        return warmup.getThroughput();\n+    }\n+}"},{"sha":"34d683c7841a3ffd6eda757e4107997478af7c9e","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","status":"modified","additions":283,"deletions":159,"changes":442,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/TestClient.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -1,4 +1,3 @@\n-package org.apache.bookkeeper.benchmark;\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -19,17 +18,32 @@\n  * under the License.\n  *\n  */\n-\n+package org.apache.bookkeeper.benchmark;\n \n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import java.util.concurrent.Future;;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -39,206 +53,316 @@\n \n import org.apache.zookeeper.KeeperException;\n \n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.Path;\n+\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.cli.ParseException;\n+\n+\n /**\n  * This is a simple test program to compare the performance of writing to\n  * BookKeeper and to the local file system.\n  *\n  */\n \n-public class TestClient\n-    implements AddCallback, ReadCallback {\n+public class TestClient {\n     private static final Logger LOG = LoggerFactory.getLogger(TestClient.class);\n \n-    BookKeeper x;\n-    LedgerHandle lh;\n-    Integer entryId;\n-    HashMap<Integer, Integer> map;\n+    /**\n+     * First says if entries should be written to BookKeeper (0) or to the local\n+     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n+     * Third parameter is the number of writes.\n+     *\n+     * @param args\n+     */\n+    public static void main(String[] args) throws ParseException {\n+        Options options = new Options();\n+        options.addOption(\"length\", true, \"Length of packets being written. Default 1024\");\n+        options.addOption(\"target\", true, \"Target medium to write to. Options are bk, fs & hdfs. Default fs\");\n+        options.addOption(\"runfor\", true, \"Number of seconds to run for. Default 60\");\n+        options.addOption(\"path\", true, \"Path to write to. fs & hdfs only. Default /foobar\");\n+        options.addOption(\"zkservers\", true, \"ZooKeeper servers, comma separated. bk only. Default localhost:2181.\");\n+        options.addOption(\"bkensemble\", true, \"BookKeeper ledger ensemble size. bk only. Default 3\");\n+        options.addOption(\"bkquorum\", true, \"BookKeeper ledger quorum size. bk only. Default 2\");\n+        options.addOption(\"bkthrottle\", true, \"BookKeeper throttle size. bk only. Default 10000\");\n+        options.addOption(\"sync\", false, \"Use synchronous writes with BookKeeper. bk only.\");\n+        options.addOption(\"numconcurrent\", true, \"Number of concurrently clients. Default 1\");\n+        options.addOption(\"timeout\", true, \"Number of seconds after which to give up\");\n+        options.addOption(\"help\", false, \"This message\");\n \n-    FileOutputStream fStream;\n-    FileOutputStream fStreamLocal;\n-    long start, lastId;\n+        CommandLineParser parser = new PosixParser();\n+        CommandLine cmd = parser.parse(options, args);\n \n-    public TestClient() {\n-        entryId = 0;\n-        map = new HashMap<Integer, Integer>();\n-    }\n+        if (cmd.hasOption(\"help\")) {\n+            HelpFormatter formatter = new HelpFormatter();\n+            formatter.printHelp(\"TestClient <options>\", options);\n+            System.exit(-1);\n+        }\n \n-    public TestClient(String servers) throws KeeperException, IOException, InterruptedException {\n-        this();\n-        x = new BookKeeper(servers);\n-        try {\n-            lh = x.createLedger(DigestType.MAC, new byte[] {'a', 'b'});\n-        } catch (BKException e) {\n-            LOG.error(e.toString());\n+        int length = Integer.valueOf(cmd.getOptionValue(\"length\", \"1024\"));\n+        String target = cmd.getOptionValue(\"target\", \"fs\");\n+        long runfor = Long.valueOf(cmd.getOptionValue(\"runfor\", \"60\")) * 1000;\n+\n+        StringBuilder sb = new StringBuilder();\n+        while(length-- > 0) {\n+            sb.append('a');\n         }\n-    }\n \n-    public TestClient(String servers, int ensSize, int qSize)\n-            throws KeeperException, IOException, InterruptedException {\n-        this();\n-        x = new BookKeeper(servers);\n-        try {\n-            lh = x.createLedger(ensSize, qSize, DigestType.MAC, new byte[] {'a', 'b'});\n-        } catch (BKException e) {\n-            LOG.error(e.toString());\n+        Timer timeouter = new Timer();\n+        if (cmd.hasOption(\"timeout\")) {\n+            final long timeout = Long.valueOf(cmd.getOptionValue(\"timeout\", \"360\")) * 1000;\n+\n+            timeouter.schedule(new TimerTask() {\n+                    public void run() {\n+                        System.err.println(\"Timing out benchmark after \" + timeout + \"ms\");\n+                        System.exit(-1);\n+                    }\n+                }, timeout);\n         }\n-    }\n \n-    public TestClient(FileOutputStream fStream)\n-            throws FileNotFoundException {\n-        this.fStream = fStream;\n-        this.fStreamLocal = new FileOutputStream(\"./local.log\");\n-    }\n+        BookKeeper bkc = null;\n+        try {\n+            int numFiles = Integer.valueOf(cmd.getOptionValue(\"numconcurrent\", \"1\"));\n+            int numThreads = Math.min(numFiles, 1000);\n+            byte[] data = sb.toString().getBytes();\n+            long runid = System.currentTimeMillis();\n+            List<Callable<Long>> clients = new ArrayList<Callable<Long>>();\n \n+            if (target.equals(\"bk\")) {\n+                String zkservers = cmd.getOptionValue(\"zkservers\", \"localhost:2181\");\n+                int bkensemble = Integer.valueOf(cmd.getOptionValue(\"bkensemble\", \"3\"));\n+                int bkquorum = Integer.valueOf(cmd.getOptionValue(\"bkquorum\", \"2\"));\n+                int bkthrottle = Integer.valueOf(cmd.getOptionValue(\"bkthrottle\", \"10000\"));\n \n-    public Integer getFreshEntryId(int val) {\n-        ++this.entryId;\n-        synchronized (map) {\n-            map.put(this.entryId, val);\n-        }\n-        return this.entryId;\n-    }\n+                ClientConfiguration conf = new ClientConfiguration();\n+                conf.setThrottleValue(bkthrottle);\n+                conf.setZkServers(zkservers);\n \n-    public boolean removeEntryId(Integer id) {\n-        boolean retVal = false;\n-        synchronized (map) {\n-            map.remove(id);\n-            retVal = true;\n+                bkc = new BookKeeper(conf);\n+                List<LedgerHandle> handles = new ArrayList<LedgerHandle>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    handles.add(bkc.createLedger(bkensemble, bkquorum, DigestType.CRC32, new byte[] {'a', 'b'}));\n+                }\n+                for (int i = 0; i < numFiles; i++) {\n+                    clients.add(new BKClient(handles, data, runfor, cmd.hasOption(\"sync\")));\n+                }\n+            } else if (target.equals(\"hdfs\")) {\n+                FileSystem fs = FileSystem.get(new Configuration());\n+                LOG.info(\"Default replication for HDFS: {}\", fs.getDefaultReplication());\n \n-            if(map.size() == 0) map.notifyAll();\n-            else {\n-                if(map.size() < 4)\n-                    LOG.error(map.toString());\n+                List<FSDataOutputStream> streams = new ArrayList<FSDataOutputStream>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    String path = cmd.getOptionValue(\"path\", \"/foobar\");\n+                    streams.add(fs.create(new Path(path + runid + \"_\" + i)));\n+                }\n+\n+                for (int i = 0; i < numThreads; i++) {\n+                    clients.add(new HDFSClient(streams, data, runfor));\n+                }\n+            } else if (target.equals(\"fs\")) {\n+                List<FileOutputStream> streams = new ArrayList<FileOutputStream>();\n+                for (int i = 0; i < numFiles; i++) {\n+                    String path = cmd.getOptionValue(\"path\", \"/foobar \" + i);\n+                    streams.add(new FileOutputStream(path + runid + \"_\" + i));\n+                }\n+\n+                for (int i = 0; i < numThreads; i++) {\n+                    clients.add(new FileClient(streams, data, runfor));\n+                }\n+            } else {\n+                LOG.error(\"Unknown option: \" + target);\n+                throw new IllegalArgumentException(\"Unknown target \" + target);\n+            }\n+\n+            ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n+            long start = System.currentTimeMillis();\n+\n+            List<Future<Long>> results = executor.invokeAll(clients,\n+                                                            10, TimeUnit.MINUTES);\n+            long end = System.currentTimeMillis();\n+            long count = 0;\n+            for (Future<Long> r : results) {\n+                if (!r.isDone()) {\n+                    LOG.warn(\"Job didn't complete\");\n+                    System.exit(2);\n+                }\n+                long c = r.get();\n+                if (c == 0) {\n+                    LOG.warn(\"Task didn't complete\");\n+                }\n+                count += c;\n+            }\n+            long time = end-start;\n+            LOG.info(\"Finished processing writes (ms): {} TPT: {} op/s\",\n+                     time, count/((double)time/1000));\n+            executor.shutdown();\n+        } catch (ExecutionException ee) {\n+            LOG.error(\"Exception in worker\", ee);\n+        }  catch (KeeperException ke) {\n+            LOG.error(\"Error accessing zookeeper\", ke);\n+        } catch (BKException e) {\n+            LOG.error(\"Error accessing bookkeeper\", e);\n+        } catch (IOException ioe) {\n+            LOG.error(\"I/O exception during benchmark\", ioe);\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Benchmark interrupted\", ie);\n+        } finally {\n+            if (bkc != null) {\n+                try {\n+                    bkc.close();\n+                } catch (BKException bke) {\n+                    LOG.error(\"Error closing bookkeeper client\", bke);\n+                } catch (InterruptedException ie) {\n+                    LOG.warn(\"Interrupted closing bookkeeper client\", ie);\n+                }\n             }\n         }\n-        return retVal;\n+        timeouter.cancel();\n     }\n \n-    public void closeHandle() throws KeeperException, InterruptedException, BKException {\n-        lh.close();\n-    }\n-    /**\n-     * First says if entries should be written to BookKeeper (0) or to the local\n-     * disk (1). Second parameter is an integer defining the length of a ledger entry.\n-     * Third parameter is the number of writes.\n-     *\n-     * @param args\n-     */\n-    public static void main(String[] args) {\n+    static class HDFSClient implements Callable<Long> {\n+        final List<FSDataOutputStream> streams;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n \n-        int lenght = Integer.parseInt(args[1]);\n-        StringBuilder sb = new StringBuilder();\n-        while(lenght-- > 0) {\n-            sb.append('a');\n+        HDFSClient(List<FSDataOutputStream> streams, byte[] data, long time) {\n+            this.streams = streams;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n         }\n \n-        Integer selection = Integer.parseInt(args[0]);\n-        switch(selection) {\n-        case 0:\n-            StringBuilder servers_sb = new StringBuilder();\n-            for (int i = 4; i < args.length; i++) {\n-                servers_sb.append(args[i] + \" \");\n-            }\n-\n-            String servers = servers_sb.toString().trim().replace(' ', ',');\n+        public Long call() {\n             try {\n-                TestClient c = new TestClient(servers, Integer.parseInt(args[3]), Integer.parseInt(args[4]));\n-                c.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[2]));\n-                //c.writeConsecutiveEntriesBatch(Integer.parseInt(args[0]));\n-                c.closeHandle();\n-            } catch (Exception e) {\n-                LOG.error(\"Exception occurred\", e);\n-            } \n-            break;\n-        case 1:\n+                long count = 0;\n+                long start = System.currentTimeMillis();\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    FSDataOutputStream stream = streams.get(r.nextInt(streams.size()));\n+                    synchronized(stream) {\n+                        stream.write(data);\n+                        stream.flush();\n+                        stream.hflush();\n+                    }\n+                    count++;\n+                }\n \n-            try {\n-                TestClient c = new TestClient(new FileOutputStream(args[2]));\n-                c.writeSameEntryBatchFS(sb.toString().getBytes(), Integer.parseInt(args[3]));\n-            } catch(FileNotFoundException e) {\n-                LOG.error(\"File not found\", e);\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n+                         time, count/((double)time/1000));\n+                return count;\n+            } catch(IOException ioe) {\n+                LOG.error(\"Exception in worker thread\", ioe);\n+                return 0L;\n             }\n-            break;\n-        case 2:\n-            break;\n         }\n     }\n \n-    void writeSameEntryBatch(byte[] data, int times) throws InterruptedException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        LOG.debug(\"Data: \" + new String(data) + \", \" + data.length);\n-        while(count-- > 0) {\n-            lh.asyncAddEntry(data, this, this.getFreshEntryId(2));\n-        }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n-        synchronized (map) {\n-            if(map.size() != 0)\n-                map.wait();\n+    static class FileClient implements Callable<Long> {\n+        final List<FileOutputStream> streams;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n+\n+        FileClient(List<FileOutputStream> streams, byte[] data, long time) {\n+            this.streams = streams;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n         }\n-        LOG.debug(\"Finished processing in ms: \" + (System.currentTimeMillis() - start));\n \n-        LOG.debug(\"Ended computation\");\n-    }\n+        public Long call() {\n+            try {\n+                long count = 0;\n+                long start = System.currentTimeMillis();\n \n-    void writeConsecutiveEntriesBatch(int times) throws InterruptedException {\n-        start = System.currentTimeMillis();\n-        int count = times;\n-        while(count-- > 0) {\n-            byte[] write = new byte[2];\n-            int j = count%100;\n-            int k = (count+1)%100;\n-            write[0] = (byte) j;\n-            write[1] = (byte) k;\n-            lh.asyncAddEntry(write, this, this.getFreshEntryId(2));\n-        }\n-        LOG.debug(\"Finished \" + times + \" async writes in ms: \" + (System.currentTimeMillis() - start));\n-        synchronized (map) {\n-            if(map.size() != 0)\n-                map.wait();\n-        }\n-        LOG.debug(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    FileOutputStream stream = streams.get(r.nextInt(streams.size()));\n+                    synchronized(stream) {\n+                        stream.write(data);\n+                        stream.flush();\n+                        stream.getChannel().force(false);\n+                    }\n+                    count++;\n+                }\n \n-        Integer mon = Integer.valueOf(0);\n-        synchronized(mon) {\n-            lh.asyncReadEntries(1, times - 1, this, mon);\n-            mon.wait();\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\", time, count/((double)time/1000));\n+                return count;\n+            } catch(IOException ioe) {\n+                LOG.error(\"Exception in worker thread\", ioe);\n+                return 0L;\n+            }\n         }\n-        LOG.error(\"Ended computation\");\n     }\n \n-    void writeSameEntryBatchFS(byte[] data, int times) {\n-        int count = times;\n-        LOG.debug(\"Data: \" + data.length + \", \" + times);\n-        try {\n-            start = System.currentTimeMillis();\n-            while(count-- > 0) {\n-                fStream.write(data);\n-                fStreamLocal.write(data);\n-                fStream.flush();\n-            }\n-            fStream.close();\n-            System.out.println(\"Finished processing writes (ms): \" + (System.currentTimeMillis() - start));\n-        } catch(IOException e) {\n-            LOG.error(\"IOException occurred\", e);\n+    static class BKClient implements Callable<Long>, AddCallback {\n+        final List<LedgerHandle> handles;\n+        final byte[] data;\n+        final long time;\n+        final Random r;\n+        final boolean sync;\n+        final AtomicLong success = new AtomicLong(0);\n+        final AtomicLong outstanding = new AtomicLong(0);\n+\n+        BKClient(List<LedgerHandle> handles, byte[] data, long time, boolean sync) {\n+            this.handles = handles;\n+            this.data = data;\n+            this.time = time;\n+            this.r = new Random(System.identityHashCode(this));\n+            this.sync = sync;\n         }\n-    }\n \n+        public Long call() {\n+            try {\n+                long start = System.currentTimeMillis();\n \n-    @Override\n-    public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n-        this.removeEntryId((Integer) ctx);\n-    }\n+                long stopat = start + time;\n+                while(System.currentTimeMillis() < stopat) {\n+                    LedgerHandle lh = handles.get(r.nextInt(handles.size()));\n+                    if (sync) {\n+                        lh.addEntry(data);\n+                        success.incrementAndGet();\n+                    } else {\n+                        lh.asyncAddEntry(data, this, null);\n+                        outstanding.incrementAndGet();\n+                    }\n+                }\n \n-    @Override\n-    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-        System.out.println(\"Read callback: \" + rc);\n-        while(seq.hasMoreElements()) {\n-            LedgerEntry le = seq.nextElement();\n-            LOG.debug(new String(le.getEntry()));\n+                int ticks = 10; // don't wait for more than 10 seconds\n+                while (outstanding.get() > 0 && ticks-- > 0) {\n+                    Thread.sleep(10);\n+                }\n+\n+                long time = (System.currentTimeMillis() - start);\n+                LOG.info(\"Worker finished processing writes (ms): {} TPT: {} op/s\",\n+                         time, success.get()/((double)time/1000));\n+                return success.get();\n+            } catch (BKException e) {\n+                LOG.error(\"Exception in worker thread\", e);\n+                return 0L;\n+            } catch (InterruptedException ie) {\n+                LOG.error(\"Exception in worker thread\", ie);\n+                return 0L;\n+            }\n         }\n-        synchronized(ctx) {\n-            ctx.notify();\n+\n+        @Override\n+        public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+            if (rc == BKException.Code.OK) {\n+                success.incrementAndGet();\n+            }\n+            outstanding.decrementAndGet();\n         }\n     }\n }"},{"sha":"02e40ba7fb77b024be98f0112bd48fa258ec7edd","filename":"bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/java/org/apache/bookkeeper/benchmark/TestBenchmark.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.benchmark;\n+\n+import org.junit.BeforeClass;\n+import org.junit.AfterClass;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.util.LocalBookKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n+\n+public class TestBenchmark {\n+    protected static final Logger LOG = LoggerFactory.getLogger(TestBenchmark.class);\n+\n+    private static Thread ensembleThread = null;\n+    private final static String zkString = \"localhost:2181\";\n+    private static List<String> bookies = null;\n+\n+    @BeforeClass\n+    public static void startEnsemble() throws Exception {\n+        final int numBookies = 5;\n+\n+        ensembleThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        LocalBookKeeper.main(new String[]{String.valueOf(numBookies)});\n+                    } catch (InterruptedException ie) {\n+                        LOG.info(\"Shutting down ensemble thread\");\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error running bookkeeper ensemble\", e);\n+                    }\n+                }\n+            };\n+        ensembleThread.start();\n+\n+        if (!LocalBookKeeper.waitForServerUp(zkString, 5000)) {\n+            throw new Exception(\"Failed to start zookeeper\");\n+        }\n+        ZooKeeper zk = null;\n+        try {\n+            final CountDownLatch connectLatch = new CountDownLatch(1);\n+\n+            zk = new ZooKeeper(zkString, 15000, new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        if (event.getState() == KeeperState.SyncConnected) {\n+                            connectLatch.countDown();\n+                        }\n+                    }});\n+            if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n+                LOG.error(\"Couldn't connect to zookeeper at \" + zkString);\n+            } else {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        bookies = zk.getChildren(\"/ledgers/available\", false);\n+                        if (zk.getChildren(\"/ledgers/available\", false).size()\n+                            == numBookies) {\n+                            return;\n+                        }\n+                    } catch (Exception e) {\n+                        // do nothing\n+                    }\n+                    Thread.sleep(1000);\n+                }\n+                throw new Exception(\"Not enough bookies started\");\n+            }\n+        } finally {\n+            zk.close();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void stopEnsemble() throws Exception {\n+        if (ensembleThread != null) {\n+            ensembleThread.interrupt();\n+            ensembleThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void testThroughputLatency() throws Exception {\n+        BenchThroughputLatency.main(new String[] {\n+                \"--time\", \"10\",\n+                \"--skipwarmup\",\n+                \"--throttle\", \"1\",\n+                \"--sendlimit\", \"10000\"\n+            });\n+    }\n+\n+    @Test\n+    public void testBookie() throws Exception {\n+        String bookie = bookies.get(0);\n+        String[] parts = bookie.split(\":\");\n+        BenchBookie.main(new String[] {\n+                \"--host\", parts[0],\n+                \"--port\", parts[1],\n+                \"--zookeeper\", zkString\n+                });\n+    }\n+\n+    @Test\n+    public void testReadThroughputLatency() throws Exception {\n+        AtomicBoolean threwException = new AtomicBoolean(false);\n+        Thread t = new Thread() {\n+                public void run() {\n+                    try {\n+                        BenchReadThroughputLatency.main(new String[] {\n+                                \"--listen\", \"10\"});\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Error reading\", t);\n+                    }\n+                }\n+            };\n+        t.start();\n+\n+        Thread.sleep(10000);\n+        byte data[] = new byte[1024];\n+        Arrays.fill(data, (byte)'x');\n+\n+        long lastLedgerId = 0;\n+        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n+        for (int i = 0; i < 10; i++) {\n+            BookKeeper bk = new BookKeeper(zkString);\n+            LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n+            lastLedgerId = lh.getId();\n+            try {\n+                for (int j = 0; j < 100; j++) {\n+                    lh.addEntry(data);\n+                }\n+            } finally {\n+                lh.close();\n+                bk.close();\n+            }\n+        }\n+        for (int i = 0; i < 60; i++) {\n+            if (!t.isAlive()) {\n+                break;\n+            }\n+            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n+        }\n+\n+        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n+\n+        BenchReadThroughputLatency.main(new String[] {\n+                \"--ledger\", String.valueOf(lastLedgerId)});\n+\n+        final long nextLedgerId = lastLedgerId+1;\n+        t = new Thread() {\n+                public void run() {\n+                    try {\n+                        BenchReadThroughputLatency.main(new String[] {\n+                                \"--ledger\", String.valueOf(nextLedgerId)});\n+                    } catch (Throwable t) {\n+                        LOG.error(\"Error reading\", t);\n+                    }\n+                }\n+            };\n+        t.start();\n+\n+        Assert.assertTrue(\"Thread should be running\", t.isAlive());\n+        BookKeeper bk = new BookKeeper(zkString);\n+        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.CRC32, \"benchPasswd\".getBytes());\n+        try {\n+            for (int j = 0; j < 100; j++) {\n+                lh.addEntry(data);\n+            }\n+        } finally {\n+            lh.close();\n+            bk.close();\n+        }\n+        for (int i = 0; i < 60; i++) {\n+            if (!t.isAlive()) {\n+                break;\n+            }\n+            Thread.sleep(1000); // wait for 10 seconds for reading to finish\n+        }\n+        Assert.assertFalse(\"Thread should be finished\", t.isAlive());\n+    }\n+}\n\\ No newline at end of file"},{"sha":"0d88e2b25846130f4aebf18e19a70171a24355b7","filename":"bookkeeper-benchmark/src/test/resources/log4j.properties","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/test/resources/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-benchmark/src/test/resources/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-benchmark/src/test/resources/log4j.properties?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,72 @@\n+#\n+# \n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+# \n+#   http://www.apache.org/licenses/LICENSE-2.0\n+# \n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# \n+#\n+\n+#\n+# Bookkeeper Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=OFF, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=DEBUG\n+log4j.appender.ROLLINGFILE.File=bookkeeper-benchmark.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper_trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"910bd54e2d6a7071dfea8c4bc3991fc294c2630d","filename":"bookkeeper-server/README.txt","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/README.txt","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/README.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/README.txt?ref=814f0ab6b4d43a35992e995c8abd804326ec633b","patch":"@@ -1,62 +0,0 @@\n-BookKeeper README\n-\n-1- Overview\n-BookKeeper is a highly available logging service. As many critical services rely upon write-ahead logs to provide persistence along with high performance, an alternative to make such a service highly available despite the failures of individual servers it to offload write-ahead logs to an external service. \n-\n-This is exactly what BookKeeper provides. With BookKeeper, a service (or application) writes to a set of servers dedicated to storing such logs. An example of such an application is the Namenode of the Hadoop Distributed File System. \n-\n-The main components of BookKeeper are:\n-* Client: Applications interact with BookKeeper through the interface of of a BookKeeper client;\n-* Ledger: A ledger is our equivalent to a log file. Clients read entries from and write entries to ledgers;  \n-* Bookie: Bookies are BookKeeper servers and they store the content of ledgers. Typically there are multiple bookies implementing a ledger.\n-\n-2- How to compile\n-Run \"ant\" from \"trunk/contrib/bookkeeper\". This will generate the bookkeeper jar in \"trunk/build/contrib/bookkeeper\".\n-\n-3- Setting up\n-\n-A typical BookKeeper configuration includes a set of bookies and a ZooKeeper ensemble, where the ZooKeeper instance stores metadata for BookKeeper. As an example of such metadata, BookKeeper clients learn about available bookies by consulting a ZooKeeper service. \n-\n-To set up BookKeeper, follow these steps:\n-* Once bookies and ZooKeeper servers are running, create two znodes: \"/ledgers\" and \"/ledgers/available\". \n-* To run a bookie, run the java class \"org.apache.bookkeeper.proto.BookieServer\". It takes 3 parameters: a port, one directory path for transaction logs, and one directory path for indexes and data. Here is an example: java -cp .:bookkeeper.jar:../ZooKeeper/zookeeper-<version>.jar:/usr/local/apache-log4j-1.2.15/log4j-1.2.15.jar -Dlog4j.configuration=log4j.properties org.apache.bookkeeper.proto.BookieServer 3181 /disk1/bk/ /disk2/bk/\n-* For each bookie b, if <host> is the host name of b and <port> is the bookie port, then create a znode \"/ledgers/available/<host>:<port>\".\n-* It is ready to run! \n-\n-For test purposes, there is a class named \"org.apache.bookkeeper.util.LocalBookkeeper\" which runs a custom number on BookKeeper servers, along with a ZooKeeper server, on a single node. A typical invocation would be: \n-java -cp:<classpath> org.apache.bookkeeper.util.LocalBookKeeper <number-of-bookies>\n-\n-4- Developing applications\n-\n-BookKeeper is written in Java. When implementing an application that uses BookKeeper, follow these steps:\n-\n-a. Instantiate a BookKeeper object. The single parameter to the BookKeeper constructor is a list of ZooKeeper servers;\n-b. Once we have a BookKeeper object, we can create a ledger with createLedger. The default call to createLedger takes a single parameter, which is supposed to be for password authentication, but currently it has no effect. A call to createLedger returns a ledger handle (type LedgerHandle);\n-c. Once we have a ledger, we can write to the ledger by calling either addEntry or asyncAddEntry. The first call is synchronous, whereas the second call is asynchronous, and both write byte arrays as entries. To use the asynchronous version, the application has to implement the AddCallback interface;\n-d. Ideally, once the application finishes writing to the ledger, it should close it by calling close on the ledger handle. If it doesn't then BookKeeper will try to recover the ledger when a client tries to open it. By closing the ledger properly, we avoid this recovery step, which is recommended but not mandatory;\n-e. Before reading from a ledger, a client has to open it by calling openLedger on a BookKeeper object, and readEntries or asycnReadEntries to read entries. Both read calls take as input two entry numbers, n1 and n2, and return all entries from n1 through n2.   \n-\n-Here is a simple example of a method that creates a BookKeeper object, creates a ledger, writes an entry to the ledger, and closes it:\n-\n-BookKeeper bk;\n-LedgerHandle lh;\n-\n-public void allInOne(String servers) throws KeeperException, IOException, InterruptedException{\n-        bk = new BookKeeper(servers);\n-        try{\n-          lh = bk.createLedger(new byte[] {'a', 'b'});\n-          bk.addEntry(lh, new byte[]{'a', 'b'});\n-          bk.close(lh);\n-        } catch (BKException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-5- Selecting quorum mode and number of bookies (advanced)\n-\n-There are two methods to store ledgers with BookKeeper:\n-\n-a. Self-verifying: Each entry includes a digest that is used to guarantee that upon a read, the value read is the same as the one written. This mode requires n > 2t bookies, and quorums of size t + 1. By default, a call to createLedger uses this method and 3 servers;\n-b. Generic: Entries do not include a digest, and it requires more replicas: n > 3t and quorums of size 2t + 1. \n-\n-The quorum mode and number of bookies can be selected through the createLedger method."},{"sha":"01869ca942880821785e1219da649b81b769f3a4","filename":"bookkeeper-server/bin/bookkeeper","status":"modified","additions":47,"deletions":6,"changes":53,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/bin/bookkeeper","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/bin/bookkeeper","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/bin/bookkeeper?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -20,10 +20,40 @@\n # * limitations under the License.\n # */\n \n+# check if net.ipv6.bindv6only is set to 1\n+bindv6only=$(/sbin/sysctl -n net.ipv6.bindv6only 2> /dev/null)\n+if [ -n \"$bindv6only\" ] && [ \"$bindv6only\" -eq \"1\" ]\n+then\n+  echo \"Error: \\\"net.ipv6.bindv6only\\\" is set to 1 - Java networking could be broken\"\n+  echo \"For more info (the following page also applies to bookkeeper): http://wiki.apache.org/hadoop/HadoopIPv6\"\n+  exit 1\n+fi\n+\n+# See the following page for extensive details on setting\n+# up the JVM to accept JMX remote management:\n+# http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html\n+# by default we allow local JMX connections\n+if [ \"x$JMXLOCALONLY\" = \"x\" ]\n+then\n+    JMXLOCALONLY=false\n+fi\n+\n+if [ \"x$JMXDISABLE\" = \"x\" ]\n+then\n+    echo \"JMX enabled by default\" >&2\n+    # for some reason these two options are necessary on jdk6 on Ubuntu\n+    #   accord to the docs they are not necessary, but otw jconsole cannot\n+    #   do a local attach\n+    JMX_ARGS=\"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=$JMXLOCALONLY\"\n+else\n+    echo \"JMX disabled by user request\" >&2\n+fi\n+\n BINDIR=`dirname \"$0\"`\n BK_HOME=`cd $BINDIR/..;pwd`\n \n DEFAULT_CONF=$BK_HOME/conf/bk_server.conf\n+DEFAULT_LOG_CONF=$BK_HOME/conf/log4j.properties\n \n source $BK_HOME/conf/bkenv.sh\n \n@@ -47,14 +77,16 @@ Usage: bookkeeper <command>\n where command is one of:\n     bookie              Run a bookie server\n     localbookie <n>     Run a test ensemble of <n> bookies locally\n+    upgrade             Upgrade bookie filesystem\n     help                This help message\n \n or command is the full name of a class with a defined main() method.\n \n Environment variables:\n-   BOOKIE_LOG_CONF        Log4j configuration file\n-   BOOKIE_CONF            Configuration file (default: conf/bk_server.conf)\n+   BOOKIE_LOG_CONF        Log4j configuration file (default $DEFAULT_LOG_CONF)\n+   BOOKIE_CONF            Configuration file (default: $DEFAULT_CONF)\n    BOOKIE_EXTRA_OPTS      Extra options to be passed to the jvm\n+   BOOKIE_EXTRA_CLASSPATH Add extra paths to the bookkeeper classpath\n \n These variable can also be set in conf/bkenv.sh\n EOF\n@@ -95,11 +127,15 @@ fi\n COMMAND=$1\n shift\n \n-if [ \"$BOOKIE_CONF\" == \"\" ]; then\n+if [ -z \"$BOOKIE_CONF\" ]; then\n     BOOKIE_CONF=$DEFAULT_CONF\n fi\n \n-BOOKIE_CLASSPATH=\"$BOOKIE_JAR:$BOOKIE_CLASSPATH\"\n+if [ -z \"$BOOKIE_LOG_CONF\" ]; then\n+    BOOKIE_LOG_CONF=$DEFAULT_LOG_CONF\n+fi\n+\n+BOOKIE_CLASSPATH=\"$BOOKIE_JAR:$BOOKIE_CLASSPATH:$BOOKIE_EXTRA_CLASSPATH\"\n if [ \"$BOOKIE_LOG_CONF\" != \"\" ]; then\n     BOOKIE_CLASSPATH=\"`dirname $BOOKIE_LOG_CONF`:$BOOKIE_CLASSPATH\"\n     OPTS=\"$OPTS -Dlog4j.configuration=`basename $BOOKIE_LOG_CONF`\"\n@@ -108,12 +144,17 @@ OPTS=\"-cp $BOOKIE_CLASSPATH $OPTS $BOOKIE_EXTRA_OPTS\"\n \n OPTS=\"$OPTS $BOOKIE_EXTRA_OPTS\"\n \n+# Disable ipv6 as it can cause issues\n+OPTS=\"$OPTS -Djava.net.preferIPv4Stack=true\"\n+\n if [ $COMMAND == \"bookie\" ]; then\n-    exec java $OPTS org.apache.bookkeeper.proto.BookieServer --conf $BOOKIE_CONF $@\n+    exec java $OPTS $JMX_ARGS org.apache.bookkeeper.proto.BookieServer --conf $BOOKIE_CONF $@\n elif [ $COMMAND == \"localbookie\" ]; then\n     NUMBER=$1\n     shift\n-    exec java $OPTS org.apache.bookkeeper.util.LocalBookKeeper $NUMBER $BOOKIE_CONF $@\n+    exec java $OPTS $JMX_ARGS org.apache.bookkeeper.util.LocalBookKeeper $NUMBER $BOOKIE_CONF $@\n+elif [ $COMMAND == \"upgrade\" ]; then\n+    exec java $OPTS org.apache.bookkeeper.bookie.FileSystemUpgrade --conf $BOOKIE_CONF $@\n elif [ $COMMAND == \"help\" ]; then\n     bookkeeper_help;\n else"},{"sha":"b206b7e333e47fb3590ffa94262e56bb10d220f6","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/bk_server.conf","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/bk_server.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bk_server.conf?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -52,6 +52,28 @@ ledgerDirectories=/tmp/bk-data\n # A new entry log file will be created when the old one reaches the file size limitation\n # logSizeLimit=2147483648\n \n+# Threshold of minor compaction\n+# For those entry log files whose remaining size percentage reaches below\n+# this threshold will be compacted in a minor compaction.\n+# If it is set to less than zero, the minor compaction is disabled.\n+# minorCompactionThreshold=0.2\n+\n+# Interval to run minor compaction, in seconds\n+# If it is set to less than zero, the minor compaction is disabled. \n+# minorCompactionInterval=3600\n+\n+# Threshold of major compaction\n+# For those entry log files whose remaining size percentage reaches below\n+# this threshold will be compacted in a major compaction.\n+# Those entry log files whose remaining size percentage is still\n+# higher than the threshold will never be compacted.\n+# If it is set to less than zero, the minor compaction is disabled.\n+# majorCompactionThreshold=0.8\n+\n+# Interval to run major compaction, in seconds\n+# If it is set to less than zero, the major compaction is disabled. \n+# majorCompactionInterval=86400 \n+\n # Max file size of journal file, in mega bytes\n # A new journal file will be created when the old one reaches the file size limitation\n #"},{"sha":"4e60cdefe41da09cfd3745d09f52367614068530","filename":"bookkeeper-server/conf/bkenv.sh","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/bkenv.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/bkenv.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/bkenv.sh?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -24,3 +24,12 @@\n \n # Configuration file of settings used in bookie server\n # BOOKIE_CONF=\n+\n+# Log4j configuration file\n+# BOOKIE_LOG_CONF=\n+\n+# Extra options to be passed to the jvm\n+# BOOKIE_EXTRA_OPTS=\n+\n+# Add extra paths to the bookkeeper classpath\n+# BOOKIE_EXTRA_CLASSPATH="},{"sha":"79157db1776850d0e5bde2652363590b334b5555","filename":"bookkeeper-server/conf/log4j.properties","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/conf/log4j.properties?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,72 @@\n+#\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+#\n+\n+#\n+# Hedwig Logging Configuration\n+#\n+\n+# Format is \"<default threshold> (, <appender>)+\n+\n+# DEFAULT: console appender only\n+log4j.rootLogger=WARN, CONSOLE\n+\n+# Example with rolling log file\n+#log4j.rootLogger=DEBUG, CONSOLE, ROLLINGFILE\n+\n+# Example with rolling log file and tracing\n+#log4j.rootLogger=TRACE, CONSOLE, ROLLINGFILE, TRACEFILE\n+\n+#\n+# Log INFO level and above messages to the console\n+#\n+log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\n+log4j.appender.CONSOLE.Threshold=INFO\n+log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+#\n+# Add ROLLINGFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n+log4j.appender.ROLLINGFILE.Threshold=INFO\n+log4j.appender.ROLLINGFILE.File=bookkeeper-server.log\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n+\n+# Max log file size of 10MB\n+log4j.appender.ROLLINGFILE.MaxFileSize=10MB\n+# uncomment the next line to limit number of backup files\n+#log4j.appender.ROLLINGFILE.MaxBackupIndex=10\n+\n+log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n+log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L] - %m%n\n+\n+\n+#\n+# Add TRACEFILE to rootLogger to get log file output\n+#    Log DEBUG level and above messages to a log file\n+log4j.appender.TRACEFILE=org.apache.log4j.FileAppender\n+log4j.appender.TRACEFILE.Threshold=TRACE\n+log4j.appender.TRACEFILE.File=bookkeeper-trace.log\n+\n+log4j.appender.TRACEFILE.layout=org.apache.log4j.PatternLayout\n+### Notice we are including log4j's NDC here (%x)\n+log4j.appender.TRACEFILE.layout.ConversionPattern=%d{ISO8601} - %-5p [%t:%C{1}@%L][%x] - %m%n"},{"sha":"3cc0280df52084ff0036515a7fc46782b19c48d7","filename":"bookkeeper-server/lib/zookeeper-test-3.3.3.jar","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/lib/zookeeper-test-3.3.3.jar","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/lib/zookeeper-test-3.3.3.jar","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/lib/zookeeper-test-3.3.3.jar?ref=814f0ab6b4d43a35992e995c8abd804326ec633b"},{"sha":"8ac4173a90b21cd0859225a7a36cef1adb1009fa","filename":"bookkeeper-server/pom.xml","status":"modified","additions":27,"deletions":19,"changes":46,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,7 +21,7 @@\n   <parent>\n     <artifactId>bookkeeper</artifactId>\n     <groupId>org.apache.bookkeeper</groupId>\n-    <version>4.0.0-SNAPSHOT</version>\n+    <version>4.1.0</version>\n   </parent>\n   <groupId>org.apache.bookkeeper</groupId>\n   <artifactId>bookkeeper-server</artifactId>\n@@ -50,14 +50,15 @@\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>\n       <artifactId>zookeeper</artifactId>\n-      <version>3.4.0</version>\n+      <version>3.4.3</version>\n       <scope>compile</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>\n-      <artifactId>zookeeper-test</artifactId>\n-      <version>3.4.0</version>\n-      <scope>compile</scope>\n+      <artifactId>zookeeper</artifactId>\n+      <version>3.4.3</version>\n+      <type>test-jar</type>\n+      <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.jboss.netty</groupId>\n@@ -75,6 +76,11 @@\n       <artifactId>commons-cli</artifactId>\n       <version>1.2</version>\n     </dependency>\n+    <dependency>\n+      <groupId>commons-io</groupId>\n+      <artifactId>commons-io</artifactId>\n+      <version>2.1</version>\n+    </dependency>\n     <!--\n \tAnnoying dependency we need to include because\n \tzookeeper uses log4j and so we transatively do, but\n@@ -108,12 +114,22 @@\n   <build>\n     <plugins>\n       <plugin>\n-\t<groupId>org.apache.maven.plugins</groupId>\n-\t<artifactId>maven-surefire-plugin</artifactId>\n-\t<version>2.9</version>\n-\t<configuration>\n-\t  <forkMode>pertest</forkMode>\n-\t</configuration>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>2.9</version>\n+        <configuration>\n+          <argLine>-Xmx1G</argLine>\n+          <forkMode>pertest</forkMode>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-assembly-plugin</artifactId>\n+        <version>2.2.1</version>\n+        <configuration>\n+          <descriptors>\n+\t    <descriptor>../src/assemble/bin.xml</descriptor>\n+          </descriptors>\n+        </configuration>\n       </plugin>\n       <plugin>\n \t<artifactId>maven-dependency-plugin</artifactId>\n@@ -129,14 +145,6 @@\n \t  </execution>\n \t</executions>\n       </plugin>\n-\t  <plugin>\n-      \t<groupId>org.apache.maven.plugins</groupId>\n-\t\t<artifactId>maven-surefire-plugin</artifactId>\n-\t\t<version>2.9</version>\n-\t\t<configuration>\n-\t  \t<argLine>-Xmx1G</argLine>\n-\t\t</configuration>\n-\t  </plugin>\n     </plugins>\n   </build>\n </project>"},{"sha":"eae08a330c227013c401b9693903ae1814ba30e4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":341,"deletions":603,"changes":944,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,32 +21,28 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.io.BufferedReader;\n-import java.io.BufferedWriter;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.io.RandomAccessFile;\n+import java.io.FilenameFilter;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Map;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -63,45 +59,46 @@\n  */\n \n public class Bookie extends Thread {\n-    HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n     static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n-    final static long MB = 1024 * 1024L;\n-    // max journal file size\n-    final long maxJournalSize;\n-    // number journal files kept before marked journal\n-    final int maxBackupJournals;\n \n     final File journalDirectory;\n-\n     final File ledgerDirectories[];\n-\n     final ServerConfiguration conf;\n \n     final SyncThread syncThread;\n     final LedgerManager ledgerManager;\n+    final LedgerStorage ledgerStorage;\n+    final Journal journal;\n+    final HandleFactory handles;\n+\n+    static final long METAENTRY_ID_LEDGER_KEY = -0x1000;\n \n-    /**\n-     * Current directory layout version. Increment this \n-     * when you make a change to the format of any of the files in \n-     * this directory or to the general layout of the directory.\n-     */\n-    static final int CURRENT_DIRECTORY_LAYOUT_VERSION = 1;\n-    static final String VERSION_FILENAME = \"VERSION\";\n-    \n     // ZK registration path for this bookie\n-    static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available/\";\n+    private final String bookieRegistrationPath;\n+    static final String CURRENT_DIR = \"current\";\n \n     // ZooKeeper client instance for the Bookie\n     ZooKeeper zk;\n     private volatile boolean isZkExpired = true;\n \n     // Running flag\n     private volatile boolean running = false;\n+    // Flag identify whether it is in shutting down progress\n+    private volatile boolean shuttingdown = false;\n+\n+    private int exitCode = ExitCode.OK;\n+\n+    // jmx related beans\n+    BookieBean jmxBookieBean;\n+    BKMBeanInfo jmxLedgerStorageBean;\n+\n+    Map<Long, byte[]> masterKeyCache = Collections.synchronizedMap(new HashMap<Long, byte[]>());\n \n     public static class NoLedgerException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private long ledgerId;\n         public NoLedgerException(long ledgerId) {\n+            super(\"Ledger \" + ledgerId + \" not found\");\n             this.ledgerId = ledgerId;\n         }\n         public long getLedgerId() {\n@@ -125,8 +122,16 @@ public long getEntry() {\n         }\n     }\n \n-    EntryLogger entryLogger;\n-    LedgerCache ledgerCache;\n+    // Write Callback do nothing\n+    static class NopWriteCallback implements WriteCallback {\n+        @Override\n+        public void writeComplete(int rc, long ledgerId, long entryId,\n+                                  InetSocketAddress addr, Object ctx) {\n+            LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n+                      new Object[] { entryId, ledgerId, addr, rc });\n+        }\n+    }\n+\n     /**\n      * SyncThread is a background thread which flushes ledger index pages periodically.\n      * Also it takes responsibility of garbage collecting journal files.\n@@ -168,7 +173,7 @@ public void run() {\n                 synchronized(this) {\n                     try {\n                         wait(flushInterval);\n-                        if (!entryLogger.testAndClearSomethingWritten()) {\n+                        if (!ledgerStorage.isFlushRequired()) {\n                             continue;\n                         }\n                     } catch (InterruptedException e) {\n@@ -187,43 +192,22 @@ public void run() {\n                     break;\n                 }\n \n-                lastLogMark.markLog();\n+                // journal mark log\n+                journal.markLog();\n+\n+                boolean flushFailed = false;\n                 try {\n-                    ledgerCache.flushLedger(true);\n+                    ledgerStorage.flush();\n                 } catch (IOException e) {\n                     LOG.error(\"Exception flushing Ledger\", e);\n+                    flushFailed = true;\n                 }\n-                try {\n-                    entryLogger.flush();\n-                } catch (IOException e) {\n-                    LOG.error(\"Exception flushing entry logger\", e);\n-                }\n-                lastLogMark.rollLog();\n-\n-                // list the journals that have been marked\n-                List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n-                    @Override\n-                    public boolean accept(long journalId) {\n-                        if (journalId < lastLogMark.lastMark.txnLogId) {\n-                            return true;\n-                        } else {\n-                            return false;\n-                        }\n-                    }\n-                });\n \n-                // keep MAX_BACKUP_JOURNALS journal files before marked journal\n-                if (logs.size() >= maxBackupJournals) {\n-                    int maxIdx = logs.size() - maxBackupJournals;\n-                    for (int i=0; i<maxIdx; i++) {\n-                        long id = logs.get(i);\n-                        // make sure the journal id is smaller than marked journal id\n-                        if (id < lastLogMark.lastMark.txnLogId) {\n-                            File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n-                            journalFile.delete();\n-                            LOG.info(\"garbage collected journal \" + journalFile.getName());\n-                        }\n-                    }\n+                // if flush failed, we should not roll last mark, otherwise we would\n+                // have some ledgers are not flushed and their journal entries were lost\n+                if (!flushFailed) {\n+                    journal.rollLog();\n+                    journal.gcJournals();\n                 }\n \n                 // clear flushing flag\n@@ -243,162 +227,258 @@ void shutdown() throws InterruptedException {\n         }\n     }\n \n-    public Bookie(ServerConfiguration conf) \n-            throws IOException, KeeperException, InterruptedException {\n-        this.conf = conf;\n-        this.journalDirectory = conf.getJournalDir();\n-        this.ledgerDirectories = conf.getLedgerDirs();\n-        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n-        this.maxBackupJournals = conf.getMaxBackupJournals();\n-\n-        // check directory layouts\n-        checkDirectoryLayoutVersion(journalDirectory);\n-        for (File dir : ledgerDirectories) {\n-            checkDirectoryLayoutVersion(dir);\n-        }\n-\n-        // instantiate zookeeper client to initialize ledger manager\n-        ZooKeeper newZk = instantiateZookeeperClient(conf.getZkServers());\n-        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, newZk);\n+    public static void checkDirectoryStructure(File dir) throws IOException {\n+        if (!dir.exists()) {\n+            File parent = dir.getParentFile();\n+            File preV3versionFile = new File(dir.getParent(), Cookie.VERSION_FILENAME);\n \n-        syncThread = new SyncThread(conf);\n-        entryLogger = new EntryLogger(conf, this);\n-        ledgerCache = new LedgerCache(conf, ledgerManager);\n-\n-        lastLogMark.readLog();\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Last Log Mark : \" + lastLogMark);\n-        }\n-        final long markedLogId = lastLogMark.txnLogId;\n-        List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n-            @Override\n-            public boolean accept(long journalId) {\n-                if (journalId < markedLogId) {\n-                    return false;\n-                }\n-                return true;\n+            final AtomicBoolean oldDataExists = new AtomicBoolean(false);\n+            parent.list(new FilenameFilter() {\n+                    public boolean accept(File dir, String name) {\n+                        if (name.endsWith(\".txn\") || name.endsWith(\".idx\") || name.endsWith(\".log\")) {\n+                            oldDataExists.set(true);\n+                        }\n+                        return true;\n+                    }\n+                });\n+            if (preV3versionFile.exists() || oldDataExists.get()) {\n+                String err = \"Directory layout version is less than 3, upgrade needed\";\n+                LOG.error(err);\n+                throw new IOException(err);\n             }\n-        });\n-        // last log mark may be missed due to no sync up before\n-        // validate filtered log ids only when we have markedLogId\n-        if (markedLogId > 0) {\n-            if (logs.size() == 0 || logs.get(0) != markedLogId) {\n-                throw new IOException(\"Recovery log \" + markedLogId + \" is missing\");\n+            if (!dir.mkdirs()) {\n+                String err = \"Unable to create directory \" + dir;\n+                LOG.error(err);\n+                throw new IOException(err);\n             }\n         }\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Try to relay journal logs : \" + logs);\n+    }\n+\n+    /**\n+     * Check that the environment for the bookie is correct.\n+     * This means that the configuration has stayed the same as the\n+     * first run and the filesystem structure is up to date.\n+     */\n+    private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException {\n+        if (zk == null) { // exists only for testing, just make sure directories are correct\n+            checkDirectoryStructure(journalDirectory);\n+            for (File dir : ledgerDirectories) {\n+                    checkDirectoryStructure(dir);\n+            }\n+            return;\n         }\n-        // TODO: When reading in the journal logs that need to be synced, we\n-        // should use BufferedChannels instead to minimize the amount of\n-        // system calls done.\n-        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-        ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n-        for(Long id: logs) {\n-            FileChannel recLog ;\n-            if(id == markedLogId) {\n-              long markedLogPosition = lastLogMark.txnLogPosition;\n-              recLog = openChannel(id, markedLogPosition);\n-            } else {\n-              recLog = openChannel(id);\n+        try {\n+            boolean newEnv = false;\n+            Cookie masterCookie = Cookie.generateCookie(conf);\n+            try {\n+                Cookie zkCookie = Cookie.readFromZooKeeper(zk, conf);\n+                masterCookie.verify(zkCookie);\n+            } catch (KeeperException.NoNodeException nne) {\n+                newEnv = true;\n             }\n+            List<File> missedCookieDirs = new ArrayList<File>();\n+            checkDirectoryStructure(journalDirectory);\n \n-            while(true) {\n-                lenBuff.clear();\n-                fullRead(recLog, lenBuff);\n-                if (lenBuff.remaining() != 0) {\n-                    break;\n-                }\n-                lenBuff.flip();\n-                int len = lenBuff.getInt();\n-                if (len == 0) {\n-                    break;\n-                }\n-                recBuff.clear();\n-                if (recBuff.remaining() < len) {\n-                    recBuff = ByteBuffer.allocate(len);\n+            // try to read cookie from journal directory\n+            try {\n+                Cookie journalCookie = Cookie.readFromDirectory(journalDirectory);\n+                journalCookie.verify(masterCookie);\n+            } catch (FileNotFoundException fnf) {\n+                missedCookieDirs.add(journalDirectory);\n+            }\n+            for (File dir : ledgerDirectories) {\n+                checkDirectoryStructure(dir);\n+                try {\n+                    Cookie c = Cookie.readFromDirectory(dir);\n+                    c.verify(masterCookie);\n+                } catch (FileNotFoundException fnf) {\n+                    missedCookieDirs.add(dir);\n                 }\n-                recBuff.limit(len);\n-                if (fullRead(recLog, recBuff) != len) {\n-                    // This seems scary, but it just means that this is where we\n-                    // left off writing\n-                    break;\n+            }\n+\n+            if (!newEnv && missedCookieDirs.size() > 0){\n+                LOG.error(\"Cookie exists in zookeeper, but not in all local directories. \"\n+                        + \" Directories missing cookie file are \" + missedCookieDirs);\n+                throw new BookieException.InvalidCookieException();\n+            }\n+            if (newEnv) {\n+                if (missedCookieDirs.size() > 0) {\n+                    LOG.debug(\"Directories missing cookie file are {}\", missedCookieDirs);\n+                    masterCookie.writeToDirectory(journalDirectory);\n+                    for (File dir : ledgerDirectories) {\n+                        masterCookie.writeToDirectory(dir);\n+                    }\n                 }\n-                recBuff.flip();\n+                masterCookie.writeToZooKeeper(zk, conf);\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Couldn't access cookie in zookeeper\", ke);\n+            throw new BookieException.InvalidCookieException(ke);\n+        } catch (UnknownHostException uhe) {\n+            LOG.error(\"Couldn't check cookies, networking is broken\", uhe);\n+            throw new BookieException.InvalidCookieException(uhe);\n+        } catch (IOException ioe) {\n+            LOG.error(\"Error accessing cookie on disks\", ioe);\n+            throw new BookieException.InvalidCookieException(ioe);\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Thread interrupted while checking cookies, exiting\", ie);\n+            throw new BookieException.InvalidCookieException(ie);\n+        }\n+    }\n+\n+    public static File getCurrentDirectory(File dir) {\n+        return new File(dir, CURRENT_DIR);\n+    }\n+\n+    public static File[] getCurrentDirectories(File[] dirs) {\n+        File[] currentDirs = new File[dirs.length];\n+        for (int i = 0; i < dirs.length; i++) {\n+            currentDirs[i] = getCurrentDirectory(dirs[i]);\n+        }\n+        return currentDirs;\n+    }\n+\n+\n+    public Bookie(ServerConfiguration conf)\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n+        super(\"Bookie-\" + conf.getBookiePort());\n+        this.bookieRegistrationPath = conf.getZkAvailableBookiesPath() + \"/\";\n+        this.conf = conf;\n+        this.journalDirectory = getCurrentDirectory(conf.getJournalDir());\n+        this.ledgerDirectories = getCurrentDirectories(conf.getLedgerDirs());\n+\n+        // instantiate zookeeper client to initialize ledger manager\n+        this.zk = instantiateZookeeperClient(conf);\n+        checkEnvironment(this.zk);\n+\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, this.zk);\n+\n+        syncThread = new SyncThread(conf);\n+        ledgerStorage = new InterleavedLedgerStorage(conf, ledgerManager);\n+        handles = new HandleFactoryImpl(ledgerStorage);\n+        // instantiate the journal\n+        journal = new Journal(conf);\n+\n+        // replay journals\n+        readJournal();\n+    }\n+\n+    private void readJournal() throws IOException, BookieException {\n+        journal.replay(new JournalScanner() {\n+            @Override\n+            public void process(int journalVersion, long offset, ByteBuffer recBuff) throws IOException {\n                 long ledgerId = recBuff.getLong();\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Relay journal - ledger id : \" + ledgerId);\n-                }\n-                LedgerDescriptor handle = getHandle(ledgerId, false);\n+                long entryId = recBuff.getLong();\n                 try {\n-                    recBuff.rewind();\n-                    handle.addEntry(recBuff);\n-                } finally {\n-                    putHandle(handle);\n+                    LOG.debug(\"Replay journal - ledger id : {}, entry id : {}.\", ledgerId, entryId);\n+                    if (entryId == METAENTRY_ID_LEDGER_KEY) {\n+                        if (journalVersion >= 3) {\n+                            int masterKeyLen = recBuff.getInt();\n+                            byte[] masterKey = new byte[masterKeyLen];\n+\n+                            recBuff.get(masterKey);\n+                            masterKeyCache.put(ledgerId, masterKey);\n+                        } else {\n+                            throw new IOException(\"Invalid journal. Contains journalKey \"\n+                                    + \" but layout version (\" + journalVersion\n+                                    + \") is too old to hold this\");\n+                        }\n+                    } else {\n+                        byte[] key = masterKeyCache.get(ledgerId);\n+                        if (key == null) {\n+                            key = ledgerStorage.readMasterKey(ledgerId);\n+                        }\n+                        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+\n+                        recBuff.rewind();\n+                        handle.addEntry(recBuff);\n+                    }\n+                } catch (NoLedgerException nsle) {\n+                    LOG.debug(\"Skip replaying entries of ledger {} since it was deleted.\", ledgerId);\n+                } catch (BookieException be) {\n+                    throw new IOException(be);\n                 }\n             }\n-        }\n-        // pass zookeeper instance here\n-        // since GarbageCollector thread should only start after journal\n-        // finished replay\n-        this.zk = newZk;\n-        // make the bookie available\n-        registerBookie(conf.getBookiePort());\n+        });\n+    }\n+\n+    synchronized public void start() {\n         setDaemon(true);\n         LOG.debug(\"I'm starting a bookie with journal directory \" + journalDirectory.getName());\n-        start();\n+        // start bookie thread\n+        super.start();\n         syncThread.start();\n+\n+        ledgerStorage.start();\n         // set running here.\n         // since bookie server use running as a flag to tell bookie server whether it is alive\n         // if setting it in bookie thread, the watcher might run before bookie thread.\n         running = true;\n+        try {\n+            registerBookie(conf.getBookiePort());\n+        } catch (IOException e) {\n+            LOG.error(\"Couldn't register bookie with zookeeper, shutting down\", e);\n+            shutdown(ExitCode.ZK_REG_FAIL);\n+        }\n     }\n \n-    public static interface JournalIdFilter {\n-        public boolean accept(long journalId);\n+    /**\n+     * Register jmx with parent\n+     *\n+     * @param parent parent bk mbean info\n+     */\n+    public void registerJMX(BKMBeanInfo parent) {\n+        try {\n+            jmxBookieBean = new BookieBean(this);\n+            BKMBeanRegistry.getInstance().register(jmxBookieBean, parent);\n+\n+            try {\n+                jmxLedgerStorageBean = this.ledgerStorage.getJMXBean();\n+                BKMBeanRegistry.getInstance().register(jmxLedgerStorageBean, jmxBookieBean);\n+            } catch (Exception e) {\n+                LOG.warn(\"Failed to register with JMX for ledger cache\", e);\n+                jmxLedgerStorageBean = null;\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to register with JMX\", e);\n+            jmxBookieBean = null;\n+        }\n     }\n \n     /**\n-     * List all journal ids by a specified journal id filer\n-     *\n-     * @param journalDir journal dir\n-     * @param filter journal id filter\n-     * @return list of filtered ids\n+     * Unregister jmx\n      */\n-    public static List<Long> listJournalIds(File journalDir, JournalIdFilter filter) {\n-        File logFiles[] = journalDir.listFiles();\n-        List<Long> logs = new ArrayList<Long>();\n-        for(File f: logFiles) {\n-            String name = f.getName();\n-            if (!name.endsWith(\".txn\")) {\n-                continue;\n+    public void unregisterJMX() {\n+        try {\n+            if (jmxLedgerStorageBean != null) {\n+                BKMBeanRegistry.getInstance().unregister(jmxLedgerStorageBean);\n             }\n-            String idString = name.split(\"\\\\.\")[0];\n-            long id = Long.parseLong(idString, 16);\n-            if (filter != null) {\n-                if (filter.accept(id)) {\n-                    logs.add(id);\n-                }\n-            } else {\n-                logs.add(id);\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        try {\n+            if (jmxBookieBean != null) {\n+                BKMBeanRegistry.getInstance().unregister(jmxBookieBean);\n             }\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to unregister with JMX\", e);\n         }\n-        Collections.sort(logs);\n-        return logs;\n+        jmxBookieBean = null;\n+        jmxLedgerStorageBean = null;\n     }\n \n+\n     /**\n      * Instantiate the ZooKeeper client for the Bookie.\n      */\n-    private ZooKeeper instantiateZookeeperClient(String zkServers) throws IOException {\n-        if (zkServers == null) {\n+    private ZooKeeper instantiateZookeeperClient(ServerConfiguration conf) throws IOException {\n+        if (conf.getZkServers() == null) {\n             LOG.warn(\"No ZK servers passed to Bookie constructor so BookKeeper clients won't know about this server!\");\n             isZkExpired = false;\n             return null;\n         }\n-        int zkTimeout = conf.getZkTimeout();\n         // Create the ZooKeeper client instance\n-        return newZookeeper(zkServers, zkTimeout);\n+        return newZookeeper(conf.getZkServers(), conf.getZkTimeout());\n     }\n \n     /**\n@@ -411,7 +491,7 @@ private void registerBookie(int port) throws IOException {\n         }\n         // Create the ZK ephemeral node for this Bookie.\n         try {\n-            zk.create(BOOKIE_REGISTRATION_PATH + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n+            zk.create(this.bookieRegistrationPath + InetAddress.getLocalHost().getHostAddress() + \":\" + port, new byte[0],\n                       Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n         } catch (Exception e) {\n             LOG.error(\"ZK exception registering ephemeral Znode for Bookie!\", e);\n@@ -464,419 +544,73 @@ public void process(WatchedEvent event) {\n                 Watcher.Event.KeeperState.Expired)) {\n                     LOG.error(\"ZK client connection to the ZK server has expired!\");\n                     isZkExpired = true;\n-                    try {\n-                        shutdown();\n-                    } catch (InterruptedException ie) {\n-                        System.exit(-1);\n-                    }\n+                    shutdown(ExitCode.ZK_EXPIRED);\n                 }\n             }\n         });\n         isZkExpired = false;\n         return newZk;\n     }\n \n-    /**\n-     * Check the layout version of a directory. If it is outside of the \n-     * range which this version of the software can handle, throw an\n-     * exception.\n-     *\n-     * @param dir Directory to check\n-     * @throws IOException if layout version if is outside usable range\n-     *               or if there is a problem reading the version file\n-     */\n-    private void checkDirectoryLayoutVersion(File dir) \n-            throws IOException {\n-        if (!dir.isDirectory()) {\n-            throw new IOException(\"Directory(\"+dir+\") isn't a directory\");\n-        }\n-        File versionFile = new File(dir, VERSION_FILENAME);\n-        \n-        FileInputStream fis;\n-        try {\n-            fis = new FileInputStream(versionFile);\n-        } catch (FileNotFoundException e) {\n-            /* \n-             * If the version file is not found, this must\n-             * either be the first time we've used this directory,\n-             * or it must date from before layout versions were introduced.\n-             * In both cases, we just create the version file\n-             */\n-            LOG.info(\"No version file found, creating\");\n-            createDirectoryLayoutVersionFile(dir);\n-            return;\n-        }\n-        \n-        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-        try {\n-            String layoutVersionStr = br.readLine();\n-            int layoutVersion = Integer.parseInt(layoutVersionStr);\n-            if (layoutVersion != CURRENT_DIRECTORY_LAYOUT_VERSION) {\n-                String errmsg = \"Directory has an invalid version, expected \" \n-                    + CURRENT_DIRECTORY_LAYOUT_VERSION + \", found \" + layoutVersion;\n-                LOG.error(errmsg);\n-                throw new IOException(errmsg);\n-            }\n-        } catch(NumberFormatException e) {\n-            throw new IOException(\"Version file has invalid content\", e);\n-        } finally {\n-            try {\n-                fis.close();\n-            } catch (IOException e) {\n-                LOG.warn(\"Error closing version file\", e);\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Create the directory layout version file with the current\n-     * directory layout version\n-     */\n-    private void createDirectoryLayoutVersionFile(File dir) throws IOException {\n-        File versionFile = new File(dir, VERSION_FILENAME);\n-\n-        FileOutputStream fos = new FileOutputStream(versionFile);\n-        BufferedWriter bw = null;\n-        try {\n-            bw = new BufferedWriter(new OutputStreamWriter(fos));\n-            bw.write(String.valueOf(CURRENT_DIRECTORY_LAYOUT_VERSION));\n-        } finally {\n-            if (bw != null) {\n-                bw.close();\n-            }\n-            fos.close();\n-        }\n-    }\n-\n-    private static int fullRead(FileChannel fc, ByteBuffer bb) throws IOException {\n-        int total = 0;\n-        while(bb.remaining() > 0) {\n-            int rc = fc.read(bb);\n-            if (rc <= 0) {\n-                return total;\n-            }\n-            total += rc;\n-        }\n-        return total;\n-    }\n-    private void putHandle(LedgerDescriptor handle) {\n-        synchronized (ledgers) {\n-            handle.decRef();\n-        }\n-    }\n-\n-    private LedgerDescriptor getHandle(long ledgerId, boolean readonly, byte[] masterKey) throws IOException {\n-        LedgerDescriptor handle = null;\n-        synchronized (ledgers) {\n-            handle = ledgers.get(ledgerId);\n-            if (handle == null) {\n-                FileInfo fi = null;\n-                try {\n-                    // get file info will throw NoLedgerException\n-                    fi = ledgerCache.getFileInfo(ledgerId, !readonly);\n-\n-                    // if an existed ledger index file, we can get its master key\n-                    // if an new created ledger index file, we will get a null master key\n-                    byte[] existingMasterKey = fi.readMasterKey();\n-                    ByteBuffer masterKeyToSet = ByteBuffer.wrap(masterKey);\n-                    if (existingMasterKey == null) {\n-                        // no master key set before\n-                        fi.writeMasterKey(masterKey);\n-                    } else if (!masterKeyToSet.equals(ByteBuffer.wrap(existingMasterKey))) {\n-                        throw new IOException(\"Wrong master key for ledger \" + ledgerId);\n-                    }\n-                    handle = createHandle(ledgerId, readonly);\n-                    ledgers.put(ledgerId, handle);\n-                    handle.setMasterKey(masterKeyToSet);\n-                } finally {\n-                    if (fi != null) {\n-                        fi.release();\n-                    }\n-                }\n-            }\n-            handle.incRef();\n-        }\n-        return handle;\n-    }\n-\n-    private LedgerDescriptor getHandle(long ledgerId, boolean readonly) throws IOException {\n-        LedgerDescriptor handle = null;\n-        synchronized (ledgers) {\n-            handle = ledgers.get(ledgerId);\n-            if (handle == null) {\n-                FileInfo fi = null;\n-                try {\n-                    // get file info will throw NoLedgerException\n-                    fi = ledgerCache.getFileInfo(ledgerId, !readonly);\n-\n-                    // if an existed ledger index file, we can get its master key\n-                    // if an new created ledger index file, we will get a null master key\n-                    byte[] existingMasterKey = fi.readMasterKey();\n-                    if (existingMasterKey == null) {\n-                        throw new IOException(\"Weird! No master key found in ledger \" + ledgerId);\n-                    }\n-\n-                    handle = createHandle(ledgerId, readonly);\n-                    ledgers.put(ledgerId, handle);\n-                    handle.setMasterKey(ByteBuffer.wrap(existingMasterKey));\n-                } finally {\n-                    if (fi != null) {\n-                        fi.release();\n-                    }\n-                }\n-            }\n-            handle.incRef();\n-        }\n-        return handle;\n-    }\n-\n-\n-    private LedgerDescriptor createHandle(long ledgerId, boolean readOnly) throws IOException {\n-        return new LedgerDescriptor(ledgerId, entryLogger, ledgerCache);\n-    }\n-\n-    static class QueueEntry {\n-        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n-                   WriteCallback cb, Object ctx) {\n-            this.entry = entry.duplicate();\n-            this.cb = cb;\n-            this.ctx = ctx;\n-            this.ledgerId = ledgerId;\n-            this.entryId = entryId;\n-        }\n-\n-        ByteBuffer entry;\n-\n-        long ledgerId;\n-\n-        long entryId;\n-\n-        WriteCallback cb;\n-\n-        Object ctx;\n-    }\n-\n-    LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n-\n-    public final static long preAllocSize = 4*1024*1024;\n-\n-    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n-\n-    class LastLogMark {\n-        long txnLogId;\n-        long txnLogPosition;\n-        LastLogMark lastMark;\n-        LastLogMark(long logId, long logPosition) {\n-            this.txnLogId = logId;\n-            this.txnLogPosition = logPosition;\n-        }\n-        synchronized void setLastLogMark(long logId, long logPosition) {\n-            txnLogId = logId;\n-            txnLogPosition = logPosition;\n-        }\n-        synchronized void markLog() {\n-            lastMark = new LastLogMark(txnLogId, txnLogPosition);\n-        }\n-        synchronized void rollLog() {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            // we should record <logId, logPosition> marked in markLog\n-            // which is safe since records before lastMark have been\n-            // persisted to disk (both index & entry logger)\n-            bb.putLong(lastMark.txnLogId);\n-            bb.putLong(lastMark.txnLogPosition);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"RollLog to persist last marked log : \" + lastMark);\n-            }\n-            for(File dir: ledgerDirectories) {\n-                File file = new File(dir, \"lastMark\");\n-                try {\n-                    FileOutputStream fos = new FileOutputStream(file);\n-                    fos.write(buff);\n-                    fos.getChannel().force(true);\n-                    fos.close();\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems writing to \" + file, e);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Read last mark from lastMark file.\n-         * The last mark should first be max journal log id,\n-         * and then max log position in max journal log.\n-         */\n-        synchronized void readLog() {\n-            byte buff[] = new byte[16];\n-            ByteBuffer bb = ByteBuffer.wrap(buff);\n-            for(File dir: ledgerDirectories) {\n-                File file = new File(dir, \"lastMark\");\n-                try {\n-                    FileInputStream fis = new FileInputStream(file);\n-                    fis.read(buff);\n-                    fis.close();\n-                    bb.clear();\n-                    long i = bb.getLong();\n-                    long p = bb.getLong();\n-                    if (i > txnLogId) {\n-                        txnLogId = i;\n-                        if(p > txnLogPosition) {\n-                          txnLogPosition = p;\n-                        }\n-                    }\n-                } catch (IOException e) {\n-                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            \n-            sb.append(\"LastMark: logId - \").append(txnLogId)\n-              .append(\" , position - \").append(txnLogPosition);\n-            \n-            return sb.toString();\n-        }\n-    }\n-\n-    private LastLogMark lastLogMark = new LastLogMark(0, 0);\n-\n-    LastLogMark getLastLogMark() {\n-        return lastLogMark;\n-    }\n-\n     public boolean isRunning() {\n         return running;\n     }\n \n-    /**\n-     * A thread used for persisting journal entries to journal files.\n-     * \n-     * <p>\n-     * Besides persisting journal entries, it also takes responsibility of\n-     * rolling journal files when a journal file reaches journal file size\n-     * limitation.\n-     * </p>\n-     * <p>\n-     * During journal rolling, it first closes the writing journal, generates\n-     * new journal file using current timestamp, and continue persistence logic.\n-     * Those journals will be garbage collected in SyncThread.\n-     * </p>\n-     */\n     @Override\n     public void run() {\n-        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n-        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        // bookie thread wait for journal thread\n         try {\n-            long logId = 0;\n-            FileChannel logFile = null;\n-            BufferedChannel bc = null;\n-            long nextPrealloc = 0;\n-            long lastFlushPosition = 0;\n-\n-            QueueEntry qe = null;\n-            while (true) {\n-                // new journal file to write\n-                if (null == logFile) {\n-                    logId = System.currentTimeMillis();\n-                    logFile = openChannel(logId);\n-                    bc = new BufferedChannel(logFile, 65536);\n-                    zeros.clear();\n-                    nextPrealloc = preAllocSize;\n-                    lastFlushPosition = 0;\n-                    logFile.write(zeros, nextPrealloc);\n-                }\n-\n-                if (qe == null) {\n-                    if (toFlush.isEmpty()) {\n-                        qe = queue.take();\n-                    } else {\n-                        qe = queue.poll();\n-                        if (qe == null || bc.position() > lastFlushPosition + 512*1024) {\n-                            //logFile.force(false);\n-                            bc.flush(true);\n-                            lastFlushPosition = bc.position();\n-                            lastLogMark.setLastLogMark(logId, lastFlushPosition);\n-                            for (QueueEntry e : toFlush) {\n-                                e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n-                            }\n-                            toFlush.clear();\n-\n-                            // check whether journal file is over file limit\n-                            if (bc.position() > maxJournalSize) {\n-                                logFile.close();\n-                                logFile = null;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (isZkExpired) {\n-                    LOG.warn(\"Exiting... zk client has expired.\");\n-                    break;\n-                }\n-                if (qe == null) { // no more queue entry\n-                    continue;\n-                }\n-                lenBuff.clear();\n-                lenBuff.putInt(qe.entry.remaining());\n-                lenBuff.flip();\n-                //\n-                // we should be doing the following, but then we run out of\n-                // direct byte buffers\n-                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n-                bc.write(lenBuff);\n-                bc.write(qe.entry);\n-                if (bc.position() > nextPrealloc) {\n-                    nextPrealloc = (logFile.size() / preAllocSize + 1) * preAllocSize;\n-                    zeros.clear();\n-                    logFile.write(zeros, nextPrealloc);\n-                }\n-                toFlush.add(qe);\n-                qe = null;\n-            }\n-        } catch (Exception e) {\n-            LOG.error(\"Bookie thread exiting\", e);\n+            // start journal\n+            journal.start();\n+            // wait until journal quits\n+            journal.join();\n+        } catch (InterruptedException ie) {\n+        }\n+        // if the journal thread quits due to shutting down, it is ok\n+        if (!shuttingdown) {\n+            // some error found in journal thread and it quits\n+            // following add operations to it would hang unit client timeout\n+            // so we should let bookie server exists\n+            LOG.error(\"Journal manager quits unexpectedly.\");\n+            shutdown(ExitCode.BOOKIE_EXCEPTION);\n         }\n     }\n \n-    private FileChannel openChannel(long logId) throws FileNotFoundException {\n-        return openChannel(logId, 0);\n+    // provided a public shutdown method for other caller\n+    // to shut down bookie gracefully\n+    public int shutdown() {\n+        return shutdown(ExitCode.OK);\n     }\n \n-    private FileChannel openChannel(long logId, long position) throws FileNotFoundException {\n-        FileChannel logFile = new RandomAccessFile(new File(journalDirectory,\n-                Long.toHexString(logId) + \".txn\"),\n-                \"rw\").getChannel();\n+    // internal shutdown method to let shutdown bookie gracefully\n+    // when encountering exception\n+    synchronized int shutdown(int exitCode) {\n         try {\n-            logFile.position(position);\n-        } catch (IOException e) {\n-            LOG.error(\"Bookie journal file can seek to position :\", e);\n-        }\n-        return logFile;\n-    }\n-\n-    public synchronized void shutdown() throws InterruptedException {\n-        if (!running) { // avoid shutdown twice\n-            return;\n-        }\n-        // Shutdown the ZK client\n-        if(zk != null) zk.close();\n-        this.interrupt();\n-        this.join();\n-        syncThread.shutdown(); \n-        for(LedgerDescriptor d: ledgers.values()) {\n-            d.close();\n+            if (running) { // avoid shutdown twice\n+                // the exitCode only set when first shutdown usually due to exception found\n+                this.exitCode = exitCode;\n+                // mark bookie as in shutting down progress\n+                shuttingdown = true;\n+\n+                // Shutdown the EntryLogger which has the GarbageCollector Thread running\n+                ledgerStorage.shutdown();\n+\n+                // Shutdown the ZK client\n+                if(zk != null) zk.close();\n+                // Shutdown journal\n+                journal.shutdown();\n+                this.join();\n+                syncThread.shutdown();\n+\n+                // close Ledger Manager\n+                ledgerManager.close();\n+                // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n+                running = false;\n+            }\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Interrupted during shutting down bookie : \", ie);\n         }\n-        // Shutdown the EntryLogger which has the GarbageCollector Thread running\n-        entryLogger.shutdown();\n-        // close Ledger Manager\n-        ledgerManager.close();\n-        // setting running to false here, so watch thread in bookie server know it only after bookie shut down\n-        running = false;\n+        return this.exitCode;\n     }\n \n     /** \n@@ -889,13 +623,27 @@ public synchronized void shutdown() throws InterruptedException {\n     private LedgerDescriptor getLedgerForEntry(ByteBuffer entry, byte[] masterKey) \n             throws IOException, BookieException {\n         long ledgerId = entry.getLong();\n-        LedgerDescriptor handle = getHandle(ledgerId, false, masterKey);\n+        LedgerDescriptor l = handles.getHandle(ledgerId, masterKey);\n+        if (!masterKeyCache.containsKey(ledgerId)) {\n+            // new handle, we should add the key to journal ensure we can rebuild\n+            ByteBuffer bb = ByteBuffer.allocate(8 + 8 + 4 + masterKey.length);\n+            bb.putLong(ledgerId);\n+            bb.putLong(METAENTRY_ID_LEDGER_KEY);\n+            bb.putInt(masterKey.length);\n+            bb.put(masterKey);\n+            bb.flip();\n \n-        if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))) {\n-            putHandle(handle);\n-            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+            journal.logAddEntry(bb, new NopWriteCallback(), null);\n+            masterKeyCache.put(ledgerId, masterKey);\n         }\n-        return handle;\n+        return l;\n+    }\n+\n+    protected void addEntryByLedgerId(long ledgerId, ByteBuffer entry)\n+        throws IOException, BookieException {\n+        byte[] key = ledgerStorage.readMasterKey(ledgerId);\n+        LedgerDescriptor handle = handles.getHandle(ledgerId, key);\n+        handle.addEntry(entry);\n     }\n \n     /**\n@@ -911,7 +659,7 @@ private void addEntryInternal(LedgerDescriptor handle, ByteBuffer entry, WriteCa\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Adding \" + entryId + \"@\" + ledgerId);\n         }\n-        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+        journal.logAddEntry(entry, cb, ctx);\n     }\n \n     /**\n@@ -924,11 +672,7 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n             throws IOException, BookieException {\n         LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n         synchronized (handle) {\n-            try {\n-                addEntryInternal(handle, entry, cb, ctx);\n-            } finally {\n-                putHandle(handle);\n-            }\n+            addEntryInternal(handle, entry, cb, ctx);\n         }\n     }\n     \n@@ -940,42 +684,35 @@ public void addEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byte[] mast\n             throws IOException, BookieException {\n         LedgerDescriptor handle = getLedgerForEntry(entry, masterKey);\n         synchronized (handle) {\n-            try {\n-                if (handle.isFenced()) {\n-                    throw BookieException.create(BookieException.Code.LedgerFencedException);\n-                }\n-                \n-                addEntryInternal(handle, entry, cb, ctx);\n-            } finally {\n-                putHandle(handle);\n+            if (handle.isFenced()) {\n+                throw BookieException.create(BookieException.Code.LedgerFencedException);\n             }\n+\n+            addEntryInternal(handle, entry, cb, ctx);\n         }\n     }\n \n     /**\n-     * Fences a ledger. From this point on, clients will be unable to \n+     * Fences a ledger. From this point on, clients will be unable to\n      * write to this ledger. Only recoveryAddEntry will be\n      * able to add entries to the ledger.\n      * This method is idempotent. Once a ledger is fenced, it can\n      * never be unfenced. Fencing a fenced ledger has no effect.\n      */\n-    public void fenceLedger(long ledgerId) throws IOException {\n-        LedgerDescriptor handle = getHandle(ledgerId, true);\n+    public void fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n+        LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n         synchronized (handle) {\n             handle.setFenced();\n         }\n     }\n \n-    public ByteBuffer readEntry(long ledgerId, long entryId) throws IOException {\n-        LedgerDescriptor handle = getHandle(ledgerId, true);\n-        try {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Reading \" + entryId + \"@\" + ledgerId);\n-            }\n-            return handle.readEntry(entryId);\n-        } finally {\n-            putHandle(handle);\n+    public ByteBuffer readEntry(long ledgerId, long entryId)\n+            throws IOException, NoLedgerException {\n+        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Reading \" + entryId + \"@\" + ledgerId);\n         }\n+        return handle.readEntry(entryId);\n     }\n \n     // The rest of the code is test stuff\n@@ -1008,6 +745,7 @@ synchronized public void waitZero() throws InterruptedException {\n     public static void main(String[] args) \n             throws IOException, InterruptedException, BookieException, KeeperException {\n         Bookie b = new Bookie(new ServerConfiguration());\n+        b.start();\n         CounterCallback cb = new CounterCallback();\n         long start = System.currentTimeMillis();\n         for (int i = 0; i < 100000; i++) {"},{"sha":"9ad7c9c123863555a6cfcaf1566d95d50c78c591","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,51 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+\n+/**\n+ * Bookie Bean\n+ */\n+public class BookieBean implements BookieMXBean, BKMBeanInfo {\n+\n+    protected Bookie bk;\n+\n+    public BookieBean(Bookie bk) {\n+        this.bk = bk;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Bookie\";\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getQueueLength() {\n+        return bk.journal.getJournalQueueLength();\n+    }\n+\n+}"},{"sha":"75c99402daeb12250a44b6b6f779153f4526364b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"modified","additions":63,"deletions":5,"changes":68,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -32,12 +32,24 @@ public BookieException(int code) {\n         this.code = code;\n     }\n \n+    public BookieException(int code, Throwable t) {\n+        super(t);\n+    }\n+\n+    public BookieException(int code, String reason) {\n+        super(reason);\n+    }\n+\n     public static BookieException create(int code) {\n         switch(code) {\n         case Code.UnauthorizedAccessException:\n             return new BookieUnauthorizedAccessException();\n         case Code.LedgerFencedException:\n             return new LedgerFencedException();\n+        case Code.InvalidCookieException:\n+            return new InvalidCookieException();\n+        case Code.UpgradeException:\n+            return new UpgradeException();\n         default:\n             return new BookieIllegalOpException();\n         }\n@@ -49,6 +61,9 @@ public static BookieException create(int code) {\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n+\n+        int InvalidCookieException = -102;\n+        int UpgradeException = -103;\n     }\n \n     public void setCode(int code) {\n@@ -60,15 +75,34 @@ public int getCode() {\n     }\n \n     public String getMessage(int code) {\n+        String err = \"Invalid operation\";\n         switch(code) {\n         case Code.OK:\n-            return \"No problem\";\n+            err = \"No problem\";\n+            break;\n         case Code.UnauthorizedAccessException:\n-            return \"Error while reading ledger\";\n+            err = \"Error while reading ledger\";\n+            break;\n         case Code.LedgerFencedException:\n-            return \"Ledger has been fenced; No more entries can be added\";\n-        default:\n-            return \"Invalid operation\";\n+            err = \"Ledger has been fenced; No more entries can be added\";\n+            break;\n+        case Code.InvalidCookieException:\n+            err = \"Invalid environment cookie found\";\n+            break;\n+        case Code.UpgradeException:\n+            err = \"Error performing an upgrade operation \";\n+            break;\n+        }\n+        String reason = super.getMessage();\n+        if (reason == null) {\n+            if (super.getCause() != null) {\n+                reason = super.getCause().getMessage();\n+            }\n+        }\n+        if (reason == null) {\n+            return err;\n+        } else {\n+            return String.format(\"%s [%s]\", err, reason);\n         }\n     }\n \n@@ -89,4 +123,28 @@ public LedgerFencedException() {\n             super(Code.LedgerFencedException);\n         }\n     }\n+\n+    public static class InvalidCookieException extends BookieException {\n+        public InvalidCookieException() {\n+            this(null);\n+        }\n+\n+        public InvalidCookieException(Throwable cause) {\n+            super(Code.InvalidCookieException, cause);\n+        }\n+    }\n+\n+    public static class UpgradeException extends BookieException {\n+        public UpgradeException() {\n+            super(Code.UpgradeException);\n+        }\n+\n+        public UpgradeException(Throwable cause) {\n+            super(Code.UpgradeException, cause);\n+        }\n+\n+        public UpgradeException(String reason) {\n+            super(Code.UpgradeException, reason);\n+        }\n+    }\n }"},{"sha":"24f299cc5ca38db1df20917e371517b646107deb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,31 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+\n+/**\n+ * Bookie MBean\n+ */\n+public interface BookieMXBean {\n+    /**\n+     * @return log entry queue length\n+     */\n+    public int getQueueLength();\n+}"},{"sha":"3024ff9706ae9396663fedbc79b428a474870863","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","status":"added","additions":196,"deletions":0,"changes":196,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,196 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Scanner;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * When a bookie starts for the first time it generates  a cookie, and stores\n+ * the cookie in zookeeper as well as in the each of the local filesystem\n+ * directories it uses. This cookie is used to ensure that for the life of the\n+ * bookie, its configuration stays the same. If any of the bookie directories\n+ * becomes unavailable, the bookie becomes unavailable. If the bookie changes\n+ * port, it must also reset all of its data.\n+ *\n+ * This is done to ensure data integrity. Without the cookie a bookie could\n+ * start with one of its ledger directories missing, so data would be missing,\n+ * but the bookie would be up, so the client would think that everything is ok\n+ * with the cluster. It's better to fail early and obviously.\n+ */\n+class Cookie {\n+    static Logger LOG = LoggerFactory.getLogger(Cookie.class);\n+\n+    static final int CURRENT_COOKIE_LAYOUT_VERSION = 3;\n+    static final String COOKIE_NODE = \"cookies\";\n+    static final String VERSION_FILENAME = \"VERSION\";\n+    private int layoutVersion = 0;\n+    private String bookieHost = null;\n+    private String journalDir = null;\n+    private String ledgerDirs = null;\n+    private int znodeVersion = -1;\n+\n+    private Cookie() {\n+    }\n+\n+    public void verify(Cookie c)\n+            throws BookieException.InvalidCookieException {\n+        if (!(c.layoutVersion == layoutVersion\n+              && c.layoutVersion >= 3\n+              && c.bookieHost.equals(bookieHost)\n+              && c.journalDir.equals(journalDir)\n+              && c.ledgerDirs.equals(ledgerDirs))) {\n+            throw new BookieException.InvalidCookieException();\n+        }\n+    }\n+\n+    public String toString() {\n+        StringBuilder b = new StringBuilder();\n+        b.append(CURRENT_COOKIE_LAYOUT_VERSION).append(\"\\n\")\n+            .append(bookieHost).append(\"\\n\")\n+            .append(journalDir).append(\"\\n\")\n+            .append(ledgerDirs).append(\"\\n\");\n+        return b.toString();\n+    }\n+\n+    private static Cookie parse(Scanner s) throws IOException {\n+        Cookie c  = new Cookie();\n+        if (!s.hasNextInt()) {\n+            throw new IOException(\"Invalid string, cannot parse cookie.\");\n+        }\n+        c.layoutVersion = s.nextInt();\n+        if (c.layoutVersion >= 3) {\n+            s.nextLine();\n+            c.bookieHost = s.nextLine();\n+            c.journalDir = s.nextLine();\n+            c.ledgerDirs = s.nextLine();\n+        }\n+        s.close();\n+        return c;\n+    }\n+\n+    void writeToDirectory(File directory) throws IOException {\n+        File versionFile = new File(directory, VERSION_FILENAME);\n+\n+        FileOutputStream fos = new FileOutputStream(versionFile);\n+        BufferedWriter bw = null;\n+        try {\n+            bw = new BufferedWriter(new OutputStreamWriter(fos));\n+            bw.write(toString());\n+        } finally {\n+            if (bw != null) {\n+                bw.close();\n+            }\n+            fos.close();\n+        }\n+    }\n+\n+    void writeToZooKeeper(ZooKeeper zk, ServerConfiguration conf)\n+            throws KeeperException, InterruptedException, UnknownHostException {\n+        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\" + COOKIE_NODE;\n+        String zkPath = getZkPath(conf);\n+        byte[] data = toString().getBytes();\n+        if (znodeVersion != -1) {\n+            zk.setData(zkPath, data, znodeVersion);\n+        } else {\n+            if (zk.exists(bookieCookiePath, false) == null) {\n+                try {\n+                    zk.create(bookieCookiePath, new byte[0],\n+                              Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                } catch (KeeperException.NodeExistsException nne) {\n+                    LOG.info(\"More than one bookie tried to create {} at once. Safe to ignore\",\n+                             bookieCookiePath);\n+                }\n+            }\n+            zk.create(zkPath, data,\n+                      Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            Stat stat = zk.exists(zkPath, false);\n+            this.znodeVersion = stat.getVersion();\n+        }\n+    }\n+\n+    void deleteFromZooKeeper(ZooKeeper zk, ServerConfiguration conf)\n+            throws KeeperException, InterruptedException, UnknownHostException {\n+        String zkPath = getZkPath(conf);\n+        if (znodeVersion != -1) {\n+            zk.delete(zkPath, znodeVersion);\n+        }\n+        znodeVersion = -1;\n+    }\n+\n+    static Cookie generateCookie(ServerConfiguration conf)\n+            throws UnknownHostException {\n+        Cookie c = new Cookie();\n+        c.layoutVersion = CURRENT_COOKIE_LAYOUT_VERSION;\n+        c.bookieHost = InetAddress.getLocalHost().getHostAddress() + \":\" + conf.getBookiePort();\n+        c.journalDir = conf.getJournalDirName();\n+        StringBuilder b = new StringBuilder();\n+        String[] dirs = conf.getLedgerDirNames();\n+        b.append(dirs.length);\n+        for (String d : dirs) {\n+            b.append(\"\\t\").append(d);\n+        }\n+        c.ledgerDirs = b.toString();\n+        return c;\n+    }\n+\n+    static Cookie readFromZooKeeper(ZooKeeper zk, ServerConfiguration conf)\n+            throws KeeperException, InterruptedException, IOException, UnknownHostException {\n+        String zkPath = getZkPath(conf);\n+\n+        Stat stat = zk.exists(zkPath, false);\n+        byte[] data = zk.getData(zkPath, false, stat);\n+        Cookie c = parse(new Scanner(new String(data)));\n+        c.znodeVersion = stat.getVersion();\n+        return c;\n+    }\n+\n+    static Cookie readFromDirectory(File directory) throws IOException {\n+        File versionFile = new File(directory, VERSION_FILENAME);\n+        return parse(new Scanner(versionFile));\n+    }\n+\n+    private static String getZkPath(ServerConfiguration conf)\n+            throws UnknownHostException {\n+        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\" + COOKIE_NODE;\n+        return bookieCookiePath + \"/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + conf.getBookiePort();\n+    }\n+}"},{"sha":"9c3e051ebfda32abb8607b10388791f806eada84","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":219,"deletions":217,"changes":436,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -24,6 +24,7 @@\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n+import java.io.FileFilter;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n@@ -34,15 +35,16 @@\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.util.IOUtils;\n \n /**\n  * This class manages the writing of the bookkeeper entries. All the new\n@@ -54,9 +56,6 @@\n public class EntryLogger {\n     private static final Logger LOG = LoggerFactory.getLogger(EntryLogger.class);\n     private File dirs[];\n-    // This is a handle to the Bookie parent instance. We need this to get\n-    // access to the LedgerCache as well as the ZooKeeper client handle.\n-    private final Bookie bookie;\n \n     private long logId;\n     /**\n@@ -71,163 +70,134 @@\n     final static int LOGFILE_HEADER_SIZE = 1024;\n     final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n \n-    // this indicates that a write has happened since the last flush\n-    private volatile boolean somethingWritten = false;\n+    final static long MB = 1024 * 1024;\n+\n+    /**\n+     * Scan entries in a entry log file.\n+     */\n+    static interface EntryLogScanner {\n+        /**\n+         * Tests whether or not the entries belongs to the specified ledger\n+         * should be processed.\n+         *\n+         * @param ledgerId\n+         *          Ledger ID.\n+         * @return true if and only the entries of the ledger should be scanned.\n+         */\n+        public boolean accept(long ledgerId);\n \n-    // Maps entry log files to the set of ledgers that comprise the file.\n-    private ConcurrentMap<Long, ConcurrentHashMap<Long, Boolean>> entryLogs2LedgersMap = new ConcurrentHashMap<Long, ConcurrentHashMap<Long, Boolean>>();\n-    // This is the thread that garbage collects the entry logs that do not\n-    // contain any active ledgers in them.\n-    GarbageCollectorThread gcThread = new GarbageCollectorThread();\n-    // This is how often we want to run the Garbage Collector Thread (in milliseconds).\n-    final long gcWaitTime;\n+        /**\n+         * Process an entry.\n+         *\n+         * @param ledgerId\n+         *          Ledger ID.\n+         * @param entry\n+         *          Entry ByteBuffer\n+         * @throws IOException\n+         */\n+        public void process(long ledgerId, ByteBuffer entry) throws IOException;\n+    }\n \n     /**\n      * Create an EntryLogger that stores it's log files in the given\n      * directories\n      */\n-    public EntryLogger(ServerConfiguration conf, Bookie bookie) throws IOException {\n-        this.dirs = conf.getLedgerDirs();\n-        this.bookie = bookie;\n+    public EntryLogger(ServerConfiguration conf) throws IOException {\n+        this.dirs = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n         // log size limit\n         this.logSizeLimit = conf.getEntryLogSizeLimit();\n-        this.gcWaitTime = conf.getGcWaitTime();\n+\n         // Initialize the entry log header buffer. This cannot be a static object\n         // since in our unit tests, we run multiple Bookies and thus EntryLoggers\n         // within the same JVM. All of these Bookie instances access this header\n         // so there can be race conditions when entry logs are rolled over and\n         // this header buffer is cleared before writing it into the new logChannel.\n         LOGFILE_HEADER.put(\"BKLO\".getBytes());\n         // Find the largest logId\n-        for(File f: dirs) {\n-            long lastLogId = getLastLogId(f);\n-            if (lastLogId >= logId) {\n-                logId = lastLogId+1;\n+        logId = -1;\n+        for(File dir: dirs) {\n+            if (!dir.exists()) {\n+                throw new FileNotFoundException(\n+                        \"Entry log directory does not exist\");\n+            }\n+            long lastLogId = getLastLogId(dir);\n+            if (lastLogId > logId) {\n+                logId = lastLogId;\n             }\n         }\n-        createLogId(logId);\n-        // Start the Garbage Collector thread to prune unneeded entry logs.\n-        gcThread.start();\n+        createNewLog();\n     }\n \n     /**\n      * Maps entry log files to open channels.\n      */\n     private ConcurrentHashMap<Long, BufferedChannel> channels = new ConcurrentHashMap<Long, BufferedChannel>();\n \n-    /**\n-     * This is the garbage collector thread that runs in the background to\n-     * remove any entry log files that no longer contains any active ledger.\n-     */\n-    class GarbageCollectorThread extends Thread {\n-        volatile boolean running = true;\n-\n-        public GarbageCollectorThread() {\n-            super(\"GarbageCollectorThread\");\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (running) {\n-                synchronized (this) {\n-                    try {\n-                        wait(gcWaitTime);\n-                    } catch (InterruptedException e) {\n-                        Thread.currentThread().interrupt();\n-                        continue;\n-                    }\n-                }\n-                // Initialization check. No need to run any logic if we are still starting up.\n-                if (bookie.zk == null || entryLogs2LedgersMap.isEmpty() ||\n-                    bookie.ledgerCache == null) {\n-                    continue;\n-                }\n-\n-                // gc inactive/deleted ledgers\n-                doGcLedgers();\n-\n-                // gc entry logs\n-                doGcEntryLogs();\n-            }\n-        }\n-\n-        /**\n-         * Do garbage collection ledger index files\n-         */\n-        private void doGcLedgers() {\n-            bookie.ledgerCache.activeLedgerManager.garbageCollectLedgers(\n-            new LedgerManager.GarbageCollector() {\n-                @Override\n-                public void gc(long ledgerId) {\n-                    try {\n-                        bookie.ledgerCache.deleteLedger(ledgerId);\n-                    } catch (IOException e) {\n-                        LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n-                    }\n-                }\n-            });\n-        }\n-\n-        /**\n-         * Garbage collect those entry loggers which are not associated with any active ledgers\n-         */\n-        private void doGcEntryLogs() {\n-            // Loop through all of the entry logs and remove the non-active ledgers.\n-            for (Long entryLogId : entryLogs2LedgersMap.keySet()) {\n-                ConcurrentHashMap<Long, Boolean> entryLogLedgers = entryLogs2LedgersMap.get(entryLogId);\n-                for (Long entryLogLedger : entryLogLedgers.keySet()) {\n-                    // Remove the entry log ledger from the set if it isn't active.\n-                    if (!bookie.ledgerCache.activeLedgerManager.containsActiveLedger(entryLogLedger)) {\n-                        entryLogLedgers.remove(entryLogLedger);\n-                    }\n-                }\n-                if (entryLogLedgers.isEmpty()) {\n-                    // This means the entry log is not associated with any active ledgers anymore.\n-                    // We can remove this entry log file now.\n-                    LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n-                    BufferedChannel bc = channels.remove(entryLogId);\n-                    if (null != bc) {\n-                        // close its underlying file channel, so it could be deleted really\n-                        try {\n-                            bc.getFileChannel().close();\n-                        } catch (IOException ie) {\n-                            LOG.warn(\"Exception while closing garbage collected entryLog file : \", ie);\n-                        }\n-                    }\n-                    File entryLogFile;\n-                    try {\n-                        entryLogFile = findFile(entryLogId);\n-                    } catch (FileNotFoundException e) {\n-                        LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n-                                + entryLogId + \".log\");\n-                        continue;\n-                    }\n-                    entryLogFile.delete();\n-                    entryLogs2LedgersMap.remove(entryLogId);\n-                }\n-            }\n-        }\n+    synchronized long getCurrentLogId() {\n+        return logId;\n     }\n \n     /**\n-     * Creates a new log file with the given id.\n+     * Creates a new log file\n      */\n-    private void createLogId(long logId) throws IOException {\n+    private void createNewLog() throws IOException {\n         List<File> list = Arrays.asList(dirs);\n         Collections.shuffle(list);\n-        File firstDir = list.get(0);\n         if (logChannel != null) {\n             logChannel.flush(true);\n         }\n-        logChannel = new BufferedChannel(new RandomAccessFile(new File(firstDir, Long.toHexString(logId)+\".log\"), \"rw\").getChannel(), 64*1024);\n+\n+        // It would better not to overwrite existing entry log files\n+        File newLogFile = null;\n+        do {\n+            String logFileName = Long.toHexString(++logId) + \".log\";\n+            for (File dir : list) {\n+                newLogFile = new File(dir, logFileName);\n+                if (newLogFile.exists()) {\n+                    LOG.warn(\"Found existed entry log \" + newLogFile\n+                           + \" when trying to create it as a new log.\");\n+                    newLogFile = null;\n+                    break;\n+                }\n+            }\n+        } while (newLogFile == null);\n+\n+        logChannel = new BufferedChannel(new RandomAccessFile(newLogFile, \"rw\").getChannel(), 64*1024);\n         logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n         channels.put(logId, logChannel);\n         for(File f: dirs) {\n             setLastLogId(f, logId);\n         }\n-        // Extract all of the ledger ID's that comprise all of the entry logs\n-        // (except for the current new one which is still being written to).\n-        extractLedgersFromEntryLogs();\n+    }\n+\n+    /**\n+     * Remove entry log.\n+     *\n+     * @param entryLogId\n+     *          Entry Log File Id\n+     */\n+    protected boolean removeEntryLog(long entryLogId) {\n+        BufferedChannel bc = channels.remove(entryLogId);\n+        if (null != bc) {\n+            // close its underlying file channel, so it could be deleted really\n+            try {\n+                bc.getFileChannel().close();\n+            } catch (IOException ie) {\n+                LOG.warn(\"Exception while closing garbage collected entryLog file : \", ie);\n+            }\n+        }\n+        File entryLogFile;\n+        try {\n+            entryLogFile = findFile(entryLogId);\n+        } catch (FileNotFoundException e) {\n+            LOG.error(\"Trying to delete an entryLog file that could not be found: \"\n+                    + entryLogId + \".log\");\n+            return false;\n+        }\n+        if (!entryLogFile.delete()) {\n+            LOG.warn(\"Could not delete entry log file {}\", entryLogFile);\n+        }\n+        return true;\n     }\n \n     /**\n@@ -242,16 +212,47 @@ private void setLastLogId(File dir, long logId) throws IOException {\n             bw.flush();\n         } finally {\n             try {\n-                fos.close();\n+                bw.close();\n             } catch (IOException e) {\n             }\n         }\n     }\n \n+    private long getLastLogId(File dir) {\n+        long id = readLastLogId(dir);\n+        // read success\n+        if (id > 0) {\n+            return id;\n+        }\n+        // read failed, scan the ledger directories to find biggest log id\n+        File[] logFiles = dir.listFiles(new FileFilter() {\n+            @Override\n+            public boolean accept(File file) {\n+                return file.getName().endsWith(\".log\");\n+            }\n+        });\n+        List<Long> logs = new ArrayList<Long>();\n+        for (File lf : logFiles) {\n+            String idString = lf.getName().split(\"\\\\.\")[0];\n+            try {\n+                long lid = Long.parseLong(idString, 16);\n+                logs.add(lid);\n+            } catch (NumberFormatException nfe) {\n+            }\n+        }\n+        // no log file found in this directory\n+        if (0 == logs.size()) {\n+            return -1;\n+        }\n+        // order the collections\n+        Collections.sort(logs);\n+        return logs.get(logs.size() - 1);\n+    }\n+\n     /**\n      * reads id from the \"lastId\" file in the given directory.\n      */\n-    private long getLastLogId(File f) {\n+    private long readLastLogId(File f) {\n         FileInputStream fis;\n         try {\n             fis = new FileInputStream(new File(f, \"lastId\"));\n@@ -261,31 +262,27 @@ private long getLastLogId(File f) {\n         BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n         try {\n             String lastIdString = br.readLine();\n-            return Long.parseLong(lastIdString);\n+            return Long.parseLong(lastIdString, 16);\n         } catch (IOException e) {\n             return -1;\n         } catch(NumberFormatException e) {\n             return -1;\n         } finally {\n             try {\n-                fis.close();\n+                br.close();\n             } catch (IOException e) {\n             }\n         }\n     }\n \n-    private void openNewChannel() throws IOException {\n-        createLogId(++logId);\n-    }\n-\n     synchronized void flush() throws IOException {\n         if (logChannel != null) {\n             logChannel.flush(true);\n         }\n     }\n     synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         if (logChannel.position() + entry.remaining() + 4 > logSizeLimit) {\n-            openNewChannel();\n+            createNewLog();\n         }\n         ByteBuffer buff = ByteBuffer.allocate(4);\n         buff.putInt(entry.remaining());\n@@ -294,7 +291,7 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         long pos = logChannel.position();\n         logChannel.write(entry);\n         //logChannel.flush(false);\n-        somethingWritten = true;\n+\n         return (logId << 32L) | pos;\n     }\n \n@@ -318,7 +315,7 @@ synchronized long addEntry(long ledger, ByteBuffer entry) throws IOException {\n         sizeBuff.flip();\n         int entrySize = sizeBuff.getInt();\n         // entrySize does not include the ledgerId\n-        if (entrySize > 1024*1024) {\n+        if (entrySize > MB) {\n             LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n \n         }\n@@ -347,22 +344,36 @@ private BufferedChannel getChannelForLogId(long entryLogId) throws IOException {\n             return fc;\n         }\n         File file = findFile(entryLogId);\n-        FileChannel newFc = new RandomAccessFile(file, \"rw\").getChannel();\n+        // get channel is used to open an existing entry log file\n+        // it would be better to open using read mode\n+        FileChannel newFc = new RandomAccessFile(file, \"r\").getChannel();\n         // If the file already exists before creating a BufferedChannel layer above it,\n         // set the FileChannel's position to the end so the write buffer knows where to start.\n         newFc.position(newFc.size());\n-        synchronized (channels) {\n-            fc = channels.get(entryLogId);\n-            if (fc != null) {\n-                newFc.close();\n-                return fc;\n-            }\n-            fc = new BufferedChannel(newFc, 8192);\n-            channels.put(entryLogId, fc);\n+        fc = new BufferedChannel(newFc, 8192);\n+\n+        BufferedChannel oldfc = channels.putIfAbsent(entryLogId, fc);\n+        if (oldfc != null) {\n+            newFc.close();\n+            return oldfc;\n+        } else {\n             return fc;\n         }\n     }\n \n+    /**\n+     * Whether the log file exists or not.\n+     */\n+    boolean logExists(long logId) {\n+        for (File d : dirs) {\n+            File f = new File(d, Long.toHexString(logId) + \".log\");\n+            if (f.exists()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private File findFile(long logId) throws FileNotFoundException {\n         for(File d: dirs) {\n             File f = new File(d, Long.toHexString(logId)+\".log\");\n@@ -373,98 +384,89 @@ private File findFile(long logId) throws FileNotFoundException {\n         throw new FileNotFoundException(\"No file for log \" + Long.toHexString(logId));\n     }\n \n-    synchronized public boolean testAndClearSomethingWritten() {\n-        try {\n-            return somethingWritten;\n-        } finally {\n-            somethingWritten = false;\n-        }\n-    }\n-\n     /**\n-     * Method to read in all of the entry logs (those that we haven't done so yet),\n-     * and find the set of ledger ID's that make up each entry log file.\n+     * Scan entry log\n+     *\n+     * @param entryLogId\n+     *          Entry Log Id\n+     * @param scanner\n+     *          Entry Log Scanner\n+     * @throws IOException\n      */\n-    private void extractLedgersFromEntryLogs() throws IOException {\n-        // Extract it for every entry log except for the current one.\n-        // Entry Log ID's are just a long value that starts at 0 and increments\n-        // by 1 when the log fills up and we roll to a new one.\n+    protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOException {\n         ByteBuffer sizeBuff = ByteBuffer.allocate(4);\n+        ByteBuffer lidBuff = ByteBuffer.allocate(8);\n         BufferedChannel bc;\n-        for (long entryLogId = 0; entryLogId < logId; entryLogId++) {\n-            // Comb the current entry log file if it has not already been extracted.\n-            if (entryLogs2LedgersMap.containsKey(entryLogId)) {\n-                continue;\n+        // Get the BufferedChannel for the current entry log file\n+        try {\n+            bc = getChannelForLogId(entryLogId);\n+        } catch (IOException e) {\n+            LOG.warn(\"Failed to get channel to scan entry log: \" + entryLogId + \".log\");\n+            throw e;\n+        }\n+        // Start the read position in the current entry log file to be after\n+        // the header where all of the ledger entries are.\n+        long pos = LOGFILE_HEADER_SIZE;\n+        // Read through the entry log file and extract the ledger ID's.\n+        while (true) {\n+            // Check if we've finished reading the entry log file.\n+            if (pos >= bc.size()) {\n+                break;\n             }\n-            LOG.info(\"Extracting the ledgers from entryLogId: \" + entryLogId);\n-            // Get the BufferedChannel for the current entry log file\n-            try {\n-                bc = getChannelForLogId(entryLogId);\n-            } catch (FileNotFoundException e) {\n-                // If we can't find the entry log file, just log a warning message and continue.\n-                // This could be a deleted/garbage collected entry log.\n-                LOG.warn(\"Entry Log file not found in log directories: \" + entryLogId + \".log\");\n+            if (bc.read(sizeBuff, pos) != sizeBuff.capacity()) {\n+                throw new IOException(\"Short read for entry size from entrylog \" + entryLogId);\n+            }\n+            pos += 4;\n+            sizeBuff.flip();\n+            int entrySize = sizeBuff.getInt();\n+            if (entrySize > MB) {\n+                LOG.warn(\"Found large size entry of \" + entrySize + \" at location \" + pos + \" in \"\n+                        + entryLogId);\n+            }\n+            sizeBuff.clear();\n+            // try to read ledger id first\n+            if (bc.read(lidBuff, pos) != lidBuff.capacity()) {\n+                throw new IOException(\"Short read for ledger id from entrylog \" + entryLogId);\n+            }\n+            lidBuff.flip();\n+            long lid = lidBuff.getLong();\n+            lidBuff.clear();\n+            if (!scanner.accept(lid)) {\n+                // skip this entry\n+                pos += entrySize;\n                 continue;\n             }\n-            // Start the read position in the current entry log file to be after\n-            // the header where all of the ledger entries are.\n-            long pos = LOGFILE_HEADER_SIZE;\n-            ConcurrentHashMap<Long, Boolean> entryLogLedgers = new ConcurrentHashMap<Long, Boolean>();\n-            // Read through the entry log file and extract the ledger ID's.\n-            try {\n-                while (true) {\n-                    // Check if we've finished reading the entry log file.\n-                    if (pos >= bc.size()) {\n-                        break;\n-                    }\n-                    if (bc.read(sizeBuff, pos) != sizeBuff.capacity()) {\n-                        throw new IOException(\"Short read from entrylog \" + entryLogId);\n-                    }\n-                    pos += 4;\n-                    sizeBuff.flip();\n-                    int entrySize = sizeBuff.getInt();\n-                    if (entrySize > 1024 * 1024) {\n-                        LOG.error(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \"\n-                                + entryLogId);\n-                    }\n-                    byte data[] = new byte[entrySize];\n-                    ByteBuffer buff = ByteBuffer.wrap(data);\n-                    int rc = bc.read(buff, pos);\n-                    if (rc != data.length) {\n-                        throw new IOException(\"Short read for entryLog \" + entryLogId + \"@\" + pos + \"(\" + rc + \"!=\"\n-                                + data.length + \")\");\n-                    }\n-                    buff.flip();\n-                    long ledgerId = buff.getLong();\n-                    entryLogLedgers.put(ledgerId, true);\n-                    // Advance position to the next entry and clear sizeBuff.\n-                    pos += entrySize;\n-                    sizeBuff.clear();\n-                }\n-            } catch(IOException e) {\n-              LOG.info(\"Premature exception when processing \" + entryLogId + \n-                       \"recovery will take care of the problem\", e);\n+            // read the entry\n+            byte data[] = new byte[entrySize];\n+            ByteBuffer buff = ByteBuffer.wrap(data);\n+            int rc = bc.read(buff, pos);\n+            if (rc != data.length) {\n+                throw new IOException(\"Short read for ledger entry from entryLog \" + entryLogId\n+                                    + \"@\" + pos + \"(\" + rc + \"!=\" + data.length + \")\");\n             }\n-            LOG.info(\"Retrieved all ledgers that comprise entryLogId: \" + entryLogId + \", values: \" + entryLogLedgers);\n-            entryLogs2LedgersMap.put(entryLogId, entryLogLedgers);\n+            buff.flip();\n+            // process the entry\n+            scanner.process(lid, buff);\n+            // Advance position to the next entry\n+            pos += entrySize;\n         }\n     }\n \n     /**\n-     * Shutdown method to gracefully stop all threads spawned in this class and exit.\n-     *\n-     * @throws InterruptedException if there is an exception stopping threads.\n+     * Shutdown method to gracefully stop entry logger.\n      */\n-    public void shutdown() throws InterruptedException {\n-        gcThread.running = false;\n-        gcThread.interrupt();\n-        gcThread.join();\n+    public void shutdown() {\n         // since logChannel is buffered channel, do flush when shutting down\n         try {\n             flush();\n+            logChannel.getFileChannel().close();\n         } catch (IOException ie) {\n             // we have no idea how to avoid io exception during shutting down, so just ignore it\n             LOG.error(\"Error flush entry log during shutting down, which may cause entry log corrupted.\", ie);\n+        } finally {\n+            if (logChannel.getFileChannel().isOpen()) {\n+                IOUtils.close(LOG, logChannel.getFileChannel());\n+            }\n         }\n     }\n "},{"sha":"b683c7b546561ea4df979bca41835e0a8d384fa8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+/**\n+ * Exit code used to exit bookie server\n+ */\n+public class ExitCode {\n+    // normal quit\n+    public final static int OK                  = 0;\n+    // invalid configuration\n+    public final static int INVALID_CONF        = 1;\n+    // exception running bookie server\n+    public final static int SERVER_EXCEPTION    = 2;\n+    // zookeeper is expired\n+    public final static int ZK_EXPIRED          = 3;\n+    // register bookie on zookeeper failed\n+    public final static int ZK_REG_FAIL         = 4;\n+    // exception running bookie\n+    public final static int BOOKIE_EXCEPTION    = 5;\n+}"},{"sha":"ab5405839915076809a1b1d2e04a5371ff81fbbf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":114,"deletions":63,"changes":177,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -25,6 +25,7 @@\n import java.io.IOException;\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n+import java.nio.BufferUnderflowException;\n import java.nio.channels.FileChannel;\n \n import org.slf4j.Logger;\n@@ -40,7 +41,7 @@\n  * <b>Header</b> is formated as below:\n  * <pre>&lt;magic bytes&gt;&lt;len of master key&gt;&lt;master key&gt;</pre>\n  * <ul>\n- * <li>magic bytes: 8 bytes, 'BKLE\\0\\0\\0\\0'\n+ * <li>magic bytes: 4 bytes, 'BKLE', version: 4 bytes\n  * <li>len of master key: indicates length of master key. -1 means no master key stored in header.\n  * <li>master key: master key\n  * </ul>\n@@ -54,78 +55,107 @@\n \n     private FileChannel fc;\n     private final File lf;\n+    byte[] masterKey;\n+\n     /**\n      * The fingerprint of a ledger index file\n      */\n-    private byte header[] = \"BKLE\\0\\0\\0\\0\".getBytes();\n+    static final public int signature = ByteBuffer.wrap(\"BKLE\".getBytes()).getInt();\n+    static final public int headerVersion = 0;\n+\n     static final long START_OF_DATA = 1024;\n     private long size;\n     private int useCount;\n     private boolean isClosed;\n-    public FileInfo(File lf) throws IOException {\n+\n+    public FileInfo(File lf, byte[] masterKey) throws IOException {\n         this.lf = lf;\n-        fc = new RandomAccessFile(lf, \"rws\").getChannel();\n-        size = fc.size();\n-        if (size == 0) {\n-            fc.write(ByteBuffer.wrap(header));\n-            // write NO_MASTER_KEY, which means there is no master key\n-            ByteBuffer buf = ByteBuffer.allocate(4);\n-            buf.putInt(NO_MASTER_KEY);\n-            buf.flip();\n-            fc.write(buf);\n-        }\n+\n+        this.masterKey = masterKey;\n     }\n \n-    /**\n-     * Write master key to index file header\n-     *\n-     * @param masterKey master key to store\n-     * @return void\n-     * @throws IOException\n-     */\n-    synchronized public void writeMasterKey(byte[] masterKey) throws IOException {\n-        // write master key\n-        if (masterKey == null ||\n-            masterKey.length + 4 + header.length > START_OF_DATA) {\n-            throw new IOException(\"master key is more than \" + (START_OF_DATA - 4 - header.length));\n-        }\n+    synchronized public void readHeader() throws IOException {\n+        if (lf.exists()) {\n+            if (fc != null) {\n+                return;\n+            }\n \n-        int len = masterKey.length;\n-        ByteBuffer lenBuf = ByteBuffer.allocate(4);\n-        lenBuf.putInt(len);\n-        lenBuf.flip();\n-        fc.position(header.length);\n-        fc.write(lenBuf);\n-        fc.write(ByteBuffer.wrap(masterKey));\n+            fc = new RandomAccessFile(lf, \"rw\").getChannel();\n+            size = fc.size();\n+\n+            // avoid hang on reading partial index\n+            ByteBuffer bb = ByteBuffer.allocate((int)(Math.min(size, START_OF_DATA)));\n+            while(bb.hasRemaining()) {\n+                fc.read(bb);\n+            }\n+            bb.flip();\n+            if (bb.getInt() != signature) {\n+                throw new IOException(\"Missing ledger signature\");\n+            }\n+            int version = bb.getInt();\n+            if (version != headerVersion) {\n+                throw new IOException(\"Incompatible ledger version \" + version);\n+            }\n+            int length = bb.getInt();\n+            if (length < 0) {\n+                throw new IOException(\"Length \" + length + \" is invalid\");\n+            } else if (length > bb.remaining()) {\n+                throw new BufferUnderflowException();\n+            }\n+            masterKey = new byte[length];\n+            bb.get(masterKey);\n+        } else {\n+            throw new IOException(\"Ledger index file does not exist\");\n+        }\n     }\n \n-    /**\n-     * Read master key\n-     *\n-     * @return master key. null means no master key stored in index header\n-     * @throws IOException\n-     */\n-    synchronized public byte[] readMasterKey() throws IOException {\n-        ByteBuffer lenBuf = ByteBuffer.allocate(4);\n-        int total = readAbsolute(lenBuf, header.length);\n-        if (total != 4) {\n-            throw new IOException(\"Short read during reading master key length\");\n+    synchronized private void checkOpen(boolean create) throws IOException {\n+        if (fc != null) {\n+            return;\n         }\n-        lenBuf.rewind();\n-        int len = lenBuf.getInt();\n-        if (len == NO_MASTER_KEY) {\n-            return null;\n+        boolean exists = lf.exists();\n+        if (masterKey == null && !exists) {\n+            throw new IOException(lf + \" not found\");\n         }\n \n-        byte[] masterKey = new byte[len];\n-        total = readAbsolute(ByteBuffer.wrap(masterKey), header.length + 4);\n-        if (total != len) {\n-            throw new IOException(\"Short read during reading master key\");\n+        if (!exists) { \n+            if (create) {\n+                // delayed the creation of parents directories\n+                checkParents(lf);\n+                fc = new RandomAccessFile(lf, \"rw\").getChannel();\n+                size = fc.size();\n+                if (size == 0) {\n+                    writeHeader();\n+                }\n+            }\n+        } else {\n+            try {\n+                readHeader();\n+            } catch (BufferUnderflowException buf) {\n+                LOG.warn(\"Exception when reading header of {} : {}\", lf, buf);\n+                if (null != masterKey) {\n+                    LOG.warn(\"Attempting to write header of {} again.\", lf);\n+                    writeHeader();\n+                } else {\n+                    throw new IOException(\"Error reading header \" + lf);\n+                }\n+            }\n         }\n-        return masterKey;\n     }\n \n-    synchronized public long size() {\n+    private void writeHeader() throws IOException {\n+        ByteBuffer bb = ByteBuffer.allocate((int)START_OF_DATA);\n+        bb.putInt(signature);\n+        bb.putInt(headerVersion);\n+        bb.putInt(masterKey.length);\n+        bb.put(masterKey);\n+        bb.rewind();\n+        fc.position(0);\n+        fc.write(bb);\n+    }\n+\n+    synchronized public long size() throws IOException {\n+        checkOpen(false);\n         long rc = size-START_OF_DATA;\n         if (rc < 0) {\n             rc = 0;\n@@ -138,6 +168,7 @@ synchronized public int read(ByteBuffer bb, long position) throws IOException {\n     }\n \n     private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n+        checkOpen(false);\n         int total = 0;\n         while(bb.remaining() > 0) {\n             int rc = fc.read(bb, start);\n@@ -151,14 +182,23 @@ private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n         return total;\n     }\n \n-    synchronized public void close() throws IOException {\n+    /**\n+     * Close a file info\n+     *\n+     * @param force\n+     *          if set to true, the index is forced to create before closed,\n+     *          if set to false, the index is not forced to create.\n+     */\n+    synchronized public void close(boolean force) throws IOException {\n         isClosed = true;\n-        if (useCount == 0) {\n+        checkOpen(force);\n+        if (useCount == 0 && fc != null) {\n             fc.close();\n         }\n     }\n \n     synchronized public long write(ByteBuffer[] buffs, long position) throws IOException {\n+        checkOpen(true);\n         long total = 0;\n         try {\n             fc.position(position+START_OF_DATA);\n@@ -170,6 +210,7 @@ synchronized public long write(ByteBuffer[] buffs, long position) throws IOExcep\n                 total += rc;\n             }\n         } finally {\n+            fc.force(true);\n             long newsize = position+START_OF_DATA+total;\n             if (newsize > size) {\n                 size = newsize;\n@@ -178,13 +219,18 @@ synchronized public long write(ByteBuffer[] buffs, long position) throws IOExcep\n         return total;\n     }\n \n+    synchronized public byte[] getMasterKey() throws IOException {\n+        checkOpen(false);\n+        return masterKey;\n+    }\n+\n     synchronized public void use() {\n         useCount++;\n     }\n \n     synchronized public void release() {\n         useCount--;\n-        if (isClosed && useCount == 0) {\n+        if (isClosed && useCount == 0 && fc != null) {\n             try {\n                 fc.close();\n             } catch (IOException e) {\n@@ -193,12 +239,17 @@ synchronized public void release() {\n         }\n     }\n \n-    /**\n-     * Getter to a handle on the actual ledger index file.\n-     * This is used when we are deleting a ledger and want to physically remove the index file.\n-     */\n-    File getFile() {\n-        return lf;\n+    public boolean delete() {\n+        return lf.delete();\n     }\n \n+    static final private void checkParents(File f) throws IOException {\n+        File parent = f.getParentFile();\n+        if (parent.exists()) {\n+            return;\n+        }\n+        if (parent.mkdirs() == false) {\n+            throw new IOException(\"Counldn't mkdirs for \" + parent);\n+        }\n+    }\n }"},{"sha":"7ca3104a136ea0cb46109d3a20f116129555befc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","status":"added","additions":379,"deletions":0,"changes":379,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,379 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import org.apache.bookkeeper.util.HardLink;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.cli.BasicParser;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.ParseException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Scanner;\n+import java.util.NoSuchElementException;\n+\n+import java.net.MalformedURLException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.commons.configuration.ConfigurationException;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.KeeperException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Application for upgrading the bookkeeper filesystem\n+ * between versions\n+ */\n+public class FileSystemUpgrade {\n+    static Logger LOG = LoggerFactory.getLogger(FileSystemUpgrade.class);\n+\n+    static FilenameFilter BOOKIE_FILES_FILTER = new FilenameFilter() {\n+            private boolean containsIndexFiles(File dir, String name) {\n+                if (name.endsWith(\".idx\")) {\n+                    return true;\n+                }\n+\n+                try {\n+                    Long.parseLong(name, 16);\n+                    File d = new File(dir, name);\n+                    if (d.isDirectory()) {\n+                        String[] files = d.list();\n+                        for (String f : files) {\n+                            if (containsIndexFiles(d, f)) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    return false;\n+                }\n+                return false;\n+            }\n+\n+            public boolean accept(File dir, String name) {\n+                if (name.endsWith(\".txn\") || name.endsWith(\".log\")\n+                    || name.equals(\"lastId\") || name.equals(\"lastMark\")) {\n+                    return true;\n+                }\n+                if (containsIndexFiles(dir, name)) {\n+                    return true;\n+                }\n+                return false;\n+            }\n+        };\n+\n+    private static List<File> getAllDirectories(ServerConfiguration conf) {\n+        List<File> dirs = new ArrayList<File>();\n+        dirs.add(conf.getJournalDir());\n+        for (File d: conf.getLedgerDirs()) {\n+            dirs.add(d);\n+        }\n+        return dirs;\n+    }\n+\n+    private static int detectPreviousVersion(File directory) throws IOException {\n+        String[] files = directory.list(BOOKIE_FILES_FILTER);\n+        File v2versionFile = new File(directory, Cookie.VERSION_FILENAME);\n+        if (files.length == 0 && !v2versionFile.exists()) { // no old data, so we're ok\n+            return Cookie.CURRENT_COOKIE_LAYOUT_VERSION;\n+        }\n+\n+        if (!v2versionFile.exists()) {\n+            return 1;\n+        }\n+        Scanner s = new Scanner(v2versionFile);\n+        try {\n+            return s.nextInt();\n+        } catch (NoSuchElementException nse) {\n+            LOG.error(\"Couldn't parse version file \" + v2versionFile , nse);\n+            throw new IOException(\"Couldn't parse version file\", nse);\n+        } catch (IllegalStateException ise) {\n+            LOG.error(\"Error reading file \" + v2versionFile, ise);\n+            throw new IOException(\"Error reading version file\", ise);\n+        } finally {\n+            s.close();\n+        }\n+    }\n+\n+    private static ZooKeeper newZookeeper(final ServerConfiguration conf)\n+            throws BookieException.UpgradeException {\n+        try {\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            ZooKeeper zk = new ZooKeeper(conf.getZkServers(), conf.getZkTimeout(),\n+                    new Watcher() {\n+                        @Override\n+                        public void process(WatchedEvent event) {\n+                            // handle session disconnects and expires\n+                            if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n+                                latch.countDown();\n+                            }\n+                        }\n+                    });\n+            if (!latch.await(conf.getZkTimeout()*2, TimeUnit.MILLISECONDS)) {\n+                zk.close();\n+                throw new BookieException.UpgradeException(\"Couldn't connect to zookeeper\");\n+            }\n+            return zk;\n+        } catch (InterruptedException ie) {\n+            throw new BookieException.UpgradeException(ie);\n+        } catch (IOException ioe) {\n+            throw new BookieException.UpgradeException(ioe);\n+        }\n+    }\n+\n+    private static void linkIndexDirectories(File srcPath, File targetPath) throws IOException {\n+        String[] files = srcPath.list();\n+\n+        for (String f : files) {\n+            if (f.endsWith(\".idx\")) { // this is an index dir, create the links\n+                if (!targetPath.mkdirs()) {\n+                    throw new IOException(\"Could not create target path [\"+targetPath+\"]\");\n+                }\n+                HardLink.createHardLinkMult(srcPath, files, targetPath);\n+                return;\n+            }\n+            File newSrcPath = new File(srcPath, f);\n+            if (newSrcPath.isDirectory()) {\n+                try {\n+                    Long.parseLong(f, 16);\n+                    linkIndexDirectories(newSrcPath, new File(targetPath, f));\n+                } catch (NumberFormatException nfe) {\n+                    // filename does not parse to a hex Long, so\n+                    // it will not contain idx files. Ignoring\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void upgrade(ServerConfiguration conf)\n+            throws BookieException.UpgradeException, InterruptedException {\n+        LOG.info(\"Upgrading...\");\n+\n+        ZooKeeper zk = newZookeeper(conf);\n+        try {\n+            Map<File,File> deferredMoves = new HashMap<File, File>();\n+            Cookie c = Cookie.generateCookie(conf);\n+            for (File d : getAllDirectories(conf)) {\n+                LOG.info(\"Upgrading {}\", d);\n+                int version = detectPreviousVersion(d);\n+                if (version == Cookie.CURRENT_COOKIE_LAYOUT_VERSION) {\n+                    LOG.info(\"Directory is current, no need to upgrade\");\n+                }\n+                try {\n+                    File curDir = new File(d, Bookie.CURRENT_DIR);\n+                    File tmpDir = new File(d, \"upgradeTmp.\" + System.nanoTime());\n+                    deferredMoves.put(curDir, tmpDir);\n+                    if (!tmpDir.mkdirs()) {\n+                        throw new BookieException.UpgradeException(\"Could not create temporary directory \" + tmpDir);\n+                    }\n+                    c.writeToDirectory(tmpDir);\n+\n+                    String[] files = d.list(new FilenameFilter() {\n+                            public boolean accept(File dir, String name) {\n+                                return BOOKIE_FILES_FILTER.accept(dir, name)\n+                                    && !(new File(dir, name).isDirectory());\n+                            }\n+                        });\n+                    HardLink.createHardLinkMult(d, files, tmpDir);\n+\n+                    linkIndexDirectories(d, tmpDir);\n+                } catch (IOException ioe) {\n+                    LOG.error(\"Error upgrading {}\", d);\n+                    throw new BookieException.UpgradeException(ioe);\n+                }\n+            }\n+\n+            for (Map.Entry<File,File> e : deferredMoves.entrySet()) {\n+                try {\n+                    FileUtils.moveDirectory(e.getValue(), e.getKey());\n+                } catch (IOException ioe) {\n+                    String err = String.format(\"Error moving upgraded directories into place %s -> %s \",\n+                                               e.getValue(), e.getKey());\n+                    LOG.error(err, ioe);\n+                    throw new BookieException.UpgradeException(ioe);\n+                }\n+            }\n+            try {\n+                c.writeToZooKeeper(zk, conf);\n+            } catch (KeeperException ke) {\n+                LOG.error(\"Error writing cookie to zookeeper\");\n+                throw new BookieException.UpgradeException(ke);\n+            }\n+        } catch (IOException ioe) {\n+            throw new BookieException.UpgradeException(ioe);\n+        } finally {\n+            zk.close();\n+        }\n+        LOG.info(\"Done\");\n+    }\n+\n+    public static void finalizeUpgrade(ServerConfiguration conf)\n+            throws BookieException.UpgradeException, InterruptedException {\n+        LOG.info(\"Finalizing upgrade...\");\n+        // verify that upgrade is correct\n+        for (File d : getAllDirectories(conf)) {\n+            LOG.info(\"Finalizing {}\", d);\n+            try {\n+                int version = detectPreviousVersion(d);\n+                if (version < 3) {\n+                    if (version == 2) {\n+                        File v2versionFile = new File(d, Cookie.VERSION_FILENAME);\n+                        if (!v2versionFile.delete()) {\n+                            LOG.warn(\"Could not delete old version file {}\", v2versionFile);\n+                        }\n+                    }\n+                    File[] files = d.listFiles(BOOKIE_FILES_FILTER);\n+                    for (File f : files) {\n+                        if (f.isDirectory()) {\n+                            FileUtils.deleteDirectory(f);\n+                        } else{\n+                            if (!f.delete()) {\n+                                LOG.warn(\"Could not delete {}\", f);\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ioe) {\n+                LOG.error(\"Error finalizing {}\", d);\n+                throw new BookieException.UpgradeException(ioe);\n+            }\n+        }\n+        // noop at the moment\n+        LOG.info(\"Done\");\n+    }\n+\n+    public static void rollback(ServerConfiguration conf)\n+            throws BookieException.UpgradeException, InterruptedException {\n+        LOG.info(\"Rolling back upgrade...\");\n+        ZooKeeper zk = newZookeeper(conf);\n+        try {\n+            for (File d : getAllDirectories(conf)) {\n+                LOG.info(\"Rolling back {}\", d);\n+                try {\n+                    // ensure there is a previous version before rollback\n+                    int version = detectPreviousVersion(d);\n+\n+                    if (version <= Cookie.CURRENT_COOKIE_LAYOUT_VERSION) {\n+                        File curDir = new File(d, Bookie.CURRENT_DIR);\n+                        FileUtils.deleteDirectory(curDir);\n+                    } else {\n+                        throw new BookieException.UpgradeException(\n+                                \"Cannot rollback as previous data does not exist\");\n+                    }\n+                } catch (IOException ioe) {\n+                    LOG.error(\"Error rolling back {}\", d);\n+                    throw new BookieException.UpgradeException(ioe);\n+                }\n+            }\n+            try {\n+                Cookie c = Cookie.readFromZooKeeper(zk, conf);\n+                c.deleteFromZooKeeper(zk, conf);\n+            } catch (KeeperException ke) {\n+                LOG.error(\"Error deleting cookie from ZooKeeper\");\n+                throw new BookieException.UpgradeException(ke);\n+            } catch (IOException ioe) {\n+                LOG.error(\"I/O Error deleting cookie from ZooKeeper\");\n+                throw new BookieException.UpgradeException(ioe);\n+            }\n+        } finally {\n+            zk.close();\n+        }\n+        LOG.info(\"Done\");\n+    }\n+\n+    private static void printHelp(Options opts) {\n+        HelpFormatter hf = new HelpFormatter();\n+        hf.printHelp(\"FileSystemUpgrade [options]\", opts);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        org.apache.log4j.Logger root = org.apache.log4j.Logger.getRootLogger();\n+        root.addAppender(new org.apache.log4j.ConsoleAppender(\n+                                 new org.apache.log4j.PatternLayout(\"%-5p [%t]: %m%n\")));\n+        root.setLevel(org.apache.log4j.Level.ERROR);\n+        root.getLogger(FileSystemUpgrade.class).setLevel(org.apache.log4j.Level.INFO);\n+\n+        final Options opts = new Options();\n+        opts.addOption(\"c\", \"conf\", true, \"Configuration for Bookie\");\n+        opts.addOption(\"u\", \"upgrade\", false, \"Upgrade bookie directories\");\n+        opts.addOption(\"f\", \"finalize\", false, \"Finalize upgrade\");\n+        opts.addOption(\"r\", \"rollback\", false, \"Rollback upgrade\");\n+        opts.addOption(\"h\", \"help\", false, \"Print help message\");\n+\n+        BasicParser parser = new BasicParser();\n+        CommandLine cmdLine = parser.parse(opts, args);\n+        if (cmdLine.hasOption(\"h\")) {\n+            printHelp(opts);\n+            return;\n+        }\n+\n+        if (!cmdLine.hasOption(\"c\")) {\n+            String err = \"Cannot upgrade without configuration\";\n+            LOG.error(err);\n+            printHelp(opts);\n+            throw new IllegalArgumentException(err);\n+        }\n+\n+        String confFile = cmdLine.getOptionValue(\"c\");\n+        ServerConfiguration conf = new ServerConfiguration();\n+        try {\n+            conf.loadConf(new File(confFile).toURI().toURL());\n+        } catch (MalformedURLException mue) {\n+            LOG.error(\"Could not open configuration file \" + confFile, mue);\n+            throw new IllegalArgumentException();\n+        } catch (ConfigurationException ce) {\n+            LOG.error(\"Invalid configuration file \" + confFile, ce);\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (cmdLine.hasOption(\"u\")) {\n+            upgrade(conf);\n+        } else if (cmdLine.hasOption(\"r\")) {\n+            rollback(conf);\n+        } else if (cmdLine.hasOption(\"f\")) {\n+            finalizeUpgrade(conf);\n+        } else {\n+            String err = \"Must specify -upgrade, -finalize or -rollback\";\n+            LOG.error(err);\n+            printHelp(opts);\n+            throw new IllegalArgumentException(err);\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"139e1c3590722e5919f8481525aeb46fc87ccb95","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"added","additions":509,"deletions":0,"changes":509,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,509 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Comparator;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+/**\n+ * This is the garbage collector thread that runs in the background to\n+ * remove any entry log files that no longer contains any active ledger.\n+ */\n+public class GarbageCollectorThread extends Thread {\n+    private static final Logger LOG = LoggerFactory.getLogger(GarbageCollectorThread.class);\n+\n+    private static final int SECOND = 1000;\n+\n+    // Maps entry log files to the set of ledgers that comprise the file and the size usage per ledger\n+    private Map<Long, EntryLogMetadata> entryLogMetaMap = new ConcurrentHashMap<Long, EntryLogMetadata>();\n+\n+    // This is how often we want to run the Garbage Collector Thread (in milliseconds).\n+    final long gcWaitTime;\n+\n+    // Compaction parameters\n+    boolean enableMinorCompaction = false;\n+    final double minorCompactionThreshold;\n+    final long minorCompactionInterval;\n+\n+    boolean enableMajorCompaction = false;\n+    final double majorCompactionThreshold;\n+    final long majorCompactionInterval;\n+\n+    long lastMinorCompactionTime;\n+    long lastMajorCompactionTime;\n+\n+    // Entry Logger Handle\n+    final EntryLogger entryLogger;\n+    final EntryLogScanner scanner;\n+\n+    // Ledger Cache Handle\n+    final LedgerCache ledgerCache;\n+\n+    final LedgerManager ledgerManager;\n+\n+    // flag to ensure gc thread will not be interrupted during compaction\n+    // to reduce the risk getting entry log corrupted\n+    final AtomicBoolean compacting = new AtomicBoolean(false);\n+\n+    volatile boolean running = true;\n+\n+    // track the last scanned successfully log id\n+    long scannedLogId = 0;\n+\n+    /**\n+     * A scanner wrapper to check whether a ledger is alive in an entry log file\n+     */\n+    class CompactionScanner implements EntryLogScanner {\n+        EntryLogMetadata meta;\n+\n+        public CompactionScanner(EntryLogMetadata meta) {\n+            this.meta = meta;\n+        }\n+\n+        @Override\n+        public boolean accept(long ledgerId) {\n+            return meta.containsLedger(ledgerId) && scanner.accept(ledgerId);\n+        }\n+\n+        @Override\n+        public void process(long ledgerId, ByteBuffer entry) throws IOException {\n+            scanner.process(ledgerId, entry);\n+        }\n+    }\n+\n+\n+    /**\n+     * Create a garbage collector thread.\n+     *\n+     * @param conf\n+     *          Server Configuration Object.\n+     * @throws IOException\n+     */\n+    public GarbageCollectorThread(ServerConfiguration conf,\n+                                  LedgerCache ledgerCache,\n+                                  EntryLogger entryLogger,\n+                                  LedgerManager ledgerManager,\n+                                  EntryLogScanner scanner)\n+        throws IOException {\n+        super(\"GarbageCollectorThread\");\n+\n+        this.ledgerCache = ledgerCache;\n+        this.entryLogger = entryLogger;\n+        this.ledgerManager = ledgerManager;\n+        this.scanner = scanner;\n+\n+        this.gcWaitTime = conf.getGcWaitTime();\n+        // compaction parameters\n+        minorCompactionThreshold = conf.getMinorCompactionThreshold();\n+        minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;\n+        majorCompactionThreshold = conf.getMajorCompactionThreshold();\n+        majorCompactionInterval = conf.getMajorCompactionInterval() * SECOND;\n+\n+        if (minorCompactionInterval > 0 && minorCompactionThreshold > 0) {\n+            if (minorCompactionThreshold > 1.0f) {\n+                throw new IOException(\"Invalid minor compaction threshold \"\n+                                    + minorCompactionThreshold);\n+            }\n+            if (minorCompactionInterval <= gcWaitTime) {\n+                throw new IOException(\"Too short minor compaction interval : \"\n+                                    + minorCompactionInterval);\n+            }\n+            enableMinorCompaction = true;\n+        }\n+\n+        if (majorCompactionInterval > 0 && majorCompactionThreshold > 0) {\n+            if (majorCompactionThreshold > 1.0f) {\n+                throw new IOException(\"Invalid major compaction threshold \"\n+                                    + majorCompactionThreshold);\n+            }\n+            if (majorCompactionInterval <= gcWaitTime) {\n+                throw new IOException(\"Too short major compaction interval : \"\n+                                    + majorCompactionInterval);\n+            }\n+            enableMajorCompaction = true;\n+        }\n+\n+        if (enableMinorCompaction && enableMajorCompaction) {\n+            if (minorCompactionInterval >= majorCompactionInterval ||\n+                minorCompactionThreshold >= majorCompactionThreshold) {\n+                throw new IOException(\"Invalid minor/major compaction settings : minor (\"\n+                                    + minorCompactionThreshold + \", \" + minorCompactionInterval\n+                                    + \"), major (\" + majorCompactionThreshold + \", \"\n+                                    + majorCompactionInterval + \")\");\n+            }\n+        }\n+\n+        LOG.info(\"Minor Compaction : enabled=\" + enableMinorCompaction + \", threshold=\"\n+               + minorCompactionThreshold + \", interval=\" + minorCompactionInterval);\n+        LOG.info(\"Major Compaction : enabled=\" + enableMajorCompaction + \", threshold=\"\n+               + majorCompactionThreshold + \", interval=\" + majorCompactionInterval);\n+\n+        lastMinorCompactionTime = lastMajorCompactionTime = System.currentTimeMillis();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            synchronized (this) {\n+                try {\n+                    wait(gcWaitTime);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    continue;\n+                }\n+            }\n+\n+            // Extract all of the ledger ID's that comprise all of the entry logs\n+            // (except for the current new one which is still being written to).\n+            entryLogMetaMap = extractMetaFromEntryLogs(entryLogMetaMap);\n+\n+            // gc inactive/deleted ledgers\n+            doGcLedgers();\n+\n+            // gc entry logs\n+            doGcEntryLogs();\n+\n+            long curTime = System.currentTimeMillis();\n+            if (enableMajorCompaction &&\n+                curTime - lastMajorCompactionTime > majorCompactionInterval) {\n+                // enter major compaction\n+                LOG.info(\"Enter major compaction\");\n+                doCompactEntryLogs(majorCompactionThreshold);\n+                lastMajorCompactionTime = System.currentTimeMillis();\n+                // also move minor compaction time\n+                lastMinorCompactionTime = lastMajorCompactionTime;\n+                continue;\n+            }\n+\n+            if (enableMinorCompaction &&\n+                curTime - lastMinorCompactionTime > minorCompactionInterval) {\n+                // enter minor compaction\n+                LOG.info(\"Enter minor compaction\");\n+                doCompactEntryLogs(minorCompactionThreshold);\n+                lastMinorCompactionTime = System.currentTimeMillis();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Do garbage collection ledger index files\n+     */\n+    private void doGcLedgers() {\n+        ledgerManager.garbageCollectLedgers(\n+        new LedgerManager.GarbageCollector() {\n+            @Override\n+            public void gc(long ledgerId) {\n+                try {\n+                    ledgerCache.deleteLedger(ledgerId);\n+                } catch (IOException e) {\n+                    LOG.error(\"Exception when deleting the ledger index file on the Bookie: \", e);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Garbage collect those entry loggers which are not associated with any active ledgers\n+     */\n+    private void doGcEntryLogs() {\n+        // Loop through all of the entry logs and remove the non-active ledgers.\n+        for (Long entryLogId : entryLogMetaMap.keySet()) {\n+            EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n+            for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n+                // Remove the entry log ledger from the set if it isn't active.\n+                if (!ledgerManager.containsActiveLedger(entryLogLedger)) {\n+                    meta.removeLedger(entryLogLedger);\n+                }\n+            }\n+            if (meta.isEmpty()) {\n+                // This means the entry log is not associated with any active ledgers anymore.\n+                // We can remove this entry log file now.\n+                LOG.info(\"Deleting entryLogId \" + entryLogId + \" as it has no active ledgers!\");\n+                removeEntryLog(entryLogId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compact entry logs if necessary.\n+     *\n+     * <p>\n+     * Compaction will be executed from low unused space to high unused space.\n+     * Those entry log files whose remaining size percentage is higher than threshold\n+     * would not be compacted.\n+     * </p>\n+     */\n+    private void doCompactEntryLogs(double threshold) {\n+        LOG.info(\"Do compaction to compact those files lower than \" + threshold);\n+        // sort the ledger meta by occupied unused space\n+        Comparator<EntryLogMetadata> sizeComparator = new Comparator<EntryLogMetadata>() {\n+            @Override\n+            public int compare(EntryLogMetadata m1, EntryLogMetadata m2) {\n+                long unusedSize1 = m1.totalSize - m1.remainingSize;\n+                long unusedSize2 = m2.totalSize - m2.remainingSize;\n+                if (unusedSize1 > unusedSize2) {\n+                    return -1;\n+                } else if (unusedSize1 < unusedSize2) {\n+                    return 1;\n+                } else {\n+                    return 0;\n+                }\n+            }\n+        };\n+        List<EntryLogMetadata> logsToCompact = new ArrayList();\n+        logsToCompact.addAll(entryLogMetaMap.values());\n+        Collections.sort(logsToCompact, sizeComparator);\n+        for (EntryLogMetadata meta : logsToCompact) {\n+            if (meta.getUsage() >= threshold) {\n+                break;\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Compacting entry log \" + meta.entryLogId + \" below threshold \"\n+                        + threshold + \".\");\n+            }\n+            compactEntryLog(meta.entryLogId);\n+            if (!running) { // if gc thread is not running, stop compaction\n+                return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the garbage collector thread.\n+     *\n+     * @throws InterruptedException if there is an exception stopping gc thread.\n+     */\n+    public void shutdown() throws InterruptedException {\n+        this.running = false;\n+        if (compacting.compareAndSet(false, true)) {\n+            // if setting compacting flag succeed, means gcThread is not compacting now\n+            // it is safe to interrupt itself now\n+            this.interrupt();\n+        }\n+        this.join();\n+    }\n+\n+    /**\n+     * Remove entry log.\n+     *\n+     * @param entryLogId\n+     *          Entry Log File Id\n+     */\n+    private void removeEntryLog(long entryLogId) {\n+        // remove entry log file successfully\n+        if (entryLogger.removeEntryLog(entryLogId)) {\n+            entryLogMetaMap.remove(entryLogId);\n+        }\n+    }\n+\n+    /**\n+     * Compact an entry log.\n+     *\n+     * @param entryLogId\n+     *          Entry Log File Id\n+     */\n+    protected void compactEntryLog(long entryLogId) {\n+        EntryLogMetadata entryLogMeta = entryLogMetaMap.get(entryLogId);\n+        if (null == entryLogMeta) {\n+            LOG.warn(\"Can't get entry log meta when compacting entry log \" + entryLogId + \".\");\n+            return;\n+        }\n+\n+        // Similar with Sync Thread\n+        // try to mark compacting flag to make sure it would not be interrupted\n+        // by shutdown during compaction. otherwise it will receive\n+        // ClosedByInterruptException which may cause index file & entry logger\n+        // closed and corrupted.\n+        if (!compacting.compareAndSet(false, true)) {\n+            // set compacting flag failed, means compacting is true now\n+            // indicates another thread wants to interrupt gc thread to exit\n+            return;\n+        }\n+\n+        LOG.info(\"Compacting entry log : \" + entryLogId);\n+\n+        try {\n+            entryLogger.scanEntryLog(entryLogId, new CompactionScanner(entryLogMeta));\n+            // after moving entries to new entry log, remove this old one\n+            removeEntryLog(entryLogId);\n+        } catch (IOException e) {\n+            LOG.info(\"Premature exception when compacting \" + entryLogId, e);\n+        } finally {\n+            // clear compacting flag\n+            compacting.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Records the total size, remaining size and the set of ledgers that comprise a entry log.\n+     */\n+    static class EntryLogMetadata {\n+        long entryLogId;\n+        long totalSize;\n+        long remainingSize;\n+        ConcurrentHashMap<Long, Long> ledgersMap;\n+\n+        public EntryLogMetadata(long logId) {\n+            this.entryLogId = logId;\n+\n+            totalSize = remainingSize = 0;\n+            ledgersMap = new ConcurrentHashMap<Long, Long>();\n+        }\n+\n+        public void addLedgerSize(long ledgerId, long size) {\n+            totalSize += size;\n+            remainingSize += size;\n+            Long ledgerSize = ledgersMap.get(ledgerId);\n+            if (null == ledgerSize) {\n+                ledgerSize = 0L;\n+            }\n+            ledgerSize += size;\n+            ledgersMap.put(ledgerId, ledgerSize);\n+        }\n+\n+        public void removeLedger(long ledgerId) {\n+            Long size = ledgersMap.remove(ledgerId);\n+            if (null == size) {\n+                return;\n+            }\n+            remainingSize -= size;\n+        }\n+\n+        public boolean containsLedger(long ledgerId) {\n+            return ledgersMap.containsKey(ledgerId);\n+        }\n+\n+        public double getUsage() {\n+            if (totalSize == 0L) {\n+                return 0.0f;\n+            }\n+            return (double)remainingSize / totalSize;\n+        }\n+\n+        public boolean isEmpty() {\n+            return ledgersMap.isEmpty();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"{ totalSize = \").append(totalSize).append(\", remainingSize = \")\n+              .append(remainingSize).append(\", ledgersMap = \").append(ledgersMap).append(\" }\");\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * A scanner used to extract entry log meta from entry log files.\n+     */\n+    static class ExtractionScanner implements EntryLogScanner {\n+        EntryLogMetadata meta;\n+\n+        public ExtractionScanner(EntryLogMetadata meta) {\n+            this.meta = meta;\n+        }\n+\n+        @Override\n+        public boolean accept(long ledgerId) {\n+            return true;\n+        }\n+        @Override\n+        public void process(long ledgerId, ByteBuffer entry) {\n+            // add new entry size of a ledger to entry log meta\n+            meta.addLedgerSize(ledgerId, entry.limit() + 4);\n+        }\n+    }\n+\n+    /**\n+     * Method to read in all of the entry logs (those that we haven't done so yet),\n+     * and find the set of ledger ID's that make up each entry log file.\n+     *\n+     * @param entryLogMetaMap\n+     *          Existing EntryLogs to Meta\n+     * @throws IOException\n+     */\n+    protected Map<Long, EntryLogMetadata> extractMetaFromEntryLogs(Map<Long, EntryLogMetadata> entryLogMetaMap) {\n+        // Extract it for every entry log except for the current one.\n+        // Entry Log ID's are just a long value that starts at 0 and increments\n+        // by 1 when the log fills up and we roll to a new one.\n+        long curLogId = entryLogger.getCurrentLogId();\n+        boolean hasExceptionWhenScan = false;\n+        for (long entryLogId = scannedLogId; entryLogId < curLogId; entryLogId++) {\n+            // Comb the current entry log file if it has not already been extracted.\n+            if (entryLogMetaMap.containsKey(entryLogId)) {\n+                continue;\n+            }\n+\n+            // check whether log file exists or not\n+            // if it doesn't exist, this log file might have been garbage collected.\n+            if (!entryLogger.logExists(entryLogId)) {\n+                continue;\n+            }\n+\n+            LOG.info(\"Extracting entry log meta from entryLogId: \" + entryLogId);\n+\n+            try {\n+                // Read through the entry log file and extract the entry log meta\n+                EntryLogMetadata entryLogMeta = extractMetaFromEntryLog(entryLogger, entryLogId);\n+                entryLogMetaMap.put(entryLogId, entryLogMeta);\n+            } catch (IOException e) {\n+                hasExceptionWhenScan = true;\n+                LOG.warn(\"Premature exception when processing \" + entryLogId +\n+                         \"recovery will take care of the problem\", e);\n+            }\n+\n+            // if scan failed on some entry log, we don't move 'scannedLogId' to next id\n+            // if scan succeed, we don't need to scan it again during next gc run,\n+            // we move 'scannedLogId' to next id\n+            if (!hasExceptionWhenScan) {\n+                ++scannedLogId;\n+            }\n+        }\n+        return entryLogMetaMap;\n+    }\n+\n+    static EntryLogMetadata extractMetaFromEntryLog(EntryLogger entryLogger, long entryLogId)\n+            throws IOException {\n+        EntryLogMetadata entryLogMeta = new EntryLogMetadata(entryLogId);\n+        ExtractionScanner scanner = new ExtractionScanner(entryLogMeta);\n+        // Read through the entry log file and extract the entry log meta\n+        entryLogger.scanEntryLog(entryLogId, scanner);\n+        LOG.info(\"Retrieved entry log meta data entryLogId: \"\n+                 + entryLogId + \", meta: \" + entryLogMeta);\n+        return entryLogMeta;\n+    }\n+}"},{"sha":"ee5f8f81eedf737a0b1736a5d6b0f9d7bb9c83e1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactory.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,32 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+\n+interface HandleFactory {\n+    LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n+            throws IOException, BookieException;\n+\n+    LedgerDescriptor getReadOnlyHandle(long ledgerId)\n+            throws IOException, Bookie.NoLedgerException;\n+}\n\\ No newline at end of file"},{"sha":"558e8cf151911d834ee63c9b8a6e5bdc6bf335e1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/HandleFactoryImpl.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,66 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+\n+class HandleFactoryImpl implements HandleFactory {\n+    HashMap<Long, LedgerDescriptor> ledgers = new HashMap<Long, LedgerDescriptor>();\n+    HashMap<Long, LedgerDescriptor> readOnlyLedgers\n+        = new HashMap<Long, LedgerDescriptor>();\n+\n+    final LedgerStorage ledgerStorage;\n+\n+    HandleFactoryImpl(LedgerStorage ledgerStorage) {\n+        this.ledgerStorage = ledgerStorage;\n+    }\n+\n+    @Override\n+    public LedgerDescriptor getHandle(long ledgerId, byte[] masterKey)\n+            throws IOException, BookieException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = ledgers.get(ledgerId);\n+            if (handle == null) {\n+                handle = LedgerDescriptor.create(masterKey, ledgerId, ledgerStorage);\n+                ledgers.put(ledgerId, handle);\n+            }\n+            handle.checkAccess(masterKey);\n+        }\n+        return handle;\n+    }\n+\n+    @Override\n+    public LedgerDescriptor getReadOnlyHandle(long ledgerId)\n+            throws IOException, Bookie.NoLedgerException {\n+        LedgerDescriptor handle = null;\n+        synchronized (ledgers) {\n+            handle = readOnlyLedgers.get(ledgerId);\n+            if (handle == null) {\n+                handle = LedgerDescriptor.createReadOnly(ledgerId, ledgerStorage);\n+                readOnlyLedgers.put(ledgerId, handle);\n+            }\n+        }\n+        return handle;\n+    }\n+}\n\\ No newline at end of file"},{"sha":"3c4f339778a6a9f72dfdda68dac668d7866ab061","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,187 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.nio.ByteBuffer;\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Interleave ledger storage\n+ * This ledger storage implementation stores all entries in a single\n+ * file and maintains an index file for each ledger.\n+ */\n+class InterleavedLedgerStorage implements LedgerStorage {\n+    final static Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n+\n+    private EntryLogger entryLogger;\n+    private LedgerCache ledgerCache;\n+    // This is the thread that garbage collects the entry logs that do not\n+    // contain any active ledgers in them; and compacts the entry logs that\n+    // has lower remaining percentage to reclaim disk space.\n+    final GarbageCollectorThread gcThread;\n+\n+    // this indicates that a write has happened since the last flush\n+    private volatile boolean somethingWritten = false;\n+\n+    InterleavedLedgerStorage(ServerConfiguration conf, LedgerManager ledgerManager)\n+            throws IOException {\n+        entryLogger = new EntryLogger(conf);\n+        ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n+        gcThread = new GarbageCollectorThread(conf, ledgerCache, entryLogger,\n+                ledgerManager, new EntryLogCompactionScanner());\n+    }\n+\n+    @Override    \n+    public void start() {\n+        gcThread.start();\n+    }\n+\n+    @Override\n+    public void shutdown() throws InterruptedException {\n+        // shut down gc thread, which depends on zookeeper client\n+        // also compaction will write entries again to entry log file\n+        gcThread.shutdown();\n+        entryLogger.shutdown();\n+        try {\n+            ledgerCache.close();\n+        } catch (IOException e) {\n+            LOG.error(\"Error while closing the ledger cache\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n+        ledgerCache.setMasterKey(ledgerId, masterKey);\n+    }\n+\n+    @Override\n+    public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n+        return ledgerCache.readMasterKey(ledgerId);\n+    }\n+\n+    @Override\n+    public boolean ledgerExists(long ledgerId) throws IOException {\n+        return ledgerCache.ledgerExists(ledgerId);\n+    }\n+\n+    @Override\n+    synchronized public long addEntry(ByteBuffer entry) throws IOException {\n+        long ledgerId = entry.getLong();\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+        \n+        /*\n+         * Log the entry\n+         */\n+        long pos = entryLogger.addEntry(ledgerId, entry);\n+        \n+        \n+        /*\n+         * Set offset of entry id to be the current ledger position\n+         */\n+        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n+\n+        somethingWritten = true;\n+\n+        return entryId;\n+    }\n+\n+    @Override\n+    public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n+        long offset;\n+        /*\n+         * If entryId is BookieProtocol.LAST_ADD_CONFIRMED, then return the last written.\n+         */\n+        if (entryId == BookieProtocol.LAST_ADD_CONFIRMED) {\n+            entryId = ledgerCache.getLastEntry(ledgerId);\n+        }\n+\n+        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n+        if (offset == 0) {\n+            throw new Bookie.NoEntryException(ledgerId, entryId);\n+        }\n+        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n+    }\n+\n+    @Override\n+    public boolean isFlushRequired() {\n+        return somethingWritten;\n+    };\n+\n+    @Override\n+    public void flush() throws IOException {\n+        if (!somethingWritten) {\n+            return;\n+        }\n+        somethingWritten = false;\n+        boolean flushFailed = false;\n+\n+        try {\n+            ledgerCache.flushLedger(true);\n+        } catch (IOException ioe) {\n+            LOG.error(\"Exception flushing Ledger cache\", ioe);\n+            flushFailed = true;\n+        }\n+\n+        try {\n+            entryLogger.flush();\n+        } catch (IOException ioe) {\n+            LOG.error(\"Exception flushing Ledger\", ioe);\n+            flushFailed = true;\n+        }\n+        if (flushFailed) {\n+            throw new IOException(\"Flushing to storage failed, check logs\");\n+        }\n+    }\n+\n+    @Override\n+    public BKMBeanInfo getJMXBean() {\n+        return ledgerCache.getJMXBean();\n+    }\n+\n+    /**\n+     * Scanner used to do entry log compaction\n+     */\n+    class EntryLogCompactionScanner implements EntryLogger.EntryLogScanner {\n+        @Override\n+        public boolean accept(long ledgerId) {\n+            // bookie has no knowledge about which ledger is deleted\n+            // so just accept all ledgers.\n+            return true;\n+        }\n+\n+        @Override\n+        public void process(long ledgerId, ByteBuffer buffer)\n+            throws IOException {\n+            addEntry(buffer);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file"},{"sha":"409e2fc8c95eff1fdac6cf6befa49c9b70f4825c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"added","additions":576,"deletions":0,"changes":576,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,576 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.util.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Provide journal related management.\n+ */\n+class Journal extends Thread {\n+\n+    static Logger LOG = LoggerFactory.getLogger(Journal.class);\n+\n+    /**\n+     * Filter to pickup journals\n+     */\n+    private static interface JournalIdFilter {\n+        public boolean accept(long journalId);\n+    }\n+\n+    /**\n+     * List all journal ids by a specified journal id filer\n+     *\n+     * @param journalDir journal dir\n+     * @param filter journal id filter\n+     * @return list of filtered ids\n+     */\n+    private static List<Long> listJournalIds(File journalDir, JournalIdFilter filter) {\n+        File logFiles[] = journalDir.listFiles();\n+        List<Long> logs = new ArrayList<Long>();\n+        for(File f: logFiles) {\n+            String name = f.getName();\n+            if (!name.endsWith(\".txn\")) {\n+                continue;\n+            }\n+            String idString = name.split(\"\\\\.\")[0];\n+            long id = Long.parseLong(idString, 16);\n+            if (filter != null) {\n+                if (filter.accept(id)) {\n+                    logs.add(id);\n+                }\n+            } else {\n+                logs.add(id);\n+            }\n+        }\n+        Collections.sort(logs);\n+        return logs;\n+    }\n+\n+    /**\n+     * Last Log Mark\n+     */\n+    class LastLogMark {\n+        long txnLogId;\n+        long txnLogPosition;\n+        LastLogMark lastMark;\n+        LastLogMark(long logId, long logPosition) {\n+            this.txnLogId = logId;\n+            this.txnLogPosition = logPosition;\n+        }\n+        synchronized void setLastLogMark(long logId, long logPosition) {\n+            txnLogId = logId;\n+            txnLogPosition = logPosition;\n+        }\n+        synchronized void markLog() {\n+            lastMark = new LastLogMark(txnLogId, txnLogPosition);\n+        }\n+\n+        synchronized LastLogMark getLastMark() {\n+            return lastMark;\n+        }\n+        synchronized long getTxnLogId() {\n+            return txnLogId;\n+        }\n+        synchronized long getTxnLogPosition() {\n+            return txnLogPosition;\n+        }\n+\n+        synchronized void rollLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            // we should record <logId, logPosition> marked in markLog\n+            // which is safe since records before lastMark have been\n+            // persisted to disk (both index & entry logger)\n+            bb.putLong(lastMark.getTxnLogId());\n+            bb.putLong(lastMark.getTxnLogPosition());\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"RollLog to persist last marked log : \" + lastMark);\n+            }\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileOutputStream fos = new FileOutputStream(file);\n+                    fos.write(buff);\n+                    fos.getChannel().force(true);\n+                    fos.close();\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems writing to \" + file, e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Read last mark from lastMark file.\n+         * The last mark should first be max journal log id,\n+         * and then max log position in max journal log.\n+         */\n+        synchronized void readLog() {\n+            byte buff[] = new byte[16];\n+            ByteBuffer bb = ByteBuffer.wrap(buff);\n+            for(File dir: ledgerDirectories) {\n+                File file = new File(dir, \"lastMark\");\n+                try {\n+                    FileInputStream fis = new FileInputStream(file);\n+                    try {\n+                        int bytesRead = fis.read(buff);\n+                        if (bytesRead != 16) {\n+                            throw new IOException(\"Couldn't read enough bytes from lastMark.\"\n+                                                  + \" Wanted \" + 16 + \", got \" + bytesRead);\n+                        }\n+                    } finally {\n+                        fis.close();\n+                    }\n+                    bb.clear();\n+                    long i = bb.getLong();\n+                    long p = bb.getLong();\n+                    if (i > txnLogId) {\n+                        txnLogId = i;\n+                        if(p > txnLogPosition) {\n+                          txnLogPosition = p;\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+\n+            sb.append(\"LastMark: logId - \").append(txnLogId)\n+              .append(\" , position - \").append(txnLogPosition);\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * Filter to return list of journals for rolling\n+     */\n+    private class JournalRollingFilter implements JournalIdFilter {\n+        @Override\n+        public boolean accept(long journalId) {\n+            if (journalId < lastLogMark.getLastMark().getTxnLogId()) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Scanner used to scan a journal\n+     */\n+    public static interface JournalScanner {\n+        /**\n+         * Process a journal entry.\n+         *\n+         * @param journalVersion\n+         *          Journal Version\n+         * @param offset\n+         *          File offset of the journal entry\n+         * @param entry\n+         *          Journal Entry\n+         * @throws IOException\n+         */\n+        public void process(int journalVersion, long offset, ByteBuffer entry) throws IOException;\n+    }\n+\n+    /**\n+     * Journal Entry to Record\n+     */\n+    private static class QueueEntry {\n+        QueueEntry(ByteBuffer entry, long ledgerId, long entryId,\n+                   WriteCallback cb, Object ctx) {\n+            this.entry = entry.duplicate();\n+            this.cb = cb;\n+            this.ctx = ctx;\n+            this.ledgerId = ledgerId;\n+            this.entryId = entryId;\n+        }\n+\n+        ByteBuffer entry;\n+\n+        long ledgerId;\n+\n+        long entryId;\n+\n+        WriteCallback cb;\n+\n+        Object ctx;\n+    }\n+\n+    final static long MB = 1024 * 1024L;\n+    // max journal file size\n+    final long maxJournalSize;\n+    // number journal files kept before marked journal\n+    final int maxBackupJournals;\n+\n+    final File journalDirectory;\n+    final File ledgerDirectories[];\n+    final ServerConfiguration conf;\n+\n+    private LastLogMark lastLogMark = new LastLogMark(0, 0);\n+\n+    // journal entry queue to commit\n+    LinkedBlockingQueue<QueueEntry> queue = new LinkedBlockingQueue<QueueEntry>();\n+\n+    volatile boolean running = true;\n+\n+    public Journal(ServerConfiguration conf) {\n+        super(\"BookieJournal-\" + conf.getBookiePort());\n+        this.conf = conf;\n+        this.journalDirectory = Bookie.getCurrentDirectory(conf.getJournalDir());\n+        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n+        this.maxJournalSize = conf.getMaxJournalSize() * MB;\n+        this.maxBackupJournals = conf.getMaxBackupJournals();\n+\n+        // read last log mark\n+        lastLogMark.readLog();\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Last Log Mark : \" + lastLogMark);\n+        }\n+    }\n+\n+    LastLogMark getLastLogMark() {\n+        return lastLogMark;\n+    }\n+\n+    /**\n+     * Records a <i>LastLogMark</i> in memory.\n+     *\n+     * <p>\n+     * The <i>LastLogMark</i> contains two parts: first one is <i>txnLogId</i>\n+     * (file id of a journal) and the second one is <i>txnLogPos</i> (offset in\n+     *  a journal). The <i>LastLogMark</i> indicates that those entries before\n+     * it have been persisted to both index and entry log files.\n+     * </p>\n+     *\n+     * <p>\n+     * This method is called before flushing entry log files and ledger cache.\n+     * </p>\n+     */\n+    public void markLog() {\n+        lastLogMark.markLog();\n+    }\n+\n+    /**\n+     * Persists the <i>LastLogMark</i> marked by #markLog() to disk.\n+     *\n+     * <p>\n+     * This action means entries added before <i>LastLogMark</i> whose entry data\n+     * and index pages were already persisted to disk. It is the time to safely\n+     * remove journal files created earlier than <i>LastLogMark.txnLogId</i>.\n+     * </p>\n+     * <p>\n+     * If the bookie has crashed before persisting <i>LastLogMark</i> to disk,\n+     * it still has journal files contains entries for which index pages may not\n+     * have been persisted. Consequently, when the bookie restarts, it inspects\n+     * journal files to restore those entries; data isn't lost.\n+     * </p>\n+     * <p>\n+     * This method is called after flushing entry log files and ledger cache successfully, which is to ensure <i>LastLogMark</i> is pesisted.\n+     * </p>\n+     * @see #markLog()\n+     */\n+    public void rollLog() {\n+        lastLogMark.rollLog();\n+    }\n+\n+    /**\n+     * Garbage collect older journals\n+     */\n+    public void gcJournals() {\n+        // list the journals that have been marked\n+        List<Long> logs = listJournalIds(journalDirectory, new JournalRollingFilter());\n+        // keep MAX_BACKUP_JOURNALS journal files before marked journal\n+        if (logs.size() >= maxBackupJournals) {\n+            int maxIdx = logs.size() - maxBackupJournals;\n+            for (int i=0; i<maxIdx; i++) {\n+                long id = logs.get(i);\n+                // make sure the journal id is smaller than marked journal id\n+                if (id < lastLogMark.getLastMark().getTxnLogId()) {\n+                    File journalFile = new File(journalDirectory, Long.toHexString(id) + \".txn\");\n+                    if (!journalFile.delete()) {\n+                        LOG.warn(\"Could not delete old journal file {}\", journalFile);\n+                    }\n+                    LOG.info(\"garbage collected journal \" + journalFile.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Scan the journal\n+     *\n+     * @param journalId\n+     *          Journal Log Id\n+     * @param journalPos\n+     *          Offset to start scanning\n+     * @param scanner\n+     *          Scanner to handle entries\n+     * @throws IOException\n+     */\n+    public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n+        throws IOException {\n+        JournalChannel recLog;\n+        if (journalPos <= 0) {\n+            recLog = new JournalChannel(journalDirectory, journalId);\n+        } else {\n+            recLog = new JournalChannel(journalDirectory, journalId, journalPos);\n+        }\n+        int journalVersion = recLog.getFormatVersion();\n+        try {\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n+            while(true) {\n+                // entry start offset\n+                long offset = recLog.fc.position();\n+                // start reading entry\n+                lenBuff.clear();\n+                fullRead(recLog, lenBuff);\n+                if (lenBuff.remaining() != 0) {\n+                    break;\n+                }\n+                lenBuff.flip();\n+                int len = lenBuff.getInt();\n+                if (len == 0) {\n+                    break;\n+                }\n+                recBuff.clear();\n+                if (recBuff.remaining() < len) {\n+                    recBuff = ByteBuffer.allocate(len);\n+                }\n+                recBuff.limit(len);\n+                if (fullRead(recLog, recBuff) != len) {\n+                    // This seems scary, but it just means that this is where we\n+                    // left off writing\n+                    break;\n+                }\n+                recBuff.flip();\n+                scanner.process(journalVersion, offset, recBuff);\n+            }\n+        } finally {\n+            recLog.close();\n+        }\n+    }\n+\n+    /**\n+     * Replay journal files\n+     *\n+     * @param scanner\n+     *          Scanner to process replayed entries.\n+     * @throws IOException\n+     */\n+    public void replay(JournalScanner scanner) throws IOException {\n+        final long markedLogId = lastLogMark.getTxnLogId();\n+        List<Long> logs = listJournalIds(journalDirectory, new JournalIdFilter() {\n+            @Override\n+            public boolean accept(long journalId) {\n+                if (journalId < markedLogId) {\n+                    return false;\n+                }\n+                return true;\n+            }\n+        });\n+        // last log mark may be missed due to no sync up before\n+        // validate filtered log ids only when we have markedLogId\n+        if (markedLogId > 0) {\n+            if (logs.size() == 0 || logs.get(0) != markedLogId) {\n+                throw new IOException(\"Recovery log \" + markedLogId + \" is missing\");\n+            }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Try to relay journal logs : \" + logs);\n+        }\n+        // TODO: When reading in the journal logs that need to be synced, we\n+        // should use BufferedChannels instead to minimize the amount of\n+        // system calls done.\n+        for(Long id: logs) {\n+            long logPosition = 0L;\n+            if(id == markedLogId) {\n+                logPosition = lastLogMark.getTxnLogPosition();\n+            }\n+            scanJournal(id, logPosition, scanner);\n+        }\n+    }\n+\n+    /**\n+     * record an add entry operation in journal\n+     */\n+    public void logAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx) {\n+        long ledgerId = entry.getLong();\n+        long entryId = entry.getLong();\n+        entry.rewind();\n+        queue.add(new QueueEntry(entry, ledgerId, entryId, cb, ctx));\n+    }\n+\n+    /**\n+     * Get the length of journal entries queue.\n+     *\n+     * @return length of journal entry queue.\n+     */\n+    public int getJournalQueueLength() {\n+        return queue.size();\n+    }\n+\n+    /**\n+     * A thread used for persisting journal entries to journal files.\n+     *\n+     * <p>\n+     * Besides persisting journal entries, it also takes responsibility of\n+     * rolling journal files when a journal file reaches journal file size\n+     * limitation.\n+     * </p>\n+     * <p>\n+     * During journal rolling, it first closes the writing journal, generates\n+     * new journal file using current timestamp, and continue persistence logic.\n+     * Those journals will be garbage collected in SyncThread.\n+     * </p>\n+     * @see Bookie#SyncThread\n+     */\n+    @Override\n+    public void run() {\n+        LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n+        ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+        JournalChannel logFile = null;\n+        try {\n+            long logId = 0;\n+            BufferedChannel bc = null;\n+            long lastFlushPosition = 0;\n+\n+            QueueEntry qe = null;\n+            while (true) {\n+                // new journal file to write\n+                if (null == logFile) {\n+                    logId = System.currentTimeMillis();\n+                    logFile = new JournalChannel(journalDirectory, logId);\n+                    bc = logFile.getBufferedChannel();\n+\n+                    lastFlushPosition = 0;\n+                }\n+\n+                if (qe == null) {\n+                    if (toFlush.isEmpty()) {\n+                        qe = queue.take();\n+                    } else {\n+                        qe = queue.poll();\n+                        if (qe == null || bc.position() > lastFlushPosition + 512*1024) {\n+                            //logFile.force(false);\n+                            bc.flush(true);\n+                            lastFlushPosition = bc.position();\n+                            lastLogMark.setLastLogMark(logId, lastFlushPosition);\n+                            for (QueueEntry e : toFlush) {\n+                                e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n+                            }\n+                            toFlush.clear();\n+\n+                            // check whether journal file is over file limit\n+                            if (bc.position() > maxJournalSize) {\n+                                logFile.close();\n+                                logFile = null;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (!running) {\n+                    LOG.info(\"Journal Manager is asked to shut down, quit.\");\n+                    break;\n+                }\n+\n+                if (qe == null) { // no more queue entry\n+                    continue;\n+                }\n+                lenBuff.clear();\n+                lenBuff.putInt(qe.entry.remaining());\n+                lenBuff.flip();\n+                //\n+                // we should be doing the following, but then we run out of\n+                // direct byte buffers\n+                // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n+                bc.write(lenBuff);\n+                bc.write(qe.entry);\n+\n+                logFile.preAllocIfNeeded();\n+\n+                toFlush.add(qe);\n+                qe = null;\n+            }\n+            logFile.close();\n+            logFile = null;\n+        } catch (IOException ioe) {\n+            LOG.error(\"I/O exception in Journal thread!\", ioe);\n+        } catch (InterruptedException ie) {\n+            LOG.warn(\"Journal exits when shutting down\", ie);\n+        } finally {\n+            IOUtils.close(LOG, logFile);\n+        }\n+    }\n+\n+    /**\n+     * Shuts down the journal.\n+     */\n+    public synchronized void shutdown() {\n+        try {\n+            if (!running) {\n+                return;\n+            }\n+            running = false;\n+            this.interrupt();\n+            this.join();\n+        } catch (InterruptedException ie) {\n+            LOG.warn(\"Interrupted during shutting down journal : \", ie);\n+        }\n+    }\n+\n+    private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n+        int total = 0;\n+        while(bb.remaining() > 0) {\n+            int rc = fc.read(bb);\n+            if (rc <= 0) {\n+                return total;\n+            }\n+            total += rc;\n+        }\n+        return total;\n+    }\n+}"},{"sha":"8f4deec236052782297bd58d887060426e15ed28","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,158 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.Arrays;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.RandomAccessFile;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.ByteBuffer;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Simple wrapper around FileChannel to add versioning\n+ * information to the file.\n+ */\n+class JournalChannel implements Closeable {\n+    static Logger LOG = LoggerFactory.getLogger(JournalChannel.class);\n+\n+    final FileChannel fc;\n+    final BufferedChannel bc;\n+    final int formatVersion;\n+    long nextPrealloc = 0;\n+\n+    final byte[] MAGIC_WORD = \"BKLG\".getBytes();\n+\n+    private final static int START_OF_FILE = -12345;\n+\n+    int HEADER_SIZE = 8; // 4byte magic word, 4 byte version\n+    int MIN_COMPAT_JOURNAL_FORMAT_VERSION = 1;\n+    int CURRENT_JOURNAL_FORMAT_VERSION = 3;\n+\n+    public final static long preAllocSize = 4*1024*1024;\n+    public final static ByteBuffer zeros = ByteBuffer.allocate(512);\n+\n+    JournalChannel(File journalDirectory, long logId) throws IOException {\n+        this(journalDirectory, logId, START_OF_FILE);\n+    }\n+\n+    JournalChannel(File journalDirectory, long logId, long position) throws IOException {\n+        File fn = new File(journalDirectory, Long.toHexString(logId) + \".txn\");\n+\n+        LOG.info(\"Opening journal {}\", fn);\n+        if (!fn.exists()) { // new file, write version\n+            fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+            formatVersion = CURRENT_JOURNAL_FORMAT_VERSION;\n+\n+            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            bb.put(MAGIC_WORD);\n+            bb.putInt(formatVersion);\n+            bb.flip();\n+            fc.write(bb);\n+            fc.force(true);\n+\n+            bc = new BufferedChannel(fc, 65536);\n+\n+            nextPrealloc = preAllocSize;\n+            fc.write(zeros, nextPrealloc);\n+        } else {  // open an existing file\n+            fc = new RandomAccessFile(fn, \"r\").getChannel();\n+            bc = null; // readonly\n+\n+            ByteBuffer bb = ByteBuffer.allocate(HEADER_SIZE);\n+            int c = fc.read(bb);\n+            bb.flip();\n+\n+            if (c == HEADER_SIZE) {\n+                byte[] first4 = new byte[4];\n+                bb.get(first4);\n+\n+                if (Arrays.equals(first4, MAGIC_WORD)) {\n+                    formatVersion = bb.getInt();\n+                } else {\n+                    // pre magic word journal, reset to 0;\n+                    formatVersion = 1;\n+                }\n+            } else {\n+                // no header, must be old version\n+                formatVersion = 1;\n+            }\n+\n+            if (formatVersion < MIN_COMPAT_JOURNAL_FORMAT_VERSION\n+                || formatVersion > CURRENT_JOURNAL_FORMAT_VERSION) {\n+                String err = String.format(\"Invalid journal version, unable to read.\"\n+                        + \" Expected between (%d) and (%d), got (%d)\",\n+                        MIN_COMPAT_JOURNAL_FORMAT_VERSION, CURRENT_JOURNAL_FORMAT_VERSION,\n+                        formatVersion);\n+                LOG.error(err);\n+                throw new IOException(err);\n+            }\n+\n+            try {\n+                if (position == START_OF_FILE) {\n+                    if (formatVersion >= 2) {\n+                        fc.position(HEADER_SIZE);\n+                    } else {\n+                        fc.position(0);\n+                    }\n+                } else {\n+                    fc.position(position);\n+                }\n+            } catch (IOException e) {\n+                LOG.error(\"Bookie journal file can seek to position :\", e);\n+            }\n+        }\n+    }\n+\n+    int getFormatVersion() {\n+        return formatVersion;\n+    }\n+\n+    BufferedChannel getBufferedChannel() throws IOException {\n+        if (bc == null) {\n+            throw new IOException(\"Read only journal channel\");\n+        }\n+        return bc;\n+    }\n+\n+    void preAllocIfNeeded() throws IOException {\n+        if (bc.position() > nextPrealloc) {\n+            nextPrealloc = ((fc.size() + HEADER_SIZE) / preAllocSize + 1) * preAllocSize;\n+            zeros.clear();\n+            fc.write(zeros, nextPrealloc);\n+        }\n+    }\n+\n+    int read(ByteBuffer dst)\n+            throws IOException {\n+        return fc.read(dst);\n+    }\n+\n+    public void close() throws IOException {\n+        fc.close();\n+    }\n+}\n\\ No newline at end of file"},{"sha":"597d89ffb4a58081042b99296c89dcaede1b3d5d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":11,"deletions":516,"changes":527,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,531 +21,26 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import java.io.File;\n+import java.io.Closeable;\n import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-\n-import org.apache.bookkeeper.meta.LedgerManager;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  * This class maps a ledger entry number into a location (entrylogid, offset) in\n  * an entry log file. It does user level caching to more efficiently manage disk\n  * head scheduling.\n  */\n-public class LedgerCache {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-\n-    final File ledgerDirectories[];\n-\n-    public LedgerCache(ServerConfiguration conf, LedgerManager alm) {\n-        this.ledgerDirectories = conf.getLedgerDirs();\n-        this.openFileLimit = conf.getOpenFileLimit();\n-        this.pageSize = conf.getPageSize();\n-        this.entriesPerPage = pageSize / 8;\n-        \n-        if (conf.getPageLimit() <= 0) {\n-            // allocate half of the memory to the page cache\n-            this.pageLimit = (int)((Runtime.getRuntime().maxMemory() / 3) / this.pageSize);\n-        } else {\n-            this.pageLimit = conf.getPageLimit();\n-        }\n-        LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n-        LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n-        activeLedgerManager = alm;\n-        // Retrieve all of the active ledgers.\n-        getActiveLedgers();\n-    }\n-    /**\n-     * the list of potentially clean ledgers\n-     */\n-    LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n-\n-    /**\n-     * the list of potentially dirty ledgers\n-     */\n-    LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n-\n-    HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n-\n-    LinkedList<Long> openLedgers = new LinkedList<Long>();\n-\n-    // Manage all active ledgers in LedgerManager\n-    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n-    final LedgerManager activeLedgerManager;\n-\n-    final int openFileLimit;\n-    final int pageSize;\n-    final int pageLimit;\n-    final int entriesPerPage;\n-\n-    /**\n-     * @return page size used in ledger cache\n-     */\n-    public int getPageSize() {\n-        return pageSize;\n-    }\n-\n-    /**\n-     * @return entries per page used in ledger cache\n-     */\n-    public int getEntriesPerPage() {\n-        return entriesPerPage;\n-    }\n-\n-    // The number of pages that have actually been used\n-    private int pageCount = 0;\n-    HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n-\n-    private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n-        HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n-        if (map == null) {\n-            map = new HashMap<Long, LedgerEntryPage>();\n-            table.put(lep.getLedger(), map);\n-        }\n-        map.put(lep.getFirstEntry(), lep);\n-    }\n-\n-    private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, Long ledger, Long firstEntry) {\n-        HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n-        if (map != null) {\n-            return map.get(firstEntry);\n-        }\n-        return null;\n-    }\n-\n-    synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n-        LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n-        try {\n-            if (onlyDirty && lep.isClean()) {\n-                return null;\n-            }\n-            return lep;\n-        } finally {\n-            if (lep != null) {\n-                lep.usePage();\n-            }\n-        }\n-    }\n-\n-    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n-        int offsetInPage = (int) (entry % entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry-offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        if (lep == null) {\n-            // find a free page\n-            lep = grabCleanPage(ledger, pageEntry);\n-            updatePage(lep);\n-            synchronized(this) {\n-                putIntoTable(pages, lep);\n-            }\n-        }\n-        if (lep != null) {\n-            lep.setOffset(offset, offsetInPage*8);\n-            lep.releasePage();\n-            return;\n-        }\n-    }\n-\n-    public long getEntryOffset(long ledger, long entry) throws IOException {\n-        int offsetInPage = (int) (entry%entriesPerPage);\n-        // find the id of the first entry of the page that has the entry\n-        // we are looking for\n-        long pageEntry = entry-offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        try {\n-            if (lep == null) {\n-                lep = grabCleanPage(ledger, pageEntry);\n-                synchronized(this) {\n-                    putIntoTable(pages, lep);\n-                }\n-                updatePage(lep);\n-\n-            }\n-            return lep.getOffset(offsetInPage*8);\n-        } finally {\n-            if (lep != null) {\n-                lep.releasePage();\n-            }\n-        }\n-    }\n-\n-    static final private String getLedgerName(long ledgerId) {\n-        int parent = (int) (ledgerId & 0xff);\n-        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(Integer.toHexString(grandParent));\n-        sb.append('/');\n-        sb.append(Integer.toHexString(parent));\n-        sb.append('/');\n-        sb.append(Long.toHexString(ledgerId));\n-        sb.append(\".idx\");\n-        return sb.toString();\n-    }\n-\n-    static final private void checkParents(File f) throws IOException {\n-        File parent = f.getParentFile();\n-        if (parent.exists()) {\n-            return;\n-        }\n-        if (parent.mkdirs() == false) {\n-            throw new IOException(\"Counldn't mkdirs for \" + parent);\n-        }\n-    }\n-\n-    static final private Random rand = new Random();\n-\n-    static final private File pickDirs(File dirs[]) {\n-        return dirs[rand.nextInt(dirs.length)];\n-    }\n-\n-    FileInfo getFileInfo(Long ledger, boolean create) throws IOException {\n-        synchronized(fileInfoCache) {\n-            FileInfo fi = fileInfoCache.get(ledger);\n-            if (fi == null) {\n-                String ledgerName = getLedgerName(ledger);\n-                File lf = null;\n-                for(File d: ledgerDirectories) {\n-                    lf = new File(d, ledgerName);\n-                    if (lf.exists()) {\n-                        break;\n-                    }\n-                    lf = null;\n-                }\n-                if (lf == null) {\n-                    if (!create) {\n-                        throw new Bookie.NoLedgerException(ledger);\n-                    }\n-                    File dir = pickDirs(ledgerDirectories);\n-                    lf = new File(dir, ledgerName);\n-                    checkParents(lf);\n-                    // A new ledger index file has been created for this Bookie.\n-                    // Add this new ledger to the set of active ledgers.\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n-                    }\n-                    activeLedgerManager.addActiveLedger(ledger, true);\n-                }\n-                if (openLedgers.size() > openFileLimit) {\n-                    fileInfoCache.remove(openLedgers.removeFirst()).close();\n-                }\n-                fi = new FileInfo(lf);\n-                fileInfoCache.put(ledger, fi);\n-                openLedgers.add(ledger);\n-            }\n-            if (fi != null) {\n-                fi.use();\n-            }\n-            return fi;\n-        }\n-    }\n-    private void updatePage(LedgerEntryPage lep) throws IOException {\n-        if (!lep.isClean()) {\n-            throw new IOException(\"Trying to update a dirty page\");\n-        }\n-        FileInfo fi = null;\n-        try {\n-            fi = getFileInfo(lep.getLedger(), true);\n-            long pos = lep.getFirstEntry()*8;\n-            if (pos >= fi.size()) {\n-                lep.zeroPage();\n-            } else {\n-                lep.readPage(fi);\n-            }\n-        } finally {\n-            if (fi != null) {\n-                fi.release();\n-            }\n-        }\n-    }\n-\n-    void flushLedger(boolean doAll) throws IOException {\n-        synchronized(dirtyLedgers) {\n-            if (dirtyLedgers.isEmpty()) {\n-                synchronized(this) {\n-                    for(Long l: pages.keySet()) {\n-                        if (LOG.isTraceEnabled()) {\n-                            LOG.trace(\"Adding \" + Long.toHexString(l) + \" to dirty pages\");\n-                        }\n-                        dirtyLedgers.add(l);\n-                    }\n-                }\n-            }\n-            if (dirtyLedgers.isEmpty()) {\n-                return;\n-            }\n-            while(!dirtyLedgers.isEmpty()) {\n-                Long l = dirtyLedgers.removeFirst();\n-                LinkedList<Long> firstEntryList;\n-                synchronized(this) {\n-                    HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n-                    if (pageMap == null || pageMap.isEmpty()) {\n-                        continue;\n-                    }\n-                    firstEntryList = new LinkedList<Long>();\n-                    for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n-                        LedgerEntryPage lep = entry.getValue();\n-                        if (lep.isClean()) {\n-                            if (LOG.isTraceEnabled()) {\n-                                LOG.trace(\"Page is clean \" + lep);\n-                            }\n-                            continue;\n-                        }\n-                        firstEntryList.add(lep.getFirstEntry());\n-                    }\n-                }\n-                // Now flush all the pages of a ledger\n-                List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n-                FileInfo fi = null;\n-                try {\n-                    for(Long firstEntry: firstEntryList) {\n-                        LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n-                        if (lep != null) {\n-                            entries.add(lep);\n-                        }\n-                    }\n-                    Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n-                        @Override\n-                        public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n-                            return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n-                        }\n-                    });\n-                    ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n-                    fi = getFileInfo(l, true);\n-                    int start = 0;\n-                    long lastOffset = -1;\n-                    for(int i = 0; i < entries.size(); i++) {\n-                        versions.add(i, entries.get(i).getVersion());\n-                        if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n-                            // send up a sequential list\n-                            int count = i - start;\n-                            if (count == 0) {\n-                                System.out.println(\"Count cannot possibly be zero!\");\n-                            }\n-                            writeBuffers(l, entries, fi, start, count);\n-                            start = i;\n-                        }\n-                        lastOffset = entries.get(i).getFirstEntry();\n-                    }\n-                    if (entries.size()-start == 0 && entries.size() != 0) {\n-                        System.out.println(\"Nothing to write, but there were entries!\");\n-                    }\n-                    writeBuffers(l, entries, fi, start, entries.size()-start);\n-                    synchronized(this) {\n-                        for(int i = 0; i < entries.size(); i++) {\n-                            LedgerEntryPage lep = entries.get(i);\n-                            lep.setClean(versions.get(i));\n-                        }\n-                    }\n-                } finally {\n-                    for(LedgerEntryPage lep: entries) {\n-                        lep.releasePage();\n-                    }\n-                    if (fi != null) {\n-                        fi.release();\n-                    }\n-                }\n-                if (!doAll) {\n-                    break;\n-                }\n-                // Yeild. if we are doing all the ledgers we don't want to block other flushes that\n-                // need to happen\n-                try {\n-                    dirtyLedgers.wait(1);\n-                } catch (InterruptedException e) {\n-                    // just pass it on\n-                    Thread.currentThread().interrupt();\n-                }\n-            }\n-        }\n-    }\n-\n-    private void writeBuffers(Long ledger,\n-                              List<LedgerEntryPage> entries, FileInfo fi,\n-                              int start, int count) throws IOException {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n-        }\n-        if (count == 0) {\n-            //System.out.println(\"Count is zero!\");\n-            return;\n-        }\n-        ByteBuffer buffs[] = new ByteBuffer[count];\n-        for(int j = 0; j < count; j++) {\n-            buffs[j] = entries.get(start+j).getPageToWrite();\n-            if (entries.get(start+j).getLedger() != ledger) {\n-                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \" + entries.get(start+j).getLedger());\n-            }\n-        }\n-        long totalWritten = 0;\n-        while(buffs[buffs.length-1].remaining() > 0) {\n-            long rc = fi.write(buffs, entries.get(start+0).getFirstEntry()*8);\n-            if (rc <= 0) {\n-                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n-            }\n-            //System.out.println(\"Wrote \" + rc + \" to \" + ledger);\n-            totalWritten += rc;\n-        }\n-        if (totalWritten != count * pageSize) {\n-            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten + \" expected \" + count * pageSize);\n-        }\n-    }\n-    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n-        if (entry % entriesPerPage != 0) {\n-            throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n-        }\n-        synchronized(this) {\n-            if (pageCount  < pageLimit) {\n-                // let's see if we can allocate something\n-                LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n-                lep.setLedger(ledger);\n-                lep.setFirstEntry(entry);\n-                // note, this will not block since it is a new page\n-                lep.usePage();\n-                pageCount++;\n-                return lep;\n-            }\n-        }\n-\n-        outerLoop:\n-        while(true) {\n-            synchronized(cleanLedgers) {\n-                if (cleanLedgers.isEmpty()) {\n-                    flushLedger(false);\n-                    synchronized(this) {\n-                        for(Long l: pages.keySet()) {\n-                            cleanLedgers.add(l);\n-                        }\n-                    }\n-                }\n-                synchronized(this) {\n-                    Long cleanLedger = cleanLedgers.getFirst();\n-                    Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n-                    if (map == null || map.isEmpty()) {\n-                        cleanLedgers.removeFirst();\n-                        continue;\n-                    }\n-                    Iterator<Map.Entry<Long, LedgerEntryPage>> it = map.entrySet().iterator();\n-                    LedgerEntryPage lep = it.next().getValue();\n-                    while((lep.inUse() || !lep.isClean())) {\n-                        if (!it.hasNext()) {\n-                            continue outerLoop;\n-                        }\n-                        lep = it.next().getValue();\n-                    }\n-                    it.remove();\n-                    if (map.isEmpty()) {\n-                        pages.remove(lep.getLedger());\n-                    }\n-                    lep.usePage();\n-                    lep.zeroPage();\n-                    lep.setLedger(ledger);\n-                    lep.setFirstEntry(entry);\n-                    return lep;\n-                }\n-            }\n-        }\n-    }\n-\n-    public long getLastEntry(long ledgerId) {\n-        long lastEntry = 0;\n-        // Find the last entry in the cache\n-        synchronized(this) {\n-            Map<Long, LedgerEntryPage> map = pages.get(ledgerId);\n-            if (map != null) {\n-                for(LedgerEntryPage lep: map.values()) {\n-                    if (lep.getFirstEntry() + entriesPerPage < lastEntry) {\n-                        continue;\n-                    }\n-                    lep.usePage();\n-                    long highest = lep.getLastEntry();\n-                    if (highest > lastEntry) {\n-                        lastEntry = highest;\n-                    }\n-                    lep.releasePage();\n-                }\n-            }\n-        }\n-\n-        return lastEntry;\n-    }\n-\n-    /**\n-     * This method will look within the ledger directories for the ledger index\n-     * files. That will comprise the set of active ledgers this particular\n-     * BookieServer knows about that have not yet been deleted by the BookKeeper\n-     * Client. This is called only once during initialization.\n-     */\n-    private void getActiveLedgers() {\n-        // Ledger index files are stored in a file hierarchy with a parent and\n-        // grandParent directory. We'll have to go two levels deep into these\n-        // directories to find the index files.\n-        for (File ledgerDirectory : ledgerDirectories) {\n-            for (File grandParent : ledgerDirectory.listFiles()) {\n-                if (grandParent.isDirectory()) {\n-                    for (File parent : grandParent.listFiles()) {\n-                        if (parent.isDirectory()) {\n-                            for (File index : parent.listFiles()) {\n-                                if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n-                                    continue;\n-                                }\n-                                // We've found a ledger index file. The file name is the\n-                                // HexString representation of the ledgerId.\n-                                String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n-                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n+interface LedgerCache extends Closeable {\n+    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n+    byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n+    boolean ledgerExists(long ledgerId) throws IOException;\n \n-    /**\n-     * This method is called whenever a ledger is deleted by the BookKeeper Client\n-     * and we want to remove all relevant data for it stored in the LedgerCache.\n-     */\n-    void deleteLedger(long ledgerId) throws IOException {\n-        if (LOG.isDebugEnabled())\n-            LOG.debug(\"Deleting ledgerId: \" + ledgerId);\n-        // Delete the ledger's index file and close the FileInfo\n-        FileInfo fi = getFileInfo(ledgerId, false);\n-        fi.getFile().delete();\n-        fi.close();\n+    void putEntryOffset(long ledger, long entry, long offset) throws IOException;\n+    long getEntryOffset(long ledger, long entry) throws IOException;\n \n-        // Remove it from the active ledger manager\n-        activeLedgerManager.removeActiveLedger(ledgerId);\n+    void flushLedger(boolean doAll) throws IOException;\n+    long getLastEntry(long ledgerId) throws IOException;\n \n-        // Now remove it from all the other lists and maps.\n-        // These data structures need to be synchronized first before removing entries.\n-        synchronized(this) {\n-            pages.remove(ledgerId);\n-        }\n-        synchronized(fileInfoCache) {\n-            fileInfoCache.remove(ledgerId);\n-        }\n-        synchronized(cleanLedgers) {\n-            cleanLedgers.remove(ledgerId);\n-        }\n-        synchronized(dirtyLedgers) {\n-            dirtyLedgers.remove(ledgerId);\n-        }\n-        synchronized(openLedgers) {\n-            openLedgers.remove(ledgerId);\n-        }\n-    }\n+    void deleteLedger(long ledgerId) throws IOException;\n \n+    LedgerCacheBean getJMXBean();\n }"},{"sha":"dabc12de9b859297b4c0b8652c9e00948133c239","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+\n+/**\n+ * Ledger Cache Bean\n+ */\n+public interface LedgerCacheBean extends LedgerCacheMXBean, BKMBeanInfo {\n+}"},{"sha":"c0b8121ae6a9709dc942b6b5a40b1a3e65588f35","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"added","additions":788,"deletions":0,"changes":788,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,788 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Map.Entry;\n+\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of LedgerCache interface.\n+ * This class serves two purposes.\n+ */\n+public class LedgerCacheImpl implements LedgerCache {\n+    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n+\n+    final File ledgerDirectories[];\n+\n+    public LedgerCacheImpl(ServerConfiguration conf, LedgerManager alm) {\n+        this.ledgerDirectories = Bookie.getCurrentDirectories(conf.getLedgerDirs());\n+        this.openFileLimit = conf.getOpenFileLimit();\n+        this.pageSize = conf.getPageSize();\n+        this.entriesPerPage = pageSize / 8;\n+\n+        if (conf.getPageLimit() <= 0) {\n+            // allocate half of the memory to the page cache\n+            this.pageLimit = (int)((Runtime.getRuntime().maxMemory() / 3) / this.pageSize);\n+        } else {\n+            this.pageLimit = conf.getPageLimit();\n+        }\n+        LOG.info(\"maxMemory = \" + Runtime.getRuntime().maxMemory());\n+        LOG.info(\"openFileLimit is \" + openFileLimit + \", pageSize is \" + pageSize + \", pageLimit is \" + pageLimit);\n+        activeLedgerManager = alm;\n+        // Retrieve all of the active ledgers.\n+        getActiveLedgers();\n+    }\n+    /**\n+     * the list of potentially clean ledgers\n+     */\n+    LinkedList<Long> cleanLedgers = new LinkedList<Long>();\n+\n+    /**\n+     * the list of potentially dirty ledgers\n+     */\n+    LinkedList<Long> dirtyLedgers = new LinkedList<Long>();\n+\n+    HashMap<Long, FileInfo> fileInfoCache = new HashMap<Long, FileInfo>();\n+\n+    LinkedList<Long> openLedgers = new LinkedList<Long>();\n+\n+    // Manage all active ledgers in LedgerManager\n+    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers\n+    final LedgerManager activeLedgerManager;\n+\n+    final int openFileLimit;\n+    final int pageSize;\n+    final int pageLimit;\n+    final int entriesPerPage;\n+\n+    /**\n+     * @return page size used in ledger cache\n+     */\n+    public int getPageSize() {\n+        return pageSize;\n+    }\n+\n+    /**\n+     * @return entries per page used in ledger cache\n+     */\n+    public int getEntriesPerPage() {\n+        return entriesPerPage;\n+    }\n+\n+    /**\n+     * @return page limitation in ledger cache\n+     */\n+    public int getPageLimit() {\n+        return pageLimit;\n+    }\n+\n+    // The number of pages that have actually been used\n+    private int pageCount = 0;\n+    HashMap<Long, HashMap<Long,LedgerEntryPage>> pages = new HashMap<Long, HashMap<Long,LedgerEntryPage>>();\n+\n+    /**\n+     * @return number of page used in ledger cache\n+     */\n+    public int getNumUsedPages() {\n+        return pageCount;\n+    }\n+\n+    private void putIntoTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table, LedgerEntryPage lep) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(lep.getLedger());\n+        if (map == null) {\n+            map = new HashMap<Long, LedgerEntryPage>();\n+            table.put(lep.getLedger(), map);\n+        }\n+        map.put(lep.getFirstEntry(), lep);\n+    }\n+\n+    private static LedgerEntryPage getFromTable(HashMap<Long, HashMap<Long,LedgerEntryPage>> table,\n+                                                Long ledger, Long firstEntry) {\n+        HashMap<Long, LedgerEntryPage> map = table.get(ledger);\n+        if (map != null) {\n+            return map.get(firstEntry);\n+        }\n+        return null;\n+    }\n+\n+    synchronized private LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n+        LedgerEntryPage lep = getFromTable(pages, ledger, firstEntry);\n+        try {\n+            if (onlyDirty && lep.isClean()) {\n+                return null;\n+            }\n+            return lep;\n+        } finally {\n+            if (lep != null) {\n+                lep.usePage();\n+            }\n+        }\n+    }\n+\n+    /** \n+     * Grab ledger entry page whose first entry is <code>pageEntry</code>.\n+     *\n+     * If the page doesn't existed before, we allocate a memory page.\n+     * Otherwise, we grab a clean page and read it from disk.\n+     *\n+     * @param ledger\n+     *          Ledger Id\n+     * @param pageEntry\n+     *          Start entry of this entry page.\n+     */\n+    private LedgerEntryPage grabLedgerEntryPage(long ledger, long pageEntry) throws IOException {\n+        LedgerEntryPage lep = grabCleanPage(ledger, pageEntry);\n+        try {\n+            // should update page before we put it into table\n+            // otherwise we would put an empty page in it\n+            updatePage(lep);\n+            synchronized(this) {\n+                putIntoTable(pages, lep);\n+            }   \n+        } catch (IOException ie) {\n+            // if we grab a clean page, but failed to update the page\n+            // we are exhausting the count of ledger entry pages.\n+            // since this page will be never used, so we need to decrement\n+            // page count of ledger cache.\n+            lep.releasePage();\n+            synchronized (this) {\n+                --pageCount;\n+            }\n+            throw ie; \n+        }   \n+        return lep;\n+    }\n+\n+    @Override\n+    public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n+        int offsetInPage = (int) (entry % entriesPerPage);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        if (lep == null) {\n+            lep = grabLedgerEntryPage(ledger, pageEntry); \n+        }\n+        if (lep != null) {\n+            lep.setOffset(offset, offsetInPage*8);\n+            lep.releasePage();\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public long getEntryOffset(long ledger, long entry) throws IOException {\n+        int offsetInPage = (int) (entry%entriesPerPage);\n+        // find the id of the first entry of the page that has the entry\n+        // we are looking for\n+        long pageEntry = entry-offsetInPage;\n+        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        try {\n+            if (lep == null) {\n+                lep = grabLedgerEntryPage(ledger, pageEntry);\n+            }\n+            return lep.getOffset(offsetInPage*8);\n+        } finally {\n+            if (lep != null) {\n+                lep.releasePage();\n+            }\n+        }\n+    }\n+\n+    static final String getLedgerName(long ledgerId) {\n+        int parent = (int) (ledgerId & 0xff);\n+        int grandParent = (int) ((ledgerId & 0xff00) >> 8);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(Integer.toHexString(grandParent));\n+        sb.append('/');\n+        sb.append(Integer.toHexString(parent));\n+        sb.append('/');\n+        sb.append(Long.toHexString(ledgerId));\n+        sb.append(\".idx\");\n+        return sb.toString();\n+    }\n+\n+    static final private Random rand = new Random();\n+\n+    static final private File pickDirs(File dirs[]) {\n+        return dirs[rand.nextInt(dirs.length)];\n+    }\n+\n+    FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledger);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledger);\n+                if (lf == null) {\n+                    if (masterKey == null) {\n+                        throw new Bookie.NoLedgerException(ledger);\n+                    }\n+                    File dir = pickDirs(ledgerDirectories);\n+                    String ledgerName = getLedgerName(ledger);\n+                    lf = new File(dir, ledgerName);\n+                    // A new ledger index file has been created for this Bookie.\n+                    // Add this new ledger to the set of active ledgers.\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"New ledger index file created for ledgerId: \" + ledger);\n+                    }\n+                    activeLedgerManager.addActiveLedger(ledger, true);\n+                }\n+                evictFileInfoIfNecessary();\n+                fi = new FileInfo(lf, masterKey);\n+                fileInfoCache.put(ledger, fi);\n+                openLedgers.add(ledger);\n+            }\n+            if (fi != null) {\n+                fi.use();\n+            }\n+            return fi;\n+        }\n+    }\n+    private void updatePage(LedgerEntryPage lep) throws IOException {\n+        if (!lep.isClean()) {\n+            throw new IOException(\"Trying to update a dirty page\");\n+        }\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(lep.getLedger(), null);\n+            long pos = lep.getFirstEntry()*8;\n+            if (pos >= fi.size()) {\n+                lep.zeroPage();\n+            } else {\n+                lep.readPage(fi);\n+            }\n+        } finally {\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void flushLedger(boolean doAll) throws IOException {\n+        synchronized(dirtyLedgers) {\n+            if (dirtyLedgers.isEmpty()) {\n+                synchronized(this) {\n+                    for(Long l: pages.keySet()) {\n+                        if (LOG.isTraceEnabled()) {\n+                            LOG.trace(\"Adding \" + Long.toHexString(l) + \" to dirty pages\");\n+                        }\n+                        dirtyLedgers.add(l);\n+                    }\n+                }\n+            }\n+            if (dirtyLedgers.isEmpty()) {\n+                return;\n+            }\n+            while(!dirtyLedgers.isEmpty()) {\n+                Long l = dirtyLedgers.removeFirst();\n+\n+                flushLedger(l);\n+\n+                if (!doAll) {\n+                    break;\n+                }\n+                // Yield. if we are doing all the ledgers we don't want to block other flushes that\n+                // need to happen\n+                try {\n+                    dirtyLedgers.wait(1);\n+                } catch (InterruptedException e) {\n+                    // just pass it on\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Flush a specified ledger\n+     *\n+     * @param l\n+     *          Ledger Id\n+     * @throws IOException\n+     */\n+    private void flushLedger(long l) throws IOException {\n+        LinkedList<Long> firstEntryList;\n+        synchronized(this) {\n+            HashMap<Long, LedgerEntryPage> pageMap = pages.get(l);\n+            if (pageMap == null || pageMap.isEmpty()) {\n+                return;\n+            }\n+            firstEntryList = new LinkedList<Long>();\n+            for(Map.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n+                LedgerEntryPage lep = entry.getValue();\n+                if (lep.isClean()) {\n+                    if (LOG.isTraceEnabled()) {\n+                        LOG.trace(\"Page is clean \" + lep);\n+                    }\n+                    continue;\n+                }\n+                firstEntryList.add(lep.getFirstEntry());\n+            }\n+        }\n+\n+        if (firstEntryList.size() == 0) {\n+            LOG.debug(\"Nothing to flush for ledger {}.\", l);\n+            // nothing to do\n+            return;\n+        }\n+\n+        // Now flush all the pages of a ledger\n+        List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n+        FileInfo fi = null;\n+        try {\n+            for(Long firstEntry: firstEntryList) {\n+                LedgerEntryPage lep = getLedgerEntryPage(l, firstEntry, true);\n+                if (lep != null) {\n+                    entries.add(lep);\n+                }\n+            }\n+            Collections.sort(entries, new Comparator<LedgerEntryPage>() {\n+                    @Override\n+                    public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {\n+                    return (int)(o1.getFirstEntry()-o2.getFirstEntry());\n+                    }\n+                    });\n+            ArrayList<Integer> versions = new ArrayList<Integer>(entries.size());\n+            fi = getFileInfo(l, null);\n+            int start = 0;\n+            long lastOffset = -1;\n+            for(int i = 0; i < entries.size(); i++) {\n+                versions.add(i, entries.get(i).getVersion());\n+                if (lastOffset != -1 && (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {\n+                    // send up a sequential list\n+                    int count = i - start;\n+                    if (count == 0) {\n+                        LOG.warn(\"Count cannot possibly be zero!\");\n+                    }\n+                    writeBuffers(l, entries, fi, start, count);\n+                    start = i;\n+                }\n+                lastOffset = entries.get(i).getFirstEntry();\n+            }\n+            if (entries.size()-start == 0 && entries.size() != 0) {\n+                LOG.warn(\"Nothing to write, but there were entries!\");\n+            }\n+            writeBuffers(l, entries, fi, start, entries.size()-start);\n+            synchronized(this) {\n+                for(int i = 0; i < entries.size(); i++) {\n+                    LedgerEntryPage lep = entries.get(i);\n+                    lep.setClean(versions.get(i));\n+                }\n+            }\n+        } finally {\n+            for(LedgerEntryPage lep: entries) {\n+                lep.releasePage();\n+            }\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    private void writeBuffers(Long ledger,\n+                              List<LedgerEntryPage> entries, FileInfo fi,\n+                              int start, int count) throws IOException {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Writing \" + count + \" buffers of \" + Long.toHexString(ledger));\n+        }\n+        if (count == 0) {\n+            return;\n+        }\n+        ByteBuffer buffs[] = new ByteBuffer[count];\n+        for(int j = 0; j < count; j++) {\n+            buffs[j] = entries.get(start+j).getPageToWrite();\n+            if (entries.get(start+j).getLedger() != ledger) {\n+                throw new IOException(\"Writing to \" + ledger + \" but page belongs to \"\n+                                      + entries.get(start+j).getLedger());\n+            }\n+        }\n+        long totalWritten = 0;\n+        while(buffs[buffs.length-1].remaining() > 0) {\n+            long rc = fi.write(buffs, entries.get(start+0).getFirstEntry()*8);\n+            if (rc <= 0) {\n+                throw new IOException(\"Short write to ledger \" + ledger + \" rc = \" + rc);\n+            }\n+            totalWritten += rc;\n+        }\n+        if (totalWritten != (long)count * (long)pageSize) {\n+            throw new IOException(\"Short write to ledger \" + ledger + \" wrote \" + totalWritten\n+                                  + \" expected \" + count * pageSize);\n+        }\n+    }\n+    private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOException {\n+        if (entry % entriesPerPage != 0) {\n+            throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n+        }\n+        outerLoop:\n+        while(true) {\n+            synchronized(this) {\n+                if (pageCount  < pageLimit) {\n+                    // let's see if we can allocate something\n+                    LedgerEntryPage lep = new LedgerEntryPage(pageSize, entriesPerPage);\n+                    lep.setLedger(ledger);\n+                    lep.setFirstEntry(entry);\n+\n+                    // note, this will not block since it is a new page\n+                    lep.usePage();\n+                    pageCount++;\n+                    return lep;\n+                }\n+            }\n+\n+            synchronized(cleanLedgers) {\n+                if (cleanLedgers.isEmpty()) {\n+                    flushLedger(false);\n+                    synchronized(this) {\n+                        for(Long l: pages.keySet()) {\n+                            cleanLedgers.add(l);\n+                        }\n+                    }\n+                }\n+                synchronized(this) {\n+                    // if ledgers deleted between checking pageCount and putting\n+                    // ledgers into cleanLedgers list, the cleanLedgers list would be empty.\n+                    // so give it a chance to go back to check pageCount again because\n+                    // deleteLedger would decrement pageCount to return the number of pages\n+                    // occupied by deleted ledgers.\n+                    if (cleanLedgers.isEmpty()) {\n+                        continue outerLoop;\n+                    }\n+                    Long cleanLedger = cleanLedgers.getFirst();\n+                    Map<Long, LedgerEntryPage> map = pages.get(cleanLedger);\n+                    while (map == null || map.isEmpty()) {\n+                        cleanLedgers.removeFirst();\n+                        if (cleanLedgers.isEmpty()) {\n+                            continue outerLoop; \n+                        }\n+                        cleanLedger = cleanLedgers.getFirst();\n+                        map = pages.get(cleanLedger);\n+                    }\n+                    Iterator<Map.Entry<Long, LedgerEntryPage>> it = map.entrySet().iterator();\n+                    LedgerEntryPage lep = it.next().getValue();\n+                    while((lep.inUse() || !lep.isClean())) {\n+                        if (!it.hasNext()) {\n+                            // no clean page found in this ledger\n+                            cleanLedgers.removeFirst();\n+                            continue outerLoop;\n+                        }\n+                        lep = it.next().getValue();\n+                    }\n+                    it.remove();\n+                    if (map.isEmpty()) {\n+                        pages.remove(lep.getLedger());\n+                    }\n+                    lep.usePage();\n+                    lep.zeroPage();\n+                    lep.setLedger(ledger);\n+                    lep.setFirstEntry(entry);\n+                    return lep;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getLastEntry(long ledgerId) throws IOException {\n+        long lastEntry = 0;\n+        // Find the last entry in the cache\n+        synchronized(this) {\n+            Map<Long, LedgerEntryPage> map = pages.get(ledgerId);\n+            if (map != null) {\n+                for(LedgerEntryPage lep: map.values()) {\n+                    if (lep.getFirstEntry() + entriesPerPage < lastEntry) {\n+                        continue;\n+                    }\n+                    lep.usePage();\n+                    long highest = lep.getLastEntry();\n+                    if (highest > lastEntry) {\n+                        lastEntry = highest;\n+                    }\n+                    lep.releasePage();\n+                }\n+            }\n+        }\n+\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            long size = fi.size();\n+            // make sure the file size is aligned with index entry size\n+            // otherwise we may read incorret data\n+            if (0 != size % 8) {\n+                LOG.warn(\"Index file of ledger {} is not aligned with index entry size.\", ledgerId);\n+                size = size - size % 8;\n+            }\n+            // we may not have the last entry in the cache\n+            if (size > lastEntry*8) {\n+                ByteBuffer bb = ByteBuffer.allocate(getPageSize());\n+                long position = size - getPageSize();\n+                if (position < 0) {\n+                    position = 0;\n+                }\n+                fi.read(bb, position);\n+                bb.flip();\n+                long startingEntryId = position/8;\n+                for(int i = getEntriesPerPage()-1; i >= 0; i--) {\n+                    if (bb.getLong(i*8) != 0) {\n+                        if (lastEntry < startingEntryId+i) {\n+                            lastEntry = startingEntryId+i;\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (fi != null) {\n+                fi.release();\n+            }\n+        }\n+\n+        return lastEntry;\n+    }\n+\n+    /**\n+     * This method will look within the ledger directories for the ledger index\n+     * files. That will comprise the set of active ledgers this particular\n+     * BookieServer knows about that have not yet been deleted by the BookKeeper\n+     * Client. This is called only once during initialization.\n+     */\n+    private void getActiveLedgers() {\n+        // Ledger index files are stored in a file hierarchy with a parent and\n+        // grandParent directory. We'll have to go two levels deep into these\n+        // directories to find the index files.\n+        for (File ledgerDirectory : ledgerDirectories) {\n+            for (File grandParent : ledgerDirectory.listFiles()) {\n+                if (grandParent.isDirectory()) {\n+                    for (File parent : grandParent.listFiles()) {\n+                        if (parent.isDirectory()) {\n+                            for (File index : parent.listFiles()) {\n+                                if (!index.isFile() || !index.getName().endsWith(\".idx\")) {\n+                                    continue;\n+                                }\n+                                // We've found a ledger index file. The file name is the\n+                                // HexString representation of the ledgerId.\n+                                String ledgerIdInHex = index.getName().substring(0, index.getName().length() - 4);\n+                                activeLedgerManager.addActiveLedger(Long.parseLong(ledgerIdInHex, 16), true);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is called whenever a ledger is deleted by the BookKeeper Client\n+     * and we want to remove all relevant data for it stored in the LedgerCache.\n+     */\n+    @Override\n+    public void deleteLedger(long ledgerId) throws IOException {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Deleting ledgerId: \" + ledgerId);\n+\n+        // remove pages first to avoid page flushed when deleting file info\n+        synchronized(this) {\n+            Map<Long, LedgerEntryPage> lpages = pages.remove(ledgerId);\n+            if (null != lpages) {\n+                pageCount -= lpages.size();\n+                if (pageCount < 0) {\n+                    LOG.error(\"Page count of ledger cache has been decremented to be less than zero.\");\n+                }\n+            }\n+        }\n+        // Delete the ledger's index file and close the FileInfo\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            fi.close(false);\n+            fi.delete();\n+        } finally {\n+            // should release use count\n+            // otherwise the file channel would not be closed.\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+\n+        // Remove it from the active ledger manager\n+        activeLedgerManager.removeActiveLedger(ledgerId);\n+\n+        // Now remove it from all the other lists and maps.\n+        // These data structures need to be synchronized first before removing entries.\n+        synchronized(fileInfoCache) {\n+            fileInfoCache.remove(ledgerId);\n+        }\n+        synchronized(cleanLedgers) {\n+            cleanLedgers.remove(ledgerId);\n+        }\n+        synchronized(dirtyLedgers) {\n+            dirtyLedgers.remove(ledgerId);\n+        }\n+        synchronized(openLedgers) {\n+            openLedgers.remove(ledgerId);\n+        }\n+    }\n+\n+    private File findIndexFile(long ledgerId) throws IOException {\n+        String ledgerName = getLedgerName(ledgerId);\n+        for(File d: ledgerDirectories) {\n+            File lf = new File(d, ledgerName);\n+            if (lf.exists()) {\n+                return lf;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledgerId);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledgerId);\n+                if (lf == null) {\n+                    throw new Bookie.NoLedgerException(ledgerId);\n+                }\n+                evictFileInfoIfNecessary();        \n+                fi = new FileInfo(lf, null);\n+                byte[] key = fi.getMasterKey();\n+                fileInfoCache.put(ledgerId, fi);\n+                openLedgers.add(ledgerId);\n+                return key;\n+            }\n+            return fi.getMasterKey();\n+        }\n+    }\n+\n+    // evict file info if necessary\n+    private void evictFileInfoIfNecessary() throws IOException {\n+        if (openLedgers.size() > openFileLimit) {\n+            long ledgerToRemove = openLedgers.removeFirst();\n+            LOG.info(\"Ledger {} is evicted from file info cache.\",\n+                     ledgerToRemove);\n+            fileInfoCache.remove(ledgerToRemove).close(true);\n+        }\n+    }\n+\n+    @Override\n+    public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, masterKey);\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean ledgerExists(long ledgerId) throws IOException {\n+        synchronized(fileInfoCache) {\n+            FileInfo fi = fileInfoCache.get(ledgerId);\n+            if (fi == null) {\n+                File lf = findIndexFile(ledgerId);\n+                if (lf == null) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public LedgerCacheBean getJMXBean() {\n+        return new LedgerCacheBean() {\n+            @Override\n+            public String getName() {\n+                return \"LedgerCache\";\n+            }\n+\n+            @Override\n+            public boolean isHidden() {\n+                return false;\n+            }\n+\n+            @Override\n+            public int getPageCount() {\n+                return LedgerCacheImpl.this.getNumUsedPages();\n+            }\n+\n+            @Override\n+            public int getPageSize() {\n+                return LedgerCacheImpl.this.getPageSize();\n+            }\n+\n+            @Override\n+            public int getOpenFileLimit() {\n+                return openFileLimit;\n+            }\n+\n+            @Override\n+            public int getPageLimit() {\n+                return LedgerCacheImpl.this.getPageLimit();\n+            }\n+\n+            @Override\n+            public int getNumCleanLedgers() {\n+                return cleanLedgers.size();\n+            }\n+\n+            @Override\n+            public int getNumDirtyLedgers() {\n+                return dirtyLedgers.size();\n+            }\n+\n+            @Override\n+            public int getNumOpenLedgers() {\n+                return openLedgers.size();\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        for (Entry<Long, FileInfo> fileInfo : fileInfoCache.entrySet()) {\n+            FileInfo value = fileInfo.getValue();\n+            if (value != null) {\n+                value.close(true);\n+            }\n+        }\n+    }\n+}"},{"sha":"a1a30e29bc8ffc52d862cb800ffcb497145153e5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,60 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+/**\n+ * Ledger Cache MBean\n+ */\n+public interface LedgerCacheMXBean {\n+\n+    /**\n+     * @return number of page used in cache\n+     */\n+    public int getPageCount();\n+\n+    /**\n+     * @return page size\n+     */\n+    public int getPageSize();\n+\n+    /**\n+     * @return the limit of open files\n+     */\n+    public int getOpenFileLimit();\n+\n+    /**\n+     * @return the limit number of pages\n+     */\n+    public int getPageLimit();\n+\n+    /**\n+     * @return number of clean ledgers\n+     */\n+    public int getNumCleanLedgers();\n+\n+    /**\n+     * @return number of dirty ledgers\n+     */\n+    public int getNumDirtyLedgers();\n+\n+    /**\n+     * @return number of open ledgers\n+     */\n+    public int getNumOpenLedgers();\n+}"},{"sha":"cfeab64118718dfc9faa3f94c96b98766f61e59a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":23,"deletions":110,"changes":133,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -23,127 +23,40 @@\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n+import java.util.Arrays;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n-\n /**\n  * Implements a ledger inside a bookie. In particular, it implements operations\n  * to write entries to a ledger and read entries from a ledger.\n- *\n  */\n-public class LedgerDescriptor {\n-    final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n-    LedgerCache ledgerCache;\n-    LedgerDescriptor(long ledgerId, EntryLogger entryLogger, LedgerCache ledgerCache) {\n-        this.ledgerId = ledgerId;\n-        this.entryLogger = entryLogger;\n-        this.ledgerCache = ledgerCache;\n-    }\n-\n-    private ByteBuffer masterKey = null;\n-    volatile private boolean fenced = false;\n-\n-    void setMasterKey(ByteBuffer masterKey) {\n-        this.masterKey = masterKey;\n-    }\n-\n-    boolean cmpMasterKey(ByteBuffer masterKey) {\n-        return this.masterKey.equals(masterKey);\n-    }\n-\n-    private long ledgerId;\n-    public long getLedgerId() {\n-        return ledgerId;\n-    }\n-\n-    EntryLogger entryLogger;\n-    private int refCnt;\n-    synchronized public void incRef() {\n-        refCnt++;\n-    }\n-    synchronized public void decRef() {\n-        refCnt--;\n-    }\n-    synchronized public int getRefCnt() {\n-        return refCnt;\n-    }\n-    \n-    void setFenced() {\n-        fenced = true;\n-    }\n-    \n-    boolean isFenced() {\n-        return fenced;\n-    }\n-\n-    long addEntry(ByteBuffer entry) throws IOException {\n-        long ledgerId = entry.getLong();\n-\n-        if (ledgerId != this.ledgerId) {\n-            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n+public abstract class LedgerDescriptor {\n+    static LedgerDescriptor create(byte[] masterKey,\n+                                   long ledgerId,\n+                                   LedgerStorage ledgerStorage) throws IOException {\n+        LedgerDescriptor ledger = new LedgerDescriptorImpl(masterKey, ledgerId, ledgerStorage);\n+        ledgerStorage.setMasterKey(ledgerId, masterKey);\n+        return ledger;\n+    }\n+\n+    static LedgerDescriptor createReadOnly(long ledgerId,\n+                                           LedgerStorage ledgerStorage)\n+            throws IOException, Bookie.NoLedgerException {\n+        if (!ledgerStorage.ledgerExists(ledgerId)) {\n+            throw new Bookie.NoLedgerException(ledgerId);\n         }\n-        long entryId = entry.getLong();\n-        entry.rewind();\n+        return new LedgerDescriptorReadOnlyImpl(ledgerId, ledgerStorage);\n+    }\n \n-        /*\n-         * Log the entry\n-         */\n-        long pos = entryLogger.addEntry(ledgerId, entry);\n+    abstract void checkAccess(byte masterKey[]) throws BookieException, IOException;\n \n+    abstract long getLedgerId();\n \n-        /*\n-         * Set offset of entry id to be the current ledger position\n-         */\n-        ledgerCache.putEntryOffset(ledgerId, entryId, pos);\n-        return entryId;\n-    }\n-    ByteBuffer readEntry(long entryId) throws IOException {\n-        long offset;\n-        /*\n-         * If entryId is -1, then return the last written.\n-         */\n-        if (entryId == -1) {\n-            long lastEntry = ledgerCache.getLastEntry(ledgerId);\n-            FileInfo fi = null;\n-            try {\n-                fi = ledgerCache.getFileInfo(ledgerId, false);\n-                long size = fi.size();\n-                // we may not have the last entry in the cache\n-                if (size > lastEntry*8) {\n-                    ByteBuffer bb = ByteBuffer.allocate(ledgerCache.getPageSize());\n-                    long position = size - ledgerCache.getPageSize();\n-                    if (position < 0) {\n-                        position = 0;\n-                    }\n-                    fi.read(bb, position);\n-                    bb.flip();\n-                    long startingEntryId = position/8;\n-                    for(int i = ledgerCache.getEntriesPerPage()-1; i >= 0; i--) {\n-                        if (bb.getLong(i*8) != 0) {\n-                            if (lastEntry < startingEntryId+i) {\n-                                lastEntry = startingEntryId+i;\n-                            }\n-                            break;\n-                        }\n-                    }\n-                }\n-            } finally {\n-                if (fi != null) {\n-                    fi.release();\n-                }\n-            }\n-            entryId = lastEntry;\n-        }\n+    abstract void setFenced() throws IOException;\n+    abstract boolean isFenced();\n \n-        offset = ledgerCache.getEntryOffset(ledgerId, entryId);\n-        if (offset == 0) {\n-            throw new Bookie.NoEntryException(ledgerId, entryId);\n-        }\n-        return ByteBuffer.wrap(entryLogger.readEntry(ledgerId, entryId, offset));\n-    }\n-    void close() {\n-    }\n+    abstract long addEntry(ByteBuffer entry) throws IOException;\n+    abstract ByteBuffer readEntry(long entryId) throws IOException;\n }"},{"sha":"e05ecb7179d70de375df61da94bec71ce0484aec","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,88 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a ledger inside a bookie. In particular, it implements operations\n+ * to write entries to a ledger and read entries from a ledger.\n+ *\n+ */\n+public class LedgerDescriptorImpl extends LedgerDescriptor {\n+    final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n+    final LedgerStorage ledgerStorage;\n+    private long ledgerId;\n+\n+    volatile private boolean fenced = false;\n+    final byte[] masterKey;\n+\n+    LedgerDescriptorImpl(byte[] masterKey, long ledgerId, LedgerStorage ledgerStorage) {\n+        this.masterKey = masterKey;\n+        this.ledgerId = ledgerId;\n+        this.ledgerStorage = ledgerStorage;\n+    }\n+\n+    @Override\n+    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n+        if (!Arrays.equals(this.masterKey, masterKey)) {\n+            throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+        }\n+    }\n+\n+    @Override\n+    public long getLedgerId() {\n+        return ledgerId;\n+    }\n+\n+    @Override\n+    void setFenced() throws IOException {\n+        fenced = true;\n+    }\n+\n+    @Override\n+    boolean isFenced() {\n+        return fenced;\n+    }\n+\n+    @Override\n+    long addEntry(ByteBuffer entry) throws IOException {\n+        long ledgerId = entry.getLong();\n+\n+        if (ledgerId != this.ledgerId) {\n+            throw new IOException(\"Entry for ledger \" + ledgerId + \" was sent to \" + this.ledgerId);\n+        }\n+        entry.rewind();\n+\n+        return ledgerStorage.addEntry(entry);\n+    }\n+\n+    @Override\n+    ByteBuffer readEntry(long entryId) throws IOException {\n+        return ledgerStorage.getEntry(ledgerId, entryId);\n+    }\n+}"},{"sha":"476bc28e2dbb1ec4764a4ca30aaa04ab34f2bc4a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorReadOnlyImpl.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,52 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+/**\n+ * Implements a ledger inside a bookie. In particular, it implements operations\n+ * to write entries to a ledger and read entries from a ledger.\n+ */\n+public class LedgerDescriptorReadOnlyImpl extends LedgerDescriptorImpl {\n+    LedgerDescriptorReadOnlyImpl(long ledgerId, LedgerStorage storage) {\n+        super(null, ledgerId, storage);\n+    }\n+\n+    @Override\n+    void setFenced() throws IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+\n+    @Override\n+    long addEntry(ByteBuffer entry) throws IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+\n+    @Override\n+    void checkAccess(byte masterKey[]) throws BookieException, IOException {\n+        assert false;\n+        throw new IOException(\"Invalid action on read only descriptor\");\n+    }\n+}"},{"sha":"8395a2f776feadd87652fcad8b2e59d0b64190de","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -24,6 +24,8 @@\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+import org.apache.bookkeeper.proto.BookieProtocol;\n+\n /**\n  * This is a page in the LedgerCache. It holds the locations\n  * (entrylogfile, offset) for entry ids.\n@@ -32,7 +34,7 @@\n     private final int pageSize;\n     private final int entriesPerPage;\n     private long ledger = -1;\n-    private long firstEntry = -1;\n+    private long firstEntry = BookieProtocol.INVALID_ENTRY_ID;\n     private final ByteBuffer page;\n     private boolean clean = true;\n     private boolean pinned = false;\n@@ -80,8 +82,12 @@ synchronized private void checkPage() {\n     }\n     @Override\n     public boolean equals(Object other) {\n-        LedgerEntryPage otherLEP = (LedgerEntryPage) other;\n-        return otherLEP.getLedger() == getLedger() && otherLEP.getFirstEntry() == getFirstEntry();\n+        if (other instanceof LedgerEntryPage) {\n+            LedgerEntryPage otherLEP = (LedgerEntryPage) other;\n+            return otherLEP.getLedger() == getLedger() && otherLEP.getFirstEntry() == getFirstEntry();\n+        } else {\n+            return false;\n+        }\n     }\n     @Override\n     public int hashCode() {"},{"sha":"14f133800420215ee1468cb52f63a764c0dc7a1a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,91 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+\n+/**\n+ * Interface for storing ledger data\n+ * on persistant storage.\n+ */\n+interface LedgerStorage {\n+    /**\n+     * Start any background threads\n+     * belonging to the storage system. For example,\n+     * garbage collection.\n+     */\n+    void start();\n+\n+    /**\n+     * Cleanup and free any resources\n+     * being used by the storage system.\n+     */\n+    void shutdown() throws InterruptedException;\n+\n+    /**\n+     * Whether a ledger exists\n+     */\n+    boolean ledgerExists(long ledgerId) throws IOException;\n+\n+    /**\n+     * Set the master key for a ledger\n+     */\n+    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n+\n+    /**\n+     * Get the master key for a ledger\n+     * @throws IOException if there is an error reading the from the ledger\n+     * @throws BookieException if no such ledger exists\n+     */\n+    byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n+\n+    /**\n+     * Add an entry to the storage.\n+     * @return the entry id of the entry added\n+     */\n+    long addEntry(ByteBuffer entry) throws IOException;\n+\n+    /**\n+     * Read an entry from storage\n+     */\n+    ByteBuffer getEntry(long ledgerId, long entryId) throws IOException;\n+\n+    /**\n+     * Whether there is data in the storage which needs to be flushed\n+     */\n+    boolean isFlushRequired();\n+\n+    /**\n+     * Flushes all data in the storage. Once this is called,\n+     * add data written to the LedgerStorage up until this point\n+     * has been persisted to perminant storage\n+     */\n+    void flush() throws IOException;\n+\n+    /**\n+     * Get the JMX management bean for this LedgerStorage\n+     */\n+    BKMBeanInfo getJMXBean();\n+}\n\\ No newline at end of file"},{"sha":"632b162590ec26afd52933d331919eb910b67c6c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":12,"deletions":10,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -31,7 +31,7 @@\n          * @param entryId\n          *          entry identifier\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n         void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n     }\n@@ -45,7 +45,7 @@\n          * @param lh\n          *          ledger handle\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n         void closeComplete(int rc, LedgerHandle lh, Object ctx);\n     }\n@@ -59,7 +59,7 @@\n          * @param lh\n          *          ledger handle\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n \n         void createComplete(int rc, LedgerHandle lh, Object ctx);\n@@ -74,7 +74,7 @@\n          * @param lh\n          *          ledger handle\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n \n         public void openComplete(int rc, LedgerHandle lh, Object ctx);\n@@ -92,7 +92,7 @@\n          * @param seq\n          *          sequence of entries\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n \n         void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n@@ -106,7 +106,7 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n          * @param rc\n          *          return code\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n         void deleteComplete(int rc, Object ctx);\n     }\n@@ -115,10 +115,12 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         /**\n          * Callback definition for bookie recover operations\n          *\n-         * @param rc\n-         *          return code\n+         * @param rc Return code\n+         * @param lastConfirmed The entry id of the last confirmed write or\n+         *                      {@link LedgerHandle#INVALID_ENTRY_ID INVALID_ENTRY_ID}\n+         *                      if no entry has been confirmed\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n         void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n     }\n@@ -130,7 +132,7 @@ void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n          * @param rc\n          *          return code\n          * @param ctx\n-         *          control object\n+         *          context object\n          */\n         void recoverComplete(int rc, Object ctx);\n     }"},{"sha":"484a055790e8572e8593b04085fd0a168285350e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -78,6 +78,8 @@ public static BKException create(int code) {\n             return new BKProtocolVersionException();\n         case Code.LedgerFencedException:\n             return new BKLedgerFencedException();\n+        case Code.UnauthorizedAccessException:\n+            return new BKUnauthorizedAccessException();\n         default:\n             return new BKIllegalOpException();\n         }\n@@ -108,6 +110,7 @@ public static BKException create(int code) {\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n+        int UnauthorizedAccessException = -102;\n     }\n \n     public void setCode(int code) {\n@@ -156,6 +159,8 @@ public static String getMessage(int code) {\n             return \"Bookie protocol version on server is incompatible with client\";\n         case Code.LedgerFencedException:\n             return \"Ledger has been fenced off. Some other client must have opened it to read\";\n+        case Code.UnauthorizedAccessException:\n+            return \"Attempted to access ledger using the wrong password\";\n         default:\n             return \"Invalid operation\";\n         }\n@@ -268,4 +273,10 @@ public BKLedgerFencedException() {\n             super(Code.LedgerFencedException);\n         }\n     }\n+\n+    public static class BKUnauthorizedAccessException extends BKException {\n+        public BKUnauthorizedAccessException() {\n+            super(Code.UnauthorizedAccessException);\n+        }\n+    }\n }"},{"sha":"fd879ed8feb3596d99bb1d1890b64b6255650d22","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":81,"deletions":47,"changes":128,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -24,6 +24,9 @@\n import java.io.IOException;\n import java.util.concurrent.Executors;\n \n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -41,6 +44,7 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.apache.bookkeeper.util.SafeRunnable;\n \n /**\n  * BookKeeper client. We assume there is one single writer to a ledger at any\n@@ -59,28 +63,32 @@\n \n     static final Logger LOG = LoggerFactory.getLogger(BookKeeper.class);\n \n-    ZooKeeper zk = null;\n-    // whether the zk handle is one we created, or is owned by whoever\n-    // instantiated us\n-    boolean ownZKHandle = false;\n+    final ZooKeeper zk;\n+    final CountDownLatch connectLatch = new CountDownLatch(1);\n+    final static int zkConnectTimeoutMs = 5000;\n+    final ClientSocketChannelFactory channelFactory;\n \n-    ClientSocketChannelFactory channelFactory;\n     // whether the socket factory is one we created, or is owned by whoever\n     // instantiated us\n     boolean ownChannelFactory = false;\n+    // whether the zk handle is one we created, or is owned by whoever\n+    // instantiated us\n+    boolean ownZKHandle = false;\n \n-    BookieClient bookieClient;\n-    BookieWatcher bookieWatcher;\n+    final BookieClient bookieClient;\n+    final BookieWatcher bookieWatcher;\n \n-    OrderedSafeExecutor callbackWorker = new OrderedSafeExecutor(Runtime\n-            .getRuntime().availableProcessors());\n-    OrderedSafeExecutor mainWorkerPool = new OrderedSafeExecutor(Runtime\n-            .getRuntime().availableProcessors());\n+    final OrderedSafeExecutor mainWorkerPool;\n \n     // Ledger manager responsible for how to store ledger meta data\n     final LedgerManager ledgerManager;\n \n-    ClientConfiguration conf;\n+    final ClientConfiguration conf;\n+\n+    interface ZKConnectCallback {\n+        public void connected();\n+        public void connectionFailed(int code);\n+    }\n \n     /**\n      * Create a bookkeeper client. A zookeeper client and a client socket factory\n@@ -90,7 +98,7 @@\n      *          A list of one of more servers on which zookeeper is running. The\n      *          client assumes that the running bookies have been registered with\n      *          zookeeper under the path\n-     *          {@link BookieWatcher#BOOKIE_REGISTRATION_PATH}\n+     *          {@link BookieWatcher#bookieRegistrationPath}\n      * @throws IOException\n      * @throws InterruptedException\n      * @throws KeeperException\n@@ -111,21 +119,39 @@ public BookKeeper(String servers) throws IOException, InterruptedException,\n      * @throws InterruptedException\n      * @throws KeeperException\n      */\n-    public BookKeeper(ClientConfiguration conf) throws IOException, InterruptedException,\n-        KeeperException {\n-        this(conf, new ZooKeeper(conf.getZkServers(), conf.getZkTimeout(), new Watcher() {\n-            @Override\n-            public void process(WatchedEvent event) {\n-                // TODO: handle session disconnects and expires\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n-                }\n-            }\n-        }), new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                              Executors.newCachedThreadPool()));\n+    public BookKeeper(final ClientConfiguration conf)\n+            throws IOException, InterruptedException, KeeperException {\n+        this.conf = conf;\n+\n+        final CountDownLatch zkConnectLatch = new CountDownLatch(1);\n+        this.zk = new ZooKeeper(conf.getZkServers(), conf.getZkTimeout(),\n+                new Watcher() {\n+                    @Override\n+                    public void process(WatchedEvent event) {\n+                        // countdown the latch on all events, even if we haven't\n+                        // successfully connected.\n+                        zkConnectLatch.countDown();\n+\n+                        // TODO: handle session disconnects and expires\n+                        LOG.debug(\"Process: {} {}\", event.getType(), event.getPath());\n+                    }\n+                });\n+        if (!zkConnectLatch.await(conf.getZkTimeout(), TimeUnit.MILLISECONDS)\n+            || !zk.getState().isConnected()) {\n+            throw KeeperException.create(KeeperException.Code.CONNECTIONLOSS);\n+        }\n+\n+        this.channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n+                                                                Executors.newCachedThreadPool());\n+        mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n+        bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n+        bookieWatcher = new BookieWatcher(conf, this);\n+        bookieWatcher.readBookiesBlocking();\n+\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n \n-        ownZKHandle = true;\n         ownChannelFactory = true;\n+        ownZKHandle = true;\n      }\n \n     /**\n@@ -158,25 +184,32 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n      *          {@link ClientConfiguration}\n      * @param zk\n      *          Zookeeper client instance connected to the zookeeper with which\n-     *          the bookies have registered\n+     *          the bookies have registered. The ZooKeeper client must be connected\n+     *          before it is passed to BookKeeper. Otherwise a KeeperException is thrown.\n      * @param channelFactory\n      *          A factory that will be used to create connections to the bookies\n      * @throws IOException\n      * @throws InterruptedException\n-     * @throws KeeperException\n+     * @throws KeeperException if the passed zk handle is not connected\n      */\n     public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n             throws IOException, InterruptedException, KeeperException {\n         if (zk == null || channelFactory == null) {\n             throw new NullPointerException();\n         }\n+        if (!zk.getState().isConnected()) {\n+            LOG.error(\"Unconnected zookeeper handle passed to bookkeeper\");\n+            throw KeeperException.create(KeeperException.Code.CONNECTIONLOSS);\n+        }\n         this.conf = conf;\n         this.zk = zk;\n         this.channelFactory = channelFactory;\n-        bookieWatcher = new BookieWatcher(this);\n-        bookieWatcher.readBookiesBlocking();\n+\n+        mainWorkerPool = new OrderedSafeExecutor(conf.getNumWorkerThreads());\n         bookieClient = new BookieClient(conf, channelFactory, mainWorkerPool);\n-        // intialize ledger meta manager\n+        bookieWatcher = new BookieWatcher(conf, this);\n+        bookieWatcher.readBookiesBlocking();\n+\n         ledgerManager = LedgerManagerFactory.newLedgerManager(conf, zk);\n     }\n \n@@ -235,12 +268,10 @@ BookieClient getBookieClient() {\n      * @param ctx\n      *          optional control object\n      */\n-    public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType,\n-                                  byte[] passwd, CreateCallback cb, Object ctx) {\n-\n-        new LedgerCreateOp(this, ensSize, qSize, digestType, passwd, cb, ctx)\n-        .initiate();\n-\n+    public void asyncCreateLedger(final int ensSize, final int qSize, final DigestType digestType,\n+                                  final byte[] passwd, final CreateCallback cb, final Object ctx) {\n+        new LedgerCreateOp(BookKeeper.this, ensSize, qSize, digestType, passwd, cb, ctx)\n+            .initiate();\n     }\n \n \n@@ -322,9 +353,9 @@ public LedgerHandle createLedger(int ensSize, int qSize,\n      * @param ctx\n      *          optional control object\n      */\n-    public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n-                                OpenCallback cb, Object ctx) {\n-        new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiate();\n+    public void asyncOpenLedger(final long lId, final DigestType digestType, final byte passwd[],\n+                                final OpenCallback cb, final Object ctx) {\n+        new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiate();\n     }\n \n     /**\n@@ -354,9 +385,9 @@ public void asyncOpenLedger(long lId, DigestType digestType, byte passwd[],\n      * @param ctx\n      *          optional control object\n      */\n-    public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte passwd[],\n-                                          OpenCallback cb, Object ctx) {\n-        new LedgerOpenOp(this, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();\n+    public void asyncOpenLedgerNoRecovery(final long lId, final DigestType digestType, final byte passwd[],\n+                                          final OpenCallback cb, final Object ctx) {\n+        new LedgerOpenOp(BookKeeper.this, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();\n     }\n \n \n@@ -441,8 +472,8 @@ public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte p\n      * @param ctx\n      *            optional control object\n      */\n-    public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n-        new LedgerDeleteOp(this, lId, cb, ctx).initiate();\n+    public void asyncDeleteLedger(final long lId, final DeleteCallback cb, final Object ctx) {\n+        new LedgerDeleteOp(BookKeeper.this, lId, cb, ctx).initiate();\n     }\n \n \n@@ -453,6 +484,7 @@ public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) {\n      * @param lId\n      *            ledgerId\n      * @throws InterruptedException\n+     * @throws BKException.BKNoSuchLedgerExistsException if the ledger doesn't exist\n      * @throws BKException\n      */\n     public void deleteLedger(long lId) throws InterruptedException, BKException {\n@@ -462,7 +494,10 @@ public void deleteLedger(long lId) throws InterruptedException, BKException {\n         asyncDeleteLedger(lId, new SyncDeleteCallback(), counter);\n         // Wait\n         counter.block(0);\n-        if (counter.getrc() != KeeperException.Code.OK.intValue()) {\n+        if (counter.getrc() == KeeperException.Code.NONODE.intValue()) {\n+            LOG.warn(\"Ledger node does not exist in ZooKeeper: ledgerId={}\", lId);\n+            throw BKException.create(Code.NoSuchLedgerExistsException);\n+        } else if (counter.getrc() != KeeperException.Code.OK.intValue()) {\n             LOG.error(\"ZooKeeper error deleting ledger node: \" + counter.getrc());\n             throw BKException.create(Code.ZKException);\n         }\n@@ -482,7 +517,6 @@ public void close() throws InterruptedException, BKException {\n         if (ownZKHandle) {\n             zk.close();\n         }\n-        callbackWorker.shutdown();\n         mainWorkerPool.shutdown();\n     }\n "},{"sha":"8423de9b38d8845e9d2a07c1884ccb0ff9e12f4d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":91,"deletions":19,"changes":110,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -30,12 +30,15 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -62,7 +65,7 @@\n     // ZK client instance\n     private ZooKeeper zk;\n     // ZK ledgers related String constants\n-    static final String BOOKIES_PATH = BookieWatcher.BOOKIE_REGISTRATION_PATH;\n+    private final String bookiesPath;\n \n     // BookKeeper client instance\n     private BookKeeper bkc;\n@@ -83,7 +86,6 @@\n     private DigestType DIGEST_TYPE;\n     private byte[] PASSWD;\n \n-    \n     /**\n      * Constructor that takes in a ZooKeeper servers connect string so we know\n      * how to connect to ZooKeeper to retrieve information about the BookKeeper\n@@ -127,17 +129,25 @@ public BookKeeperAdmin(String zkServers) throws IOException, InterruptedExceptio\n      */\n     public BookKeeperAdmin(ClientConfiguration conf) throws IOException, InterruptedException, KeeperException {\n         // Create the ZooKeeper client instance\n+        final CountDownLatch latch = new CountDownLatch(1);\n         zk = new ZooKeeper(conf.getZkServers(), conf.getZkTimeout(), new Watcher() {\n             @Override\n             public void process(WatchedEvent event) {\n+                latch.countDown();\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Process: \" + event.getType() + \" \" + event.getPath());\n                 }\n             }\n         });\n-\n+        if (!latch.await(conf.getZkTimeout(), TimeUnit.MILLISECONDS)\n+            || !zk.getState().isConnected()) {\n+            throw KeeperException.create(KeeperException.Code.CONNECTIONLOSS);\n+        }\n+        // Create the bookie path\n+        bookiesPath = conf.getZkAvailableBookiesPath();\n         // Create the BookKeeper client instance\n-        bkc = new BookKeeper(conf);\n+        bkc = new BookKeeper(conf, zk);\n+\n         DIGEST_TYPE = conf.getBookieRecoveryDigestType();\n         PASSWD = conf.getBookieRecoveryPasswd();\n     }\n@@ -183,7 +193,7 @@ private DigestType getLedgerDigestType(long ledgerId) {\n     }\n \n     // Object used for calling async methods and waiting for them to complete.\n-    class SyncObject {\n+    static class SyncObject {\n         boolean value;\n         int rc;\n \n@@ -265,7 +275,7 @@ public void recoverComplete(int rc, Object ctx) {\n     public void asyncRecoverBookieData(final InetSocketAddress bookieSrc, final InetSocketAddress bookieDest,\n                                        final RecoverCallback cb, final Object context) {\n         // Sync ZK to make sure we're reading the latest bookie data.\n-        zk.sync(BOOKIES_PATH, new AsyncCallback.VoidCallback() {\n+        zk.sync(bookiesPath, new AsyncCallback.VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (rc != Code.OK.intValue()) {\n@@ -305,7 +315,7 @@ private void getAvailableBookies(final InetSocketAddress bookieSrc, final InetSo\n             // Now poll ZK to get the active ledgers\n             getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n         } else {\n-            zk.getChildren(BOOKIES_PATH, null, new AsyncCallback.ChildrenCallback() {\n+            zk.getChildren(bookiesPath, null, new AsyncCallback.ChildrenCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, List<String> children) {\n                     if (rc != Code.OK.intValue()) {\n@@ -324,7 +334,7 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                         availableBookies.add(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n                     }\n                     // Now poll ZK to get the active ledgers\n-                    getActiveLedgers(bookieSrc, bookieDest, cb, context, availableBookies);\n+                    getActiveLedgers(bookieSrc, null, cb, context, availableBookies);\n                 }\n             }, null);\n         }\n@@ -426,8 +436,8 @@ private void recoverLedger(final InetSocketAddress bookieSrc, final long lId,\n          * ledger fragments are stored on. Check if any of the ledger fragments\n          * for the current ledger are stored on the input dead bookie.\n          */\n-        DigestType digestType = getLedgerDigestType(lId);\n-        byte[] passwd = getLedgerPasswd(lId);\n+        final DigestType digestType = getLedgerDigestType(lId);\n+        final byte[] passwd = getLedgerPasswd(lId);\n         bkc.asyncOpenLedgerNoRecovery(lId, digestType, passwd, new OpenCallback() {\n             @Override\n             public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n@@ -436,6 +446,39 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                     ledgerIterCb.processResult(rc, null, null);\n                     return;\n                 }\n+\n+                LedgerMetadata lm = lh.getLedgerMetadata();\n+                if (!lm.isClosed() &&\n+                    lm.getEnsembles().size() > 0) {\n+                    Long lastKey = lm.getEnsembles().lastKey();\n+                    ArrayList<InetSocketAddress> lastEnsemble = lm.getEnsembles().get(lastKey);\n+                    // the original write has not removed faulty bookie from\n+                    // current ledger ensemble. to avoid data loss issue in\n+                    // the case of concurrent updates to the ensemble composition,\n+                    // the recovery tool should first close the ledger\n+                    if (lastEnsemble.contains(bookieSrc)) {\n+                        // close opened non recovery ledger handle\n+                        try {\n+                            lh.close();\n+                        } catch (Exception ie) {\n+                            LOG.warn(\"Error closing non recovery ledger handle for ledger \" + lId, ie);\n+                        }\n+                        bkc.asyncOpenLedger(lId, digestType, passwd, new OpenCallback() {\n+                            @Override\n+                            public void openComplete(int newrc, final LedgerHandle newlh, Object newctx) {\n+                                if (newrc != Code.OK.intValue()) {\n+                                    LOG.error(\"BK error close ledger: \" + lId, BKException.create(newrc));\n+                                    ledgerIterCb.processResult(newrc, null, null);\n+                                    return;\n+                                }\n+                                // do recovery\n+                                recoverLedger(bookieSrc, lId, ledgerIterCb, availableBookies);\n+                            }\n+                        }, null);\n+                        return;\n+                    }\n+                }\n+\n                 /*\n                  * This List stores the ledger fragments to recover indexed by\n                  * the start entry ID for the range. The ensembles TreeMap is\n@@ -465,6 +508,12 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                         ledgerFragmentsToRecover.add(entry.getKey());\n                     }\n                 }\n+                // add last ensemble otherwise if the failed bookie existed in\n+                // the last ensemble of a closed ledger. the entries belonged to\n+                // last ensemble would not be replicated.\n+                if (curEntryId != null) {\n+                    ledgerFragmentsRange.put(curEntryId, lh.getLastAddConfirmed());\n+                }\n                 /*\n                  * See if this current ledger contains any ledger fragment that\n                  * needs to be re-replicated. If not, then just invoke the\n@@ -503,7 +552,6 @@ public void openComplete(int rc, final LedgerHandle lh, Object ctx) {\n                                   + \",\" + endEntryId + \"] of ledger \" + lh.getId()\n                                   + \" to \" + newBookie);\n                     }\n-\n                     try {\n                         SingleFragmentCallback cb = new SingleFragmentCallback(\n                                                                                ledgerFragmentsMcb, lh, startEntryId, bookieSrc, newBookie);\n@@ -551,6 +599,12 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n             cb.processResult(BKException.Code.OK, null, null);\n             return;\n         }\n+        if (startEntryId > endEntryId) {\n+            // for open ledger which there is no entry, the start entry id is 0, the end entry id is -1.\n+            // we can return immediately to trigger forward read\n+            cb.processResult(BKException.Code.OK, null, null);\n+            return;\n+        }\n \n         ArrayList<InetSocketAddress> curEnsemble = lh.getLedgerMetadata().getEnsembles().get(startEntryId);\n         int bookieIndex = 0;\n@@ -603,7 +657,7 @@ private void recoverLedgerFragment(final InetSocketAddress bookieSrc, final Ledg\n      *            entries that were stored on the failed bookie.\n      */\n     private void recoverLedgerFragmentEntry(final Long entryId, final LedgerHandle lh,\n-                                            final MultiCallback ledgerFragmentEntryMcb, \n+                                            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,\n                                             final InetSocketAddress newBookie) throws InterruptedException {\n         /*\n          * Read the ledger entry using the LedgerHandle. This will allow us to\n@@ -658,14 +712,15 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n      * Once finished propogate callback up to ledgerFragmentsMcb which should\n      * be a multicallback responsible for all fragments in a single ledger\n      */\n-    class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n-        final MultiCallback ledgerFragmentsMcb;\n+    static class SingleFragmentCallback implements AsyncCallback.VoidCallback {\n+        final AsyncCallback.VoidCallback ledgerFragmentsMcb;\n         final LedgerHandle lh;\n         final long fragmentStartId;\n         final InetSocketAddress oldBookie;\n         final InetSocketAddress newBookie;\n \n-        SingleFragmentCallback(MultiCallback ledgerFragmentsMcb, LedgerHandle lh, \n+        SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,\n+                               LedgerHandle lh,\n                                long fragmentStartId,\n                                InetSocketAddress oldBookie,\n                                InetSocketAddress newBookie) {\n@@ -684,6 +739,10 @@ public void processResult(int rc, String path, Object ctx) {\n                 ledgerFragmentsMcb.processResult(rc, null, null);\n                 return;\n             }\n+            writeLedgerConfig();\n+        }\n+\n+        protected void writeLedgerConfig() {\n             /*\n              * Update the ledger metadata's ensemble info to point\n              * to the new bookie.\n@@ -693,20 +752,32 @@ public void processResult(int rc, String path, Object ctx) {\n             int deadBookieIndex = ensemble.indexOf(oldBookie);\n             ensemble.remove(deadBookieIndex);\n             ensemble.add(deadBookieIndex, newBookie);\n-            \n-            \n+\n             lh.writeLedgerConfig(new WriteCb(), null);\n         }\n         \n         private class WriteCb implements AsyncCallback.StatCallback {\n             @Override\n-            public void processResult(int rc, String path, Object ctx, Stat stat) {\n+            public void processResult(int rc, final String path, Object ctx, Stat stat) {\n                 if (rc == Code.BADVERSION.intValue()) {\n                     LOG.warn(\"Two fragments attempted update at once; ledger id: \" + lh.getId() \n                              + \" startid: \" + fragmentStartId);\n                     // try again, the previous success (with which this has conflicted)\n                     // will have updated the stat\n-                    lh.writeLedgerConfig(new WriteCb(), null);\n+                    // other operations such as (addEnsemble) would update it too.\n+                    lh.rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                        @Override\n+                        public void operationComplete(int rc, LedgerMetadata newMeta) {\n+                            if (rc != BKException.Code.OK) {\n+                                LOG.error(\"Error reading updated ledger metadata for ledger \" + lh.getId(),\n+                                          KeeperException.create(KeeperException.Code.get(rc), path));\n+                                ledgerFragmentsMcb.processResult(rc, null, null);\n+                            } else {\n+                                lh.metadata = newMeta;\n+                                writeLedgerConfig();\n+                            }\n+                        }\n+                    });\n                     return;\n                 } else if (rc != Code.OK.intValue()) {\n                     LOG.error(\"ZK error updating ledger config metadata for ledgerId: \" + lh.getId(),\n@@ -725,4 +796,5 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n             }\n         };\n     }\n+\n }"},{"sha":"7ce7ee1a163968a4446262d859d7f808483564b2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":16,"deletions":5,"changes":21,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -30,6 +30,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.util.StringUtils;\n import org.slf4j.Logger;\n@@ -50,14 +51,15 @@\n class BookieWatcher implements Watcher, ChildrenCallback {\n     static final Logger logger = LoggerFactory.getLogger(BookieWatcher.class);\n \n-    public static final String BOOKIE_REGISTRATION_PATH = \"/ledgers/available\";\n+    // Bookie registration path in ZK\n+    private final String bookieRegistrationPath;\n     static final Set<InetSocketAddress> EMPTY_SET = new HashSet<InetSocketAddress>();\n     public static int ZK_CONNECT_BACKOFF_SEC = 1;\n \n     BookKeeper bk;\n     ScheduledExecutorService scheduler;\n \n-    Set<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n+    HashSet<InetSocketAddress> knownBookies = new HashSet<InetSocketAddress>();\n \n     SafeRunnable reReadTask = new SafeRunnable() {\n         @Override\n@@ -66,8 +68,10 @@ public void safeRun() {\n         }\n     };\n \n-    public BookieWatcher(BookKeeper bk) {\n+    public BookieWatcher(ClientConfiguration conf, BookKeeper bk) {\n         this.bk = bk;\n+        // ZK bookie registration path\n+        this.bookieRegistrationPath = conf.getZkAvailableBookiesPath();\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n     }\n \n@@ -80,7 +84,7 @@ public void readBookies() {\n     }\n \n     public void readBookies(ChildrenCallback callback) {\n-        bk.getZkHandle().getChildren(BOOKIE_REGISTRATION_PATH, this, callback, null);\n+        bk.getZkHandle().getChildren(this.bookieRegistrationPath, this, callback, null);\n     }\n \n     @Override\n@@ -99,7 +103,7 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n         }\n \n         // Read the bookie addresses into a set for efficient lookup\n-        Set<InetSocketAddress> newBookieAddrs = new HashSet<InetSocketAddress>();\n+        HashSet<InetSocketAddress> newBookieAddrs = new HashSet<InetSocketAddress>();\n         for (String bookieAddrString : children) {\n             InetSocketAddress bookieAddr;\n             try {\n@@ -111,9 +115,16 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n             newBookieAddrs.add(bookieAddr);\n         }\n \n+        final HashSet<InetSocketAddress> deadBookies;\n         synchronized (this) {\n+            deadBookies = (HashSet<InetSocketAddress>)knownBookies.clone();\n+            deadBookies.removeAll(newBookieAddrs);\n             knownBookies = newBookieAddrs;\n         }\n+\n+        if (bk.getBookieClient() != null) {\n+            bk.getBookieClient().closeClients(deadBookies);\n+        }\n     }\n \n     /**"},{"sha":"9194bf9c32c21994c40a8c7601485fbbda83fa9e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"modified","additions":9,"deletions":4,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -23,7 +23,12 @@\n import java.util.zip.CRC32;\n \n class CRC32DigestManager extends DigestManager {\n-    CRC32 crc = new CRC32();\n+    private final ThreadLocal<CRC32> crc = new ThreadLocal<CRC32>() {\n+        @Override\n+        protected CRC32 initialValue() {\n+            return new CRC32();\n+        }\n+    };\n \n     public CRC32DigestManager(long ledgerId) {\n         super(ledgerId);\n@@ -38,13 +43,13 @@ int getMacCodeLength() {\n     byte[] getValueAndReset() {\n         byte[] value = new byte[8];\n         ByteBuffer buf = ByteBuffer.wrap(value);\n-        buf.putLong(crc.getValue());\n-        crc.reset();\n+        buf.putLong(crc.get().getValue());\n+        crc.get().reset();\n         return value;\n     }\n \n     @Override\n     void update(byte[] data, int offset, int length) {\n-        crc.update(data, offset, length);\n+        crc.get().update(data, offset, length);\n     }\n }"},{"sha":"99d8f679a53e11c4753ba9e0be987f1687e3bb94","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -103,7 +103,7 @@ public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAd\n     }\n \n     private void verifyDigest(ChannelBuffer dataReceived) throws BKDigestMatchException {\n-        verifyDigest(-1, dataReceived, true);\n+        verifyDigest(LedgerHandle.INVALID_ENTRY_ID, dataReceived, true);\n     }\n \n     private void verifyDigest(long entryId, ChannelBuffer dataReceived) throws BKDigestMatchException {\n@@ -163,11 +163,11 @@ ChannelBufferInputStream verifyDigestAndReturnData(long entryId, ChannelBuffer d\n \n     static class RecoveryData {\n         long lastAddConfirmed;\n-        long entryId;\n+        long length;\n \n-        public RecoveryData(long lastAddConfirmed, long entryId) {\n+        public RecoveryData(long lastAddConfirmed, long length) {\n             this.lastAddConfirmed = lastAddConfirmed;\n-            this.entryId = entryId;\n+            this.length = length;\n         }\n \n     }\n@@ -176,10 +176,9 @@ RecoveryData verifyDigestAndReturnLastConfirmed(ChannelBuffer dataReceived) thro\n         verifyDigest(dataReceived);\n         dataReceived.readerIndex(8);\n \n-        long entryId = dataReceived.readLong();\n+        dataReceived.readLong(); // skip unused entryId\n         long lastAddConfirmed = dataReceived.readLong();\n         long length = dataReceived.readLong();\n-        return new RecoveryData(lastAddConfirmed, entryId);\n-\n+        return new RecoveryData(lastAddConfirmed, length);\n     }\n }"},{"sha":"833f5014fd486906b3af32a4e897d7252ecffb5c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -48,14 +48,18 @@\n     public int getReplicaIndex(long entryId, int bookieIndex);\n \n     /**\n-     * Specifies whether its ok to proceed with recovery given that we have\n-     * heard back from the given bookie index. These calls will be a made in a\n-     * sequence and an implementation of this interface should accumulate\n-     * history about which bookie indexes we have heard from. Once this method\n-     * has returned true, it wont be called again on the same instance\n-     *\n-     * @param bookieIndexHeardFrom\n-     * @return true if its ok to proceed with recovery\n+     * Interface to keep track of which bookies in an ensemble, an action\n+     * has been performed for.\n      */\n-    public boolean canProceedWithRecovery(int bookieIndexHeardFrom);\n+    public interface QuorumCoverageSet {\n+        /**\n+         * Add a bookie to the set, and check if all quorum in the set\n+         * have had the action performed for it.\n+         * @param bookieIndexHeardFrom Bookie we've just heard from\n+         * @return whether all quorums have been covered\n+         */\n+        public boolean addBookieAndCheckCovered(int bookieIndexHeardFrom);\n+    }\n+\n+    public QuorumCoverageSet getCoverageSet();\n }"},{"sha":"8c5bce3af10561c7f74c49f8a733c780567884b5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":25,"deletions":32,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -32,14 +32,13 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.AsyncCallback.StatCallback;\n import org.apache.zookeeper.data.Stat;\n \n /**\n  * Encapsulates asynchronous ledger create operation\n  *\n  */\n-class LedgerCreateOp implements GenericCallback<String>, StatCallback {\n+class LedgerCreateOp implements GenericCallback<String> {\n \n     static final Logger LOG = LoggerFactory.getLogger(LedgerCreateOp.class);\n \n@@ -83,7 +82,28 @@\n      * Initiates the operation\n      */\n     public void initiate() {\n-        bk.getLedgerManager().newLedgerPath(this);\n+        // allocate ensemble first\n+\n+        /*\n+         * Adding bookies to ledger handle\n+         */\n+\n+        ArrayList<InetSocketAddress> ensemble;\n+        try {\n+            ensemble = bk.bookieWatcher.getNewBookies(metadata.ensembleSize);\n+        } catch (BKNotEnoughBookiesException e) {\n+            LOG.error(\"Not enough bookies to create ledger\");\n+            cb.createComplete(e.getCode(), null, this.ctx);\n+            return;\n+        }\n+\n+        /*\n+         * Add ensemble to the configuration\n+         */\n+        metadata.addEnsemble(0L, ensemble);\n+\n+        // create a ledger path with metadata\n+        bk.getLedgerManager().newLedgerPath(this, metadata);\n     }\n \n     /**\n@@ -111,23 +131,6 @@ public void operationComplete(int rc, String ledgerPath) {\n             return;\n         }\n \n-        /*\n-         * Adding bookies to ledger handle\n-         */\n-\n-        ArrayList<InetSocketAddress> ensemble;\n-        try {\n-            ensemble = bk.bookieWatcher.getNewBookies(metadata.ensembleSize);\n-        } catch (BKNotEnoughBookiesException e) {\n-            LOG.error(\"Not enough bookies to create ledger\" + ledgerId);\n-            cb.createComplete(e.getCode(), null, this.ctx);\n-            return;\n-        }\n-\n-        /*\n-         * Add ensemble to the configuration\n-         */\n-        metadata.addEnsemble(new Long(0), ensemble);\n         try {\n             lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n         } catch (GeneralSecurityException e) {\n@@ -140,18 +143,8 @@ public void operationComplete(int rc, String ledgerPath) {\n             return;\n         }\n \n-        lh.writeLedgerConfig(this, null);\n-\n-    }\n-\n-    /**\n-     * Implements ZooKeeper stat callback.\n-     *\n-     * @see org.apache.zookeeper.AsyncCallback.StatCallback#processResult(int, String, Object, Stat)\n-     */\n-    public void processResult(int rc, String path, Object ctx, Stat stat) {\n-        metadata.znodeVersion = stat.getVersion();\n-        cb.createComplete(rc, lh, this.ctx);\n+        // return the ledger handle back\n+        cb.createComplete(BKException.Code.OK, lh, this.ctx);\n     }\n \n }"},{"sha":"fd4ff032c30a97d6a8ca7bf3f2fd7a2fa2d6551e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":213,"deletions":70,"changes":283,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -20,10 +20,12 @@\n  * under the License.\n  *\n  */\n+\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.security.GeneralSecurityException;\n-import java.util.ArrayDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.Arrays;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.Queue;\n@@ -38,6 +40,7 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.util.SafeRunnable;\n \n import org.slf4j.Logger;\n@@ -55,7 +58,6 @@\n  */\n public class LedgerHandle {\n     final static Logger LOG = LoggerFactory.getLogger(LedgerHandle.class);\n-    final static long LAST_ADD_CONFIRMED = -1;\n \n     final byte[] ledgerKey;\n     LedgerMetadata metadata;\n@@ -70,7 +72,13 @@\n     final Semaphore opCounterSem;\n     private final Integer throttling;\n \n-    final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();\n+    /**\n+     * Invalid entry id. This value is returned from methods which\n+     * should return an entry id but there is no valid entry available.\n+     */\n+    final static public long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;\n+\n+    final Queue<PendingAddOp> pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n \n     LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,\n                  DigestType digestType, byte[] password)\n@@ -82,7 +90,7 @@\n             lastAddConfirmed = lastAddPushed = metadata.close;\n             length = metadata.length;\n         } else {\n-            lastAddConfirmed = lastAddPushed = -1;\n+            lastAddConfirmed = lastAddPushed = INVALID_ENTRY_ID;\n             length = 0;\n         }\n \n@@ -107,9 +115,16 @@ public long getId() {\n     }\n \n     /**\n-     * Get the last confirmed entry id on this ledger\n+     * Get the last confirmed entry id on this ledger. It reads\n+     * the local state of the ledger handle, which is different\n+     * from the readLastConfirmed call. In the case the ledger\n+     * is not closed and the client is a reader, it is necessary\n+     * to call readLastConfirmed to obtain an estimate of the\n+     * last add operation that has been confirmed.\n+     *\n+     * @see #readLastConfirmed()\n      *\n-     * @return the last confirmed entry id\n+     * @return the last confirmed entry id or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been confirmed\n      */\n     public long getLastAddConfirmed() {\n         return lastAddConfirmed;\n@@ -119,9 +134,9 @@ public long getLastAddConfirmed() {\n      * Get the entry id of the last entry that has been enqueued for addition (but\n      * may not have possibly been persited to the ledger)\n      *\n-     * @return the id of the last entry pushed\n+     * @return the id of the last entry pushed or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been pushed\n      */\n-    public long getLastAddPushed() {\n+    synchronized public long getLastAddPushed() {\n         return lastAddPushed;\n     }\n \n@@ -131,7 +146,7 @@ public long getLastAddPushed() {\n      * @return byte array for the ledger's key/password.\n      */\n     public byte[] getLedgerKey() {\n-        return ledgerKey;\n+        return Arrays.copyOf(ledgerKey, ledgerKey.length);\n     }\n \n     /**\n@@ -177,7 +192,7 @@ long addToLength(long delta) {\n      *\n      * @return the length of the ledger in bytes\n      */\n-    public long getLength() {\n+    synchronized public long getLength() {\n         return this.length;\n     }\n \n@@ -244,29 +259,64 @@ public void asyncClose(CloseCallback cb, Object ctx) {\n      * @param rc\n      */\n     void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {\n- \n         bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n-\n             @Override\n             public void safeRun() {\n-                metadata.length = length;\n-                // Close operation is idempotent, so no need to check if we are\n-                // already closed\n-\n-                metadata.close(lastAddConfirmed);\n-                errorOutPendingAdds(rc);\n-                lastAddPushed = lastAddConfirmed;\n+                final long prevClose;\n+                final long prevLength;\n+\n+                synchronized(LedgerHandle.this) {\n+                    prevClose = metadata.close;\n+                    prevLength = metadata.length;\n+\n+                    // synchronized on LedgerHandle.this to ensure that \n+                    // lastAddPushed can not be updated after the metadata \n+                    // is closed. \n+                    metadata.length = length;\n+\n+                    // Close operation is idempotent, so no need to check if we are\n+                    // already closed\n+                    metadata.close(lastAddConfirmed);\n+                    errorOutPendingAdds(rc);\n+                    lastAddPushed = lastAddConfirmed;\n+                }\n \n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Closing ledger: \" + ledgerId + \" at entryId: \"\n                               + metadata.close + \" with this many bytes: \" + metadata.length);\n                 }\n \n-                writeLedgerConfig(new StatCallback() {\n+                final class CloseCb implements StatCallback {\n                     @Override\n-                    public void processResult(int rc, String path, Object subctx,\n-                                              Stat stat) {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n+                    public void processResult(final int rc, String path, Object subctx,\n+                                              final Stat stat) {\n+                        if (rc == KeeperException.Code.BadVersion) {\n+                            rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                                @Override\n+                                public void operationComplete(int newrc, LedgerMetadata newMeta) {\n+                                    if (newrc != BKException.Code.OK) {\n+                                        LOG.error(\"Error reading new metadata from ledger \" + ledgerId\n+                                                  + \" when closing, code=\" + newrc);\n+                                        cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                    } else {\n+                                        metadata.close(prevClose);\n+                                        metadata.length = prevLength;\n+                                        if (metadata.resolveConflict(newMeta)) {\n+                                            metadata.length = length;\n+                                            metadata.close(lastAddConfirmed);\n+                                            writeLedgerConfig(new CloseCb(), null);\n+                                            return;\n+                                        } else {\n+                                            metadata.length = length;\n+                                            metadata.close(lastAddConfirmed);\n+                                            LOG.warn(\"Conditional write failed: \"\n+                                                     + KeeperException.Code.get(KeeperException.Code.BadVersion));\n+                                            cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this, ctx);\n+                                        }\n+                                    }\n+                                }\n+                            });\n+                        } else if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG.warn(\"Conditional write failed: \" + KeeperException.Code.get(rc));\n                             cb.closeComplete(BKException.Code.ZKException, LedgerHandle.this,\n                                              ctx);\n@@ -275,7 +325,9 @@ public void processResult(int rc, String path, Object subctx,\n                             cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n                         }\n                     }\n-                }, null);\n+                };\n+\n+                writeLedgerConfig(new CloseCb(), null);\n \n             }\n         });\n@@ -355,7 +407,8 @@ public void addEntry(byte[] data) throws InterruptedException, BKException {\n      */\n     public void addEntry(byte[] data, int offset, int length)\n             throws InterruptedException, BKException {\n-        LOG.debug(\"Adding entry \" + data);\n+        LOG.debug(\"Adding entry {}\", data);\n+\n         SyncCounter counter = new SyncCounter();\n         counter.inc();\n \n@@ -435,25 +488,33 @@ private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int\n             opCounterSem.acquire();\n         } catch (InterruptedException e) {\n             cb.addComplete(BKException.Code.InterruptedException,\n-                           LedgerHandle.this, -1, ctx);\n+                           LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+        }\n+\n+        final long entryId;\n+        final long currentLength;\n+        synchronized(this) {\n+            // synchronized on this to ensure that\n+            // the ledger isn't closed between checking and \n+            // updating lastAddPushed\n+            if (metadata.isClosed()) {\n+                LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n+                LedgerHandle.this.opCounterSem.release();\n+                cb.addComplete(BKException.Code.LedgerClosedException,\n+                               LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n+                return;\n+            }\n+\n+            entryId = ++lastAddPushed;\n+            currentLength = addToLength(length);\n+            op.setEntryId(entryId);\n+            pendingAddOps.add(op);\n         }\n \n         try {\n-            bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n+            bk.mainWorkerPool.submit(new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    if (metadata.isClosed()) {\n-                        LOG.warn(\"Attempt to add to closed ledger: \" + ledgerId);\n-                        LedgerHandle.this.opCounterSem.release();\n-                        cb.addComplete(BKException.Code.LedgerClosedException,\n-                                       LedgerHandle.this, -1, ctx);\n-                        return;\n-                    }\n-\n-                    long entryId = ++lastAddPushed;\n-                    long currentLength = addToLength(length);\n-                    op.setEntryId(entryId);\n-                    pendingAddOps.add(op);\n                     ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n                                                entryId, lastAddConfirmed, currentLength, data, offset, length);\n                     op.initiate(toSend);\n@@ -466,26 +527,47 @@ public void safeRun() {\n     }\n \n     /**\n-     * Obtains last confirmed write from a quorum of bookies.\n+     * Obtains asynchronously the last confirmed write from a quorum of bookies. This \n+     * call obtains the the last add confirmed each bookie has received for this ledger\n+     * and returns the maximum. If the ledger has been closed, the value returned by this\n+     * call may not correspond to the id of the last entry of the ledger, since it reads\n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n+     * return a different value than getLastAddConfirmed, which returns the local value \n+     * of the ledger handle.\n+     * \n+     * @see #getLastAddConfirmed()\n      *\n      * @param cb\n      * @param ctx\n      */\n \n-    public void asyncReadLastConfirmed(ReadLastConfirmedCallback cb, Object ctx) {\n-        new ReadLastConfirmedOp(this, cb, ctx).initiate();\n+    public void asyncReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {\n+        ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n+                public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {\n+                    if (rc == BKException.Code.OK) {\n+                        lastAddConfirmed = Math.max(lastAddConfirmed, data.lastAddConfirmed);\n+                        lastAddPushed = Math.max(lastAddPushed, data.lastAddConfirmed);\n+                        length = Math.max(length, data.length);\n+                        cb.readLastConfirmedComplete(rc, data.lastAddConfirmed, ctx);\n+                    } else {\n+                        cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);\n+                    }\n+                }\n+            };\n+        new ReadLastConfirmedOp(this, innercb).initiate();\n     }\n \n \n     /**\n      * Context objects for synchronous call to read last confirmed.\n      */\n-    class LastConfirmedCtx {\n+    static class LastConfirmedCtx {\n+        final static long ENTRY_ID_PENDING = -10;\n         long response;\n         int rc;\n \n         LastConfirmedCtx() {\n-            this.response = -1;\n+            this.response = ENTRY_ID_PENDING;\n         }\n \n         void setLastConfirmed(long lastConfirmed) {\n@@ -505,10 +587,27 @@ int getRC() {\n         }\n \n         boolean ready() {\n-            return (this.response != -1);\n+            return (this.response != ENTRY_ID_PENDING);\n         }\n     }\n \n+    /**\n+     * Obtains synchronously the last confirmed write from a quorum of bookies. This call\n+     * obtains the the last add confirmed each bookie has received for this ledger\n+     * and returns the maximum. If the ledger has been closed, the value returned by this\n+     * call may not correspond to the id of the last entry of the ledger, since it reads\n+     * the hint of bookies. Consequently, in the case the ledger has been closed, it may \n+     * return a different value than getLastAddConfirmed, which returns the local value \n+     * of the ledger handle.\n+     * \n+     * @see #getLastAddConfirmed()\n+     * \n+     * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}\n+     *         if no entry has been confirmed\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    \n     public long readLastConfirmed()\n             throws InterruptedException, BKException {\n         LastConfirmedCtx ctx = new LastConfirmedCtx();\n@@ -525,6 +624,12 @@ public long readLastConfirmed()\n \n     // close the ledger and send fails to all the adds in the pipeline\n     void handleUnrecoverableErrorDuringAdd(int rc) {\n+        if (metadata.isInRecovery()) {\n+            // we should not close ledger if ledger is recovery mode\n+            // otherwise we may lose entry.\n+            errorOutPendingAdds(rc);\n+            return;\n+        }\n         asyncCloseInternal(NoopCloseCallback.instance, null, rc);\n     }\n \n@@ -579,16 +684,43 @@ void handleBookieFailure(InetSocketAddress addr, final int bookieIndex) {\n                       + (lastAddConfirmed + 1));\n         }\n \n-        metadata.addEnsemble(lastAddConfirmed + 1, newEnsemble);\n+        final long newEnsembleStartEntry = lastAddConfirmed + 1;\n+        metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n \n-        writeLedgerConfig(new StatCallback() {\n+        final class ChangeEnsembleCb implements StatCallback {\n             @Override\n             public void processResult(final int rc, String path, Object ctx, final Stat stat) {\n \n                 bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n                     @Override\n                     public void safeRun() {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n+                        if (rc == KeeperException.Code.BadVersion) {\n+                            rereadMetadata(new GenericCallback<LedgerMetadata>() {\n+                                @Override\n+                                public void operationComplete(int newrc, LedgerMetadata newMeta) {\n+                                    if (newrc != BKException.Code.OK) {\n+                                        LOG.error(\"Error reading new metadata from ledger after changing ensemble, code=\" + newrc);\n+                                        handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                    } else {\n+                                        // a new ensemble is added only when the start entry is larger than zero\n+                                        if (newEnsembleStartEntry > 0) {\n+                                            metadata.getEnsembles().remove(newEnsembleStartEntry);\n+                                        }\n+                                        if (metadata.resolveConflict(newMeta)) {\n+                                            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n+                                            writeLedgerConfig(new ChangeEnsembleCb(), null);\n+                                            return;\n+                                        } else {\n+                                            LOG.error(\"Could not resolve ledger metadata conflict while changing ensemble to: \"\n+                                                      + newEnsemble + \", old meta data is \\n\" + new String(metadata.serialize())\n+                                                      + \"\\n, new meta data is \\n\" + new String(newMeta.serialize()) + \"\\n ,closing ledger\");\n+                                            handleUnrecoverableErrorDuringAdd(BKException.Code.ZKException);\n+                                        }\n+                                    }\n+                                }\n+                            });\n+                            return;\n+                        } else if (rc != KeeperException.Code.OK.intValue()) {\n                             LOG\n                             .error(\"Could not persist ledger metadata while changing ensemble to: \"\n                                    + newEnsemble + \" , closing ledger\");\n@@ -604,33 +736,36 @@ public void safeRun() {\n                 });\n \n             }\n-        }, null);\n+        };\n+\n+        writeLedgerConfig(new ChangeEnsembleCb(), null);\n \n     }\n \n-    void rereadMetadata(final GenericCallback<Void> cb) {\n+    void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getZkHandle().getData(bk.getLedgerManager().getLedgerPath(ledgerId), false,\n-                new DataCallback() {\n-                    public void processResult(int rc, String path,\n-                                              Object ctx, byte[] data, Stat stat) {\n-                        if (rc != KeeperException.Code.OK.intValue()) {\n-                            LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n-                            cb.operationComplete(BKException.Code.ZKException, null);\n-                            return;\n-                        }\n-                        \n-                        try {\n-                            metadata = LedgerMetadata.parseConfig(data, stat.getVersion());\n-                        } catch (IOException e) {\n-                            LOG.error(\"Error parsing ledger metadata for ledger\", e);\n-                            cb.operationComplete(BKException.Code.ZKException, null);\n-                        }\n-                        cb.operationComplete(BKException.Code.OK, null);\n+            new DataCallback() {\n+                public void processResult(int rc, String path,\n+                                          Object ctx, byte[] data, Stat stat) {\n+                    if (rc != KeeperException.Code.OK.intValue()) {\n+                        LOG.error(\"Error reading metadata from ledger, code =\" + rc);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                        return;\n+                    }\n+\n+                    try {\n+                        LedgerMetadata newMeta = LedgerMetadata.parseConfig(data, stat.getVersion());\n+                        cb.operationComplete(BKException.Code.OK, newMeta);\n+                    } catch (IOException e) {\n+                        LOG.error(\"Error parsing ledger metadata for ledger\", e);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                        return;\n                     }\n-                }, null);\n+                }\n+        }, null);\n     }\n \n-    void recover(final GenericCallback<Void> cb) {\n+    synchronized void recover(final GenericCallback<Void> cb) {\n         if (metadata.isClosed()) {\n             lastAddConfirmed = lastAddPushed = metadata.close;\n             length = metadata.length;\n@@ -640,18 +775,26 @@ void recover(final GenericCallback<Void> cb) {\n             return;\n         }\n \n+        // if metadata is already in recover, dont try to write again,\n+        // just do the recovery from the starting point\n+        if (metadata.isInRecovery()) {\n+            new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n+            return;\n+        }\n+\n         metadata.markLedgerInRecovery();\n \n         writeLedgerConfig(new StatCallback() {\n             @Override\n             public void processResult(final int rc, String path, Object ctx, Stat stat) {\n                 if (rc == KeeperException.Code.BadVersion) {\n-                    rereadMetadata(new GenericCallback<Void>() {\n+                    rereadMetadata(new GenericCallback<LedgerMetadata>() {\n                             @Override\n-                            public void operationComplete(int rc, Void result) {\n+                            public void operationComplete(int rc, LedgerMetadata newMeta) {\n                                 if (rc != BKException.Code.OK) {\n                                     cb.operationComplete(rc, null);\n                                 } else {\n+                                    metadata = newMeta;\n                                     recover(cb);\n                                 }\n                             }"},{"sha":"c699eaeed8cc4b10aba86a7e2cea2dca3fe466a0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":65,"deletions":1,"changes":66,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n@@ -93,6 +94,10 @@ boolean isClosed() {\n         return close != NOTCLOSED \n             && close != IN_RECOVERY;\n     }\n+\n+    boolean isInRecovery() {\n+        return IN_RECOVERY == close;\n+    }\n     \n     void markLedgerInRecovery() {\n         close = IN_RECOVERY;\n@@ -236,7 +241,17 @@ static LedgerMetadata parseConfig(byte[] bytes, int version) throws IOException\n     public void updateZnodeStatus(Stat stat) {\n         this.znodeVersion = stat.getVersion();\n     }\n-    \n+\n+    /**\n+     * Update the znode version of this metadata\n+     *\n+     * @param znodeVersion\n+     *        Znode version of this metadata\n+     */\n+    public void updateZnodeStatus(int znodeVersion) {\n+        this.znodeVersion = znodeVersion;\n+    }\n+\n     /**\n      * Returns the last znode version.\n      * \n@@ -245,4 +260,53 @@ public void updateZnodeStatus(Stat stat) {\n     public int getZnodeVersion() {\n         return this.znodeVersion;\n     }\n+\n+    /**\n+     * Resolve conflict with new updated metadata.\n+     *\n+     * @param newMeta\n+     *          Re-read metadata\n+     * @return true if the conflict has been resolved, otherwise false.\n+     */\n+    boolean resolveConflict(LedgerMetadata newMeta) {\n+        /*\n+         *  if length & close have changed, then another client has\n+         *  opened the ledger, can't resolve this conflict.\n+         */\n+\n+        if (metadataFormatVersion != newMeta.metadataFormatVersion ||\n+            ensembleSize != newMeta.ensembleSize ||\n+            quorumSize != newMeta.quorumSize ||\n+            length != newMeta.length ||\n+            close != newMeta.close) {\n+            return false;\n+        }\n+        // new meta znode version should be larger than old one\n+        if (znodeVersion > newMeta.znodeVersion) {\n+            return false;\n+        }\n+        // ensemble size should be same\n+        if (ensembles.size() != newMeta.ensembles.size()) {\n+            return false;\n+        }\n+        // ensemble distribution should be same\n+        // we don't check the detail ensemble, since new bookie will be set\n+        // using recovery tool.\n+        Iterator<Long> keyIter = ensembles.keySet().iterator();\n+        Iterator<Long> newMetaKeyIter = newMeta.ensembles.keySet().iterator();\n+        for (int i=0; i<ensembles.size(); i++) {\n+            Long curKey = keyIter.next();\n+            Long newMetaKey = newMetaKeyIter.next();\n+            if (!curKey.equals(newMetaKey)) {\n+                return false;\n+            }\n+        }\n+        /*\n+         *  if the conflict has been resolved, then update\n+         *  ensemble and znode version\n+         */\n+        ensembles = newMeta.ensembles;\n+        znodeVersion = newMeta.znodeVersion;\n+        return true;\n+    }\n }"},{"sha":"101ebf35547409818d598ba509373e2c9d6e25a4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerOpenOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -141,10 +141,12 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n             lh.recover(new GenericCallback<Void>() {\n                     @Override\n                     public void operationComplete(int rc, Void result) {\n-                        if (rc != BKException.Code.OK) {\n-                            cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n-                        } else {\n+                        if (rc == BKException.Code.OK) {\n                             cb.openComplete(BKException.Code.OK, lh, LedgerOpenOp.this.ctx);\n+                        } else if (rc == BKException.Code.UnauthorizedAccessException) {\n+                            cb.openComplete(BKException.Code.UnauthorizedAccessException, null, LedgerOpenOp.this.ctx);\n+                        } else {\n+                            cb.openComplete(BKException.Code.LedgerRecoveryException, null, LedgerOpenOp.this.ctx);\n                         }\n                     }\n                 });"},{"sha":"35a867600d30126238b3decb326e70af5ac969fb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":29,"deletions":72,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -23,11 +23,11 @@\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n \n import org.apache.zookeeper.KeeperException;\n@@ -37,19 +37,19 @@\n \n /**\n  * This class encapsulated the ledger recovery operation. It first does a read\n- * with entry-id of -1 (LedgerHandle.LAST_ADD_CONFIRMED) to all bookies. Then\n+ * with entry-id of -1 (BookieProtocol.LAST_ADD_CONFIRMED) to all bookies. Then\n  * starting from the last confirmed entry (from hints in the ledger entries),\n  * it reads forward until it is not able to find a particular entry. It closes\n  * the ledger at that entry.\n  *\n  */\n-class LedgerRecoveryOp implements ReadEntryCallback, ReadCallback, AddCallback {\n+class LedgerRecoveryOp implements ReadCallback, AddCallback {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerRecoveryOp.class);\n     LedgerHandle lh;\n     int numResponsesPending;\n     boolean proceedingWithRecovery = false;\n-    long maxAddPushed = -1;\n-    long maxAddConfirmed = -1;\n+    long maxAddPushed = LedgerHandle.INVALID_ENTRY_ID;\n+    long maxAddConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n     long maxLength = 0;\n \n     GenericCallback<Void> cb;\n@@ -61,70 +61,27 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n     }\n \n     public void initiate() {\n-        /** \n+        ReadLastConfirmedOp rlcop = new ReadLastConfirmedOp(lh,\n+                new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n+                public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n+                    if (rc == BKException.Code.OK) {\n+                        lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n+                        lh.length = data.length;\n+                        doRecoveryRead();\n+                    } else if (rc == BKException.Code.UnauthorizedAccessException) {\n+                        cb.operationComplete(rc, null);\n+                    } else {\n+                        cb.operationComplete(BKException.Code.ReadException, null);\n+                    }\n+                }\n+                });\n+\n+        /**\n          * Enable fencing on this op. When the read request reaches the bookies\n          * server it will fence off the ledger, stopping any subsequent operation\n          * from writing to it.\n          */\n-        int flags = BookieProtocol.FLAG_DO_FENCING;\n-        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, \n-                                         LedgerHandle.LAST_ADD_CONFIRMED, this, i, flags);\n-        }\n-    }\n-\n-    public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n-            final ChannelBuffer buffer, final Object ctx) {\n-\n-        // Already proceeding with recovery, nothing to do\n-        if (proceedingWithRecovery) {\n-            return;\n-        }\n-\n-        int bookieIndex = (Integer) ctx;\n-\n-        numResponsesPending--;\n-\n-        boolean heardValidResponse = false;\n-\n-        if (rc == BKException.Code.OK) {\n-            try {\n-                RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n-                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n-                maxAddPushed = Math.max(maxAddPushed, recoveryData.entryId);\n-                heardValidResponse = true;\n-            } catch (BKDigestMatchException e) {\n-                // Too bad, this bookie didnt give us a valid answer, we\n-                // still might be able to recover though so continue\n-                LOG.error(\"Mac mismatch while reading last entry from bookie: \"\n-                          + lh.metadata.currentEnsemble.get(bookieIndex));\n-            }\n-        }\n-\n-        if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n-            // this still counts as a valid response, e.g., if the\n-            // client\n-            // crashed without writing any entry\n-            heardValidResponse = true;\n-        }\n-\n-        // other return codes dont count as valid responses\n-        if (heardValidResponse && lh.distributionSchedule.canProceedWithRecovery(bookieIndex)) {\n-            proceedingWithRecovery = true;\n-            lh.lastAddPushed = lh.lastAddConfirmed = maxAddConfirmed;\n-            lh.length = maxLength;\n-            doRecoveryRead();\n-            return;\n-        }\n-\n-        if (numResponsesPending == 0) {\n-            // Have got all responses back but was still not enough to\n-            // start\n-            // recovery, just fail the operation\n-            LOG.error(\"While recovering ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n-            cb.operationComplete(BKException.Code.LedgerRecoveryException, null);\n-        }\n-\n+        rlcop.initiateWithFencing();\n     }\n \n     /**\n@@ -148,9 +105,10 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n              * replicas. We subtract the length of the data itself, since it will\n              * be added again when processing the call to add it.\n              */\n-            lh.length = entry.getLength() - (long) data.length;\n+            synchronized (lh) {\n+                lh.length = entry.getLength() - (long) data.length;\n+            }\n             lh.asyncRecoveryAddEntry(data, 0, data.length, this, null);\n-\n             return;\n         }\n \n@@ -163,16 +121,15 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                         cb.operationComplete(BKException.Code.ZKException, null);\n                     } else {\n                         cb.operationComplete(BKException.Code.OK, null);\n-                        LOG.debug(\"After closing length is: \" + lh.getLength()); \n+                        LOG.debug(\"After closing length is: \" + lh.getLength());\n                     }\n-                } \n-                \n+                }\n                 }, null, BKException.Code.LedgerClosedException);\n             return;\n         }\n \n         // otherwise, some other error, we can't handle\n-        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + lh.lastAddConfirmed + 1\n+        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + (lh.lastAddConfirmed + 1)\n                   + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n         cb.operationComplete(rc, null);\n         return;\n@@ -183,7 +140,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if (rc != BKException.Code.OK) {\n             // Give up, we can't recover from this error\n \n-            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + lh.lastAddConfirmed + 1\n+            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + (lh.lastAddConfirmed + 1)\n                       + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n             cb.operationComplete(rc, null);\n             return;"},{"sha":"bbd381a86937ae7c6429ec975c9166ff0c8b3c7e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"modified","additions":26,"deletions":9,"changes":35,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -25,19 +25,36 @@\n import javax.crypto.Mac;\n import javax.crypto.spec.SecretKeySpec;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n class MacDigestManager extends DigestManager {\n+    final static Logger LOG = LoggerFactory.getLogger(MacDigestManager.class);\n+\n     public static String DIGEST_ALGORITHM = \"SHA-1\";\n     public static String KEY_ALGORITHM = \"HmacSHA1\";\n-    Mac mac;\n \n-    public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityException {\n-        super(ledgerId);\n-        byte[] macKey = genDigest(\"mac\", passwd);\n-        SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n-        mac = Mac.getInstance(KEY_ALGORITHM);\n-        mac.init(keySpec);\n+    final byte[] passwd;\n \n+    private final ThreadLocal<Mac> mac = new ThreadLocal<Mac>() {\n+        @Override\n+        protected Mac initialValue() {\n+            try {\n+                byte[] macKey = genDigest(\"mac\", passwd);\n+                SecretKeySpec keySpec = new SecretKeySpec(macKey, KEY_ALGORITHM);\n+                Mac mac = Mac.getInstance(KEY_ALGORITHM);\n+                mac.init(keySpec);\n+                return mac;\n+            } catch (GeneralSecurityException gse) {\n+                LOG.error(\"Couldn't not get mac instance\", gse);\n+                return null;\n+            }\n+        }\n+    };\n \n+    public MacDigestManager(long ledgerId, byte[] passwd) throws GeneralSecurityException {\n+        super(ledgerId);\n+        this.passwd = passwd;\n     }\n \n     static byte[] genDigest(String pad, byte[] passwd) throws NoSuchAlgorithmException {\n@@ -55,12 +72,12 @@ int getMacCodeLength() {\n \n     @Override\n     byte[] getValueAndReset() {\n-        return mac.doFinal();\n+        return mac.get().doFinal();\n     }\n \n     @Override\n     void update(byte[] data, int offset, int length) {\n-        mac.update(data, offset, length);\n+        mac.get().update(data, offset, length);\n     }\n \n "},{"sha":"d61000eb991f70e92f541956abdb883a1f113134","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -51,7 +51,7 @@\n         this.lh = lh;\n         this.cb = cb;\n         this.ctx = ctx;\n-        this.entryId = -1;\n+        this.entryId = LedgerHandle.INVALID_ENTRY_ID;\n         \n         successesSoFar = new boolean[lh.metadata.quorumSize];\n         numResponsesPending = successesSoFar.length;\n@@ -138,6 +138,10 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             LOG.warn(\"Fencing exception on write: \" + ledgerId + \", \" + entryId);\n             lh.handleUnrecoverableErrorDuringAdd(rc);\n             return;\n+        case BKException.Code.UnauthorizedAccessException:\n+            LOG.warn(\"Unauthorized access exception on write: \" + ledgerId + \", \" + entryId);\n+            lh.handleUnrecoverableErrorDuringAdd(rc);\n+            return;\n         default:\n             LOG.warn(\"Write did not succeed: \" + ledgerId + \", \" + entryId);\n             lh.handleBookieFailure(addr, bookieIndex);"},{"sha":"778ec83de8e7d98acb65d7776542f02dca8df79d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":17,"deletions":1,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -97,14 +97,15 @@ void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int last\n         if (entry.nextReplicaIndexToReadFrom >= lh.metadata.quorumSize) {\n             // we are done, the read has failed from all replicas, just fail the\n             // read\n+            lh.opCounterSem.release();\n             submitCallback(lastErrorCode);\n             return;\n         }\n \n         int bookieIndex = lh.distributionSchedule.getBookieIndex(entry.entryId, entry.nextReplicaIndexToReadFrom);\n         entry.nextReplicaIndexToReadFrom++;\n         lh.bk.bookieClient.readEntry(ensemble.get(bookieIndex), lh.ledgerId, entry.entryId, \n-                                     this, entry, BookieProtocol.FLAG_NONE);\n+                                     this, entry);\n     }\n \n     void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n@@ -120,6 +121,21 @@ void logErrorAndReattemptRead(LedgerEntry entry, String errMsg, int rc) {\n     public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n         final LedgerEntry entry = (LedgerEntry) ctx;\n \n+        // if we just read only one entry, and this entry is not existed (in recoveryRead case)\n+        // we don't need to do ReattemptRead, otherwise we could not handle following case:\n+        //\n+        // an empty ledger with quorum (bk1, bk2), bk2 is failed forever.\n+        // bk1 return NoLedgerException, client do ReattemptRead to bk2 but bk2 isn't connected\n+        // so the read 0 entry would failed. this ledger could never be closed.\n+        if (startEntryId == endEntryId) {\n+            if (BKException.Code.NoSuchLedgerExistsException == rc ||\n+                BKException.Code.NoSuchEntryException == rc) {\n+                lh.opCounterSem.release();\n+                submitCallback(rc);\n+                return;\n+            }\n+        }\n+\n         if (rc != BKException.Code.OK) {\n             logErrorAndReattemptRead(entry, \"Error: \" + BKException.getMessage(rc), rc);\n             return;"},{"sha":"f20ee8882cd24509eb346fd878077d3a969171e2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":43,"deletions":19,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -33,27 +33,44 @@\n class ReadLastConfirmedOp implements ReadEntryCallback {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerRecoveryOp.class);\n     LedgerHandle lh;\n-    Object ctx;\n     int numResponsesPending;\n-    int validResponses;\n-    long maxAddConfirmed;\n-    long maxLength = 0;\n+    RecoveryData maxRecoveredData;\n     volatile boolean completed = false;\n \n-    ReadLastConfirmedCallback cb;\n+    LastConfirmedDataCallback cb;\n+    final DistributionSchedule.QuorumCoverageSet coverageSet;\n \n-    public ReadLastConfirmedOp(LedgerHandle lh, ReadLastConfirmedCallback cb, Object ctx) {\n+    /**\n+     * Wrapper to get all recovered data from the request\n+     */\n+    interface LastConfirmedDataCallback {\n+        public void readLastConfirmedDataComplete(int rc, RecoveryData data);\n+    }\n+\n+    public ReadLastConfirmedOp(LedgerHandle lh, LastConfirmedDataCallback cb) {\n         this.cb = cb;\n-        this.ctx = ctx;\n+        this.maxRecoveredData = new RecoveryData(LedgerHandle.INVALID_ENTRY_ID, 0);\n         this.lh = lh;\n-        this.validResponses = 0;\n         this.numResponsesPending = lh.metadata.ensembleSize;\n+        this.coverageSet = lh.distributionSchedule.getCoverageSet();\n     }\n \n     public void initiate() {\n         for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n-            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i), lh.ledgerId, LedgerHandle.LAST_ADD_CONFIRMED, \n-                                         this, i, BookieProtocol.FLAG_NONE);\n+            lh.bk.bookieClient.readEntry(lh.metadata.currentEnsemble.get(i),\n+                                         lh.ledgerId,\n+                                         BookieProtocol.LAST_ADD_CONFIRMED,\n+                                         this, i);\n+        }\n+    }\n+\n+    public void initiateWithFencing() {\n+        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n+            lh.bk.bookieClient.readEntryAndFenceLedger(lh.metadata.currentEnsemble.get(i),\n+                                                       lh.ledgerId,\n+                                                       lh.ledgerKey,\n+                                                       BookieProtocol.LAST_ADD_CONFIRMED,\n+                                                       this, i);\n         }\n     }\n \n@@ -62,12 +79,14 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n         int bookieIndex = (Integer) ctx;\n \n         numResponsesPending--;\n-\n+        boolean heardValidResponse = false;\n         if (rc == BKException.Code.OK) {\n             try {\n                 RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(buffer);\n-                maxAddConfirmed = Math.max(maxAddConfirmed, recoveryData.lastAddConfirmed);\n-                validResponses++;\n+                if (recoveryData.lastAddConfirmed > maxRecoveredData.lastAddConfirmed) {\n+                    maxRecoveredData = recoveryData;\n+                }\n+                heardValidResponse = true;\n             } catch (BKDigestMatchException e) {\n                 // Too bad, this bookie didn't give us a valid answer, we\n                 // still might be able to recover though so continue\n@@ -78,25 +97,30 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n \n         if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n             // this still counts as a valid response, e.g., if the client crashed without writing any entry\n-            validResponses++;\n+            heardValidResponse = true;\n         }\n \n+        if (rc == BKException.Code.UnauthorizedAccessException  && !completed) {\n+            cb.readLastConfirmedDataComplete(rc, maxRecoveredData);\n+            completed = true;\n+        }\n         // other return codes dont count as valid responses\n-        if ((validResponses >= lh.metadata.quorumSize) &&\n-                !completed) {\n+        if (heardValidResponse\n+            && coverageSet.addBookieAndCheckCovered(bookieIndex)\n+            && !completed) {\n             completed = true;\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Read Complete with enough validResponses\");\n             }\n-            cb.readLastConfirmedComplete(BKException.Code.OK, maxAddConfirmed, this.ctx);\n+\n+            cb.readLastConfirmedDataComplete(BKException.Code.OK, maxRecoveredData);\n             return;\n         }\n \n         if (numResponsesPending == 0 && !completed) {\n-            completed = true;\n             // Have got all responses back but was still not enough, just fail the operation\n             LOG.error(\"While readLastConfirmed ledger: \" + ledgerId + \" did not hear success responses from all quorums\");\n-            cb.readLastConfirmedComplete(BKException.Code.LedgerRecoveryException, maxAddConfirmed, this.ctx);\n+            cb.readLastConfirmedDataComplete(BKException.Code.LedgerRecoveryException, maxRecoveredData);\n         }\n \n     }"},{"sha":"e5739ef6c1320da296229da7e1e0a1b00039ec95","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -73,6 +73,7 @@ public void asyncAddEntry(final byte[] data, final AddCallback cb,\n     public void asyncAddEntry(final byte[] data, final int offset, final int length,\n                               final AddCallback cb, final Object ctx) {\n         LOG.error(\"Tried to add entry on a Read-Only ledger handle, ledgerid=\" + ledgerId);\n-        cb.addComplete(BKException.Code.IllegalOpException, this, -1, ctx);\n+        cb.addComplete(BKException.Code.IllegalOpException, this,\n+                       LedgerHandle.INVALID_ENTRY_ID, ctx);\n     }\n }"},{"sha":"9c989d8dfa2f1c7b9d2724872addff48e9cd6ac6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":23,"deletions":20,"changes":43,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -31,10 +31,6 @@\n     int quorumSize;\n     int ensembleSize;\n \n-    // covered[i] is true if the quorum starting at bookie index i has been\n-    // covered by a recovery reply\n-    boolean[] covered = null;\n-    int numQuorumsUncovered;\n \n     public RoundRobinDistributionSchedule(int quorumSize, int ensembleSize) {\n         this.quorumSize = quorumSize;\n@@ -57,31 +53,38 @@ public int getReplicaIndex(long entryId, int bookieIndex) {\n \n     }\n \n-    public synchronized boolean canProceedWithRecovery(int bookieIndexHeardFrom) {\n-        if (covered == null) {\n+    private class RRQuorumCoverageSet implements QuorumCoverageSet {\n+        // covered[i] is true if the quorum starting at bookie index i has been\n+        // covered by a recovery reply\n+        private boolean[] covered = null;\n+        private int numQuorumsUncovered;\n+\n+        private RRQuorumCoverageSet() {\n             covered = new boolean[ensembleSize];\n             numQuorumsUncovered = ensembleSize;\n         }\n \n-        if (numQuorumsUncovered == 0) {\n-            return true;\n-        }\n+        public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n+            if (numQuorumsUncovered == 0) {\n+                return true;\n+            }\n \n-        for (int i = 0; i < quorumSize; i++) {\n-            int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n-            if (!covered[quorumStartIndex]) {\n-                covered[quorumStartIndex] = true;\n-                numQuorumsUncovered--;\n+            for (int i = 0; i < quorumSize; i++) {\n+                int quorumStartIndex = MathUtils.signSafeMod(bookieIndexHeardFrom - i, ensembleSize);\n+                if (!covered[quorumStartIndex]) {\n+                    covered[quorumStartIndex] = true;\n+                    numQuorumsUncovered--;\n \n-                if (numQuorumsUncovered == 0) {\n-                    return true;\n+                    if (numQuorumsUncovered == 0) {\n+                        return true;\n+                    }\n                 }\n             }\n-\n+            return false;\n         }\n-\n-        return false;\n-\n     }\n \n+    public QuorumCoverageSet getCoverageSet() {\n+        return new RRQuorumCoverageSet();\n+    }\n }"},{"sha":"2b5b21ae499ae4802b5de59a488d4f1feffe08cd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -35,7 +35,7 @@\n     // Ledger Manager\n     protected final static String LEDGER_MANAGER_TYPE = \"ledgerManagerType\";\n     protected final static String ZK_LEDGERS_ROOT_PATH = \"zkLedgersRootPath\";\n-\n+    protected final static String AVAILABLE_NODE = \"available\";\n     protected AbstractConfiguration() {\n         super();\n         // add configuration for system properties\n@@ -69,7 +69,6 @@ public void loadConf(AbstractConfiguration baseConf) {\n      *\n      * @param lmType\n      *          Ledger Manager Type\n-     * @return void\n      */\n     public void setLedgerManagerType(String lmType) {\n         setProperty(LEDGER_MANAGER_TYPE, lmType); \n@@ -102,4 +101,13 @@ public void setZkLedgersRootPath(String zkLedgersPath) {\n     public String getZkLedgersRootPath() {\n         return getString(ZK_LEDGERS_ROOT_PATH, \"/ledgers\");\n     }\n+\n+    /**\n+     * Get the node under which available bookies are stored\n+     *\n+     * @return Node under which available bookies are stored.\n+     */\n+    public String getZkAvailableBookiesPath() {\n+        return getZkLedgersRootPath() + \"/\" + AVAILABLE_NODE;\n+    }\n }"},{"sha":"6db9bd339fdf7ab71142e86d6351987bddd32f09","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":61,"deletions":1,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -17,8 +17,12 @@\n  */\n package org.apache.bookkeeper.conf;\n \n+import java.util.List;\n+\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n \n+import org.apache.commons.lang.StringUtils;\n+\n /**\n  * Configuration settings for client side\n  */\n@@ -38,6 +42,10 @@\n \n     // NIO Parameters\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n+    protected final static String READ_TIMEOUT = \"readTimeout\";\n+\n+    // Number Woker Threads\n+    protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n \n     /**\n      * Construct a default client-side configuration\n@@ -178,7 +186,11 @@ public ClientConfiguration setClientTcpNoDelay(boolean noDelay) {\n      * @return zookeeper servers\n      */\n     public String getZkServers() {\n-        return getString(ZK_SERVERS, \"localhost\");\n+        List<Object> servers = getList(ZK_SERVERS, null);\n+        if (null == servers || 0 == servers.size()) {\n+            return \"localhost\";\n+        }\n+        return StringUtils.join(servers, \",\");\n     }\n \n     /**\n@@ -213,4 +225,52 @@ public ClientConfiguration setZkTimeout(int zkTimeout) {\n         return this;\n     }\n \n+    /**\n+     * Get the socket read timeout. This is the number of\n+     * seconds we wait without hearing a response from a bookie\n+     * before we consider it failed.\n+     *\n+     * @return the current read timeout in seconds\n+     */\n+    public int getReadTimeout() {\n+        return getInt(READ_TIMEOUT, 5);\n+    }\n+\n+    /**\n+     * Set the socket read timeout.\n+     * @see #getReadTimeout()\n+     * @param timeout The new read timeout in seconds\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setReadTimeout(int timeout) {\n+        setProperty(READ_TIMEOUT, Integer.toString(timeout));\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of worker threads. This is the number of\n+     * worker threads used by bookkeeper client to submit operations.\n+     *\n+     * @return the number of worker threads\n+     */\n+    public int getNumWorkerThreads() {\n+        return getInt(NUM_WORKER_THREADS, Runtime.getRuntime().availableProcessors());\n+    }\n+\n+    /**\n+     * Set the number of worker threads.\n+     *\n+     * <p>\n+     * NOTE: setting the number of worker threads after BookKeeper object is constructed\n+     * will not take any effect on the number of threads in the pool.\n+     * </p>\n+     *\n+     * @see #getNumWorkerThreads()\n+     * @param numThreads number of worker threads used for bookkeeper\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setNumWorkerThreads(int numThreads) {\n+        setProperty(NUM_WORKER_THREADS, numThreads);\n+        return this;\n+    }\n }"},{"sha":"845a456132869425492a73a8fd5c41b95e2dd337","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":180,"deletions":8,"changes":188,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -18,6 +18,7 @@\n package org.apache.bookkeeper.conf;\n \n import java.io.File;\n+import java.util.List;\n \n import org.apache.commons.lang.StringUtils;\n \n@@ -27,6 +28,10 @@\n public class ServerConfiguration extends AbstractConfiguration {\n     // Entry Log Parameters\n     protected final static String ENTRY_LOG_SIZE_LIMIT = \"logSizeLimit\";\n+    protected final static String MINOR_COMPACTION_INTERVAL = \"minorCompactionInterval\";\n+    protected final static String MINOR_COMPACTION_THRESHOLD = \"minorCompactionThreshold\";\n+    protected final static String MAJOR_COMPACTION_INTERVAL = \"majorCompactionInterval\";\n+    protected final static String MAJOR_COMPACTION_THRESHOLD = \"majorCompactionThreshold\";\n \n     // Gc Parameters\n     protected final static String GC_WAIT_TIME = \"gcWaitTime\";\n@@ -50,9 +55,8 @@\n     // Zookeeper Parameters\n     protected final static String ZK_TIMEOUT = \"zkTimeout\";\n     protected final static String ZK_SERVERS = \"zkServers\";\n-\n-    // separator for ledger dir\n-    protected final static String SEP = \",\";\n+    // Statistics Parameters\n+    protected final static String ENABLE_STATISTICS = \"enableStatistics\";\n \n     /**\n      * Construct a default configuration object\n@@ -152,6 +156,18 @@ public int getOpenFileLimit() {\n         return this.getInt(OPEN_FILE_LIMIT, 900);\n     }\n \n+    /**\n+     * Set limitation of number of open files.\n+     *\n+     * @param fileLimit\n+     *          Limitation of number of open files.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setOpenFileLimit(int fileLimit) {\n+        setProperty(OPEN_FILE_LIMIT, fileLimit);\n+        return this;\n+    }\n+\n     /**\n      * Get limitation number of index pages in ledger cache\n      *\n@@ -161,6 +177,18 @@ public int getPageLimit() {\n         return this.getInt(PAGE_LIMIT, -1);\n     }\n \n+    /**\n+     * Set limitation number of index pages in ledger cache.\n+     *\n+     * @param pageLimit\n+     *          Limitation of number of index pages in ledger cache.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setPageLimit(int pageLimit) {\n+        this.setProperty(PAGE_LIMIT, pageLimit);\n+        return this;\n+    }\n+\n     /**\n      * Get page size\n      *\n@@ -170,6 +198,20 @@ public int getPageSize() {\n         return this.getInt(PAGE_SIZE, 8192);\n     }\n \n+    /**\n+     * Set page size\n+     *\n+     * @see #getPageSize()\n+     *\n+     * @param pageSize\n+     *          Page Size\n+     * @return Server Configuration\n+     */\n+    public ServerConfiguration setPageSize(int pageSize) {\n+        this.setProperty(PAGE_SIZE, pageSize);\n+        return this;\n+    }\n+\n     /**\n      * Max journal file size\n      *\n@@ -273,11 +315,11 @@ public File getJournalDir() {\n      * @return ledger dir names, if not provided return null\n      */\n     public String[] getLedgerDirNames() {\n-        String ledgerDirs = this.getString(LEDGER_DIRS, \"/tmp/bk-data\");\n+        String[] ledgerDirs = this.getStringArray(LEDGER_DIRS);\n         if (null == ledgerDirs) {\n-            return null;\n+            return new String[] { \"/tmp/bk-data\" };\n         }\n-        return ledgerDirs.split(SEP);\n+        return ledgerDirs;\n     }\n \n     /**\n@@ -291,7 +333,7 @@ public ServerConfiguration setLedgerDirNames(String[] ledgerDirs) {\n         if (null == ledgerDirs) {\n             return this;\n         }\n-        this.setProperty(LEDGER_DIRS, StringUtils.join(ledgerDirs, SEP));\n+        this.setProperty(LEDGER_DIRS, ledgerDirs);\n         return this;\n     }\n \n@@ -339,7 +381,11 @@ public ServerConfiguration setServerTcpNoDelay(boolean noDelay) {\n      * @return zookeeper servers\n      */\n     public String getZkServers() {\n-        return getString(ZK_SERVERS, null);\n+        List<Object> servers = getList(ZK_SERVERS, null);\n+        if (null == servers || 0 == servers.size()) {\n+            return null;\n+        }\n+        return StringUtils.join(servers, \",\");\n     }\n \n     /**\n@@ -374,4 +420,130 @@ public ServerConfiguration setZkTimeout(int zkTimeout) {\n         return this;\n     }\n \n+    /**\n+     * Is statistics enabled\n+     *\n+     * @return is statistics enabled\n+     */\n+    public boolean isStatisticsEnabled() {\n+        return getBoolean(ENABLE_STATISTICS, true);\n+    }\n+\n+    /**\n+     * Turn on/off statistics\n+     *\n+     * @param enabled\n+     *          Whether statistics enabled or not.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setStatisticsEnabled(boolean enabled) {\n+        setProperty(ENABLE_STATISTICS, Boolean.toString(enabled));\n+        return this;\n+    }\n+\n+    /**\n+     * Get threshold of minor compaction.\n+     *\n+     * For those entry log files whose remaining size percentage reaches below\n+     * this threshold  will be compacted in a minor compaction.\n+     *\n+     * If it is set to less than zero, the minor compaction is disabled.\n+     *\n+     * @return threshold of minor compaction\n+     */\n+    public double getMinorCompactionThreshold() {\n+        return getDouble(MINOR_COMPACTION_THRESHOLD, 0.2f);\n+    }\n+\n+    /**\n+     * Set threshold of minor compaction\n+     *\n+     * @see #getMinorCompactionThreshold()\n+     *\n+     * @param threshold\n+     *          Threshold for minor compaction\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMinorCompactionThreshold(double threshold) {\n+        setProperty(MINOR_COMPACTION_THRESHOLD, threshold);\n+        return this;\n+    }\n+\n+    /**\n+     * Get threshold of major compaction.\n+     *\n+     * For those entry log files whose remaining size percentage reaches below\n+     * this threshold  will be compacted in a major compaction.\n+     *\n+     * If it is set to less than zero, the major compaction is disabled.\n+     *\n+     * @return threshold of major compaction\n+     */\n+    public double getMajorCompactionThreshold() {\n+        return getDouble(MAJOR_COMPACTION_THRESHOLD, 0.8f);\n+    }\n+\n+    /**\n+     * Set threshold of major compaction.\n+     *\n+     * @see #getMajorCompactionThreshold()\n+     *\n+     * @param threshold\n+     *          Threshold of major compaction\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMajorCompactionThreshold(double threshold) {\n+        setProperty(MAJOR_COMPACTION_THRESHOLD, threshold);\n+        return this;\n+    }\n+\n+    /**\n+     * Get interval to run minor compaction, in seconds.\n+     *\n+     * If it is set to less than zero, the minor compaction is disabled.\n+     *\n+     * @return threshold of minor compaction\n+     */\n+    public long getMinorCompactionInterval() {\n+        return getLong(MINOR_COMPACTION_INTERVAL, 3600);\n+    }\n+\n+    /**\n+     * Set interval to run minor compaction\n+     *\n+     * @see #getMinorCompactionInterval()\n+     *\n+     * @param interval\n+     *          Interval to run minor compaction\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMinorCompactionInterval(long interval) {\n+        setProperty(MINOR_COMPACTION_INTERVAL, interval);\n+        return this;\n+    }\n+\n+    /**\n+     * Get interval to run major compaction, in seconds.\n+     *\n+     * If it is set to less than zero, the major compaction is disabled.\n+     *\n+     * @return high water mark\n+     */\n+    public long getMajorCompactionInterval() {\n+        return getLong(MAJOR_COMPACTION_INTERVAL, 86400);\n+    }\n+\n+    /**\n+     * Set interval to run major compaction.\n+     *\n+     * @see #getMajorCompactionInterval()\n+     *\n+     * @param interval\n+     *          Interval to run major compaction\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setMajorCompactionInterval(long interval) {\n+        setProperty(MAJOR_COMPACTION_INTERVAL, interval);\n+        return this;\n+    }\n }"},{"sha":"5d4f1201517bd46f90face4752d3d593de3913d1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanInfo.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.jmx;\n+\n+import org.apache.zookeeper.jmx.ZKMBeanInfo;\n+\n+/**\n+ * BookKeeper MBean info interface.\n+ */\n+public interface BKMBeanInfo extends ZKMBeanInfo {\n+}"},{"sha":"5791b08e553edbb2d1c49ff5beb0a7d308738e99","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/jmx/BKMBeanRegistry.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.jmx;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.jmx.MBeanRegistry;\n+import org.apache.zookeeper.jmx.ZKMBeanInfo;\n+\n+/**\n+ * This class provides a unified interface for registering/unregistering of\n+ * bookkeeper MBeans with the platform MBean server. It builds a hierarchy of MBeans\n+ * where each MBean represented by a filesystem-like path. Eventually, this hierarchy\n+ * will be stored in the zookeeper data tree instance as a virtual data tree.\n+ */\n+public class BKMBeanRegistry extends MBeanRegistry {\n+    static final Logger LOG = Logger.getLogger(BKMBeanRegistry.class);\n+    \n+    static final String DOMAIN = \"org.apache.BookKeeperService\";\n+\n+    static BKMBeanRegistry instance=new BKMBeanRegistry(); \n+\n+    public static BKMBeanRegistry getInstance(){\n+        return instance;\n+    }\n+\n+    protected String getDomainName() {\n+        return DOMAIN;\n+    }\n+    \n+    /**\n+     * This takes a path, such as /a/b/c, and converts it to \n+     * name0=a,name1=b,name2=c\n+     * \n+     * Copy from zookeeper MBeanRegistry since tokenize is private\n+     */\n+    protected int tokenize(StringBuilder sb, String path, int index) {\n+        String[] tokens = path.split(\"/\");\n+        for (String s: tokens) {\n+            if (s.length()==0)\n+                continue;\n+            sb.append(\"name\").append(index++).append(\"=\").append(s).append(\",\");\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Builds an MBean path and creates an ObjectName instance using the path. \n+     * @param path MBean path\n+     * @param bean the MBean instance\n+     * @return ObjectName to be registered with the platform MBean server\n+     */\n+    protected ObjectName makeObjectName(String path, ZKMBeanInfo bean)\n+        throws MalformedObjectNameException {\n+        if(path==null)\n+            return null;\n+        StringBuilder beanName = new StringBuilder(getDomainName() + \":\");\n+        int counter=0;\n+        counter=tokenize(beanName,path,counter);\n+        tokenize(beanName,bean.getName(),counter);\n+        beanName.deleteCharAt(beanName.length()-1);\n+        try {\n+            return new ObjectName(beanName.toString());\n+        } catch (MalformedObjectNameException e) {\n+            LOG.warn(\"Invalid name \\\"\" + beanName.toString() + \"\\\" for class \"\n+                    + bean.getClass().toString());\n+            throw e;\n+        }\n+    }\n+}"},{"sha":"ce5346166448b40912b08958e262d65316c41b8e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":36,"deletions":6,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,6 +21,8 @@\n import java.io.IOException;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import java.util.Map;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n@@ -45,6 +47,7 @@\n     // Ledger Node Prefix\n     static public final String LEDGER_NODE_PREFIX = \"L\";\n     static final String AVAILABLE_NODE = \"available\";\n+    static final String COOKIES_NODE = \"cookies\";\n \n     protected final AbstractConfiguration conf;\n     protected final ZooKeeper zk;\n@@ -134,8 +137,9 @@ public void processResult(int rc, String path, Object ctx, List<String> ledgerNo\n         }, null);\n     }\n \n-    private class GetLedgersCtx {\n+    private static class GetLedgersCtx {\n         int rc;\n+        boolean done = false;\n         HashSet<Long> ledgers = null;\n     }\n \n@@ -153,22 +157,26 @@ public void processResult(int rc, String path, Object ctx, List<String> ledgerNo\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Try to get ledgers of node : \" + nodePath);\n         }\n-        synchronized (ctx) {\n-            asyncGetLedgersInSingleNode(nodePath, new GenericCallback<HashSet<Long>>() {\n+        asyncGetLedgersInSingleNode(nodePath, new GenericCallback<HashSet<Long>>() {\n                 @Override\n                 public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n                     synchronized (ctx) {\n                         if (Code.OK.intValue() == rc) {\n                             ctx.ledgers = zkActiveLedgers;\n                         }\n                         ctx.rc = rc;\n+                        ctx.done = true;\n                         ctx.notifyAll();\n                     }\n                 }\n             });\n-            ctx.wait();\n+\n+        synchronized (ctx) {\n+            while (ctx.done == false) {\n+                ctx.wait();\n+            }\n         }\n-        if (Code.OK.intValue() != ctx.rc && null != ctx.ledgers) {\n+        if (Code.OK.intValue() != ctx.rc) {\n             throw new IOException(\"Error on getting ledgers from node \" + nodePath);\n         }\n         return ctx.ledgers;\n@@ -240,7 +248,8 @@ public void operationComplete(int rc, HashSet<Long> zkActiveLedgers) {\n      * @return true  if the znode is a special znode otherwise false\n      */\n     protected boolean isSpecialZnode(String znode) {\n-        if (AVAILABLE_NODE.equals(znode) \n+        if (AVAILABLE_NODE.equals(znode)\n+            || COOKIES_NODE.equals(znode)\n             || LedgerLayout.LAYOUT_ZNODE.equals(znode)) {\n             return true;\n         }\n@@ -250,4 +259,25 @@ protected boolean isSpecialZnode(String znode) {\n     @Override\n     public void close() {\n     }\n+\n+    /**\n+     * Do garbage collecting comparing hosted ledgers and zk ledgers\n+     *\n+     * @param gc\n+     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n+     * @param bkActiveLedgers\n+     *          Active ledgers hosted in bookie server\n+     * @param zkAllLedgers\n+     *          All ledgers stored in zookeeper\n+     */\n+    void doGc(GarbageCollector gc, Map<Long, Boolean> bkActiveLedgers, Set<Long> zkAllLedgers) {\n+        // remove any active ledgers that doesn't exist in zk\n+        for (Long bkLid : bkActiveLedgers.keySet()) {\n+            if (!zkAllLedgers.contains(bkLid)) {\n+                // remove it from current active ledger\n+                bkActiveLedgers.remove(bkLid);\n+                gc.gc(bkLid);\n+            }\n+        }\n+    }\n }"},{"sha":"1300974382d34066b8935cf399f0ad6a1455e008","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"modified","additions":12,"deletions":30,"changes":42,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -19,10 +19,11 @@\n  */\n \n import java.io.IOException;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n \n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n@@ -66,7 +67,7 @@\n     // path prefix to store ledger znodes\n     private final String ledgerPrefix;\n     // hash map to store all active ledger ids\n-    private ConcurrentMap<Long, Boolean> activeLedgers;\n+    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     /**\n      * Constructor\n@@ -90,23 +91,25 @@ public FlatLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n         }\n \n         ledgerPrefix = ledgerRootPath + \"/\" + LEDGER_NODE_PREFIX;\n-        activeLedgers = new ConcurrentHashMap<Long, Boolean>();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n     }\n \n     @Override\n-    public void newLedgerPath(final GenericCallback<String> cb) {\n+    public void newLedgerPath(final GenericCallback<String> cb, final LedgerMetadata metadata) {\n         StringCallback scb = new StringCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx,\n                     String name) {\n                 if (Code.OK.intValue() != rc) {\n                     cb.operationComplete(rc, null);\n                 } else {\n+                    // update znode status\n+                    metadata.updateZnodeStatus(0);\n                     cb.operationComplete(rc, name);\n                 }\n             }\n         };\n-        ZkUtils.createFullPathOptimistic(zk, ledgerPrefix, new byte[0],\n+        ZkUtils.createFullPathOptimistic(zk, ledgerPrefix, metadata.serialize(),\n             Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, scb, null);\n     }\n \n@@ -155,8 +158,9 @@ public boolean containsActiveLedger(long ledgerId) {\n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n         try {\n-            HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n-            ConcurrentMap<Long, Boolean> bkActiveLedgers = activeLedgers;\n+            // create a snapshot first\n+            Map<Long, Boolean> bkActiveLedgers = activeLedgers.snapshot();\n+            Set<Long> zkActiveLedgers = getLedgersInSingleNode(ledgerRootPath);\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"All active ledgers from ZK: \" + zkActiveLedgers);\n                 LOG.debug(\"Current active ledgers from Bookie: \" + bkActiveLedgers.keySet());\n@@ -168,26 +172,4 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n             LOG.warn(\"Interrupted during garbage collecting ledgers from \" + ledgerRootPath, inte);\n         }\n     }\n-\n-    /**\n-     * Do garbage collecting comparing hosted ledgers and zk ledgers\n-     *\n-     * @param gc\n-     *          Garbage collector to do garbage collection when found inactive/deleted ledgers\n-     * @param bkActiveLedgers\n-     *          Active ledgers hosted in bookie server\n-     * @param zkAllLedgers\n-     *          All ledgers stored in zookeeper\n-     */\n-    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers, HashSet<Long> zkAllLedgers) {\n-        // remove any active ledgers that doesn't exist in zk\n-        for (Long bkLid : bkActiveLedgers.keySet()) {\n-            if (!zkAllLedgers.contains(bkLid)) {\n-                // remove it from current active ledger\n-                bkActiveLedgers.remove(bkLid);\n-                gc.gc(bkLid);\n-            }\n-        }\n-    }\n-\n }"},{"sha":"b573181beb49c16b1879bfea469f3430869c908b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":29,"deletions":36,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -19,14 +19,16 @@\n  */\n \n import java.io.IOException;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentSkipListMap;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.Set;\n+import java.util.Map;\n+import java.util.NavigableMap;\n import java.util.HashSet;\n import java.util.List;\n \n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n@@ -83,14 +85,15 @@\n \n     public static final int CUR_VERSION = 1;\n \n-    static final String IDGENERATION_PREFIX = \"/idgen/ID-\";\n+    static final String IDGEN_ZNODE = \"idgen\";\n+    static final String IDGENERATION_PREFIX = \"/\" + IDGEN_ZNODE + \"/ID-\";\n     private static final String MAX_ID_SUFFIX = \"9999\";\n     private static final String MIN_ID_SUFFIX = \"0000\";\n \n     // Path to generate global id\n     private final String idGenPath;\n     // A sorted map to stored all active ledger ids\n-    private ConcurrentSkipListMap<Long, Boolean> activeLedgers;\n+    private SnapshotMap<Long, Boolean> activeLedgers;\n \n     // we use this to prevent long stack chains from building up in callbacks\n     ScheduledExecutorService scheduler;\n@@ -117,7 +120,8 @@ public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk,\n         }\n \n         this.idGenPath = ledgerRootPath + IDGENERATION_PREFIX;\n-        this.activeLedgers = new ConcurrentSkipListMap<Long, Boolean>();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n+\n         this.scheduler = Executors.newSingleThreadScheduledExecutor();\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Using HierarchicalLedgerManager with root path : \" + ledgerRootPath);\n@@ -135,7 +139,7 @@ public void close() {\n     }\n \n     @Override\n-    public void newLedgerPath(final GenericCallback<String> ledgerCb) {\n+    public void newLedgerPath(final GenericCallback<String> ledgerCb, final LedgerMetadata metadata) {\n         ZkUtils.createFullPathOptimistic(zk, idGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n             CreateMode.EPHEMERAL_SEQUENTIAL, new StringCallback() {\n             @Override\n@@ -164,12 +168,14 @@ public void processResult(int rc, String path,\n                         if (rc != KeeperException.Code.OK.intValue()) {\n                             ledgerCb.operationComplete(rc, null);\n                         } else {\n+                            // update znode status\n+                            metadata.updateZnodeStatus(0);\n                             ledgerCb.operationComplete(rc, name);\n                         }\n                     }\n                 };\n                 String ledgerPath = getLedgerPath(ledgerId);\n-                ZkUtils.createFullPathOptimistic(zk, ledgerPath, new byte[0],\n+                ZkUtils.createFullPathOptimistic(zk, ledgerPath, metadata.serialize(),\n                     Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, scb, null);\n                 // delete the znode for id generation\n                 scheduler.submit(new Runnable() {\n@@ -361,6 +367,8 @@ public boolean containsActiveLedger(long ledgerId) {\n \n     @Override\n     public void garbageCollectLedgers(GarbageCollector gc) {\n+        // create a snapshot before garbage collection\n+        NavigableMap<Long, Boolean> snapshot = activeLedgers.snapshot();\n         try {\n             List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n             for (String l1Node : l1Nodes) {\n@@ -370,15 +378,15 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n                 try {\n                     List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + l1Node, null);\n                     for (String l2Node : l2Nodes) {\n-                        doGcByLevel(gc, l1Node, l2Node);\n+                        doGcByLevel(gc, l1Node, l2Node, snapshot);\n                     }\n                 } catch (Exception e) {\n                     LOG.warn(\"Exception during garbage collecting ledgers for \" + l1Node\n-                           + \" of \" + ledgerRootPath);\n+                             + \" of \" + ledgerRootPath, e);\n                 }\n             }\n         } catch (Exception e) {\n-            LOG.warn(\"Exception during garbage collecting inactive/deleted ledgers\");\n+            LOG.warn(\"Exception during garbage collecting inactive/deleted ledgers\", e);\n         }\n     }\n \n@@ -391,23 +399,25 @@ public void garbageCollectLedgers(GarbageCollector gc) {\n      *          1st level node name\n      * @param level2\n      *          2nd level node name\n+     * @param snapshot\n+     *          Snapshot of the active ledgers map.\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    void doGcByLevel(GarbageCollector gc, final String level1, final String level2)\n+    void doGcByLevel(GarbageCollector gc, final String level1, final String level2,\n+                     NavigableMap snapshot)\n         throws IOException, InterruptedException {\n \n         StringBuilder nodeBuilder = new StringBuilder();\n         nodeBuilder.append(ledgerRootPath).append(\"/\")\n                    .append(level1).append(\"/\").append(level2);\n         String nodePath = nodeBuilder.toString();\n \n-        HashSet<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n+        Set<Long> zkActiveLedgers = getLedgersInSingleNode(nodePath);\n         // get hosted ledgers in /level1/level2\n         long startLedgerId = getStartLedgerIdByLevel(level1, level2);\n         long endLedgerId = getEndLedgerIdByLevel(level1, level2);\n-        ConcurrentMap<Long, Boolean> bkActiveLedgers =\n-            activeLedgers.subMap(startLedgerId, true, endLedgerId, true);\n+        Map<Long, Boolean> bkActiveLedgers = snapshot.subMap(startLedgerId, true, endLedgerId, true);\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"All active ledgers from ZK for hash node \"\n                       + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n@@ -418,28 +428,6 @@ void doGcByLevel(GarbageCollector gc, final String level1, final String level2)\n         doGc(gc, bkActiveLedgers, zkActiveLedgers);\n     }\n \n-    /**\n-     * Do garbage collecting comparing hosted ledgers and zk ledgers\n-     *\n-     * @param gc\n-     *          Garbage collector\n-     * @param bkActiveLedgers\n-     *          Active ledgers hosted in bookie server\n-     * @param zkAllLedgers\n-     *          All ledgers stored in zookeeper\n-     */\n-    void doGc(GarbageCollector gc, ConcurrentMap<Long, Boolean> bkActiveLedgers,\n-              HashSet<Long> zkAllLedgers) {\n-        // remove any active ledgers that doesn't exist in zk\n-        for (Long lid : bkActiveLedgers.keySet()) {\n-            if (!zkAllLedgers.contains(lid)) {\n-                // remove it from current active ledger\n-                bkActiveLedgers.remove(lid);\n-                gc.gc(lid);\n-            }\n-        }\n-    }\n-\n     /**\n      * Process list one by one in asynchronize way. Process will be stopped immediately\n      * when error occurred.\n@@ -511,4 +499,9 @@ public final void run() {\n             processor.process(firstElement, stubCallback);\n         }\n     }\n+\n+    @Override\n+    protected boolean isSpecialZnode(String znode) {\n+        return IDGEN_ZNODE.equals(znode) || super.isSpecialZnode(znode);\n+    }\n }"},{"sha":"cab02feaa8656adc9c0c47a28170a715a2849643","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerLayout.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -193,6 +193,11 @@ public boolean equals(Object obj) {\n             managerVersion == other.managerVersion;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return (managerType + managerVersion).hashCode();\n+    }\n+\n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();"},{"sha":"7d9eb96a52d45a7619fce58219df0be636c467ce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,6 +21,7 @@\n import java.io.IOException;\n \n import org.apache.zookeeper.AsyncCallback;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n \n@@ -55,12 +56,14 @@\n     public long getLedgerId(String ledgerPath) throws IOException;\n \n     /**\n-     * Create a new zk ledger path.\n+     * Create a new zk ledger path with provided metadata\n      *\n      * @param cb\n      *        Callback when getting new zk ledger path to create.\n+     * @param metadata\n+     *        Metadata provided when creating a new ledger\n      */\n-    public abstract void newLedgerPath(GenericCallback<String> cb);\n+    public abstract void newLedgerPath(GenericCallback<String> cb, LedgerMetadata metadata);\n \n     /**\n      * Loop to process all ledgers."},{"sha":"491a3e404e8a15f10c31317c1bd6203ee3638821","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -50,7 +50,7 @@ public static LedgerManager newLedgerManager(\n         \n         // if zk is null, return the default ledger manager\n         if (zk == null) {\n-            return new FlatLedgerManager(conf, zk, \n+            return new FlatLedgerManager(conf, null,\n                     ledgerRootPath, FlatLedgerManager.CUR_VERSION);\n         }\n "},{"sha":"c222f0591666452cb27215b4bf6c6756b3e15f27","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/SnapshotMap.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,132 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A snapshotable map.\n+ */\n+class SnapshotMap<K, V> {\n+    // stores recent updates\n+    volatile Map<K, V> updates;\n+    volatile Map<K, V> updatesToMerge;\n+    // map stores all snapshot data\n+    volatile NavigableMap<K, V> snapshot;\n+\n+    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public SnapshotMap() {\n+        updates = new ConcurrentHashMap<K, V>();\n+        updatesToMerge = new ConcurrentHashMap<K, V>();\n+        snapshot = new ConcurrentSkipListMap<K, V>();\n+    }\n+\n+    /**\n+     * Create a snapshot of current map.\n+     *\n+     * @return a snapshot of current map.\n+     */\n+    public NavigableMap<K, V> snapshot() {\n+        this.lock.writeLock().lock();\n+        try {\n+            if (updates.isEmpty()) {\n+                return snapshot;\n+            }\n+            // put updates for merge to snapshot\n+            updatesToMerge = updates;\n+            updates = new ConcurrentHashMap<K, V>();\n+        } finally {\n+            this.lock.writeLock().unlock();\n+        }\n+        // merging the updates to snapshot\n+        for (Map.Entry<K, V> entry : updatesToMerge.entrySet()) {\n+            snapshot.put(entry.getKey(), entry.getValue());\n+        }\n+        // clear updatesToMerge\n+        this.lock.writeLock().lock();\n+        try {\n+            updatesToMerge = new ConcurrentHashMap<K, V>();\n+        } finally {\n+            this.lock.writeLock().unlock();\n+        }\n+        return snapshot;\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this map.\n+     *\n+     * @param key\n+     *          Key with which the specified value is to be associated.\n+     * @param value\n+     *          Value to be associated with the specified key.\n+     */\n+    public void put(K key, V value) {\n+        this.lock.readLock().lock();\n+        try {\n+            updates.put(key, value);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+\n+    }\n+\n+    /**\n+     * Removes the mapping for the key from this map if it is present.\n+     *\n+     * @param key\n+     *          Key whose mapping is to be removed from this map.\n+     */\n+    public void remove(K key) {\n+        this.lock.readLock().lock();\n+        try {\n+            // first remove updates\n+            updates.remove(key);\n+            updatesToMerge.remove(key);\n+            // then remove snapshot\n+            snapshot.remove(key);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns true if this map contains a mapping for the specified key.\n+     *\n+     * @param key\n+     *          Key whose presence is in the map to be tested.\n+     * @return true if the map contains a mapping for the specified key.\n+     */\n+    public boolean containsKey(K key) {\n+        this.lock.readLock().lock();\n+        try {\n+            return updates.containsKey(key)\n+                 | updatesToMerge.containsKey(key)\n+                 | snapshot.containsKey(key);\n+        } finally {\n+            this.lock.readLock().unlock();\n+        }\n+    }\n+}"},{"sha":"8943775db9c827805b5b4f0f1d7bd4e1fce94fca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","status":"added","additions":236,"deletions":0,"changes":236,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,236 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+import java.beans.ConstructorProperties;\n+\n+/**\n+ * Bookie Server Stats\n+ */\n+public class BKStats {\n+    private static BKStats instance = new BKStats();\n+\n+    public static BKStats getInstance() {\n+        return instance;\n+    }\n+\n+    /**\n+     * A read view of stats, also used in CompositeViewData to expose to JMX\n+     */\n+    public static class OpStatData {\n+        private final long maxLatency, minLatency;\n+        private final double avgLatency;\n+        private final long numSuccessOps, numFailedOps;\n+        private final String latencyHist;\n+\n+        @ConstructorProperties({\"maxLatency\", \"minLatency\", \"avgLatency\",\n+                                \"numSuccessOps\", \"numFailedOps\", \"latencyHist\"})\n+        public OpStatData(long maxLatency, long minLatency, double avgLatency,\n+                          long numSuccessOps, long numFailedOps, String latencyHist) {\n+            this.maxLatency = maxLatency;\n+            this.minLatency = minLatency == Long.MAX_VALUE ? 0 : minLatency;\n+            this.avgLatency = avgLatency;\n+            this.numSuccessOps = numSuccessOps;\n+            this.numFailedOps = numFailedOps;\n+            this.latencyHist = latencyHist;\n+        }\n+\n+        public long getMaxLatency() {\n+            return maxLatency;\n+        }\n+\n+        public long getMinLatency() {\n+            return minLatency;\n+        }\n+\n+        public double getAvgLatency() {\n+            return avgLatency;\n+        }\n+\n+        public long getNumSuccessOps() {\n+            return numSuccessOps;\n+        }\n+\n+        public long getNumFailedOps() {\n+            return numFailedOps;\n+        }\n+\n+        public String getLatencyHist() {\n+            return latencyHist;\n+        }\n+    }\n+\n+    /**\n+     * Operation Statistics\n+     */\n+    public static class OpStats {\n+        static final int NUM_BUCKETS = 3*9 + 2;\n+\n+        long maxLatency = 0;\n+        long minLatency = Long.MAX_VALUE;\n+        double totalLatency = 0.0f;\n+        long numSuccessOps = 0;\n+        long numFailedOps = 0;\n+        long[] latencyBuckets = new long[NUM_BUCKETS];\n+\n+        OpStats() {}\n+\n+        /**\n+         * Increment number of failed operations\n+         */\n+        synchronized public void incrementFailedOps() {\n+            ++numFailedOps;\n+        }\n+\n+        /**\n+         * Update Latency\n+         */\n+        synchronized public void updateLatency(long latency) {\n+            totalLatency += latency;\n+            ++numSuccessOps;\n+            if (latency < minLatency) {\n+                minLatency = latency;\n+            }\n+            if (latency > maxLatency) {\n+                maxLatency = latency;\n+            }\n+            int bucket;\n+            if (latency <= 100) { // less than 100ms\n+                bucket = (int)(latency / 10);\n+            } else if (latency <= 1000) { // 100ms ~ 1000ms\n+                bucket = 1 * 9 + (int)(latency / 100);\n+            } else if (latency <= 10000) { // 1s ~ 10s\n+                bucket = 2 * 9 + (int)(latency / 1000);\n+            } else { // more than 10s\n+                bucket = 3 * 9 + 1;\n+            }\n+            ++latencyBuckets[bucket];\n+        }\n+\n+        public OpStatData toOpStatData() {\n+            double avgLatency = numSuccessOps > 0 ? totalLatency / numSuccessOps : 0.0f;\n+            StringBuilder sb = new StringBuilder();\n+            for (int i=0; i<NUM_BUCKETS; i++) {\n+                sb.append(latencyBuckets[i]);\n+                if (i != NUM_BUCKETS - 1) {\n+                    sb.append(',');\n+                }\n+            }\n+\n+            return new OpStatData(maxLatency, minLatency, avgLatency, numSuccessOps, numFailedOps, sb.toString());\n+        }\n+\n+        /**\n+         * Diff with base opstats\n+         *\n+         * @param base\n+         *        base opstats\n+         * @return diff opstats\n+         */\n+        public OpStats diff(OpStats base) {\n+            OpStats diff = new OpStats();\n+            diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;\n+            diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;\n+            diff.totalLatency = this.totalLatency - base.totalLatency;\n+            diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;\n+            diff.numFailedOps = this.numFailedOps - base.numFailedOps;\n+            for (int i = 0; i < NUM_BUCKETS; i++) {\n+                diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];\n+            }\n+            return diff;\n+        }\n+\n+        /**\n+         * Copy stats from other OpStats\n+         *\n+         * @param other other op stats\n+         * @return void\n+         */\n+        public synchronized void copyOf(OpStats other) {\n+            this.maxLatency = other.maxLatency;\n+            this.minLatency = other.minLatency;\n+            this.totalLatency = other.totalLatency;\n+            this.numSuccessOps = other.numSuccessOps;\n+            this.numFailedOps = other.numFailedOps;\n+            System.arraycopy(other.latencyBuckets, 0, this.latencyBuckets, 0, this.latencyBuckets.length);\n+        }\n+    }\n+\n+    public static final int STATS_ADD = 0;\n+    public static final int STATS_READ = 1;\n+    public static final int STATS_UNKNOWN = 2;\n+    // NOTE: if add other stats, increment NUM_STATS\n+    public static final int NUM_STATS = 3;\n+\n+    OpStats[] stats = new OpStats[NUM_STATS];\n+\n+    private BKStats() {\n+        for (int i=0; i<NUM_STATS; i++) {\n+            stats[i] = new OpStats();\n+        }\n+    }\n+\n+    /**\n+     * Stats of operations\n+     *\n+     * @return op stats\n+     */\n+    public OpStats getOpStats(int type) {\n+        return stats[type];\n+    }\n+\n+    /**\n+     * Set stats of a specified operation\n+     *\n+     * @param type operation type\n+     * @param stat operation stats\n+     */\n+    public void setOpStats(int type, OpStats stat) {\n+        stats[type] = stat;\n+    }\n+\n+    /**\n+     * Diff with base stats\n+     *\n+     * @param base base stats\n+     * @return diff stats\n+     */\n+    public BKStats diff(BKStats base) {\n+        BKStats diff = new BKStats();\n+        for (int i=0; i<NUM_STATS; i++) {\n+            diff.setOpStats(i, stats[i].diff(base.getOpStats(i)));\n+        }\n+        return diff;\n+    }\n+\n+    /**\n+     * Copy stats from other stats\n+     *\n+     * @param other other stats\n+     * @return void\n+     */\n+    public void copyOf(BKStats other) {\n+        for (int i=0; i<NUM_STATS; i++) {\n+            stats[i].copyOf(other.getOpStats(i));\n+        }\n+    }\n+}"},{"sha":"f45809de75788fafd85ccd096095ff9046130b26","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":49,"deletions":3,"changes":52,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,6 +21,8 @@\n  *\n  */\n \n+import java.util.Set;\n+import java.util.HashSet;\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -32,6 +34,8 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -65,7 +69,7 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n         PerChannelBookieClient channel = channels.get(addr);\n \n         if (channel == null) {\n-            channel = new PerChannelBookieClient(executor, channelFactory, addr, totalBytesOutstanding);\n+            channel = new PerChannelBookieClient(conf, executor, channelFactory, addr, totalBytesOutstanding);\n             PerChannelBookieClient prevChannel = channels.putIfAbsent(addr, channel);\n             if (prevChannel != null) {\n                 channel = prevChannel;\n@@ -75,6 +79,28 @@ public PerChannelBookieClient lookupClient(InetSocketAddress addr) {\n         return channel;\n     }\n \n+    public void closeClients(Set<InetSocketAddress> addrs) {\n+        final HashSet<PerChannelBookieClient> clients = new HashSet<PerChannelBookieClient>();\n+        for (InetSocketAddress a : addrs) {\n+            PerChannelBookieClient c = channels.get(a);\n+            if (c != null) {\n+                clients.add(c);\n+            }\n+        }\n+\n+        if (clients.size() == 0) {\n+            return;\n+        }\n+        executor.submit(new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    for (PerChannelBookieClient c : clients) {\n+                        c.close();\n+                    }\n+                }\n+            });\n+    }\n+\n     public void addEntry(final InetSocketAddress addr, final long ledgerId, final byte[] masterKey, final long entryId,\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n         final PerChannelBookieClient client = lookupClient(addr);\n@@ -91,8 +117,28 @@ public void operationComplete(int rc, Void result) {\n         });\n     }\n \n+    public void readEntryAndFenceLedger(final InetSocketAddress addr,\n+                                        final long ledgerId,\n+                                        final byte[] masterKey,\n+                                        final long entryId,\n+                                        final ReadEntryCallback cb,\n+                                        final Object ctx) {\n+        final PerChannelBookieClient client = lookupClient(addr);\n+\n+        client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (rc != BKException.Code.OK) {\n+                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n+                    return;\n+                }\n+                client.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n+            }\n+        });\n+    }\n+\n     public void readEntry(final InetSocketAddress addr, final long ledgerId, final long entryId,\n-                          final ReadEntryCallback cb, final Object ctx, final int options) {\n+                          final ReadEntryCallback cb, final Object ctx) {\n         final PerChannelBookieClient client = lookupClient(addr);\n \n         client.connectIfNeededAndDoOp(new GenericCallback<Void>() {\n@@ -103,7 +149,7 @@ public void operationComplete(int rc, Void result) {\n                     cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n                     return;\n                 }\n-                client.readEntry(ledgerId, entryId, cb, ctx, options);\n+                client.readEntry(ledgerId, entryId, cb, ctx);\n             }\n         });\n     }"},{"sha":"9f77d8a7cb90d90a4ffff8617d1b79e7198939d2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":19,"deletions":1,"changes":20,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -37,7 +37,25 @@\n     /**\n      * Current version of the protocol, which client will use. \n      */\n-    public static final byte CURRENT_PROTOCOL_VERSION = 1;\n+    public static final byte CURRENT_PROTOCOL_VERSION = 2;\n+\n+    /**\n+     * Entry Entry ID. To be used when no valid entry id can be assigned.\n+     */\n+    public static final long INVALID_ENTRY_ID = -1;\n+\n+    /**\n+     * Entry identifier representing a request to obtain the last add entry confirmed\n+     */\n+    public static final long LAST_ADD_CONFIRMED = -1;\n+\n+    /**\n+     * The length of the master key in add packets. This\n+     * is fixed at 20 for historic reasons. This is because it\n+     * is always generated using the MacDigestManager regardless\n+     * of whether Mac is being used for the digest or not\n+     */\n+    public static final int MASTER_KEY_LENGTH = 20;\n \n     /** \n      * The first int of a packet is the header."},{"sha":"125b3fa4ed4d5c3b0b8a9c79cba0f3cbfe9c779e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":149,"deletions":35,"changes":184,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -29,11 +29,15 @@\n import java.net.UnknownHostException;\n import java.nio.ByteBuffer;\n \n+import javax.management.JMException;\n+\n import org.apache.zookeeper.KeeperException;\n \n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.bookie.ExitCode;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.jmx.BKMBeanRegistry;\n import org.apache.bookkeeper.proto.NIOServerFactory.Cnxn;\n import static org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n import org.apache.commons.configuration.ConfigurationException;\n@@ -58,17 +62,37 @@\n     DeathWatcher deathWatcher;\n     static Logger LOG = LoggerFactory.getLogger(BookieServer.class);\n \n+    int exitCode = ExitCode.OK;\n+\n+    // operation stats\n+    final BKStats bkStats = BKStats.getInstance();\n+    final boolean isStatsEnabled;\n+    protected BookieServerBean jmxBkServerBean;\n+\n     public BookieServer(ServerConfiguration conf) \n-            throws IOException, KeeperException, InterruptedException {\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n         this.conf = conf;\n-        this.bookie = new Bookie(conf);\n+        this.bookie = newBookie(conf);\n+\n+        isStatsEnabled = conf.isStatisticsEnabled();\n+    }\n+\n+    protected Bookie newBookie(ServerConfiguration conf)\n+        throws IOException, KeeperException, InterruptedException, BookieException {\n+        return new Bookie(conf);\n     }\n \n     public void start() throws IOException {\n+        this.bookie.start();\n+\n         nioServerFactory = new NIOServerFactory(conf, this);\n+        nioServerFactory.start();\n         running = true;\n         deathWatcher = new DeathWatcher(conf);\n         deathWatcher.start();\n+\n+        // register jmx\n+        registerJMX();\n     }\n \n     public InetSocketAddress getLocalAddress() {\n@@ -79,13 +103,40 @@ public InetSocketAddress getLocalAddress() {\n         }\n     }\n \n-    public synchronized void shutdown() throws InterruptedException {\n+    public synchronized void shutdown() {\n         if (!running) {\n             return;\n         }\n         nioServerFactory.shutdown();\n-        bookie.shutdown();\n+        exitCode = bookie.shutdown();\n         running = false;\n+\n+        // unregister JMX\n+        unregisterJMX();\n+    }\n+\n+    protected void registerJMX() {\n+        try {\n+            jmxBkServerBean = new BookieServerBean(conf, this);\n+            BKMBeanRegistry.getInstance().register(jmxBkServerBean, null);\n+\n+            bookie.registerJMX(jmxBkServerBean);\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to register with JMX\", e);\n+            jmxBkServerBean = null;\n+        }\n+    }\n+\n+    protected void unregisterJMX() {\n+        try {\n+            bookie.unregisterJMX();\n+            if (jmxBkServerBean != null) {\n+                BKMBeanRegistry.getInstance().unregister(jmxBkServerBean);\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        jmxBkServerBean = null;\n     }\n \n     public boolean isRunning() {\n@@ -114,6 +165,10 @@ public void join() throws InterruptedException {\n         nioServerFactory.join();\n     }\n \n+    public int getExitCode() {\n+        return exitCode;\n+    }\n+\n     /**\n      * A thread to watch whether bookie & nioserver is still alive\n      */\n@@ -134,11 +189,7 @@ public void run() {\n                     // do nothing\n                 }\n                 if (!isBookieRunning() || !isNioServerRunning()) {\n-                    try {\n-                        shutdown();\n-                    } catch (InterruptedException ie) {\n-                        System.exit(-1);\n-                    }\n+                    shutdown();\n                     break;\n                 }\n             }\n@@ -220,16 +271,15 @@ private static ServerConfiguration parseArgs(String[] args)\n      * @throws IOException\n      * @throws InterruptedException\n      */\n-    public static void main(String[] args) \n-            throws IOException, KeeperException, InterruptedException {\n+    public static void main(String[] args) {\n         ServerConfiguration conf = null;\n         try {\n             conf = parseArgs(args);\n         } catch (IllegalArgumentException iae) {\n             LOG.error(\"Error parsing command line arguments : \", iae);\n             System.err.println(iae.getMessage());\n             printUsage();\n-            throw iae;\n+            System.exit(ExitCode.INVALID_CONF);\n         }\n \n         StringBuilder sb = new StringBuilder();\n@@ -246,41 +296,53 @@ public static void main(String[] args)\n                            conf.getBookiePort(), conf.getZkServers(),\n                            conf.getJournalDirName(), sb);\n         LOG.info(hello);\n-        final BookieServer bs = new BookieServer(conf);\n-        bs.start();\n-        Runtime.getRuntime().addShutdownHook(new Thread() {\n-            @Override\n-            public void run() {\n-                try {\n+        try {\n+            final BookieServer bs = new BookieServer(conf);\n+            bs.start();\n+            Runtime.getRuntime().addShutdownHook(new Thread() {\n+                @Override\n+                public void run() {\n                     bs.shutdown();\n                     LOG.info(\"Shut down bookie server successfully\");\n-                } catch (InterruptedException ie) {\n-                    LOG.warn(\"Exception when shutting down bookie server : \", ie);\n                 }\n-            }\n-        });\n-        LOG.info(\"Register shutdown hook successfully\");\n-        bs.join();\n+            });\n+            LOG.info(\"Register shutdown hook successfully\");\n+            bs.join();\n+\n+            System.exit(bs.getExitCode());\n+        } catch (Exception e) {\n+            LOG.error(\"Exception running bookie server : \", e);\n+            System.exit(ExitCode.SERVER_EXCEPTION);\n+        }\n     }\n \n     public void processPacket(ByteBuffer packet, Cnxn src) {\n         PacketHeader h = PacketHeader.fromInt(packet.getInt());\n \n+        boolean success = false;\n+        int statType = BKStats.STATS_UNKNOWN;\n+        long startTime = 0;\n+        if (isStatsEnabled) {\n+            startTime = System.currentTimeMillis();\n+        }\n+\n         // packet format is different between ADDENTRY and READENTRY\n         long ledgerId = -1;\n-        long entryId = -1;\n+        long entryId = BookieProtocol.INVALID_ENTRY_ID;\n         byte[] masterKey = null;\n         switch (h.getOpCode()) {\n         case BookieProtocol.ADDENTRY:\n             // first read master key\n-            masterKey = new byte[20];\n-            packet.get(masterKey, 0, 20);\n-            // !! fall thru to read ledger id and entry id\n-        case BookieProtocol.READENTRY:\n+            masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n+            packet.get(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n             ByteBuffer bb = packet.duplicate();\n             ledgerId = bb.getLong();\n             entryId = bb.getLong();\n             break;\n+        case BookieProtocol.READENTRY:\n+            ledgerId = packet.getLong();\n+            entryId = packet.getLong();\n+            break;\n         }\n \n         if (h.getVersion() < BookieProtocol.LOWEST_COMPAT_PROTOCOL_VERSION\n@@ -296,13 +358,16 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n         short flags = h.getFlags();\n         switch (h.getOpCode()) {\n         case BookieProtocol.ADDENTRY:\n+            statType = BKStats.STATS_ADD;\n             try {\n+                TimedCnxn tsrc = new TimedCnxn(src, startTime);\n                 // LOG.debug(\"Master key: \" + new String(masterKey));\n                 if ((flags & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n-                    bookie.recoveryAddEntry(packet.slice(), this, src, masterKey);\n+                    bookie.recoveryAddEntry(packet.slice(), this, tsrc, masterKey);\n                 } else {\n-                    bookie.addEntry(packet.slice(), this, src, masterKey);\n+                    bookie.addEntry(packet.slice(), this, tsrc, masterKey);\n                 }\n+                success = true;\n             } catch (IOException e) {\n                 LOG.error(\"Error writing \" + entryId + \"@\" + ledgerId, e);\n                 src.sendResponse(buildResponse(BookieProtocol.EIO, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n@@ -315,17 +380,27 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n             }\n             break;\n         case BookieProtocol.READENTRY:\n+            statType = BKStats.STATS_READ;\n             ByteBuffer[] rsp = new ByteBuffer[2];\n             LOG.debug(\"Received new read request: \" + ledgerId + \", \" + entryId);\n             int errorCode = BookieProtocol.EIO;\n             try {\n                 if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {\n                     LOG.warn(\"Ledger \" + ledgerId + \" fenced by \" + src.getPeerName());\n-                    bookie.fenceLedger(ledgerId);\n+                    if (h.getVersion() >= 2) {\n+                        masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n+                        packet.get(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n+\n+                        bookie.fenceLedger(ledgerId, masterKey);\n+                    } else {\n+                        LOG.error(\"Password not provided, Not safe to fence {}\", ledgerId);\n+                        throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                    }\n                 }\n                 rsp[1] = bookie.readEntry(ledgerId, entryId);\n                 LOG.debug(\"##### Read entry ##### \" + rsp[1].remaining());\n                 errorCode = BookieProtocol.EOK;\n+                success = true;\n             } catch (Bookie.NoLedgerException e) {\n                 if (LOG.isTraceEnabled()) {\n                     LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n@@ -341,6 +416,9 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n                     LOG.error(\"Error reading \" + entryId + \"@\" + ledgerId, e);\n                 }\n                 errorCode = BookieProtocol.EIO;\n+            } catch (BookieException e) {\n+                LOG.error(\"Unauthorized access to ledger \" + ledgerId, e);\n+                errorCode = BookieProtocol.EUA;\n             }\n             rsp[0] = buildResponse(errorCode, h.getVersion(), h.getOpCode(), ledgerId, entryId);\n \n@@ -358,11 +436,22 @@ public void processPacket(ByteBuffer packet, Cnxn src) {\n             LOG.debug(\"Sending response for: \" + entryId + \", \" + new String(rsp[1].array()));\n             src.sendResponse(rsp);\n             break;\n-        default: \n+        default:\n             src.sendResponse(buildResponse(BookieProtocol.EBADREQ, h.getVersion(), h.getOpCode(), ledgerId, entryId));\n         }\n+        if (isStatsEnabled) {\n+            if (success) {\n+                // for add operations, we compute latency in writeComplete callbacks.\n+                if (statType != BKStats.STATS_ADD) {\n+                    long elapsedTime = System.currentTimeMillis() - startTime;\n+                    bkStats.getOpStats(statType).updateLatency(elapsedTime);\n+                }\n+            } else {\n+                bkStats.getOpStats(statType).incrementFailedOps();\n+            }\n+        }\n     }\n-    \n+\n     private ByteBuffer buildResponse(int errorCode, byte version, byte opCode, long ledgerId, long entryId) {\n         ByteBuffer rsp = ByteBuffer.allocate(24);\n         rsp.putInt(new PacketHeader(version, \n@@ -376,7 +465,9 @@ private ByteBuffer buildResponse(int errorCode, byte version, byte opCode, long\n     }\n \n     public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n-        Cnxn src = (Cnxn) ctx;\n+        TimedCnxn tcnxn = (TimedCnxn) ctx;\n+        Cnxn src = tcnxn.cnxn;\n+        long startTime = tcnxn.time;\n         ByteBuffer bb = ByteBuffer.allocate(24);\n         bb.putInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n                                    BookieProtocol.ADDENTRY, (short)0).toInt());\n@@ -388,6 +479,29 @@ public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress\n             LOG.trace(\"Add entry rc = \" + rc + \" for \" + entryId + \"@\" + ledgerId);\n         }\n         src.sendResponse(new ByteBuffer[] { bb });\n+        if (isStatsEnabled) {\n+            // compute the latency\n+            if (0 == rc) {\n+                // for add operations, we compute latency in writeComplete callbacks.\n+                long elapsedTime = System.currentTimeMillis() - startTime;\n+                bkStats.getOpStats(BKStats.STATS_ADD).updateLatency(elapsedTime);\n+            } else {\n+                bkStats.getOpStats(BKStats.STATS_ADD).incrementFailedOps();                \n+            }\n+        }\n+    }\n+\n+    /**\n+     * A cnxn wrapper for time\n+     */\n+    static class TimedCnxn {\n+        Cnxn cnxn;\n+        long time;\n+\n+        public TimedCnxn(Cnxn cnxn, long startTime) {\n+            this.cnxn = cnxn;\n+            this.time = startTime;\n+        }\n     }\n \n }"},{"sha":"b222395ec45f4320fd290488f83acd4ec1078ab2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,90 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+import org.apache.bookkeeper.proto.BKStats;\n+import org.apache.bookkeeper.proto.BKStats.OpStats;\n+import org.apache.bookkeeper.proto.BKStats.OpStatData;\n+\n+/**\n+ * Bookie Server Bean\n+ */\n+public class BookieServerBean implements BookieServerMXBean, BKMBeanInfo {\n+\n+    protected final BookieServer bks;\n+    protected final ServerConfiguration conf;\n+    private final String name;\n+\n+    public BookieServerBean(ServerConfiguration conf, BookieServer bks) {\n+        this.conf = conf;\n+        this.bks = bks;\n+        name = \"BookieServer_\" + conf.getBookiePort();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long getNumPacketsReceived() {\n+        return ServerStats.getInstance().getPacketsReceived();\n+    }\n+\n+    @Override\n+    public long getNumPacketsSent() {\n+        return ServerStats.getInstance().getPacketsSent();\n+    }\n+\n+    @Override\n+    public OpStatData getAddStats() {\n+        return bks.bkStats.getOpStats(BKStats.STATS_ADD).toOpStatData();\n+    }\n+\n+    @Override\n+    public OpStatData getReadStats() {\n+        return bks.bkStats.getOpStats(BKStats.STATS_READ).toOpStatData();\n+    }\n+\n+    @Override\n+    public String getServerState() {\n+        return bks.nioServerFactory.stats.getServerState();\n+    }\n+\n+    @Override\n+    public String getServerPort() {\n+        try {\n+            return InetAddress.getLocalHost().getHostAddress() + \":\"\n+                    + conf.getBookiePort();\n+        } catch (UnknownHostException e) {\n+            return \"localhost:\" + conf.getBookiePort();\n+        }\n+    }\n+\n+}"},{"sha":"539f22273f01f70d20aa9820920c9e0325aab4f0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServerMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,58 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.proto.BKStats.OpStatData;\n+\n+/**\n+ * Bookie Server MBean\n+ */\n+public interface BookieServerMXBean {\n+\n+    /**\n+     * @return packets received\n+     */\n+    public long getNumPacketsReceived();\n+\n+    /**\n+     * @return packets sent\n+     */\n+    public long getNumPacketsSent();\n+\n+    /**\n+     * @return add stats\n+     */\n+    public OpStatData getAddStats();\n+\n+    /**\n+     * @return read stats\n+     */\n+    public OpStatData getReadStats();\n+\n+    /**\n+     * @return server state\n+     */\n+    public String getServerState();\n+\n+    /**\n+     * @return server port\n+     */\n+    public String getServerPort();\n+\n+}"},{"sha":"56dc6e6dec09e6b4d19303159af01a5566d43792","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","status":"modified","additions":7,"deletions":11,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NIOServerFactory.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -75,15 +75,14 @@\n     ServerConfiguration conf;\n \n     public NIOServerFactory(ServerConfiguration conf, PacketProcessor processor) throws IOException {\n-        super(\"NIOServerFactory\");\n+        super(\"NIOServerFactory-\" + conf.getBookiePort());\n         setDaemon(true);\n         this.processor = processor;\n         this.conf = conf;\n         this.ss = ServerSocketChannel.open();\n         ss.socket().bind(new InetSocketAddress(conf.getBookiePort()));\n         ss.configureBlocking(false);\n         ss.register(selector, SelectionKey.OP_ACCEPT);\n-        start();\n     }\n \n     public InetSocketAddress getLocalAddress() {\n@@ -188,10 +187,6 @@ public void shutdown() {\n \n         int sessionTimeout;\n \n-        int packetsSent;\n-\n-        int packetsReceived;\n-\n         void doIO(SelectionKey k) throws InterruptedException {\n             try {\n                 if (sock == null) {\n@@ -208,7 +203,7 @@ void doIO(SelectionKey k) throws InterruptedException {\n                             readLength(k);\n                         } else {\n                             cnxnStats.packetsReceived++;\n-                            stats.incrementPacketsReceived();\n+                            ServerStats.getInstance().incrementPacketsReceived();\n                             try {\n                                 readRequest();\n                             } finally {\n@@ -490,16 +485,17 @@ public InetSocketAddress getRemoteAddress() {\n         }\n \n         private class CnxnStats {\n-            long packetsReceived;\n-\n-            long packetsSent;\n+            long packetsSent = 0;\n+            long packetsReceived = 0;\n \n             /**\n              * The number of requests that have been submitted but not yet\n              * responded to.\n              */\n             public long getOutstandingRequests() {\n-                return outstandingRequests;\n+                synchronized(Cnxn.this) {\n+                    return outstandingRequests;\n+                }\n             }\n \n             public long getPacketsReceived() {"},{"sha":"36ddcf053d11586babb4c0b4961a2e52dc83607f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":130,"deletions":39,"changes":169,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -36,6 +36,8 @@\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.jboss.netty.util.Timer;\n+import org.jboss.netty.util.HashedWheelTimer;\n import org.jboss.netty.bootstrap.ClientBootstrap;\n import org.jboss.netty.buffer.ChannelBuffer;\n import org.jboss.netty.buffer.ChannelBuffers;\n@@ -56,6 +58,8 @@\n import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n+import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n+import org.jboss.netty.handler.timeout.ReadTimeoutException;\n \n /**\n  * This class manages all details of connection to a particular bookie. It also\n@@ -69,13 +73,14 @@\n     static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n \n     static final long maxMemory = Runtime.getRuntime().maxMemory() / 5;\n-    public static int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n+    public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n \n     InetSocketAddress addr;\n     Semaphore opCounterSem = new Semaphore(2000);\n     AtomicLong totalBytesOutstanding;\n     ClientSocketChannelFactory channelFactory;\n     OrderedSafeExecutor executor;\n+    private Timer readTimeoutTimer;\n \n     ConcurrentHashMap<CompletionKey, AddCompletion> addCompletions = new ConcurrentHashMap<CompletionKey, AddCompletion>();\n     ConcurrentHashMap<CompletionKey, ReadCompletion> readCompletions = new ConcurrentHashMap<CompletionKey, ReadCompletion>();\n@@ -85,13 +90,13 @@\n      * because they are always updated under a lock\n      */\n     Queue<GenericCallback<Void>> pendingOps = new ArrayDeque<GenericCallback<Void>>();\n-    Channel channel = null;\n+    volatile Channel channel = null;\n \n     private enum ConnectionState {\n         DISCONNECTED, CONNECTING, CONNECTED\n             };\n \n-    private ConnectionState state;\n+    private volatile ConnectionState state;\n     private final ClientConfiguration conf;\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n@@ -107,6 +112,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.totalBytesOutstanding = totalBytesOutstanding;\n         this.channelFactory = channelFactory;\n         this.state = ConnectionState.DISCONNECTED;\n+        this.readTimeoutTimer = null;\n     }\n \n     synchronized private void connect() {\n@@ -219,61 +225,66 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n                   Object ctx, final int options) {\n         final int entrySize = toSend.readableBytes();\n \n-        // if (totalBytesOutstanding.get() > maxMemory) {\n-        // // TODO: how to throttle, throw an exception, or call the callback?\n-        // // Maybe this should be done at the layer above?\n-        // }\n-\n         final CompletionKey completionKey = new CompletionKey(ledgerId, entryId);\n \n         addCompletions.put(completionKey, new AddCompletion(cb, entrySize, ctx));\n \n         int totalHeaderSize = 4 // for the length of the packet\n                               + 4 // for the type of request\n-                              + masterKey.length; // for the master key\n+                              + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n \n-        ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n-        header.writeInt(totalHeaderSize - 4 + entrySize);\n-        header.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n-                                         BookieProtocol.ADDENTRY, (short)options).toInt());\n-        header.writeBytes(masterKey);\n+        try{\n+            ChannelBuffer header = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n \n-        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(header, toSend);\n+            header.writeInt(totalHeaderSize - 4 + entrySize);\n+            header.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                                             BookieProtocol.ADDENTRY, (short)options).toInt());\n+            header.writeBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n \n-        ChannelFuture future = channel.write(wrappedBuffer);\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (future.isSuccess()) {\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Successfully wrote request for adding entry: \" + entryId + \" ledger-id: \" + ledgerId\n-                                  + \" bookie: \" + channel.getRemoteAddress() + \" entry length: \" + entrySize);\n+            ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer(header, toSend);\n+\n+            ChannelFuture future = channel.write(wrappedBuffer);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Successfully wrote request for adding entry: \" + entryId + \" ledger-id: \" + ledgerId\n+                                                            + \" bookie: \" + channel.getRemoteAddress() + \" entry length: \" + entrySize);\n+                        }\n+                        // totalBytesOutstanding.addAndGet(entrySize);\n+                    } else {\n+                        errorOutAddKey(completionKey);\n                     }\n-                    // totalBytesOutstanding.addAndGet(entrySize);\n-                } else {\n-                    errorOutAddKey(completionKey);\n                 }\n-            }\n-        });\n-\n+            });\n+        } catch (Throwable e) {\n+            LOG.warn(\"Add entry operation failed\", e);\n+            errorOutAddKey(completionKey);\n+        }\n     }\n \n-    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx, final int options) {\n+    public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n+                                        final long entryId,\n+                                        ReadEntryCallback cb, Object ctx) {\n         final CompletionKey key = new CompletionKey(ledgerId, entryId);\n         readCompletions.put(key, new ReadCompletion(cb, ctx));\n \n         int totalHeaderSize = 4 // for the length of the packet\n                               + 4 // for request type\n                               + 8 // for ledgerId\n-                              + 8; // for entryId\n+                              + 8 // for entryId\n+                              + BookieProtocol.MASTER_KEY_LENGTH; // for masterKey\n \n         ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n         tmpEntry.writeInt(totalHeaderSize - 4);\n \n-        tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION, \n-                                           BookieProtocol.READENTRY, (short)options).toInt());\n+        tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                                           BookieProtocol.READENTRY,\n+                                           BookieProtocol.FLAG_DO_FENCING).toInt());\n         tmpEntry.writeLong(ledgerId);\n         tmpEntry.writeLong(entryId);\n+        tmpEntry.writeBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n \n         ChannelFuture future = channel.write(tmpEntry);\n         future.addListener(new ChannelFutureListener() {\n@@ -289,13 +300,54 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 }\n             }\n         });\n+    }\n \n+    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n+        final CompletionKey key = new CompletionKey(ledgerId, entryId);\n+        readCompletions.put(key, new ReadCompletion(cb, ctx));\n+\n+        int totalHeaderSize = 4 // for the length of the packet\n+                              + 4 // for request type\n+                              + 8 // for ledgerId\n+                              + 8; // for entryId\n+\n+        try{\n+            ChannelBuffer tmpEntry = channel.getConfig().getBufferFactory().getBuffer(totalHeaderSize);\n+            tmpEntry.writeInt(totalHeaderSize - 4);\n+\n+            tmpEntry.writeInt(new PacketHeader(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n+                                               BookieProtocol.READENTRY, BookieProtocol.FLAG_NONE).toInt());\n+            tmpEntry.writeLong(ledgerId);\n+            tmpEntry.writeLong(entryId);\n+\n+            ChannelFuture future = channel.write(tmpEntry);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Successfully wrote request for reading entry: \" + entryId + \" ledger-id: \"\n+                                                            + ledgerId + \" bookie: \" + channel.getRemoteAddress());\n+                        }\n+                    } else {\n+                        errorOutReadKey(key);\n+                    }\n+                }\n+            });\n+        } catch(Throwable e) {\n+            LOG.warn(\"Read entry operation failed\", e);\n+            errorOutReadKey(key);\n+        }\n     }\n \n     public void close() {\n         if (channel != null) {\n             channel.close().awaitUninterruptibly();\n         }\n+        if (readTimeoutTimer != null) {\n+            readTimeoutTimer.stop();\n+            readTimeoutTimer = null;\n+        }\n     }\n \n     void errorOutReadKey(final CompletionKey key) {\n@@ -375,6 +427,13 @@ void errorOutOutstandingEntries() {\n     @Override\n     public ChannelPipeline getPipeline() throws Exception {\n         ChannelPipeline pipeline = Channels.pipeline();\n+\n+        if (readTimeoutTimer == null) {\n+            readTimeoutTimer = new HashedWheelTimer();\n+        }\n+\n+        pipeline.addLast(\"readTimeout\", new ReadTimeoutHandler(readTimeoutTimer, \n+                                                               conf.getReadTimeout()));\n         pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));\n         pipeline.addLast(\"mainhandler\", this);\n         return pipeline;\n@@ -388,8 +447,9 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n         LOG.info(\"Disconnected from bookie: \" + addr);\n         errorOutOutstandingEntries();\n         channel.close();\n-\n-        state = ConnectionState.DISCONNECTED;\n+        synchronized (this) {\n+            state = ConnectionState.DISCONNECTED;\n+        }\n \n         // we don't want to reconnect right away. If someone sends a request to\n         // this address, we will reconnect.\n@@ -407,6 +467,20 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws\n                       + e.getChannel().getRemoteAddress());\n             return;\n         }\n+        if (t instanceof ReadTimeoutException) {\n+            for (CompletionKey key : addCompletions.keySet()) {\n+                if (key.shouldTimeout()) {\n+                    errorOutAddKey(key);\n+                }\n+            }\n+            for (CompletionKey key : readCompletions.keySet()) {\n+                if (key.shouldTimeout()) {\n+                    errorOutReadKey(key);\n+                }\n+            }\n+            return;\n+        }\n+\n         if (t instanceof IOException) {\n             // these are thrown when a bookie fails, logging them just pollutes\n             // the logs (the failure is logged from the listeners on the write\n@@ -480,7 +554,10 @@ void handleAddResponse(long ledgerId, long entryId, int rc) {\n         case BookieProtocol.EFENCED:\n             rc = BKException.Code.LedgerFencedException;\n             break;\n-        default: \n+        case BookieProtocol.EUA:\n+            rc = BKException.Code.UnauthorizedAccessException;\n+            break;\n+        default:\n             LOG.error(\"Add for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n                       + \" with code: \" + rc);\n             rc = BKException.Code.WriteException;\n@@ -516,6 +593,8 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n             rc = BKException.Code.NoSuchEntryException;\n         } else if (rc == BookieProtocol.EBADVERSION) {\n             rc = BKException.Code.ProtocolVersionException;\n+        } else if (rc == BookieProtocol.EUA) {\n+            rc = BKException.Code.UnauthorizedAccessException;\n         } else {\n             LOG.error(\"Read for ledger: \" + ledgerId + \", entry: \" + entryId + \" failed on bookie: \" + addr\n                       + \" with code: \" + rc);\n@@ -531,7 +610,8 @@ void handleReadResponse(long ledgerId, long entryId, int rc, ChannelBuffer buffe\n              * submits a read request with id -1, and receives a response with a\n              * different entry id.\n              */\n-            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, -1));\n+            \n+            readCompletion = readCompletions.remove(new CompletionKey(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED));\n         }\n \n         if (readCompletion == null) {\n@@ -570,15 +650,22 @@ public AddCompletion(WriteCallback cb, long size, Object ctx) {\n             this.ctx = ctx;\n         }\n     }\n-    \n+\n+    // visable for testing\n+    CompletionKey newCompletionKey(long ledgerId, long entryId) {\n+        return new CompletionKey(ledgerId, entryId);\n+    }\n+\n     // visable for testing\n-    static class CompletionKey {\n+    class CompletionKey {\n         long ledgerId;\n         long entryId;\n+        final long timeoutAt;\n \n         CompletionKey(long ledgerId, long entryId) {\n             this.ledgerId = ledgerId;\n             this.entryId = entryId;\n+            this.timeoutAt = System.currentTimeMillis() + (conf.getReadTimeout()*1000);\n         }\n \n         @Override\n@@ -598,6 +685,10 @@ public int hashCode() {\n         public String toString() {\n             return String.format(\"LedgerEntry(%d, %d)\", ledgerId, entryId);\n         }\n+\n+        public boolean shouldTimeout() {\n+            return this.timeoutAt <= System.currentTimeMillis();\n+        }\n     }\n \n }"},{"sha":"6165791d85ae4bc7c5ba222cf549da91f676a987","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/BookKeeperTools.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -64,7 +64,7 @@ public static void main(String[] args)\n         String zkServers = args[0];\n         String bookieSrcString[] = args[1].split(\":\");\n         if (bookieSrcString.length < 2) {\n-            System.err.println(\"BookieSrc inputted has invalid name format (host:port expected): \" + bookieSrcString);\n+            System.err.println(\"BookieSrc inputted has invalid name format (host:port expected): \" + args[1]);\n             return;\n         }\n         final InetSocketAddress bookieSrc = new InetSocketAddress(bookieSrcString[0], Integer\n@@ -74,7 +74,7 @@ public static void main(String[] args)\n             String bookieDestString[] = args[2].split(\":\");\n             if (bookieDestString.length < 2) {\n                 System.err.println(\"BookieDest inputted has invalid name format (host:port expected): \"\n-                                   + bookieDestString);\n+                                   + args[2]);\n                 return;\n             }\n             bookieDest = new InetSocketAddress(bookieDestString[0], Integer.parseInt(bookieDestString[1]));"},{"sha":"57fbd3e044414fe7d85d33ecfdea6e4b7f574efb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","status":"added","additions":665,"deletions":0,"changes":665,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,665 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/* Copied wholesale from hadoop-common 0.23.1\n+package org.apache.hadoop.fs;\n+*/\n+package org.apache.bookkeeper.util;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+\n+/**\n+ * Class for creating hardlinks.\n+ * Supports Unix/Linux, WinXP/2003/Vista via Cygwin, and Mac OS X.\n+ * \n+ * The HardLink class was formerly a static inner class of FSUtil,\n+ * and the methods provided were blatantly non-thread-safe.\n+ * To enable volume-parallel Update snapshots, we now provide static \n+ * threadsafe methods that allocate new buffer string arrays\n+ * upon each call.  We also provide an API to hardlink all files in a\n+ * directory with a single command, which is up to 128 times more \n+ * efficient - and minimizes the impact of the extra buffer creations.\n+ */\n+public class HardLink { \n+\n+  public enum OSType {\n+    OS_TYPE_UNIX,\n+    OS_TYPE_WINXP,\n+    OS_TYPE_SOLARIS,\n+    OS_TYPE_MAC\n+  }\n+  \n+  public static final OSType osType;\n+  private static HardLinkCommandGetter getHardLinkCommand;\n+  \n+  public final LinkStats linkStats; //not static\n+  \n+  //initialize the command \"getters\" statically, so can use their \n+  //methods without instantiating the HardLink object\n+  static { \n+    osType = getOSType();\n+    if (osType == OSType.OS_TYPE_WINXP) {\n+      // Windows\n+      getHardLinkCommand = new HardLinkCGWin();\n+    } else {\n+      // Unix\n+      getHardLinkCommand = new HardLinkCGUnix();\n+      //override getLinkCountCommand for the particular Unix variant\n+      //Linux is already set as the default - {\"stat\",\"-c%h\", null}\n+      if (osType == OSType.OS_TYPE_MAC) {\n+        String[] linkCountCmdTemplate = {\"stat\",\"-f%l\", null};\n+        HardLinkCGUnix.setLinkCountCmdTemplate(linkCountCmdTemplate);\n+      } else if (osType == OSType.OS_TYPE_SOLARIS) {\n+        String[] linkCountCmdTemplate = {\"ls\",\"-l\", null};\n+        HardLinkCGUnix.setLinkCountCmdTemplate(linkCountCmdTemplate);        \n+      }\n+    }\n+  }\n+\n+  public HardLink() {\n+    linkStats = new LinkStats();\n+  }\n+  \n+  static private OSType getOSType() {\n+    String osName = System.getProperty(\"os.name\");\n+    if (osName.contains(\"Windows\") &&\n+            (osName.contains(\"XP\") \n+            || osName.contains(\"2003\") \n+            || osName.contains(\"Vista\")\n+            || osName.contains(\"Windows_7\")\n+            || osName.contains(\"Windows 7\") \n+            || osName.contains(\"Windows7\"))) {\n+      return OSType.OS_TYPE_WINXP;\n+    }\n+    else if (osName.contains(\"SunOS\") \n+            || osName.contains(\"Solaris\")) {\n+       return OSType.OS_TYPE_SOLARIS;\n+    }\n+    else if (osName.contains(\"Mac\")) {\n+       return OSType.OS_TYPE_MAC;\n+    }\n+    else {\n+      return OSType.OS_TYPE_UNIX;\n+    }\n+  }\n+  \n+  /**\n+   * This abstract class bridges the OS-dependent implementations of the \n+   * needed functionality for creating hardlinks and querying link counts.\n+   * The particular implementation class is chosen during \n+   * static initialization phase of the HardLink class.\n+   * The \"getter\" methods construct shell command strings for various purposes.\n+   */\n+  private static abstract class HardLinkCommandGetter {\n+\n+    /**\n+     * Get the command string needed to hardlink a bunch of files from\n+     * a single source directory into a target directory.  The source directory\n+     * is not specified here, but the command will be executed using the source\n+     * directory as the \"current working directory\" of the shell invocation.\n+     * \n+     * @param fileBaseNames - array of path-less file names, relative\n+     *            to the source directory\n+     * @param linkDir - target directory where the hardlinks will be put\n+     * @return - an array of Strings suitable for use as a single shell command\n+     *            with {@link Runtime.exec()}\n+     * @throws IOException - if any of the file or path names misbehave\n+     */\n+    abstract String[] linkMult(String[] fileBaseNames, File linkDir) \n+                          throws IOException;\n+    \n+    /**\n+     * Get the command string needed to hardlink a single file\n+     */\n+    abstract String[] linkOne(File file, File linkName) throws IOException;\n+    \n+    /**\n+     * Get the command string to query the hardlink count of a file\n+     */\n+    abstract String[] linkCount(File file) throws IOException;\n+    \n+    /**\n+     * Calculate the total string length of the shell command\n+     * resulting from execution of linkMult, plus the length of the\n+     * source directory name (which will also be provided to the shell)\n+     * \n+     * @param fileDir - source directory, parent of fileBaseNames\n+     * @param fileBaseNames - array of path-less file names, relative\n+     *            to the source directory\n+     * @param linkDir - target directory where the hardlinks will be put\n+     * @return - total data length (must not exceed maxAllowedCmdArgLength)\n+     * @throws IOException\n+     */\n+    abstract int getLinkMultArgLength(\n+                     File fileDir, String[] fileBaseNames, File linkDir) \n+                     throws IOException;\n+    \n+    /**\n+     * Get the maximum allowed string length of a shell command on this OS,\n+     * which is just the documented minimum guaranteed supported command\n+     * length - aprx. 32KB for Unix, and 8KB for Windows.\n+     */\n+    abstract int getMaxAllowedCmdArgLength(); \n+  }\n+  \n+  /**\n+   * Implementation of HardLinkCommandGetter class for Unix\n+   */\n+  static class HardLinkCGUnix extends HardLinkCommandGetter {\n+    private static String[] hardLinkCommand = {\"ln\", null, null};\n+    private static String[] hardLinkMultPrefix = {\"ln\"};\n+    private static String[] hardLinkMultSuffix = {null};\n+    private static String[] getLinkCountCommand = {\"stat\",\"-c%h\", null};\n+    //Unix guarantees at least 32K bytes cmd length.\n+    //Subtract another 64b to allow for Java 'exec' overhead\n+    private static final int maxAllowedCmdArgLength = 32*1024 - 65;\n+    \n+    private static synchronized \n+    void setLinkCountCmdTemplate(String[] template) {\n+      //May update this for specific unix variants, \n+      //after static initialization phase\n+      getLinkCountCommand = template;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkOne(java.io.File, java.io.File)\n+     */\n+    @Override\n+    String[] linkOne(File file, File linkName) \n+    throws IOException {\n+      String[] buf = new String[hardLinkCommand.length];\n+      System.arraycopy(hardLinkCommand, 0, buf, 0, hardLinkCommand.length);\n+      //unix wants argument order: \"ln <existing> <new>\"\n+      buf[1] = makeShellPath(file); \n+      buf[2] = makeShellPath(linkName);\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkMult(java.lang.String[], java.io.File)\n+     */\n+    @Override\n+    String[] linkMult(String[] fileBaseNames, File linkDir) \n+    throws IOException {\n+      String[] buf = new String[fileBaseNames.length \n+                                + hardLinkMultPrefix.length \n+                                + hardLinkMultSuffix.length];\n+      int mark=0;\n+      System.arraycopy(hardLinkMultPrefix, 0, buf, mark, \n+                       hardLinkMultPrefix.length);\n+      mark += hardLinkMultPrefix.length;\n+      System.arraycopy(fileBaseNames, 0, buf, mark, fileBaseNames.length);\n+      mark += fileBaseNames.length;\n+      buf[mark] = makeShellPath(linkDir);\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkCount(java.io.File)\n+     */\n+    @Override\n+    String[] linkCount(File file) \n+    throws IOException {\n+      String[] buf = new String[getLinkCountCommand.length];\n+      System.arraycopy(getLinkCountCommand, 0, buf, 0, \n+                       getLinkCountCommand.length);\n+      buf[getLinkCountCommand.length - 1] = makeShellPath(file);\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getLinkMultArgLength(java.io.File, java.lang.String[], java.io.File)\n+     */\n+    @Override\n+    int getLinkMultArgLength(File fileDir, String[] fileBaseNames, File linkDir) \n+    throws IOException{\n+      int sum = 0;\n+      for (String x : fileBaseNames) {\n+        // add 1 to account for terminal null or delimiter space\n+        sum += 1 + ((x == null) ? 0 : x.length());\n+      }\n+      sum += 2 + makeShellPath(fileDir).length()\n+             + makeShellPath(linkDir).length();\n+      //add the fixed overhead of the hardLinkMult prefix and suffix\n+      sum += 3; //length(\"ln\") + 1\n+      return sum;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getMaxAllowedCmdArgLength()\n+     */\n+    @Override\n+    int getMaxAllowedCmdArgLength() {\n+      return maxAllowedCmdArgLength;\n+    }\n+  }\n+  \n+  \n+  /**\n+   * Implementation of HardLinkCommandGetter class for Windows\n+   * \n+   * Note that the linkCount shell command for Windows is actually\n+   * a Cygwin shell command, and depends on ${cygwin}/bin\n+   * being in the Windows PATH environment variable, so\n+   * stat.exe can be found.\n+   */\n+  static class HardLinkCGWin extends HardLinkCommandGetter {\n+    //The Windows command getter impl class and its member fields are\n+    //package-private (\"default\") access instead of \"private\" to assist \n+    //unit testing (sort of) on non-Win servers\n+\n+    static String[] hardLinkCommand = {\n+                        \"fsutil\",\"hardlink\",\"create\", null, null};\n+    static String[] hardLinkMultPrefix = {\n+                        \"cmd\",\"/q\",\"/c\",\"for\", \"%f\", \"in\", \"(\"};\n+    static String   hardLinkMultDir = \"\\\\%f\";\n+    static String[] hardLinkMultSuffix = {\n+                        \")\", \"do\", \"fsutil\", \"hardlink\", \"create\", null, \n+                        \"%f\", \"1>NUL\"};\n+    static String[] getLinkCountCommand = {\"stat\",\"-c%h\", null};\n+    //Windows guarantees only 8K - 1 bytes cmd length.\n+    //Subtract another 64b to allow for Java 'exec' overhead\n+    static final int maxAllowedCmdArgLength = 8*1024 - 65;\n+\n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkOne(java.io.File, java.io.File)\n+     */\n+    @Override\n+    String[] linkOne(File file, File linkName) \n+    throws IOException {\n+      String[] buf = new String[hardLinkCommand.length];\n+      System.arraycopy(hardLinkCommand, 0, buf, 0, hardLinkCommand.length);\n+      //windows wants argument order: \"create <new> <existing>\"\n+      buf[4] = file.getCanonicalPath(); \n+      buf[3] = linkName.getCanonicalPath();\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkMult(java.lang.String[], java.io.File)\n+     */\n+    @Override\n+    String[] linkMult(String[] fileBaseNames, File linkDir) \n+    throws IOException {\n+      String[] buf = new String[fileBaseNames.length \n+                                + hardLinkMultPrefix.length \n+                                + hardLinkMultSuffix.length];\n+      String td = linkDir.getCanonicalPath() + hardLinkMultDir;\n+      int mark=0;\n+      System.arraycopy(hardLinkMultPrefix, 0, buf, mark, \n+                       hardLinkMultPrefix.length);\n+      mark += hardLinkMultPrefix.length;\n+      System.arraycopy(fileBaseNames, 0, buf, mark, fileBaseNames.length);\n+      mark += fileBaseNames.length;\n+      System.arraycopy(hardLinkMultSuffix, 0, buf, mark, \n+                       hardLinkMultSuffix.length);\n+      mark += hardLinkMultSuffix.length;\n+      buf[mark - 3] = td;\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkCount(java.io.File)\n+     */\n+    @Override\n+    String[] linkCount(File file) \n+    throws IOException {\n+      String[] buf = new String[getLinkCountCommand.length];\n+      System.arraycopy(getLinkCountCommand, 0, buf, 0, \n+                       getLinkCountCommand.length);\n+      //The linkCount command is actually a Cygwin shell command,\n+      //not a Windows shell command, so we should use \"makeShellPath()\"\n+      //instead of \"getCanonicalPath()\".  However, that causes another\n+      //shell exec to \"cygpath.exe\", and \"stat.exe\" actually can handle\n+      //DOS-style paths (it just prints a couple hundred bytes of warning\n+      //to stderr), so we use the more efficient \"getCanonicalPath()\".\n+      buf[getLinkCountCommand.length - 1] = file.getCanonicalPath();\n+      return buf;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getLinkMultArgLength(java.io.File, java.lang.String[], java.io.File)\n+     */\n+    @Override\n+    int getLinkMultArgLength(File fileDir, String[] fileBaseNames, File linkDir) \n+    throws IOException {\n+      int sum = 0;\n+      for (String x : fileBaseNames) {\n+        // add 1 to account for terminal null or delimiter space\n+        sum += 1 + ((x == null) ? 0 : x.length());\n+      }\n+      sum += 2 + fileDir.getCanonicalPath().length() +\n+               linkDir.getCanonicalPath().length();\n+      //add the fixed overhead of the hardLinkMult command \n+      //(prefix, suffix, and Dir suffix)\n+      sum += (\"cmd.exe /q /c for %f in ( ) do \"\n+              + \"fsutil hardlink create \\\\%f %f 1>NUL \").length();\n+      return sum;\n+    }\n+    \n+    /*\n+     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getMaxAllowedCmdArgLength()\n+     */\n+    @Override\n+    int getMaxAllowedCmdArgLength() {\n+      return maxAllowedCmdArgLength;\n+    }\n+  }\n+  \n+  \n+  /**\n+   * Calculate the nominal length of all contributors to the total \n+   * commandstring length, including fixed overhead of the OS-dependent \n+   * command.  It's protected rather than private, to assist unit testing,\n+   * but real clients are not expected to need it -- see the way \n+   * createHardLinkMult() uses it internally so the user doesn't need to worry\n+   * about it.\n+   * \n+   * @param fileDir - source directory, parent of fileBaseNames\n+   * @param fileBaseNames - array of path-less file names, relative\n+   *            to the source directory\n+   * @param linkDir - target directory where the hardlinks will be put\n+   * @return - total data length (must not exceed maxAllowedCmdArgLength)\n+   * @throws IOException\n+   */\n+  protected static int getLinkMultArgLength(\n+          File fileDir, String[] fileBaseNames, File linkDir) \n+  throws IOException {\n+    return getHardLinkCommand.getLinkMultArgLength(fileDir, \n+          fileBaseNames, linkDir);\n+  }\n+  \n+  /**\n+   * Return this private value for use by unit tests.\n+   * Shell commands are not allowed to have a total string length\n+   * exceeding this size.\n+   */\n+  protected static int getMaxAllowedCmdArgLength() {\n+    return getHardLinkCommand.getMaxAllowedCmdArgLength();\n+  }\n+  \n+  /*\n+   * ****************************************************\n+   * Complexity is above.  User-visible functionality is below\n+   * ****************************************************\n+   */\n+\n+  /**\n+   * Creates a hardlink \n+   * @param file - existing source file\n+   * @param linkName - desired target link file\n+   */\n+  public static void createHardLink(File file, File linkName) \n+  throws IOException {\n+    if (file == null) {\n+      throw new IOException(\n+          \"invalid arguments to createHardLink: source file is null\");\n+    }\n+    if (linkName == null) {\n+      throw new IOException(\n+          \"invalid arguments to createHardLink: link name is null\");\n+    }\n+\t  // construct and execute shell command\n+    String[] hardLinkCommand = getHardLinkCommand.linkOne(file, linkName);\n+    Process process = Runtime.getRuntime().exec(hardLinkCommand);\n+    try {\n+      if (process.waitFor() != 0) {\n+        String errMsg = new BufferedReader(new InputStreamReader(\n+            process.getInputStream())).readLine();\n+        if (errMsg == null)  errMsg = \"\";\n+        String inpMsg = new BufferedReader(new InputStreamReader(\n+            process.getErrorStream())).readLine();\n+        if (inpMsg == null)  inpMsg = \"\";\n+        throw new IOException(errMsg + inpMsg);\n+      }\n+    } catch (InterruptedException e) {\n+      throw new IOException(e);\n+    } finally {\n+      process.destroy();\n+    }\n+  }\n+\n+  /**\n+   * Creates hardlinks from multiple existing files within one parent\n+   * directory, into one target directory.\n+   * @param parentDir - directory containing source files\n+   * @param fileBaseNames - list of path-less file names, as returned by \n+   *                        parentDir.list()\n+   * @param linkDir - where the hardlinks should be put.  It must already exist.\n+   * \n+   * If the list of files is too long (overflows maxAllowedCmdArgLength),\n+   * we will automatically split it into multiple invocations of the\n+   * underlying method.\n+   */\n+  public static void createHardLinkMult(File parentDir, String[] fileBaseNames, \n+      File linkDir) throws IOException {\n+    //This is the public method all non-test clients are expected to use.\n+    //Normal case - allow up to maxAllowedCmdArgLength characters in the cmd\n+    createHardLinkMult(parentDir, fileBaseNames, linkDir, \n+                       getHardLinkCommand.getMaxAllowedCmdArgLength());\n+  }\n+\n+  /*\n+   * Implements {@link createHardLinkMult} with added variable  \"maxLength\",\n+   * to ease unit testing of the auto-splitting feature for long lists.\n+   * Likewise why it returns \"callCount\", the number of sub-arrays that\n+   * the file list had to be split into.\n+   * Non-test clients are expected to call the public method instead.\n+   */\n+  protected static int createHardLinkMult(File parentDir, \n+      String[] fileBaseNames, File linkDir, int maxLength) \n+  throws IOException {\n+    if (parentDir == null) {\n+      throw new IOException(\n+          \"invalid arguments to createHardLinkMult: parent directory is null\");\n+    }\n+    if (linkDir == null) {\n+      throw new IOException(\n+          \"invalid arguments to createHardLinkMult: link directory is null\");\n+    }\n+    if (fileBaseNames == null) {\n+      throw new IOException(\n+          \"invalid arguments to createHardLinkMult: \"\n+          + \"filename list can be empty but not null\");\n+    }\n+    if (fileBaseNames.length == 0) {\n+      //the OS cmds can't handle empty list of filenames, \n+      //but it's legal, so just return.\n+      return 0; \n+    }\n+    if (!linkDir.exists()) {\n+      throw new FileNotFoundException(linkDir + \" not found.\");\n+    }\n+\n+    //if the list is too long, split into multiple invocations\n+    int callCount = 0;\n+    if (getLinkMultArgLength(parentDir, fileBaseNames, linkDir) > maxLength\n+          && fileBaseNames.length > 1) {\n+      String[] list1 = Arrays.copyOf(fileBaseNames, fileBaseNames.length/2);\n+      callCount += createHardLinkMult(parentDir, list1, linkDir, maxLength);\n+      String[] list2 = Arrays.copyOfRange(fileBaseNames, fileBaseNames.length/2,\n+          fileBaseNames.length);\n+      callCount += createHardLinkMult(parentDir, list2, linkDir, maxLength);  \n+      return callCount;\n+    } else {\n+      callCount = 1;\n+    }\n+    \n+    // construct and execute shell command\n+    String[] hardLinkCommand = getHardLinkCommand.linkMult(fileBaseNames, \n+        linkDir);\n+    Process process = Runtime.getRuntime().exec(hardLinkCommand, null, \n+        parentDir);\n+    try {\n+      if (process.waitFor() != 0) {\n+        String errMsg = new BufferedReader(new InputStreamReader(\n+            process.getInputStream())).readLine();\n+        if (errMsg == null)  errMsg = \"\";\n+        String inpMsg = new BufferedReader(new InputStreamReader(\n+            process.getErrorStream())).readLine();\n+        if (inpMsg == null)  inpMsg = \"\";\n+        throw new IOException(errMsg + inpMsg);\n+      }\n+    } catch (InterruptedException e) {\n+      throw new IOException(e);\n+    } finally {\n+      process.destroy();\n+    }\n+    return callCount;\n+  }\n+\n+   /**\n+   * Retrieves the number of links to the specified file.\n+   */\n+  public static int getLinkCount(File fileName) throws IOException {\n+    if (fileName == null) {\n+      throw new IOException(\n+          \"invalid argument to getLinkCount: file name is null\");\n+    }\n+    if (!fileName.exists()) {\n+      throw new FileNotFoundException(fileName + \" not found.\");\n+    }\n+\n+    // construct and execute shell command\n+    String[] cmd = getHardLinkCommand.linkCount(fileName);\n+    String inpMsg = null;\n+    String errMsg = null;\n+    int exitValue = -1;\n+    BufferedReader in = null;\n+    BufferedReader err = null;\n+\n+    Process process = Runtime.getRuntime().exec(cmd);\n+    try {\n+      exitValue = process.waitFor();\n+      in = new BufferedReader(new InputStreamReader(\n+                                  process.getInputStream()));\n+      inpMsg = in.readLine();\n+      err = new BufferedReader(new InputStreamReader(\n+                                   process.getErrorStream()));\n+      errMsg = err.readLine();\n+      if (inpMsg == null || exitValue != 0) {\n+        throw createIOException(fileName, inpMsg, errMsg, exitValue, null);\n+      }\n+      if (osType == OSType.OS_TYPE_SOLARIS) {\n+        String[] result = inpMsg.split(\"\\\\s+\");\n+        return Integer.parseInt(result[1]);\n+      } else {\n+        return Integer.parseInt(inpMsg);\n+      }\n+    } catch (NumberFormatException e) {\n+      throw createIOException(fileName, inpMsg, errMsg, exitValue, e);\n+    } catch (InterruptedException e) {\n+      throw createIOException(fileName, inpMsg, errMsg, exitValue, e);\n+    } finally {\n+      process.destroy();\n+      if (in != null) in.close();\n+      if (err != null) err.close();\n+    }\n+  }\n+  \n+  /* Create an IOException for failing to get link count. */\n+  private static IOException createIOException(File f, String message,\n+      String error, int exitvalue, Exception cause) {\n+    \n+    final String winErrMsg = \"; Windows errors in getLinkCount are often due \"\n+         + \"to Cygwin misconfiguration\";\n+\n+    final String s = \"Failed to get link count on file \" + f\n+        + \": message=\" + message\n+        + \"; error=\" + error\n+        + ((osType == OSType.OS_TYPE_WINXP) ? winErrMsg : \"\")\n+        + \"; exit value=\" + exitvalue;\n+    return (cause == null) ? new IOException(s) : new IOException(s, cause);\n+  }\n+  \n+  \n+  /**\n+   * HardLink statistics counters and methods.\n+   * Not multi-thread safe, obviously.\n+   * Init is called during HardLink instantiation, above.\n+   * \n+   * These are intended for use by knowledgeable clients, not internally, \n+   * because many of the internal methods are static and can't update these\n+   * per-instance counters.\n+   */\n+  public static class LinkStats {\n+    public int countDirs = 0; \n+    public int countSingleLinks = 0; \n+    public int countMultLinks = 0; \n+    public int countFilesMultLinks = 0; \n+    public int countEmptyDirs = 0; \n+    public int countPhysicalFileCopies = 0;\n+  \n+    public void clear() {\n+      countDirs = 0; \n+      countSingleLinks = 0; \n+      countMultLinks = 0; \n+      countFilesMultLinks = 0; \n+      countEmptyDirs = 0; \n+      countPhysicalFileCopies = 0;\n+    }\n+    \n+    public String report() {\n+      return \"HardLinkStats: \" + countDirs + \" Directories, including \" \n+      + countEmptyDirs + \" Empty Directories, \" \n+      + countSingleLinks \n+      + \" single Link operations, \" + countMultLinks \n+      + \" multi-Link operations, linking \" + countFilesMultLinks \n+      + \" files, total \" + (countSingleLinks + countFilesMultLinks) \n+      + \" linkable files.  Also physically copied \" \n+      + countPhysicalFileCopies + \" other files.\";\n+    }\n+  }\n+\n+  /**\n+   * Convert a os-native filename to a path that works for the shell.\n+   * @param filename The filename to convert\n+   * @return The unix pathname\n+   * @throws IOException on windows, there can be problems with the subprocess\n+   */\n+  public static String makeShellPath(File file) throws IOException {\n+    String filename = file.getCanonicalPath();\n+    if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+      BufferedReader r = null;\n+      try {\n+        ProcessBuilder pb = new ProcessBuilder(\"cygpath\", \"-u\", filename);\n+        Process p = pb.start();\n+        int err = p.waitFor();\n+        if (err != 0) {\n+            throw new IOException(\"Couldn't resolve path \"\n+                                  + filename + \"(\" + err + \")\");\n+        }\n+        r = new BufferedReader(new InputStreamReader(p.getInputStream()));\n+        return r.readLine();\n+      } catch (InterruptedException ie) {\n+        throw new IOException(\"Couldn't resolve path \" + filename, ie);\n+      } finally {\n+        if (r != null) {\n+          r.close();\n+        }\n+      }\n+    } else {\n+      return filename;\n+    }\n+  }\n+}\n+"},{"sha":"61fab73286bd8e7cf0eeb2f9ea2a50fa9d5932b9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/IOUtils.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,55 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import java.io.IOException;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * An utility class for I/O related functionality.\n+ */\n+public class IOUtils {\n+\n+    /**\n+     * Close the Closeable objects and <b>ignore</b> any {@link IOException} or\n+     * null pointers. Must only be used for cleanup in exception handlers.\n+     * \n+     * @param log\n+     *            the log to record problems to at debug level. Can be null.\n+     * @param closeables\n+     *            the objects to close\n+     */\n+    public static void close(Logger log, java.io.Closeable... closeables) {\n+        for (java.io.Closeable c : closeables) {\n+            if (c != null) {\n+                try {\n+                    c.close();\n+                } catch (IOException e) {\n+                    if (log != null && log.isDebugEnabled()) {\n+                        log.debug(\"Exception in closing \" + c, e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+}"},{"sha":"f6dc07bad939a3e33d9f1b02f5d7dd1e253160bb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":42,"deletions":20,"changes":62,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -26,22 +26,20 @@\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.server.NIOServerCnxnFactory;\n import org.apache.zookeeper.server.ZooKeeperServer;\n@@ -67,6 +65,7 @@ public LocalBookKeeper(int numberOfBookies) {\n     ZooKeeperServer zks;\n     ZooKeeper zkc;\n     int ZooKeeperDefaultPort = 2181;\n+    static int zkSessionTimeOut = 5000;\n     File ZkTmpDir;\n \n     //BookKeeper variables\n@@ -85,8 +84,9 @@ private void runZookeeper(int maxCC) throws IOException {\n         //ServerStats.registerAsConcrete();\n         //ClientBase.setupTestEnv();\n         ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n-        ZkTmpDir.delete();\n-        ZkTmpDir.mkdir();\n+        if (!ZkTmpDir.delete() || !ZkTmpDir.mkdir()) {\n+            throw new IOException(\"Couldn't create zk directory \" + ZkTmpDir);\n+        }\n \n         try {\n             zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n@@ -102,11 +102,14 @@ private void runZookeeper(int maxCC) throws IOException {\n         LOG.debug(\"ZooKeeper server up: \" + b);\n     }\n \n-    private void initializeZookeper() {\n+    private void initializeZookeper() throws IOException {\n         LOG.info(\"Instantiate ZK Client\");\n         //initialize the zk client with values\n         try {\n-            zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n+            ZKConnectionWatcher zkConnectionWatcher = new ZKConnectionWatcher();\n+            zkc = new ZooKeeper(HOSTPORT, zkSessionTimeOut,\n+                    zkConnectionWatcher);\n+            zkConnectionWatcher.waitForConnection();\n             zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n             zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n             // No need to create an entry for each requested bookie anymore as the\n@@ -117,13 +120,10 @@ private void initializeZookeper() {\n         } catch (InterruptedException e) {\n             // TODO Auto-generated catch block\n             LOG.error(\"Interrupted while creating znodes\", e);\n-        } catch (IOException e) {\n-            // TODO Auto-generated catch block\n-            LOG.error(\"Exception while creating znodes\", e);\n         }\n     }\n     private void runBookies(ServerConfiguration baseConf) \n-            throws IOException, KeeperException, InterruptedException {\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n         LOG.info(\"Starting Bookie(s)\");\n         // Create Bookie Servers (B1, B2, B3)\n \n@@ -133,8 +133,9 @@ private void runBookies(ServerConfiguration baseConf)\n \n         for(int i = 0; i < numberOfBookies; i++) {\n             tmpDirs[i] = File.createTempFile(\"bookie\" + Integer.toString(i), \"test\");\n-            tmpDirs[i].delete();\n-            tmpDirs[i].mkdir();\n+            if (!tmpDirs[i].delete() || !tmpDirs[i].mkdir()) {\n+                throw new IOException(\"Couldn't create bookie dir \" + tmpDirs[i]);\n+            }\n \n             bsConfs[i] = new ServerConfiguration(baseConf);\n             // override settings\n@@ -150,7 +151,7 @@ private void runBookies(ServerConfiguration baseConf)\n     }\n \n     public static void main(String[] args)\n-            throws IOException, KeeperException, InterruptedException {\n+            throws IOException, KeeperException, InterruptedException, BookieException {\n         if(args.length < 1) {\n             usage();\n             System.exit(-1);\n@@ -181,9 +182,30 @@ private static void usage() {\n         System.err.println(\"Usage: LocalBookKeeper number-of-bookies\");\n     }\n \n-    /*\tUser for testing purposes, void */\n-    class emptyWatcher implements Watcher {\n-        public void process(WatchedEvent event) {}\n+    /* Watching SyncConnected event from ZooKeeper */\n+    static class ZKConnectionWatcher implements Watcher {\n+        private CountDownLatch clientConnectLatch = new CountDownLatch(1);\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            if (event.getState() == KeeperState.SyncConnected) {\n+                clientConnectLatch.countDown();\n+            }\n+        }\n+\n+        // Waiting for the SyncConnected event from the ZooKeeper server\n+        public void waitForConnection() throws IOException {\n+            try {\n+                if (!clientConnectLatch.await(zkSessionTimeOut,\n+                        TimeUnit.MILLISECONDS)) {\n+                    throw new IOException(\n+                            \"Couldn't connect to zookeeper server\");\n+                }\n+            } catch (InterruptedException e) {\n+                throw new IOException(\n+                        \"Interrupted when connecting to zookeeper server\", e);\n+            }\n+        }\n     }\n \n     public static boolean waitForServerUp(String hp, long timeout) {"},{"sha":"d11ebef44bd552f7965e3920c23216574bb8bb41","filename":"bookkeeper-server/src/main/resources/LICENSE.bin.txt","status":"added","additions":265,"deletions":0,"changes":265,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/resources/LICENSE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/resources/LICENSE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/LICENSE.bin.txt?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,265 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+\n+------------------------------------------------------------------------------------\n+For lib/slf4j-*.jar\n+\n+ Copyright (c) 2004-2011 QOS.ch\n+ All rights reserved.\n+\n+ Permission is hereby granted, free  of charge, to any person obtaining\n+ a  copy  of this  software  and  associated  documentation files  (the\n+ \"Software\"), to  deal in  the Software without  restriction, including\n+ without limitation  the rights to  use, copy, modify,  merge, publish,\n+ distribute,  sublicense, and/or sell  copies of  the Software,  and to\n+ permit persons to whom the Software  is furnished to do so, subject to\n+ the following conditions:\n+\n+ The  above  copyright  notice  and  this permission  notice  shall  be\n+ included in all copies or substantial portions of the Software.\n+\n+ THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n+ EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n+ MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n+ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+ OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n+ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+------------------------------------------------------------------------------------\n+For lib/jline-*.jar\n+\n+Copyright (c) 2002-2006, Marc Prud'hommeaux <mwp1@cornell.edu>\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or\n+without modification, are permitted provided that the following\n+conditions are met:\n+\n+Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+\n+Redistributions in binary form must reproduce the above copyright\n+notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with\n+the distribution.\n+\n+Neither the name of JLine nor the names of its contributors\n+may be used to endorse or promote products derived from this\n+software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n+AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n+EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n+OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+"},{"sha":"b55e16f9685220d2cdf5af7768ad92314cfad644","filename":"bookkeeper-server/src/main/resources/NOTICE.bin.txt","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/resources/NOTICE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/main/resources/NOTICE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/main/resources/NOTICE.bin.txt?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,33 @@\n+Apache BookKeeper\n+Copyright 2011-2012 The Apache Software Foundation\n+\n+Licensed under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License. You may obtain a copy of the License at:\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+\n+This project includes:\n+  Apache Log4j under The Apache Software License, Version 2.0\n+  Commons BeanUtils Core under The Apache Software License, Version 2.0\n+  Commons CLI under The Apache Software License, Version 2.0\n+  Commons Collections under The Apache Software License, Version 2.0\n+  Commons Configuration under The Apache Software License, Version 2.0\n+  Commons IO under The Apache Software License, Version 2.0\n+  Commons Lang under The Apache Software License, Version 2.0\n+  Commons Logging under The Apache Software License, Version 2.0\n+  commons Beanutils under Apache License, Version 2.0\n+  Commons Digester under The Apache Software License, Version 2.0\n+  JLine under BSD\n+  SLF4J API Module under MIT License\n+  SLF4J LOG4J-12 Binding under MIT License\n+  The Netty Project under Apache License, Version 2.0\n+  ZooKeeper under Apache License, Version 2.0\n+"},{"sha":"3c6d99b6d5670eb023699c7402b89c0b2a24ba2d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"added","additions":582,"deletions":0,"changes":582,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,582 @@\n+package org.apache.bookkeeper.bookie;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.io.File;\n+import java.io.RandomAccessFile;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.Arrays;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeperTestClient;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.ClientUtil;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Before;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class BookieJournalTest {\n+    static Logger LOG = LoggerFactory.getLogger(BookieJournalTest.class);\n+\n+    final Random r = new Random(System.currentTimeMillis());\n+\n+    private void writeIndexFileForLedger(File indexDir, long ledgerId,\n+                                         byte[] masterKey)\n+            throws Exception {\n+        File fn = new File(indexDir, LedgerCacheImpl.getLedgerName(ledgerId));\n+        fn.getParentFile().mkdirs();\n+        FileInfo fi = new FileInfo(fn, masterKey);\n+        // force creation of index file\n+        fi.write(new ByteBuffer[]{ ByteBuffer.allocate(0) }, 0);\n+        fi.close(true);\n+    }\n+\n+    private void writePartialIndexFileForLedger(File indexDir, long ledgerId,\n+                                                byte[] masterKey, boolean truncateToMasterKey)\n+            throws Exception {\n+        File fn = new File(indexDir, LedgerCacheImpl.getLedgerName(ledgerId));\n+        fn.getParentFile().mkdirs();\n+        FileInfo fi = new FileInfo(fn, masterKey);\n+        // force creation of index file\n+        fi.write(new ByteBuffer[]{ ByteBuffer.allocate(0) }, 0);\n+        fi.close(true);\n+        // file info header\n+        int headerLen = 8 + 4 + masterKey.length;\n+        // truncate the index file\n+        int leftSize;\n+        if (truncateToMasterKey) {\n+            leftSize = r.nextInt(headerLen);\n+        } else {\n+            leftSize = headerLen + r.nextInt(1024 - headerLen);\n+        }\n+        FileChannel fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+        fc.truncate(leftSize);\n+        fc.close();\n+    }\n+\n+    /**\n+     * Generate meta entry with given master key\n+     */\n+    private ByteBuffer generateMetaEntry(long ledgerId, byte[] masterKey) {\n+        ByteBuffer bb = ByteBuffer.allocate(8 + 8 + 4 + masterKey.length);\n+        bb.putLong(ledgerId);\n+        bb.putLong(Bookie.METAENTRY_ID_LEDGER_KEY);\n+        bb.putInt(masterKey.length);\n+        bb.put(masterKey);\n+        bb.flip();\n+        return bb;\n+    }\n+\n+    private void writeJunkJournal(File journalDir) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        File fn = new File(journalDir, Long.toHexString(logId) + \".txn\");\n+\n+        FileChannel fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+\n+        ByteBuffer zeros = ByteBuffer.allocate(512);\n+        fc.write(zeros, 4*1024*1024);\n+        fc.position(0);\n+\n+        for (int i = 1; i <= 10; i++) {\n+            fc.write(ByteBuffer.wrap(\"JunkJunkJunk\".getBytes()));\n+        }\n+    }\n+\n+    private void writePreV2Journal(File journalDir, int numEntries) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        File fn = new File(journalDir, Long.toHexString(logId) + \".txn\");\n+\n+        FileChannel fc = new RandomAccessFile(fn, \"rw\").getChannel();\n+\n+        ByteBuffer zeros = ByteBuffer.allocate(512);\n+        fc.write(zeros, 4*1024*1024);\n+        fc.position(0);\n+\n+        byte[] data = \"JournalTestData\".getBytes();\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+        for (int i = 1; i <= numEntries; i++) {\n+            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            fc.write(lenBuff);\n+            fc.write(packet);\n+        }\n+    }\n+\n+    private JournalChannel writePostV2Journal(File journalDir, int numEntries) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        byte[] data = new byte[1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+        for (int i = 1; i <= numEntries; i++) {\n+            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+        }\n+        bc.flush(true);\n+\n+        return jc;\n+    }\n+\n+    private JournalChannel writePostV3Journal(File journalDir, int numEntries, byte[] masterKey) throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        byte[] data = new byte[1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+        for (int i = 0; i <= numEntries; i++) {\n+            ByteBuffer packet;\n+            if (i == 0) {\n+                packet = generateMetaEntry(1, masterKey);\n+            } else {\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            }\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+        }\n+        bc.flush(true);\n+\n+        return jc;\n+    }\n+\n+    /**\n+     * test that we can open a journal written without the magic\n+     * word at the start. This is for versions of bookkeeper before\n+     * the magic word was introduced\n+     */\n+    @Test\n+    public void testPreV2Journal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writePreV2Journal(Bookie.getCurrentDirectory(journalDir), 100);\n+        writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir), 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.start();\n+\n+        b.readEntry(1, 100);\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if the journal is all journal, we can not\n+     * start the bookie. An admin should look to see what has\n+     * happened in this case\n+     */\n+    @Test\n+    public void testAllJunkJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writeJunkJournal(Bookie.getCurrentDirectory(journalDir));\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+        Bookie b = null;\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start without admin\");\n+        } catch (Throwable t) {\n+            // correct behaviour\n+        } finally {\n+            if (b != null) {\n+                b.shutdown();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test that we can start with an empty journal.\n+     * This can happen if the bookie crashes between creating the\n+     * journal and writing the magic word. It could also happen before\n+     * the magic word existed, if the bookie started but nothing was\n+     * ever written.\n+     */\n+    @Test\n+    public void testEmptyJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writePreV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+    }\n+\n+    /**\n+     * Test that a journal can load if only the magic word and\n+     * version are there.\n+     */\n+    @Test\n+    public void testHeaderOnlyJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        writePostV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+    }\n+\n+    /**\n+     * Test that if a journal has junk at the end, it does not load.\n+     * If the journal is corrupt like this, admin intervention is needed\n+     */\n+    @Test\n+    public void testJunkEndedJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        JournalChannel jc = writePostV2Journal(Bookie.getCurrentDirectory(journalDir), 0);\n+        jc.getBufferedChannel().write(ByteBuffer.wrap(\"JunkJunkJunk\".getBytes()));\n+        jc.getBufferedChannel().flush(true);\n+\n+        writeIndexFileForLedger(ledgerDir, 1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = null;\n+        try {\n+            b = new Bookie(conf);\n+        } catch (Throwable t) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if the bookie crashes while writing the length\n+     * of an entry, that we can recover.\n+     *\n+     * This is currently not the case, which is bad as recovery\n+     * should be fine here. The bookie has crashed while writing\n+     * but so the client has not be notified of success.\n+     */\n+    @Test\n+    public void testTruncatedInLenJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        JournalChannel jc = writePostV2Journal(\n+                Bookie.getCurrentDirectory(journalDir), 100);\n+        ByteBuffer zeros = ByteBuffer.allocate(2048);\n+\n+        jc.fc.position(jc.getBufferedChannel().position() - 0x429);\n+        jc.fc.write(zeros);\n+        jc.fc.force(false);\n+\n+        writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),\n+                                1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+\n+        b.readEntry(1, 99);\n+\n+        try {\n+            b.readEntry(1, 100);\n+            fail(\"Shouldn't have found entry 100\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if the bookie crashes in the middle of writing\n+     * the actual entry it can recover.\n+     * In this case the entry will be available, but it will corrupt.\n+     * This is ok, as the client will disregard the entry after looking\n+     * at its checksum.\n+     */\n+    @Test\n+    public void testTruncatedInEntryJournal() throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        JournalChannel jc = writePostV2Journal(\n+                Bookie.getCurrentDirectory(journalDir), 100);\n+        ByteBuffer zeros = ByteBuffer.allocate(2048);\n+\n+        jc.fc.position(jc.getBufferedChannel().position() - 0x300);\n+        jc.fc.write(zeros);\n+        jc.fc.force(false);\n+\n+        writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),\n+                                1, \"testPasswd\".getBytes());\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+        b.readEntry(1, 99);\n+\n+        // still able to read last entry, but it's junk\n+        ByteBuffer buf = b.readEntry(1, 100);\n+        assertEquals(\"Ledger Id is wrong\", buf.getLong(), 1);\n+        assertEquals(\"Entry Id is wrong\", buf.getLong(), 100);\n+        assertEquals(\"Last confirmed is wrong\", buf.getLong(), 99);\n+        assertEquals(\"Length is wrong\", buf.getLong(), 100*1024);\n+        buf.getLong(); // skip checksum\n+        boolean allX = true;\n+        for (int i = 0; i < 1024; i++) {\n+            byte x = buf.get();\n+            allX = allX && x == (byte)'X';\n+        }\n+        assertFalse(\"Some of buffer should have been zeroed\", allX);\n+\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test partial index (truncate master key) with pre-v3 journals\n+     */\n+    @Test\n+    public void testPartialFileInfoPreV3Journal1() throws Exception {\n+        testPartialFileInfoPreV3Journal(true);\n+    }\n+\n+    /**\n+     * Test partial index with pre-v3 journals\n+     */\n+    @Test\n+    public void testPartialFileInfoPreV3Journal2() throws Exception {\n+        testPartialFileInfoPreV3Journal(false);\n+    }\n+\n+    /**\n+     * Test partial index file with pre-v3 journals.\n+     */\n+    private void testPartialFileInfoPreV3Journal(boolean truncateMasterKey)\n+        throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        writePreV2Journal(Bookie.getCurrentDirectory(journalDir), 100);\n+        writePartialIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),\n+                                       1, \"testPasswd\".getBytes(), truncateMasterKey);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        if (truncateMasterKey) {\n+            try {\n+                Bookie b = new Bookie(conf);\n+                fail(\"Should not reach here!\");\n+            } catch (IOException ie) {\n+            }\n+        } else {\n+            Bookie b = new Bookie(conf);\n+\n+            b.readEntry(1, 100);\n+            try {\n+                b.readEntry(1, 101);\n+                fail(\"Shouldn't have found entry 101\");\n+            } catch (Bookie.NoEntryException e) {\n+                // correct behaviour\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test partial index (truncate master key) with post-v3 journals\n+     */\n+    @Test\n+    public void testPartialFileInfoPostV3Journal1() throws Exception {\n+        testPartialFileInfoPostV3Journal(true);\n+    }\n+\n+    /**\n+     * Test partial index with post-v3 journals\n+     */\n+    @Test\n+    public void testPartialFileInfoPostV3Journal2() throws Exception {\n+        testPartialFileInfoPostV3Journal(false);\n+    }\n+\n+    /**\n+     * Test partial index file with post-v3 journals.\n+     */\n+    private void testPartialFileInfoPostV3Journal(boolean truncateMasterKey)\n+        throws Exception {\n+        File journalDir = File.createTempFile(\"bookie\", \"journal\");\n+        journalDir.delete();\n+        journalDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));\n+\n+        File ledgerDir = File.createTempFile(\"bookie\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));\n+\n+        byte[] masterKey = \"testPasswd\".getBytes();\n+\n+        writePostV3Journal(Bookie.getCurrentDirectory(journalDir), 100, masterKey);\n+        writePartialIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir), 1, masterKey,\n+                                       truncateMasterKey);\n+\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(null)\n+            .setJournalDirName(journalDir.getPath())\n+            .setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        Bookie b = new Bookie(conf);\n+\n+        b.readEntry(1, 100);\n+        try {\n+            b.readEntry(1, 101);\n+            fail(\"Shouldn't have found entry 101\");\n+        } catch (Bookie.NoEntryException e) {\n+            // correct behaviour\n+        }\n+    }\n+}"},{"sha":"c7b07e68d18d77afc75fd555d996eab76e4c81b9","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieLayoutVersionTest.java","status":"removed","additions":0,"deletions":261,"changes":261,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieLayoutVersionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieLayoutVersionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieLayoutVersionTest.java?ref=814f0ab6b4d43a35992e995c8abd804326ec633b","patch":"@@ -1,261 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.bookie;\n-\n-import java.io.IOException;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.BufferedWriter;\n-import java.io.OutputStreamWriter;\n-\n-import org.junit.*;\n-import static org.junit.Assert.*;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-\n-import org.apache.bookkeeper.test.BaseTestCase;\n-\n-public class BookieLayoutVersionTest extends BaseTestCase {\n-    static Logger LOG = LoggerFactory.getLogger(BookieLayoutVersionTest.class);\n-    \n-    final int BOOKIE_PORT = 3181;\n-\n-    public BookieLayoutVersionTest(DigestType digestType) {\n-        super(0);\n-    }\n-\n-    private static void writeTextToVersionFile(File dir, String text) throws IOException {\n-        File versionFile = new File(dir, Bookie.VERSION_FILENAME);\n-\n-        FileOutputStream fos = new FileOutputStream(versionFile);\n-        BufferedWriter bw = null;\n-        try {\n-            bw = new BufferedWriter(new OutputStreamWriter(fos));\n-            bw.write(text);\n-        } finally {\n-            if (bw != null) {\n-                bw.close();\n-            }\n-            fos.close();\n-        }\n-    }\n-\n-    private static void writeDirectoryLayoutVersionFile(File dir, int version) throws IOException {\n-        writeTextToVersionFile(dir, String.valueOf(version));\n-    }\n-\n-    private static File newDirectory(int version) throws IOException {\n-        File d = newDirectoryWithoutVersion();\n-        writeDirectoryLayoutVersionFile(d, version);\n-        return d;\n-    }\n-    \n-    private static File newDirectoryWithoutVersion() throws IOException {\n-        File d = File.createTempFile(\"bookie\", \"dir\");\n-        d.delete();\n-        d.mkdirs();\n-        return d;\n-    }\n-\n-    @Test\n-    public void testTooNewVersion() throws Exception {\n-        // test with bad ledger dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectoryWithoutVersion(),\n-                new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION + 1) }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-        \n-        // test with bad data dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION + 1),\n-                new File[] { newDirectoryWithoutVersion() }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-\n-        // test with both bad        \n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION + 1),\n-                new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION + 1) }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-\n-        // test with neither bad, both with good version\n-        Bookie b = new Bookie(newServerConfiguration(\n-            BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION ),\n-            new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION) }));\n-        b.shutdown();\n-    }\n-\n-    @Test\n-    public void testTooOldVersion() throws Exception {\n-        // test with bad ledger dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectoryWithoutVersion(),\n-                new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1) }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-        \n-        // test with bad data dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1),\n-                new File[] { newDirectoryWithoutVersion() }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-\n-        // test with both bad        \n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1),\n-                new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1) }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-    }\n-    \n-    @Test\n-    public void testSomeOldSomeCurrent() throws Exception {\n-        // test with both bad        \n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                    BOOKIE_PORT, HOSTPORT, newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION),\n-                    new File[] { newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1),\n-                                 newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION),\n-                                 newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION + 1),\n-                                 newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION),\n-                                 newDirectory(Bookie.CURRENT_DIRECTORY_LAYOUT_VERSION - 1),}));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Directory has an invalid version,\"));\n-        }\n-    }\n-\n-    @Test\n-    public void testInvalidVersionFile() throws Exception {\n-        // invalid data\n-        File junkDir = newDirectoryWithoutVersion();\n-        writeTextToVersionFile(junkDir, \"JunkText\");\n-        File junkDir2 = newDirectoryWithoutVersion();\n-        writeTextToVersionFile(junkDir2, \"JunkText2\");\n-\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectoryWithoutVersion(),\n-                new File[] { junkDir }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Version file has invalid content\"));\n-        }\n-        \n-        // test with bad data dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, junkDir,\n-                new File[] { newDirectoryWithoutVersion() }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Version file has invalid content\"));\n-        }\n-\n-        // test with both bad        \n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, junkDir,\n-                new File[] { junkDir2 }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Version file has invalid content\"));\n-        }\n-    }\n-    \n-    @Test \n-    public void directoryIsReadOnly() throws Exception {\n-        // invalid data\n-        File roDir = newDirectoryWithoutVersion();\n-        roDir.setWritable(false);\n-        File roDir2 = newDirectoryWithoutVersion();\n-        roDir2.setWritable(false);\n-\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, newDirectoryWithoutVersion(),\n-                new File[] { roDir }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Permission denied\"));\n-        }\n-        \n-        // test with bad data dir\n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, roDir,\n-                new File[] { newDirectoryWithoutVersion() }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Permission denied\"));\n-        }\n-\n-        // test with both bad        \n-        try {\n-            Bookie b = new Bookie(newServerConfiguration(\n-                BOOKIE_PORT, HOSTPORT, roDir,\n-                new File[] { roDir2 }));\n-            fail(\"Shouldn't reach here\");\n-        } catch (IOException ioe) {\n-            assertTrue(\"Invalid exception\", \n-                       ioe.getMessage().contains(\"Permission denied\"));\n-        }\n-\n-    } \n-\n-\n-}"},{"sha":"8ba99639f8298cb369af4486a75fd7a8267dc12c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"added","additions":319,"deletions":0,"changes":319,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,319 @@\n+package org.apache.bookkeeper.bookie;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * This class tests the entry log compaction functionality.\n+ */\n+public class CompactionTest extends BookKeeperClusterTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(CompactionTest.class);\n+    DigestType digestType;\n+\n+    static int ENTRY_SIZE = 1024;\n+    static int NUM_BOOKIES = 1;\n+\n+    int numEntries;\n+    int gcWaitTime;\n+    double minorCompactionThreshold;\n+    double majorCompactionThreshold;\n+    long minorCompactionInterval;\n+    long majorCompactionInterval;\n+\n+    String msg;\n+\n+    public CompactionTest() {\n+        super(NUM_BOOKIES);\n+\n+        this.digestType = DigestType.CRC32;\n+\n+        numEntries = 100;\n+        gcWaitTime = 1000;\n+        minorCompactionThreshold = 0.1f;\n+        majorCompactionThreshold = 0.5f;\n+        minorCompactionInterval = 2 * gcWaitTime / 1000;\n+        majorCompactionInterval = 4 * gcWaitTime / 1000;\n+\n+        // a dummy message\n+        StringBuilder msgSB = new StringBuilder();\n+        for (int i = 0; i < ENTRY_SIZE; i++) {\n+            msgSB.append(\"a\");\n+        }\n+        msg = msgSB.toString();\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        // Set up the configuration properties needed.\n+        baseConf.setEntryLogSizeLimit(numEntries * ENTRY_SIZE);\n+        baseConf.setGcWaitTime(gcWaitTime);\n+        baseConf.setMinorCompactionThreshold(minorCompactionThreshold);\n+        baseConf.setMajorCompactionThreshold(majorCompactionThreshold);\n+        baseConf.setMinorCompactionInterval(minorCompactionInterval);\n+        baseConf.setMajorCompactionInterval(majorCompactionInterval);\n+\n+        super.setUp();\n+    }\n+\n+    LedgerHandle[] prepareData(int numEntryLogs, boolean changeNum)\n+        throws Exception {\n+        // since an entry log file can hold at most 100 entries\n+        // first ledger write 2 entries, which is less than low water mark\n+        int num1 = 2;\n+        // third ledger write more than high water mark entries\n+        int num3 = (int)(numEntries * 0.7f);\n+        // second ledger write remaining entries, which is higher than low water mark\n+        // and less than high water mark\n+        int num2 = numEntries - num3 - num1;\n+\n+        LedgerHandle[] lhs = new LedgerHandle[3];\n+        for (int i=0; i<3; ++i) {\n+            lhs[i] = bkc.createLedger(NUM_BOOKIES, NUM_BOOKIES, digestType, \"\".getBytes());\n+        }\n+\n+        for (int n = 0; n < numEntryLogs; n++) {\n+            for (int k = 0; k < num1; k++) {\n+                lhs[0].addEntry(msg.getBytes());\n+            }\n+            for (int k = 0; k < num2; k++) {\n+                lhs[1].addEntry(msg.getBytes());\n+            }\n+            for (int k = 0; k < num3; k++) {\n+                lhs[2].addEntry(msg.getBytes());\n+            }\n+            if (changeNum) {\n+                --num2;\n+                ++num3;\n+            }\n+        }\n+\n+        return lhs;\n+    }\n+\n+    private void verifyLedger(long lid, long startEntryId, long endEntryId) throws Exception {\n+        LedgerHandle lh = bkc.openLedger(lid, digestType, \"\".getBytes());\n+        Enumeration<LedgerEntry> entries = lh.readEntries(startEntryId, endEntryId);\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertEquals(msg, new String(entry.getEntry()));\n+        }\n+    }\n+\n+    private boolean[] checkLogFiles(File ledgerDirectory, int numFiles) {\n+        boolean[] hasLogFiles = new boolean[numFiles];\n+        Arrays.fill(hasLogFiles, false);\n+        for (File f : Bookie.getCurrentDirectory(ledgerDirectory).listFiles()) {\n+            LOG.info(\"Checking file : \" + f);\n+            if (f.isFile()) {\n+                String name = f.getName();\n+                if (!name.endsWith(\".log\")) {\n+                    continue;\n+                }\n+                String idString = name.split(\"\\\\.\")[0];\n+                int id = Integer.parseInt(idString, 16);\n+                if (id >= numFiles) {\n+                    continue;\n+                }\n+                hasLogFiles[id] = true; \n+            }\n+        }\n+        return hasLogFiles;\n+    }\n+\n+    @Test\n+    public void testDisableCompaction() throws Exception {\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        // disable compaction\n+        baseConf.setMinorCompactionThreshold(0.0f);\n+        baseConf.setMajorCompactionThreshold(0.0f);\n+\n+        // restart bookies\n+        restartBookies(baseConf);\n+\n+        // remove ledger2 and ledger3\n+        // so entry log 1 and 2 would have ledger1 entries left\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+        Thread.sleep(baseConf.getMajorCompactionInterval() * 1000\n+                   + baseConf.getGcWaitTime());\n+\n+        // entry logs ([0,1].log) should not be compacted.\n+        for (File ledgerDirectory : tmpDirs) {\n+            boolean[] hasLogFiles = checkLogFiles(ledgerDirectory, 2);\n+            assertTrue(\"Not Found entry log file ([0,1].log that should have been compacted in ledgerDirectory: \" + ledgerDirectory, hasLogFiles[0] & hasLogFiles[1]);\n+        }\n+    }\n+\n+    @Test\n+    public void testMinorCompaction() throws Exception {\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // disable major compaction\n+        baseConf.setMajorCompactionThreshold(0.0f);\n+\n+        // restart bookies\n+        restartBookies(baseConf);\n+\n+        // remove ledger2 and ledger3\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+        Thread.sleep(baseConf.getMinorCompactionInterval() * 1000\n+                   + baseConf.getGcWaitTime());\n+\n+        // entry logs ([0,1,2].log) should be compacted.\n+        for (File ledgerDirectory : tmpDirs) {\n+            boolean[] hasLog = checkLogFiles(ledgerDirectory, 3); \n+            assertFalse(\"Found entry log file ([0,1,2].log that should have not been compacted in ledgerDirectory: \" + ledgerDirectory, hasLog[0] | hasLog[1] | hasLog[2]);\n+        }\n+\n+        // even entry log files are removed, we still can access entries for ledger1\n+        // since those entries has been compacted to new entry log\n+        verifyLedger(lhs[0].getId(), 0, lhs[0].getLastAddConfirmed());\n+    }\n+\n+    @Test\n+    public void testMajorCompaction() throws Exception {\n+\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, true);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // disable minor compaction\n+        baseConf.setMinorCompactionThreshold(0.0f);\n+\n+        // restart bookies\n+        restartBookies(baseConf);\n+\n+        // remove ledger1 and ledger3\n+        bkc.deleteLedger(lhs[0].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+\n+        Thread.sleep(baseConf.getMajorCompactionInterval() * 1000\n+                   + baseConf.getGcWaitTime());\n+\n+        // entry logs ([0,1,2].log) should be compacted\n+        for (File ledgerDirectory : tmpDirs) {\n+            boolean[] hasLogFiles = checkLogFiles(ledgerDirectory, 3); \n+            assertFalse(\"Found entry log file ([0,1,2].log that should have not been compacted in ledgerDirectory: \"\n+                      + ledgerDirectory, hasLogFiles[0] | hasLogFiles[1] | hasLogFiles[2]);\n+        }\n+\n+        // even entry log files are removed, we still can access entries for ledger2\n+        // since those entries has been compacted to new entry log\n+        verifyLedger(lhs[1].getId(), 0, lhs[1].getLastAddConfirmed());\n+    }\n+\n+    @Test\n+    public void testMajorCompactionAboveThreshold() throws Exception {\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // remove ledger1 and ledger2\n+        bkc.deleteLedger(lhs[0].getId());\n+        bkc.deleteLedger(lhs[1].getId());\n+        LOG.info(\"Finished deleting the ledgers contains less entries.\");\n+        Thread.sleep(baseConf.getMajorCompactionInterval() * 1000\n+                   + baseConf.getGcWaitTime());\n+\n+        // entry logs ([0,1,2].log) should not be compacted\n+        for (File ledgerDirectory : tmpDirs) {\n+            boolean[] hasLogFiles = checkLogFiles(ledgerDirectory, 3); \n+            assertTrue(\"Not Found entry log file ([1,2].log that should have been compacted in ledgerDirectory: \"\n+                     + ledgerDirectory, hasLogFiles[0] & hasLogFiles[1] & hasLogFiles[2]);\n+        }\n+    }\n+\n+    @Test\n+    public void testCompactionSmallEntryLogs() throws Exception {\n+\n+        // create a ledger to write a few entries\n+        LedgerHandle alh = bkc.createLedger(NUM_BOOKIES, NUM_BOOKIES, digestType, \"\".getBytes());\n+        for (int i=0; i<3; i++) {\n+           alh.addEntry(msg.getBytes());\n+        }\n+        alh.close();\n+\n+        // restart bookie to roll entry log files\n+        restartBookies();\n+\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // remove ledger2 and ledger3\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+        Thread.sleep(baseConf.getMajorCompactionInterval() * 1000\n+                   + baseConf.getGcWaitTime());\n+\n+        // entry logs (0.log) should not be compacted\n+        // entry logs ([1,2,3].log) should be compacted.\n+        for (File ledgerDirectory : tmpDirs) {\n+            boolean[] hasLog = checkLogFiles(ledgerDirectory, 4);\n+            \n+            assertTrue(\"Not Found entry log file ([0].log that should have been compacted in ledgerDirectory: \"\n+                     + ledgerDirectory, hasLog[0]);\n+            assertFalse(\"Found entry log file ([1,2,3].log that should have not been compacted in ledgerDirectory: \"\n+                      + ledgerDirectory, hasLog[1] | hasLog[2] | hasLog[3]);\n+        }\n+\n+        // even entry log files are removed, we still can access entries for ledger1\n+        // since those entries has been compacted to new entry log\n+        verifyLedger(lhs[0].getId(), 0, lhs[0].getLastAddConfirmed());\n+    }\n+}"},{"sha":"615d48e0fe0b6fb657297d260725d172108e3cc7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","status":"added","additions":321,"deletions":0,"changes":321,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CookieTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,321 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.test.ZooKeeperUtil;\n+import org.apache.zookeeper.ZooKeeper;\n+\n+import java.io.FileOutputStream;\n+import java.io.BufferedWriter;\n+import java.io.OutputStreamWriter;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.junit.After;\n+import org.junit.Before;\n+import static org.junit.Assert.*;\n+\n+import static org.apache.bookkeeper.bookie.UpgradeTest.*;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CookieTest {\n+    ZooKeeperUtil zkutil;\n+    ZooKeeper zkc = null;\n+\n+    @Before\n+    public void setupZooKeeper() throws Exception {\n+        zkutil = new ZooKeeperUtil();\n+        zkutil.startServer();\n+        zkc = zkutil.getZooKeeperClient();\n+    }\n+\n+    @After\n+    public void tearDownZooKeeper() throws Exception {\n+        zkutil.killServer();\n+    }\n+\n+    private static String newDirectory() throws IOException {\n+        return newDirectory(true);\n+    }\n+\n+    private static String newDirectory(boolean createCurDir) throws IOException {\n+        File d = File.createTempFile(\"bookie\", \"tmpdir\");\n+        d.delete();\n+        d.mkdirs();\n+        if (createCurDir) {\n+            new File(d, \"current\").mkdirs();\n+        }\n+        return d.getPath();\n+    }\n+\n+    /**\n+     * Test starting bookie with clean state.\n+     */\n+    @Test\n+    public void testCleanStart() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newDirectory(false))\n+            .setLedgerDirNames(new String[] { newDirectory(false) })\n+            .setBookiePort(3181);\n+        try {\n+            Bookie b = new Bookie(conf);\n+        } catch (Exception e) {\n+            fail(\"Should not reach here.\");\n+        }\n+    }\n+\n+    /**\n+     * Test that if a zookeeper cookie\n+     * is different to a local cookie, the bookie\n+     * will fail to start\n+     */\n+    @Test\n+    public void testBadJournalCookie() throws Exception {\n+        ServerConfiguration conf1 = new ServerConfiguration()\n+            .setJournalDirName(newDirectory())\n+            .setLedgerDirNames(new String[] { newDirectory() })\n+            .setBookiePort(3181);\n+        Cookie c = Cookie.generateCookie(conf1);\n+        c.writeToZooKeeper(zkc, conf1);\n+\n+        String journalDir = newDirectory();\n+        String ledgerDir = newDirectory();\n+        ServerConfiguration conf2 = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(journalDir)\n+            .setLedgerDirNames(new String[] { ledgerDir })\n+            .setBookiePort(3181);\n+        Cookie c2 = Cookie.generateCookie(conf2);\n+        c2.writeToDirectory(new File(journalDir, \"current\"));\n+        c2.writeToDirectory(new File(ledgerDir, \"current\"));\n+\n+        try {\n+            Bookie b = new Bookie(conf2);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if a directory is removed from\n+     * the configuration, the bookie will fail to\n+     * start\n+     */\n+    @Test\n+    public void testDirectoryMissing() throws Exception {\n+        String[] ledgerDirs = new String[] {\n+            newDirectory(), newDirectory(), newDirectory() };\n+        String journalDir = newDirectory();\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(journalDir)\n+            .setLedgerDirNames(ledgerDirs)\n+            .setBookiePort(3181);\n+\n+        Bookie b = new Bookie(conf); // should work fine\n+        b.start();\n+        b.shutdown();\n+\n+        conf.setLedgerDirNames(new String[] { ledgerDirs[0], ledgerDirs[1] });\n+        try {\n+            Bookie b2 = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+\n+        conf.setJournalDirName(newDirectory()).setLedgerDirNames(ledgerDirs);\n+        try {\n+            Bookie b2 = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+\n+        conf.setJournalDirName(journalDir);\n+        b = new Bookie(conf);\n+        b.start();\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if a directory is added to a\n+     * preexisting bookie, the bookie will fail\n+     * to start\n+     */\n+    @Test\n+    public void testDirectoryAdded() throws Exception {\n+        String ledgerDir0 = newDirectory();\n+        String journalDir = newDirectory();\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(journalDir)\n+            .setLedgerDirNames(new String[] { ledgerDir0 })\n+            .setBookiePort(3181);\n+\n+        Bookie b = new Bookie(conf); // should work fine\n+        b.start();\n+        b.shutdown();\n+\n+        conf.setLedgerDirNames(new String[] { ledgerDir0, newDirectory() });\n+        try {\n+            Bookie b2 = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+\n+        conf.setLedgerDirNames(new String[] { ledgerDir0 });\n+        b = new Bookie(conf);\n+        b.start();\n+        b.shutdown();\n+    }\n+\n+    /**\n+     * Test that if a directory's contents\n+     * are emptied, the bookie will fail to start\n+     */\n+    @Test\n+    public void testDirectoryCleared() throws Exception {\n+        String ledgerDir0 = newDirectory();\n+        String journalDir = newDirectory();\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(journalDir)\n+            .setLedgerDirNames(new String[] { ledgerDir0 , newDirectory() })\n+            .setBookiePort(3181);\n+\n+        Bookie b = new Bookie(conf); // should work fine\n+        b.start();\n+        b.shutdown();\n+\n+        FileUtils.deleteDirectory(new File(ledgerDir0));\n+        try {\n+            Bookie b2 = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if a bookie's port is changed\n+     * the bookie will fail to start\n+     */\n+    @Test\n+    public void testBookiePortChanged() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newDirectory())\n+            .setLedgerDirNames(new String[] { newDirectory() , newDirectory() })\n+            .setBookiePort(3181);\n+        Bookie b = new Bookie(conf); // should work fine\n+        b.start();\n+        b.shutdown();\n+\n+        conf.setBookiePort(3182);\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if a bookie tries to start\n+     * with the address of a bookie which has already\n+     * existed in the system, then the bookie will fail\n+     * to start\n+     */\n+    @Test\n+    public void testNewBookieStartingWithAnotherBookiesPort() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newDirectory())\n+            .setLedgerDirNames(new String[] { newDirectory() , newDirectory() })\n+            .setBookiePort(3181);\n+        Bookie b = new Bookie(conf); // should work fine\n+        b.start();\n+        b.shutdown();\n+\n+        conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newDirectory())\n+            .setLedgerDirNames(new String[] { newDirectory() , newDirectory() })\n+            .setBookiePort(3181);\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+        }\n+    }\n+\n+    /**\n+     * Test that if a bookie is started with directories with\n+     * version 2 data, that it will fail to start (it needs upgrade)\n+     */\n+    @Test\n+    public void testV2data() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newV2JournalDirectory())\n+            .setLedgerDirNames(new String[] { newV2LedgerDirectory() })\n+            .setBookiePort(3181);\n+        try {\n+            Bookie b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+            assertTrue(\"wrong exception\", ice.getCause().getMessage().contains(\"upgrade needed\"));\n+        }\n+    }\n+\n+    /**\n+     * Test that if a bookie is started with directories with\n+     * version 1 data, that it will fail to start (it needs upgrade)\n+     */\n+    @Test\n+    public void testV1data() throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkutil.getZooKeeperConnectString())\n+            .setJournalDirName(newV1JournalDirectory())\n+            .setLedgerDirNames(new String[] { newV1LedgerDirectory() })\n+            .setBookiePort(3181);\n+        try {\n+            Bookie b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException ice) {\n+            // correct behaviour\n+            assertTrue(\"wrong exception\", ice.getCause().getMessage().contains(\"upgrade needed\"));\n+        }\n+    }\n+}"},{"sha":"3d598573189d6d384d9d733231085a77d05dd60d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"modified","additions":109,"deletions":16,"changes":125,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,14 +21,15 @@\n package org.apache.bookkeeper.bookie;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.RandomAccessFile;\n-import java.lang.reflect.Field;\n import java.nio.ByteBuffer;\n-import java.util.Map;\n \n import junit.framework.TestCase;\n \n+import org.apache.bookkeeper.bookie.GarbageCollectorThread.EntryLogMetadata;\n+import org.apache.bookkeeper.bookie.GarbageCollectorThread.ExtractionScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.junit.After;\n import org.junit.Before;\n@@ -45,44 +46,136 @@ public void setUp() throws Exception {\n     }\n \n     @Test\n-    public void testCorruptEntryLog() throws IOException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {\n+    public void testCorruptEntryLog() throws Exception {\n         File tmpDir = File.createTempFile(\"bkTest\", \".dir\");\n         tmpDir.delete();\n         tmpDir.mkdir();\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        int gcWaitTime = 1000;\n         ServerConfiguration conf = new ServerConfiguration();\n+        conf.setGcWaitTime(gcWaitTime);\n         conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n         // create some entries\n-        EntryLogger logger = new EntryLogger(conf, null);\n+        EntryLogger logger = new EntryLogger(conf);\n         logger.addEntry(1, generateEntry(1, 1));\n         logger.addEntry(3, generateEntry(3, 1));\n         logger.addEntry(2, generateEntry(2, 1));\n         logger.flush();\n         // now lets truncate the file to corrupt the last entry, which simulates a partial write\n-        File f = new File(tmpDir, \"0.log\");\n+        File f = new File(curDir, \"0.log\");\n         RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n         raf.setLength(raf.length()-10);\n         raf.close();\n         // now see which ledgers are in the log\n-        logger = new EntryLogger(conf, null);\n-        Field entryLogs2LedgersMapField = logger.getClass().getDeclaredField(\"entryLogs2LedgersMap\");\n-        entryLogs2LedgersMapField.setAccessible(true);\n-        @SuppressWarnings(\"unchecked\")\n-        Map<Long, Map<Long, Boolean>> ledgersMap = (Map<Long, Map<Long, Boolean>>) entryLogs2LedgersMapField.get(logger);\n-        LOG.info(\"LedgersMap.get(0) {}\", ledgersMap.get(0L));\n-        assertNotNull(ledgersMap.get(0L).get(1L));\n-        assertNull(ledgersMap.get(0L).get(2L));\n-        assertNotNull(ledgersMap.get(0L).get(3L));\n+        logger = new EntryLogger(conf);\n+\n+        EntryLogMetadata meta = new EntryLogMetadata(0L);\n+        ExtractionScanner scanner = new ExtractionScanner(meta);\n+\n+        try {\n+            logger.scanEntryLog(0L, scanner);\n+            fail(\"Should not reach here!\");\n+        } catch (IOException ie) {\n+        }\n+\n+        LOG.info(\"Extracted Meta From Entry Log {}\", meta);\n+        assertNotNull(meta.ledgersMap.get(1L));\n+        assertNull(meta.ledgersMap.get(2L));\n+        assertNotNull(meta.ledgersMap.get(3L));\n     }\n \n     private ByteBuffer generateEntry(long ledger, long entry) {\n         ByteBuffer bb = ByteBuffer.wrap(new byte[64]);\n         bb.putLong(ledger);\n         bb.putLong(entry);\n-        bb.put((\"ledger\"+ledger).getBytes());\n+        bb.put((\"ledger-\" + ledger + \"-\" + entry).getBytes());\n         bb.flip();\n         return bb;\n     }\n-    \n+\n+    @Test\n+    public void testMissingLogId() throws Exception {\n+        File tmpDir = File.createTempFile(\"entryLogTest\", \".dir\");\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        ServerConfiguration conf = new ServerConfiguration();\n+        conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n+        // create some entries\n+        int numLogs = 3;\n+        int numEntries = 10;\n+        long[][] positions = new long[2*numLogs][];\n+        for (int i=0; i<numLogs; i++) {\n+            positions[i] = new long[numEntries];\n+\n+            EntryLogger logger = new EntryLogger(conf);\n+            for (int j=0; j<numEntries; j++) {\n+                positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n+            }\n+            logger.flush();\n+        }\n+        // delete last log id\n+        File lastLogId = new File(curDir, \"lastId\");\n+        lastLogId.delete();\n+\n+        // write another entries\n+        for (int i=numLogs; i<2*numLogs; i++) {\n+            positions[i] = new long[numEntries];\n+\n+            EntryLogger logger = new EntryLogger(conf);\n+            for (int j=0; j<numEntries; j++) {\n+                positions[i][j] = logger.addEntry(i, generateEntry(i, j));\n+            }\n+            logger.flush();\n+        }\n+\n+        EntryLogger newLogger = new EntryLogger(conf);\n+        for (int i=0; i<(2*numLogs+1); i++) {\n+            File logFile = new File(curDir, Long.toHexString(i) + \".log\");\n+            assertTrue(logFile.exists());\n+        }\n+        for (int i=0; i<2*numLogs; i++) {\n+            for (int j=0; j<numEntries; j++) {\n+                String expectedValue = \"ledger-\" + i + \"-\" + j;\n+                byte[] value = newLogger.readEntry(i, j, positions[i][j]);\n+                ByteBuffer buf = ByteBuffer.wrap(value);\n+                long ledgerId = buf.getLong();\n+                long entryId = buf.getLong();\n+                byte[] data = new byte[buf.remaining()];\n+                buf.get(data);\n+                assertEquals(i, ledgerId);\n+                assertEquals(j, entryId);\n+                assertEquals(expectedValue, new String(data));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    /** Test that EntryLogger Should fail with FNFE, if entry logger directories does not exist*/\n+    public void testEntryLoggerShouldThrowFNFEIfDirectoriesDoesNotExist()\n+            throws Exception {\n+        File tmpDir = File.createTempFile(\"bkTest\", \".dir\");\n+        tmpDir.delete();\n+        ServerConfiguration conf = new ServerConfiguration();\n+        conf.setLedgerDirNames(new String[] { tmpDir.toString() });\n+        EntryLogger entryLogger = null;\n+        try {\n+            entryLogger = new EntryLogger(conf);\n+            fail(\"Expecting FileNotFoundException\");\n+        } catch (FileNotFoundException e) {\n+            assertEquals(\"Entry log directory does not exist\", e\n+                    .getLocalizedMessage());\n+        } finally {\n+            if (entryLogger != null) {\n+                entryLogger.shutdown();\n+            }\n+        }\n+    }\n+\n     @After\n     public void tearDown() throws Exception {\n     }"},{"sha":"3720bb886dbff1baf433ab8ff0320dde7c182dc1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"added","additions":210,"deletions":0,"changes":210,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,210 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * LedgerCache related test cases\n+ */\n+public class LedgerCacheTest extends TestCase {\n+    static Logger LOG = LoggerFactory.getLogger(LedgerCacheTest.class);\n+\n+    LedgerManager ledgerManager;\n+    LedgerCache ledgerCache;\n+    ServerConfiguration conf;\n+    File txnDir, ledgerDir;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        txnDir = File.createTempFile(\"ledgercache\", \"txn\");\n+        txnDir.delete();\n+        txnDir.mkdir();\n+        ledgerDir = File.createTempFile(\"ledgercache\", \"ledger\");\n+        ledgerDir.delete();\n+        ledgerDir.mkdir();\n+        // create current dir\n+        new File(ledgerDir, Bookie.CURRENT_DIR).mkdir();\n+\n+        conf = new ServerConfiguration();\n+        conf.setZkServers(null);\n+        conf.setJournalDirName(txnDir.getPath());\n+        conf.setLedgerDirNames(new String[] { ledgerDir.getPath() });\n+\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(conf, null);\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        ledgerManager.close();\n+        FileUtils.deleteDirectory(txnDir);\n+        FileUtils.deleteDirectory(ledgerDir);\n+    }\n+\n+    private void newLedgerCache() {\n+        ledgerCache = new LedgerCacheImpl(conf, ledgerManager);\n+    }\n+\n+    @Test\n+    public void testAddEntryException() {\n+        // set page limitation\n+        conf.setPageLimit(10);\n+        // create a ledger cache\n+        newLedgerCache();\n+        /*\n+         * Populate ledger cache.\n+         */\n+        try {\n+            byte[] masterKey = \"blah\".getBytes();\n+            for( int i = 0; i < 100; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                ledgerCache.putEntryOffset(i, 0, i*8);\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Got IOException.\", e);\n+            fail(\"Failed to add entry.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testLedgerEviction() throws Exception {\n+        int numEntries = 10;\n+        // limit open files & pages\n+        conf.setOpenFileLimit(1).setPageLimit(2)\n+            .setPageSize(8 * numEntries);\n+        // create ledger cache\n+        newLedgerCache();\n+        try {\n+            int numLedgers = 3;\n+            byte[] masterKey = \"blah\".getBytes();\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                for (int j=0; j<numEntries; j++) {\n+                    ledgerCache.putEntryOffset(i, j, i * numEntries + j);\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Got Exception.\", e);\n+            fail(\"Failed to add entry.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testDeleteLedger() throws Exception {\n+        int numEntries = 10;\n+        // limit open files & pages\n+        conf.setOpenFileLimit(999).setPageLimit(2)\n+            .setPageSize(8 * numEntries);\n+        // create ledger cache\n+        newLedgerCache();\n+        try {\n+            int numLedgers = 2;\n+            byte[] masterKey = \"blah\".getBytes();\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                for (int j=0; j<numEntries; j++) {\n+                    ledgerCache.putEntryOffset(i, j, i*numEntries + j);\n+                }\n+            }\n+            // ledger cache is exhausted\n+            // delete ledgers\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.deleteLedger((long)i);\n+            }\n+            // create num ledgers to add entries\n+            for (int i=numLedgers+1; i<=2*numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                for (int j=0; j<numEntries; j++) {\n+                    ledgerCache.putEntryOffset(i, j, i*numEntries + j);\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Got Exception.\", e);\n+            fail(\"Failed to add entry.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPageEviction() throws Exception {\n+        int numLedgers = 10;\n+        byte[] masterKey = \"blah\".getBytes();\n+        // limit page count\n+        conf.setOpenFileLimit(999999).setPageLimit(3);\n+        // create ledger cache\n+        newLedgerCache();\n+        try {\n+            // create serveral ledgers\n+            for (int i=1; i<=numLedgers; i++) {\n+                ledgerCache.setMasterKey((long)i, masterKey);\n+                ledgerCache.putEntryOffset(i, 0, i*8);\n+                ledgerCache.putEntryOffset(i, 1, i*8);\n+            }\n+\n+            // flush all first to clean previous dirty ledgers\n+            ledgerCache.flushLedger(true);\n+            // flush all \n+            ledgerCache.flushLedger(true);\n+\n+            // delete serveral ledgers\n+            for (int i=1; i<=numLedgers/2; i++) {\n+                ledgerCache.deleteLedger(i);\n+            }\n+\n+            // bookie restarts\n+            newLedgerCache();\n+\n+            // simulate replaying journals to add entries again\n+            for (int i=1; i<=numLedgers; i++) {\n+                try {\n+                    ledgerCache.putEntryOffset(i, 1, i*8);\n+                } catch (NoLedgerException nsle) {\n+                    if (i<=numLedgers/2) {\n+                        // it is ok\n+                    } else {\n+                        LOG.error(\"Error put entry offset : \", nsle);\n+                        fail(\"Should not reach here.\");\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Got Exception.\", e);\n+            fail(\"Failed to add entry.\");\n+        }\n+    }\n+}"},{"sha":"2e35f452289a8c7ad24d57b50641204f5a279c3b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","status":"added","additions":249,"deletions":0,"changes":249,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,249 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.Arrays;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import java.io.FileOutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.BufferedWriter;\n+import java.io.PrintStream;\n+import java.io.RandomAccessFile;\n+\n+import org.junit.Before;\n+import org.junit.After;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import org.apache.bookkeeper.client.ClientUtil;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.bookkeeper.test.ZooKeeperUtil;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UpgradeTest {\n+    static Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n+\n+    ZooKeeperUtil zkutil;\n+    ZooKeeper zkc = null;\n+\n+    @Before\n+    public void setupZooKeeper() throws Exception {\n+        zkutil = new ZooKeeperUtil();\n+        zkutil.startServer();\n+        zkc = zkutil.getZooKeeperClient();\n+    }\n+\n+    @After\n+    public void tearDownZooKeeper() throws Exception {\n+        zkutil.killServer();\n+    }\n+\n+    static void writeLedgerDir(File dir,\n+                               byte[] masterKey)\n+            throws Exception {\n+        long ledgerId = 1;\n+\n+        File fn = new File(dir, LedgerCacheImpl.getLedgerName(ledgerId));\n+        fn.getParentFile().mkdirs();\n+        FileInfo fi = new FileInfo(fn, masterKey);\n+        // force creation of index file\n+        fi.write(new ByteBuffer[]{ ByteBuffer.allocate(0) }, 0);\n+        fi.close(true);\n+\n+        long logId = 0;\n+        ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(1024);\n+        LOGFILE_HEADER.put(\"BKLO\".getBytes());\n+        FileChannel logfile = new RandomAccessFile(\n+                new File(dir, Long.toHexString(logId)+\".log\"), \"rw\").getChannel();\n+        logfile.write((ByteBuffer) LOGFILE_HEADER.clear());\n+        logfile.close();\n+    }\n+\n+    static JournalChannel writeJournal(File journalDir, int numEntries, byte[] masterKey)\n+            throws Exception {\n+        long logId = System.currentTimeMillis();\n+        JournalChannel jc = new JournalChannel(journalDir, logId);\n+\n+        BufferedChannel bc = jc.getBufferedChannel();\n+\n+        long ledgerId = 1;\n+        byte[] data = new byte[1024];\n+        Arrays.fill(data, (byte)'X');\n+        long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n+\n+        for (int i = 1; i <= numEntries; i++) {\n+            ByteBuffer packet = ClientUtil.generatePacket(ledgerId, i, lastConfirmed,\n+                                                          i*data.length, data).toByteBuffer();\n+            lastConfirmed = i;\n+            ByteBuffer lenBuff = ByteBuffer.allocate(4);\n+            lenBuff.putInt(packet.remaining());\n+            lenBuff.flip();\n+\n+            bc.write(lenBuff);\n+            bc.write(packet);\n+        }\n+        bc.flush(true);\n+\n+        return jc;\n+    }\n+\n+    static String newV1JournalDirectory() throws Exception {\n+        File d = File.createTempFile(\"bookie\", \"tmpdir\");\n+        d.delete();\n+        d.mkdirs();\n+        writeJournal(d, 100, \"foobar\".getBytes()).close();\n+        return d.getPath();\n+    }\n+\n+    static String newV1LedgerDirectory() throws Exception {\n+        File d = File.createTempFile(\"bookie\", \"tmpdir\");\n+        d.delete();\n+        d.mkdirs();\n+        writeLedgerDir(d, \"foobar\".getBytes());\n+        return d.getPath();\n+    }\n+\n+    static void createVersion2File(String dir) throws Exception {\n+        File versionFile = new File(dir, \"VERSION\");\n+\n+        FileOutputStream fos = new FileOutputStream(versionFile);\n+        BufferedWriter bw = null;\n+        try {\n+            bw = new BufferedWriter(new OutputStreamWriter(fos));\n+            bw.write(String.valueOf(2));\n+        } finally {\n+            if (bw != null) {\n+                bw.close();\n+            }\n+            fos.close();\n+        }\n+    }\n+\n+    static String newV2JournalDirectory() throws Exception {\n+        String d = newV1JournalDirectory();\n+        createVersion2File(d);\n+        return d;\n+    }\n+\n+    static String newV2LedgerDirectory() throws Exception {\n+        String d = newV1LedgerDirectory();\n+        createVersion2File(d);\n+        return d;\n+    }\n+\n+    private static void testUpgradeProceedure(String zkServers, String journalDir, String ledgerDir) throws Exception {\n+        ServerConfiguration conf = new ServerConfiguration()\n+            .setZkServers(zkServers)\n+            .setJournalDirName(journalDir)\n+            .setLedgerDirNames(new String[] { ledgerDir })\n+            .setBookiePort(3181);\n+        Bookie b = null;\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException e) {\n+            // correct behaviour\n+            assertTrue(\"wrong exception\", e.getMessage().contains(\"upgrade needed\"));\n+        }\n+\n+        FileSystemUpgrade.upgrade(conf); // should work fine\n+        b = new Bookie(conf);\n+        b.start();\n+        b.shutdown();\n+        b = null;\n+\n+        FileSystemUpgrade.rollback(conf);\n+        try {\n+            b = new Bookie(conf);\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (BookieException.InvalidCookieException e) {\n+            // correct behaviour\n+            assertTrue(\"wrong exception\", e.getMessage().contains(\"upgrade needed\"));\n+        }\n+\n+        FileSystemUpgrade.upgrade(conf);\n+        FileSystemUpgrade.finalizeUpgrade(conf);\n+        b = new Bookie(conf);\n+        b.start();\n+        b.shutdown();\n+        b = null;\n+    }\n+\n+    @Test\n+    public void testUpgradeV1toCurrent() throws Exception {\n+        String journalDir = newV1JournalDirectory();\n+        String ledgerDir = newV1LedgerDirectory();\n+        testUpgradeProceedure(zkutil.getZooKeeperConnectString(), journalDir, ledgerDir);\n+    }\n+\n+    @Test\n+    public void testUpgradeV2toCurrent() throws Exception {\n+        String journalDir = newV2JournalDirectory();\n+        String ledgerDir = newV2LedgerDirectory();\n+        testUpgradeProceedure(zkutil.getZooKeeperConnectString(), journalDir, ledgerDir);\n+    }\n+\n+    @Test\n+    public void testCommandLine() throws Exception {\n+        PrintStream origerr = System.err;\n+        PrintStream origout = System.out;\n+\n+        File output = File.createTempFile(\"bookie\", \"stdout\");\n+        File erroutput = File.createTempFile(\"bookie\", \"stderr\");\n+        System.setOut(new PrintStream(output));\n+        System.setErr(new PrintStream(erroutput));\n+        try {\n+            FileSystemUpgrade.main(new String[] { \"-h\" });\n+            try {\n+                // test without conf\n+                FileSystemUpgrade.main(new String[] { \"-u\" });\n+                fail(\"Should have failed\");\n+            } catch (IllegalArgumentException iae) {\n+                assertTrue(\"Wrong exception \" + iae.getMessage(),\n+                           iae.getMessage().contains(\"without configuration\"));\n+            }\n+            File f = File.createTempFile(\"bookie\", \"tmpconf\");\n+            try {\n+                // test without upgrade op\n+                FileSystemUpgrade.main(new String[] { \"--conf\", f.getPath() });\n+                fail(\"Should have failed\");\n+            } catch (IllegalArgumentException iae) {\n+                assertTrue(\"Wrong exception \" + iae.getMessage(),\n+                           iae.getMessage().contains(\"Must specify -upgrade\"));\n+            }\n+        } finally {\n+            System.setOut(origout);\n+            System.setErr(origerr);\n+        }\n+    }\n+}"},{"sha":"1f46e1cf2e2e0d6926c15c24aaa8f51f856a0813","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,88 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+*/\n+\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.KeeperException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests of the main BookKeeper client\n+ */\n+public class BookKeeperTest extends BookKeeperClusterTestCase {\n+    public BookKeeperTest() {\n+        super(4);\n+    }\n+\n+    @Test\n+    public void testConstructionZkDelay() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setZkTimeout(20000);\n+\n+        CountDownLatch l = new CountDownLatch(1);\n+        zkUtil.sleepServer(5, l);\n+        l.await();\n+\n+        BookKeeper bkc = new BookKeeper(conf);\n+        bkc.createLedger(DigestType.CRC32, \"testPasswd\".getBytes()).close();\n+        bkc.close();\n+    }\n+\n+    @Test\n+    public void testConstructionNotConnectedExplicitZk() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setZkTimeout(20000);\n+\n+        CountDownLatch l = new CountDownLatch(1);\n+        zkUtil.sleepServer(5, l);\n+        l.await();\n+\n+        ZooKeeper zk = new ZooKeeper(zkUtil.getZooKeeperConnectString(), 10000,\n+                            new Watcher() {\n+                                @Override\n+                                public void process(WatchedEvent event) {\n+                                }\n+                            });\n+        assertFalse(\"ZK shouldn't have connected yet\", zk.getState().isConnected());\n+        try {\n+            BookKeeper bkc = new BookKeeper(conf, zk);\n+            fail(\"Shouldn't be able to construct with unconnected zk\");\n+        } catch (KeeperException.ConnectionLossException cle) {\n+            // correct behaviour\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"8bd3f6b94aa7e4f1ac40001e538e68e7571023b0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":160,"deletions":43,"changes":203,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -33,6 +33,7 @@\n import java.util.HashMap;\n import java.util.Collections;\n import java.util.Random;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.jboss.netty.buffer.ChannelBuffer;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -41,6 +42,7 @@\n import org.apache.bookkeeper.test.BaseTestCase;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -50,6 +52,7 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -113,7 +116,7 @@ public void setUp() throws Exception {\n         sync = new SyncObject();\n         bookieRecoverCb = new BookieRecoverCallback();\n         ClientConfiguration adminConf = new ClientConfiguration(baseClientConf);\n-        adminConf.setZkServers(HOSTPORT);\n+        adminConf.setZkServers(zkUtil.getZooKeeperConnectString());\n         bkAdmin = new BookKeeperAdmin(adminConf);\n     }\n \n@@ -158,6 +161,15 @@ public void tearDown() throws Exception {\n         return lhs;\n     }\n \n+    private List<LedgerHandle> openLedgers(List<LedgerHandle> oldLhs)\n+            throws Exception {\n+        List<LedgerHandle> newLhs = new ArrayList<LedgerHandle>();\n+        for (LedgerHandle oldLh : oldLhs) {\n+            newLhs.add(bkc.openLedger(oldLh.getId(), digestType, baseClientConf.getBookieRecoveryPasswd()));\n+        }\n+        return newLhs;\n+    }\n+\n     /**\n      * Helper method to write dummy ledger entries to all of the ledgers passed.\n      *\n@@ -170,42 +182,20 @@ public void tearDown() throws Exception {\n      * @throws BKException\n      * @throws InterruptedException\n      */\n-    private void writeEntriestoLedgers(int numEntries, long startEntryId, List<LedgerHandle> lhs) throws BKException,\n-        InterruptedException {\n+    private void writeEntriestoLedgers(int numEntries, long startEntryId,\n+                                       List<LedgerHandle> lhs)\n+        throws BKException, InterruptedException {\n         for (LedgerHandle lh : lhs) {\n             for (int i = 0; i < numEntries; i++) {\n                 lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (startEntryId + i)).getBytes());\n             }\n         }\n     }\n \n-    /**\n-     * Helper method to startup a new bookie server with the indicated port\n-     * number\n-     *\n-     * @param port\n-     *            Port to start the new bookie server on\n-     * @throws IOException\n-     */\n-    private void startNewBookie(int port)\n-            throws IOException, InterruptedException, KeeperException {\n-        File f = File.createTempFile(\"bookie\", \"test\");\n-        tmpDirs.add(f);\n-        f.delete();\n-        f.mkdir();\n-\n-        ServerConfiguration conf = newServerConfiguration(port, HOSTPORT, f, new File[] { f });\n-\n-        BookieServer server = new BookieServer(conf);\n-        server.start();\n-        bs.add(server);\n-\n-        while(bkc.getZkHandle().exists(\"/ledgers/available/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + port, false) == null) {\n-            Thread.sleep(500);\n+    private void closeLedgers(List<LedgerHandle> lhs) throws BKException, InterruptedException {\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n         }\n-\n-        bkc.readBookiesBlocking();\n-        LOG.info(\"New bookie on port \" + port + \" has been created.\");\n     }\n \n     /**\n@@ -265,8 +255,7 @@ public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {\n         bs.remove(0);\n \n         // Startup a new bookie server\n-        int newBookiePort = initialPort + numBookies;\n-        startNewBookie(newBookiePort);\n+        int newBookiePort = startNewBookie();\n \n         // Write some more entries for the ledgers so a new ensemble will be\n         // created for them.\n@@ -320,8 +309,7 @@ public void testAsyncBookieRecoveryToRandomBookies() throws Exception {\n \n         // Startup three new bookie servers\n         for (int i = 0; i < 3; i++) {\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n         }\n \n         // Write some more entries for the ledgers so a new ensemble will be\n@@ -374,8 +362,7 @@ public void testSyncBookieRecoveryToSpecificBookie() throws Exception {\n         bs.remove(0);\n \n         // Startup a new bookie server\n-        int newBookiePort = initialPort + numBookies;\n-        startNewBookie(newBookiePort);\n+        int newBookiePort = startNewBookie();\n \n         // Write some more entries for the ledgers so a new ensemble will be\n         // created for them.\n@@ -419,8 +406,7 @@ public void testSyncBookieRecoveryToRandomBookies() throws Exception {\n \n         // Startup three new bookie servers\n         for (int i = 0; i < 3; i++) {\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n         }\n \n         // Write some more entries for the ledgers so a new ensemble will be\n@@ -496,7 +482,7 @@ private boolean verifyFullyReplicated(LedgerHandle lh, long untilEntry) throws E\n             ReplicationVerificationCallback cb = new ReplicationVerificationCallback(numRequests);\n             for (long i = startEntryId; i < endEntryId; i++) {\n                 for (InetSocketAddress addr : e.getValue()) {\n-                    bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr, BookieProtocol.FLAG_NONE);\n+                    bkc.bookieClient.readEntry(addr, lh.getId(), i, cb, addr);\n                 }\n             }\n \n@@ -539,6 +525,140 @@ private boolean findDupesInEnsembles(List<LedgerHandle> lhs) throws Exception {\n         return numDupes > 0;\n     }\n \n+    /**\n+     * Test recoverying the closed ledgers when the failed bookie server is in the last ensemble\n+     */\n+    @Test\n+    public void testBookieRecoveryOnClosedLedgers() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        closeLedgers(lhs);\n+\n+        // Shutdown last bookie server in last ensemble\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        killBookie(bookieToKill);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n+               + \") and replicate it to a random available one\");\n+\n+        bkAdmin.recoverBookieData(bookieToKill, bookieDest);\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+            lh.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testBookieRecoveryOnOpenedLedgers() throws Exception {\n+        // Create the ledgers\n+        int numLedgers = 3;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, numBookies, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        int numMsgs = 10;\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        InetSocketAddress bookieToKill = lastEnsemble.get(lastEnsemble.size() - 1);\n+        killBookie(bookieToKill);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        InetSocketAddress bookieDest = null;\n+        LOG.info(\"Now recover the data on the killed bookie (\" + bookieToKill\n+               + \") and replicate it to a random available one\");\n+\n+        bkAdmin.recoverBookieData(bookieToKill, bookieDest);\n+\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+        }\n+\n+        try {\n+            // we can't write entries\n+            writeEntriestoLedgers(numMsgs, 0, lhs);\n+            fail(\"should not reach here\");\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testBookieRecoveryOnInRecoveryLedger() throws Exception {\n+        int numMsgs = 10;\n+        // Create the ledgers\n+        int numLedgers = 1;\n+        List<LedgerHandle> lhs = createLedgers(numLedgers, 2, 2);\n+\n+        // Write the entries for the ledgers with dummy values\n+        writeEntriestoLedgers(numMsgs, 0, lhs);\n+\n+        // Shutdown the first bookie server\n+        ArrayList<InetSocketAddress> lastEnsemble = lhs.get(0).getLedgerMetadata().getEnsembles()\n+                                                       .entrySet().iterator().next().getValue();\n+        // removed bookie\n+        InetSocketAddress bookieToKill = lastEnsemble.get(0);\n+        killBookie(bookieToKill);\n+        // temp failure\n+        InetSocketAddress bookieToKill2 = lastEnsemble.get(1);\n+        ServerConfiguration conf2 = killBookie(bookieToKill2);\n+\n+        // start a new bookie\n+        startNewBookie();\n+\n+        // open these ledgers\n+        for (LedgerHandle oldLh : lhs) {\n+            try {\n+                bkc.openLedger(oldLh.getId(), digestType, baseClientConf.getBookieRecoveryPasswd());\n+                fail(\"Should have thrown exception\");\n+            } catch (Exception e) {\n+            }\n+        }\n+\n+        try {\n+            bkAdmin.recoverBookieData(bookieToKill, null);\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKLedgerRecoveryException bke) {\n+            // correct behaviour\n+        }\n+\n+        // restart failed bookie\n+        bs.add(startBookie(conf2));\n+        bsConfs.add(conf2);\n+\n+        // recover them\n+        bkAdmin.recoverBookieData(bookieToKill, null);\n+\n+        for (LedgerHandle lh : lhs) {\n+            assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs));\n+        }\n+\n+        // open ledgers to read metadata\n+        List<LedgerHandle> newLhs = openLedgers(lhs);\n+        for (LedgerHandle newLh : newLhs) {\n+            // first ensemble should contains bookieToKill2 and not contain bookieToKill\n+            Map.Entry<Long, ArrayList<InetSocketAddress>> entry =\n+                newLh.getLedgerMetadata().getEnsembles().entrySet().iterator().next();\n+            assertFalse(entry.getValue().contains(bookieToKill));\n+            assertTrue(entry.getValue().contains(bookieToKill2));\n+        }\n+\n+    }\n+\n     @Test\n     public void testAsyncBookieRecoveryToRandomBookiesNotEnoughBookies() throws Exception {\n         // Create the ledgers\n@@ -589,8 +709,7 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             bs.remove(removeIndex);\n             \n             // Startup three new bookie servers\n-            int newBookiePort = initialPort + numBookies + i;\n-            startNewBookie(newBookiePort);\n+            startNewBookie();\n             \n             // Write some more entries for the ledgers so a new ensemble will be\n             // created for them.\n@@ -608,9 +727,7 @@ public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exceptio\n             writeEntriestoLedgers(numMsgs, numMsgs*2, lhs);\n             for (LedgerHandle lh : lhs) {\n                 assertTrue(\"Not fully replicated\", verifyFullyReplicated(lh, numMsgs*3));\n-                // TODO (BOOKKEEPER-112) this throws an exception at the moment \n-                // because recovering a ledger updates the ledger znode\n-                //lh.close();\n+                lh.close();\n             }\n         }\n     }"},{"sha":"3d03cd38dea1e919cc6732de55418d9727ad60db","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieThrottleTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,127 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+*/\n+\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.test.BookieFailureTest;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookieThrottleTest extends BookKeeperClusterTestCase{\n+\n+    private static Logger LOG = LoggerFactory.getLogger(BookieFailureTest.class);\n+    private DigestType digestType;\n+    private LedgerHandle lh;\n+    private static CountDownLatch countDownLatch;\n+    private int throttle = 5;\n+    private int TIME_OUT = 30;\n+\n+    // Constructor\n+    public BookieThrottleTest() {\n+        super(4);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Test\n+    public void testVerifyPermitRelaseInReadFailure() throws Exception {\n+        baseClientConf.setThrottleValue(numBookies);\n+        int numEntries = throttle * 2;\n+        System.setProperty(\"throttle\", String.valueOf(throttle));\n+\n+        lh = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n+        // Add ledger entries.\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (i))\n+                    .getBytes());\n+        }\n+        LOG.info(\"Finished writing all ledger entries so shutdown all the bookies \" +\n+                \"to verify the read permits.\");\n+\n+        for (int i = 0; i < numBookies; i++) {\n+            bs.get(i).shutdown();\n+        }\n+\n+        try {\n+            lh.readEntries(0, throttle-1);\n+        } catch (BKException e) {\n+            LOG.info( \"Exception when reading the entries, since all bookies are stopped\", e);\n+        }\n+        LOG.debug(\"*** READ COMPLETE ***\");\n+        // grace period, just to avoid randomness\n+        Thread.sleep(2000);\n+        assertEquals(\"Permits is not released when read has failed from all replicas\",\n+                throttle, lh.getAvailablePermits().availablePermits());\n+        lh.close();\n+    }\n+\n+    @Test\n+    public void testVerifyPermitRelaseInAsyncReadFailure() throws Exception {\n+        baseClientConf.setThrottleValue(numBookies);\n+        System.setProperty(\"throttle\", String.valueOf(throttle));\n+\n+        lh = bkc.createLedger(numBookies, 1, digestType, \"\"\n+                .getBytes());\n+        // Add ledger entries.\n+        int numEntries = throttle * 2;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry((\"LedgerId: \" + lh.getId() + \", EntryId: \" + (i))\n+                    .getBytes());\n+        }\n+        LOG.info(\"Finished writing all ledger entries so shutdown all the bookies \"+\n+                \"to verify the read permits.\");\n+\n+        for (int i = 0; i < numBookies; i++) {\n+            bs.get(i).shutdown();\n+        }\n+        BookieReadCallback bookieReadCallback = new BookieReadCallback();\n+        countDownLatch = new CountDownLatch(throttle);\n+        try {\n+            lh.asyncReadEntries(0, throttle-1, bookieReadCallback, null);\n+        } catch (Exception e) {\n+            LOG.info( \"Exception when reading the entries, since all bookies are stopped\", e);\n+        }\n+        countDownLatch.await(TIME_OUT, TimeUnit.SECONDS);\n+        LOG.debug(\"*** READ COMPLETE ***\");\n+        // grace period, just to avoid randomness\n+        Thread.sleep(2000);\n+        assertEquals(\"Permits is not released when read has failed from all replicas\",\n+                throttle, lh.getAvailablePermits().availablePermits());\n+        lh.close();\n+    }\n+\n+    static class BookieReadCallback implements ReadCallback\n+    {\n+        @Override\n+        public void readComplete(int rc, LedgerHandle lh,\n+                Enumeration<LedgerEntry> seq, Object ctx) {\n+            assertTrue(\"Expected Not OK, since all bookies are stopped\", rc != BKException.Code.OK);\n+            countDownLatch.countDown();\n+        }        \n+    }\n+}"},{"sha":"d4b62880f180f0059f91304fdba51b0ed2f6dbd5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,30 @@\n+package org.apache.bookkeeper.client;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+public class ClientUtil {\n+    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed, \n+                                        long length, byte[] data) {\n+        CRC32DigestManager dm = new CRC32DigestManager(ledgerId);\n+        return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,\n+                                                    data, 0, data.length);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"3a0e261b318c61f471141c51b97ca4169886d325","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","status":"removed","additions":0,"deletions":139,"changes":139,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerCacheTest.java?ref=814f0ab6b4d43a35992e995c8abd804326ec633b","patch":"@@ -1,139 +0,0 @@\n-/*\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\n- */\n-\n-package org.apache.bookkeeper.client;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.security.GeneralSecurityException;\n-\n-import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.BookieException;\n-import org.apache.bookkeeper.bookie.LedgerEntryPage;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.client.MacDigestManager;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * Tests writing to concurrent ledgers\n- */\n-public class LedgerCacheTest extends TestCase {\n-    static Logger LOG = LoggerFactory.getLogger(LedgerCacheTest.class);\n-\n-    Bookie bookie;\n-    ServerConfiguration conf;\n-    File txnDir, ledgerDir;\n-\n-    class TestWriteCallback implements WriteCallback {\n-        public void writeComplete(int rc, long ledgerId, long entryId, InetSocketAddress addr, Object ctx) {\n-            LOG.info(\"Added entry: \" + rc + \", \" + ledgerId + \", \" + entryId + \", \" + addr);\n-        }\n-    }\n-\n-\n-    @Override\n-    @Before\n-    public void setUp() throws Exception {\n-        String txnDirName = System.getProperty(\"txnDir\");\n-        if (txnDirName != null) {\n-            txnDir = new File(txnDirName);\n-        }\n-        String ledgerDirName = System.getProperty(\"ledgerDir\");\n-        if (ledgerDirName != null) {\n-            ledgerDir = new File(ledgerDirName);\n-        }\n-        File tmpFile = File.createTempFile(\"book\", \".txn\", txnDir);\n-        tmpFile.delete();\n-        txnDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n-        txnDir.mkdirs();\n-        tmpFile = File.createTempFile(\"book\", \".ledger\", ledgerDir);\n-        ledgerDir = new File(tmpFile.getParent(), tmpFile.getName()+\".dir\");\n-        ledgerDir.mkdirs();\n-\n-        conf = new ServerConfiguration();\n-        conf.setBookiePort(5000);\n-        conf.setZkServers(null);\n-        conf.setJournalDirName(txnDir.getPath());\n-        conf.setLedgerDirNames(new String[] { ledgerDir.getPath() });\n-        bookie = new Bookie(conf);\n-    }\n-\n-\n-    @Override\n-    @After\n-    public void tearDown() {\n-        try {\n-            bookie.shutdown();\n-            recursiveDelete(txnDir);\n-            recursiveDelete(ledgerDir);\n-        } catch (InterruptedException e) {\n-            LOG.error(\"Error tearing down\", e);\n-        }\n-    }\n-\n-    /**\n-     * Recursively deletes a directory. This is a duplication of BookieClientTest.\n-     *\n-     * @param dir\n-     */\n-    private static void recursiveDelete(File dir) {\n-        File children[] = dir.listFiles();\n-        if (children != null) {\n-            for (File child : children) {\n-                recursiveDelete(child);\n-            }\n-        }\n-        dir.delete();\n-    }\n-\n-    @Test\n-    public void testAddEntryException()\n-            throws GeneralSecurityException, BookieException {\n-        /*\n-         * Populate ledger cache\n-         */\n-        try {\n-            byte[] masterKey = \"blah\".getBytes();\n-            for( int i = 0; i < 30000; i++) {\n-                MacDigestManager dm = new MacDigestManager(i, masterKey);\n-                byte[] data = \"0123456789\".getBytes();\n-                ByteBuffer entry = dm.computeDigestAndPackageForSending(0, 0, 10, data, 0, data.length).toByteBuffer();\n-                bookie.addEntry(entry, new TestWriteCallback(), null, masterKey);\n-            }\n-        } catch (IOException e) {\n-            LOG.error(\"Got IOException.\", e);\n-            fail(\"Failed to add entry.\");\n-        }\n-    }\n-\n-}"},{"sha":"1c109a28741df7bebdd9675fa5dddf7db35d05b1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","status":"modified","additions":46,"deletions":11,"changes":57,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestFencing.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -62,7 +62,7 @@ public void testBasicFencing() throws Exception {\n          * Create ledger.\n          */\n         LedgerHandle writelh = null;\n-        writelh = bkc.createLedger(digestType, \"\".getBytes());\n+        writelh = bkc.createLedger(digestType, \"password\".getBytes());\n \n         String tmp = \"BookKeeper is cool!\";\n         for (int i = 0; i < 10; i++) {\n@@ -72,7 +72,7 @@ public void testBasicFencing() throws Exception {\n         /*\n          * Try to open ledger.\n          */\n-        LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType, \"\".getBytes());\n+        LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType, \"password\".getBytes());\n         // should have triggered recovery and fencing\n         \n         try {\n@@ -162,8 +162,10 @@ public void testManyOpenParallel() throws Exception {\n          */\n         final LedgerHandle writelh = bkc.createLedger(digestType, \"\".getBytes());\n \n+        final int numRecovery = 10;\n+\n         final String tmp = \"BookKeeper is cool!\";\n-        final CountDownLatch latch = new CountDownLatch(100);\n+        final CountDownLatch latch = new CountDownLatch(numRecovery);\n         Thread writethread = new Thread() {\n                 public void run() {\n                     try {\n@@ -178,7 +180,7 @@ public void run() {\n             };\n         writethread.start();\n \n-        final int numRecovery = 100;\n+\n         CyclicBarrier barrier = new CyclicBarrier(numRecovery+1);\n         LedgerOpenThread threads[] = new LedgerOpenThread[numRecovery];\n         for (int i = 0; i < numRecovery; i++) {\n@@ -253,7 +255,7 @@ public void testFencingInteractionWithBookieRecovery() throws Exception {\n         System.setProperty(\"digestType\", digestType.toString());\n         System.setProperty(\"passwd\", \"testPasswd\");\n \n-        BookKeeperAdmin admin = new BookKeeperAdmin(HOSTPORT);\n+        BookKeeperAdmin admin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n \n         LedgerHandle writelh = bkc.createLedger(digestType, \"testPasswd\".getBytes());\n         \n@@ -267,16 +269,18 @@ public void testFencingInteractionWithBookieRecovery() throws Exception {\n         InetSocketAddress bookieToKill \n             = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n         killBookie(bookieToKill);\n+\n+        // write entries to change ensemble\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n         admin.recoverBookieData(bookieToKill, null);\n         \n-        /* TODO: uncomment this when BOOKKEEPER-112 is\n-           fixed\n-           \n         for (int i = 0; i < numEntries; i++) {\n             writelh.addEntry(tmp.getBytes());\n         }\n-        */\n-        \n+\n         LedgerHandle readlh = bkc.openLedger(writelh.getId(), \n                                              digestType, \"testPasswd\".getBytes());\n         try {\n@@ -306,7 +310,7 @@ public void testFencingInteractionWithBookieRecovery2() throws Exception {\n         System.setProperty(\"digestType\", digestType.toString());\n         System.setProperty(\"passwd\", \"testPasswd\");\n \n-        BookKeeperAdmin admin = new BookKeeperAdmin(HOSTPORT);\n+        BookKeeperAdmin admin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n \n         LedgerHandle writelh = bkc.createLedger(digestType, \"testPasswd\".getBytes());\n         \n@@ -342,4 +346,35 @@ public void testFencingInteractionWithBookieRecovery2() throws Exception {\n             // correct behaviour\n         }\n     }\n+\n+    /**\n+     * Test that fencing doesn't work with a bad password\n+     */\n+    @Test\n+    public void testFencingBadPassword() throws Exception {\n+        /*\n+         * Create ledger.\n+         */\n+        LedgerHandle writelh = null;\n+        writelh = bkc.createLedger(digestType, \"password1\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < 10; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        /*\n+         * Try to open ledger.\n+         */\n+        try {\n+            LedgerHandle readlh = bkc.openLedger(writelh.getId(), digestType, \"badPassword\".getBytes());\n+            fail(\"Should not have been able to open with a bad password\");\n+        } catch (BKException.BKUnauthorizedAccessException uue) {\n+            // correct behaviour\n+        }\n+        // should have triggered recovery and fencing\n+\n+        writelh.addEntry(tmp.getBytes());\n+    }\n+\n }"},{"sha":"eed9905dee872829e2987d640e7d8025689851bd","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadTimeout.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,101 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import org.junit.*;\n+import java.net.InetSocketAddress;\n+import java.util.Enumeration;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This unit test tests ledger fencing;\n+ *\n+ */\n+public class TestReadTimeout extends BookKeeperClusterTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(TestReadTimeout.class);\n+\n+    DigestType digestType;\n+\n+    public TestReadTimeout() {\n+        super(10);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Test\n+    public void testReadTimeout() throws Exception {\n+        final AtomicBoolean completed = new AtomicBoolean(false);\n+\n+        LedgerHandle writelh = bkc.createLedger(3,3,digestType, \"testPasswd\".getBytes());\n+        String tmp = \"Foobar\";\n+        \n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+        \n+        Set<InetSocketAddress> beforeSet = new HashSet<InetSocketAddress>();\n+        for (InetSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries)) {\n+            beforeSet.add(addr);\n+        }\n+\n+        final InetSocketAddress bookieToSleep \n+            = writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n+        int sleeptime = baseClientConf.getReadTimeout()*3;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        sleepBookie(bookieToSleep, sleeptime, latch);\n+        latch.await();\n+\n+        writelh.asyncAddEntry(tmp.getBytes(), \n+                new AddCallback() {\n+                    public void addComplete(int rc, LedgerHandle lh, \n+                                            long entryId, Object ctx) {\n+                        completed.set(true);\n+                    }\n+                }, null);\n+        Thread.sleep((baseClientConf.getReadTimeout()*3)*1000);\n+        Assert.assertTrue(\"Write request did not finish\", completed.get());\n+\n+        Set<InetSocketAddress> afterSet = new HashSet<InetSocketAddress>();\n+        for (InetSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries+1)) {\n+            afterSet.add(addr);\n+        }\n+        beforeSet.removeAll(afterSet);\n+        Assert.assertTrue(\"Bookie set should not match\", beforeSet.size() != 0);\n+    }\n+}"},{"sha":"12c1b5a2abe22bf26cb52b24f66842d1b71f5582","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"added","additions":167,"deletions":0,"changes":167,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,167 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.meta.LedgerManager.GarbageCollector;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test garbage collection ledgers in ledger manager\n+ */\n+public class GcLedgersTest extends LedgerManagerTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(GcLedgersTest.class);\n+\n+    public GcLedgersTest(String ledgerManagerType) {\n+        super(ledgerManagerType);\n+    }\n+\n+    /**\n+     * Create ledgers\n+     */\n+    private void createLedgers(int numLedgers, final Set<Long> createdLedgers) {\n+        final AtomicInteger expected = new AtomicInteger(numLedgers);\n+        for (int i=0; i<numLedgers; i++) {\n+            ledgerManager.newLedgerPath(new GenericCallback<String>() {\n+                @Override\n+                public void operationComplete(int rc, String ledgerPath) {\n+                    if (rc == BKException.Code.OK) {\n+                        try {\n+                            long ledgerId = ledgerManager.getLedgerId(ledgerPath);\n+                            ledgerManager.addActiveLedger(ledgerId, true);\n+                            createdLedgers.add(ledgerId);\n+                        } catch (IOException ie) {\n+                        }\n+                    }\n+                    synchronized (expected) {\n+                        int num = expected.decrementAndGet();\n+                        if (num == 0) {\n+                            expected.notify();\n+                        }\n+                    }\n+                }\n+            }, new LedgerMetadata(1, 1));\n+        }\n+        synchronized (expected) {\n+            try {\n+                while (expected.get() > 0) {\n+                    expected.wait(100);\n+                }\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGarbageCollectLedgers() throws Exception {\n+        int numLedgers = 100;\n+        int numRemovedLedgers = 10;\n+\n+        final Set<Long> createdLedgers = new HashSet<Long>();\n+        final Set<Long> removedLedgers = new HashSet<Long>();\n+\n+        // create 100 ledgers\n+        createLedgers(numLedgers, createdLedgers);\n+\n+        Random r = new Random(System.currentTimeMillis());\n+        final List<Long> tmpList = new ArrayList<Long>();\n+        tmpList.addAll(createdLedgers);\n+        Collections.shuffle(tmpList, r);\n+        // random remove several ledgers\n+        for (int i=0; i<numRemovedLedgers; i++) {\n+            long ledgerId = tmpList.get(i);\n+            zkc.delete(ledgerManager.getLedgerPath(ledgerId), -1);\n+            removedLedgers.add(ledgerId);\n+            createdLedgers.remove(ledgerId);\n+        }\n+        final CountDownLatch inGcProgress = new CountDownLatch(1);\n+        final CountDownLatch createLatch = new CountDownLatch(1);\n+        final CountDownLatch endLatch = new CountDownLatch(2);\n+\n+        Thread gcThread = new Thread() {\n+            @Override\n+            public void run() {\n+                ledgerManager.garbageCollectLedgers(new GarbageCollector() {\n+                    boolean paused = false;\n+                    @Override\n+                    public void gc(long ledgerId) {\n+                        if (!paused) {\n+                            inGcProgress.countDown();\n+                            try {\n+                                createLatch.await();\n+                            } catch (InterruptedException ie) {\n+                            }\n+                            paused = true;\n+                        }\n+                        LOG.info(\"Garbage Collected ledger {}\", ledgerId);\n+                    }\n+                });\n+                LOG.info(\"Gc Thread quits.\");\n+                endLatch.countDown();\n+            }\n+        };\n+\n+        Thread createThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    inGcProgress.await();\n+                    // create 10 more ledgers\n+                    createLedgers(10, createdLedgers);\n+                    LOG.info(\"Finished creating 10 more ledgers.\");\n+                    createLatch.countDown();\n+                } catch (Exception e) {\n+                }\n+                LOG.info(\"Create Thread quits.\");\n+                endLatch.countDown();\n+            }\n+        };\n+\n+        createThread.start();\n+        gcThread.start();\n+\n+        endLatch.await();\n+\n+        // test ledgers\n+        for (Long ledger : removedLedgers) {\n+            assertFalse(ledgerManager.containsActiveLedger(ledger));\n+        }\n+        for (Long ledger : createdLedgers) {\n+            assertTrue(ledgerManager.containsActiveLedger(ledger));\n+        }\n+    }\n+}"},{"sha":"dbcd65ae5f010744c2044f7b3c2d068b38d8638d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/HierarchicalLedgerDeleteTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -32,10 +32,6 @@\n  */\n public class HierarchicalLedgerDeleteTest extends LedgerDeleteTest {\n \n-    public HierarchicalLedgerDeleteTest(DigestType digestType) {\n-        super(digestType);\n-    }\n-\n     @Before\n     @Override\n     public void setUp() throws Exception {"},{"sha":"4784854e8765a5fb81d58bc70c5e5156846e57be","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","status":"modified","additions":3,"deletions":5,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerLayoutTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -30,18 +30,16 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.ZooDefs.Ids;\n-import org.apache.bookkeeper.test.BaseTestCase;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.Assert.*;\n \n-public class LedgerLayoutTest extends BaseTestCase {\n-    DigestType digestType;\n+public class LedgerLayoutTest extends BookKeeperClusterTestCase {\n \n-    public LedgerLayoutTest(DigestType digestType) {\n+    public LedgerLayoutTest() {\n         super(0);\n-        this.digestType = digestType;\n     }\n \n     @Test"},{"sha":"b8a541b315c1490b246a7644c5fbf4c9161e6fe3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,77 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test case to run over serveral ledger managers\n+ */\n+@RunWith(Parameterized.class)\n+public abstract class LedgerManagerTestCase extends BookKeeperClusterTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(LedgerManagerTestCase.class);\n+\n+    LedgerManager ledgerManager;\n+\n+    public LedgerManagerTestCase(String ledgerManagerType) {\n+        super(0);\n+        baseConf.setLedgerManagerType(ledgerManagerType);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] {\n+            { FlatLedgerManager.NAME },\n+            { HierarchicalLedgerManager.NAME }\n+        });\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ledgerManager = LedgerManagerFactory.newLedgerManager(baseConf, zkc);\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        ledgerManager.close();\n+        super.tearDown();\n+    }\n+\n+}"},{"sha":"e07c756114b84b7ee872cacfa239e69622bebdba","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLedgerManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -33,7 +33,7 @@\n import java.util.List;\n import java.util.ArrayList;\n \n-import org.apache.bookkeeper.test.BaseTestCase;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -42,10 +42,10 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class TestLedgerManager extends BaseTestCase {\n+public class TestLedgerManager extends BookKeeperClusterTestCase {\n     static Logger LOG = LoggerFactory.getLogger(TestLedgerManager.class);\n \n-    public TestLedgerManager(DigestType digestType) {\n+    public TestLedgerManager() {\n         super(0);\n     }\n \n@@ -258,4 +258,4 @@ public void testConcurrent2() throws Exception {\n         assertEquals(\"Incorrect number of successes\", numThreadsEach, numSuccess);\n         assertEquals(\"Incorrect number of failures\", numThreadsEach, numFails);\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"2dcad980f2da2aa46be1b1ce071f1996f9dfc880","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestProtoVersions.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -80,7 +80,7 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n                     readLatch.countDown();\n                 }\n             };\n-        bc.readCompletions.put(new PerChannelBookieClient.CompletionKey(1, 1), \n+        bc.readCompletions.put(bc.newCompletionKey(1, 1),\n                                new PerChannelBookieClient.ReadCompletion(cb, this));\n         \n         int totalHeaderSize = 4 // for the length of the packet"},{"sha":"437f0aebeade22edd847840e9544c754447dbc07","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","status":"modified","additions":4,"deletions":212,"changes":216,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BaseTestCase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,237 +21,29 @@\n \n package org.apache.bookkeeper.test;\n \n-import java.io.IOException;\n-import java.io.File;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.List;\n \n-import org.apache.bookkeeper.client.BookKeeperTestClient;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.proto.BookieServer;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.ZooDefs.Ids;\n-import org.apache.zookeeper.server.NIOServerCnxnFactory;\n-import org.apache.zookeeper.server.ZooKeeperServer;\n-import org.apache.zookeeper.test.ClientBase;\n-import org.junit.After;\n-import org.junit.Before;\n+\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n import org.junit.runners.Parameterized.Parameters;\n \n-import junit.framework.TestCase;\n-\n @RunWith(Parameterized.class)\n-public abstract class BaseTestCase extends TestCase {\n+public abstract class BaseTestCase extends BookKeeperClusterTestCase {\n     static final Logger LOG = LoggerFactory.getLogger(BaseTestCase.class);\n-    // ZooKeeper related variables\n-    protected static final String HOSTPORT = \"127.0.0.1:2181\";\n-    protected static Integer ZooKeeperDefaultPort = 2181;\n-    protected ZooKeeperServer zks;\n-    protected ZooKeeper zkc; // zookeeper client\n-    protected NIOServerCnxnFactory serverFactory;\n-    protected File ZkTmpDir;\n-\n-    // BookKeeper\n-    protected List<File> tmpDirs = new ArrayList<File>();\n-    protected List<BookieServer> bs = new ArrayList<BookieServer>();\n-    protected List<ServerConfiguration> bsConfs = new ArrayList<ServerConfiguration>();\n-    protected Integer initialPort = 5000;\n-    protected int numBookies;\n-    protected BookKeeperTestClient bkc;\n-\n-    protected ServerConfiguration baseConf = new ServerConfiguration();\n-    protected ClientConfiguration baseClientConf = new ClientConfiguration();\n \n     public BaseTestCase(int numBookies) {\n-        this.numBookies = numBookies;\n+        super(numBookies);\n     }\n \n     @Parameters\n     public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] { {DigestType.MAC }, {DigestType.CRC32}});\n     }\n \n-    protected ServerConfiguration newServerConfiguration(int port, String zkServers, File journalDir, File[] ledgerDirs) {\n-        ServerConfiguration conf = new ServerConfiguration(baseConf);\n-        conf.setBookiePort(port);\n-        conf.setZkServers(zkServers);\n-        conf.setJournalDirName(journalDir.getPath());\n-        String[] ledgerDirNames = new String[ledgerDirs.length];\n-        for (int i=0; i<ledgerDirs.length; i++) {\n-            ledgerDirNames[i] = ledgerDirs[i].getPath();\n-        }\n-        conf.setLedgerDirNames(ledgerDirNames);\n-        return conf;\n-    }\n-\n-    @Before\n-    @Override\n-    public void setUp() throws Exception {\n-        try {\n-            // create a ZooKeeper server(dataDir, dataLogDir, port)\n-            LOG.debug(\"Running ZK server\");\n-            // ServerStats.registerAsConcrete();\n-            ClientBase.setupTestEnv();\n-            ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n-            ZkTmpDir.delete();\n-            ZkTmpDir.mkdir();\n-\n-            zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n-            serverFactory = new NIOServerCnxnFactory();\n-            serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), 100);\n-            serverFactory.startup(zks);\n-\n-            boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);\n-\n-            LOG.debug(\"Server up: \" + b);\n-\n-            // create a zookeeper client\n-            LOG.debug(\"Instantiate ZK Client\");\n-            zkc = new ZooKeeper(\"127.0.0.1\", ZooKeeperDefaultPort, new emptyWatcher());\n-\n-            // initialize the zk client with values\n-            zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-            zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-\n-            // Create Bookie Servers (B1, B2, B3)\n-            for (int i = 0; i < numBookies; i++) {\n-                File f = File.createTempFile(\"bookie\", \"test\");\n-                tmpDirs.add(f);\n-                f.delete();\n-                f.mkdir();\n-\n-                ServerConfiguration conf = newServerConfiguration(\n-                    initialPort + i, HOSTPORT, f, new File[] { f });\n-                bsConfs.add(conf);\n-\n-                BookieServer server = new BookieServer(conf);\n-                server.start();\n-                bs.add(server);\n-            }\n-\n-            baseClientConf.setZkServers(\"127.0.0.1\");\n-            if (numBookies > 0) {\n-                bkc = new BookKeeperTestClient(baseClientConf);\n-            }\n-        } catch(Exception e) {\n-            LOG.error(\"Error setting up\", e);\n-            throw e;\n-        }\n-    }\n-\n-    public void killBookie(InetSocketAddress addr) throws InterruptedException {\n-        BookieServer toRemove = null;\n-        for (BookieServer server : bs) {\n-            if (server.getLocalAddress().equals(addr)) {\n-                server.shutdown();\n-                toRemove = server;\n-            }\n-        }\n-        if (toRemove != null) {\n-            bs.remove(toRemove);\n-        }\n-    }\n-\n-    /**\n-     * Restart bookie servers\n-     *\n-     * @throws InterruptedException\n-     * @throws IOException\n-     */\n-    protected void restartBookies() \n-            throws InterruptedException, IOException, KeeperException {\n-        restartBookies(null);\n-    }\n-\n-    /**\n-     * Restart bookie servers add new configuration settings\n-     */\n-    protected void restartBookies(ServerConfiguration newConf)\n-            throws InterruptedException, IOException, KeeperException {\n-        // shut down bookie server\n-        for (BookieServer server : bs) {\n-            server.shutdown();\n-        }\n-        bs.clear();\n-        Thread.sleep(1000);\n-        // restart them to ensure we can't \n-        int j = 0;\n-        for (File f : tmpDirs) {\n-            ServerConfiguration conf = bsConfs.get(j);\n-            if (null != newConf) {\n-                conf.loadConf(newConf);\n-            }\n-            BookieServer server = new BookieServer(conf);\n-            server.start();\n-            bs.add(server);\n-            j++;\n-        }\n-    }\n-\n-    @After\n-    @Override\n-    public void tearDown() throws Exception {\n-        LOG.info(\"TearDown\");\n-\n-        if (bkc != null) {\n-            bkc.close();;\n-        }\n-\n-        for (BookieServer server : bs) {\n-            server.shutdown();\n-        }\n-\n-        if (zkc != null) {\n-            zkc.close();\n-        }\n-\n-        for (File f : tmpDirs) {\n-            cleanUpDir(f);\n-        }\n-\n-        // shutdown ZK server\n-        if (serverFactory != null) {\n-            serverFactory.shutdown();\n-            assertTrue(\"waiting for server down\", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));\n-        }\n-        // ServerStats.unregister();\n-        cleanUpDir(ZkTmpDir);\n-\n-\n-    }\n-\n-    /* Clean up a directory recursively */\n-    protected boolean cleanUpDir(File dir) {\n-        if (dir.isDirectory()) {\n-            LOG.info(\"Cleaning up \" + dir.getName());\n-            String[] children = dir.list();\n-            for (String string : children) {\n-                boolean success = cleanUpDir(new File(dir, string));\n-                if (!success)\n-                    return false;\n-            }\n-        }\n-        // The directory is now empty so delete it\n-        return dir.delete();\n-    }\n-\n-    /* User for testing purposes, void */\n-    class emptyWatcher implements Watcher {\n-        public void process(WatchedEvent event) {\n-        }\n-    }\n-\n }"},{"sha":"a81067de7047fce9a51f459121b3c23a51e4dd7a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"added","additions":339,"deletions":0,"changes":339,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,339 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.test;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.client.BookKeeperTestClient;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * A class runs several bookie servers for testing.\n+ */\n+public abstract class BookKeeperClusterTestCase extends TestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(BookKeeperClusterTestCase.class);\n+\n+    // ZooKeeper related variables\n+    protected ZooKeeperUtil zkUtil = new ZooKeeperUtil();\n+    protected ZooKeeper zkc;\n+\n+    // BookKeeper related variables\n+    protected List<File> tmpDirs = new LinkedList<File>();\n+    protected List<BookieServer> bs = new LinkedList<BookieServer>();\n+    protected List<ServerConfiguration> bsConfs = new LinkedList<ServerConfiguration>();\n+    protected Integer initialPort = 5000;\n+    private Integer nextPort = initialPort;\n+    protected int numBookies;\n+    protected BookKeeperTestClient bkc;\n+\n+    protected ServerConfiguration baseConf = new ServerConfiguration();\n+    protected ClientConfiguration baseClientConf = new ClientConfiguration();\n+\n+    public BookKeeperClusterTestCase(int numBookies) {\n+        this.numBookies = numBookies;\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        try {\n+            // start zookeeper service\n+            startZKCluster();\n+            // start bookkeeper service\n+            startBKCluster();\n+        } catch (Exception e) {\n+            LOG.error(\"Error setting up\", e);\n+            throw e;\n+        }\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        LOG.info(\"TearDown\");\n+        // stop bookkeeper service\n+        stopBKCluster();\n+        // stop zookeeper service\n+        stopZKCluster();\n+    }\n+\n+    /**\n+     * Start zookeeper cluster\n+     *\n+     * @throws Exception\n+     */\n+    protected void startZKCluster() throws Exception {\n+        zkUtil.startServer();\n+        zkc = zkUtil.getZooKeeperClient();\n+    }\n+\n+    /**\n+     * Stop zookeeper cluster\n+     *\n+     * @throws Exception\n+     */\n+    protected void stopZKCluster() throws Exception {\n+        zkUtil.killServer();\n+    }\n+\n+    /**\n+     * Start cluster\n+     *\n+     * @throws Exception\n+     */\n+    protected void startBKCluster() throws Exception {\n+        baseClientConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        if (numBookies > 0) {\n+            bkc = new BookKeeperTestClient(baseClientConf);\n+        }\n+\n+        // Create Bookie Servers (B1, B2, B3)\n+        for (int i = 0; i < numBookies; i++) {\n+            startNewBookie();\n+        }\n+    }\n+\n+    /**\n+     * Stop cluster\n+     *\n+     * @throws Exception\n+     */\n+    protected void stopBKCluster() throws Exception {\n+        if (bkc != null) {\n+            bkc.close();;\n+        }\n+\n+        for (BookieServer server : bs) {\n+            server.shutdown();\n+        }\n+\n+        for (File f : tmpDirs) {\n+            FileUtils.deleteDirectory(f);\n+        }\n+    }\n+\n+    protected ServerConfiguration newServerConfiguration(int port, String zkServers, File journalDir, File[] ledgerDirs) {\n+        ServerConfiguration conf = new ServerConfiguration(baseConf);\n+        conf.setBookiePort(port);\n+        conf.setZkServers(zkServers);\n+        conf.setJournalDirName(journalDir.getPath());\n+        String[] ledgerDirNames = new String[ledgerDirs.length];\n+        for (int i=0; i<ledgerDirs.length; i++) {\n+            ledgerDirNames[i] = ledgerDirs[i].getPath();\n+        }\n+        conf.setLedgerDirNames(ledgerDirNames);\n+        return conf;\n+    }\n+\n+    /**\n+     * Kill a bookie by its socket address\n+     *\n+     * @param addr\n+     *          Socket Address\n+     * @return the configuration of killed bookie\n+     * @throws InterruptedException\n+     */\n+    public ServerConfiguration killBookie(InetSocketAddress addr) throws InterruptedException {\n+        BookieServer toRemove = null;\n+        int toRemoveIndex = 0;\n+        for (BookieServer server : bs) {\n+            if (server.getLocalAddress().equals(addr)) {\n+                server.shutdown();\n+                toRemove = server;\n+                break;\n+            }\n+            ++toRemoveIndex;\n+        }\n+        if (toRemove != null) {\n+            bs.remove(toRemove);\n+            return bsConfs.remove(toRemoveIndex);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Kill a bookie by index\n+     *\n+     * @param index\n+     *          Bookie Index\n+     * @return the configuration of killed bookie\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+    public ServerConfiguration killBookie(int index) throws InterruptedException, IOException {\n+        if (index >= bs.size()) {\n+            throw new IOException(\"Bookie does not exist\");\n+        }\n+        BookieServer server = bs.get(index);\n+        server.shutdown();\n+        bs.remove(server);\n+        return bsConfs.remove(index);\n+    }\n+\n+    /**\n+     * Sleep a bookie\n+     *\n+     * @param addr\n+     *          Socket Address\n+     * @param seconds\n+     *          Sleep seconds\n+     * @param l\n+     *          Count Down Latch\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+    public void sleepBookie(InetSocketAddress addr, final int seconds,\n+                            final CountDownLatch l)\n+            throws InterruptedException, IOException {\n+        final String name = \"BookieJournal-\" + addr.getPort();\n+        Thread[] allthreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allthreads);\n+        for (final Thread t : allthreads) {\n+            if (t.getName().equals(name)) {\n+                Thread sleeper = new Thread() {\n+                    public void run() {\n+                        try {\n+                            t.suspend();\n+                            l.countDown();\n+                            Thread.sleep(seconds*1000);\n+                            t.resume();\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error suspending thread\", e);\n+                        }\n+                    }\n+                };\n+                sleeper.start();\n+                return;\n+            }\n+        }\n+        throw new IOException(\"Bookie thread not found\");\n+    }\n+\n+    /**\n+     * Restart bookie servers\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws KeeperException\n+     * @throws BookieException\n+     */\n+    public void restartBookies()\n+            throws InterruptedException, IOException, KeeperException, BookieException {\n+        restartBookies(null);\n+    }\n+\n+    /**\n+     * Restart bookie servers using new configuration settings\n+     *\n+     * @param newConf\n+     *          New Configuration Settings\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws KeeperException\n+     * @throws BookieException\n+     */\n+    public void restartBookies(ServerConfiguration newConf)\n+        throws InterruptedException, IOException, KeeperException, BookieException {\n+        // shut down bookie server\n+        for (BookieServer server : bs) {\n+            server.shutdown();\n+        }\n+        bs.clear();\n+        Thread.sleep(1000);\n+        // restart them to ensure we can't\n+        int j = 0;\n+        for (ServerConfiguration conf : bsConfs) {\n+            if (null != newConf) {\n+                conf.loadConf(newConf);\n+            }\n+            bs.add(startBookie(conf));\n+            j++;\n+        }\n+    }\n+\n+    /**\n+     * Helper method to startup a new bookie server with the indicated port\n+     * number\n+     *\n+     * @param port\n+     *            Port to start the new bookie server on\n+     * @throws IOException\n+     */\n+    public int startNewBookie()\n+            throws IOException, InterruptedException, KeeperException, BookieException {\n+        File f = File.createTempFile(\"bookie\", \"test\");\n+        tmpDirs.add(f);\n+        f.delete();\n+        f.mkdir();\n+\n+        int port = nextPort++;\n+        ServerConfiguration conf = newServerConfiguration(port, zkUtil.getZooKeeperConnectString(),\n+                                                          f, new File[] { f });\n+        bsConfs.add(conf);\n+        bs.add(startBookie(conf));\n+\n+        return port;\n+    }\n+\n+    /**\n+     * Helper method to startup a bookie server using a configuration object\n+     *\n+     * @param conf\n+     *            Server Configuration Object\n+     *\n+     */\n+    protected BookieServer startBookie(ServerConfiguration conf)\n+            throws IOException, InterruptedException, KeeperException, BookieException {\n+        BookieServer server = new BookieServer(conf);\n+        server.start();\n+\n+        int port = conf.getBookiePort();\n+        while(bkc.getZkHandle().exists(\"/ledgers/available/\" + InetAddress.getLocalHost().getHostAddress() + \":\" + port, false) == null) {\n+            Thread.sleep(500);\n+        }\n+\n+        bkc.readBookiesBlocking();\n+        LOG.info(\"New bookie on port \" + port + \" has been created.\");\n+\n+        return server;\n+    }\n+}"},{"sha":"773d7698b28b8884a4ef3d9d433127b5d42cc411","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":15,"deletions":14,"changes":29,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -135,9 +135,10 @@ public void testWriteGaps() throws Exception {\n         BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n         ChannelBuffer bb;\n         bb = createByteBuffer(1, 1, 1);\n-        bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null, BookieProtocol.FLAG_NONE);\n+        bc.addEntry(addr, 1, passwd, 1, bb, wrcb, arc, BookieProtocol.FLAG_NONE);\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 1, recb, arc, BookieProtocol.FLAG_NONE);\n+            arc.wait(1000);\n+            bc.readEntry(addr, 1, 1, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(1, arc.entry.getInt());\n@@ -156,63 +157,63 @@ public void testWriteGaps() throws Exception {\n             notifyObject.wait();\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 6, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 6, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 7, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 7, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(7, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 1, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 1, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(1, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 2, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 2, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(2, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 3, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 3, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(3, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 4, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 4, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 11, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 11, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(11, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 5, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 5, recb, arc);\n             arc.wait(1000);\n             assertEquals(0, arc.rc);\n             assertEquals(5, arc.entry.getInt());\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 10, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 10, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 12, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 12, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n         synchronized (arc) {\n-            bc.readEntry(addr, 1, 13, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 1, 13, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }\n@@ -234,7 +235,7 @@ public void testNoLedger() throws Exception {\n         InetSocketAddress addr = new InetSocketAddress(\"127.0.0.1\", port);\n         BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n         synchronized (arc) {\n-            bc.readEntry(addr, 2, 13, recb, arc, BookieProtocol.FLAG_NONE);\n+            bc.readEntry(addr, 2, 13, recb, arc);\n             arc.wait(1000);\n             assertEquals(BKException.Code.NoSuchEntryException, arc.rc);\n         }"},{"sha":"e647d6876d0afc40c6e88211cf53195d428c7154","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","status":"modified","additions":69,"deletions":16,"changes":85,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieFailureTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -279,26 +279,79 @@ public void setUp() throws Exception {\n         zkc.close();\n     }\n \n+    @Test\n+    public void testLedgerNoRecoveryOpenAfterBKCrashed() throws Exception {\n+        // Create a ledger\n+        LedgerHandle beforelh = bkc.createLedger(numBookies, numBookies, digestType, \"\".getBytes());\n+\n+        int numEntries = 10;\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n \n-    /* Clean up a directory recursively */\n-    @Override\n-    protected boolean cleanUpDir(File dir) {\n-        if (dir.isDirectory()) {\n-            LOG.info(\"Cleaning up \" + dir.getName());\n-            String[] children = dir.list();\n-            for (String string : children) {\n-                boolean success = cleanUpDir(new File(dir, string));\n-                if (!success)\n-                    return false;\n-            }\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        LedgerHandle afterlh = bkc.openLedgerNoRecovery(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        assertEquals(numEntries - 2, afterlh.getLastAddConfirmed());\n+\n+        startNewBookie();\n+        LedgerHandle beforelh2 = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n+\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh2.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        try {\n+            bkc.openLedgerNoRecovery(beforelh2.getId(), digestType, \"\".getBytes());\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKReadException e) {\n+            // correct behaviour\n         }\n-        // The directory is now empty so delete it\n-        return dir.delete();\n     }\n \n-    /* User for testing purposes, void */\n-    class emptyWatcher implements Watcher {\n-        public void process(WatchedEvent event) {\n+    @Test\n+    public void testLedgerOpenAfterBKCrashed() throws Exception {\n+        // Create a ledger\n+        LedgerHandle beforelh = bkc.createLedger(numBookies, numBookies, digestType, \"\".getBytes());\n+\n+        int numEntries = 10;\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+        startNewBookie();\n+\n+        // try to open ledger no recovery\n+        LedgerHandle afterlh = bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        assertEquals(beforelh.getLastAddPushed(), afterlh.getLastAddConfirmed());\n+\n+        LedgerHandle beforelh2 = bkc.createLedger(numBookies, 1, digestType, \"\".getBytes());\n+\n+        for (int i=0; i<numEntries; i++) {\n+            beforelh2.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        killBookie(0);\n+\n+        // try to open ledger no recovery\n+        try {\n+            bkc.openLedger(beforelh2.getId(), digestType, \"\".getBytes());\n+            fail(\"Should have thrown exception\");\n+        } catch (BKException.BKLedgerRecoveryException e) {\n+            // correct behaviour\n         }\n     }\n "},{"sha":"d1c4b334eedd67bd519425ded3f7c5dd197e52aa","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","status":"modified","additions":55,"deletions":15,"changes":70,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieJournalRollingTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -26,7 +26,6 @@\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.bookie.Bookie.JournalIdFilter;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -43,14 +42,14 @@\n /**\n  * This class tests that bookie rolling journals\n  */\n-public class BookieJournalRollingTest extends BaseTestCase {\n+public class BookieJournalRollingTest extends BookKeeperClusterTestCase {\n     static Logger LOG = LoggerFactory.getLogger(BookieJournalRollingTest.class);\n \n     DigestType digestType;\n \n-    public BookieJournalRollingTest(DigestType digestType) {\n+    public BookieJournalRollingTest() {\n         super(3);\n-        this.digestType = digestType;\n+        this.digestType = DigestType.CRC32;\n     }\n \n     @Before\n@@ -79,7 +78,12 @@ public void tearDown() throws Exception {\n             lhs[i] = bkc.createLedger(digestType, \"\".getBytes());\n             ledgerIds[i] = lhs[i].getId();\n         }\n+        writeLedgerEntries(lhs, msgSize, numMsgs);\n+        // Return the ledger handles to the inserted ledgers and entries\n+        return lhs;\n+    }\n \n+    private void writeLedgerEntries(LedgerHandle[] lhs, int msgSize, int numMsgs) throws Exception {\n         // Create a dummy message string to write as ledger entries\n         StringBuilder msgSB = new StringBuilder();\n         for (int i = 0; i < msgSize; i++) {\n@@ -89,16 +93,13 @@ public void tearDown() throws Exception {\n \n         // Write all of the entries for all of the ledgers\n         for (int i = 0; i < numMsgs; i++) {\n-            for (int j = 0; j < numLedgers; j++) {\n+            for (int j = 0; j < lhs.length; j++) {\n                 StringBuilder sb = new StringBuilder();\n-                sb.append(ledgerIds[j]).append('-').append(i).append('-')\n+                sb.append(lhs[j].getId()).append('-').append(i).append('-')\n                   .append(msg);\n                 lhs[j].addEntry(sb.toString().getBytes());\n             }\n         }\n-\n-        // Return the ledger handles to the inserted ledgers and entries\n-        return lhs;\n     }\n \n     private void validLedgerEntries(long[] ledgerIds, int msgSize, int numMsgs) throws Exception {\n@@ -169,13 +170,15 @@ public void testJournalRolling() throws Exception {\n \n         // verify that we only keep at most journal files \n         for (File journalDir : tmpDirs) {\n-            List<Long> logs = Bookie.listJournalIds(journalDir, new JournalIdFilter() {\n-                @Override\n-                public boolean accept(long journalId) {\n-                    return true;\n+            File[] journals = journalDir.listFiles();\n+            int numJournals = 0;\n+            for (File f : journals) {\n+                if (!f.getName().endsWith(\".txn\")) {\n+                    continue;\n                 }\n-            });\n-            assertTrue(logs.size() <= 2);\n+                ++numJournals;\n+            }\n+            assertTrue(numJournals <= 2);\n         }\n \n         // restart bookies \n@@ -216,4 +219,41 @@ public void testJournalRollingWithoutSyncup() throws Exception {\n         validLedgerEntries(ledgerIds, 1024, 1024);\n     }\n \n+    /**\n+     * This test writes enough ledger entries to roll over the journals\n+     * without sync up\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReplayDeletedLedgerJournalEntries() throws Exception {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Testing replaying journal entries whose ledger has been removed.\");\n+        }\n+\n+        // Write entries\n+        LedgerHandle[] lhs = writeLedgerEntries(1, 1024, 10);\n+        // Wait until all entries are flushed and last mark rolls\n+        Thread.sleep(3 * baseConf.getFlushInterval());\n+\n+        // restart bookies with flush interval set to a large value\n+        ServerConfiguration newConf = new ServerConfiguration();\n+        newConf.setFlushInterval(999999999);\n+        // restart bookies\n+        restartBookies(newConf);\n+\n+        // Write entries again to let them existed in journal\n+        writeLedgerEntries(lhs, 1024, 10);\n+\n+        // delete them\n+        for (LedgerHandle lh : lhs) {\n+            bkc.deleteLedger(lh.getId());\n+        }\n+        // wait for gc\n+        Thread.sleep(2 * newConf.getGcWaitTime());\n+\n+        // restart bookies again to trigger replaying journal\n+        restartBookies(newConf);\n+    }\n+\n }"},{"sha":"384cc3b65ac925470692c7fbc43a4073a0900169","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":129,"deletions":2,"changes":131,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -99,7 +99,7 @@ public BookieReadWriteTest(DigestType digestType) {\n \n         public SyncObj() {\n             counter = 0;\n-            lastConfirmed = -1;\n+            lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n             value = false;\n         }\n     }\n@@ -904,7 +904,134 @@ public void testReadFromOpenLedger() throws IOException {\n             fail(\"Test failed due to interruption\");\n         }\n     }\n+    \n+    @Test\n+    public void testReadFromOpenLedgerOpenOnce() throws Exception {\n+        try {\n+            // Create a ledger\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+                \n+                entries.add(entry.array());\n+                entriesSize.add(entry.array().length);\n+                lh.addEntry(entry.array());\n+                if (i == numEntriesToWrite / 2) {\n+                    // no recovery opened ledger 's last confirmed entry id is\n+                    // less than written\n+                    // and it just can read until (i-1)\n+                    int toRead = i - 1;\n+                    \n+                    long readLastConfirmed = lhOpen.readLastConfirmed();\n+                    assertTrue(readLastConfirmed != 0);\n+                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);\n+                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);\n+                    LedgerEntry e = readEntry.nextElement();\n+                    assertEquals(toRead, e.getEntryId());\n+                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());\n+                    // should not written to a read only ledger\n+                    try {\n+                        lhOpen.addEntry(entry.array());\n+                        fail(\"Should have thrown an exception here\");\n+                    } catch (BKException.BKIllegalOpException bkioe) {\n+                        // this is the correct response\n+                    } catch (Exception ex) {\n+                        LOG.error(\"Unexpected exception\", ex);\n+                        fail(\"Unexpected exception\");\n+                    }\n+                    \n+                }\n+            }\n+            long last = lh.readLastConfirmed();\n+            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));\n+    \n+            LOG.debug(\"*** WRITE COMPLETE ***\");\n+            // close ledger\n+            lh.close();\n+            // close read only ledger should not change metadata\n+            lhOpen.close();\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        } \n+    }\n+    \n+    @Test\n+    public void testReadFromOpenLedgerZeroAndOne() throws Exception {\n+        try {\n+            // Create a ledger\n+            lh = bkc.createLedger(digestType, ledgerPassword);\n+            // bkc.initMessageDigest(\"SHA1\");\n+            ledgerId = lh.getId();\n+            LOG.info(\"Ledger ID: \" + lh.getId());\n+            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);\n+            \n+            /*\n+             * We haven't written anything, so it should be empty.\n+             */\n+            LOG.debug(\"Checking that it is empty\");\n+            long readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(\"Last confirmed has the wrong value\",\n+                       readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);\n+            \n+            /*\n+             * Writing one entry.\n+             */\n+            LOG.debug(\"Going to write one entry\");\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            \n+            entries.add(entry.array());\n+            entriesSize.add(entry.array().length);\n+            lh.addEntry(entry.array());\n \n+            /*\n+             * The hint should still indicate that there is no confirmed\n+             * add.\n+             */\n+            LOG.debug(\"Checking that it is still empty even after writing one entry\");\n+            readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);\n+\n+            /*\n+             * Adding one more, and this time we should expect to \n+             * see one entry.\n+             */\n+            entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            \n+            entries.add(entry.array());\n+            entriesSize.add(entry.array().length);\n+            lh.addEntry(entry.array());\n+\n+            LOG.info(\"Checking that it has an entry\");\n+            readLastConfirmed = lhOpen.readLastConfirmed();\n+            assertTrue(readLastConfirmed == 0L);\n+                        \n+            // close ledger\n+            lh.close();\n+            // close read only ledger should not change metadata\n+            lhOpen.close();\n+        } catch (BKException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to BookKeeper exception\");\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Test failed\", e);\n+            fail(\"Test failed due to interruption\");\n+        } \n+    }\n+    \n \n     @Test\n     public void testLastConfirmedAdd() throws IOException {\n@@ -953,7 +1080,7 @@ public void testLastConfirmedAdd() throws IOException {\n \n             // Wait for for last confirmed\n             synchronized (sync) {\n-                while (sync.lastConfirmed == -1) {\n+                while (sync.lastConfirmed == LedgerHandle.INVALID_ENTRY_ID) {\n                     LOG.debug(\"Counter = \" + sync.lastConfirmed);\n                     sync.wait();\n                 }"},{"sha":"de1db36d757bc9910639cbcf92c8eb8a5ec8ae53","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieZKExpireTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -28,20 +28,19 @@\n import static org.junit.Assert.*;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import java.util.HashSet;\n import junit.framework.TestCase;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.bookie.Bookie;\n \n-public class BookieZKExpireTest extends BaseTestCase {\n+public class BookieZKExpireTest extends BookKeeperClusterTestCase {\n \n-    public BookieZKExpireTest(DigestType digestType) {\n+    public BookieZKExpireTest() {\n         super(0);\n     }\n \n     @Test\n-    public void runBookieServerZKExpireBehaviourTest() throws Exception {\n+    public void testBookieServerZKExpireBehaviour() throws Exception {\n         BookieServer server = null;\n         try {\n             File f = File.createTempFile(\"bookieserver\", \"test\");\n@@ -58,7 +57,8 @@ public void runBookieServerZKExpireBehaviourTest() throws Exception {\n                 }\n             }\n \n-            ServerConfiguration conf = newServerConfiguration(initialPort + 1, HOSTPORT, f, new File[] { f });\n+            ServerConfiguration conf = newServerConfiguration(initialPort + 1,\n+                                                              zkUtil.getZooKeeperConnectString(), f, new File[] { f });\n             server = new BookieServer(conf);\n             server.start();\n "},{"sha":"eaea75e2cddd8d7137a9ba1742055eff755c7c81","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/CloseTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -72,4 +72,29 @@ public void testClose() throws Exception {\n             lh[i].close();\n         }\n     }\n+\n+    @Test\n+    public void testCloseByOthers() throws Exception {\n+\n+        int numLedgers = 1;\n+        int numMsgs = 10;\n+\n+        LedgerHandle lh = bkc.createLedger(digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+\n+        /*\n+         * Write 10 entries to lh.\n+         */\n+        for (int i = 0; i < numMsgs; i++) {\n+            lh.addEntry(tmp.getBytes());\n+        }\n+\n+        // other one close the entries\n+        LedgerHandle lh2 = bkc.openLedger(lh.getId(), digestType, \"\".getBytes());\n+\n+        // so the ledger would be closed, the metadata is changed\n+        // the original ledger handle should be able to close it successfully\n+        lh2.close();\n+    }\n }"},{"sha":"e4477390dfcfa1a0f3b73bc2ae121beb7b1a7e70","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","status":"modified","additions":4,"deletions":7,"changes":11,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConcurrentLedgerTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -76,6 +76,7 @@ public void setUp() throws Exception {\n         conf.setJournalDirName(txnDir.getPath());\n         conf.setLedgerDirNames(new String[] { ledgerDir.getPath() });\n         bookie = new Bookie(conf);\n+        bookie.start();\n     }\n \n     static void recursiveDelete(File f) {\n@@ -92,13 +93,9 @@ static void recursiveDelete(File f) {\n     @Override\n     @After\n     public void tearDown() {\n-        try {\n-            bookie.shutdown();\n-            recursiveDelete(txnDir);\n-            recursiveDelete(ledgerDir);\n-        } catch (InterruptedException e) {\n-            LOG.error(\"Error tearing down\", e);\n-        }\n+        bookie.shutdown();\n+        recursiveDelete(txnDir);\n+        recursiveDelete(ledgerDir);\n     }\n \n     byte zeros[] = new byte[16];"},{"sha":"6ed28b594bec7cfd0ab3a14d79c1185f0a86e47a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConfigurationTest.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConfigurationTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConfigurationTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ConfigurationTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -21,6 +21,7 @@\n package org.apache.bookkeeper.test;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n \n import junit.framework.TestCase;\n \n@@ -52,4 +53,15 @@ public void testConfigurationOverwrite() {\n         conf2.loadConf(newConf);\n         assertEquals(\"newserver\", conf2.getZkServers());\n     }\n+\n+    @Test\n+    public void testGetZkServers() {\n+        System.setProperty(\"zkServers\", \"server1:port1,server2:port2\");\n+        ServerConfiguration conf = new ServerConfiguration();\n+        ClientConfiguration clientConf = new ClientConfiguration();\n+        assertEquals(\"zookeeper connect string doesn't match in server configuration\",\n+                     \"server1:port1,server2:port2\", conf.getZkServers());\n+        assertEquals(\"zookeeper connect string doesn't match in client configuration\",\n+                     \"server1:port1,server2:port2\", clientConf.getZkServers());\n+    }\n }"},{"sha":"6bbc8e3a3445f822332c5528e7675c7d4c053de2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/IndexCorruptionTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,166 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * This class tests that index corruption cases\n+ */\n+public class IndexCorruptionTest extends BookKeeperClusterTestCase {\n+    static Logger LOG = LoggerFactory.getLogger(IndexCorruptionTest.class);\n+\n+    DigestType digestType;\n+\n+    int pageSize = 1024;\n+\n+    public IndexCorruptionTest() {\n+        super(1);\n+        this.digestType = DigestType.CRC32;\n+        baseConf.setPageSize(pageSize);\n+    }\n+\n+    private Thread findSyncThread() {\n+        int threadCount = Thread.activeCount();\n+        Thread[] allthreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allthreads);\n+        for (Thread t : allthreads) {\n+            if (t.getName().equals(\"SyncThread\")) {\n+                return t;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Test\n+    public void testNoSuchLedger() throws Exception {\n+        LOG.debug(\"Testing NoSuchLedger\");\n+\n+        Thread syncThread = findSyncThread();\n+        assertNotNull(\"Not found SyncThread.\", syncThread);\n+\n+        syncThread.suspend();\n+        // Create a ledger\n+        LedgerHandle lh = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+\n+        // Close the ledger which cause a readEntry(0) call\n+        LedgerHandle newLh = bkc.openLedger(lh.getId(), digestType, \"\".getBytes());\n+\n+        // Create a new ledger to write entries\n+        String dummyMsg = \"NoSuchLedger\";\n+        int numMsgs = 3;\n+        LedgerHandle wlh = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+        for (int i=0; i<numMsgs; i++) {\n+            wlh.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // trigger sync \n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+\n+        // restart bookies\n+        restartBookies();\n+\n+        Enumeration<LedgerEntry> seq = wlh.readEntries(0, numMsgs - 1); \n+        assertTrue(\"Enumeration of ledger entries has no element\", seq.hasMoreElements() == true);\n+        int entryId = 0;\n+        while (seq.hasMoreElements()) {\n+            LedgerEntry e = seq.nextElement();\n+            assertEquals(entryId, e.getEntryId());\n+\n+            Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry());\n+            ++entryId;\n+        }\n+        assertEquals(entryId, numMsgs);\n+    }\n+\n+    @Test\n+    public void testEmptyIndexPage() throws Exception {\n+        LOG.debug(\"Testing EmptyIndexPage\");\n+\n+        Thread syncThread = findSyncThread();\n+        assertNotNull(\"Not found SyncThread.\", syncThread);\n+\n+        syncThread.suspend();\n+\n+        // Create a ledger\n+        LedgerHandle lh1 = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+\n+        String dummyMsg = \"NoSuchLedger\";\n+\n+        // write two page entries to ledger 2\n+        int numMsgs = 2 * pageSize / 8;\n+        LedgerHandle lh2 = bkc.createLedger(1, 1, digestType, \"\".getBytes());\n+        for (int i=0; i<numMsgs; i++) {\n+            lh2.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // trigger sync\n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+\n+        syncThread.suspend();\n+\n+        // Close ledger 1 which cause a readEntry(0) call\n+        LedgerHandle newLh1 = bkc.openLedger(lh1.getId(), digestType, \"\".getBytes());\n+\n+        // write another 3 entries to ledger 2\n+        for (int i=0; i<3; i++) {\n+            lh2.addEntry(dummyMsg.getBytes());\n+        }\n+\n+        syncThread.resume();\n+\n+        // wait for sync again\n+        Thread.sleep(2 * baseConf.getFlushInterval());\n+    \n+        // restart bookies\n+        restartBookies();\n+\n+        numMsgs += 3;\n+        Enumeration<LedgerEntry> seq = lh2.readEntries(0, numMsgs - 1); \n+        assertTrue(\"Enumeration of ledger entries has no element\", seq.hasMoreElements() == true);\n+        int entryId = 0;\n+        while (seq.hasMoreElements()) {\n+            LedgerEntry e = seq.nextElement();\n+            assertEquals(entryId, e.getEntryId());\n+\n+            Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry());\n+            ++entryId;\n+        }\n+        assertEquals(entryId, numMsgs);\n+    }\n+}"},{"sha":"7c7db0386255fc34c8040aea7436ba5fdd3cd2df","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCreateDeleteTest.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCreateDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCreateDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerCreateDeleteTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,74 @@\n+package org.apache.bookkeeper.test;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import java.util.ArrayList;\n+\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test Create/Delete ledgers\n+ */\n+public class LedgerCreateDeleteTest extends BookKeeperClusterTestCase {\n+\n+    public LedgerCreateDeleteTest() {\n+        super(1);\n+    }\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        baseConf.setOpenFileLimit(1); \n+        super.setUp();\n+    }\n+\n+    @Test\n+    public void testCreateDeleteLedgers() throws Exception {\n+        int numLedgers = 3;\n+        ArrayList<Long> ledgers = new ArrayList<Long>();\n+        for (int i=0; i<numLedgers; i++) {\n+            LedgerHandle lh = bkc.createLedger(1, 1, DigestType.CRC32, \"bk is cool\".getBytes());\n+            for (int j=0; j<5; j++) {\n+                lh.addEntry(\"just test\".getBytes());\n+            }\n+            ledgers.add(lh.getId());\n+            lh.close();\n+        }\n+        for (long ledgerId : ledgers) {\n+            bkc.deleteLedger(ledgerId);\n+        }\n+        ledgers.clear();\n+        Thread.sleep(baseConf.getGcWaitTime() * 2);\n+        for (int i=0; i<numLedgers; i++) {\n+            LedgerHandle lh = bkc.createLedger(1, 1, DigestType.CRC32, \"bk is cool\".getBytes());\n+            for (int j=0; j<5; j++) {\n+                lh.addEntry(\"just test\".getBytes());\n+            }\n+            ledgers.add(lh.getId());\n+            lh.close();\n+        }\n+    }\n+}"},{"sha":"2d3593ea04da2b5800ed404c1d342ef0aed8e0f0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerDeleteTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -35,13 +35,13 @@\n  * This class tests the ledger delete functionality both from the BookKeeper\n  * client and the server side.\n  */\n-public class LedgerDeleteTest extends BaseTestCase {\n+public class LedgerDeleteTest extends BookKeeperClusterTestCase {\n     static Logger LOG = LoggerFactory.getLogger(LedgerDeleteTest.class);\n     DigestType digestType;\n \n-    public LedgerDeleteTest(DigestType digestType) {\n+    public LedgerDeleteTest() {\n         super(3);\n-        this.digestType = digestType;\n+        this.digestType = DigestType.CRC32;\n     }\n \n     @Before"},{"sha":"22e494e40acb6e8c628cdfcb4773e62bcfbff3b7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","status":"modified","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LedgerRecoveryTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -111,4 +111,42 @@ public void testLedgerRecoveryWithWrongPassword() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testLedgerRecoveryWithNotEnoughBookies() throws Exception {\n+        int numEntries = 3;\n+\n+        // Create a ledger\n+        LedgerHandle beforelh = null;\n+        beforelh = bkc.createLedger(3, 3, digestType, \"\".getBytes());\n+\n+        String tmp = \"BookKeeper is cool!\";\n+        for (int i = 0; i < numEntries; i++) {\n+            beforelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // shutdown first bookie server\n+        bs.get(0).shutdown();\n+        bs.remove(0);\n+\n+        /*\n+         * Try to open ledger.\n+         */\n+        try {\n+            bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n+            fail(\"should not reach here!\");\n+        } catch (Exception e) {\n+            // should thrown recovery exception\n+        }\n+\n+        // start a new bookie server\n+        startNewBookie();\n+\n+        LedgerHandle afterlh = bkc.openLedger(beforelh.getId(), digestType, \"\".getBytes());\n+\n+        /*\n+         * Check if has recovered properly.\n+         */\n+        assertEquals(numEntries - 1, afterlh.getLastAddConfirmed());\n+    }\n+\n }"},{"sha":"bdcb7a27e3ec0b9c93fd2f5752afb9af353bfad4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/NIOServerFactoryTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -49,6 +49,7 @@ public void testProblemProcessor() throws Exception {\n         ServerConfiguration conf = new ServerConfiguration();\n         conf.setBookiePort(22334);\n         NIOServerFactory factory = new NIOServerFactory(conf, problemProcessor);\n+        factory.start();\n         Socket s = new Socket(\"127.0.0.1\", 22334);\n         s.setSoTimeout(5000);\n         try {"},{"sha":"905ab6dead6526afe63225cb5402c55a555cfa5c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ZooKeeperUtil.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,163 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.apache.commons.io.FileUtils;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+\n+import org.apache.zookeeper.server.NIOServerCnxnFactory;\n+import org.apache.zookeeper.server.ZooKeeperServer;\n+import org.apache.zookeeper.test.ClientBase;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+\n+public class ZooKeeperUtil {\n+    static final Logger LOG = LoggerFactory.getLogger(ZooKeeperUtil.class);\n+\n+    // ZooKeeper related variables\n+    protected static Integer ZooKeeperDefaultPort = 2181;\n+    private final InetSocketAddress zkaddr;\n+\n+    protected ZooKeeperServer zks;\n+    protected ZooKeeper zkc; // zookeeper client\n+    protected NIOServerCnxnFactory serverFactory;\n+    protected File ZkTmpDir;\n+    private final String connectString;\n+\n+    public ZooKeeperUtil() {\n+        zkaddr = new InetSocketAddress(ZooKeeperDefaultPort);\n+        connectString= \"localhost:\" + ZooKeeperDefaultPort;\n+    }\n+\n+    public ZooKeeper getZooKeeperClient() {\n+        return zkc;\n+    }\n+\n+    public String getZooKeeperConnectString() {\n+        return connectString;\n+    }\n+\n+    public void startServer() throws Exception {\n+        // create a ZooKeeper server(dataDir, dataLogDir, port)\n+        LOG.debug(\"Running ZK server\");\n+        // ServerStats.registerAsConcrete();\n+        ClientBase.setupTestEnv();\n+        ZkTmpDir = File.createTempFile(\"zookeeper\", \"test\");\n+        ZkTmpDir.delete();\n+        ZkTmpDir.mkdir();\n+\n+        zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);\n+        serverFactory = new NIOServerCnxnFactory();\n+        serverFactory.configure(zkaddr, 100);\n+        serverFactory.startup(zks);\n+\n+        boolean b = ClientBase.waitForServerUp(getZooKeeperConnectString(),\n+                                               ClientBase.CONNECTION_TIMEOUT);\n+        LOG.debug(\"Server up: \" + b);\n+\n+        // create a zookeeper client\n+        LOG.debug(\"Instantiate ZK Client\");\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        zkc = new ZooKeeper(getZooKeeperConnectString(), 10000,\n+                            new Watcher() {\n+                                @Override\n+                                public void process(WatchedEvent event) {\n+                                    // handle session disconnects and expires\n+                                    if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {\n+                                        latch.countDown();\n+                                    }\n+                                }\n+                            });\n+        if (!latch.await(10000, TimeUnit.MILLISECONDS)) {\n+            zkc.close();\n+            fail(\"Could not connect to zookeeper server\");\n+        }\n+\n+        // initialize the zk client with values\n+        zkc.create(\"/ledgers\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        zkc.create(\"/ledgers/available\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+    }\n+\n+    public void sleepServer(final int seconds, final CountDownLatch l)\n+            throws InterruptedException, IOException {\n+        Thread[] allthreads = new Thread[Thread.activeCount()];\n+        Thread.enumerate(allthreads);\n+        for (final Thread t : allthreads) {\n+            if (t.getName().contains(\"SyncThread:0\")) {\n+                Thread sleeper = new Thread() {\n+                    public void run() {\n+                        try {\n+                            t.suspend();\n+                            l.countDown();\n+                            Thread.sleep(seconds*1000);\n+                            t.resume();\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error suspending thread\", e);\n+                        }\n+                    }\n+                };\n+                sleeper.start();\n+                return;\n+            }\n+        }\n+        throw new IOException(\"ZooKeeper thread not found\");\n+    }\n+\n+    public void killServer() throws Exception {\n+        if (zkc != null) {\n+            zkc.close();\n+        }\n+\n+        // shutdown ZK server\n+        if (serverFactory != null) {\n+            serverFactory.shutdown();\n+            assertTrue(\"waiting for server down\",\n+                       ClientBase.waitForServerDown(getZooKeeperConnectString(),\n+                                                    ClientBase.CONNECTION_TIMEOUT));\n+        }\n+        if (zks != null) {\n+            zks.getTxnLogFactory().close();\n+        }\n+        // ServerStats.unregister();\n+        FileUtils.deleteDirectory(ZkTmpDir);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"3717433d7cd4e0df4b21e7ea89816755b4f4a30f","filename":"doc/bookieConfigParams.textile","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookieConfigParams.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookieConfigParams.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookieConfigParams.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,51 @@\n+Title:        Bookie Configuration Parameters\n+Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License. You may\n+        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n+        .        \n+        Unless required by applicable law or agreed to in writing,\n+        software distributed under the License is distributed on an \"AS IS\"\n+        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+        implied. See the License for the specific language governing permissions\n+        and limitations under the License.\n+        .\n+\n+h1. Bookie Configuration Parameters\n+\n+This page contains detailed information about configuration parameters used for configuring a bookie server. There is an example in \"bookkeeper-server/conf/bk_server.conf\". \n+\n+h3. General parameters\n+\n+| @zkServers@ | A list of one of more servers on which zookeeper is running. The server list can be comma separated values, e.g., zk1:2181,zk2:2181,zk3:2181 |\n+| @zkTimeout@ | ZooKeeper client session timeout in milliseconds. Bookie server will exit if it received SESSION_EXPIRED because it was partitioned off from ZooKeeper for more than the session timeout JVM garbage collection, disk I/O will cause SESSION_EXPIRED. Increment this value could help avoiding this issue. The default value is 10,000. |\n+| @bookiePort@        |Port that bookie server listens on. The default value is 3181.|\n+| @journalDir@        | Directory Bookkeeper outputs its write ahead log, ideally in a dedicated device. The default value is \"/tmp/bk-txn\". |\n+| @ledgerDirs@        | Directory Bookkeeper outputs ledger snapshots could define multiple directories to store snapshots, comma separated. For example: /tmp/bk1-data,/tmp/bk2-data. Ideally ledger dirs and journal dir are each in a differet device, which reduce the contention between random i/o and sequential write. It is possible to run with a single disk,  but performance will be significantly lower.|\n+| @logSizeLimit@      | Maximum file size of entry logger, in bytes. A new entry log file will be created when the old one reaches the file size limitation. The default value is 2GB. |\n+| @journalMaxSizeMB@  |  Maximum file size of journal file, in mega bytes. A new journal file will be created when the old one reaches the file size limitation. The default value is 2kB. |\n+| @journalMaxBackups@ |  Max number of old journal file to keep. Keeping a number of old journal files might help data recovery in some special cases. The default value is 5. |\n+| @gcWaitTime@        | Interval to trigger next garbage collection, in milliseconds. Since garbage collection is running in the background, running the garbage collector too frequently hurts performance. It is best to set its value high enough if there is sufficient disk capacity.|\n+| @flushInterval@ | Interval to flush ledger index pages to disk, in milliseconds. Flushing index files will introduce random disk I/O. Consequently, it is important to have journal dir and ledger dirs each on different devices. However,  if it necessary to have journal dir and ledger dirs on the same device, one option is to increment the flush interval to get higher performance. Upon a failure, the bookie will take longer to recover. |\n+| @bookieDeathWatchInterval@ | Interval to check whether a bookie is dead or not, in milliseconds. |\n+\n+h3. NIO server settings\n+\n+| @serverTcpNoDelay@ | This settings is used to enabled/disabled Nagle's algorithm, which is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network. If you are sending many small messages, such that more than one can fit in a single IP packet, setting server.tcpnodelay to false to enable Nagle algorithm can provide better performance. Default value is true. |\n+\n+h3. Ledger cache settings\n+\n+| @openFileLimit@ | Maximum number of ledger index files that can be opened in a bookie. If the number of ledger index files reaches this limit, the bookie starts to flush some ledger indexes from memory to disk. If flushing happens too frequently, then performance is affected. You can tune this number to improve performance according. |\n+| @pageSize@ | Size of an index page in ledger cache, in bytes. A larger index page can improve performance when writing page to disk, which is efficient when you have small number of ledgers and these ledgers have a similar number of entries. With a large number of ledgers and a few entries per ledger, a smaller index page would improves memory usage. |\n+| @pageLimit@ | Maximum number of index pages to store in the ledger cache. If the number of index pages reaches this limit, bookie server starts to flush ledger indexes from memory to disk. Incrementing this value is an option when flushing becomes frequent. It is important to make sure, though, that pageLimit*pageSize is not more than JVM max memory limit; otherwise it will raise an OutOfMemoryException. In general, incrementing pageLimit, using smaller index page would gain better performance in the case of a large number of ledgers with few entries per ledger. If pageLimit is -1, a bookie uses 1/3 of the JVM memory to compute the maximum number of index pages. |\n+\n+h3. Ledger manager settings\n+\n+| @ledgerManagerType@ | What kind of ledger manager is used to manage how ledgers are stored, managed and garbage collected. See \"BookKeeper Internals\":./bookkeeperInternals.html for detailed info. Default is flat. |\n+| @zkLedgersRootPath@ | Root zookeeper path to store ledger metadata. Default is /ledgers. |\n+\n+h3. Entry Log compaction settings\n+\n+| @minorCompactionInterval@ | Interval to run minor compaction, in seconds. If it is set to less than or equal to zero, then minor compaction is disabled. Default is 1 hour. |\n+| @minorCompactionThreshold@ | Entry log files with remaining size under this threshold value will be compacted in a minor compaction. If it is set to less than or equal to zero, the minor compaction is disabled. Default is 0.2 |\n+| @majorCompactionInterval@ | Interval to run major compaction, in seconds. If it is set to less than or equal to zero, then major compaction is disabled. Default is 1 day. |\n+| @majorCompactionThreshold@ | Entry log files with remaining size below this threshold value will be compacted in a major compaction. Those entry log files whose remaining size percentage is still higher than the threshold value will never be compacted. If it is set to less than or equal to zero, the major compaction is disabled. Default is 0.8. |"},{"sha":"6c9c50dccf3c06e92f604f56351abbc000f0d1d7","filename":"doc/bookieRecovery.textile","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookieRecovery.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookieRecovery.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookieRecovery.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -18,13 +18,13 @@ Notice:    Licensed to the Apache Software Foundation (ASF) under one\n \n h1. Bookie Recovery\n \n-p. When a bookie crashes, any ledgers with entries on the bookie potentially become underreplicated. For this reason, we provide a recovery tool which will ensure that all ledgers which had entries on the bookie are fully replicated. At the moment, this is not an automatic process. The administrator must run this tool manually when he sees that the bookie has died. \n+p. When a bookie crashes, any ledgers with entries on the bookie potentially become under-replicated. For this reason, we provide a recovery tool which will ensure that all ledgers which had entries on the bookie are fully replicated. At the moment, this is not an automatic process. The administrator must run this tool manually when he sees that the bookie has died. \n \n-To run recovery, with zk1.example.com as the zookeeper ensemble, and bk3.example.com as the failed bookie, do the following:\n+To run recovery, with zk1.example.com as the zookeeper ensemble, and 192.168.1.10 as the failed bookie, do the following:\n \n-@bookkeeper-server/bin/bookkeeper org.apache.bookkeeper.tools.BookKeeperTools zk1.example.com:2181 bk3.example.com:3181@\n+@bookkeeper-server/bin/bookkeeper org.apache.bookkeeper.tools.BookKeeperTools zk1.example.com:2181 192.168.1.10:3181@\n \n-It is necessary to specify the host and port portion of failed bookie, as this is how it identifies itself to zookeeper. It is possible to specify a third argument, which is the bookie to replicate to. If this is omitted, as in our example, a random bookie is chosen for each ledger fragment. A ledger fragment is a continous sequence of entries in a bookie, which share the same ensemble. \n+It is necessary to specify the host and port portion of failed bookie, as this is how it identifies itself to zookeeper. It is possible to specify a third argument, which is the bookie to replicate to. If this is omitted, as in our example, a random bookie is chosen for each ledger fragment. A ledger fragment is a continuous sequence of entries in a bookie, which share the same ensemble. \n \n The recovery process is as follows.\n \n@@ -37,5 +37,5 @@ The recovery process is as follows.\n ### the client reads entries that belong to the ledger fragment from other bookies in the ensemble and writes them to the selected bookie;\n ### Once all entries have been replicated, the zookeeper metadata for the fragment is updated to reflect the new ensemble;\n ### The fragment is marked as fully replicated in the recovery tool;\n-## Once all ledger fragements are marked as fully replicated, the ledger is marked as fully replicated;\n+## Once all ledger fragments are marked as fully replicated, the ledger is marked as fully replicated;\n # Once all ledgers are marked as fully replicated, bookie recovery is finished.\n\\ No newline at end of file"},{"sha":"be4ad1c06c8a6c422ec2dc72e126858c5db76370","filename":"doc/bookkeeperConfig.textile","status":"modified","additions":53,"deletions":12,"changes":65,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperConfig.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperConfig.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperConfig.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -14,34 +14,52 @@ Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n \n h1. Abstract\n \n-This document contains information about deploying, administering and mantaining BookKeeper. It also discusses best practices and common problems. \n+This document contains information about deploying, administering and maintaining BookKeeper. It also discusses best practices and common problems. \n \n h1. Running a BookKeeper instance\n \n h2. System requirements\n \n-p. A typical BookKeeper installation comprises a set of bookies and a set of ZooKeeper replicas. The exact number of bookies depends on the quorum mode, desired throughput, and number of clients using this installation simultaneously. The minimum number of bookies is three for self-verifying (stores a message authentication code along with each entry) and four for generic (does not store a message authentication code with each entry), and there is no upper limit on the number of bookies. Increasing the number of bookies will, in fact, enable higher throughput. \n+A typical BookKeeper installation comprises a set of bookies and a set of ZooKeeper replicas. The exact number of bookies depends on the quorum mode, desired throughput, and number of clients using this installation simultaneously. The minimum number of bookies is three for self-verifying (stores a message authentication code along with each entry) and four for generic (does not store a message authentication code with each entry), and there is no upper limit on the number of bookies. Increasing the number of bookies will, in fact, enable higher throughput.\n \n-p. For performance, we require each server to have at least two disks. It is possible to run a bookie with a single disk, but performance will be significantly lower in this case.\n+For performance, we require each server to have at least two disks. It is possible to run a bookie with a single disk, but performance will be significantly lower in this case.\n \n-p. For ZooKeeper, there is no constraint with respect to the number of replicas. Having a single machine running ZooKeeper in standalone mode is sufficient for BookKeeper. For resilience purposes, it might be a good idea to run ZooKeeper in quorum mode with multiple servers. Please refer to the ZooKeeper documentation for detail on how to configure ZooKeeper with multiple replicas. \n+For ZooKeeper, there is no constraint with respect to the number of replicas. Having a single machine running ZooKeeper in standalone mode is sufficient for BookKeeper. For resilience purposes, it might be a good idea to run ZooKeeper in quorum mode with multiple servers. Please refer to the ZooKeeper documentation for detail on how to configure ZooKeeper with multiple replicas.\n \n h2. Running bookies\n \n-p. To run a bookie, we execute the following command: \n+To run a bookie, we execute the following command:\n \n @bookkeeper-server/bin/bookkeeper bookie@\n \n-p. The configuration parameters can be set in bookkeeper-server/conf/bk_server.conf. \n+The configuration parameters can be set in bookkeeper-server/conf/bk_server.conf.\n \n The important parameters are:\n- * @bookiePort@, Port number that the bookie listens on; \n- * @zkServers@, Comma separated list of ZooKeeper servers with a hostname:port format; \n- * @journalDir@, Path for Log Device (stores bookie write-ahead log); \n- * @ledgerDir@, Path for Ledger Device (stores ledger entries); \n \n-p. Ideally, @journalDir@ and @ledgerDir@ are each in a different device. See \"BookKeeper Configuration Parameters\":./bookkeeperConfigParams.html for a full list of configuration parameters.\n+* @bookiePort@, Port number that the bookie listens on; \n+* @zkServers@, Comma separated list of ZooKeeper servers with a hostname:port format; \n+* @journalDir@, Path for Log Device (stores bookie write-ahead log); \n+* @ledgerDir@, Path for Ledger Device (stores ledger entries); \n \n+Ideally, @journalDir@ and @ledgerDir@ are each in a different device. See \"Bookie Configuration Parameters\":./bookieConfigParams.html for a full list of configuration parameters.\n+\n+h3. Upgrading\n+\n+From time to time, we may make changes to the filesystem layout of the bookie, which are incompatible with previous versions of bookkeeper and require that directories used with previous versions are upgraded. If you upgrade your bookkeeper software, and an upgrade is required, then the bookie will fail to start and print an error such as:\n+\n+@2012-05-25 10:41:50,494 - ERROR - [main:Bookie@246] - Directory layout version is less than 3, upgrade needed@\n+\n+BookKeeper provides a utility for upgrading the filesystem.\n+@bookkeeper-server/bin/bookkeeper upgrade@\n+\n+The upgrade application takes 3 possible switches, @--upgrade@, @--rollback@ or @--finalize@. A normal upgrade process looks like.\n+\n+# @bookkeeper-server/bin/bookkeeper upgrade --upgrade@\n+# @bookkeeper-server/bin/bookkeeper bookie@\n+# Check everything is working. Kill bookie, ^C\n+# If everything is ok, @bookkeeper-server/bin/bookkeeper upgrade --finalize@\n+# Start bookie again @bookkeeper-server/bin/bookkeeper bookie@\n+# If something is amiss, you can roll back the upgrade @bookkeeper-server/bin/bookkeeper upgrade --rollback@\n \n h3. Logging\n \n@@ -50,8 +68,31 @@ BookKeeper uses \"slf4j\":http://www.slf4j.org for logging, with the log4j binding\n @export BOOKIE_LOG_CONF=/tmp/log4j.properties@\n @bookkeeper-server/bin/bookkeeper bookie@\n \n+h3. Missing disks or directories\n+\n+Replacing disks or removing directories accidentally can cause a bookie to fail while trying to read a ledger fragment which the ledger metadata has claimed exists on the bookie. For this reason, when a bookie is started for the first time, it's disk configuration is fixed for the lifetime of that bookie. Any change to the disk configuration of the bookie, such as a crashed disk or an accidental configuration change, will result in the bookie being unable to start with the following error:\n+\n+@2012-05-29 18:19:13,790 - ERROR - [main:BookieServer@314] - Exception running bookie server : @\n+@org.apache.bookkeeper.bookie.BookieException$InvalidCookieException@\n+@.......at org.apache.bookkeeper.bookie.Cookie.verify(Cookie.java:82)@\n+@.......at org.apache.bookkeeper.bookie.Bookie.checkEnvironment(Bookie.java:275)@\n+@.......at org.apache.bookkeeper.bookie.Bookie.<init>(Bookie.java:351)@\n+\n+If the change was the result of an accidental configuration change, the change can be reverted and the bookie can be restarted. However, if the change cannot be reverted, such as is the case when you want to add a new disk or replace a disk, the bookie must be wiped and then all its data re-replicated onto it. To do this, do the following:\n+\n+# Increment the _bookiePort_ in _bk_server.conf_.\n+# Ensure that all directories specified by _journalDirectory_ and _ledgerDirectories_ are empty.\n+# Start the bookie.\n+# Run @bin/bookkeeper org.apache.bookkeeper.tools.BookKeeperTools <zkserver> <oldbookie> <newbookie>@ to re-replicate data. <oldbookie> and <newbookie> are identified by their external IP and bookiePort. For example if this process is being run on a bookie with an external IP of 192.168.1.10, with an old _bookiePort_ of 3181 and a new _bookiePort_ of 3182, and with zookeeper running on _zk1.example.com_, the command to run would be <br/>@bin/bookkeeper org.apache.bookkeeper.tools.BookKeeperTools zk1.example.com 192.168.1.10:3181 192.168.1.10:3182@. See \"Bookie Recovery\":./bookieRecovery.html for more details on the re-replication process.\n+\n+The mechanism to prevent the bookie from starting up in the case of configuration changes exists to prevent the following silent failures:\n+\n+# A strict subset of the ledger devices (among multiple ledger devices) has been replaced, consequently making the content of the replaced devices unavailable;\n+# A strict subset of the ledger directories has been accidentally deleted.\n+\n h2. Setting up a test ensemble\n \n-Sometimes it is useful to run a ensemble of bookies on your local machine for testing. We provide a utility for doing this. It will set up N bookies, and a zookeeper instance locally. The data on these bookies and of the zookeeper instance are not persisted over restarts, so obviously this should never be used in a production environment. To run a test ensemble of 10 bookies, do the following.\n+Sometimes it is useful to run a ensemble of bookies on your local machine for testing. We provide a utility for doing this. It will set up N bookies, and a zookeeper instance locally. The data on these bookies and of the zookeeper instance are not persisted over restarts, so obviously this should never be used in a production environment. To run a test ensemble of 10 bookies, do the following:\n \n @bookkeeper-server/bin/bookkeeper localbookie 10@\n+"},{"sha":"eb76ca4cc2a49c7aa23d596322c555200b812caa","filename":"doc/bookkeeperConfigParams.textile","status":"modified","additions":12,"deletions":19,"changes":31,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperConfigParams.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperConfigParams.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperConfigParams.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -12,35 +12,28 @@ Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n \n h1. BookKeeper Configuration Parameters\n \n-This page contains detailed information about configuration parameters used for configuring a BookKeeper bookie. There is an example in \"bookkeeper-server/conf/bk_server.conf\". \n+This page contains detailed information about configuration parameters used for configuring a BookKeeper client.\n \n h3. General parameters\n \n | @zkServers@ | A list of one of more servers on which zookeeper is running. The server list can be comma separated values, e.g., zk1:2181,zk2:2181,zk3:2181 |\n-| @zkTimeout@ | ZooKeeper client session timeout in milliseconds. Bookie server will exit if it received SESSION_EXPIRED because it was partitioned off from ZooKeeper for more than the session timeout JVM garbage collection, disk I/O will cause SESSION_EXPIRED. Increment this value could help avoiding this issue. The default value is 10,000. |\n-| @bookiePort@        |Port that bookie server listens on. The default value is 3181.|\n-| @journalDir@        | Directory Bookkeeper outputs its write ahead log, ideally in a dedicated device. The default value is \"/tmp/bk-txn\". |\n-| @ledgerDirs@        | Directory Bookkeeper outputs ledger snapshots could define multiple directories to store snapshots, comma separated. For example: /tmp/bk1-data,/tmp/bk2-data. Ideally ledger dirs and journal dir are each in a differet device, which reduce the contention between random i/o and sequential write. It is possible to run with a single disk,  but performance will be significantly lower.|\n-| @logSizeLimit@      | Maximum file size of entry logger, in bytes. A new entry log file will be created when the old one reaches the file size limitation. The default value is 2GB. |\n-| @journalMaxSizeMB@  |  Maximum file size of journal file, in mega bytes. A new journal file will be created when the old one reaches the file size limitation. The default value is 2kB. |\n-| @journalMaxBackups@ |  Max number of old journal file to keep. Keeping a number of old journal files might help data recovery in some special cases. The default value is 5. |\n-| @gcWaitTime@        | Interval to trigger next garbage collection, in milliseconds. Since garbage collection is running in the background, running the garbage collector too frequently hurts performance. It is best to set its value high enough if there is sufficient disk capacity.|\n-| @flushInterval@ | Interval to flush ledger index pages to disk, in milliseconds. Flushing index files will introduce random disk I/O. Consequently, it is important to have journal dir and ledger dirs each on different devices. However,  if it necessary to have journal dir and ledger dirs on the same device, one option is to increment the flush interval to get higher performance. Upon a failure, the bookie will take longer to recover. |\n-| @bookieDeathWatchInterval@ | Interval to check whether a bookie is dead or not, in milliseconds. |\n+| @zkTimeout@ | ZooKeeper client session timeout in milliseconds. The default value is 10,000. |\n+| @throttle@ | A throttle value is used to prevent running out of memory when producing too many requests than the capability of bookie servers can handle. The default is 5,000. |\n+| @readTimeout@ | This is the number of seconds bookkeeper client wait without hearing a response from a bookie before client consider it failed. The default is 5 seconds. |\n+| @numWorkerThreads@ | This is the number of worker threads used by bookkeeper client to submit operations. The default value is the number of available processors. |\n \n h3. NIO server settings\n \n-| @serverTcpNoDelay@ | This settings is used to enabled/disabled Nagle's algorithm, which is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network. If you are sending many small messages, such that more than one can fit in a single IP packet, setting server.tcpnodelay to false to enable Nagle algorithm can provide better performance. Default value is true. |\n-\n-h3. Ledger cache settings\n-\n-| @openFileLimit@ | Maximum number of ledger index files that can be opened in a bookie. If the number of ledger index files reaches this limit, the bookie starts to flush some ledger indexes from memory to disk. If flushing happens too frequently, then performance is affected. You can tune this number to improve performance according. |\n-| @pageSize@ | Size of an index page in ledger cache, in bytes. A larger index page can improve performance when writing page to disk, which is efficient when you have small number of ledgers and these ledgers have a similar number of entries. With a large number of ledgers and a few entries per ledger, a smaller index page would improves memory usage. |\n-| @pageLimit@ | Maximum number of index pages to store in the ledger cache. If the number of index pages reaches this limit, bookie server starts to flush ledger indexes from memory to disk. Incrementing this value is an option when flushing becomes frequent. It is important to make sure, though, that pageLimit*pageSize is not more than JVM max memory limit; otherwise it will raise an OutOfMemoryException. In general, incrementing pageLimit, using smaller index page would gain better performance in the case of a large number of ledgers with few entries per ledger. If pageLimit is -1, a bookie uses 1/3 of the JVM memory to compute the maximum number of index pages. |\n+| @clientTcpNoDelay@ | This settings is used to enabled/disabled Nagle's algorithm, which is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network. If you are sending many small messages, such that more than one can fit in a single IP packet, setting server.tcpnodelay to false to enable Nagle algorithm can provide better performance. Default value is true. |\n \n h3. Ledger manager settings\n \n-| @ledgerManagerType@ | What kind of ledger manager is used to manage how ledgers are stored, managed and garbage collected. See \"BookKeeper Internals\":./bookkeeperInternals.html for detailed info. Default is flat. |\n+| @ledgerManagerType@ | This parameter determines the type of ledger manager used to manage how ledgers are stored, manipulated, and garbage collected. See \"BookKeeper Internals\":./bookkeeperInternals.html for detailed info. Default value is flat. |\n | @zkLedgersRootPath@ | Root zookeeper path to store ledger metadata. Default is /ledgers. |\n \n+h3. Bookie recovery settings\n+\n+Currently bookie recovery tool needs a digest type and passwd to open ledgers to do recovery. Currently, bookkeeper assumes that all ledgers were created with the same DigestType and Password. In the future, it needs to know for each ledger, what was the DigestType and Password used to create it before opening it.\n \n+| @digestType@ | Digest type used to open ledgers from bookkie recovery tool. |\n+| @passwd@ | Password used to open ledgers from bookie recovery tool. |"},{"sha":"289fb3c7a228728b482c113eb019f2488eebeaf3","filename":"doc/bookkeeperJMX.textile","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperJMX.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperJMX.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperJMX.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,32 @@\n+Title:        BookKeeper JMX\n+Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License. You may\n+        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n+        .\n+        .        \n+        Unless required by applicable law or agreed to in writing,\n+        software distributed under the License is distributed on an \"AS IS\"\n+        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+        implied. See the License for the specific language governing permissions\n+        and limitations under the License.\n+        .\n+        .\n+\n+h1. JMX\n+\n+Apache BookKeeper has extensive support for JMX, which allows viewing and managing a BookKeeper cluster.\n+\n+This document assumes that you have basic knowledge of JMX. See \"Sun JMX Technology\":http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/ page to get started with JMX.\n+\n+See the \"JMX Management Guide\":http://java.sun.com/javase/6/docs/technotes/guides/management/agent.html for details on setting up local and remote management of VM instances. By default the included __bookkeeper__ script supports only local management - review the linked document to enable support for remote management (beyond the scope of this document).\n+\n+__Bookie Server__ is a JMX manageable server, which registers the proper MBeans during initialization to support JMX monitoring and management of the instance.\n+\n+h1. Bookie Server MBean Reference\n+\n+This table details JMX for a bookie server.\n+\n+| _.MBean | _.MBean Object Name | _.Description |\n+| BookieServer | BookieServer_<port> | Represents a bookie server. Note that the object name includes bookie port that the server listens on. It is the root MBean for bookie server, which includes statistics for a bookie server. E.g. number packets sent/received, and statistics for add/read operations. |\n+| Bookie | Bookie | Provide bookie statistics. Currently it just returns current journal queue length waiting to be committed. |\n+| LedgerCache | LedgerCache | Provide ledger cache statistics. E.g. number of page cached in page cache, number of files opened for ledger index files. |"},{"sha":"87ba67287e27c8483e64381486aa814c09db062c","filename":"doc/bookkeeperOverview.textile","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperOverview.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/bookkeeperOverview.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/bookkeeperOverview.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -165,3 +165,21 @@ p. Using the above data flush mechanism, it is safe for the _Sync Thread_ to ski\n p. As described above, _EntryLogger#flush_ is invoked in the following two cases:\n * in _Sync Thread_ : used to ensure entries added before _LastLogMark_ are persisted to disk.\n * in _ShutDown_ : used to ensure its buffered data persisted to disk to avoid data corruption with partial entries.\n+\n+h2. Data Compaction\n+\n+p. In bookie server, entries of different ledgers are interleaved in entry log files. A bookie server runs a _Garbage Collector_ thread to delete un-associated entry log files to reclaim disk space. If a given entry log file contains entries from a ledger that has not been deleted, then the entry log file would never be removed and the occupied disk space never reclaimed. In order to avoid such a case, a bookie server compacts entry log files in _Garbage Collector_ thread to reclaim disk space.\n+\n+p. There are two kinds of compaction running with different frequency, which are _Minor Compaction_ and _Major Compaction_. The differences of _Minor Compaction_ and _Major Compaction_ are just their threshold value and compaction interval.\n+\n+# _Threshold_ : Size percentage of an entry log file occupied by those undeleted ledgers. Default minor compaction threshold is 0.2, while major compaction threshold is 0.8.\n+# _Interval_ : How long to run the compaction. Default minor compaction is 1 hour, while major compaction threshold is 1 day.\n+\n+p. NOTE: if either _Threshold_ or _Interval_ is set to less than or equal to zero, then compaction is disabled.\n+\n+p. The data compaction flow in _Garbage Collector Thread_ is as follows:\n+\n+# _Garbage Collector_ thread scans entry log files to get their entry log metadata, which records a list of ledgers comprising an entry log and their corresponding percentages.\n+# With the normal garbage collection flow, once the bookie determines that a ledger has been deleted, the ledger will be removed from the entry log metadata and the size of the entry log reduced.\n+# If the remaining size of an entry log file reaches a specified threshold, the entries of active ledgers in the entry log will be copied to a new entry log file.\n+# Once all valid entries have been copied, the old entry log file is deleted."},{"sha":"b37d20c174d68c02a1d88cb6c9732733d672ae39","filename":"doc/hedwigConsole.textile","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/hedwigConsole.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/hedwigConsole.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigConsole.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab","patch":"@@ -0,0 +1,187 @@\n+Title:        Hedwig Console\n+Notice: Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License. You may\n+        obtain a copy of the License at \"http://www.apache.org/licenses/LICENSE-2.0\":http://www.apache.org/licenses/LICENSE-2.0.\n+        .\n+        .        \n+        Unless required by applicable law or agreed to in writing,\n+        software distributed under the License is distributed on an \"AS IS\"\n+        BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+        implied. See the License for the specific language governing permissions\n+        and limitations under the License.\n+        .\n+        .\n+\n+h1. Hedwig Console\n+\n+Apache Hedwig provides a console client, which allows users and administrators to interact with a hedwig cluster. \n+\n+h2. Connecting to hedwig cluster\n+\n+Hedwig console client is shipped with hedwig server package.\n+\n+p. To start the console client:\n+\n+ @hedwig-server/bin/hedwig console@\n+\n+p. By default, the console client connects to hub server on localhost. If you want the console client to connect to a different hub server, you can override following environment variables.\n+\n+| @HEDWIG_CONSOLE_SERVER_CONF@ | Path of a hub server configuration file. Override to make hedwig console client connect to correct zookeeper cluster. |\n+| @HEDWIG_CONSOLE_CLIENT_CONF@ | Path of a hedwig client configuration file. Override to make hedwig console client communicate with correct hub servers. |\n+\n+p. Once connected, you should see something like:\n+\n+<pre>\n+Connecting to zookeeper/bookkeeper using HedwigAdmin\n+\n+Connecting to default hub server localhost/127.0.0.1:4080\n+Welcome to Hedwig!\n+JLine support is enabled\n+JLine history support is enabled\n+[hedwig: (standalone) 16] \n+</pre>\n+\n+p. From the shell, type __help__ to get a list of commands that can be executed from the client:\n+\n+<pre>\n+[hedwig: (standalone) 16] help\n+HedwigConsole [options] [command] [args]\n+\n+Available commands:\n+        pub\n+        sub\n+        closesub\n+        unsub\n+        rmsub\n+        consume\n+        consumeto\n+        pubsub\n+        show\n+        describe\n+        readtopic\n+        set\n+        history\n+        redo\n+        help\n+        quit\n+        exit\n+\n+Finished 0.0020 s.\n+</pre>\n+\n+p. If you want to know detail usage for each command, type __help {command}__ in the shell. For example:\n+\n+<pre>\n+[hedwig: (standalone) 17] help pub\n+pub: Publish a message to a topic in Hedwig\n+usage: pub {topic} {message}\n+\n+  {topic}   : topic name.\n+              any printable string without spaces.\n+  {message} : message body.\n+              remaining arguments are used as message body to publish.\n+\n+Finished 0.0 s.\n+</pre>\n+\n+h2. Commands\n+\n+All the available commands provided in hedwig console could be categorized into three groups. They are __interactive commands__, __admin commands__, __utility commands__.\n+\n+h3. Interactive Commands\n+\n+p. Interactive commands are used by users to communicate with a hedwig cluster. They are __pub__, __sub__, __closesub__, __unsub__, __consume__ and __consumeto__.\n+\n+p. These commands are quite simple and have same semantics as the API provided in hedwig client.\n+\n+h3.  Admin Commands\n+\n+p. Admin commands are used by administrators to operate or debug a hedwig cluster. They are __show__, __describe__, __pubsub__ and __readtopic__.\n+\n+p. __show__ is used to list all available hub servers or topics in the cluster.\n+\n+p. You could use __show__ to list hub servers to know how many hub servers are alive in the cluster.\n+\n+<pre>\n+[hedwig: (standalone) 27] show hubs\n+Available Hub Servers:\n+        192.168.1.102:4080:9876 :       0\n+Finished 0.0040 s.\n+</pre>\n+\n+p. Also, you could use __show__ to list all topics. If you have a lot of topics on the clusters, this command will take a long time to run.\n+\n+<pre>\n+[hedwig: (standalone) 28] show topics\n+Topic List:\n+[mytopic]\n+Finished 0.0020 s.\n+</pre>\n+\n+p. To see the details of a topic, run __describe__. This shows the metadata of a topic, including topic owner, persistence info, subscriptions info.\n+\n+<pre>\n+[hedwig: (standalone) 43] describe topic mytopic\n+===== Topic Information : mytopic =====\n+\n+Owner : 192.168.1.102:4080:9876\n+\n+>>> Persistence Info <<<\n+Ledger 3 [ 1 ~ 9 ]\n+\n+>>> Subscription Info <<<\n+Subscriber mysub : consumeSeqId: local:0\n+\n+Finished 0.011 s.\n+</pre>\n+\n+p. When you are run the __describe__ command, you should keep in mind that __describe__ command reads the metadata from __ZooKeeper__ directly, so the subscription info might not be completely up to date due to the fact that hub servers update the subscription metadata lazily.\n+\n+p. The __readtopic__ command is useful to see which messages have not been consumed by the client.\n+\n+<pre>\n+[hedwig: (standalone) 46] readtopic mytopic\n+\n+>>>>> Ledger 3 [ 1 ~ 9] <<<<<\n+\n+---------- MSGID=LOCAL(1) ----------\n+MsgId:     LOCAL(1)\n+SrcRegion: standalone\n+Message:\n+\n+hello\n+\n+---------- MSGID=LOCAL(2) ----------\n+MsgId:     LOCAL(2)\n+SrcRegion: standalone\n+Message:\n+\n+hello 2\n+\n+---------- MSGID=LOCAL(3) ----------\n+MsgId:     LOCAL(3)\n+SrcRegion: standalone\n+Message:\n+\n+hello 3\n+\n+...\n+</pre>\n+\n+p. __pubsub__ is another useful command for administrators. It can be used to test availability and functionality of a cluster. It generates a temporary subscriber id with the current timestamp, subscribes to the given topic using generated subscriber id, publishes a message to given topic and testes whether the subscriber received the message.\n+\n+<pre>\n+[hedwig: (standalone) 48] pubsub testtopic testsub- 10 test message for availability\n+Starting PUBSUB test ...\n+Sub topic testtopic, subscriber id testsub--1338126964504\n+Pub topic testtopic : test message for availability-1338126964504\n+Received message : test message for availability-1338126964504\n+PUBSUB SUCCESS. TIME: 377 MS\n+Finished 0.388 s.\n+</pre>\n+\n+h3. Utility Commands\n+\n+p. Utility Commands are __help__, __history__, __redo__, __quit__ and __exit__.\n+\n+p. __quit__ and __exit__ are used to exit console, while __history__ and __redo__ are used to manage the history of commands executed in the shell."},{"sha":"4c694993a8f0599155f649a1fe5a190c7682edb4","filename":"doc/hedwigJMX.textile","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/hedwigJMX.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/hedwigJMX.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/hedwigJMX.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"1ada780d9bf58b5c60956f59a2875b798d11c47d","filename":"doc/index.textile","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/index.textile","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/doc/index.textile","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/doc/index.textile?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"23864427fee14d1cb3b1f422fe13b9462a0d97e6","filename":"hedwig-client/pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"1f41d3f046c6e7af4327abf8cc2e124043832e3d","filename":"hedwig-client/src/main/cpp/inc/hedwig/client.h","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/inc/hedwig/client.h","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/inc/hedwig/client.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/client.h?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fc8da58414320019ca0b888af55d626e7eb1328c","filename":"hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/inc/hedwig/subscribe.h?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"4b55f9ab8c1075a3e3db525d69123f435e165915","filename":"hedwig-client/src/main/cpp/lib/client.cpp","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/client.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/client.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/client.cpp?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"42fa2adf44224925fb8269017a5efb6470837463","filename":"hedwig-client/src/main/cpp/lib/data.cpp","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/data.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/data.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.cpp?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"d9d2ffdef79c75baab5c9446f296984ba7e2050f","filename":"hedwig-client/src/main/cpp/lib/data.h","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/data.h","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/data.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/data.h?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"6f7d02e41e10ac18ffdb6d008a1341a9504f432d","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.cpp?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"508a4957d60586258c05698de776cae98757d2a9","filename":"hedwig-client/src/main/cpp/lib/subscriberimpl.h","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/subscriberimpl.h","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/lib/subscriberimpl.h","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/lib/subscriberimpl.h?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5651e25269f5e9962fd6bd0f1c1196127095dc56","filename":"hedwig-client/src/main/cpp/log4cpp.conf","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/814f0ab6b4d43a35992e995c8abd804326ec633b/hedwig-client/src/main/cpp/log4cpp.conf","raw_url":"https://github.com/apache/bookkeeper/raw/814f0ab6b4d43a35992e995c8abd804326ec633b/hedwig-client/src/main/cpp/log4cpp.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/log4cpp.conf?ref=814f0ab6b4d43a35992e995c8abd804326ec633b"},{"sha":"13ee220ba72082ca9de48a7c7390894f5c1edc25","filename":"hedwig-client/src/main/cpp/scripts/log4cxx.conf","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/log4cxx.conf","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/log4cxx.conf","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/log4cxx.conf?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"83fd132fed15de2285c90729e169a8be90109175","filename":"hedwig-client/src/main/cpp/scripts/network-delays.sh","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/network-delays.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/network-delays.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/network-delays.sh?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"0851eaf83ee83b12ae968d561d50f040868cc6b5","filename":"hedwig-client/src/main/cpp/scripts/tester.sh","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/tester.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/scripts/tester.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/scripts/tester.sh?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"00cdd356b5f72676900a27665543af75fa7950ff","filename":"hedwig-client/src/main/cpp/test/Makefile.am","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/Makefile.am","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/Makefile.am","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/Makefile.am?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fbb1737d1099d65cb799836dfdaafc7f06c513d9","filename":"hedwig-client/src/main/cpp/test/main.cpp","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/main.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/main.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/main.cpp?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"45ba046653af2bcf8fbe818d52eae5f3f7a8a4cc","filename":"hedwig-client/src/main/cpp/test/messageboundtest.cpp","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/messageboundtest.cpp","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/cpp/test/messageboundtest.cpp","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/cpp/test/messageboundtest.cpp?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"8da6bd938e461965f5816157de8e8db39a214862","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/api/Subscriber.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"3bc167bfebad9c968094b5b7a1e057bdc5a74254","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkPublisher.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"73b6478775eb4f0e4512401af53efaa33c504ebe","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkSubscriber.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"64899235d73fe77adc258450f740493342d1190f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/BenchmarkUtils.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"cc5e93778a041724de8a050276fcc3497f14c21b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/benchmark/HedwigBenchmark.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fa2c6d6df41ab5164366d59bef579d25e2eb0c34","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/conf/ClientConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"8460de00012ed26fadae2210912cea0e9ea2986f","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/data/PubSubData.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5f468e6d3f5b05408946f3485861e8004d13f030","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/exceptions/AlreadyStartDeliveryException.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"6c79feebd80db01efe365cac9c736dc256299ecb","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeReconnectCallback.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"ba3ee65b57b1b811efef7dc7e22fbd1e3aa48a00","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/handlers/SubscribeResponseHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"db38fa06705052e4e87dc16befeea0ee7a983ef2","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ConnectCallback.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"0b99238b91f0049a41ef7d9d6f12e65393eb2d0d","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigClientImpl.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fac5b443150729ea2f5fd7c207b06cb6a3b25ad6","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigPublisher.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"e77e4211929afc299ab7c222a26596eff10cf6f0","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/HedwigSubscriber.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"c4affafa12bf0e334a4a2fba4b0df5c31ccacb79","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/ResponseHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"515e8f343134683f89807977b603166efd469f6b","filename":"hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/client/netty/WriteCallback.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"57232ba375d47db6d15dece98d6cd50dc77f0cad","filename":"hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/conf/AbstractConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"8bfdadaa97d0d22154906af16a9aefa47b375530","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/HedwigSocketAddress.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"269286caf9057204a4f9431843461812e60cbb8d","filename":"hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-client/src/main/java/org/apache/hedwig/util/PathUtils.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"c3716217331656aee72bed872d295b03b5048ee2","filename":"hedwig-protocol/pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"92f409d30e95f60512e764df8294005239ca1eda","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protocol/PubSubProtocol.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"e3e1fcd22abfeacec2d8e655f2f5b53f16af4f5a","filename":"hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/java/org/apache/hedwig/protoextensions/PubSubResponseUtils.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"b845c403e4af434c6b6e723c77bbcd03d9fe07de","filename":"hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-protocol/src/main/protobuf/PubSubProtocol.proto?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"213d6198e8a54e1be0c0f7afe9005fd6d64dca84","filename":"hedwig-server/bin/hedwig","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/bin/hedwig","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/bin/hedwig","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/bin/hedwig?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"256ada685dd79a1f6a5cef2e3d72201aa7ec6e1b","filename":"hedwig-server/conf/hwenv.sh","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/conf/hwenv.sh","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/conf/hwenv.sh","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/conf/hwenv.sh?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"bc9b38121050330ba720e54d392d36c883c9bd3f","filename":"hedwig-server/conf/log4j.properties","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/conf/log4j.properties","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/conf/log4j.properties","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/conf/log4j.properties?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"f1f7e72388e9c7e58b20c062d031bd69920d7c1c","filename":"hedwig-server/pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"c0db83ad45c6d6eebbe5221346a34db32adfc9dd","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/HedwigAdmin.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"1392e71c92f1bc7f13d2bff0c7fc0386ebbfb936","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigCommands.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"f3f7f974679fb9832bb5a464709b3c5998621720","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/HedwigConsole.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"c600a292549b51d9ae682d2dae0225ad27cf4f4a","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/JLineHedwigCompletor.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"a1481c7f32cf7989ac24795db820478c0954755e","filename":"hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/admin/console/ReadTopic.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"a37e336aa1715e2e811daef73594e17054939a6e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"3751092896f67dbf46e2daba6d9b49b458d4d70e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/common/TerminateJVMExceptionHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"a37211f1b1d6b6c2d9a96cc20b14aa9f40347cb2","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/ChannelEndPoint.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"51db8d60d2d98cb9cdf0e282bf4bef227ed6483c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/DeliveryManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"0a47ad5e7744bc5457a141659d541b4a6962fe7d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/delivery/FIFODeliveryManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"4189eb66e11887c207a4b9b1ff30285f8f244ae9","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/BaseHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5042a37eea8cbba676750750cda1cdad2e62194e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/ConsumeHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"2262d4f8d4efd546a0bc562ad1448aea99f1fef8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"ab8af29648879b66d0bd2f939dfe02dface4a630","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/NettyHandlerMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"3548b70d4d2471d1e0f53f1c8ac61eff8bcfa10f","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/PublishHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"76e0c14a3867432768b352096a86d4291ae7b30b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/SubscribeHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"1e679e174eef5f791bacd82479a5e7077b2d1f59","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/handlers/UnsubscribeHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"f0081d99b710564156532379508957019fb9854d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigJMXService.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"866a2173ac4a14db6f2e2a5202d4c45a13c7f3db","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanInfo.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"563cae8e1b5d87028b380047ddb2ca5ad5695bbb","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/jmx/HedwigMBeanRegistry.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"cb11955f778a5123f522712d5b06a5c118be2be5","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServer.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"db9befc44481b328ca18781478b1029ee8217c77","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"15e860fb04812d5d290170eb638e306e5a032c8d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/PubSubServerMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"641e187198fcaf65396b2a27ed97a3135656d251","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/ServerStats.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"44993225ca2e6d25b48f2c83f6c0c3b396aef0a7","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/netty/UmbrellaHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"c8a936ac26bb3110e47a4716bcd102a9d4d7b65d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"a8b9f743922c33f654b8ef3bd76f53a89d2cfbdc","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/LocalDBPersistenceManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"0ee0a9bc7af95d5d3c79f2da9240caf1d3ee3810","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/PersistenceManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"3cca541a0d1228f0e05b3c04da468cc1aaeb5eb8","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCache.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"1a4380ffe4bded4bb1f9d960cb0237840a931323","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"eba77a074d349e27b186e47c6c0edc925980ecf4","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/persistence/ReadAheadCacheMXBean.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5c200c13ecf0a3241aa2f2770a88968e82a4999d","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/HedwigProxy.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"051a7829022cfc2c78628cb1731e935f3371252e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyConfiguration.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"e77fbceb6c7473374a3d4d38c6c55ba92151910a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStartDeliveryHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"4ac23e7023fb306b620c93bf8e0e2cc1d01970ee","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/proxy/ProxyStopDeliveryHandler.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"70552516fab84719da35326ac8fe2381b0fb009a","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/HedwigHubSubscriber.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"060560d71089fe3a99b605f54b5039cdc851cef1","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/regions/RegionManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"3c2097683f4ff6a3eb6da41dc690416f5db11139","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/AbstractSubscriptionManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"b04863de58b7a2f225620fdde68ff2139208eb81","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/InMemorySubscriptionState.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"33271a96f3206bc3793fc6b566869787df55ff52","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/SubscriptionManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fa51bdfe9ed2429786577936767e672829496a0e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/subscriptions/TrueFilter.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"9353b7f2cdbd41639228232940aa1508f6094f9b","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/AbstractTopicManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"b4254488c6051fc096a2022f8af020aecc724d39","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TopicManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"24fcb788ea1f243e93c63d3add30dd573f55e75c","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/TrivialOwnAllTopicManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"f92101a22338ac085c988412e94c6ca667bf208e","filename":"hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"11ca3ff1e4b60a27fab7f7003e38dbdf380e0f06","filename":"hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/java/org/apache/hedwig/zookeeper/SafeAsyncCallback.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"129943423fb222d7a9fa659efe3007f3692d0a3b","filename":"hedwig-server/src/main/resources/LICENSE.bin.txt","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/LICENSE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/LICENSE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/resources/LICENSE.bin.txt?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"e9d967ef50eea173e03dbd6ae202b7c6513f83ce","filename":"hedwig-server/src/main/resources/NOTICE.bin.txt","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/NOTICE.bin.txt","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/NOTICE.bin.txt","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/resources/NOTICE.bin.txt?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"9d6d431bcd25133b2a5b034319d93d34df77a6df","filename":"hedwig-server/src/main/resources/findbugsExclude.xml","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/findbugsExclude.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/main/resources/findbugsExclude.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/main/resources/findbugsExclude.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"523ecdc5d2a2d92b3ee1a9ebba78868feff374a2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigHubTestBase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5c44a855dc69d87037341479febc04e16f50c8d9","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/HedwigRegionTestBase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"8a6122355dd29de0954d6427cc3ff82fdbcfa563","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/PubSubServerStandAloneTestBase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"2bc8d23af05bc73495dd497f0ae58dbe62ffebe2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/TestPubSubServerStartup.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"174d6bf51c9cd9f0e4acd7a06a1be67993d36623","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/delivery/StubDeliveryManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"02b45032ff4c1c18ae845f1681f2ae7c679b576c","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigHub.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"0b1851ebbc5c6c80fa25a0fd62e1dfb2783ae947","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/integration/TestHedwigRegion.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"5d64498b59540a84b702382940a578fcfca76961","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/netty/TestPubSubServer.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"6dddf47aa19eee1b6c2d714ec4c789aea7846b9b","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/BookKeeperTestBase.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"dec7ca773ccd2d2bf05d1de7e0617fcaf968cc49","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/MessageBoundedPersistenceTest.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"fecf86184a7472c2211590f4ef3f81e9761bb14e","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/StubPersistenceManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"216cd8aa70349da6adc004880e286975b8967f06","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestBookkeeperPersistenceManagerWhiteBox.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"114e0c5970d7eb93bd4546c6076db60f89a01cf2","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/persistence/TestDeadlock.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"d21eef3e45f106f2df3263e2fcbcadc2223d85e1","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestUpdateSubscriptionState.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"9558acf7b50ee5ca05984d2f25e0e57a8dcbe74f","filename":"hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/hedwig-server/src/test/java/org/apache/hedwig/server/subscriptions/TestZkSubscriptionManager.java?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"8ff14874c7d626f5ceea96b9efb427adbf543768","filename":"pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/pom.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/pom.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/pom.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"47edf5c77e17fd4a6fdd577f26c2294c43400fd3","filename":"src/assemble/bin.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/src/assemble/bin.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/src/assemble/bin.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/src/assemble/bin.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"},{"sha":"395f2b3834aa5776877adf6f9a94e1760b9d2e14","filename":"src/assemble/src.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/bookkeeper/blob/d867700500eed6404c2f2f54f1ebe7b385d067ab/src/assemble/src.xml","raw_url":"https://github.com/apache/bookkeeper/raw/d867700500eed6404c2f2f54f1ebe7b385d067ab/src/assemble/src.xml","contents_url":"https://api.github.com/repos/apache/bookkeeper/contents/src/assemble/src.xml?ref=d867700500eed6404c2f2f54f1ebe7b385d067ab"}]}

