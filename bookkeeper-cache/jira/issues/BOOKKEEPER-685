{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12668539","self":"https://issues.apache.org/jira/rest/api/2/issue/12668539","key":"BOOKKEEPER-685","fields":{"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12324601","id":"12324601","name":"4.2.2","archived":false,"released":true,"releaseDate":"2013-10-10"}],"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"348473","customfield_12312320":null,"customfield_12312321":null,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/1","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/blocker.svg","name":"Blocker","id":"1"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12312331":null,"customfield_12312332":null,"aggregatetimeoriginalestimate":null,"timeestimate":null,"customfield_12312330":null,"versions":[],"customfield_12311120":null,"customfield_12313826":null,"issuelinks":[],"customfield_12312339":null,"customfield_12313825":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"customfield_12312337":null,"customfield_12313823":null,"customfield_12312338":null,"customfield_12311920":null,"customfield_12313822":null,"customfield_12312335":null,"customfield_12313821":null,"customfield_12312336":null,"customfield_12313820":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"348770","customfield_12312823":null,"creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"subtasks":[],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"aggregateprogress":{"progress":0,"total":0},"customfield_12313520":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"customfield_12313924":null,"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/BOOKKEEPER-685/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12313920":null,"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"customfield_12314020":"{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3127366d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ce389d7[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33f29f37[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@432f15af[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6416f916[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2d220277[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@a0e3bc3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3137c540[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62ba5439[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5f36d3a3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@241d3ba5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2b8fe7a3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}","customfield_12314141":null,"customfield_12314140":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12311293","id":"12311293","key":"BOOKKEEPER","name":"Bookkeeper","projectTypeKey":"software","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12311293&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311293&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311293&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311293&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/14780","id":"14780","description":"BookKeeper","name":"BookKeeper"}},"aggregatetimespent":null,"customfield_12312520":null,"customfield_12314422":null,"customfield_12314421":null,"customfield_12314146":null,"customfield_12314420":null,"customfield_12314145":null,"customfield_12314144":null,"customfield_12314143":null,"resolutiondate":"2013-10-02T09:53:02.862+0000","workratio":-1,"customfield_12312923":null,"customfield_12312920":null,"customfield_12312921":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/BOOKKEEPER-685/watchers","watchCount":3,"isWatching":false},"created":"2013-09-13T19:15:03.614+0000","updated":"2013-10-02T09:53:02.904+0000","timeoriginalestimate":null,"description":"I discovered a race in the algorithm when I was forward porting to trunk.\n\n1) Thread1: flushed.set(false)\n2) Thread2: onRotateEntryLog() // flushed.set(true)\n3) Thread1: entryLogger addEntry L123-E456\n4) Thread1: offsets > max, waits for flushed, flushed is true(as set in 2), L123-E456 updated in ledger cache\n5) T2: L123 flushed out of ledger cache\n6) Crash\n\nThis will possible lose 1 entry. I've only reasoned this, not observed it, but it can happen.\n\nThe fix is pretty easy. EntryLoggerListener should notify with the point offset in the entry log it has synced as far as. \n      \n","customfield_10010":null,"timetracking":{},"customfield_12314523":null,"customfield_12314127":null,"customfield_12314522":null,"customfield_12314126":null,"customfield_12314521":null,"customfield_12314125":null,"customfield_12314520":null,"customfield_12314124":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12605290","id":"12605290","filename":"0001-BOOKKEEPER-685-Race-in-compaction-algorithm-from-BOO.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-26T17:44:25.073+0000","size":3289,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12605290/0001-BOOKKEEPER-685-Race-in-compaction-algorithm-from-BOO.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12606259","id":"12606259","filename":"BOOKKEEPER-685.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-10-02T05:26:04.818+0000","size":2729,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12606259/BOOKKEEPER-685.patch"}],"customfield_12314123":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12314122":null,"customfield_12314121":null,"customfield_12314120":null,"customfield_12314129":null,"customfield_12314524":null,"customfield_12314128":null,"summary":"Race in compaction algorithm from BOOKKEEPER-664","customfield_12314130":null,"customfield_12310291":null,"customfield_12310290":null,"customfield_12311024":null,"customfield_12314138":null,"customfield_12314137":null,"environment":null,"customfield_12314136":null,"customfield_12314135":null,"customfield_12311020":null,"customfield_12314134":null,"duedate":null,"customfield_12314132":null,"customfield_12314131":null,"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13767302","id":"13767302","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"the problem here is you set flush to false ahead of adding entry to entry logger. the better way is to set flushed to false after you add something to entry logger, no?\n\nI don't want to notify the offset until we really need it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-14T02:10:30.486+0000","updated":"2013-09-14T02:10:30.486+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13768185","id":"13768185","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"{quote}the problem here is you set flush to false ahead of adding entry to entry logger. the better way is to set flushed to false after you add something to entry logger, no?{quote}\nThis should work, though there could be a problem if onRotateEntryLog runs between the add and the set flushed, and then nothing more is added to the bookie. The compaction would hang until something in added to the bookie. This is a minor problem though. If the load is so low that compaction is hanging, then compaction isn't really necessary.\n\nOut of interest, why don't you want to notify the offset? I discovered this problem when I was looking at forward porting BOOKKEEPER-664 to trunk. As we don't flush before rotating in trunk, EntrylogListener needs a new call for onEntryLogFlush() so that we can ensure the entry has hit disk before updating the offset. I was thinking of perhaps using the offset as a parameter in #onEntryLogFlush() so that I can see how many offsets I can flush.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-16T09:05:21.945+0000","updated":"2013-09-16T09:05:21.945+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13768983","id":"13768983","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"{quote}\nOut of interest, why don't you want to notify the offset? \n{quote}\n\nnotifying offset doesn't help. the core part of EntryLogListener#onRotateEntryLog is that bookie should not checkpoint/flush current entry log. notifying offset doesn't (and should not) change this behavior, so GC thread still needs to wait until entry logger rotated to next file then do flushing.\n\n#onRotateEntryLog is not a good name for 4.2 branch. since in the 4.2 patch for BOOKKEEPER-664, onRotateEntryLog actually means entry logger file is flushed, so you don't need to call EntryLogger#flush in GCThread.\n\nBut in trunk, onRotateEntryLog just means that entry logger file is rotated, which doesn't mean that entry logger is flushed. so GCThread needs to call EntryLogger#checkpoint to flush the previous entry log files before flushing ledger cache. \n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-17T00:01:43.772+0000","updated":"2013-09-17T00:01:43.772+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13769361","id":"13769361","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"For 4.2 I was thinking of a solution like.\n{code}\nclass EntryLogListener {\n     void onRotateEntryLog();\n     void onEntryLogFlush(int offset);\n}\n{code}\n\nThen, when the scanner would implement only #onEntryLogFlush.\n\n{code}\n@Override\npublic void onEntryLogFlush(int flushedToOffset) {\n    for (Offset o : offsets) {\n        if (offset.getOffset() < offset) {\n             toFlush.add(o);\n        }\n    }\n    offsets.removeAll(toFlush);\n    for (Offset o : toFlush) {\n        ledgerCache.putEntryOffset(...);\n    }\n}\n{code}\nOr the work could be done in other thread after setting a shared flushedToOffset var. But in any case, this is how I was planning to use the offset. Trunk can just use #checkpoint as you said. This interface is as internals as they get in any case. It's not like we need to maintain any compatibility between branches on it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-17T09:26:02.305+0000","updated":"2013-09-17T09:26:02.305+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13769719","id":"13769719","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"I can image how you use offset, but I still don't understand the benefits of using offset.\n\nfor example, suppose GCThread is compacting entry log file X, which adding N entries in entry log file Y and adding M entries in entry log file (Y+1). the only benefit is that you could flush N entries using offset when entry logger rotated from Y to Y+1. *but, you still could not flush M entries until entry logger rotated from Y+1 to Y+2, which means you also could not delete entry log file X at this point, right?* so if bookie crashed at this point, bookie will still need to compact entry log file X again, both N and M entries. the new flushed N entries don't help anything.\n\nfrom the compaction perspective, I didn't see any difference between using offset and just setting flushed after adding entry. so why not keep the solution simpler and also keep solution consistent crossing 4.2.2 and 4.3.0? \n\nI don't have strong preferences. you could use offset in 4.2.2 if you want.  \n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-17T17:36:48.187+0000","updated":"2013-09-17T17:36:48.187+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13776159","id":"13776159","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"Thanks [~ikelly] for the finding. If I understood the problem statement, its the race between SyncThread flushing and the compaction logic.\n\nbq.the problem here is you set flush to false ahead of adding entry to entry logger. the better way is to set flushed to false after you add something to entry logger, no?\n\n[~hustlmsp], thanks for the simple proposal. In the approach, I could see one possible race condition, here #onRotateEntryLog can override 'flushed' to true, which was modified to false immediately after #addEntry. Could you please see the below execution sequence. If agree, just changing the flushed=false sequence would not really help us no?\n\nTh1 : addEntry\nTh2 : onRotateEntryLog\nTh1 : setFlushed=false\nTh2 : setFlushed=true\nTh1: offsets > max, waits for flushed, as flushed is true, will update in ledger cache\nTh2 : flushed out","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-24T09:47:40.977+0000","updated":"2013-09-24T09:47:40.977+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13776687","id":"13776687","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"[~rakeshr] \n\n{quote}\n#onRotateEntryLog is not a good name for 4.2 branch. since in the 4.2 patch for BOOKKEEPER-664, onRotateEntryLog actually means entry logger file is flushed,\n{quote}\n\nas my previous comment, your case will never happen. in 4.2 branch, if addEntry happened after #onRotateEntryLog, GCThread will setFlushed to false again; if addEntry happened before #onRotateEntryLog, this entry is already flushed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-24T20:10:32.714+0000","updated":"2013-09-24T20:10:32.714+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13777289","id":"13777289","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"I'm looking at the below code, where scannerFactory is also flushing the ledgerCache. In worst case, when the compaction thread finishes compaction and now if it sees flushed=true, then will flush out the ledgercache. Followed an immediate bookie crash can leads to trouble. Hope I'm not confusing you guys.\n{code}\nGarbageCollectorThread#doCompactEntryLogs(){\n            //....\n            compactEntryLog(scannerFactory, meta);\n             //....\n\n            // compaction finished, flush any outstanding offsets\n            scannerFactory.flush();\n             //...\n}\n{code}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-25T08:54:27.466+0000","updated":"2013-09-25T08:54:27.466+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13777945","id":"13777945","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"[~rakeshr] could you clarify it when you are saying it leads to trouble?\n\nthe only thing I could see is that it would flush index entries whose entries are not flushed to entry logger. but it doesn't matter, most of the time that journal would resecure them and even the corner case is handled by BOOKKEEPER-447.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-25T19:11:30.625+0000","updated":"2013-09-25T19:11:30.625+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778023","id":"13778023","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"Thanks Sijie for the reply.\n\nbq.could you clarify it when you are saying it leads to trouble?\n[~hustlmsp] as per my previous comments, I was thinking, just interchanging of #addEntry and flushed.set(false) sequence won't actually solve the issue. It can still enter into the execution flow of flush the ledger cache entries which are not yet flushed to the entry logger.\n\n{quote}\nthe only thing I could see is that it would flush index entries whose entries are not flushed to entry logger. {quote}\nBTW Ivan's problem statement is also saying about this case I guess. please correct me if am wrong:(\nIs this already handled by BOOKKEEPER-447?\n\n{quote}\nbut it doesn't matter, most of the time that journal would resecure them and even the corner case is handled by BOOKKEEPER-447.\n{quote}\nI didn't fully gone through the comments on BOOKKEEPER-447, as it has large discussion thread. By initial look at the patch, I'm seeing only it handles NoSuchEntryException and not recovering entries from Journal. I'll go through and try understanding the background.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-25T20:19:38.701+0000","updated":"2013-09-25T20:19:38.701+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778359","id":"13778359","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"{quote}\nas per my previous comments, I was thinking, just interchanging of #addEntry and flushed.set(false) sequence won't actually solve the issue. It can still enter into the execution flow of flush the ledger cache entries which are not yet flushed to the entry logger.\n{quote}\n\nI don't mean to discourage discussion. but when you are saying \"it leads trouble\", could you explain what kind of steps that would cause this issue and what is the effect? otherwise, it is unclear for people about what you are saying.\n\n{quote}\nBOOKKEEPER-447\n{quote}\n\nfirst of all, I shouldn't mention BOOKKEEPER-447 in this thread, since it is totally a different topic. but as you were raising an unclear question, I have to raise it as a background reference for all the corner cases I know.\n\nin order to make it clear for anyone who wants to join this discussion, please make sure you understand the background first.\n\n1) this jira is about the data loss during compaction, which is moving entries from one entry logger to the other entry logger. Those entries are not protected by journal, so GCThread needs to do compaction in following sequence to guarantee no data loss: a) adding entries to entry logger; b) add index entries to ledger cache; c) remove old entry log file only after the data added by a) & b) is flushed. And setFlushed after addEntry is to guarantee this sequence. (if you don't think it works, please provide the sequence to convince me.)\n\n2) the normal add entries are already protected by journal, so there is no data loss in that pipeline. \n\n3) the case in BOOKKEEPER-447 is an irrelative issue to 1) & 2), which an index entry is flushed before its journal entry flushed. It is an issue of invalid adds not data loss, which happens in normal add flow (e.g. a ledger is evicting from ledger cache and forced to write back to disk).\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-26T01:56:42.331+0000","updated":"2013-09-26T02:00:49.449+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778415","id":"13778415","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"Thanks [~hustlmsp] for the detailed explanation.\n\nbq.could you clarify it when you are saying it leads to trouble?\n\nCould you please see the following execution sequence:\n\nTh1 - compaction thread\nTh2 - SyncThread\n\n1) Th1: addEntry and sets flushed.set(false); // Consider that added entry is the 'last entry' of the last ledger participated in compaction. After this, compaction would move to flush.\n2) Th2: onRotateEntryLog and sets flushed.set(true);\n3) Th1: scannerFactory.flush(); // since it sees flushed==true, it will iterate over the offsets and flush out\n4) Th1: removeEntryLog\n5) server crashed\n\nIn the above sequence, I could see a possible loss of 'last entry' which is not flushed into the entry logger. Any thoughts?\n\nCompactionScannerFactory.java\n{code}\n        try {\n            // compaction finished, flush any outstanding offsets\n            scannerFactory.flush();\n        } catch (IOException ioe) {\n            LOG.error(\"Cannot flush compacted entries, skip removal\", ioe);\n            return;\n        }\n\n        // offsets have been flushed, its now safe to remove the old entrylogs\n        for (Long l : toRemove) {\n            removeEntryLog(l);\n        }\n{code}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-26T03:26:23.200+0000","updated":"2013-09-26T03:26:23.200+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778426","id":"13778426","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"{code}\nTh1 - compaction thread\nTh2 - SyncThread\n\n1) Th1: addEntry and sets flushed.set(false); // Consider that added entry is the 'last entry' of the last ledger participated in compaction. After this, compaction would move to flush.\n2) Th2: onRotateEntryLog and sets flushed.set(true);\n3) Th1: scannerFactory.flush(); // since it sees flushed==true, it will iterate over the offsets and flush out\n4) Th1: removeEntryLog\n5) server crashed\n\nIn the above sequence, I could see a possible loss of 'last entry' which is not flushed into the entry logger. Any thoughts?\n{code}\n\nfirst to clarify, th2 could never be SyncThread.\n\nin step2, when entry logger roate entry log, it already flushed previous entry log, which means the entry added by th1 is flushed. I don't see how it would loss the last entry. And again, I already explained your case in my previous comment (right after your first question).\n\n{quote}\nin 4.2 branch, if addEntry happened after #onRotateEntryLog, GCThread will setFlushed to false again; if addEntry happened before #onRotateEntryLog, this entry is already flushed.\n{quote}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-26T03:49:15.797+0000","updated":"2013-09-26T03:49:15.797+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778515","id":"13778515","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"[~hustlmsp] thats great!. I think, I got the concept of 'onRotateEntryLog' in 4.2.2 branch. Thanks again for helping out and knowledge sharing.\n\n+1 for your idea of 'set flushed to false after add something to entry logger'. Now I also feel its simple approach and would work in 4.2.2 branch.\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-26T06:31:01.656+0000","updated":"2013-09-26T06:31:01.656+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778828","id":"13778828","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"[~rakeshr] The case you describe is pretty much the case in the JIRA description. 1 single entry can be lost in the scenario.\n\n[~hustlmsp] set to false after flush will work. It will also create the possibility that the gc thread hangs it onRotateEntryLog sets flushed to true, between the addEntry and the setFalse, assuming no more entries are added. This is not a big problem, as there should be more entries added. There's a very very small case that the universe could conspire to make it so that we cannot add more entries to the entrylog without gc getting rid of a different entrylog, and if gc is waiting on a flush that never happens we have a deadlock.\n\n{quote}\nfor example, suppose GCThread is compacting entry log file X, which adding N entries in entry log file Y and adding M entries in entry log file (Y+1). the only benefit is that you could flush N entries using offset when entry logger rotated from Y to Y+1. but, you still could not flush M entries until entry logger rotated from Y+1 to Y+2, which means you also could not delete entry log file X at this point, right? so if bookie crashed at this point, bookie will still need to compact entry log file X again, both N and M entries. the new flushed N entries don't help anything.{quote}\nSo, in 4.2.2, flushing is not tied to rotation to start with. Flushing occurs at a regular interval if there is data to be flushed. So if N+M entries have been added to the entrylog, the sync thread will eventually flush them. The case you describe wont happen, because if N+M entries have been added to logs Y & Y+1, the entrylog _will_ flush them. I think this will be clearer in code. I'll make a patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-26T14:33:01.777+0000","updated":"2013-09-26T14:33:01.777+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778833","id":"13778833","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"[~ikelly] its really a good catch and difficult to findout if it happens in production.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-26T14:43:46.825+0000","updated":"2013-09-26T14:43:46.825+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778986","id":"13778986","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"{quote}\nwe cannot add more entries to the entrylog without gc getting rid of a different entrylog, and if gc is waiting on a flush that never happens we have a deadlock.\n{quote}\n\nplease clarify the sequence how it would introduce a deadlock. the normal add entries & flush flow will never wait for any gc activities. only gc is waiting for normal flush.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-26T17:18:09.863+0000","updated":"2013-09-26T17:18:09.863+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13778997","id":"13778997","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"Actually, it wouldn't deadlock now I think of it. The machine would go readonly. I was thinking of a scenario where the request handler thread would try to add while there's no disk space, and the gc thread could be trying to collect a log file, but stalled while waiting for something to be added to the entrylog so that flush would occur again. However, this would only cause the server to error the client request and go into readonly mode, which is fine.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-26T17:32:05.194+0000","updated":"2013-09-26T17:32:05.194+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13779010","id":"13779010","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"I realized the stall with the ordering change can easily be fixed just by checking isFlushRequired on EntryLogger. Attached patch to do same.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-09-26T17:45:17.188+0000","updated":"2013-09-26T17:45:17.188+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13779021","id":"13779021","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"Testing JIRA BOOKKEEPER-685\n\n\nPatch [0001-BOOKKEEPER-685-Race-in-compaction-algorithm-from-BOO.patch|https://issues.apache.org/jira/secure/attachment/12605290/0001-BOOKKEEPER-685-Race-in-compaction-algorithm-from-BOO.patch] downloaded at Thu Sep 26 17:51:27 UTC 2013\n\n----------------------------\n\n{color:red}-1{color} Patch failed to apply to head of branch\n\n----------------------------","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2013-09-26T17:54:07.177+0000","updated":"2013-09-26T17:54:07.177+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13779549","id":"13779549","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"+1 for the patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-09-27T01:29:34.271+0000","updated":"2013-09-27T01:29:34.271+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13780132","id":"13780132","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"body":"+1 patch looks fine. Just small suggestion, would be good to modify javadoc.\n{code}\n        /**\n         * Rotate a new entry log to write.\n         */\n        public void onEntryLogFlushed();\n{code}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rakeshr","name":"rakeshr","key":"rakeshr","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rakeshr&avatarId=29267","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rakeshr&avatarId=29267","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rakeshr&avatarId=29267","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rakeshr&avatarId=29267"},"displayName":"Rakesh Radhakrishnan","active":true,"timeZone":"Asia/Kolkata"},"created":"2013-09-27T17:39:02.105+0000","updated":"2013-09-27T17:39:02.105+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13783668","id":"13783668","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"body":"[~rakeshr] in general, this comment is good since this callback is only called when a new entry log is rotated. but as your suggestion, changed the comment, so we could move on 4.2.2 release.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hustlmsp","name":"hustlmsp","key":"hustlmsp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sijie Guo","active":true,"timeZone":"America/Los_Angeles"},"created":"2013-10-02T05:26:04.820+0000","updated":"2013-10-02T05:26:04.820+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13783680","id":"13783680","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"Testing JIRA BOOKKEEPER-685\n\n\nPatch [BOOKKEEPER-685.patch|https://issues.apache.org/jira/secure/attachment/12606259/BOOKKEEPER-685.patch] downloaded at Wed Oct  2 05:48:38 UTC 2013\n\n----------------------------\n\n{color:red}-1{color} Patch failed to apply to head of branch\n\n----------------------------","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2013-10-02T05:50:35.060+0000","updated":"2013-10-02T05:50:35.060+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12668539/comment/13783778","id":"13783778","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"body":"Committed revision 1528399.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ikelly","name":"ikelly","key":"ikelly","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Ivan Kelly","active":true,"timeZone":"Europe/Berlin"},"created":"2013-10-02T09:53:02.884+0000","updated":"2013-10-02T09:53:02.884+0000"}],"maxResults":25,"total":25,"startAt":0},"customfield_12311820":"0|i1o35r:","customfield_12314139":null}}

