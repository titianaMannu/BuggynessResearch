{"sha":"0243702b35421949b0353d3b08de04cfcdec7fea","node_id":"MDY6Q29tbWl0MjA2MzY0OjAyNDM3MDJiMzU0MjE5NDliMDM1M2QzYjA4ZGUwNGNmY2RlYzdmZWE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-07-28T19:53:13Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-07-28T19:53:13Z"},"message":"OPENJPA-293. Fixed problem with transactional state maintenance that was preventing lifecycle tests from passing.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@560601 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d184b4e87c445b851e00d0b5b248f704ceb4614c","url":"https://api.github.com/repos/apache/openjpa/git/trees/d184b4e87c445b851e00d0b5b248f704ceb4614c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0243702b35421949b0353d3b08de04cfcdec7fea","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0243702b35421949b0353d3b08de04cfcdec7fea","html_url":"https://github.com/apache/openjpa/commit/0243702b35421949b0353d3b08de04cfcdec7fea","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0243702b35421949b0353d3b08de04cfcdec7fea/comments","author":null,"committer":null,"parents":[{"sha":"b83db9322909051f0253d0fc5ec754f7afe0cbce","url":"https://api.github.com/repos/apache/openjpa/commits/b83db9322909051f0253d0fc5ec754f7afe0cbce","html_url":"https://github.com/apache/openjpa/commit/b83db9322909051f0253d0fc5ec754f7afe0cbce"}],"stats":{"total":180,"additions":147,"deletions":33},"files":[{"sha":"25f912e31cae767206c1676c1072f31ef5a43190","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":35,"deletions":13,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=0243702b35421949b0353d3b08de04cfcdec7fea","patch":"@@ -1584,7 +1584,7 @@ public void rollbackToSavepoint(String savepoint) {\n             Collection saved = save.rollback(_savepoints.values());\n             if (_savepointCache != null)\n                 _savepointCache.clear();\n-            if (_transCache != null) {\n+            if (hasTransactionalObjects()) {\n                 // build up a new collection of states\n                 TransactionalCache oldTransCache = _transCache;\n                 TransactionalCache newTransCache = new TransactionalCache\n@@ -2156,8 +2156,10 @@ protected void endTransaction(int status) {\n         _fc.setWriteLockLevel(LOCK_NONE);\n         _fc.setLockTimeout(-1);\n \n-        Collection transStates = _transCache;\n-        if (transStates == null)\n+        Collection transStates;\n+        if (hasTransactionalObjects())\n+            transStates = _transCache;\n+        else\n             transStates = Collections.EMPTY_LIST;\n \n         // fire after rollback/commit event\n@@ -3750,16 +3752,26 @@ protected Collection getManagedStates() {\n      * Return a copy of all transactional state managers.\n      */\n     protected Collection getTransactionalStates() {\n-        if (_transCache == null)\n+        if (!hasTransactionalObjects())\n             return Collections.EMPTY_LIST;\n         return _transCache.copy();\n     }\n \n+    /**\n+     * Whether or not there are any transactional objects in the current\n+     * persistence context. If there are any instances with untracked state,\n+     * this method will cause those instances to be scanned.\n+     */\n+    private boolean hasTransactionalObjects() {\n+        _cache.dirtyCheck();\n+        return _transCache != null;\n+    }\n+\n     /**\n      * Return a copy of all dirty state managers.\n      */\n     protected Collection getDirtyStates() {\n-        if (_transCache == null)\n+        if (!hasTransactionalObjects())\n             return Collections.EMPTY_LIST;\n \n         return _transCache.copyDirty();\n@@ -3823,7 +3835,7 @@ void addToTransaction(StateManagerImpl sm) {\n \n         lock();\n         try {\n-            if (_transCache == null)\n+            if (!hasTransactionalObjects())\n                 _transCache = new TransactionalCache(_orderDirty);\n             _transCache.addClean(sm);\n         } finally {\n@@ -3839,6 +3851,8 @@ void removeFromTransaction(StateManagerImpl sm) {\n         lock();\n         try {\n             if (_transCache != null)\n+                // intentional direct access; we don't want to recompute\n+                // dirtiness while removing instances from the transaction\n                 _transCache.remove(sm);\n             if (_derefCache != null && !sm.isPersistent())\n                 _derefCache.remove(sm);\n@@ -3866,7 +3880,7 @@ void setDirty(StateManagerImpl sm, boolean firstDirty) {\n             lock();\n             try {\n                 // cache dirty instance\n-                if (_transCache == null)\n+                if (!hasTransactionalObjects())\n                     _transCache = new TransactionalCache(_orderDirty);\n                 _transCache.addDirty(sm);\n \n@@ -4427,6 +4441,12 @@ public StateManagerImpl getById(Object oid, boolean allowNew) {\n          * Call this method when a new state manager initializes itself.\n          */\n         public void add(StateManagerImpl sm) {\n+            if (!sm.isIntercepting()) {\n+                if (_untracked == null)\n+                    _untracked = new HashSet();\n+                _untracked.add(sm);\n+            }\n+\n             if (!sm.isPersistent() || sm.isEmbedded()) {\n                 if (_embeds == null)\n                     _embeds = new ReferenceHashSet(ReferenceHashSet.WEAK);\n@@ -4453,12 +4473,6 @@ public void add(StateManagerImpl sm) {\n                     (orig.getManagedInstance()))).\n                     setFailedObject(sm.getManagedInstance());\n             }\n-\n-            if (!sm.isIntercepting()) {\n-                if (_untracked == null)\n-                    _untracked = new HashSet();\n-                _untracked.add(sm);\n-            }\n         }\n \n         /**\n@@ -4624,6 +4638,14 @@ public void clearNew() {\n             if (_news != null)\n                 _news.clear();\n         }\n+\n+        private void dirtyCheck() {\n+            if (_untracked == null)\n+                return;\n+\n+            for (Iterator iter = _untracked.iterator(); iter.hasNext(); )\n+                ((StateManagerImpl) iter.next()).dirtyCheck();\n+        }\n     }\n \n     /**"},{"sha":"cea42eb950bc58635673733e487da50e4ea6a028","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=0243702b35421949b0353d3b08de04cfcdec7fea","patch":"@@ -177,12 +177,13 @@ public boolean isFieldEqual(int field, Object current) {\n         // if the field is not available, assume that it has changed.\n         if (_saved == null || !_saved.get(field))\n             return false;\n-        if (!(_state.pcGetStateManager() instanceof OpenJPAStateManager))\n+        if (!(_state.pcGetStateManager() instanceof StateManagerImpl))\n             return false;\n \n-        OpenJPAStateManager sm = (OpenJPAStateManager)\n-            _state.pcGetStateManager();\n-        Object old = sm.fetch(field);\n+        StateManagerImpl sm = (StateManagerImpl) _state.pcGetStateManager();\n+        SingleFieldManager single = new SingleFieldManager(sm, sm.getBroker());\n+        sm.provideField(_state, single, field);\n+        Object old = single.fetchObjectField(field);\n         return current == old || current != null && current.equals(old);\n     }\n "},{"sha":"57f30cffac99f639b848c508c12f851e7c471eb2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":2,"deletions":5,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=0243702b35421949b0353d3b08de04cfcdec7fea","patch":"@@ -795,8 +795,8 @@ public void dirtyCheck() {\n         for (int i = 0; i < fmds.length; i++) {\n             // pk and version fields cannot be mutated; don't mark them\n             // as such. ##### validate?\n-            if (!fmds[i].isPrimaryKey()\n-                && !fmds[i].isVersion()) {\n+            if (!fmds[i].isPrimaryKey() && !fmds[i].isVersion()\n+                && _loaded.get(i)) {\n                 if (!saved.isFieldEqual(i, fetch(i))) {\n                     dirty(i);\n                 }\n@@ -811,9 +811,6 @@ private boolean needsDirtyCheck() {\n             return false;\n         if (isNew() && !isFlushed())\n             return false;\n-        if (getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD\n-            && !(isNew() && isFlushed()))\n-            return false;\n         return true;\n     }\n "},{"sha":"d1d05821a974e0d22306b7abb92b8bbe18620e30","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":105,"deletions":11,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/0243702b35421949b0353d3b08de04cfcdec7fea/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=0243702b35421949b0353d3b08de04cfcdec7fea","patch":"@@ -33,6 +33,8 @@\n import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n import org.apache.openjpa.meta.ClassMetaData;\r\n import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.event.AbstractLifecycleListener;\r\n+import org.apache.openjpa.event.LifecycleEvent;\r\n \r\n public abstract class AbstractUnenhancedClassTest\r\n     extends SingleEMFTestCase {\r\n@@ -60,6 +62,11 @@ public void setUp() {\n \r\n     protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\r\n \r\n+    private UnenhancedType newInstance(boolean sub) {\r\n+        return sub ? newUnenhancedSubclassInstance()\r\n+            : newUnenhancedInstance();\r\n+    }\r\n+\r\n     public void testMetaData() {\r\n         ClassMetaData meta = OpenJPAPersistence.getMetaData(emf,\r\n             getUnenhancedClass());\r\n@@ -136,15 +143,23 @@ private void getObjectIdHelper(boolean sub, boolean userDefined) {\n         assertNotNull(em.getObjectId(un));\r\n     }\r\n \r\n-    public void testOperations() {\r\n-        opsHelper(false);\r\n+    public void testOperationsOnUserDefined() {\r\n+        opsHelper(false, true);\r\n+    }\r\n+\r\n+    public void testSubclassOperationsOnUserDefined() {\r\n+        opsHelper(true, true);\r\n     }\r\n \r\n-    public void testSubclassOperations() {\r\n-        opsHelper(true);\r\n+    public void testOperationsOnOpenJPADefined() {\r\n+        opsHelper(false, false);\r\n     }\r\n \r\n-    private void opsHelper(boolean sub) {\r\n+    public void testSubclassOperationsOnOpenJPADefined() {\r\n+        opsHelper(true, false);\r\n+    }\r\n+\r\n+    private void opsHelper(boolean sub, boolean userDefined) {\r\n         OpenJPAEntityManager em = null;\r\n         try {\r\n             UnenhancedType un = newInstance(sub);\r\n@@ -154,22 +169,30 @@ private void opsHelper(boolean sub) {\n             em.persist(un);\r\n             un.setStringField(\"bar\");\r\n             assertEquals(\"bar\", un.getStringField());\r\n+            assertPersistenceContext(em, un, true, true, sub);\r\n             em.flush();\r\n+            assertPersistenceContext(em, un, true, true, sub);\r\n             assertTrue(un.getId() != 0);\r\n             UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\r\n             assertSame(un, un2);\r\n             em.getTransaction().commit();\r\n+            assertPersistenceContext(em, un, false, false, sub);\r\n             un2 = em.find(getUnenhancedClass(), un.getId());\r\n             assertSame(un, un2);\r\n-            em.close();\r\n \r\n-            em = emf.createEntityManager();\r\n+            if (!userDefined) {\r\n+                em.close();\r\n+                em = emf.createEntityManager();\r\n+            }\r\n+\r\n             un = em.find(getUnenhancedClass(), un.getId());\r\n             assertNotNull(un);\r\n-            assertTrue(un instanceof PersistenceCapable);\r\n+            if (!userDefined)\r\n+                assertTrue(un instanceof PersistenceCapable);\r\n             assertEquals(\"bar\", un.getStringField());\r\n             em.getTransaction().begin();\r\n             un.setStringField(\"baz\");\r\n+            assertPersistenceContext(em, un, true, true, sub);\r\n             assertEquals(\"baz\", un.getStringField());\r\n \r\n             if (sub)\r\n@@ -178,6 +201,11 @@ private void opsHelper(boolean sub) {\n             assertTrue(em.isDirty(un));\r\n             \r\n             em.getTransaction().commit();\r\n+\r\n+            // make sure that the values are still up-to-date after\r\n+            // the commit happens\r\n+            assertEquals(\"baz\", un.getStringField());\r\n+            \r\n             em.close();\r\n \r\n             em = emf.createEntityManager();\r\n@@ -196,6 +224,17 @@ private void opsHelper(boolean sub) {\n         }\r\n     }\r\n \r\n+    private void assertPersistenceContext(OpenJPAEntityManager em,\r\n+        UnenhancedType un, boolean transactional, boolean dirty, boolean sub) {\r\n+        assertEquals(transactional, em.getTransactionalObjects().contains(un));\r\n+        assertEquals(dirty, em.getDirtyObjects().contains(un));\r\n+        if (dirty) {\r\n+            Class cls = sub ? getUnenhancedSubclass() : getUnenhancedClass();\r\n+            assertTrue(em.getUpdatedClasses().contains(cls)\r\n+                || em.getPersistedClasses().contains(cls));\r\n+        }\r\n+    }\r\n+\r\n     public void testRelations() {\r\n         OpenJPAEntityManager em = emf.createEntityManager();\r\n         em.getTransaction().begin();\r\n@@ -480,9 +519,51 @@ private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\n         em.getTransaction().commit();\r\n     }\r\n \r\n-    private UnenhancedType newInstance(boolean sub) {\r\n-        return sub ? newUnenhancedSubclassInstance()\r\n-            : newUnenhancedInstance();\r\n+    public void testListenersOnUserDefinedInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        listenerHelper(true, false);\r\n+    }\r\n+\r\n+    public void testListenersOnUserDefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        listenerHelper(true, true);\r\n+    }\r\n+\r\n+    public void testListenersOnOpenJPADefinedInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        listenerHelper(false, false);\r\n+    }\r\n+\r\n+    public void testListenersOnOpenJPADefinedSubclassInstance()\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        listenerHelper(false, true);\r\n+    }\r\n+\r\n+    private void listenerHelper(boolean userDefined, boolean sub)\r\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n+        ListenerImpl listener = new ListenerImpl();\r\n+        emf.addLifecycleListener(listener, (Class[]) null);\r\n+        OpenJPAEntityManager em = emf.createEntityManager();\r\n+        UnenhancedType un = newInstance(sub);\r\n+        em.getTransaction().begin();\r\n+        em.persist(un);\r\n+        em.getTransaction().commit();\r\n+\r\n+        if (!userDefined) {\r\n+            em.close();\r\n+            em = emf.createEntityManager();\r\n+        }\r\n+\r\n+        listener.invoked = false;\r\n+\r\n+        un = em.find(getUnenhancedClass(), un.getId());\r\n+        em.getTransaction().begin();\r\n+        un.setStringField(\"updated\");\r\n+        em.getTransaction().commit();\r\n+        assertTrue(listener.invoked);\r\n+        em.close();\r\n+\r\n+        assertEquals(\"updated\", listener.stringField);\r\n     }\r\n \r\n     public void testGetMetaDataOfSubtype() {\r\n@@ -499,4 +580,17 @@ public void testGetMetaDataOfSubtype() {\n             Collections.singleton(getUnenhancedSubclass()), null);\r\n         assertSame(meta, OpenJPAPersistence.getMetaData(emf, subs.get(0)));\r\n     }\r\n+\r\n+    private class ListenerImpl\r\n+        extends AbstractLifecycleListener {\r\n+\r\n+        String stringField;\r\n+        boolean invoked;\r\n+\r\n+        @Override\r\n+        public void afterStore(LifecycleEvent event) {\r\n+            invoked = true;\r\n+            stringField = ((UnenhancedType) event.getSource()).getStringField();\r\n+        }\r\n+    }\r\n }\n\\ No newline at end of file"}]}

