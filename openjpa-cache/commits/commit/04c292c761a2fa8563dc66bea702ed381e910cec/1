{"sha":"04c292c761a2fa8563dc66bea702ed381e910cec","node_id":"MDY6Q29tbWl0MjA2MzY0OjA0YzI5MmM3NjFhMmZhODU2M2RjNjZiZWE3MDJlZDM4MWU5MTBjZWM=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-22T16:19:07Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-22T16:19:07Z"},"message":"OPENJPA-698: Decorate callable statements with logging. Added a new inner class LoggingConnection.LoggingCallableStatement which is almost a duplicate of LoggingPreparedStatement -- but existing hierarchy prohibits a direct inheritance. The logging with parameter tracking code needs to be refactored for a cleaner and less duplicated code, but has not be done with this commit.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@688111 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"91bdd1ff79f3b8c58c4d03c11d655fe40e7bbaef","url":"https://api.github.com/repos/apache/openjpa/git/trees/91bdd1ff79f3b8c58c4d03c11d655fe40e7bbaef"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/04c292c761a2fa8563dc66bea702ed381e910cec","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/04c292c761a2fa8563dc66bea702ed381e910cec","html_url":"https://github.com/apache/openjpa/commit/04c292c761a2fa8563dc66bea702ed381e910cec","comments_url":"https://api.github.com/repos/apache/openjpa/commits/04c292c761a2fa8563dc66bea702ed381e910cec/comments","author":null,"committer":null,"parents":[{"sha":"3ee2f9e40e7bed5c539a743885603dbd6e02252f","url":"https://api.github.com/repos/apache/openjpa/commits/3ee2f9e40e7bed5c539a743885603dbd6e02252f","html_url":"https://github.com/apache/openjpa/commit/3ee2f9e40e7bed5c539a743885603dbd6e02252f"}],"stats":{"total":456,"additions":452,"deletions":4},"files":[{"sha":"62ab28d0761bfab22afe11afa6794856edb11bfc","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/04c292c761a2fa8563dc66bea702ed381e910cec/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","raw_url":"https://github.com/apache/openjpa/raw/04c292c761a2fa8563dc66bea702ed381e910cec/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java?ref=04c292c761a2fa8563dc66bea702ed381e910cec","patch":"@@ -63,7 +63,7 @@ public DelegatingCallableStatement(CallableStatement stmnt,\n             _del = null;\n     }\n \n-    private ResultSet wrapResult(boolean wrap, ResultSet rs) {\n+    protected ResultSet wrapResult(boolean wrap, ResultSet rs) {\n         if (!wrap)\n             return rs;\n \n@@ -102,7 +102,7 @@ public boolean equals(Object other) {\n     }\n \n     public String toString() {\n-        StringBuffer buf = new StringBuffer(\"prepstmnt \").append(hashCode());\n+        StringBuffer buf = new StringBuffer(\"callstmnt \").append(hashCode());\n         appendInfo(buf);\n         return buf.toString();\n     }"},{"sha":"111eebc4dd90b968fc672624167434177cc8c351","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":450,"deletions":2,"changes":452,"blob_url":"https://github.com/apache/openjpa/blob/04c292c761a2fa8563dc66bea702ed381e910cec/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/04c292c761a2fa8563dc66bea702ed381e910cec/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=04c292c761a2fa8563dc66bea702ed381e910cec","patch":"@@ -24,6 +24,7 @@\n import java.sql.Array;\n import java.sql.BatchUpdateException;\n import java.sql.Blob;\n+import java.sql.CallableStatement;\n import java.sql.Clob;\n import java.sql.Connection;\n import java.sql.DatabaseMetaData;\n@@ -250,6 +251,16 @@ protected Statement createStatement(int type, int concurrency,\n             Statement stmnt = super.createStatement(type, concurrency, false);\n             return new LoggingStatement(stmnt);\n         }\n+        \n+        protected CallableStatement prepareCall(String sql, boolean wrap) \n+            throws SQLException {\n+        \ttry {\n+        \t\tCallableStatement stmt = super.prepareCall(sql, wrap);\n+        \t\treturn new LoggingCallableStatement(stmt, sql);\n+        \t} catch (SQLException se) {\n+        \t\tthrow wrap(se, sql);\n+        \t}\n+        }\n \n         public void commit() throws SQLException {\n             long start = System.currentTimeMillis();\n@@ -892,7 +903,7 @@ public int executeUpdate() throws SQLException {\n                             for (int i = 0; i < count.length; i++) {\n                                 // -3 is Statement.STATEMENT_FAILED, but is\n                                 // only available in JDK 1.4+\n-                                if (count[i] == -3) {\n+                                if (count[i] == Statement.EXECUTE_FAILED) {\n                                     index = i;\n                                     break;\n                                 }\n@@ -1295,5 +1306,442 @@ public boolean previous() throws SQLException {\n                 }\n             }\n         }\n-    }\n+        \n+        /**\n+         * CallableStatement decorated with logging.\n+         * Similar to {@link LoggingPreparedStatement} but can not be extended\n+         * due to the existing delegation hierarchy.\n+         */\n+        private class LoggingCallableStatement extends \n+            DelegatingCallableStatement {\n+            private final String _sql;\n+            private List _params = null;\n+            private List _paramBatch = null;\n+\n+            public LoggingCallableStatement(CallableStatement stmt, String sql) \n+                throws SQLException {\n+        \t\tsuper(stmt, LoggingConnection.this);\n+        \t\t_sql = sql;\n+        \t}\n+        \t\n+            protected ResultSet wrapResult(ResultSet rs, boolean wrap) {\n+                if (!wrap || rs == null)\n+                    return super.wrapResult(wrap, rs);\n+                return new LoggingResultSet(rs, this);\n+            }\n+\n+            protected ResultSet executeQuery(String sql, boolean wrap)\n+                throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.executeQuery(sql, wrap);\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public int executeUpdate(String sql) throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.executeUpdate(sql);\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public boolean execute(String sql) throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.execute(sql);\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            protected ResultSet executeQuery(boolean wrap) throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.executeQuery(wrap);\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public int executeUpdate() throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.executeUpdate();\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public int[] executeBatch() throws SQLException {\n+                logBatchSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.executeBatch();\n+                } catch (SQLException se) {\n+                    // if the exception is a BatchUpdateException, and\n+                    // we are tracking parameters, then set the current\n+                    // parameter set to be the index of the failed\n+                    // statement so that the ReportingSQLException will\n+                    // show the correct param\n+                    if (se instanceof BatchUpdateException\n+                        && _paramBatch != null && shouldTrackParameters()) {\n+                        int[] count = ((BatchUpdateException) se).\n+                            getUpdateCounts();\n+                        if (count != null && count.length <= _paramBatch.size())\n+                        {\n+                            int index = -1;\n+                            for (int i = 0; i < count.length; i++) {\n+                                // -3 is Statement.STATEMENT_FAILED, but is\n+                                // only available in JDK 1.4+\n+                                if (count[i] == Statement.EXECUTE_FAILED) {\n+                                    index = i;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // no -3 element: it may be that the server stopped\n+                            // processing, so the size of the count will be\n+                            // the index\n+                            if (index == -1)\n+                                index = count.length + 1;\n+\n+                            // set the current params to the saved values\n+                            if (index < _paramBatch.size())\n+                                _params = (List) _paramBatch.get(index);\n+                        }\n+                    }\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public boolean execute() throws SQLException {\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    return super.execute();\n+                } catch (SQLException se) {\n+                    throw wrap(se, LoggingCallableStatement.this);\n+                } finally {\n+                    logTime(start);\n+                    clearLogParameters(true);\n+                    handleSQLWarning(LoggingCallableStatement.this);\n+                }\n+            }\n+\n+            public void cancel() throws SQLException {\n+                if (_logs.isJDBCEnabled())\n+                    _logs.logJDBC(\"cancel \" + this + \": \" + _sql,\n+                        LoggingConnection.this);\n+\n+                super.cancel();\n+            }\n+\n+            public void setNull(int i1, int i2) throws SQLException {\n+                setLogParameter(i1, \"null\", null);\n+                super.setNull(i1, i2);\n+            }\n+\n+            public void setBoolean(int i, boolean b) throws SQLException {\n+                setLogParameter(i, b);\n+                super.setBoolean(i, b);\n+            }\n+\n+            public void setByte(int i, byte b) throws SQLException {\n+                setLogParameter(i, b);\n+                super.setByte(i, b);\n+            }\n+\n+            public void setShort(int i, short s) throws SQLException {\n+                setLogParameter(i, s);\n+                super.setShort(i, s);\n+            }\n+\n+            public void setInt(int i1, int i2) throws SQLException {\n+                setLogParameter(i1, i2);\n+                super.setInt(i1, i2);\n+            }\n+\n+            public void setLong(int i, long l) throws SQLException {\n+                setLogParameter(i, l);\n+                super.setLong(i, l);\n+            }\n+\n+            public void setFloat(int i, float f) throws SQLException {\n+                setLogParameter(i, f);\n+                super.setFloat(i, f);\n+            }\n+\n+            public void setDouble(int i, double d) throws SQLException {\n+                setLogParameter(i, d);\n+                super.setDouble(i, d);\n+            }\n+\n+            public void setBigDecimal(int i, BigDecimal bd)\n+                throws SQLException {\n+                setLogParameter(i, \"BigDecimal\", bd);\n+                super.setBigDecimal(i, bd);\n+            }\n+\n+            public void setString(int i, String s) throws SQLException {\n+                setLogParameter(i, \"String\", s);\n+                super.setString(i, s);\n+            }\n+\n+            public void setBytes(int i, byte[] b) throws SQLException {\n+                setLogParameter(i, \"byte[]\", b);\n+                super.setBytes(i, b);\n+            }\n+\n+            public void setDate(int i, Date d) throws SQLException {\n+                setLogParameter(i, \"Date\", d);\n+                super.setDate(i, d);\n+            }\n+\n+            public void setTime(int i, Time t) throws SQLException {\n+                setLogParameter(i, \"Time\", t);\n+                super.setTime(i, t);\n+            }\n+\n+            public void setTimestamp(int i, Timestamp t) throws SQLException {\n+                setLogParameter(i, \"Timestamp\", t);\n+                super.setTimestamp(i, t);\n+            }\n+\n+            public void setAsciiStream(int i1, InputStream is, int i2)\n+                throws SQLException {\n+                setLogParameter(i1, \"InputStream\", is);\n+                super.setAsciiStream(i1, is, i2);\n+            }\n+\n+            public void setUnicodeStream(int i1, InputStream is, int i2)\n+                throws SQLException {\n+                setLogParameter(i1, \"InputStream\", is);\n+                super.setUnicodeStream(i2, is, i2);\n+            }\n+\n+            public void setBinaryStream(int i1, InputStream is, int i2)\n+                throws SQLException {\n+                setLogParameter(i1, \"InputStream\", is);\n+                super.setBinaryStream(i1, is, i2);\n+            }\n+\n+            public void clearParameters() throws SQLException {\n+                clearLogParameters(false);\n+                super.clearParameters();\n+            }\n+\n+            public void setObject(int i1, Object o, int i2, int i3)\n+                throws SQLException {\n+                setLogParameter(i1, \"Object\", o);\n+                super.setObject(i1, o, i2, i3);\n+            }\n+\n+            public void setObject(int i1, Object o, int i2)\n+                throws SQLException {\n+                setLogParameter(i1, \"Object\", o);\n+                super.setObject(i1, o, i2);\n+            }\n+\n+            public void setObject(int i, Object o) throws SQLException {\n+                setLogParameter(i, \"Object\", o);\n+                super.setObject(i, o);\n+            }\n+\n+            public void addBatch() throws SQLException {\n+                if (_logs.isSQLEnabled())\n+                    _logs.logSQL(\"batching \" + this, LoggingConnection.this);\n+                long start = System.currentTimeMillis();\n+                try {\n+                    super.addBatch();\n+                    if (shouldTrackParameters()) {\n+                        // make sure our list is initialized\n+                        if (_paramBatch == null)\n+                            _paramBatch = new ArrayList();\n+                        // copy parameters since they will be re-used\n+                        if (_params != null)\n+                            _paramBatch.add(new ArrayList(_params));\n+                        else\n+                            _paramBatch.add(null);\n+                    }\n+                }\n+                finally {\n+                    logTime(start);\n+                }\n+            }\n+\n+            public void setCharacterStream(int i1, Reader r, int i2)\n+                throws SQLException {\n+                setLogParameter(i1, \"Reader\", r);\n+                super.setCharacterStream(i1, r, i2);\n+            }\n+\n+            public void setRef(int i, Ref r) throws SQLException {\n+                setLogParameter(i, \"Ref\", r);\n+                super.setRef(i, r);\n+            }\n+\n+            public void setBlob(int i, Blob b) throws SQLException {\n+                setLogParameter(i, \"Blob\", b);\n+                super.setBlob(i, b);\n+            }\n+\n+            public void setClob(int i, Clob c) throws SQLException {\n+                setLogParameter(i, \"Clob\", c);\n+                super.setClob(i, c);\n+            }\n+\n+            public void setArray(int i, Array a) throws SQLException {\n+                setLogParameter(i, \"Array\", a);\n+                super.setArray(i, a);\n+            }\n+\n+            public ResultSetMetaData getMetaData() throws SQLException {\n+                return super.getMetaData();\n+            }\n+\n+            public void setDate(int i, Date d, Calendar c) throws SQLException {\n+                setLogParameter(i, \"Date\", d);\n+                super.setDate(i, d, c);\n+            }\n+\n+            public void setTime(int i, Time t, Calendar c) throws SQLException {\n+                setLogParameter(i, \"Time\", t);\n+                super.setTime(i, t, c);\n+            }\n+\n+            public void setTimestamp(int i, Timestamp t, Calendar c)\n+                throws SQLException {\n+                setLogParameter(i, \"Timestamp\", t);\n+                super.setTimestamp(i, t, c);\n+            }\n+\n+            public void setNull(int i1, int i2, String s) throws SQLException {\n+                setLogParameter(i1, \"null\", null);\n+                super.setNull(i1, i2, s);\n+            }\n+\n+            protected void appendInfo(StringBuffer buf) {\n+                buf.append(\" \");\n+                if (_formatter != null) {\n+                    buf.append(SEP);\n+                    buf.append(_formatter.prettyPrint(_sql));\n+                    buf.append(SEP);\n+                } else {\n+                    buf.append(_sql);\n+                }\n+\n+                StringBuffer paramBuf = null;\n+                if (_params != null && !_params.isEmpty()) {\n+                    paramBuf = new StringBuffer();\n+                    for (Iterator itr = _params.iterator(); itr.hasNext();) {\n+                        paramBuf.append(itr.next());\n+                        if (itr.hasNext())\n+                            paramBuf.append(\", \");\n+                    }\n+                }\n+\n+                if (paramBuf != null) {\n+                    if (!_prettyPrint)\n+                        buf.append(\" \");\n+                    buf.append(\"[params=\").\n+                        append(paramBuf.toString()).append(\"]\");\n+                }\n+                super.appendInfo(buf);\n+            }\n+\n+            protected void clearLogParameters(boolean batch) {\n+                if (_params != null)\n+                    _params.clear();\n+                if (batch && _paramBatch != null)\n+                    _paramBatch.clear();\n+            }\n+\n+            private boolean shouldTrackParameters() {\n+                return _trackParameters || _logs.isSQLEnabled();\n+            }\n+\n+            private void setLogParameter(int index, boolean val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(boolean) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, byte val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(byte) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, double val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(double) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, float val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(float) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, int val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(int) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, long val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(long) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, short val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(short) \" + val);\n+            }\n+\n+            private void setLogParameter(int index, String type, Object val) {\n+                if (shouldTrackParameters())\n+                    setLogParameter(index, \"(\" + type + \") \" + val);\n+            }\n+\n+            private void setLogParameter(int index, String val) {\n+                if (_params == null)\n+                    _params = new ArrayList();\n+                while (_params.size() < index)\n+                    _params.add(null);\n+                if (val.length() > 80)\n+                    val = val.substring(0, 77) + \"...\";\n+                _params.set(index - 1, val);\n+            }\n+        }\n+    }   \n }"}]}

