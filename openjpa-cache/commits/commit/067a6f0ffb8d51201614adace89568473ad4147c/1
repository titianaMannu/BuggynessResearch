{"sha":"067a6f0ffb8d51201614adace89568473ad4147c","node_id":"MDY6Q29tbWl0MjA2MzY0OjA2N2E2ZjBmZmI4ZDUxMjAxNjE0YWRhY2U4OTU2ODQ3M2FkNDE0N2M=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-24T09:00:12Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-24T09:00:12Z"},"message":"OPENJPA-1253: support non-default uni-directional one to many map using foreign key strategy\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@818410 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"da66aeb0cb9627f805f4a8798087476e022a8222","url":"https://api.github.com/repos/apache/openjpa/git/trees/da66aeb0cb9627f805f4a8798087476e022a8222"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/067a6f0ffb8d51201614adace89568473ad4147c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/067a6f0ffb8d51201614adace89568473ad4147c","html_url":"https://github.com/apache/openjpa/commit/067a6f0ffb8d51201614adace89568473ad4147c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/067a6f0ffb8d51201614adace89568473ad4147c/comments","author":null,"committer":null,"parents":[{"sha":"65ff86ce24da411ddb7d910730d8df97a93eb808","url":"https://api.github.com/repos/apache/openjpa/commits/65ff86ce24da411ddb7d910730d8df97a93eb808","html_url":"https://github.com/apache/openjpa/commit/65ff86ce24da411ddb7d910730d8df97a93eb808"}],"stats":{"total":500,"additions":431,"deletions":69},"files":[{"sha":"2f0b6b8684a6b5f24d467cdfdc95b8d50804ce8b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":123,"deletions":53,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -86,18 +86,26 @@ public void selectValue(Select sel, ClassMapping val,\n         union.select(new Union.Selector() {\n             public void select(Select sel, int idx) {\n                 sel.select(_kcols);\n-                sel.whereForeignKey(field.getJoinForeignKey(),\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\n-                FieldMapping mapped = field.getMappedByMapping();\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n-                \n-                sel.select(vals[idx], field.getElementMapping().\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n-\n-                //### cheat: result joins only care about the relation path;\n-                //### thus we can use first mapping of union only\n-                if (idx == 0)\n-                    resJoins[1] = joins;\n+                if (isUni1ToMFK()) {\n+                    sel.whereForeignKey(field.getElementMapping().getForeignKey(),\n+                        sm.getObjectId(), field.getElementMapping().getDeclaredTypeMapping(), store);\n+                } else {\n+                    sel.whereForeignKey(field.getJoinForeignKey(),\n+                        sm.getObjectId(), field.getDefiningMapping(), store);\n+                }\n+                if (!isUni1ToMFK()) {\n+                    Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                    sel.select(vals[idx], field.getElementMapping().\n+                        getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                    //### cheat: result joins only care about the relation path;\n+                    //### thus we can use first mapping of union only\n+                    if (idx == 0)\n+                        resJoins[1] = joins;\n+                } else {\n+                    sel.select(vals[idx], field.getElementMapping().\n+                        getSelectSubclasses(), store, fetch, eagerMode, null);\n+                }\n             }\n         });\n         Result res = union.execute(store, fetch);\n@@ -138,11 +146,12 @@ public void map(boolean adapt) {\n         ValueMapping val = field.getElementMapping();\n         if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n             throw new MetaDataException(_loc.get(\"not-relation\", val));\n-        FieldMapping mapped = field.getMappedByMapping();\n         \n-        if (mapped != null) // map to the owner table\n-            handleMappedBy(adapt);\n-        else { \n+        FieldMapping mapped = field.getMappedByMapping();\n+        if ((isUni1ToMFK() && !isBi1ToMJT()) || mapped != null) { \n+            // map to the owner table\n+            handleMappedByForeignKey(adapt);\n+        } else if ((!isUni1ToMFK() && isBi1ToMJT()) || mapped == null){ \n             // map to a separate table\n             field.mapJoin(adapt, true);\n             if (val.getTypeMapping().isMapped()) {\n@@ -178,35 +187,47 @@ private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n         throws SQLException {\n         if (map == null || map.isEmpty())\n             return;\n+        \n         if (field.getMappedBy() != null)\n             return;\n \n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n-            sm);\n-\n+        Row row = null;\n+        if (!isUni1ToMFK()) {\n+            row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+            row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+                sm);\n+        }\n         ValueMapping key = field.getKeyMapping();\n         ValueMapping val = field.getElementMapping();\n         StoreContext ctx = store.getContext();\n         OpenJPAStateManager valsm;\n         Map.Entry entry;\n         for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n             entry = (Map.Entry) itr.next();\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n-                _kio, true);\n             valsm = RelationStrategies.getStateManager(entry.getValue(),\n                 ctx);\n-            val.setForeignKey(row, valsm);\n+            if (isUni1ToMFK()){\n+                row = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                    Row.ACTION_UPDATE, valsm, true);\n+                row.wherePrimaryKey(valsm);\n+                val.setForeignKey(row, sm);\n+            } else {\n+                val.setForeignKey(row, valsm);\n+            }\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                    _kio, true);\n             \n-            // So far we poplulated the key/value of each\n+            // So far we populated the key/value of each\n             // map element owned by the entity.\n             // In the case of ToMany, and both sides\n             // use Map to represent the relation,\n             // we need to populate the key value of the owner\n             // from the view point of the owned side\n             PersistenceCapable obj = sm.getPersistenceCapable();\n-            if (!populateKey(row, valsm, obj, ctx, rm, store))\n-                rm.flushSecondaryRow(row);\n+            if (!populateKey(row, valsm, obj, ctx, rm, store)) {\n+                if (!isUni1ToMFK())\n+                    rm.flushSecondaryRow(row);\n+            }\n         }\n     }\n     \n@@ -249,65 +270,114 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         boolean canChange = val.getForeignKey().isLogical();\n         Object mkey;\n         if (canChange && !change.isEmpty()) {\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_UPDATE);\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n-\n+            Row changeRow = null;\n+            if (!isUni1ToMFK()) {\n+                changeRow = rm.getSecondaryRow(field.getTable(),\n+                    Row.ACTION_UPDATE);\n+                changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            }\n+            \n             for (Iterator itr = change.iterator(); itr.hasNext();) {\n                 mkey = itr.next();\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n                 valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n-                val.setForeignKey(changeRow, valsm);\n-                rm.flushSecondaryRow(changeRow);\n+                if (isUni1ToMFK()){\n+                    changeRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                        Row.ACTION_UPDATE, valsm, true);\n+                    changeRow.wherePrimaryKey(valsm);\n+                    val.setForeignKey(changeRow, sm);\n+                } else {\n+                    val.setForeignKey(changeRow, valsm);\n+                }\n+                \n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                if (!isUni1ToMFK())\n+                    rm.flushSecondaryRow(changeRow);\n             }\n         }\n \n         // delete the removes\n         Collection rem = ct.getRemoved();\n         if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_DELETE);\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n-\n+            Row delRow = null;\n+            if (!isUni1ToMFK()) {\n+                delRow = rm.getSecondaryRow(field.getTable(),\n+                    Row.ACTION_DELETE);\n+                delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            }\n             for (Iterator itr = rem.iterator(); itr.hasNext();) {\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                mkey = itr.next();\n+                if (isUni1ToMFK()){\n+                    delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                        Row.ACTION_UPDATE, sm, true);\n+                    val.setForeignKey(delRow, null);\n+                } \n+                \n+                HandlerStrategies.where(key, mkey, store, delRow,\n                     _kcols);\n-                rm.flushSecondaryRow(delRow);\n+                if (!isUni1ToMFK())\n+                    rm.flushSecondaryRow(delRow);\n             }\n             if (!canChange && !change.isEmpty()) {\n                 for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    if (isUni1ToMFK()){\n+                        delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                            Row.ACTION_UPDATE, sm, true);\n+                        val.setForeignKey(delRow, null);\n+                    } \n+\n                     HandlerStrategies.where(key, itr.next(), store, delRow,\n                         _kcols);\n-                    rm.flushSecondaryRow(delRow);\n+                    if (!isUni1ToMFK())\n+                        rm.flushSecondaryRow(delRow);\n                 }\n             }\n         }\n \n         // insert the adds\n         Collection add = ct.getAdded();\n         if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_INSERT);\n-            addRow.setForeignKey(field.getJoinForeignKey(),\n-                field.getJoinColumnIO(), sm);\n-\n+            Row addRow = null;\n+            if (!isUni1ToMFK()) {\n+                addRow = rm.getSecondaryRow(field.getTable(),\n+                        Row.ACTION_INSERT);\n+                addRow.setForeignKey(field.getJoinForeignKey(),\n+                        field.getJoinColumnIO(), sm);\n+            }\n             for (Iterator itr = add.iterator(); itr.hasNext();) {\n                 mkey = itr.next();\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                if (isUni1ToMFK()){\n+                    addRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                        Row.ACTION_UPDATE, valsm, true);\n+                    addRow.wherePrimaryKey(valsm);\n+                    val.setForeignKey(addRow, sm);\n+                } else {\n+                    val.setForeignKey(addRow, valsm);\n+                }\n+                \n                 HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n                     _kio, true);\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n-                val.setForeignKey(addRow, valsm);\n-                rm.flushSecondaryRow(addRow);\n+                if (!isUni1ToMFK())\n+                    rm.flushSecondaryRow(addRow);\n             }\n             if (!canChange && !change.isEmpty()) {\n                 for (Iterator itr = change.iterator(); itr.hasNext();) {\n                     mkey = itr.next();\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                    if (isUni1ToMFK()){\n+                        addRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                            Row.ACTION_UPDATE, valsm, true);\n+                        addRow.wherePrimaryKey(valsm);\n+                        val.setForeignKey(addRow, sm);\n+                    } else {\n+                        val.setForeignKey(addRow, valsm);\n+                    }\n+                    \n                     HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n                         _kio, true);\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n-                        ctx);\n-                    val.setForeignKey(addRow, valsm);\n-                    rm.flushSecondaryRow(addRow);\n+                    if (!isUni1ToMFK())\n+                        rm.flushSecondaryRow(addRow);\n                 }\n             }\n         }\n@@ -353,7 +423,7 @@ public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n     \n     public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n-        if (field.getMappedBy() != null)\n+        if (field.getMappedBy() != null || isUni1ToMFK())\n             return;\n         super.delete(sm, store, rm);\n     }"},{"sha":"fd2f2ef7c2fc79e1e88e235ec3f509da7e3f0589","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"modified","additions":68,"deletions":2,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -22,6 +22,7 @@\n import java.util.Collection;\n import java.util.Map;\n \n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n@@ -31,6 +32,7 @@\n import org.apache.openjpa.jdbc.meta.FieldStrategy;\n import org.apache.openjpa.jdbc.meta.Strategy;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n@@ -42,6 +44,7 @@\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.MetaDataException;\n \n@@ -63,10 +66,44 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (MapTableFieldStrategy.class);\n \n+    private Boolean _isNonDefaultMappingAllowed = null;\n+    private Boolean _isBi1ToMJT = null;\n+    private Boolean _isUni1ToMFK = null;\n+\n     public FieldMapping getFieldMapping() {\n         return field;\n     }\n \n+    private void isNonDefaultMapping() {\n+        FieldMapping mapped = field.getMappedByMapping();\n+        if (isNonDefaultMappingAllowed() && \n+            field.getAssociationType() == FieldMetaData.ONE_TO_MANY &&\n+            field.getValueInfo().getColumns().size() > 0) {\n+            if (mapped != null) {\n+                _isBi1ToMJT = true;\n+                _isUni1ToMFK = false;\n+            } else {\n+                _isBi1ToMJT = false;\n+                _isUni1ToMFK = true;\n+            }\n+        } else {\n+            _isBi1ToMJT = false;\n+            _isUni1ToMFK = false;\n+        }\n+    }\n+    \n+    protected boolean isBi1ToMJT() {\n+        if (_isBi1ToMJT == null)\n+            isNonDefaultMapping();\n+        return _isBi1ToMJT;\n+    }\n+    \n+    protected boolean isUni1ToMFK() {\n+        if (_isUni1ToMFK == null)\n+            isNonDefaultMapping();\n+        return _isUni1ToMFK;\n+    }\n+\n     public ClassMapping[] getIndependentKeyMappings(boolean traverse) {\n         return (traverse) ? field.getKeyMapping().getIndependentTypeMappings()\n             : ClassMapping.EMPTY_MAPPINGS;\n@@ -108,8 +145,23 @@ public void map(boolean adapt) {\n             throw new MetaDataException(_loc.get(\"not-map\", field));\n         if (field.getKey().getValueMappedBy() != null)\n             throw new MetaDataException(_loc.get(\"mapped-by-key\", field));\n+\n+        // Non-default mapping Uni-/OneToMany/ForeignKey allows schema components\n+        if (isNonDefaultMappingAllowed() && \n+            field.getAssociationType() == FieldMetaData.ONE_TO_MANY && \n+            field.getMappedByMapping() == null)  \n+                return;\n         field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n     }\n+    \n+    protected boolean isNonDefaultMappingAllowed() {\n+        if (_isNonDefaultMappingAllowed == null) {\n+            OpenJPAConfiguration conf = field.getRepository().getConfiguration();\n+            _isNonDefaultMappingAllowed = field.getRepository().\n+                getMetaDataFactory().getDefaults().isNonDefaultMappingAllowed(conf);\n+        }\n+        return _isNonDefaultMappingAllowed;\n+    }\n \n     public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n@@ -182,12 +234,11 @@ protected ForeignKey getJoinForeignKey() {\n         return ClassMapping.EMPTY_MAPPINGS;\n     }\n     \n-    protected void handleMappedBy(boolean adapt){\n+    protected void handleMappedByForeignKey(boolean adapt){\n         boolean criteria = field.getValueInfo().getUseClassCriteria();\n         // check for named inverse\n         FieldMapping mapped = field.getMappedByMapping();\n         if (mapped != null) {\n-            field.getMappingInfo().assertNoSchemaComponents(field, !adapt);\n             field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n             mapped.resolve(mapped.MODE_META | mapped.MODE_MAPPING);\n \n@@ -228,6 +279,21 @@ protected void handleMappedBy(boolean adapt){\n                     field, mapped));\n \n             field.setUseClassCriteria(criteria);\n+            return;\n+        } else {\n+            // Uni-/OneToMany/ForeingKey\n+            ValueMapping val = field.getElementMapping();\n+            val.getValueInfo().setColumns(field.getValueInfo().getColumns());\n+            if (val.getTypeMapping().isMapped()) {\n+                ValueMappingInfo vinfo = val.getValueInfo();\n+                ForeignKey fk = vinfo.getTypeJoin(val, null, false, adapt);\n+                val.setForeignKey(fk);\n+                val.setColumnIO(vinfo.getColumnIO());\n+            } else\n+                RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\n+\n+            val.mapConstraints(\"value\", adapt);\n+            \n             return;\n         }\n /*"},{"sha":"069f2721ced0bf23a64aa831923609dd2662b837","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -375,14 +375,15 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n             }\n             \n             if (_biOneToManyJoinTable != -1) { // also need to update the join table\n-                PersistenceCapable inversePC = (PersistenceCapable)sm.fetchObject(_biOneToManyJoinTable);\n+                PersistenceCapable invPC = (PersistenceCapable)sm.fetchObject(_biOneToManyJoinTable);\n                 Row secondaryRow = null;\n-                if (inversePC != null) {\n+                if (invPC != null) {\n                     secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n                         Row.ACTION_INSERT);\n                     secondaryRow.setForeignKey(_biOneToManyElemFK, null, sm);\n                     secondaryRow.setForeignKey(_biOneToManyJoinFK, null, \n-                        (OpenJPAStateManager)inversePC.pcGetStateManager());\n+                        RelationStrategies.getStateManager(invPC,\n+                        store.getContext()));\n                 } else { \n                     secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n                             Row.ACTION_DELETE);"},{"sha":"c224fa024a645846a92e79d59756176926190400","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -185,7 +185,7 @@ public void map(boolean adapt) {\n         DBDictionary dict = field.getMappingRepository().getDBDictionary();\n         String keyName = null;\n         if (mapped != null) {         \n-            handleMappedBy(adapt);\n+            handleMappedByForeignKey(adapt);\n             keyName = dict.getValidColumnName(\"vkey\", field.getTable());\n          } else {\n             field.mapJoin(adapt, true);"},{"sha":"2d78df440306641ac57490a1e01a31203c0d2c5b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","status":"modified","additions":12,"deletions":10,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -214,16 +214,18 @@ public void populateForeignKeyColumn(ValueMapping vm, String name,\n         // otherwise jpa always uses <field>_<pkcol> for column name, even\n         // when only one col\n         if (target instanceof Column) {\n-            if (elem)\n-                name = vm.getFieldMapping().getName();\n-\n-            if (isRemoveHungarianNotation())\n-                name = removeHungarianNotation(name);\n-            \n-            name = dict.combineNames(name, ((Column)target).getName());\n-            \n-            // No need to check for uniqueness.\n-            name = dict.getValidColumnName(name, local, false);\n+            if (name == null) {\n+                name = col.getName();\n+            } else {\n+                if (elem)\n+                    name = vm.getFieldMapping().getName();\n+                if (isRemoveHungarianNotation())\n+                    name = removeHungarianNotation(name);\n+                name = dict.combineNames(name, ((Column)target).getName());\n+\n+                // No need to check for uniqueness.\n+                name = dict.getValidColumnName(name, local, false);\n+            }\n             col.setName(name);\n         }\n     }"},{"sha":"1e01fc05b0dcf445c3dc073d1dfd211b0f5d3d99","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_FK.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_FK.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_FK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_FK.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.compat;\n+\n+import java.util.List;\n+\n+import javax.persistence.*;\n+\n+@Entity\n+public class EntityC_U1M_Map_FK {\n+\n+    @Id\n+    @GeneratedValue\n+    private long id;\n+\n+    private String name;\n+\n+    public long getId() { \n+        return id; \n+    }\n+\n+    public String getName() { \n+        return name; \n+    }\n+\n+    public void setName(String name) { \n+        this.name = name; \n+    }\n+\n+    public int hashCode() {\n+        return name.hashCode() + (int)id;\n+    }\n+    \n+    public boolean equals(Object o) {\n+        if (!(o instanceof EntityC_U1M_Map_FK)) return false;\n+        EntityC_U1M_Map_FK c = (EntityC_U1M_Map_FK)o;\n+        if (!c.name.equals(name)) return false;\n+        if (c.id != id) return false;\n+        return true;\n+    }\n+}"},{"sha":"5b8d6d8be45132d4b0e95669f34677d9b5801b8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","status":"modified","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -392,7 +392,89 @@ public void crudBi1MJT(EntityManager em) {\n         em.clear();\n     }\n     \n+    public void testOneToManyMapRelation() {\n+        List<Class<?>> types = new ArrayList<Class<?>>();\n+        types.add(EntityC_U1M_Map_FK.class);\n+        types.add(Uni_1ToM_Map_FK.class);\n+        OpenJPAEntityManagerFactorySPI emf = createEMF2_0(types);\n+        EntityManager em = emf.createEntityManager();\n+        \n+        try {\n+            // trigger table creation\n+            em.getTransaction().begin();\n+            em.getTransaction().commit();\n+            assertSQLFragnments(sql, \"CREATE TABLE EntityC_U1M_Map_FK\", \"Uni1MFK_ID\", \"KEY0\");\n+            crudUni1MMapFK(em);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            fail(\"OneToMany mapping failed with exception message: \" + e.getMessage());\n+        } finally {\n+            em.close();\n+            emf.close();            \n+        }\n+    }\n \n+    public void crudUni1MMapFK(EntityManager em) {\n+        //create\n+        Uni_1ToM_Map_FK u = new Uni_1ToM_Map_FK();\n+        u.setName(\"uni1mfk\");\n+        Map<String, EntityC_U1M_Map_FK> cs = new HashMap<String, EntityC_U1M_Map_FK>();\n+        EntityC_U1M_Map_FK c1 = new EntityC_U1M_Map_FK();\n+        c1.setName(\"c1\");\n+        cs.put(c1.getName(), c1);\n+        EntityC_U1M_Map_FK c2 = new EntityC_U1M_Map_FK();\n+        c2.setName(\"c2\");\n+        cs.put(c2.getName(), c2);\n+        u.setEntityCs(cs);\n+        \n+        em.persist(u);\n+        em.persist(c1);\n+        em.persist(c2);\n+        em.getTransaction().begin();\n+        em.getTransaction().commit();\n+\n+        //update by adding a new C\n+        cs = u.getEntityCs();\n+        u.setName(\"uni1mfk_new\");\n+        EntityC_U1M_Map_FK c3 = new EntityC_U1M_Map_FK();\n+        c3.setName(\"c3\");\n+        cs.put(c3.getName(), c3);\n+        em.persist(c3);\n+\n+        em.getTransaction().begin();\n+        em.getTransaction().commit();\n+        \n+        // update by removing a c and then add this c to a new u\n+        em.getTransaction().begin();\n+        EntityC_U1M_Map_FK c4 = cs.remove(\"c1\");\n+        \n+        Uni_1ToM_Map_FK u2 = new Uni_1ToM_Map_FK();\n+        u2.setName(\"uni1mfk2\");\n+        Map<String, EntityC_U1M_Map_FK> cs2 = new HashMap<String, EntityC_U1M_Map_FK>();\n+        cs2.put(c4.getName(), c4);\n+        u2.setEntityCs(cs2);\n+        em.persist(u2);\n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        //query\n+        Query q = em.createQuery(\"SELECT u FROM Uni_1ToM_Map_FK u where u.name='uni1mfk_new'\");\n+        Uni_1ToM_Map_FK u1 = (Uni_1ToM_Map_FK)q.getSingleResult();\n+        assertEquals(u, u1);\n+        em.clear();\n+\n+        //find\n+        long id = u1.getId();\n+        Uni_1ToM_Map_FK findU = em.find(Uni_1ToM_Map_FK.class, id);\n+        assertEquals(u, findU);\n+        \n+        //remove\n+        em.getTransaction().begin();\n+        em.remove(findU);\n+        em.getTransaction().commit();\n+    }\n+    \n+    \n     private OpenJPAEntityManagerFactorySPI createEMF2_0(List<Class<?>> types) {\n         Map<Object,Object> map = new HashMap<Object,Object>();\n         map.put(\"openjpa.jdbc.JDBCListeners\", "},{"sha":"3531e32a6b1c98f5fa4a66f27d4f65317c78b90c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_FK.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_FK.java","raw_url":"https://github.com/apache/openjpa/raw/067a6f0ffb8d51201614adace89568473ad4147c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_FK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_FK.java?ref=067a6f0ffb8d51201614adace89568473ad4147c","patch":"@@ -0,0 +1,84 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.compat;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import javax.persistence.*;\r\n+\r\n+//non-default mapping\r\n+//Sec 11.1.36, Example 3: \r\n+//    Unidirectional One-to-Many association using a foreign key mapping\r\n+//    In Customer class:\r\n+//    @OneToMany(orphanRemoval=true)\r\n+//    @JoinColumn(name=\"CUST_ID\") // join column is in table for Order\r\n+//    public Set<Order> getOrders() {return orders;}\r\n+\r\n+@Entity\r\n+public class Uni_1ToM_Map_FK {\r\n+\r\n+    @Id\r\n+    @GeneratedValue\r\n+    private long id;\r\n+\r\n+    private String name;\r\n+\r\n+    @OneToMany(cascade = CascadeType.ALL, fetch=FetchType.EAGER)\r\n+    @JoinColumn(name=\"Uni1MFK_ID\")\r\n+    private Map<String, EntityC_U1M_Map_FK> entityCs = null;\r\n+    \r\n+    public long getId() { \r\n+        return id; \r\n+    }\r\n+\r\n+    public String getName() { \r\n+        return name; \r\n+    }\r\n+\r\n+    public void setName(String name) { \r\n+        this.name = name; \r\n+    }\r\n+\r\n+    public Map<String, EntityC_U1M_Map_FK> getEntityCs() { \r\n+        return entityCs; \r\n+    }\r\n+\r\n+    public void setEntityCs(Map<String, EntityC_U1M_Map_FK> entityCs) { \r\n+        this.entityCs = entityCs; \r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return name.hashCode();\r\n+    }\r\n+    \r\n+    public boolean equals(Object o) {\r\n+        if (!(o instanceof Uni_1ToM_Map_FK)) return false;\r\n+        Uni_1ToM_Map_FK b = (Uni_1ToM_Map_FK)o;\r\n+        if (!b.name.equals(name)) return false;\r\n+        if (b.entityCs.size() != entityCs.size()) return false;\r\n+        Collection<EntityC_U1M_Map_FK> coll = b.entityCs.values();\r\n+        for (EntityC_U1M_Map_FK c : coll) {\r\n+            if (!b.entityCs.get(c.getName()).equals(entityCs.get(c.getName())))\r\n+                return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+}\r"}]}

