{"sha":"0a96982e61dadc190d809790e41da922ba715bfb","node_id":"MDY6Q29tbWl0MjA2MzY0OjBhOTY5ODJlNjFkYWRjMTkwZDgwOTc5MGU0MWRhOTIyYmE3MTViZmI=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-10-30T23:23:11Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-10-30T23:23:11Z"},"message":"Fixed OPENJPA-70. Data caching + external modifications could result in stale data getting stuck in cache.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@469313 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"441c722b044bd7f8e42a289a24410038376688f5","url":"https://api.github.com/repos/apache/openjpa/git/trees/441c722b044bd7f8e42a289a24410038376688f5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0a96982e61dadc190d809790e41da922ba715bfb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0a96982e61dadc190d809790e41da922ba715bfb","html_url":"https://github.com/apache/openjpa/commit/0a96982e61dadc190d809790e41da922ba715bfb","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0a96982e61dadc190d809790e41da922ba715bfb/comments","author":null,"committer":null,"parents":[{"sha":"10a9e2e7ba58d25c13e628043726d379c8329630","url":"https://api.github.com/repos/apache/openjpa/commits/10a9e2e7ba58d25c13e628043726d379c8329630","html_url":"https://github.com/apache/openjpa/commit/10a9e2e7ba58d25c13e628043726d379c8329630"}],"stats":{"total":246,"additions":245,"deletions":1},"files":[{"sha":"a07d2fa6be97199d4b1f43e49b31851b2efca3d5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":74,"deletions":1,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=0a96982e61dadc190d809790e41da922ba715bfb","patch":"@@ -38,6 +38,7 @@\n import org.apache.openjpa.kernel.StoreQuery;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.OptimisticException;\n \n /**\n  * StoreManager proxy that delegates to a data cache when possible.\n@@ -503,8 +504,16 @@ private static Map addUnloaded(OpenJPAStateManager sm, BitSet fields,\n \n     public Collection flush(Collection states) {\n         Collection exceps = super.flush(states);\n-        if (!exceps.isEmpty() || _ctx.isLargeTransaction())\n+        if (exceps.isEmpty() && _ctx.isLargeTransaction())\n             return exceps;\n+        else if (!exceps.isEmpty()) {\n+            for (Iterator iter = exceps.iterator(); iter.hasNext(); ) {\n+                Exception e = (Exception) iter.next();\n+                if (e instanceof OptimisticException)\n+                    evictOptimisticLockFailure((OptimisticException) e);\n+            }\n+            return exceps;\n+        }\n \n         OpenJPAStateManager sm;\n         for (Iterator itr = states.iterator(); itr.hasNext();) {\n@@ -535,6 +544,70 @@ else if (sm.getPCState() == PCState.PDIRTY) {\n         return Collections.EMPTY_LIST;\n     }\n \n+    /**\n+     * Evict from the cache the OID (if available) that resulted in an\n+     * optimistic lock exception iff the\n+     * version information in the cache matches the version\n+     * information in the state manager for the failed\n+     * instance. This means that we will evict data from the\n+     * cache for records that should have successfully\n+     * committed according to the data cache but did not. The\n+     * only predictable reason that could cause this behavior\n+     * is a concurrent out-of-band modification to the\n+     * database that was not communicated to the cache. This\n+     * logic makes OpenJPA's data cache somewhat tolerant of\n+     * such behavior, in that the cache will be cleaned up as\n+     * failures occur.\n+     */\n+    private void evictOptimisticLockFailure(OptimisticException e) {\n+        Object o = ((OptimisticException) e).getFailedObject();\n+        OpenJPAStateManager sm = _ctx.getStateManager(o);\n+        ClassMetaData meta = sm.getMetaData();\n+\n+        // this logic could be more efficient -- we could aggregate\n+        // all the cache->oid changes, and then use\n+        // DataCache.removeAll() and less write locks to do the\n+        // mutation.\n+        DataCache cache = meta.getDataCache();\n+        cache.writeLock();\n+        try {\n+            DataCachePCData data = cache.get(sm.getId());\n+            boolean remove;\n+            switch (compareVersion(sm, sm.getVersion(), data.getVersion())) {\n+                case StoreManager.VERSION_LATER:\n+                case StoreManager.VERSION_SAME:\n+                    // This tx's current version is later than the data cache \n+                    // version. In this case, the commit should have succeeded. \n+                    // Remove the instance from cache in the hopes that the \n+                    // cache is out of sync.\n+                    remove = true;\n+                    break;\n+                case StoreManager.VERSION_EARLIER:\n+                    // This tx's current version is earlier than the data \n+                    // cache version. This is a normal optimistic lock failure. \n+                    // Do not clean up the cache; it probably already has the \n+                    // right values, and if not, it'll get cleaned up by a tx\n+                    // that fails in one of the other case statements.\n+                    remove = false;\n+                    break;\n+                case StoreManager.VERSION_DIFFERENT:\n+                    // The version strategy for the failed object does not\n+                    // store enough information to optimize for expected\n+                    // failures. Clean up the cache.\n+                    remove = true;\n+                    break;\n+                default:\n+                    // Unexpected return value. Remove to be future-proof.\n+                    remove = true;\n+                    break;\n+            }\n+            if (remove)\n+                cache.remove(sm.getId());\n+        } finally {\n+            cache.writeUnlock();\n+        }\n+    }\n+\n     public StoreQuery newQuery(String language) {\n         StoreQuery q = super.newQuery(language);\n "},{"sha":"0771d903b804d037a9b600685e180a122fcb34bd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","raw_url":"https://github.com/apache/openjpa/raw/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java?ref=0a96982e61dadc190d809790e41da922ba715bfb","patch":"@@ -0,0 +1,39 @@\n+package org.apache.openjpa.persistence.datacache;\r\n+\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.Id;\r\n+import javax.persistence.Version;\r\n+import javax.persistence.GeneratedValue;\r\n+\r\n+import javax.persistence.Table;\r\n+\r\n+@Entity\r\n+@Table(name=\"OPTIMISTIC_LOCK_INSTANCE\")\r\n+public class OptimisticLockInstance {\r\n+    @Id @GeneratedValue \r\n+    private int pk;\r\n+\r\n+    @Version \r\n+    private int oplock;\r\n+\r\n+    private String str;\r\n+\r\n+    protected OptimisticLockInstance() { }\r\n+\r\n+    public OptimisticLockInstance(String str) {\r\n+        this.str = str;\r\n+    }\r\n+\r\n+    public int getPK() {\r\n+        return pk;\r\n+    }\r\n+\r\n+    public int getOpLock() {\r\n+        return oplock;\r\n+    }\r\n+\r\n+    public String getStr() {\r\n+        return str;\r\n+    }\r\n+}\r\n+  \r"},{"sha":"68e9aab8e050fb98280b7856006c6f4e51827877","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","raw_url":"https://github.com/apache/openjpa/raw/0a96982e61dadc190d809790e41da922ba715bfb/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java?ref=0a96982e61dadc190d809790e41da922ba715bfb","patch":"@@ -0,0 +1,132 @@\n+package org.apache.openjpa.persistence.datacache;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityManagerFactory;\r\n+import javax.persistence.Persistence;\r\n+import javax.persistence.RollbackException;\r\n+import javax.persistence.LockModeType;\r\n+\r\n+import junit.framework.TestCase;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.PreparedStatement;\r\n+import java.sql.SQLException;\r\n+import javax.sql.DataSource;\r\n+\r\n+public class TestDataCacheOptimisticLockRecovery\r\n+    extends TestCase {\r\n+\r\n+    private EntityManagerFactory emf;\r\n+\r\n+    public void setUp() {\r\n+        Map options = new HashMap();\r\n+\r\n+        // turn on caching\r\n+        options.put(\"openjpa.DataCache\", \"true\");\r\n+        options.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\r\n+\r\n+        // ensure that OpenJPA knows about our type, so that \r\n+        // auto-schema-creation works\r\n+        options.put(\"openjpa.MetaDataFactory\",\r\n+            \"jpa(Types=\" + OptimisticLockInstance.class.getName() + \")\");\r\n+\r\n+        emf = Persistence.createEntityManagerFactory(\"test\", options);\r\n+\r\n+        EntityManager em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        em.createQuery(\"delete from OptimisticLockInstance\");\r\n+        em.getTransaction().commit();\r\n+        em.close();\r\n+    }\r\n+\r\n+    public void tearDown() {\r\n+        emf.close();\r\n+    }\r\n+\r\n+    public void testOptimisticLockRecovery() \r\n+        throws SQLException {\r\n+\r\n+        EntityManager em;\r\n+        \r\n+        // 1. get the instance into the cache via this insert\r\n+        em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        OptimisticLockInstance oli = new OptimisticLockInstance(\"foo\");\r\n+        try {\r\n+            em.persist(oli);\r\n+            em.getTransaction().commit();\r\n+        } finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+        }\r\n+        int pk = oli.getPK();\r\n+        em.close();\r\n+        \r\n+        // 2. get the oplock value for the instance after commit and\r\n+        // get a read lock to ensure that we check for the optimistic\r\n+        // lock column at tx commit.\r\n+        em = emf.createEntityManager();\r\n+        em.getTransaction().begin();\r\n+        oli = em.find(OptimisticLockInstance.class, pk);\r\n+        int firstOpLockValue = oli.getOpLock();\r\n+        em.lock(oli, LockModeType.READ);\r\n+\r\n+        // 2. make a change to the instance's optimistic lock column\r\n+        // via direct SQL in a separate transaction\r\n+        int secondOpLockValue = firstOpLockValue + 1;\r\n+\r\n+        DataSource ds = (DataSource) OpenJPAPersistence.cast(em)\r\n+            .getEntityManagerFactory().getConfiguration()\r\n+            .getConnectionFactory();\r\n+        Connection c = ds.getConnection();\r\n+        c.setAutoCommit(false);\r\n+        PreparedStatement ps = c.prepareStatement(\r\n+            \"UPDATE OPTIMISTIC_LOCK_INSTANCE SET OPLOCK = ? WHERE PK = ?\");\r\n+        ps.setInt(1, secondOpLockValue);\r\n+        ps.setInt(2, pk);\r\n+        assertEquals(1, ps.executeUpdate());\r\n+        c.commit();\r\n+        \r\n+        // 3. commit the transaction, catching the expected oplock\r\n+        // exception\r\n+        try {\r\n+            em.getTransaction().commit();\r\n+            fail(\"tx should have failed due to out-of-band oplock change\");\r\n+        } catch (RollbackException re) {\r\n+            // expected\r\n+        } finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+        }\r\n+\r\n+        // 4. obtain the object in a new persistence context and\r\n+        // assert that the oplock column is set to the one that\r\n+        // happened in the out-of-band transaction\r\n+        em.close();\r\n+        em = emf.createEntityManager();\r\n+        oli = em.find(OptimisticLockInstance.class, pk);\r\n+\r\n+        // If this fails, then the data cache has the wrong value.\r\n+        // This is what this test case is designed to exercise.\r\n+        assertEquals(\"data cache is not being cleared when oplock \"\r\n+            + \"violations occur\", secondOpLockValue, oli.getOpLock());\r\n+\r\n+        // 5. get a read lock on the instance and commit the tx; this\r\n+        // time it should go through\r\n+        em.getTransaction().begin();\r\n+        em.lock(oli, LockModeType.READ);\r\n+        try {\r\n+            em.getTransaction().commit();\r\n+        } catch (RollbackException e) {\r\n+            e.printStackTrace();\r\n+            throw e;\r\n+        } finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+        }\r\n+        em.close();\r\n+    }\r\n+}\r"}]}

