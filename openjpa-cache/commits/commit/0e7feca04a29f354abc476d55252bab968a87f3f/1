{"sha":"0e7feca04a29f354abc476d55252bab968a87f3f","node_id":"MDY6Q29tbWl0MjA2MzY0OjBlN2ZlY2EwNGEyOWYzNTRhYmM0NzZkNTUyNTJiYWI5NjhhODdmM2Y=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-04-24T23:34:46Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-04-24T23:34:46Z"},"message":"OPENJPA-219. Avoid Class.getDeclaredField() / Class.getDeclaredMethod() in Reflection, since they throw exceptions as a side-effect. Also contains assorted clean-up in ClassMetaData.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@532137 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5221d89dade4b6bcda9fd2f7446272bfc0155d3b","url":"https://api.github.com/repos/apache/openjpa/git/trees/5221d89dade4b6bcda9fd2f7446272bfc0155d3b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0e7feca04a29f354abc476d55252bab968a87f3f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0e7feca04a29f354abc476d55252bab968a87f3f","html_url":"https://github.com/apache/openjpa/commit/0e7feca04a29f354abc476d55252bab968a87f3f","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0e7feca04a29f354abc476d55252bab968a87f3f/comments","author":null,"committer":null,"parents":[{"sha":"6bad8ff71558cc7207a7a6098ef14f69a3e19863","url":"https://api.github.com/repos/apache/openjpa/commits/6bad8ff71558cc7207a7a6098ef14f69a3e19863","html_url":"https://github.com/apache/openjpa/commit/6bad8ff71558cc7207a7a6098ef14f69a3e19863"}],"stats":{"total":131,"additions":82,"deletions":49},"files":[{"sha":"64c5b759f1cd3ab5d872634f38c0173ae33dc3d6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":2,"deletions":9,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=0e7feca04a29f354abc476d55252bab968a87f3f","patch":"@@ -687,15 +687,8 @@ private ClassMetaData getPersistenceCapableOwner(String fieldName,\n         Class owner) {\n         // find the actual ancestor class that declares the field, then\n         // check if the class is persistent, and if the field is managed\n-        for (; !owner.getName().equals(Object.class.getName());\n-            owner = owner.getSuperclass()) {\n-            try {\n-                owner.getDeclaredField(fieldName);\n-                break;\n-            } catch (Exception e) {\n-            }\n-        }\n-        if (owner.getName().equals(Object.class.getName()))\n+        Field f = Reflection.findField(owner, fieldName, false);\n+        if (f == null)\n             return null;\n \n         // managed interface"},{"sha":"414e453ff30113465c637c47eff7108f0f5c2550","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","status":"modified","additions":63,"deletions":24,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","raw_url":"https://github.com/apache/openjpa/raw/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java?ref=0e7feca04a29f354abc476d55252bab968a87f3f","patch":"@@ -47,20 +47,20 @@\n     public static Method findGetter(Class cls, String prop, boolean mustExist) {\n         prop = StringUtils.capitalize(prop);\n         String name = \"get\" + prop;\n+        Method m;\n         try {\n-            for (Class c = cls; c != null && c != Object.class; \n+            // this algorithm searches for a get<prop> or is<prop> method in\n+            // a breadth-first manner.\n+            for (Class c = cls; c != null && c != Object.class;\n                 c = c.getSuperclass()) {\n-                try {\n-                    return c.getDeclaredMethod(name, (Class[]) null);\n-                } catch (NoSuchMethodException nsme) {\n-                    try {\n-                        Method m = c.getDeclaredMethod(\"is\" + prop, \n-                            (Class[]) null);\n-                        if (m != null && (m.getReturnType() == boolean.class\n-                            || m.getReturnType() == Boolean.class))\n-                            return m;\n-                    } catch (NoSuchMethodException nsme2) {\n-                    }\n+                m = getDeclaredMethod(c, name, null);\n+                if (m != null) {\n+                    return m;\n+                } else {\n+                    m = getDeclaredMethod(c, \"is\" + prop, null);\n+                    if (m != null && (m.getReturnType() == boolean.class\n+                        || m.getReturnType() == Boolean.class))\n+                        return m;\n                 }\n             }\n         } catch (Exception e) {\n@@ -89,14 +89,13 @@ public static Method findSetter(Class cls, String prop, boolean mustExist) {\n     public static Method findSetter(Class cls, String prop, Class param,\n         boolean mustExist) {\n         String name = \"set\" + StringUtils.capitalize(prop);\n-        Class[] params = new Class[] { param };\n+        Method m;\n         try {\n-            for (Class c = cls; c != null && c != Object.class; \n+            for (Class c = cls; c != null && c != Object.class;\n                 c = c.getSuperclass()) {\n-                try {\n-                    return c.getDeclaredMethod(name, params);\n-                } catch (NoSuchMethodException nsme) {\n-                }\n+                m = getDeclaredMethod(c, name, param);\n+                if (m != null)\n+                    return m;\n             }\n         } catch (Exception e) {\n             throw new GeneralException(e);\n@@ -108,17 +107,41 @@ public static Method findSetter(Class cls, String prop, Class param,\n     }\n \n     /**\n-     * Return the field with the given name, optionally throwing an exception \n+     * Invokes <code>cls.getDeclaredMethods()</code>, and returns the method\n+     * that matches the <code>name</code> and <code>param</code> arguments.\n+     * Avoids the exception thrown by <code>Class.getDeclaredMethod()</code>\n+     * for performance reasons. <code>param</code> may be null.\n+     *\n+     * @since 0.9.8\n+     */\n+    private static Method getDeclaredMethod(Class cls, String name,\n+        Class param) {\n+        Method[] methods = cls.getDeclaredMethods();\n+        for (int i = 0 ; i < methods.length; i++) {\n+    \t    if (name.equals(methods[i].getName())) {\n+                Class[] methodParams = methods[i].getParameterTypes();\n+                if (param == null && methodParams.length == 0)\n+                    return methods[i];\n+                if (param != null && methodParams.length == 1\n+                    && param.equals(methodParams[0]))\n+                    return methods[i];\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Return the field with the given name, optionally throwing an exception\n      * if none.\n      */\n     public static Field findField(Class cls, String name, boolean mustExist) {\n         try {\n-            for (Class c = cls; c != null && c != Object.class; \n+            Field f;\n+            for (Class c = cls; c != null && c != Object.class;\n                 c = c.getSuperclass()) {\n-                try {\n-                    return c.getDeclaredField(name);\n-                } catch (NoSuchFieldException nsfe) {\n-                }\n+                f = getDeclaredField(c, name);\n+                if (f != null)\n+                    return f;\n             }\n         } catch (Exception e) {\n             throw new GeneralException(e);\n@@ -129,6 +152,22 @@ public static Field findField(Class cls, String name, boolean mustExist) {\n         return null;\n     }\n \n+    /**\n+     * Invokes <code>cls.getDeclaredFields()</code>, and returns the field\n+     * that matches the <code>name</code> argument.  Avoids the exception\n+     * thrown by <code>Class.getDeclaredField()</code> for performance reasons.\n+     *\n+     * @since 0.9.8\n+     */\n+    private static Field getDeclaredField(Class cls, String name) {\n+        Field[] fields = cls.getDeclaredFields();\n+        for (int i = 0 ; i < fields.length; i++) {\n+    \t    if (name.equals(fields[i].getName()))\n+\t\t        return fields[i];\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Return the value of the given field in the given object.\n      */"},{"sha":"ada6e9a3a76d799f93872fb289e38484a401e48b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":17,"deletions":16,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/0e7feca04a29f354abc476d55252bab968a87f3f/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=0e7feca04a29f354abc476d55252bab968a87f3f","patch":"@@ -55,7 +55,6 @@\n import org.apache.openjpa.util.LongId;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.ObjectId;\n-import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.OpenJPAId;\n import org.apache.openjpa.util.ShortId;\n import org.apache.openjpa.util.StringId;\n@@ -117,6 +116,10 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (ClassMetaData.class);\n \n+    private static final FetchGroup[] EMPTY_FETCH_GROUP_ARRAY\n+        = new FetchGroup[0];\n+    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+\n     private MetaDataRepository _repos;\n     private transient ClassLoader _loader = null;\n \n@@ -784,8 +787,9 @@ public String getInterfacePropertyAlias(Class iface, String orig) {\n         synchronized (_ifaceMap) {\n             Map fields = (Map) _ifaceMap.get(iface);\n             if (fields == null)\n-                return new String[0];\n-            return (String[]) fields.keySet().toArray(new String[0]);\n+                return EMPTY_STRING_ARRAY;\n+            return (String[]) fields.keySet().toArray(\n+                new String[fields.size()]);\n         }\n     }\n     \n@@ -1397,15 +1401,12 @@ public Field getDetachedStateField() {\n         if (fieldName == null || SYNTHETIC.equals(fieldName))\n             return null;\n \n-        for (Class type = _type; type != null && type != Object.class;\n-            type = type.getSuperclass()) {\n-            try {\n-                return type.getDeclaredField(fieldName);\n-            } catch (Exception e) {\n-            }\n-        }\n-        throw new MetaDataException(_loc.get(\"no-detach-state\", fieldName,\n-            _type));\n+        Field f = Reflection.findField(_type, fieldName, false);\n+        if (f != null)\n+            return f;\n+        else\n+            throw new MetaDataException(\n+                _loc.get(\"no-detach-state\", fieldName, _type));\n     }\n \n     /**\n@@ -1823,7 +1824,7 @@ private void validateAppIdClass(boolean runtime) {\n                 ClassMetaData embed = pks[0].getEmbeddedMetaData();\n                 validateAppIdClassMethods(embed.getDescribedType());\n                 validateAppIdClassPKs(embed, embed.getFields(),\n-                    embed.getDescribedType(), runtime);\n+                    embed.getDescribedType());\n             }\n             return;\n         }\n@@ -1850,7 +1851,7 @@ private void validateAppIdClass(boolean runtime) {\n                 validateAppIdClassMethods(_objectId);\n \n             // make sure the app id class has all pk fields\n-            validateAppIdClassPKs(this, pks, _objectId, runtime);\n+            validateAppIdClassPKs(this, pks, _objectId);\n         }\n     }\n \n@@ -1904,7 +1905,7 @@ private void validateAppIdClassMethods(Class oid) {\n      * Validate that the primary key class has all pk fields.\n      */\n     private void validateAppIdClassPKs(ClassMetaData meta,\n-        FieldMetaData[] fmds, Class oid, boolean runtime) {\n+        FieldMetaData[] fmds, Class oid) {\n         if (fmds.length == 0 && !Modifier.isAbstract(meta.getDescribedType().\n             getModifiers()))\n             throw new MetaDataException(_loc.get(\"no-pk\", _type));\n@@ -2012,7 +2013,7 @@ private void validateDetachable() {\n      */\n     public FetchGroup[] getDeclaredFetchGroups() {\n         if (_fgs == null)\n-            _fgs = (_fgMap == null) ? new FetchGroup[0] : (FetchGroup[])\n+            _fgs = (_fgMap == null) ? EMPTY_FETCH_GROUP_ARRAY : (FetchGroup[])\n                 _fgMap.values().toArray(new FetchGroup[_fgMap.size()]); \n         return _fgs;\n     }"}]}

