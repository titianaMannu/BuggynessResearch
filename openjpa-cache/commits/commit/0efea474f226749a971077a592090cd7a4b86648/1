{"sha":"0efea474f226749a971077a592090cd7a4b86648","node_id":"MDY6Q29tbWl0MjA2MzY0OjBlZmVhNDc0ZjIyNjc0OWE5NzEwNzdhNTkyMDkwY2Q3YTRiODY2NDg=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-01-11T19:34:23Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-01-11T19:34:23Z"},"message":"OPENJPA-250: Committing to trunk. Submitted by Patrick Linskey, Simon Droscher, and Rick Curtis.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@898024 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b8e7dec68ac554b0275bbf2a24237fe5d8626f05","url":"https://api.github.com/repos/apache/openjpa/git/trees/b8e7dec68ac554b0275bbf2a24237fe5d8626f05"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0efea474f226749a971077a592090cd7a4b86648","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0efea474f226749a971077a592090cd7a4b86648","html_url":"https://github.com/apache/openjpa/commit/0efea474f226749a971077a592090cd7a4b86648","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0efea474f226749a971077a592090cd7a4b86648/comments","author":null,"committer":null,"parents":[{"sha":"5cef9cff179bc021c3a0a075dbb167db0aed3039","url":"https://api.github.com/repos/apache/openjpa/commits/5cef9cff179bc021c3a0a075dbb167db0aed3039","html_url":"https://github.com/apache/openjpa/commit/5cef9cff179bc021c3a0a075dbb167db0aed3039"}],"stats":{"total":934,"additions":550,"deletions":384},"files":[{"sha":"95862dbe967ead65eb6f70c0b127300ec18cd12e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":99,"deletions":62,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -104,8 +104,7 @@\n  *\n  * @author Abe White\n  */\n-public class MappingRepository\n-    extends MetaDataRepository {\n+public class MappingRepository extends MetaDataRepository {\n \n     private static final Localizer _loc = Localizer.forPackage\n         (MappingRepository.class);\n@@ -150,56 +149,83 @@ public void setMappingDefaults(MappingDefaults defaults) {\n      * Representation of the database schema.\n      */\n     public SchemaGroup getSchemaGroup() {\n-        if (_schema == null)\n-            _schema = ((JDBCConfiguration) getConfiguration()).\n-                getSchemaFactoryInstance().readSchema();\n-        return _schema;\n+        if (_locking) {\n+            synchronized (this) {\n+                if (_schema == null)\n+                    _schema = ((JDBCConfiguration) getConfiguration()).getSchemaFactoryInstance().readSchema();\n+                return _schema;\n+            }\n+        } else {\n+            if (_schema == null)\n+                _schema = ((JDBCConfiguration) getConfiguration()).getSchemaFactoryInstance().readSchema();\n+            return _schema;\n+        }\n     }\n \n     /**\n      * Representation of the database schema.\n      */\n     public void setSchemaGroup(SchemaGroup schema) {\n-        _schema = schema;\n+        if (_locking) {\n+            synchronized (this) {\n+                _schema = schema;\n+            }\n+        } else {\n+            _schema = schema;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n     public StrategyInstaller getStrategyInstaller() {\n-        if (_installer == null)\n-            _installer = new RuntimeStrategyInstaller(this);\n-        return _installer;\n+        if (_locking) {\n+            synchronized (this) {\n+                if (_installer == null)\n+                    _installer = new RuntimeStrategyInstaller(this);\n+                return _installer;\n+            }\n+        } else {\n+            if (_installer == null)\n+                _installer = new RuntimeStrategyInstaller(this);\n+            return _installer;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n     public void setStrategyInstaller(StrategyInstaller installer) {\n-        _installer = installer;\n+        if (_locking) {\n+            synchronized (this) {\n+                _installer = installer;\n+            }\n+        } else {\n+            _installer = installer;\n+        }\n     }\n \n     /**\n      * Return the query result mapping for the given name.\n      */\n-    public QueryResultMapping getQueryResultMapping(Class cls,\n-        String name, ClassLoader envLoader, boolean mustExist) {\n-        lock();\n-        try {\n-            QueryResultMapping res = getQueryResultMappingInternal(cls, name, envLoader);\n-            if (res == null && mustExist)\n-                throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n-            return res;\n-        } finally {\n-            unlock();\n+    public QueryResultMapping getQueryResultMapping(Class<?> cls, String name, ClassLoader loader, boolean mustExist) {\n+        QueryResultMapping res = null;\n+        if (_locking) {\n+            synchronized (this) {\n+                res = getQueryResultMappingInternal(cls, name, loader);\n+            }\n+        } else {\n+            res = getQueryResultMappingInternal(cls, name, loader);\n         }\n+        if (res == null && mustExist)\n+            throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n+        return res;\n     }\n \n     /**\n      * Returned the query result mapping with the given name.\n      */\n-    private QueryResultMapping getQueryResultMappingInternal(Class cls,\n-        String name, ClassLoader envLoader) {\n+    private QueryResultMapping getQueryResultMappingInternal(Class<?> cls, String name, ClassLoader envLoader) {\n         if (name == null)\n             return null;\n \n@@ -229,71 +255,79 @@ private QueryResultMapping getQueryResultMappingInternal(Class cls,\n     /**\n      * Return all cached query result mappings.\n      */\n-    public synchronized QueryResultMapping[] getQueryResultMappings() {\n-        lock();\n-        try {\n+    public QueryResultMapping[] getQueryResultMappings() {\n+        if (_locking) {\n+            synchronized (this) {\n+                Collection values = _results.values();\n+                return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+            }\n+        } else {\n             Collection values = _results.values();\n             return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Return the cached query result mapping with the given name, or null if\n      * none.\n      */\n-    public QueryResultMapping getCachedQueryResultMapping\n-        (Class cls, String name) {\n-        lock();\n-        try {\n+    public QueryResultMapping getCachedQueryResultMapping(Class cls, String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+            }\n+        } else {\n             return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Add a query result mapping.\n      */\n-    public QueryResultMapping addQueryResultMapping(Class cls,\n-        String name) {\n-        lock();\n-        try {\n-            QueryResultMapping res = new QueryResultMapping(name, this);\n-            res.setDefiningType(cls);\n-            _results.put(getQueryResultKey(res), res);\n-            return res;\n-        } finally {\n-            unlock();\n+    public QueryResultMapping addQueryResultMapping(Class cls, String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                return addQueryResultMappingInternal(cls, name);\n+            }\n+        } else {\n+            return addQueryResultMappingInternal(cls, name);\n         }\n     }\n \n+    private QueryResultMapping addQueryResultMappingInternal(Class cls, String name) {\n+        QueryResultMapping res = new QueryResultMapping(name, this);\n+        res.setDefiningType(cls);\n+        _results.put(getQueryResultKey(res), res);\n+        return res;\n+    }\n+\n     /**\n      * Remove a query result mapping.\n      */\n-    public boolean removeQueryResultMapping\n-        (QueryResultMapping res) {\n-        lock();\n-        try {\n+    public boolean removeQueryResultMapping(QueryResultMapping res) {\n+        if (_locking) {\n+            synchronized (this) {\n+                return _results.remove(getQueryResultKey(res)) != null;\n+            }\n+        } else {\n             return _results.remove(getQueryResultKey(res)) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Remove a query result mapping.\n      */\n-    public boolean removeQueryResultMapping(Class cls,\n-        String name) {\n-        lock();\n-        try {\n+    public boolean removeQueryResultMapping(Class cls, String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _results.remove(getQueryResultKey(cls, name)) != null;\n+            }\n+        } else {\n             if (name == null)\n                 return false;\n             return _results.remove(getQueryResultKey(cls, name)) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -334,14 +368,17 @@ public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n             mustExist);\n     }\n \n-    public synchronized void clear() {\n-        lock();\n-        try {\n+    public void clear() {\n+        if (_locking) {\n+            synchronized (this) {\n+                super.clear();\n+                _schema = null;\n+                _results.clear();\n+            }\n+        } else {\n             super.clear();\n             _schema = null;\n             _results.clear();\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -1208,7 +1245,7 @@ protected ValueHandler namedHandler(ValueMapping val) {\n                 val, name), e);\n         }\n     }\n-\n+    \n     /**\n      * Determine the default handler to use for the given value. Does\n      * not take into account the named handler, if any."},{"sha":"75669ab0e0da1e5b3e9cd4c29c7707cf10942a7c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -335,7 +335,7 @@ public OpenJPAConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         mapping = addString(\"Mapping\");\n         metaFactoryPlugin = addPlugin(\"MetaDataFactory\", false);\n \n-        metaRepositoryPlugin = addValue(new MetaDataRepositoryValue());\n+        metaRepositoryPlugin = (MetaDataRepositoryValue) addValue(new MetaDataRepositoryValue());\n \n         connectionFactory = addObject(\"ConnectionFactory\");\n         connectionFactory.setInstantiatingGetter(\"getConnectionFactory\");"},{"sha":"eafe288607d08ae31844ef08bf617c6808221d0b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -264,7 +264,7 @@ protected void addListeners(Broker broker) {\n      * Load the configured persistent classes list. Performed automatically\n      * whenever a broker is created.\n      */\n-    private void loadPersistentTypes(ClassLoader envLoader) {\n+    public void loadPersistentTypes(ClassLoader envLoader) {\n         // if we've loaded the persistent types and the class name list\n         // is empty, then we can simply return. Note that there is a\n         // potential threading scenario in which _persistentTypesLoaded is"},{"sha":"764c1e3daf1e8faa77960334505c1f9dbac5cdaf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":408,"deletions":298,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -33,7 +33,6 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeSet;\n-import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n@@ -49,6 +48,7 @@\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.MultiClassLoader;\n+import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.lib.util.StringDistance;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n@@ -148,9 +148,10 @@\n     // system listeners\n     private LifecycleEventManager.ListenerList _listeners = new LifecycleEventManager.ListenerList(3);\n \n-    private ReentrantLock _lock = null;\n     protected boolean _preload = false;\n-    protected boolean _noLock = false;\n+    protected boolean _preloadComplete = false;\n+    protected boolean _locking = true;\n+    private static final String PRELOAD_STR = \"Preload\";\n     \n     private boolean _reorderMetaDataResolution = false;\n \n@@ -292,96 +293,54 @@ public void setPreload(boolean l) {\n         _preload = l;\n     }\n \n-    /**\n-     * Sets whether this repository will use unguarded access. Unguarded access\n-     * can be safe if all metadata has been loaded at initialization.\n-     */\n-    public void setNoLock(boolean l) {\n-        _noLock = l;\n-    }\n-    \n-    /**\n-     * Affirms whether this repository will use unguarded access. Unguarded access\n-     * can be safe if all metadata has been loaded at initialization.\n-     */\n-    public boolean getNoLock() {\n-        return _noLock;\n-    }\n \n-    /**\n-     * Loads all the known persistent classes if {@linkplain #setPreload(boolean) early loading} \n-     * initialization has been set. The configuration must enlist all classes.\n-     * \n-     * <br>\n-     * If {@linkplain #setNoLock(boolean) no lock} has been set then uses unguarded access to\n-     * all internal data container structures.\n-     * If the openjpa.MetaDataRepository plugin value preload=false is set, this method will noop.\n-     * <p>\n-     * NOTE : This method is not thread safe and should ONLY be called by PersistenceProviderImpl.\n-     * \n-     * @see #getPersistentTypeNames(boolean, ClassLoader)\n+     /**\n+     * If the openjpa.MetaDataRepository plugin value Preload=true is set, this method will load all\n+     * MetaData for all persistent classes and will remove locking from this class. \n      */\n-    public void preload() {\n-        if (!_preload) {\n+    public synchronized void preload() {\n+        if (_preload == false) {\n             return;\n         }\n-        if (_log.isInfoEnabled()) {\n-            _log.info(_loc.get(_noLock ? \"repos-preload\" : \"repos-preload-nolock\"));\n-        }\n-\n-        // Remove locking and use unsynchronized maps.\n-        if (_noLock == true) {\n-            _oids = new HashMap<Class<?>, Class<?>>();\n-            _impls = new HashMap<Class<?>, Collection<Class<?>>>();\n-            _ifaces = new HashMap<Class<?>, Class<?>>();\n-            _aliases = new HashMap<String, List<Class<?>>>();\n-            _pawares = new HashMap<Class<?>, NonPersistentMetaData>();\n-            _nonMapped = new HashMap<Class<?>, NonPersistentMetaData>();\n-            _subs = new HashMap<Class<?>, List<Class<?>>>();\n-            _metamodel = new HashMap<Class<?>, Class<?>>();\n-\n-            _lock = null;\n+        // If pooling EMFs, this method may be invoked more than once. Only perform this work once.\n+        if (_preloadComplete == true) {\n+            return;\n         }\n \n         MultiClassLoader multi = AccessController.doPrivileged(J2DoPrivHelper.newMultiClassLoaderAction());\n         multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));\n         multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper\n-             .getClassLoaderAction(MetaDataRepository.class)));\n+            .getClassLoaderAction(MetaDataRepository.class)));\n \n         Set<String> classes = getPersistentTypeNames(false, multi);\n         if (classes == null || classes.size() == 0) {\n-            throw new MetaDataException(_loc.get(\"repos-preload-none\"));\n+            throw new MetaDataException(_loc.get(\"repos-initializeEager-none\"));\n         }\n-        if (_log.isTraceEnabled()) {\n-            _log.trace(_loc.get(\"repos-preloading\", this.getClass().getName(), classes.toString()));\n+        if (_log.isTraceEnabled() == true) {\n+            _log.trace(_loc.get(\"repos-initializeEager-found\", classes));\n         }\n \n+        List<Class<?>> loaded = new ArrayList<Class<?>>();\n         for (String c : classes) {\n             try {\n                 Class<?> cls = AccessController.doPrivileged((J2DoPrivHelper.getForNameAction(c, true, multi)));\n+                loaded.add(cls);\n+                // This call may be unnecessary?\n                 _factory.load(cls, MODE_ALL, multi);\n             } catch (PrivilegedActionException pae) {\n-                throw new MetaDataException(_loc.get(\"repos-preload-error\"), pae);\n+                throw new MetaDataException(_loc.get(\"repos-initializeEager-error\"), pae);\n             }\n         }\n-        \n-        // Hook this class in early so we can process registered classes and add them \n-        // to _aliases list.\n+        resolveAll(multi);\n+\n+        // Hook in this class as a listener and process registered classes list to populate _aliases\n+        // list.\n         PCRegistry.addRegisterClassListener(this);\n         processRegisteredClasses(multi);\n+        _locking = false;\n+        _preloadComplete = true;\n     }\n \n-    protected void lock() {\n-        if (_lock != null) {\n-            _lock.lock();\n-        }\n-    }\n-    \n-    protected void unlock() {\n-        if (_lock != null) {\n-            _lock.unlock();\n-        }\n-    }\n     \n     /**\n      * Return the metadata for the given class.\n@@ -393,9 +352,17 @@ protected void unlock() {\n      * @param mustExist\n      *            if true, throws a {@link MetaDataException} if no metadata is found\n      */\n-    public ClassMetaData getMetaData(Class cls, ClassLoader envLoader, boolean mustExist) {\n-        lock();\n-        try {\n+    public ClassMetaData getMetaData(Class<?> cls, ClassLoader envLoader, boolean mustExist) {\n+        if (_locking) {\n+            synchronized(this){\n+                return getMetaDataInternal(cls, envLoader, mustExist);    \n+            }\n+        } else {\n+            return getMetaDataInternal(cls, envLoader, mustExist);\n+        }\n+    }\n+\n+    private ClassMetaData getMetaDataInternal(Class<?> cls, ClassLoader envLoader, boolean mustExist) {\n             if (cls != null && DynamicPersistenceCapable.class.isAssignableFrom(cls))\n                 cls = cls.getSuperclass();\n \n@@ -417,9 +384,6 @@ public ClassMetaData getMetaData(Class cls, ClassLoader envLoader, boolean mustE\n             }\n             resolve(meta);\n             return meta;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -515,13 +479,21 @@ public String getClosestAliasName(String alias) {\n      * @since 1.1.0\n      */\n     public Collection<String> getAliasNames() {\n+        if (_locking) {\n+            synchronized (_aliases) {\n+                return getAliasNamesInternal();\n+            }\n+        } else {\n+            return getAliasNamesInternal();\n+        }\n+    }\n+\n+    private final Collection<String> getAliasNamesInternal() {\n         Collection<String> aliases = new HashSet<String>();\n-        synchronized (_aliases) {\n             for (Iterator<Map.Entry<String, List<Class<?>>>> iter = _aliases.entrySet().iterator(); iter.hasNext();) {\n                 Map.Entry<String, List<Class<?>>> e = iter.next();\n                 if (e.getValue() != null)\n                     aliases.add(e.getKey());\n-            }\n         }\n         return aliases;\n     }\n@@ -844,8 +816,16 @@ private boolean resolveMapping(ClassMetaData meta) {\n      * Return all the metadata instances currently in the repository.\n      */\n     public ClassMetaData[] getMetaDatas() {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized(this){\n+                return getMetaDatasInternal();    \n+            }\n+        } else {\n+            return getMetaDatasInternal();\n+        }\n+    }\n+    \n+    private ClassMetaData[] getMetaDatasInternal() {\n             // prevent concurrent mod errors when resolving one metadata\n             // introduces others\n             ClassMetaData[] metas = (ClassMetaData[]) _metas.values().toArray(new ClassMetaData[_metas.size()]);\n@@ -861,9 +841,6 @@ private boolean resolveMapping(ClassMetaData meta) {\n             metas = resolved.toArray(newClassMetaDataArray(resolved.size()));\n             Arrays.sort(metas);\n             return metas;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -908,14 +885,20 @@ public ClassMetaData addMetaData(Class<?> cls, int access, boolean ignoreTransie\n \n         // synchronize on this rather than the map, because all other methods\n         // that access _metas are synchronized on this\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized(this){\n+                return metasPutInternal(cls, meta);\n+            }\n+        } else {\n+            return metasPutInternal(cls, meta);\n+        }\n+            \n+    }\n+\n+    private ClassMetaData metasPutInternal(Class<?> cls, ClassMetaData meta){\n             if (_pawares.containsKey(cls))\n                 throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n             _metas.put(cls, meta);\n-        } finally {\n-            unlock();\n-        }\n         return meta;\n     }\n \n@@ -1048,9 +1031,17 @@ public boolean removeMetaData(ClassMetaData meta) {\n      * \n      * @return true if removed, false if not in this repository\n      */\n-    public boolean removeMetaData(Class cls) {\n-        lock();\n-        try {\n+    public boolean removeMetaData(Class<?> cls) {\n+        if(_locking){\n+            synchronized(this){\n+                return removeMetaDataInternal(cls);\n+            }\n+        }else{\n+            return removeMetaDataInternal(cls);\n+        }\n+    }\n+\n+    private boolean removeMetaDataInternal(Class<?> cls) {\n             if (cls == null)\n                 return false;\n             if (_metas.remove(cls) != null) {\n@@ -1060,16 +1051,21 @@ public boolean removeMetaData(Class cls) {\n                 return true;\n             }\n             return false;\n-        } finally {\n-            unlock();\n-        }\n     }\n-\n     /**\n      * Add the given metadata as declared interface implementation.\n      */\n     void addDeclaredInterfaceImpl(ClassMetaData meta, Class<?> iface) {\n-        synchronized (_impls) {\n+        if (_locking) {\n+            synchronized (_impls) {\n+                addDeclaredInterfaceImplInternal(meta, iface);\n+            }\n+        } else {\n+            addDeclaredInterfaceImplInternal(meta, iface);\n+        }\n+    }\n+\n+   private void addDeclaredInterfaceImplInternal(ClassMetaData meta, Class<?> iface) {\n             Collection<Class<?>> vals = _impls.get(iface);\n \n             // check to see if the superclass already declares to avoid dups\n@@ -1081,14 +1077,20 @@ void addDeclaredInterfaceImpl(ClassMetaData meta, Class<?> iface) {\n             }\n             addToCollection(_impls, iface, meta.getDescribedType(), false);\n         }\n-    }\n-\n     /**\n      * Set the implementation for the given managed interface.\n      */\n     void setInterfaceImpl(ClassMetaData meta, Class<?> impl) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                setInterfaceImplInternal(meta, impl);\n+            }\n+        } else {\n+            setInterfaceImplInternal(meta, impl);\n+        }\n+    }\n+\n+    private void setInterfaceImplInternal(ClassMetaData meta, Class<?> impl) {\n             if (!meta.isManagedInterface())\n                 throw new MetaDataException(_loc.get(\"not-managed-interface\", meta, impl));\n             _ifaces.put(meta.getDescribedType(), impl);\n@@ -1100,9 +1102,6 @@ void setInterfaceImpl(ClassMetaData meta, Class<?> impl) {\n                 sup.clearSubclassCache();\n                 addToCollection(_subs, sup.getDescribedType(), impl, true);\n                 sup = (ClassMetaData) sup.getPCSuperclassMetaData();\n-            }\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -1222,31 +1221,36 @@ private void resolveIdentityClass(Object oid) {\n         // get impls of given interface / abstract class\n         loadRegisteredClassMetaData(envLoader);\n         Collection<Class<?>> vals = _impls.get(cls);\n-        ClassMetaData meta;\n-        Collection<ClassMetaData> mapped = null;\n+        ClassMetaData[] mapped = null;\n         if (vals != null) {\n-            lock();\n-            try {\n-                for (Iterator<Class<?>> itr = vals.iterator(); itr.hasNext();) {\n-                    meta = getMetaData(itr.next(), envLoader, true);\n-                    if (meta.isMapped() || meta.getMappedPCSubclassMetaDatas().length > 0) {\n-                        if (mapped == null)\n-                            mapped = new ArrayList<ClassMetaData>(vals.size());\n-                        mapped.add(meta);\n-                    }\n+            if (_locking) {\n+                synchronized (vals) {\n+                    mapped = getImplementorMetaDatasInternal(vals, envLoader, mustExist);\n                 }\n-            } finally {\n-                unlock();\n+            } else {\n+                mapped = getImplementorMetaDatasInternal(vals, envLoader, mustExist);\n             }\n         }\n \n         if (mapped == null && mustExist)\n             throw new MetaDataException(_loc.get(\"no-meta\", cls));\n         if (mapped == null)\n             return EMPTY_METAS;\n-        return mapped.toArray(newClassMetaDataArray(mapped.size()));\n+        return mapped;\n     }\n \n+    private ClassMetaData[] getImplementorMetaDatasInternal(Collection<Class<?>> classes, ClassLoader envLoader,\n+        boolean mustExist) {\n+        Collection<ClassMetaData> mapped = new ArrayList<ClassMetaData>(classes.size());\n+        ClassMetaData meta = null;\n+        for (Class<?> c : classes) {\n+            meta = getMetaData(c, envLoader, true);\n+            if (meta.isMapped() || meta.getMappedPCSubclassMetaDatas().length > 0) {\n+                mapped.add(meta);\n+            }\n+        }\n+        return mapped.toArray(new ClassMetaData[]{});\n+    }\n     /**\n      * Gets the metadata corresponding to the given persistence-aware class. Returns null, if the\n      * given class is not registered as persistence-aware.\n@@ -1261,14 +1265,19 @@ public NonPersistentMetaData getPersistenceAware(Class<?> cls) {\n      * @return empty array if no class has been registered as pers-aware\n      */\n     public NonPersistentMetaData[] getPersistenceAwares() {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (_pawares) {\n+                return getPersistenceAwaresInternal();\n+            }\n+        } else {\n+            return getPersistenceAwaresInternal();\n+        }\n+    }\n+\n+    private NonPersistentMetaData[] getPersistenceAwaresInternal() {\n             if (_pawares.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n             return (NonPersistentMetaData[]) _pawares.values().toArray(new NonPersistentMetaData[_pawares.size()]);\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -1280,8 +1289,16 @@ public NonPersistentMetaData getPersistenceAware(Class<?> cls) {\n     public NonPersistentMetaData addPersistenceAware(Class<?> cls) {\n         if (cls == null)\n             return null;\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return addPersistenceAwareInternal(cls);\n+            }\n+        } else {\n+            return addPersistenceAwareInternal(cls);\n+        }\n+    }\n+\n+    private NonPersistentMetaData addPersistenceAwareInternal(Class<?> cls) {\n             if (_pawares.containsKey(cls))\n                 return (NonPersistentMetaData) _pawares.get(cls);\n             if (getCachedMetaData(cls) != null)\n@@ -1290,9 +1307,6 @@ public NonPersistentMetaData addPersistenceAware(Class<?> cls) {\n                 new NonPersistentMetaData(cls, this, NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);\n             _pawares.put(cls, meta);\n             return meta;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -1318,14 +1332,19 @@ public NonPersistentMetaData getNonMappedInterface(Class<?> iface) {\n      * @return empty array if no non-mapped interface has been registered.\n      */\n     public NonPersistentMetaData[] getNonMappedInterfaces() {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (_nonMapped) {\n+                return getNonMappedInterfacesInternal();\n+            }\n+        } else {\n+            return getNonMappedInterfacesInternal();\n+        }\n+    }\n+\n+    private NonPersistentMetaData[] getNonMappedInterfacesInternal() {\n             if (_nonMapped.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n             return (NonPersistentMetaData[]) _nonMapped.values().toArray(new NonPersistentMetaData[_nonMapped.size()]);\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -1339,8 +1358,16 @@ public NonPersistentMetaData addNonMappedInterface(Class<?> iface) {\n             return null;\n         if (!iface.isInterface())\n             throw new MetaDataException(_loc.get(\"not-non-mapped\", iface));\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return addNonMappedInterfaceInternal(iface);\n+            }\n+        } else {\n+            return addNonMappedInterfaceInternal(iface);\n+        }\n+    }\n+    \n+    private NonPersistentMetaData addNonMappedInterfaceInternal(Class<?> iface) {\n             if (_nonMapped.containsKey(iface))\n                 return (NonPersistentMetaData) _nonMapped.get(iface);\n             if (getCachedMetaData(iface) != null)\n@@ -1349,10 +1376,7 @@ public NonPersistentMetaData addNonMappedInterface(Class<?> iface) {\n                 new NonPersistentMetaData(iface, this, NonPersistentMetaData.TYPE_NON_MAPPED_INTERFACE);\n             _nonMapped.put(iface, meta);\n             return meta;\n-        } finally {\n-            unlock();\n         }\n-    }\n \n     /**\n      * Remove a non-mapped interface from the repository\n@@ -1368,11 +1392,19 @@ public boolean removeNonMappedInterface(Class<?> iface) {\n      * {@link MetaDataFactory MetaDataFactory}'s cache.\n      */\n     public void clear() {\n-        lock();\n-        try {\n             if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"clear-repos\", this));\n+            _log.trace(_loc.get(\"clear-repos\", this));\n+        if (_locking) {\n+            synchronized (this) {\n+                clearInternal();\n+            }\n+        } else {\n+            clearInternal();\n+        }\n+    }\n \n+    private void clearInternal(){\n+        // Recreating these datastructures is probably faster than calling clear. Future change?\n             _metas.clear();\n             _oids.clear();\n             _subs.clear();\n@@ -1384,11 +1416,7 @@ public void clear() {\n             _aliases.clear();\n             _pawares.clear();\n             _nonMapped.clear();\n-        } finally {\n-            unlock();\n-        }\n     }\n-\n     /**\n      * Return the set of configured persistent classes, or null if the user did not configure any.\n      * \n@@ -1399,18 +1427,33 @@ public void clear() {\n      *            the class loader to use, or null for default\n      */\n     public Set<String> getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {\n-        lock();\n-        try {\n-            return _factory.getPersistentTypeNames(devpath, envLoader);\n-        } finally {\n-            unlock();\n+        if (_locking) {\n+            synchronized (this) {\n+                return getPersistentTypeNamesInternal(devpath, envLoader);\n+            }\n+        } else {\n+            return getPersistentTypeNamesInternal(devpath, envLoader);\n         }\n     }\n \n-    public synchronized Collection<Class<?>> loadPersistentTypes(boolean devpath, ClassLoader envLoader) {\n+    private Set<String> getPersistentTypeNamesInternal(boolean devpath, ClassLoader envLoader) {\n+        return _factory.getPersistentTypeNames(devpath, envLoader);\n+    }\n+    /**\n+     * Load the persistent classes named in configuration.\n+     * This ensures that all subclasses and application identity classes of\n+     * each type are known in advance, without having to rely on the\n+     * application loading the classes before performing operations that\n+     * might involve them.\n+     *\n+     * @param devpath if true, search for metadata files in directories\n+     * in the classpath if the no classes are configured explicitly\n+     * @param envLoader the class loader to use, or null for default\n+     * @return the loaded classes, or empty collection if none\n+     */\n+    public Collection<Class<?>> loadPersistentTypes(boolean devpath, ClassLoader envLoader) {\n         return loadPersistentTypes(devpath, envLoader, false);\n     }\n-\n     /**\n      * Load the persistent classes named in configuration. This ensures that all subclasses and\n      * application identity classes of each type are known in advance, without having to rely on the\n@@ -1427,12 +1470,21 @@ public void clear() {\n      * @return the loaded classes, or empty collection if none\n      */\n     public Collection<Class<?>> loadPersistentTypes(boolean devpath, ClassLoader envLoader, boolean mustExist) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return loadPersistentTypesInternal(devpath, envLoader, mustExist);\n+            }\n+        } else {\n+            return loadPersistentTypesInternal(devpath, envLoader, mustExist);\n+        }\n+    }\n+\n+    private Collection<Class<?>> loadPersistentTypesInternal(boolean devpath, ClassLoader envLoader, \n+        boolean mustExist) {\n             Set<String> names = getPersistentTypeNames(devpath, envLoader);\n             if (names == null || names.isEmpty()) {\n                 if (!mustExist)\n-                    return Collections.EMPTY_LIST;\n+                    return Collections.emptyList();\n                 else\n                     throw new MetaDataException(_loc.get(\"eager-no-class-found\"));\n             }\n@@ -1459,9 +1511,6 @@ public void clear() {\n                 }\n             }\n             return classes;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -1503,23 +1552,23 @@ public void clear() {\n     Collection<Class<?>> getPCSubclasses(Class<?> cls) {\n         Collection<Class<?>> subs = _subs.get(cls);\n         if (subs == null)\n-            return Collections.EMPTY_LIST;\n+            return Collections.emptyList();\n         return subs;\n     }\n \n     // //////////////////////////////////////\n     // RegisterClassListener implementation\n     // //////////////////////////////////////\n \n-    public void register(Class cls) {\n+    public void register(Class<?> cls) {\n         // buffer registered classes until an oid metadata request is made,\n         // at which point we'll parse everything in the buffer\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (_registered) {\n+                _registered.add(cls);\n+            }\n+        } else {\n             _registered.add(cls);\n-            registerAlias(cls);\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -1548,12 +1597,14 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n         // copy into new collection to avoid concurrent mod errors on reentrant\n         // registrations\n         Class<?>[] reg;\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (_registered) {\n+                reg = _registered.toArray(new Class[_registered.size()]);\n+                _registered.clear();\n+            }\n+        } else {\n             reg = _registered.toArray(new Class[_registered.size()]);\n             _registered.clear();\n-        } finally {\n-            unlock();\n         }\n         \n \n@@ -1579,11 +1630,12 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n             }\n         }\n         if (failed != null) {\n-            lock();\n-            try {\n+            if (_locking) {\n+                synchronized (_registered) {\n+                    _registered.addAll(failed);\n+                }\n+            } else {\n                 _registered.addAll(failed);\n-            } finally {\n-                unlock();\n             }\n         }\n         return reg;\n@@ -1601,8 +1653,7 @@ private void processRegisteredClass(Class<?> cls) {\n         // update subclass lists; synchronize on this because accessing _metas\n         // requires it\n         Class<?> leastDerived = cls;\n-        lock();\n-        try {\n+        synchronized (this) {\n             ClassMetaData meta;\n             for (Class<?> anc = cls; (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {\n                 addToCollection(_subs, anc, cls, true);\n@@ -1611,10 +1662,8 @@ private void processRegisteredClass(Class<?> cls) {\n                     meta.clearSubclassCache();\n                 leastDerived = anc;\n             }\n-        } finally {\n-            unlock();\n         }\n-\n+        \n         // update oid mappings if this is a base concrete class\n         Object oid = null;\n         try {\n@@ -1642,7 +1691,11 @@ private void processRegisteredClass(Class<?> cls) {\n \n         // update mappings from interfaces and non-pc superclasses to\n         // pc implementing types\n-        synchronized (_impls) {\n+        if (_locking) {\n+            synchronized (_impls) {\n+                updateImpls(cls, leastDerived, cls);\n+            }\n+        } else {\n             updateImpls(cls, leastDerived, cls);\n         }\n \n@@ -1664,7 +1717,6 @@ public void registerAlias(String alias, Class<?> cls) {\n         if (alias == null)\n             return;\n         try {\n-            lock();\n             if (alias != null) {\n                 List<Class<?>> classes = _aliases.get(alias);\n                 if (classes == null)\n@@ -1676,8 +1728,6 @@ public void registerAlias(String alias, Class<?> cls) {\n             }\n         } catch (IllegalStateException ise) {\n             // the class has not been registered to PCRegistry\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -1728,22 +1778,27 @@ private boolean isLeastDerivedImpl(Class<?> inter, Class<?> cls) {\n      * Add the given value to the collection cached in the given map under the given key.\n      */\n     private void addToCollection(Map map, Class<?> key, Class<?> value, boolean inheritance) {\n-        lock();\n-        try {\n-            Collection coll = (Collection) map.get(key);\n-            if (coll == null) {\n-                if (inheritance) {\n-                    InheritanceComparator comp = new InheritanceComparator();\n-                    comp.setBase(key);\n-                    coll = new TreeSet<Class<?>>(comp);\n-                } else\n-                    coll = new LinkedList<Class<?>>();\n-                map.put(key, coll);\n+        if (_locking) {\n+            synchronized (map) {\n+                addToCollectionInternal(map, key, value, inheritance);\n             }\n-            coll.add(value);\n-        } finally {\n-            unlock();\n+        } else {\n+            addToCollectionInternal(map, key, value, inheritance);\n+        }\n+    }\n+\n+    private void addToCollectionInternal(Map map, Class<?> key, Class<?> value, boolean inheritance) {\n+        Collection coll = (Collection) map.get(key);\n+        if (coll == null) {\n+            if (inheritance) {\n+                InheritanceComparator comp = new InheritanceComparator();\n+                comp.setBase(key);\n+                coll = new TreeSet<Class<?>>(comp);\n+            } else\n+                coll = new LinkedList<Class<?>>();\n+            map.put(key, coll);\n         }\n+        coll.add(value);\n     }\n \n     /**\n@@ -1804,11 +1859,19 @@ public void startConfiguration() {\n     }\n \n     public void endConfiguration() {\n-        _lock = new ReentrantLock();\n-        \n         initializeMetaDataFactory();\n         if (_implGen == null)\n             _implGen = new InterfaceImplGenerator(this);\n+        if (_preload == true) {\n+            _oids = new HashMap<Class<?>, Class<?>>();\n+            _impls = new HashMap<Class<?>, Collection<Class<?>>>();\n+            _ifaces = new HashMap<Class<?>, Class<?>>();\n+            _aliases = new HashMap<String, List<Class<?>>>();\n+            _pawares = new HashMap<Class<?>, NonPersistentMetaData>();\n+            _nonMapped = new HashMap<Class<?>, NonPersistentMetaData>();\n+            _subs = new HashMap<Class<?>, List<Class<?>>>();\n+            // Wait till we're done loading MetaData to flip _lock boolean.\n+        }            \n     }\n \n     private void initializeMetaDataFactory() {\n@@ -1828,8 +1891,17 @@ private void initializeMetaDataFactory() {\n      * Return query metadata for the given class, name, and classloader.\n      */\n     public QueryMetaData getQueryMetaData(Class<?> cls, String name, ClassLoader envLoader, boolean mustExist) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return getQueryMetaDataInternal(cls, name, envLoader, mustExist);\n+            }\n+        } else {\n+            return getQueryMetaDataInternal(cls, name, envLoader, mustExist);\n+        }\n+    }\n+\n+    private QueryMetaData getQueryMetaDataInternal(Class<?> cls, String name, ClassLoader envLoader, \n+        boolean mustExist) {\n             QueryMetaData meta = getQueryMetaDataInternal(cls, name, envLoader);\n             if (meta == null) {\n                 // load all the metadatas for all the known classes so that\n@@ -1848,9 +1920,6 @@ public QueryMetaData getQueryMetaData(Class<?> cls, String name, ClassLoader env\n             }\n \n             return meta;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -1903,81 +1972,83 @@ private QueryMetaData getQueryMetaDataInternal(Class<?> cls, String name, ClassL\n      * Return the cached query metadata.\n      */\n     public QueryMetaData[] getQueryMetaDatas() {\n-        lock();\n-        try {\n-            return _queries.values().toArray(new QueryMetaData[_queries.size()]);\n-        } finally {\n-            unlock();\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryMetaData[]) _queries.values().toArray(new QueryMetaData[_queries.size()]);\n+            }\n+        } else {\n+            return (QueryMetaData[]) _queries.values().toArray(new QueryMetaData[_queries.size()]);\n         }\n     }\n \n     /**\n      * Return the cached query metadata for the given name.\n      */\n     public QueryMetaData getCachedQueryMetaData(Class<?> cls, String name) {\n-        lock();\n-        try {\n-            return _queries.get(getQueryKey(cls, name));\n-        } finally {\n-            unlock();\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryMetaData) _queries.get(getQueryKey(cls, name));\n+            }\n+        } else {\n+            return (QueryMetaData) _queries.get(getQueryKey(cls, name));\n         }\n     }\n \n     /**\n      * Add a new query metadata to the repository and return it.\n      */\n     public QueryMetaData addQueryMetaData(Class<?> cls, String name) {\n-        lock();\n-        try{\n+        if (_locking) {\n+            synchronized (this) {\n+                QueryMetaData meta = newQueryMetaData(cls, name);\n+                _queries.put(getQueryKey(meta), meta);\n+                return meta;\n+            }\n+        }else{\n             QueryMetaData meta = newQueryMetaData(cls, name);\n             _queries.put(getQueryKey(meta), meta);\n-            return meta;\n-        }finally{\n-            unlock();\n+            return meta;   \n         }\n     }\n \n     /**\n      * Create a new query metadata instance.\n      */\n     protected QueryMetaData newQueryMetaData(Class<?> cls, String name) {\n-        lock();\n-        try {\n-            QueryMetaData meta = new QueryMetaData(name);\n-            meta.setDefiningType(cls);\n-            return meta;\n-        } finally {\n-            unlock();\n-        }\n+        QueryMetaData meta = new QueryMetaData(name);\n+        meta.setDefiningType(cls);\n+        return meta;\n     }\n \n     /**\n      * Remove the given query metadata from the repository.\n      */\n     public boolean removeQueryMetaData(QueryMetaData meta) {\n-        lock();\n-        try {\n-            if (meta == null) {\n-                return false;\n+        if (meta == null)\n+            return false;\n+        if (_locking) {\n+            synchronized (this) {\n+                return _queries.remove(getQueryKey(meta)) != null;\n             }\n-\n+        } else {\n             return _queries.remove(getQueryKey(meta)) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Remove query metadata for the given class name if in the repository.\n      */\n     public boolean removeQueryMetaData(Class<?> cls, String name) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _queries.remove(getQueryKey(cls, name)) != null;\n+            }\n+        } else {\n             if (name == null)\n                 return false;\n             return _queries.remove(getQueryKey(cls, name)) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -2022,8 +2093,16 @@ protected static Object getQueryKey(Class<?> cls, String name) {\n      * Return sequence metadata for the given name and classloader.\n      */\n     public SequenceMetaData getSequenceMetaData(String name, ClassLoader envLoader, boolean mustExist) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return getSequenceMetaDataInternal(name, envLoader, mustExist);\n+            }\n+        } else {\n+            return getSequenceMetaDataInternal(name, envLoader, mustExist);\n+        }\n+    }\n+\n+    private SequenceMetaData getSequenceMetaDataInternal(String name, ClassLoader envLoader, boolean mustExist) {\n             SequenceMetaData meta = getSequenceMetaDataInternal(name, envLoader);\n             if (meta == null && SequenceMetaData.NAME_SYSTEM.equals(name)) {\n                 if (_sysSeq == null)\n@@ -2033,9 +2112,6 @@ public SequenceMetaData getSequenceMetaData(String name, ClassLoader envLoader,\n             if (meta == null && mustExist)\n                 throw new MetaDataException(_loc.get(\"no-named-sequence\", name));\n             return meta;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -2094,37 +2170,42 @@ private SequenceMetaData getSequenceMetaDataInternal(String name, ClassLoader en\n      * Return the cached sequence metadata.\n      */\n     public SequenceMetaData[] getSequenceMetaDatas() {\n-        lock();\n-        try {\n-            return _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n-        } finally {\n-            unlock();\n+        if (_locking) {\n+            synchronized (this) {\n+                return (SequenceMetaData[]) _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n+            }\n+        } else {\n+            return (SequenceMetaData[]) _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n         }\n     }\n \n     /**\n      * Return the cached a sequence metadata for the given name.\n      */\n     public SequenceMetaData getCachedSequenceMetaData(String name) {\n-        lock();\n-        try {\n-            return _seqs.get(name);\n-        } finally {\n-            unlock();\n+        if (_locking) {\n+            synchronized (this) {\n+                return (SequenceMetaData) _seqs.get(name);\n+            }\n+        } else {\n+            return (SequenceMetaData) _seqs.get(name);\n         }\n     }\n \n     /**\n      * Add a new sequence metadata to the repository and return it.\n      */\n     public SequenceMetaData addSequenceMetaData(String name) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                SequenceMetaData meta = newSequenceMetaData(name);\n+                _seqs.put(name, meta);\n+                return meta;\n+            }\n+        } else {\n             SequenceMetaData meta = newSequenceMetaData(name);\n             _seqs.put(name, meta);\n             return meta;\n-        } finally {\n-            unlock();\n         }\n     }\n \n@@ -2139,52 +2220,65 @@ protected SequenceMetaData newSequenceMetaData(String name) {\n      * Remove the given sequence metadata from the repository.\n      */\n     public boolean removeSequenceMetaData(SequenceMetaData meta) {\n-        lock();\n-        try {\n-            if (meta == null)\n-                return false;\n+        if (meta == null)\n+            return false;\n+        if (_locking) {\n+            synchronized (this) {\n+                return _seqs.remove(meta.getName()) != null;\n+            }\n+        } else {\n             return _seqs.remove(meta.getName()) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Remove sequence metadata for the name if in the repository.\n      */\n     public boolean removeSequenceMetaData(String name) {\n-        lock();\n-        try {\n-            if (name == null)\n-                return false;\n+        if (name == null)\n+            return false;\n+        if (_locking) {\n+            synchronized (this) {\n+                return _seqs.remove(name) != null;\n+            }\n+        } else {\n             return _seqs.remove(name) != null;\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Add the given system lifecycle listener.\n      */\n     public void addSystemListener(Object listener) {\n-        lock();\n-        try {\n-            // copy to avoid issues with ListenerList and avoid unncessary\n-            // locking on the list during runtime\n+        if (_locking) {\n+            synchronized (this) {\n+                // copy to avoid issues with ListenerList and avoid unncessary\n+                // locking on the list during runtime\n+                LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n+                listeners.add(listener);\n+                _listeners = listeners;\n+            }\n+        } else {\n             LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n             listeners.add(listener);\n             _listeners = listeners;\n-        } finally {\n-            unlock();\n         }\n     }\n \n     /**\n      * Remove the given system lifecycle listener.\n      */\n     public boolean removeSystemListener(Object listener) {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                return removeSystemListenerInternal(listener);\n+            }\n+        } else {\n+            return removeSystemListenerInternal(listener);\n+        }\n+    }\n+\n+    private boolean removeSystemListenerInternal(Object listener) {\n             if (!_listeners.contains(listener))\n                 return false;\n \n@@ -2194,9 +2288,6 @@ public boolean removeSystemListener(Object listener) {\n             listeners.remove(listener);\n             _listeners = listeners;\n             return true;\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -2210,15 +2301,20 @@ public boolean removeSystemListener(Object listener) {\n      * Free the resources used by this repository. Closes all user sequences.\n      */\n     public void close() {\n-        lock();\n-        try {\n+        if (_locking) {\n+            synchronized (this) {\n+                closeInternal();\n+            }\n+        } else {\n+            closeInternal();\n+        }\n+    }\n+\n+    private void closeInternal() {\n             SequenceMetaData[] smds = getSequenceMetaDatas();\n             for (int i = 0; i < smds.length; i++)\n                 smds[i].close();\n             clear();\n-        } finally {\n-            unlock();\n-        }\n     }\n \n     /**\n@@ -2253,23 +2349,28 @@ public boolean equals(Object obj) {\n      * @return XML metadata\n      */\n     public XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n-        lock();\n-        try {\n-            Class<?> cls = fmd.getDeclaredType();\n-            // check if cached before\n-            XMLMetaData xmlmeta = _xmlmetas.get(cls);\n-            if (xmlmeta != null)\n-                return xmlmeta;\n+        if (_locking) {\n+            synchronized (this) {\n+                return getXMLMetaDataInternal(fmd);\n+            }\n+        } else {\n+            return getXMLMetaDataInternal(fmd);\n+        }\n+    }\n+    \n+    private XMLMetaData getXMLMetaDataInternal(FieldMetaData fmd) {\n+        Class<?> cls = fmd.getDeclaredType();\n+        // check if cached before\n+        XMLMetaData xmlmeta = _xmlmetas.get(cls);\n+        if (xmlmeta != null)\n+            return xmlmeta;\n \n-            // load JAXB XML metadata\n-            _factory.loadXMLMetaData(fmd);\n+        // load JAXB XML metadata\n+        _factory.loadXMLMetaData(fmd);\n \n-            xmlmeta = (XMLClassMetaData) _xmlmetas.get(cls);\n+        xmlmeta = (XMLClassMetaData) _xmlmetas.get(cls);\n \n-            return xmlmeta;\n-        } finally {\n-            unlock();\n-        }\n+        return xmlmeta;\n     }\n \n     /**\n@@ -2281,11 +2382,12 @@ public XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n      */\n     public XMLClassMetaData addXMLMetaData(Class<?> type, String name) {\n         XMLClassMetaData meta = newXMLClassMetaData(type, name);\n-        lock();\n-        try {\n+        if(_locking){\n+            synchronized(this){\n+                _xmlmetas.put(type, meta);                \n+            }\n+        }else{\n             _xmlmetas.put(type, meta);\n-        } finally {\n-            unlock();\n         }\n         return meta;\n     }\n@@ -2509,4 +2611,12 @@ private boolean internalCheckForCycle(java.util.Stack<CMDDependencyNode> visitSt\n             return false;\n         }\n     }\n+\n+    public static boolean needsPreload(Options o) {\n+        if (o.getBooleanProperty(PRELOAD_STR) == true) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n }"},{"sha":"a878044787faee18ec63243550aae441d0bb9b9f","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -350,4 +350,9 @@ repos-preload-error: Unexpected error during early loading during initialization\n \tSee nested stacktrace for details. \t  \n cmd-discover-cycle: A cycle was detected while resolving the identity \\\n     references for type \"{0}\".  The original process buffer ordering \\\n-    will be used.\n\\ No newline at end of file\n+    will be used.\n+repos-initializeEager-none: No persistent metadata found for loading during initialization. \\\n+    The persistent classes must be listed in persistence unit configuration to be loaded during initialization.\n+repos-initializeEager-found: The following classes are being preloaded \"{0}\".\t   \n+repos-initializeEager-error: Unexpected error during early loading of entity metadata during initialization. \\\n+    See nested stacktrace for details.\t  "},{"sha":"ce703142293ee1eb17f4842bb76a352208d5acc1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -988,9 +988,8 @@ public TemporaryClassLoader run() {\n      *   \n      * @return MultiClassLoader\n      */\n-    public static final PrivilegedAction<MultiClassLoader>\n-        newMultiClassLoaderAction() {\n-        return new PrivilegedAction<MultiClassLoader>() {\n+    public static final PrivilegedAction<MultiClassLoader> newMultiClassLoaderAction() {\n+        return new PrivilegedAction() {\n             public MultiClassLoader run() {\n                 return new MultiClassLoader();\n             }"},{"sha":"f2328604893ebbfbc4285b0c8ef37ef2af0a5677","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":33,"deletions":18,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/0efea474f226749a971077a592090cd7a4b86648/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0efea474f226749a971077a592090cd7a4b86648/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=0efea474f226749a971077a592090cd7a4b86648","patch":"@@ -20,6 +20,7 @@\n \n import java.lang.instrument.ClassFileTransformer;\n import java.lang.instrument.IllegalClassFormatException;\n+import java.security.AccessController;\n import java.security.ProtectionDomain;\n import java.util.Map;\n \n@@ -35,12 +36,14 @@\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n import org.apache.openjpa.enhance.PCClassFileTransformer;\n import org.apache.openjpa.enhance.PCEnhancerAgent;\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\n import org.apache.openjpa.kernel.Bootstrap;\n import org.apache.openjpa.kernel.BrokerFactory;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.ConfigurationProvider;\n import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.meta.MetaDataModes;\n@@ -87,24 +90,16 @@ public OpenJPAEntityManagerFactory createEntityManagerFactory(String name, Strin\n \n             BrokerFactory factory = getBrokerFactory(cp, poolValue, null);\n             OpenJPAConfiguration conf = factory.getConfiguration();\n-            _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+            _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);            \n             pd.checkPuNameCollisions(_log,name);\n             \n             loadAgent(_log, conf);\n             \n             // TODO - Can this be moved back to BrokerImpl.initialize()?\n             // Create appropriate LifecycleEventManager\n             loadValidator(_log, conf);\n-\n-            // We need to wait to preload until after we get back a fully configured/instantiated\n-            // BrokerFactory. This is because it is possible that someone has extended OpenJPA\n-            // functions and they need to be allowed time to configure themselves before we go off and\n-            // start instanting configurable objects (ie:openjpa.MetaDataRepository). Don't catch\n-            // any exceptions here because we want to fail-fast.\n-            Options o = Configurations.parseProperties(Configurations.getProperties(conf.getMetaDataRepository()));\n-            if(o.getBooleanProperty(\"Preload\")){\n-                conf.getMetaDataRepositoryInstance().preload();\n-            }\n+            \n+            preloadMetaDataRepository(factory);\n             \n             return JPAFacadeHelper.toEntityManagerFactory(factory);\n         } catch (Exception e) {\n@@ -186,21 +181,17 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(Persisten\n                     log.warn(_loc.get(\"transformer-registration-error\", pui));\n                 }\n             }\n-            \n             // Create appropriate LifecycleEventManager\n             OpenJPAConfiguration conf = factory.getConfiguration();\n             _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n             loadValidator(_log, conf);\n+            \n             // We need to wait to preload until after we get back a fully configured/instantiated\n             // BrokerFactory. This is because it is possible that someone has extended OpenJPA\n             // functions and they need to be allowed time to configure themselves before we go off and\n             // start instanting configurable objects (ie:openjpa.MetaDataRepository). Don't catch\n             // any exceptions here because we want to fail-fast.\n-            Options o = Configurations.parseProperties(Configurations.getProperties(conf.getMetaDataRepository()));\n-            if(o.getBooleanProperty(\"Preload\")){\n-                conf.getMetaDataRepositoryInstance().preload();\n-            }\n-            \n+            preloadMetaDataRepository(factory);           \n             return JPAFacadeHelper.toEntityManagerFactory(factory);\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n@@ -233,7 +224,31 @@ protected String getDefaultBrokerAlias() {\n     protected OpenJPAConfiguration newConfigurationImpl() {\n         return new OpenJPAConfigurationImpl();\n     }\n-        \n+\n+    /**\n+     * Private worker method that will call to the MetaDataRepository to preload if the provided\n+     * BrokerFactory is configured to do so.\n+     */\n+    private void preloadMetaDataRepository(BrokerFactory factory){\n+        // We need to wait to preload until after we get back a fully configured/instantiated\n+        // BrokerFactory. This is because it is possible that someone has extended OpenJPA\n+        // functions and they need to be allowed time to configure themselves before we go off and\n+        // start instanting configurable objects (ie:openjpa.MetaDataRepository). Don't catch\n+        // any exceptions here because we want to fail-fast.\n+        OpenJPAConfiguration conf = factory.getConfiguration();\n+        Options o = Configurations.parseProperties(Configurations.getProperties(conf.getMetaDataRepository()));\n+        if (MetaDataRepository.needsPreload(o) == true) {\n+            MetaDataRepository mdr = conf.getMetaDataRepositoryInstance(); \n+            mdr.setValidate(MetaDataRepository.VALIDATE_RUNTIME, true);\n+            mdr.setResolve(MetaDataRepository.MODE_MAPPING_INIT, true);\n+            \n+            // Load persistent classes and hook in subclasser\n+            ((AbstractBrokerFactory) factory).loadPersistentTypes((ClassLoader) AccessController\n+                .doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));\n+            mdr.preload();\n+        }\n+    }\n+    \n     /**\n      * Java EE 5 class transformer.\n      */"}]}

