{"sha":"0f32d376687fd1515a4cd9b8953e14b666499e93","node_id":"MDY6Q29tbWl0MjA2MzY0OjBmMzJkMzc2Njg3ZmQxNTE1YTRjZDliODk1M2UxNGI2NjY0OTllOTM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-05-02T21:09:14Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-05-02T21:09:14Z"},"message":"OPENJPA-407 committing patch provided by Fay Wang and Jeremy Bauer\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@652913 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0362c0dbf28751d482ee9737273ee5a8f879deb5","url":"https://api.github.com/repos/apache/openjpa/git/trees/0362c0dbf28751d482ee9737273ee5a8f879deb5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0f32d376687fd1515a4cd9b8953e14b666499e93","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0f32d376687fd1515a4cd9b8953e14b666499e93","html_url":"https://github.com/apache/openjpa/commit/0f32d376687fd1515a4cd9b8953e14b666499e93","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0f32d376687fd1515a4cd9b8953e14b666499e93/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"78ff71749c19643a0b74f0a68e1c351f262106b3","url":"https://api.github.com/repos/apache/openjpa/commits/78ff71749c19643a0b74f0a68e1c351f262106b3","html_url":"https://github.com/apache/openjpa/commit/78ff71749c19643a0b74f0a68e1c351f262106b3"}],"stats":{"total":1494,"additions":1397,"deletions":97},"files":[{"sha":"fa8f5a0d4b06a3f6449487a3ece2e0ef644e5f43","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","status":"modified","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.openjpa.jdbc.conf;\n \n+import java.util.Map;\n+\n import javax.sql.DataSource;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n@@ -602,4 +604,23 @@\n      * @see #getDataSource\n      */\n     public DataSource getDataSource2(StoreContext ctx);\n+    \n+    /**\n+     * Return QuerySQLCacheValue.\n+     * @since 1.2.0\n+     */\n+    public QuerySQLCacheValue getQuerySQLCache();\n+        \n+    /**\n+     * Whether querySQLCache is enabled or not.\n+     * @since 1.2.0\n+     */\n+    public boolean isQuerySQLCacheOn();\n+    \n+    /**\n+     * Return QuerySQLCacheInstance.\n+     * @since 1.2.0\n+     */\n+    public Map getQuerySQLCacheInstance();     \n+    \n }"},{"sha":"41d05d09f7d1ffca0a1803891244ef661d379b14","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -20,6 +20,9 @@\n \n import java.sql.Connection;\n import java.sql.ResultSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n import javax.sql.DataSource;\n \n import org.apache.commons.lang.StringUtils;\n@@ -82,6 +85,8 @@\n     public ObjectValue mappingDefaultsPlugin;\n     public PluginValue driverDataSourcePlugin;\n     public MappingFactoryValue mappingFactoryPlugin;\n+    public QuerySQLCacheValue querySQLCache;\n+    private Map querySQLCacheInstance = new HashMap(); \n \n     // used internally\n     private String firstUser = null;\n@@ -302,6 +307,9 @@ public JDBCConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         seqPlugin.setDefault(JDBCSeqValue.ALIASES[0]);\n         seqPlugin.setString(JDBCSeqValue.ALIASES[0]);\n \n+        querySQLCache = new QuerySQLCacheValue(\"jdbc.QuerySQLCache\");\n+        addValue(querySQLCache);\n+\n         // this static initializer is to get past a weird\n         // ClassCircularityError that happens only under IBM's\n         // JDK 1.3.1 on Linux from within the JRun ClassLoader;\n@@ -856,4 +864,21 @@ protected boolean isInvalidProperty(String propName) {\n                 return true; \n         return false;\n     }\n+    \n+    public void setQuerySQLCache(String querySQLCache) {\n+        this.querySQLCache.setString(querySQLCache);\n+    }\n+\n+    public QuerySQLCacheValue getQuerySQLCache() {\n+        return querySQLCache;\n+    }\n+    \n+    public boolean isQuerySQLCacheOn() {\n+        return querySQLCache.isSQLCacheOn();\n+    }\n+\n+    public Map getQuerySQLCacheInstance() {\n+        return querySQLCacheInstance;\n+    }\n+    \n }"},{"sha":"7db54b7e2bb5ffdbdcd913f8d5c7e844ebcfe2bf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/QuerySQLCacheValue.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/QuerySQLCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/QuerySQLCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/QuerySQLCacheValue.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.util.CacheMap;\n+\n+\n+/**\n+ * A cache of sql queries.\n+ *\n+ * @since 1.2\n+ * @nojavadoc\n+ */\n+public class QuerySQLCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+    \n+    public QuerySQLCacheValue(String prop) {\n+        super(prop, true); \n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+    \n+    public boolean isSQLCacheOn() {\n+        if (getClassName() == null) \n+            return false;\n+        return true;\n+    }\n+    \n+    public Object newInstance() {\n+        // make sure map handles concurrency\n+        String clsName = getClassName();\n+        if (clsName == null)\n+            return null;\n+        Map map = null;\n+\n+        try {\n+            // Use the \"OpenJPA\" classloader first...\n+            map = (Map) Configurations.newInstance(clsName, this.getClass()\n+                    .getClassLoader());\n+        } catch (Exception e) {\n+            // If the \"OpenJPA\" classloader fails, then try the classloader\n+            // that was used to load java.util.Map...\n+            map = (Map) Configurations.newInstance(clsName,\n+                    Map.class.getClassLoader());\n+        }\n+        if (map != null\n+                && !(map instanceof Hashtable)\n+                && !(map instanceof CacheMap)\n+                && !(map instanceof \n+                        org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\n+                && !(map instanceof java.util.concurrent.ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+    }\n+\n+}"},{"sha":"02173e3f3b70d075305a7635c88f13f848dd1c75","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":248,"deletions":2,"changes":250,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -29,15 +29,20 @@\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+\n import javax.sql.DataSource;\n \n import org.apache.openjpa.event.OrphanedKeyAction;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.QuerySQLCacheValue;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Discriminator;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n import org.apache.openjpa.jdbc.sql.Joins;\n@@ -60,10 +65,12 @@\n import org.apache.openjpa.lib.jdbc.DelegatingConnection;\n import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;\n import org.apache.openjpa.lib.jdbc.DelegatingStatement;\n+import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n import org.apache.openjpa.lib.rop.ResultObjectProvider;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FetchGroup;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.ValueStrategies;\n@@ -99,7 +106,11 @@\n \n     // track the pending statements so we can cancel them\n     private Set _stmnts = Collections.synchronizedSet(new HashSet());\n-\n+    \n+    private Map _sqlCache = null;\n+    private boolean _isQuerySQLCache = true;\n+    private static final Object _nullCacheValue = new Object();\n+    \n     public StoreContext getContext() {\n         return _ctx;\n     }\n@@ -125,6 +136,9 @@ public void setContext(StoreContext ctx, JDBCConfiguration conf) {\n \n         if (_conf.getUpdateManagerInstance().orderDirty())\n             ctx.setOrderDirtyObjects(true);\n+        \n+        _sqlCache = _conf.getQuerySQLCacheInstance();\n+        _isQuerySQLCache = _conf.isQuerySQLCacheOn();\n     }\n \n     public JDBCConfiguration getConfiguration() {\n@@ -402,13 +416,86 @@ private Boolean customLoad(OpenJPAStateManager sm, ClassMapping mapping,\n     private Result getInitializeStateResult(OpenJPAStateManager sm,\n         ClassMapping mapping, JDBCFetchConfiguration fetch, int subs)\n         throws SQLException {\n+        List params = new ArrayList();\n+        Select sel = newSelect(sm, mapping, fetch, subs, params);\n+        if (sel == null) return null;\n+        return sel.execute(this, fetch, params);\n+    }\n+\n+    private Select newSelect(OpenJPAStateManager sm,\n+        ClassMapping mapping, JDBCFetchConfiguration fetch, int subs,\n+        List params) {\n+        if (!_isQuerySQLCache) \n+            return newSelect(sm, mapping, fetch, subs);       \n+           \n+        Map<SelectKey, Select> selectImplCacheMap = \n+            getCacheMapFromQuerySQLCache(JDBCStoreManager.class);\n+        JDBCFetchConfiguration fetchClone = new JDBCFetchConfigurationImpl();\n+        fetchClone.copy(fetch);\n+        SelectKey selKey = new SelectKey(mapping, null, fetchClone);\n+        Select sel = null;\n+        boolean found = true;\n+        Object obj = selectImplCacheMap.get(selKey);\n+        if (obj == null) {\n+            synchronized (selectImplCacheMap) {\n+                obj = selectImplCacheMap.get(selKey);\n+                if (obj == null) {\n+                    // Not found in cache, create a new select\n+                    obj = newSelect(sm, mapping, fetch, subs);\n+                    found = false;\n+                }\n+                    \n+                if (obj == null) {\n+                    // If the generated SelectImpl is null, store a generic\n+                    // known object in the cache as a placeholder. Some map \n+                    // implementations do not allow null values.\n+                    obj = _nullCacheValue;\n+                    found = false;\n+                }\n+                else if (obj != _nullCacheValue)\n+                {\n+                    sel = (Select)obj;\n+                    if (sel.getSQL() == null) {\n+                        sel.setSQL(this, fetch);\n+                        found = false;\n+                    }\n+                }\n+                if (!found) {\n+                    addToSqlCache(selectImplCacheMap, selKey, obj);\n+                }\n+            }\n+        }\n+\n+        if (obj != null && obj != _nullCacheValue)\n+            sel = (Select) obj;\n+\n+        Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n+        if (log.isTraceEnabled()) {\n+            if (!found)\n+                log.trace(_loc.get(\"cache-missed\", mapping, this.getClass()));\n+            else\n+                log.trace(_loc.get(\"cache-hit\", mapping, this.getClass()));\n+        }\n+\n+        if (sel == null)\n+            return null;\n+        \n+        Object oid = sm.getObjectId();\n+        Column[] cols = mapping.getPrimaryKeyColumns();\n+        sel.wherePrimaryKey(mapping, cols, cols, oid, this, \n+        \tnull, null, params);\n+        return sel;\n+    }\n+\n+    protected Select newSelect(OpenJPAStateManager sm,\n+        ClassMapping mapping, JDBCFetchConfiguration fetch, int subs) {\n         Select sel = _sql.newSelect();\n         if (!select(sel, mapping, subs, sm, null, fetch,\n             JDBCFetchConfiguration.EAGER_JOIN, true, false))\n             return null;\n         sel.wherePrimaryKey(sm.getObjectId(), mapping, this);\n         sel.setExpectedResultCount(1, false);\n-        return sel.execute(this, fetch);\n+        return sel;\n     }\n \n     /**\n@@ -1419,4 +1506,163 @@ protected ResultSet executeQuery(boolean wrap) throws SQLException {\n             }\n         }\n     }\n+    \n+    public Map getCacheMapFromQuerySQLCache(Object key) {\n+        synchronized(_sqlCache) {\n+            //sqlCache is a map of map\n+            Map cacheMap = (Map)_sqlCache.get(key);\n+            if (cacheMap == null) {\n+                cacheMap = createSQLCache();\n+                _sqlCache.put(key, cacheMap);\n+            }\n+            return cacheMap;\n+        }\n+    }\n+    \n+    public void addToSqlCache(Map cacheMap, Object key, Object value) {\n+        cacheMap.put(key, value);\n+    }\n+    \n+    public Map createSQLCache() {\n+        QuerySQLCacheValue querySQLCache = _conf.getQuerySQLCache();\n+        return (Map)querySQLCache.newInstance();\n+    }\n+\n+    public boolean isQuerySQLCacheOn() {\n+        return _isQuerySQLCache;  \n+    }\n+    \n+    public Map getQuerySQLCache() {\n+        return _sqlCache;\n+    }\n+    \n+    public static class SelectKey {\n+        public ClassMapping mapping;\n+        public FieldMapping fm;\n+        public JDBCFetchConfiguration fetch;\n+        \n+        public SelectKey (ClassMapping mapping, FieldMapping fm, \n+            JDBCFetchConfiguration fetch) {\n+            this.mapping = mapping;\n+            this.fm = fm;\n+            this.fetch = fetch;\n+        }\n+        \n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            SelectKey selectKey = (SelectKey) o;\n+            if (fetch != null ? !equals(fetch, selectKey.fetch) :\n+                selectKey.fetch != null) return false;\n+            if (mapping != null ? !mapping.equals(selectKey.mapping) :\n+                selectKey.mapping != null) return false;\n+            if (fm != null ? !fm.equals(selectKey.fm) :\n+                selectKey.fm != null) return false;\n+            return true;\n+        }\n+        \n+        public boolean equals(JDBCFetchConfiguration fetch1,\n+        \tJDBCFetchConfiguration fetch2) {\n+            if (fetch1 == fetch2) \n+            \treturn true;\n+\n+            if (fetch1.getIsolation() != fetch2.getIsolation()) \n+            \treturn false;\n+            if (fetch1.getFetchDirection() != fetch2.getFetchDirection()) \n+            \treturn false;\n+            if (fetch1.getEagerFetchMode() != fetch2.getEagerFetchMode()) \n+            \treturn false;\n+            if (fetch1.getSubclassFetchMode() != fetch2.getSubclassFetchMode()) \n+            \treturn false;\n+            if (fetch1.getJoinSyntax() != fetch2.getJoinSyntax()) \n+            \treturn false;\n+            Set joins1 = fetch1.getJoins();\n+            Set joins2 = fetch2.getJoins();\n+            if (joins1 != null ? !joins1.equals(joins2) : joins2 != null)\n+                return false;\n+            \n+            if (fetch1.getMaxFetchDepth() != fetch2.getMaxFetchDepth()) \n+            \treturn false;\n+            if (fetch1.getReadLockLevel() != fetch2.getReadLockLevel()) \n+            \treturn false;\n+            if (fetch1.getWriteLockLevel() != fetch2.getWriteLockLevel()) \n+            \treturn false;\n+            \n+            boolean sameFetchGroup = false;\n+            boolean hasFetchGroupAll = ((JDBCFetchConfigurationImpl)fetch1).\n+            \thasFetchGroupAll();\n+            boolean hasFetchGroupAll1 = ((JDBCFetchConfigurationImpl)fetch2).\n+            \thasFetchGroupAll();\n+            if (hasFetchGroupAll && hasFetchGroupAll1) \n+                sameFetchGroup = true;\n+            else if (!hasFetchGroupAll && !hasFetchGroupAll1){\n+                boolean hasFetchGroupDefault = \n+                \t((JDBCFetchConfigurationImpl)fetch1).hasFetchGroupDefault();\n+                boolean hasFetchGroupDefault1 = \n+                \t((JDBCFetchConfigurationImpl)fetch2).hasFetchGroupDefault();\n+                if (hasFetchGroupDefault && hasFetchGroupDefault1) \n+                    sameFetchGroup = true;\n+            }\n+            \n+            if (!sameFetchGroup) {\n+                Set fetchGroups = fetch1.getFetchGroups();\n+                Set fetchGroups1 = fetch2.getFetchGroups();\n+                if (fetchGroups != null ? !fetchGroups.equals(fetchGroups1) : \n+                \tfetchGroups1 != null)\n+                    return false;\n+            }\n+            \n+            Set fields = fetch1.getFields();\n+            Set fields1 = fetch2.getFields();\n+            int size = fields.size();\n+            int size1 = fields1.size();\n+            if (size == 0 && size1 == 0)\n+                return true;\n+            else if (size != size1) \n+                return false;   \n+            \n+            if (fields != null ? !fields.equals(fields1) : fields1 != null)\n+                return false;\n+            \n+            return true;\n+        }\n+        \n+        \n+        public int hashCode() {\n+            int result = 0;\n+            result = 31 * result + (mapping != null ? mapping.hashCode() : 0);\n+            result = 31 * result + (fm != null ? fm.hashCode() : 0);\n+            result = 31 * result + fetch.getIsolation();\n+            result = 31 * result + fetch.getFetchDirection();\n+            result = 31 * result + fetch.getEagerFetchMode();\n+            result = 31 * result + fetch.getSubclassFetchMode();\n+            result = 31 * result + fetch.getJoinSyntax();\n+            Set joins = fetch.getJoins();\n+            result = 31 * result + (joins != null ? joins.hashCode() : 0);\n+            \n+            result = 31 * result + fetch.getMaxFetchDepth();\n+            result = 31 * result + fetch.getReadLockLevel();\n+            result = 31 * result + fetch.getWriteLockLevel();\n+        \t\n+            if (((JDBCFetchConfigurationImpl)fetch).hasFetchGroupAll()) \n+            \tresult = 31 * result + FetchGroup.NAME_ALL.hashCode();\n+            else {\n+                Set fetchGroups = fetch.getFetchGroups();\n+                if (((JDBCFetchConfigurationImpl)fetch).hasFetchGroupDefault() \n+                \t&& fetchGroups != null && fetchGroups.size() == 1)\n+                    result = 31 * result + FetchGroup.NAME_DEFAULT.hashCode();\n+                else {\n+                    result = 31 * result + (fetchGroups != null && \n+                        fetchGroups.size() > 0 ? \n+                        fetchGroups.hashCode() : 0);\n+                }\n+            }\n+            Set fields = fetch.getFields();\n+        \tresult = 31 * result + (fields != null &&  fields.size() > 0 ? \n+        \t\tfields.hashCode() : 0);\n+            \n+            return result;\n+        }\n+    }\n }"},{"sha":"c8b90909955195305d334926351403951e361287","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":100,"deletions":14,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -19,11 +19,16 @@\n package org.apache.openjpa.jdbc.meta.strats;\n \n import java.sql.SQLException;\n+import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfigurationImpl;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Embeddable;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n@@ -38,12 +43,14 @@\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.LogicalUnion;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n import org.apache.openjpa.jdbc.sql.RowManager;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n import org.apache.openjpa.jdbc.sql.Union;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.lib.log.Log;\n@@ -55,6 +62,7 @@\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n import org.apache.openjpa.util.UnsupportedException;\n+\n import serp.util.Numbers;\n \n /**\n@@ -579,9 +587,97 @@ public void load(final OpenJPAStateManager sm, final JDBCStore store,\n         final int subs = field.getSelectSubclasses();\n         final Joins[] resJoins = new Joins[rels.length];\n \n-        // select related mapping columns; joining from the related type\n-        // back to our fk table if not an inverse mapping (in which case we\n-        // can just make sure the inverse cols == our pk values)\n+        //cache union for field here\n+        //select data for this sm\n+        Union union = null;\n+        SelectImpl sel = null;\n+        List parmList = null;\n+\n+        if (!((JDBCStoreManager)store).isQuerySQLCacheOn())\n+            union = newUnion(sm, store, fetch, rels, subs, resJoins);\n+        else {\n+            Map<JDBCStoreManager.SelectKey, Object[]> relationFieldUnionCache = \n+                ((JDBCStoreManager)store).getCacheMapFromQuerySQLCache(\n+                RelationFieldStrategy.class);\n+            boolean found = true;\n+            JDBCFetchConfiguration fetchClone = new JDBCFetchConfigurationImpl();\n+            fetchClone.copy(fetch);\n+            JDBCStoreManager.SelectKey selKey = \n+                new JDBCStoreManager.SelectKey(null, field, fetch);\n+            Object[] obj = relationFieldUnionCache.get(selKey);\n+            if (obj != null) {\n+                union = (Union) obj[0];\n+                resJoins[0] = (Joins)obj[1];\n+            } else {\n+                synchronized(relationFieldUnionCache) {\n+                    obj = relationFieldUnionCache.get(selKey);\n+                    if (obj != null) {\n+                        union = (Union) obj[0];\n+                        resJoins[0] = (Joins) obj[1];\n+                    } else {\n+                        // select related mapping columns; joining from the \n+                        // related type back to our fk table if not an inverse \n+                        // mapping (in which case we can just make sure the \n+                        // inverse cols == our pk values)\n+                        union = newUnion(sm, store, fetch, rels, subs, \n+                                resJoins);\n+                        found = false;                \n+                    }\n+                    sel = ((LogicalUnion.UnionSelect)union.getSelects()[0]).\n+                        getDelegate();\n+                    SQLBuffer buf = sel.getSQL();\n+                    if (buf == null) {\n+                    \t((SelectImpl)sel).setSQL(store, fetch);\n+                        found = false;\n+                    }\n+\n+                    // only cache the union when elems length is 1 for now\n+                    if (!found && rels.length == 1) {\n+                        Object[] obj1 = new Object[2];\n+                        obj1[0] = union;\n+                        obj1[1] = resJoins[0];\n+                        ((JDBCStoreManager)store).addToSqlCache(\n+                            relationFieldUnionCache, selKey, obj1);\n+                    }\n+                }\n+            }\n+            Log log = store.getConfiguration().\n+                getLog(JDBCConfiguration.LOG_JDBC);\n+            if (log.isTraceEnabled()){\n+                if (found) \n+                    log.trace(_loc.get(\"cache-hit\", field, this.getClass()));                        \n+                else\n+                    log.trace(_loc.get(\"cache-missed\", field, this.getClass()));\n+            }\n+\n+            parmList = new ArrayList();\n+            ClassMapping mapping = field.getDefiningMapping();\n+            Object oid = sm.getObjectId();\n+            Column[] cols = mapping.getPrimaryKeyColumns();\n+            if (sel == null)\n+                sel = ((LogicalUnion.UnionSelect)union.getSelects()[0]).\n+                getDelegate();\n+\n+            sel.wherePrimaryKey(mapping, cols, cols, oid, store, \n+            \tnull, null, parmList);\n+        }\n+        \n+        Result res = union.execute(store, fetch, parmList);\n+        try {\n+            Object val = null;\n+            if (res.next())\n+                val = res.load(rels[res.indexOf()], store, fetch,\n+                    resJoins[res.indexOf()]);\n+            sm.storeObject(field.getIndex(), val);\n+        } finally {\n+            res.close();\n+        }\n+    }\n+    \n+    protected Union newUnion(final OpenJPAStateManager sm, \n+        final JDBCStore store, final JDBCFetchConfiguration fetch, \n+        final ClassMapping[] rels, final int subs, \n+        final Joins[] resJoins) {\n         Union union = store.getSQLFactory().newUnion(rels.length);\n         union.setExpectedResultCount(1, false);\n         if (fetch.getSubclassFetchMode(field.getTypeMapping())\n@@ -602,17 +698,7 @@ public void select(Select sel, int idx) {\n                     resJoins[idx]);\n             }\n         });\n-\n-        Result res = union.execute(store, fetch);\n-        try {\n-            Object val = null;\n-            if (res.next())\n-                val = res.load(rels[res.indexOf()], store, fetch,\n-                    resJoins[res.indexOf()]);\n-            sm.storeObject(field.getIndex(), val);\n-        } finally {\n-            res.close();\n-        }\n+        return union;\n     }\n \n     public Object toDataStoreValue(Object val, JDBCStore store) {"},{"sha":"4d178e08f668d5ae4fb994d6aecade6301dd54d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","status":"modified","additions":102,"deletions":12,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -22,21 +22,29 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfigurationImpl;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.FieldStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.sql.Joins;\n+import org.apache.openjpa.jdbc.sql.LogicalUnion;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.jdbc.sql.SelectExecutor;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n import org.apache.openjpa.jdbc.sql.Union;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.ChangeTracker;\n import org.apache.openjpa.util.Id;\n@@ -55,6 +63,9 @@\n public abstract class StoreCollectionFieldStrategy\n     extends ContainerFieldStrategy {\n \n+    private static final Localizer _loc = Localizer.forPackage\n+        (StoreCollectionFieldStrategy.class);\n+    \n     /**\n      * Return the foreign key used to join to the owning field for the given\n      * element mapping from {@link #getIndependentElementMappings} (or null).\n@@ -445,19 +456,83 @@ public void load(final OpenJPAStateManager sm, final JDBCStore store,\n             return;\n         }\n \n+        //cache union for field here\n         // select data for this sm\n+        boolean found = true;\n         final ClassMapping[] elems = getIndependentElementMappings(true);\n         final Joins[] resJoins = new Joins[Math.max(1, elems.length)];\n-        Union union = store.getSQLFactory().newUnion\n-            (Math.max(1, elems.length));\n-        union.select(new Union.Selector() {\n-            public void select(Select sel, int idx) {\n-                ClassMapping elem = (elems.length == 0) ? null : elems[idx];\n-                resJoins[idx] = selectAll(sel, elem, sm, store, fetch,\n-                    JDBCFetchConfiguration.EAGER_PARALLEL);\n+        List parmList = null;\n+        Union union = null;\n+        SelectImpl sel = null;\n+        Map<JDBCStoreManager.SelectKey, Object[]> storeCollectionUnionCache = null;\n+        JDBCStoreManager.SelectKey selKey = null;\n+        if (!((JDBCStoreManager)store).isQuerySQLCacheOn())\n+            union = newUnion(sm, store, fetch, elems, resJoins);\n+        else {\n+            parmList = new ArrayList();\n+            JDBCFetchConfiguration fetchClone = new JDBCFetchConfigurationImpl();\n+            fetchClone.copy(fetch);\n+           \n+            // to specify the type so that no cast is needed\n+            storeCollectionUnionCache = ((JDBCStoreManager)store).\n+                getCacheMapFromQuerySQLCache(StoreCollectionFieldStrategy.class);\n+            selKey = \n+                new JDBCStoreManager.SelectKey(null, field, fetchClone);\n+            Object[] objs = storeCollectionUnionCache.get(selKey);\n+            if (objs != null) {\n+                union = (Union) objs[0];\n+                resJoins[0] = (Joins) objs[1];\n             }\n-        });\n-\n+            else {\n+                synchronized(storeCollectionUnionCache) {\n+                    objs = storeCollectionUnionCache.get(selKey);\n+                    if (objs == null) {\n+                        // select data for this sm\n+                        union = newUnion(sm, store, fetch, elems, resJoins);\n+                        found = false;\n+                    } else {\n+                        union = (Union) objs[0];\n+                        resJoins[0] = (Joins) objs[1];\n+                    }\n+\n+                    sel = ((LogicalUnion.UnionSelect)union.getSelects()[0]).\n+                        getDelegate();\n+                    if (sel.getSQL() == null) {\n+                    \t((SelectImpl)sel).setSQL(store, fetch);\n+                        found = false;\n+                    }\n+\n+                    // only cache the union when elems length is 1 for now\n+                    if (!found && elems.length == 1) { \n+                        Object[] objs1 = new Object[2];\n+                        objs1[0] = union;\n+                        objs1[1] = resJoins[0];\n+                        ((JDBCStoreManager)store).addToSqlCache(\n+                            storeCollectionUnionCache, selKey, objs1);\n+                     }\n+                }\n+            }\n+            \n+            Log log = store.getConfiguration().\n+                getLog(JDBCConfiguration.LOG_JDBC);\n+            if (log.isTraceEnabled()) {\n+                if (found)\n+                    log.trace(_loc.get(\"cache-hit\", field, this.getClass()));\n+                else\n+                    log.trace(_loc.get(\"cache-missed\", field, this.getClass())); \n+            }\n+            \n+            ClassMapping mapping = field.getDefiningMapping();\n+            Object oid = sm.getObjectId();\n+            Column[] cols = mapping.getPrimaryKeyColumns();\n+            if (sel == null)\n+                sel = ((LogicalUnion.UnionSelect)union.getSelects()[0]).\n+                getDelegate();\n+\n+            sel.wherePrimaryKey(mapping, cols, cols, oid, store, \n+                \tnull, null, parmList);\n+        }\n+        \n         // create proxy\n         Object coll;\n         ChangeTracker ct = null;\n@@ -470,14 +545,14 @@ public void select(Select sel, int idx) {\n         }\n \n         // load values\n-        Result res = union.execute(store, fetch);\n+        Result res = union.execute(store, fetch, parmList);\n         try {\n             int seq = -1;\n             while (res.next()) {\n                 if (ct != null && field.getOrderColumn() != null)\n                     seq = res.getInt(field.getOrderColumn());\n-                add(store, coll, loadElement(sm, store, fetch, res,\n-                    resJoins[res.indexOf()]));\n+               \tadd(store, coll, loadElement(sm, store, fetch, res,\n+           \t        resJoins[res.indexOf()]));\n             }\n             if (ct != null && field.getOrderColumn() != null)\n                 ct.setNextSequence(seq + 1);\n@@ -493,6 +568,21 @@ public void select(Select sel, int idx) {\n             sm.storeObject(field.getIndex(), coll);\n     }\n \n+    protected Union newUnion(final OpenJPAStateManager sm, final JDBCStore store,\n+        final JDBCFetchConfiguration fetch, final ClassMapping[] elems,\n+        final Joins[] resJoins) {\n+        Union union = store.getSQLFactory().newUnion\n+        (Math.max(1, elems.length));\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                ClassMapping elem = (elems.length == 0) ? null : elems[idx];\n+                resJoins[idx] = selectAll(sel, elem, sm, store, fetch,\n+                        JDBCFetchConfiguration.EAGER_PARALLEL);\n+            }\n+        });\n+        return union;\n+    }\n+    \n     /**\n      * Select data for loading, starting in field table.\n      */"},{"sha":"9f28b9bb13d9e98902564a5a3646aad86d262fb1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","status":"modified","additions":48,"deletions":7,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -202,20 +202,32 @@ public int getCount(JDBCStore store)\n     }\n \n     public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+            throws SQLException {\n+        return execute(store, fetch, null);\n+    }    \n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel)\n+        throws SQLException {\n+        return execute(store, fetch, lockLevel, null);\n+    }\n+    \n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch, \n+        List params)\n         throws SQLException {\n         if (fetch == null)\n             fetch = store.getFetchConfiguration();\n-        return execute(store, fetch, fetch.getReadLockLevel());\n+        return execute(store, fetch, fetch.getReadLockLevel(), params);\n     }\n \n     public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n-        int lockLevel)\n+        int lockLevel, List params)\n         throws SQLException {\n         if (fetch == null)\n             fetch = store.getFetchConfiguration();\n \n         if (sels.length == 1) {\n-            Result res = sels[0].execute(store, fetch, lockLevel);\n+            Result res = sels[0].execute(store, fetch, lockLevel, params);\n             ((AbstractResult) res).setBaseMapping(mappings[0]);\n             return res;\n         }\n@@ -224,7 +236,7 @@ public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n             AbstractResult res;\n             for (int i = 0; i < sels.length; i++) {\n                 res = (AbstractResult) sels[i].execute(store, fetch,\n-                    lockLevel);\n+                    lockLevel, params);\n                 res.setBaseMapping(mappings[i]);\n                 res.setIndexOf(i);\n \n@@ -256,7 +268,7 @@ public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n             List l;\n             for (int i = 0; i < res.length; i++) {\n                 res[i] = (AbstractResult) sels[i].execute(store, fetch,\n-                    lockLevel);\n+                    lockLevel, params);\n                 res[i].setBaseMapping(mappings[i]);\n                 res[i].setIndexOf(i);\n \n@@ -303,7 +315,7 @@ public String toString() {\n     /**\n      * A select that is part of a logical union.\n      */\n-    protected class UnionSelect\n+    public class UnionSelect\n         implements Select {\n \n         protected final SelectImpl sel;\n@@ -396,6 +408,18 @@ public int getCount(JDBCStore store)\n             return sel.getCount(store);\n         }\n \n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch, \n+            List params)\n+            throws SQLException {\n+            return sel.execute(store, fetch, params);\n+        }\n+\n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+            int lockLevel, List params)\n+            throws SQLException {\n+            return sel.execute(store, fetch, lockLevel, params);\n+        }\n+\n         public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n             throws SQLException {\n             return sel.execute(store, fetch);\n@@ -406,7 +430,7 @@ public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n             throws SQLException {\n             return sel.execute(store, fetch, lockLevel);\n         }\n-\n+        \n         public List getSubselects() {\n             return Collections.EMPTY_LIST;\n         }\n@@ -475,6 +499,14 @@ public SQLBuffer getHaving() {\n             return sel.getHaving();\n         }\n \n+        public SQLBuffer getSQL() {\n+            return sel.getSQL();\n+        }\n+        \n+        public void setSQL(JDBCStore store, JDBCFetchConfiguration fetch) {\n+            sel.setSQL(store, fetch);\n+        }\n+        \n         public void addJoinClassConditions() {\n             sel.addJoinClassConditions();\n         }\n@@ -717,6 +749,15 @@ public void wherePrimaryKey(Object oid, ClassMapping mapping,\n             JDBCStore store) {\n             sel.wherePrimaryKey(oid, mapping, store);\n         }\n+        \n+        public int wherePrimaryKey(ClassMapping mapping, Column[] toCols, \n+            Column[] fromCols, Object oid, JDBCStore store, PathJoins pj,\n+            SQLBuffer buf, List parmList) {\n+            return sel.wherePrimaryKey(mapping, toCols, fromCols, oid, store, pj, \n+                buf, parmList);\n+        }\n+        \n+        \n \n         public void whereForeignKey(ForeignKey fk, Object oid,\n             ClassMapping mapping, JDBCStore store) {"},{"sha":"073b35139be7de46a30c7585e4d209a4f7237071","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"modified","additions":37,"deletions":5,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -445,14 +445,24 @@ public PreparedStatement prepareStatement(Connection conn)\n             ResultSet.CONCUR_READ_ONLY);\n     }\n \n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn, int rsType,\n+        int rsConcur, List parms)\n+        throws SQLException {\n+        return prepareStatement(conn, null, rsType, rsConcur, parms);\n+    }\n+    \n     /**\n      * Create and populate the parameters of a prepared statement using\n      * the SQL in this buffer.\n      */\n     public PreparedStatement prepareStatement(Connection conn, int rsType,\n         int rsConcur)\n         throws SQLException {\n-        return prepareStatement(conn, null, rsType, rsConcur);\n+        return prepareStatement(conn, rsType, rsConcur, null);\n     }\n \n     /**\n@@ -462,6 +472,16 @@ public PreparedStatement prepareStatement(Connection conn, int rsType,\n     public PreparedStatement prepareStatement(Connection conn,\n         JDBCFetchConfiguration fetch, int rsType, int rsConcur)\n         throws SQLException {\n+        return prepareStatement(conn, fetch, rsType, rsConcur, null);\n+    }\n+    \n+    /**\n+     * Create and populate the parameters of a prepred statement using the\n+     * SQL in this buffer and the given fetch configuration.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn,\n+        JDBCFetchConfiguration fetch, int rsType, int rsConcur, List parms)\n+        throws SQLException {\n         if (rsType == -1 && fetch == null)\n             rsType = ResultSet.TYPE_FORWARD_ONLY;\n         else if (rsType == -1)\n@@ -476,7 +496,7 @@ else if (rsType == -1)\n         else\n             stmnt = conn.prepareStatement(getSQL(), rsType, rsConcur);\n         try {\n-            setParameters(stmnt);\n+            setParameters(stmnt, parms);\n             if (fetch != null) {\n                 if (fetch.getFetchBatchSize() > 0)\n                     stmnt.setFetchSize(fetch.getFetchBatchSize());\n@@ -559,13 +579,25 @@ else if (rsType == -1)\n      */\n     public void setParameters(PreparedStatement ps)\n         throws SQLException {\n-        if (_params == null)\n+        setParameters(ps, null);\n+    }\n+    \n+    /**\n+     * Populate the parameters of an existing PreparedStatement\n+     * with values from this buffer.\n+     */\n+    public void setParameters(PreparedStatement ps, List cacheParams)\n+        throws SQLException {\n+        List params = ((cacheParams != null && cacheParams.size() > 0) ? \n+            cacheParams : _params);    \n+        \n+        if (params == null)\n             return;\n \n         Column col;\n-        for (int i = 0; i < _params.size(); i++) {\n+        for (int i = 0; i < params.size(); i++) {\n             col = (_cols == null) ? null : (Column) _cols.get(i);\n-            _dict.setUnknown(ps, i + 1, _params.get(i), col);\n+            _dict.setUnknown(ps, i + 1, params.get(i), col);\n         }\n     }\n "},{"sha":"14a0d5e0820dc4dd7ae56b4fbd43e4238a1fc020","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","status":"modified","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -192,6 +192,19 @@\n      */\n     public SQLBuffer getHaving();\n \n+    /**\n+     * Return the SQL for this select. This buffer contains\n+     * the final SQL to be executed/cached.\n+     */\n+    public SQLBuffer getSQL();    \n+    \n+    /**\n+     * Create and set the SQLBuffer object to this select. This buffer contains\n+     * the final SQL to be executed/cached.\n+     */\n+    public void setSQL(JDBCStore store, JDBCFetchConfiguration fetch); \n+    \n+    \n     /**\n      * Apply class conditions from relation joins.  This may affect the return\n      * values of {@link #getJoins}, {@link #getJoinIterator}, and\n@@ -515,6 +528,19 @@ public boolean orderBy(SQLBuffer sql, boolean asc, Joins joins,\n      */\n     public void wherePrimaryKey(Object oid, ClassMapping mapping,\n         JDBCStore store);\n+    \n+    \n+    /**\n+     * Add where conditions setting the mapping's primary key to the given\n+     * oid values. If the parmList is not null, the value of the primary\n+     * key will be collected and saved into the parmList. If the parmList is \n+     * null, this method will build the where clause with the value\n+     * incorporated in the where clause.\n+     */\n+    public int wherePrimaryKey(ClassMapping mapping, Column[] toCols, \n+            Column[] fromCols, Object oid, JDBCStore store, PathJoins pj,\n+            SQLBuffer buf, List parmList);\n+    \n \n     /**\n      * Add where conditions setting the given foreign key to the given"},{"sha":"72aa438bf701368e89c5fcf0cf5af84da832b8b8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -19,6 +19,7 @@\n package org.apache.openjpa.jdbc.sql;\n \n import java.sql.SQLException;\n+import java.util.List;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n@@ -129,6 +130,20 @@ public int getCount(JDBCStore store)\n     public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n         throws SQLException;\n \n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        List params) \n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel, List params)\n+        throws SQLException;\n+\n     /**\n      * Execute this select in the context of the given store manager.\n      */"},{"sha":"d8b75cd9d4a28fded5d9071451fa6a8972642035","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":139,"deletions":46,"changes":185,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -118,6 +118,9 @@\n     // 'parent.address.street' for the purposes of comparisons\n     private Map _aliases = null;\n \n+    // to cache table alias using Table as the key\n+    private Map _tableAliases = null;\n+\n     // map of indexes to table aliases like 'TABLENAME t0'\n     private SortedMap _tables = null;\n \n@@ -167,7 +170,10 @@\n     // if the bit is set, the corresponding alias has been removed from parent\n     // and recorded under subselect.\n     private BitSet _removedAliasFromParent = new BitSet(16);\n-     \n+\n+    //contains final sql statement to be executed/cached\n+    private SQLBuffer _sql = null;\n+    \n     /**\n      * Helper method to return the proper table alias for the given alias index.\n      */\n@@ -300,7 +306,7 @@ public int getCount(JDBCStore store)\n             stmnt = prepareStatement(conn, sql, null, \n                 ResultSet.TYPE_FORWARD_ONLY, \n                 ResultSet.CONCUR_READ_ONLY, false);\n-            rs = executeQuery(conn, stmnt, sql, false, store);\n+            rs = executeQuery(conn, stmnt, sql, false, store, null);\n             return getCount(rs);\n         } finally {\n             if (rs != null)\n@@ -312,37 +318,53 @@ public int getCount(JDBCStore store)\n         }\n     }\n \n-    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n-        throws SQLException {\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch, \n+        List parms) throws SQLException {\n         if (fetch == null)\n             fetch = store.getFetchConfiguration();\n         return execute(store.getContext(), store, fetch,\n-            fetch.getReadLockLevel());\n+            fetch.getReadLockLevel(), parms);\n+    }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch) \n+        throws SQLException {\n+        return execute(store, fetch, null);\n+     }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel, List parms)\n+        throws SQLException {\n+            if (fetch == null)\n+                fetch = store.getFetchConfiguration();\n+            return execute(store.getContext(), store, fetch, lockLevel, parms);\n     }\n \n     public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n         int lockLevel)\n         throws SQLException {\n-        if (fetch == null)\n-            fetch = store.getFetchConfiguration();\n-        return execute(store.getContext(), store, fetch, lockLevel);\n+        return execute(store, fetch, lockLevel, null);\n     }\n \n     /**\n      * Execute this select in the context of the given store manager. The\n      * context is passed in separately for profiling purposes.\n      */\n     protected Result execute(StoreContext ctx, JDBCStore store, \n-        JDBCFetchConfiguration fetch, int lockLevel)\n+        JDBCFetchConfiguration fetch, int lockLevel, List params)\n         throws SQLException {\n-        boolean forUpdate = false;\n-        if (!isAggregate() && _grouping == null) {\n-            JDBCLockManager lm = store.getLockManager();\n-            if (lm != null)\n-                forUpdate = lm.selectForUpdate(this, lockLevel);\n-        }\n-\n-        SQLBuffer sql = toSelect(forUpdate, fetch);\n+        boolean forUpdate = isForUpdate(store, lockLevel);\n+        \n+        // A non-null _sql indicates that this SelectImpl object\n+        // is obtained from cache. The _sql is constructed\n+        // under the assumption that isAggregate() is false\n+        // and _grouping is null. If neither of these holds,\n+        // we need to re-construct the _sql\n+        if (_sql != null && (isAggregate() || _grouping != null)) \n+            _sql = null;\n+        \n+        if (_sql == null) \n+        \t_sql = toSelect(forUpdate, fetch);\n+        \n         boolean isLRS = isLRS();\n         int rsType = (isLRS && supportsRandomAccess(forUpdate))\n             ? -1 : ResultSet.TYPE_FORWARD_ONLY;\n@@ -351,13 +373,15 @@ protected Result execute(StoreContext ctx, JDBCStore store,\n         ResultSet rs = null;\n         try {\n             if (isLRS) \n-                stmnt = prepareStatement(conn, sql, fetch, rsType, -1, true); \n+                stmnt = prepareStatement(conn, _sql, fetch, rsType, -1, true, \n+                        params); \n             else\n-                stmnt = prepareStatement(conn, sql, null, rsType, -1, false);\n+                stmnt = prepareStatement(conn, _sql, null, rsType, -1, false, \n+                        params);\n             \n             setTimeout(stmnt, forUpdate, fetch);\n             \n-            rs = executeQuery(conn, stmnt, sql, isLRS, store);\n+            rs = executeQuery(conn, stmnt, _sql, isLRS, store, params);\n         } catch (SQLException se) {\n             // clean up statement\n             if (stmnt != null)\n@@ -367,7 +391,17 @@ protected Result execute(StoreContext ctx, JDBCStore store,\n         }\n \n         return getEagerResult(conn, stmnt, rs, store, fetch, forUpdate, \n-            sql.getSQL());\n+            _sql.getSQL());\n+    }\n+    \n+    private boolean isForUpdate(JDBCStore store, int lockLevel) {\n+    \tboolean forUpdate = false;\n+        if (!isAggregate() && _grouping == null) {\n+            JDBCLockManager lm = store.getLockManager();\n+            if (lm != null)\n+                forUpdate = lm.selectForUpdate(this, lockLevel);\n+        }\n+        return forUpdate;\n     }\n \n     /**\n@@ -413,10 +447,22 @@ private static void addEagerResults(SelectResult res, SelectImpl sel,\n     protected PreparedStatement prepareStatement(Connection conn, \n         SQLBuffer sql, JDBCFetchConfiguration fetch, int rsType, \n         int rsConcur, boolean isLRS) throws SQLException {\n+        // add comments why we pass in null as the last parameter\n+        return prepareStatement(conn, sql, fetch, rsType, rsConcur, isLRS, \n+                null);\n+    }\n+\n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, \n+        SQLBuffer sql, JDBCFetchConfiguration fetch, int rsType, \n+        int rsConcur, boolean isLRS, List params) throws SQLException {\n         if (fetch == null)\n-            return sql.prepareStatement(conn, rsType, rsConcur);\n+            return sql.prepareStatement(conn, rsType, rsConcur, params);\n         else\n-            return sql.prepareStatement(conn, fetch, rsType, -1);\n+            return sql.prepareStatement(conn, fetch, rsType, -1, params);\n     }\n     \n     /**\n@@ -445,7 +491,8 @@ protected void setTimeout(PreparedStatement stmnt, boolean forUpdate,\n      * implementation of executing query.\n      */\n     protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt, \n-        SQLBuffer sql, boolean isLRS, JDBCStore store) throws SQLException {\n+        SQLBuffer sql, boolean isLRS, JDBCStore store, List params) \n+        throws SQLException {\n         return stmnt.executeQuery();\n     }\n     \n@@ -589,6 +636,19 @@ public SQLBuffer getHaving() {\n         return _having;\n     }\n \n+    public SQLBuffer getSQL() {\n+        return _sql;\n+    }\n+\n+    public void setSQL(SQLBuffer sql) {\n+        _sql = sql;\n+    }\n+\n+    public void setSQL(JDBCStore store, JDBCFetchConfiguration fetch) {\n+        boolean forUpdate = isForUpdate(store, fetch.getReadLockLevel());\n+        _sql = toSelect(forUpdate, fetch);\n+    }\n+    \n     public void addJoinClassConditions() {\n         if (_joins == null || _joins.joins() == null)\n             return;\n@@ -656,13 +716,30 @@ public String getColumnAlias(String col, Table table, Joins joins) {\n      * Return the alias for the given column.\n      */\n     private String getColumnAlias(String col, Table table, PathJoins pj) {\n+        String tableAlias = null;\n+        if (pj == null || pj.path() == null) {\n+            if (_tableAliases == null)\n+                _tableAliases = new HashMap();\n+            tableAlias = (String) _tableAliases.get(table);\n+            if (tableAlias == null) {\n+                tableAlias = getTableAlias(table, pj).toString();\n+                _tableAliases.put(table, tableAlias);\n+            }\n+            return new StringBuilder(tableAlias).append(col).toString();\n+        }\n+        return getTableAlias(table, pj).append(col).toString();\n+    }\n+    \n+    private StringBuilder getTableAlias(Table table, PathJoins pj) {\n+        StringBuilder buf = new StringBuilder();\n         if (_from != null) {\n             String alias = toAlias(_from.getTableIndex(table, pj, true));\n             if (_dict.requiresAliasForSubselect)\n-                return FROM_SELECT_ALIAS + \".\" + alias + \"_\" + col;\n-            return alias + \"_\" + col;\n+                return buf.append(FROM_SELECT_ALIAS).append(\".\").append(alias).\n+                    append(\"_\");\n+            return buf.append(alias).append(\"_\");\n         }\n-        return toAlias(getTableIndex(table, pj, true)) + \".\" + col;\n+        return buf.append(toAlias(getTableIndex(table, pj, true))).append(\".\");\n     }\n \n     public boolean isAggregate() {\n@@ -1263,12 +1340,38 @@ private void where(Object oid, ClassMapping mapping, Column[] toCols,\n             return;\n         }\n \n+        SQLBuffer buf = new SQLBuffer(_dict);\n+\n+        // only bother to pack pk values into array if app id        \n+        int count = wherePrimaryKey(mapping, toCols, fromCols, oid, store, pj, \n+        \tbuf, null);\n+            \t\n+        if (constCols != null && constCols.length > 0) {\n+            for (int i = 0; i < constCols.length; i++, count++) {\n+                if (count > 0)\n+                    buf.append(\" AND \");\n+                buf.append(getColumnAlias(constCols[i], pj));\n+\n+                if (vals[i] == null)\n+                    buf.append(\" IS \");\n+                else\n+                    buf.append(\" = \");\n+                buf.appendValue(vals[i], constCols[i]);\n+            }\n+        }\n+\n+        where(buf, pj);\n+    }\n+\n+    public int wherePrimaryKey(ClassMapping mapping, Column[] toCols, \n+    \tColumn[] fromCols, Object oid, JDBCStore store, PathJoins pj,\n+    \tSQLBuffer buf, List parmList) {\n         // only bother to pack pk values into array if app id\n+    \tboolean collectParmValueOnly = (parmList != null ? true : false);\n         Object[] pks = null;\n         if (mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\n             pks = ApplicationIds.toPKValues(oid, mapping);\n \n-        SQLBuffer buf = new SQLBuffer(_dict);\n         Joinable join;\n         Object val;\n         int count = 0;\n@@ -1281,8 +1384,13 @@ private void where(Object oid, ClassMapping mapping, Column[] toCols,\n                 val = pks[mapping.getField(join.getFieldIndex()).\n                     getPrimaryKeyIndex()];\n                 val = join.getJoinValue(val, toCols[i], store);\n+                if (parmList != null)\n+                \tparmList.add(val);\n             }\n-\n+            \n+            if (collectParmValueOnly) \n+            \tcontinue;\n+            \n             if (count > 0)\n                 buf.append(\" AND \");\n             buf.append(getColumnAlias(fromCols[i], pj));\n@@ -1292,24 +1400,9 @@ private void where(Object oid, ClassMapping mapping, Column[] toCols,\n                 buf.append(\" = \");\n             buf.appendValue(val, fromCols[i]);\n         }\n-\n-        if (constCols != null && constCols.length > 0) {\n-            for (int i = 0; i < constCols.length; i++, count++) {\n-                if (count > 0)\n-                    buf.append(\" AND \");\n-                buf.append(getColumnAlias(constCols[i], pj));\n-\n-                if (vals[i] == null)\n-                    buf.append(\" IS \");\n-                else\n-                    buf.append(\" = \");\n-                buf.appendValue(vals[i], constCols[i]);\n-            }\n-        }\n-\n-        where(buf, pj);\n+        return count;\n     }\n-\n+    \n     /**\n      * Test to see if the given set of columns contains all the\n      * columns in the given potential subset."},{"sha":"5c918cd85318cbd7821ef97cce57a87f0a12d686","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -113,4 +113,5 @@ graph-not-cycle-free: A circular flush dependency has been found after all \\\n batch_limit: The batch limit is set to {0}.\n batch_update_info: ExecuteBatch command returns update count {0} for \\\n \tstatement {1}.\n-    \n+cache-hit: SQL Cache hit with key: {0} in {1}\n+cache-missed: SQL Cache missed with key: {0} in {1}    "},{"sha":"6f7e16ebb87ee024d783ee81674d9bbe9c2b9266","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -134,3 +134,5 @@ bad-unmapped-rel: \"{0}\" cannot be mapped without stringifying the oid of \\\n \tits \"{1}\" primary key field does not use a simple mapping.\n unmapped-datastore-value: Instances of type \"{0}\" are not valid query \\\n \tparameters because the type is not mapped.\n+cache-hit: SQL Cache hit with key: {0} in {1}\n+cache-missed: SQL Cache missed with key: {0} in {1}"},{"sha":"9363edb9daf678d36f7e7841b05435fb08037481","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":38,"deletions":10,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -82,6 +82,9 @@\n         public Set rootClasses;\n         public Set rootInstances;\n         public Map hints = null;\n+        \n+        public boolean fetchGroupContainsDefault = false;\n+        public boolean fetchGroupContainsAll = false;\n     }\n \n     private final ConfigurationState _state;\n@@ -92,7 +95,7 @@\n     private boolean _load = true;\n     private int _availableRecursion;\n     private int _availableDepth;\n-\n+    \n     public FetchConfigurationImpl() {\n         this(null);\n     }\n@@ -221,10 +224,22 @@ public Set getFetchGroups() {\n \n     public boolean hasFetchGroup(String group) {\n         return _state.fetchGroups != null\n-            && (_state.fetchGroups.contains(group)\n-            || _state.fetchGroups.contains(FetchGroup.NAME_ALL));\n+            && (hasFetchGroupAll()\n+            ||  _state.fetchGroups.contains(group));\n     }\n \n+    public boolean hasFetchGroupDefault()\n+    {\n+        // Fetch group All includes fetch group Default by definition\n+        return _state.fetchGroupContainsDefault || \n+            _state.fetchGroupContainsAll;\n+    }\n+    \n+    public boolean hasFetchGroupAll()\n+    {\n+        return _state.fetchGroupContainsAll;\n+    }\n+    \n     public FetchConfiguration addFetchGroup(String name) {\n         if (StringUtils.isEmpty(name))\n             throw new UserException(_loc.get(\"null-fg\"));\n@@ -234,6 +249,10 @@ public FetchConfiguration addFetchGroup(String name) {\n             if (_state.fetchGroups == null)\n                 _state.fetchGroups = new HashSet();\n             _state.fetchGroups.add(name);\n+            if (FetchGroup.NAME_ALL.equals(name))\n+                _state.fetchGroupContainsAll = true;\n+            else if (FetchGroup.NAME_DEFAULT.equals(name))\n+                _state.fetchGroupContainsDefault = true;\n         } finally {\n             unlock();\n         }\n@@ -251,8 +270,13 @@ public FetchConfiguration addFetchGroups(Collection groups) {\n     public FetchConfiguration removeFetchGroup(String group) {\n         lock();\n         try {\n-            if (_state.fetchGroups != null)\n+            if (_state.fetchGroups != null) {\n                 _state.fetchGroups.remove(group);\n+                if (FetchGroup.NAME_ALL.equals(group))\n+                    _state.fetchGroupContainsAll = false;\n+                else if (FetchGroup.NAME_DEFAULT.equals(group))\n+                    _state.fetchGroupContainsDefault = false;\n+            }\n         } finally {\n             unlock();\n         }\n@@ -262,8 +286,9 @@ public FetchConfiguration removeFetchGroup(String group) {\n     public FetchConfiguration removeFetchGroups(Collection groups) {\n         lock();\n         try {\n-            if (_state.fetchGroups != null)\n-                _state.fetchGroups.removeAll(groups);\n+            if (_state.fetchGroups != null && groups != null)\n+                for (Object group : groups)\n+                    removeFetchGroup(group.toString());\n         } finally {\n             unlock();\n         }\n@@ -273,8 +298,11 @@ public FetchConfiguration removeFetchGroups(Collection groups) {\n     public FetchConfiguration clearFetchGroups() {\n         lock();\n         try {\n-            if (_state.fetchGroups != null)\n+            if (_state.fetchGroups != null) {\n                 _state.fetchGroups.clear();\n+                _state.fetchGroupContainsAll = false;\n+                _state.fetchGroupContainsDefault = true;\n+            }\n         } finally {\n             unlock();\n         }\n@@ -562,9 +590,9 @@ public FetchConfiguration traverse(FieldMetaData fm) {\n      * Whether our configuration state includes the given field.\n      */\n     private boolean includes(FieldMetaData fmd) {\n-        if ((fmd.isInDefaultFetchGroup() \n-            && hasFetchGroup(FetchGroup.NAME_DEFAULT))\n-            || hasFetchGroup(FetchGroup.NAME_ALL)\n+        if (hasFetchGroupAll()\n+            || (fmd.isInDefaultFetchGroup() \n+            && hasFetchGroupDefault())\n             || hasField(fmd.getFullName(false)))\n             return true;\n         String[] fgs = fmd.getCustomFetchGroups();"},{"sha":"1dcf94d9e8a078d19f2d4d801231fa084dbf38e1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestQuerySQLCache.java","status":"added","additions":391,"deletions":0,"changes":391,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestQuerySQLCache.java","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestQuerySQLCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestQuerySQLCache.java?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Persistence;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.persistence.EntityManagerImpl;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.simple.Person;\n+\n+/*\n+ * Verify multiple permutations of openjpa.jdbc.QuerySQLCache settings.\n+ */\n+public class TestQuerySQLCache\n+    extends TestCase {\n+    \n+    final int nThreads = 5;\n+    final int nPeople = 100;\n+    final int nIterations = 10;\n+\n+    /*\n+     * Verify QuerySQLCacheValue setting \"all\" is caching queries.\n+     */\n+    public void testAllCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"all\");\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\n+            OpenJPAPersistence.cast(\n+                Persistence.createEntityManagerFactory(\"test\", props));\n+        \n+        EntityManagerImpl em = (EntityManagerImpl)emf.createEntityManager();\n+        BrokerImpl broker = (BrokerImpl) em.getBroker();\n+        DelegatingStoreManager dstore = broker.getStoreManager();\n+        JDBCStoreManager jstore = \n+            (JDBCStoreManager)dstore.getInnermostDelegate();\n+\n+        em.getTransaction().begin();\n+        Person p = new Person();\n+        p.setId(1);\n+        em.persist(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        Person p1 = em.find(Person.class, 1);\n+        Map sqlCache = jstore.getQuerySQLCache();\n+        Set keys = sqlCache.keySet();\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            Map cacheMap = (Map) iter.next();\n+            //make sure there is an entry in the cache\n+            assertEquals(1, cacheMap.size());   \n+        }\n+        \n+        em.getTransaction().begin();\n+        em.remove(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        em.close();\n+        emf.close();\n+    }\n+    \n+    /*\n+     * Verify QuerySQLCacheValue setting \"true\" uses the expected cache\n+     * implementation and is caching.\n+     */\n+    public void testTrueCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"true\");\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\n+            OpenJPAPersistence.cast(\n+                Persistence.createEntityManagerFactory(\"test\", props));\n+        \n+        EntityManagerImpl em = (EntityManagerImpl)emf.createEntityManager();\n+        BrokerImpl broker = (BrokerImpl) em.getBroker();\n+        DelegatingStoreManager dstore = broker.getStoreManager();\n+        JDBCStoreManager jstore = \n+            (JDBCStoreManager)dstore.getInnermostDelegate();\n+        \n+        em.getTransaction().begin();\n+        Person p = new Person();\n+        p.setId(1);\n+        em.persist(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        Person p1 = em.find(Person.class, 1);\n+        Map sqlCache = jstore.getQuerySQLCache();\n+        Set keys = sqlCache.keySet();\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            Map cacheMap = (Map) iter.next();\n+            //make sure there is an entry in the cache\n+            assertEquals(1, cacheMap.size());   \n+        }\n+        \n+        em.getTransaction().begin();\n+        em.remove(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        em.close();\n+        emf.close();\n+    }\n+\n+    /*\n+     * Verify caching is disabled when the QuerySQLCacheValue setting is \n+     * \"false\".\n+     */\n+    public void testFalseCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \"false\");\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\n+            OpenJPAPersistence.cast(\n+                Persistence.createEntityManagerFactory(\"test\", props));\n+        \n+        EntityManagerImpl em = (EntityManagerImpl)emf.createEntityManager();\n+        BrokerImpl broker = (BrokerImpl) em.getBroker();\n+        DelegatingStoreManager dstore = broker.getStoreManager();\n+        JDBCStoreManager jstore = \n+            (JDBCStoreManager)dstore.getInnermostDelegate();\n+        \n+        em.getTransaction().begin();\n+        Person p = new Person();\n+        p.setId(1);\n+        em.persist(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        Person p1 = em.find(Person.class, 1);\n+\n+        assertFalse(jstore.isQuerySQLCacheOn());\n+        \n+        em.getTransaction().begin();\n+        em.remove(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        em.close();\n+        emf.close();\n+    }\n+\n+    /*\n+     * Verify QuerySQLCacheValue setting with a custom cache backend uses\n+     * the expected cache implementation and is caching.\n+     */\n+    public void testCustomCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \n+            \"org.apache.openjpa.kernel.TestQuerySQLCache.CustomCacheMap\");\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\n+            OpenJPAPersistence.cast(\n+                Persistence.createEntityManagerFactory(\"test\", props));\n+        \n+        EntityManagerImpl em = (EntityManagerImpl)emf.createEntityManager();\n+        BrokerImpl broker = (BrokerImpl) em.getBroker();\n+        DelegatingStoreManager dstore = broker.getStoreManager();\n+        JDBCStoreManager jstore = \n+            (JDBCStoreManager)dstore.getInnermostDelegate();\n+        \n+        em.getTransaction().begin();\n+        Person p = new Person();\n+        p.setId(1);\n+        em.persist(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        Person p1 = em.find(Person.class, 1);\n+\n+        assertTrue(jstore.isQuerySQLCacheOn());\n+\n+        Map sqlCache = jstore.getQuerySQLCache();\n+        Set keys = sqlCache.keySet();\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            Map cacheMap = (Map) iter.next();\n+            assertTrue((cacheMap instanceof \n+                org.apache.openjpa.kernel.TestQuerySQLCache.CustomCacheMap));\n+            //make sure there is an entry in the cache\n+            assertEquals(1, cacheMap.size());   \n+        }\n+        \n+        em.getTransaction().begin();\n+        em.remove(p);\n+        em.flush();\n+        em.getTransaction().commit();\n+        \n+        em.close();\n+        emf.close();\n+    }\n+\n+    /*\n+     * Verify an exception is thrown if a bad cache implementation class\n+     * is specified.\n+     */\n+    public void testBadCustomCacheSetting() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \n+            \"org.apache.openjpa.kernel.TestQuerySQLCache.BadCacheMap\");\n+        \n+        try {\n+            OpenJPAEntityManagerFactorySPI emf = \n+                (OpenJPAEntityManagerFactorySPI)OpenJPAPersistence.cast(\n+                        Persistence.createEntityManagerFactory(\"test\", props));\n+            // EMF creation should throw an exception because the cache \n+            // implementation class will not be found.\n+            assertFalse(false);\n+        } catch (Exception e) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+    /*\n+     * Verify multi-threaded multi-entity manager finder works with the\n+     * QuerySQLCache set to \"all\".\n+     */\n+    public void testMultiEMCachingAll() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \n+            \"all\");\n+        runMultiEMCaching(props);        \n+    }\n+\n+    /*\n+     * Verify multi-threaded multi-entity manager finder works with the\n+     * QuerySQLCache set to \"true\".\n+     */\n+    public void testMultiEMCachingTrue() {\n+        Map props = new HashMap(System.getProperties());\n+        props.put(\"openjpa.MetaDataFactory\", \"jpa(Types=\" \n+            + Person.class.getName() + \")\");\n+        props.put(\"openjpa.jdbc.QuerySQLCache\", \n+            \"true\");\n+        runMultiEMCaching(props);\n+    }\n+\n+    private void runMultiEMCaching(Map props) {\n+\n+        EntityManagerFactory emfac = \n+                Persistence.createEntityManagerFactory(\"test\", props);\n+\n+        EntityManager em = emfac.createEntityManager();            \n+\n+        // Create some entities\n+        em.getTransaction().begin();\n+        for (int i = 0; i < nPeople; i++)\n+        {\n+            Person p = new Person();\n+            p.setId(i);\n+            em.persist(p);\n+        }\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        Thread[] newThreads = new Thread[nThreads];\n+        FindPeople[] customer = new FindPeople[nThreads];\n+        \n+        for (int i=0; i < nThreads; i++) {\n+            customer[i] = new FindPeople(emfac, 0, nPeople, \n+                nIterations, i);\n+            newThreads[i] = new Thread(customer[i]);\n+            newThreads[i].start();\n+        }\n+        \n+        // Wait for the worker threads to complete\n+        for (int i = 0; i < nThreads; i++) {\n+            try {\n+                newThreads[i].join();\n+            } catch (InterruptedException e) {\n+                this.fail(\"Caught Interrupted Exception: \" + e);\n+            }\n+        }   \n+\n+        // Run through the state of all runnables to assert if any of them\n+        // failed.\n+        for (int i = 0; i < nThreads; i++) {\n+            assertFalse(customer[i].hadFailures());\n+        }\n+\n+        // Clean up the entities used in this test\n+        em = emfac.createEntityManager();            \n+        em.getTransaction().begin();\n+\n+        for (int i = 0; i < nPeople; i++) {\n+            Person p = em.find(Person.class, i);\n+            em.remove(p);\n+        }\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+    \n+    /*\n+     * Empty ConcurrentHashMap subclass. Useful for testing custom cache\n+     * storage implementations.\n+     */\n+    public class CustomCacheMap extends ConcurrentHashMap {\n+        \n+    }\n+\n+    /*\n+     * Simple runnable to test finder in a tight loop.  Multiple instances\n+     * of this runnable will run simultaneously.\n+     */\n+    private class FindPeople implements Runnable {\n+        \n+        private int startId;\n+        private int endId;\n+        private int thread;\n+        private int iterations;\n+        private EntityManagerFactory emf;\n+        private boolean failures = false;\n+        \n+        public FindPeople(EntityManagerFactory emf, \n+            int startId, int endId, int iterations, int thread) {\n+            super();\n+            this.startId = startId;\n+            this.endId = endId;\n+            this.thread = thread;\n+            this.iterations = iterations;\n+            this.emf = emf;\n+        }\n+        \n+        public boolean hadFailures()\n+        {\n+            return failures;\n+        }\n+        \n+        public void run() {\n+            try {            \n+                EntityManager em = emf.createEntityManager();            \n+                for (int j = 0; j < iterations; j++) {\n+                    \n+                    for (int i = startId; i < endId; i++) {\n+                        Person p1 = em.find(Person.class, i);\n+                        if (p1.getId() != i) {\n+                            System.out.println(\"Finder failed: \" + i);\n+                            failures = true;\n+                            break;\n+                        }                    \n+                    }\n+                    em.clear();  \n+                }\n+                em.close();  \n+            } \n+            catch (Exception e) {\n+               failures = true;\n+               System.out.println(\"Thread \" + thread + \" exception :\" +\n+                   e );\n+            }\n+        }\n+    }\n+}"},{"sha":"cd36c6e14808cae519c9090ba26b73b54508bde8","filename":"openjpa-project/src/doc/manual/ref_guide_caching.xml","status":"modified","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-project/src/doc/manual/ref_guide_caching.xml","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-project/src/doc/manual/ref_guide_caching.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_caching.xml?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -885,4 +885,85 @@ Disables the compilation cache.\n \t\t\t</tgroup>\n \t\t</table>\n \t</section>\n+    <section id=\"ref_guide_cache_querysql\">\n+        <title>\n+            Query SQL Cache\n+        </title>\n+        <indexterm zone=\"ref_guide_cache_querysql\">\n+            <primary>\n+                caching\n+            </primary>\n+            <secondary>\n+                query sql cache\n+            </secondary>\n+        </indexterm>\n+        <para>\n+The query SQL cache is a <classname>Map</classname> used to cache \n+pushed-down SQL query strings for the find operation.  As a result, \n+the SQL queries are only generated once in OpenJPA, and cached thereafter.  \n+This query SQL cache is shared across entity managers and the fetch plan \n+is part of the cache key. You can control the SQL cache through \n+the <link linkend=\"openjpa.jdbc.QuerySQLCache\"><literal>\n+openjpa.jdbc.QuerySQLCache</literal></link> configuration property.  This \n+property accepts a plugin string (see <xref linkend=\"ref_guide_conf_plugins\"/>) \n+describing the <classname>Map</classname> used to associate query strings and \n+their parsed form.  This property accepts the following aliases:\n+        </para>\n+        <table>\n+            <title>\n+                Pre-defined aliases\n+            </title>\n+            <tgroup cols=\"2\" align=\"left\" colsep=\"1\" rowsep=\"1\">\n+                <colspec colname=\"alias\"/>\n+                <colspec colname=\"value\"/>\n+                <colspec colname=\"notes\"/>\n+                <thead>\n+                    <row>\n+                        <entry colname=\"alias\">Alias</entry>\n+                        <entry colname=\"value\">Value</entry>\n+                        <entry colname=\"notes\">Notes</entry>\n+                    </row>\n+                </thead>\n+                <tbody>\n+                    <row>\n+                        <entry colname=\"alias\">\n+<literal>true</literal>\n+                        </entry>\n+                        <entry colname=\"value\">\n+<literal>org.apache.openjpa.util.CacheMap</literal>\n+                        </entry>\n+                        <entry colname=\"notes\">\n+The default option.  Uses a \n+<ulink url=\"../javadoc/org/apache/openjpa/util/CacheMap.html\"> \n+<literal>CacheMap</literal></ulink> to store sql string.  \n+<literal>CacheMap</literal> maintains a fixed number of cache entries, and an \n+optional soft reference map for entries that are moved out of the LRU space. \n+So, for applications that have a monotonically increasing number of distinct \n+queries, this option can be used to ensure that a fixed amount of memory is \n+used by the cache.\n+                        </entry>\n+                    </row>\n+                    <row>\n+                        <entry colname=\"alias\"><literal>all</literal></entry>\n+                        <entry colname=\"value\">\n+<literal>org.apache.openjpa.lib.util.ConcurrentHashMap</literal>\n+                        </entry>\n+                        <entry colname=\"notes\">\n+This is the fastest option, but sql string is never dropped from the \n+cache, so if you use a large number of dynamic queries, this option may result \n+in ever-increasing memory usage. Note that if your queries only differ in the \n+values of the parameters, this should not be an issue.\n+                        </entry>\n+                    </row>\n+                    <row>\n+                        <entry colname=\"alias\"><literal>false</literal></entry>\n+                        <entry colname=\"value\"><emphasis>none</emphasis></entry>\n+                        <entry colname=\"notes\">\n+Disables the sql cache.\n+                        </entry>\n+                    </row>\n+                </tbody>\n+            </tgroup>\n+        </table>\n+    </section>\n </chapter>"},{"sha":"fa9dc03766cad396e4f8902bc25b0ea08f8a32b9","filename":"openjpa-project/src/doc/manual/ref_guide_conf.xml","status":"modified","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-project/src/doc/manual/ref_guide_conf.xml","raw_url":"https://github.com/apache/openjpa/raw/0f32d376687fd1515a4cd9b8953e14b666499e93/openjpa-project/src/doc/manual/ref_guide_conf.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_conf.xml?ref=0f32d376687fd1515a4cd9b8953e14b666499e93","patch":"@@ -3328,6 +3328,42 @@ store and retrieve object-relational mapping information for your persistent\n classes. See <xref linkend=\"ref_guide_mapping_factory\"/> for details.\n             </para>\n         </section>\n+        <section id=\"openjpa.jdbc.QuerySQLCache\">\n+            <title>\n+                openjpa.jdbc.QuerySQLCache\n+            </title>\n+            <indexterm zone=\"openjpa.jdbc.QuerySQLCache\">\n+                <primary>\n+                    QuerySQLCache\n+                </primary>\n+            </indexterm>\n+            <indexterm zone=\"openjpa.jdbc.QuerySQLCache\">\n+                <primary>\n+                    caching\n+                </primary>\n+                <secondary>\n+                    QuerySQLCache\n+                </secondary>\n+            </indexterm>\n+            <para>\n+<emphasis role=\"bold\">Property name:</emphasis>\n+<literal>openjpa.jdbc.QuerySQLCache</literal>\n+            </para>\n+            <para>\n+<emphasis role=\"bold\">Resource adaptor config-property:</emphasis> \n+<literal>QuerySQLCache</literal>\n+            </para>\n+            <para>\n+<emphasis role=\"bold\">Default:</emphasis> <literal>true</literal>.\n+            </para>\n+            <para>\n+<emphasis role=\"bold\">Description:</emphasis> A plugin string (see \n+<xref linkend=\"ref_guide_conf_plugins\"/>) describing the \n+<classname>java.util.Map</classname> to use for caching of the SQL string \n+used by the find operation.  See <xref linkend=\"ref_guide_cache_querysql\"/> for \n+details.\n+            </para>\n+        </section>\n         <section id=\"openjpa.jdbc.ResultSetType\">\n             <title>\n                 openjpa.jdbc.ResultSetType"}]}

