{"sha":"115af5954d8ba917d83b7dceb181b01257c359ab","node_id":"MDY6Q29tbWl0MjA2MzY0OjExNWFmNTk1NGQ4YmE5MTdkODNiN2RjZWIxODFiMDEyNTdjMzU5YWI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:51:28Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:51:28Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@757282 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ab319d3032f3fa17ec07fc7036deedcd8f73f16c","url":"https://api.github.com/repos/apache/openjpa/git/trees/ab319d3032f3fa17ec07fc7036deedcd8f73f16c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/115af5954d8ba917d83b7dceb181b01257c359ab","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/115af5954d8ba917d83b7dceb181b01257c359ab","html_url":"https://github.com/apache/openjpa/commit/115af5954d8ba917d83b7dceb181b01257c359ab","comments_url":"https://api.github.com/repos/apache/openjpa/commits/115af5954d8ba917d83b7dceb181b01257c359ab/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","url":"https://api.github.com/repos/apache/openjpa/commits/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","html_url":"https://github.com/apache/openjpa/commit/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb"}],"stats":{"total":290030,"additions":145015,"deletions":145015},"files":[{"sha":"c445fdb8461789a8d3bb30f1b107db5626b04aa1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":545,"deletions":545,"changes":1090,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,546 +1,546 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowImpl;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n-import org.apache.openjpa.lib.graph.Edge;\r\n-import org.apache.openjpa.lib.graph.Graph;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ConstraintUpdateManager\r\n-    extends AbstractUpdateManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ConstraintUpdateManager.class);\r\n-\r\n-    public boolean orderDirty() {\r\n-        return true;\r\n-    }\r\n-\r\n-    protected PreparedStatementManager newPreparedStatementManager\r\n-        (JDBCStore store, Connection conn) {\r\n-        return new PreparedStatementManagerImpl(store, conn);\r\n-    }\r\n-\r\n-    protected RowManager newRowManager() {\r\n-        return new RowManagerImpl(false);\r\n-    }\r\n-\r\n-    protected Collection flush(RowManager rowMgr,\r\n-        PreparedStatementManager psMgr, Collection exceps) {\r\n-        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n-\r\n-        // first take care of all secondary table deletes and 'all row' deletes\r\n-        // (which are probably secondary table deletes), since no foreign\r\n-        // keys ever rely on secondary table pks\r\n-        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n-        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n-\r\n-        // now do any 'all row' updates\r\n-        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n-\r\n-        // analyze foreign keys\r\n-        Collection inserts = rmimpl.getInserts();\r\n-        Collection updates = rmimpl.getUpdates();\r\n-        Collection deletes = rmimpl.getDeletes();\r\n-        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n-        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n-\r\n-        // flush insert graph, if any\r\n-        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n-        try {\r\n-            flushGraph(graphs[0], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // flush the rest of the inserts and updates; inserts before updates\r\n-        // because some update fks might reference pks that have to be inserted\r\n-        flush(inserts, psMgr);\r\n-        flush(updates, psMgr);\r\n-\r\n-        // flush the delete graph, if any\r\n-        try {\r\n-            flushGraph(graphs[1], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // put the remainder of the deletes after updates because some updates\r\n-        // may be nulling fks to rows that are going to be deleted\r\n-        flush(deletes, psMgr);\r\n-\r\n-        // take care of all secondary table inserts and updates last, since\r\n-        // they may rely on previous inserts or updates, but nothing relies\r\n-        // on them\r\n-        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n-\r\n-        // flush any left over prepared statements\r\n-        psMgr.flush();\r\n-        return exceps;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze foreign key dependencies on the given rows\r\n-     * and create an insert and a delete graph to execute.  The insert\r\n-     * graph will be flushed before all other rows, and the delete graph will\r\n-     * be flushed after them.\r\n-     */\r\n-    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n-        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n-        // if there are any deletes, we have to map the insert objects on their\r\n-        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n-        Map insertMap = null;\r\n-        OpenJPAStateManager sm;\r\n-        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n-            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n-            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n-                sm = ((Row) itr.next()).getPrimaryKey();\r\n-                if (sm != null && sm.getObjectId() != null)\r\n-                    insertMap.put(sm.getObjectId(), sm);\r\n-            }\r\n-        }\r\n-\r\n-        // first construct the graph for deletes; this may expand to include\r\n-        // inserts and updates as well if there are any inserts that rely on\r\n-        // deletes (delete-then-insert-same-pk cases)\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        OpenJPAStateManager fkVal;\r\n-        boolean ignoreUpdates = true;\r\n-        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            row2 = getInsertRow(insertMap, rowMgr, row);\r\n-            if (row2 != null) {\r\n-                ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n-            }\r\n-\r\n-            // now check this row's fks against other deletes\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                // when deleting ref fks they'll just set a where value, so\r\n-                // check both for fk updates (relation fks) and wheres (ref fks)\r\n-                fkVal = row.getForeignKeySet(fks[j]);\r\n-                if (fkVal == null)\r\n-                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n-                if (fkVal == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_DELETE, fkVal, false);\r\n-                if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n-                        fks[j]);\r\n-            }\r\n-        }\r\n-\r\n-        if (ignoreUpdates)\r\n-            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n-        else {\r\n-            // put inserts *and updates* in the delete graph; they all rely\r\n-            // on each other\r\n-            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n-            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if there is an insert for for the same table and primary\r\n-     * key values as the given delete row.\r\n-     */\r\n-    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n-        if (insertMap == null)\r\n-            return null;\r\n-\r\n-        OpenJPAStateManager sm = row.getPrimaryKey();\r\n-        if (sm == null)\r\n-            return null;\r\n-\r\n-        // look for a new object whose insert id is the same as this delete one\r\n-        Object oid = sm.getObjectId();\r\n-        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n-        if (nsm == null)\r\n-            return null;\r\n-\r\n-        // found new object; get its row\r\n-        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n-        return (row == null || row.isValid()) ? row : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the given rows against the inserts, placing dependencies\r\n-     * in the given graph.\r\n-     */\r\n-    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n-        Graph graph) {\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        Column[] cols;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            // check this row's fks against inserts; a logical fk to an auto-inc\r\n-            // column is treated just as actual database fk because the result\r\n-            // is the same: the pk row has to be inserted before the fk row\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                if (row.getForeignKeySet(fks[j]) == null)\r\n-                    continue;\r\n-\r\n-                // see if this row is dependent on another.  if it's only\r\n-                // depenent on itself, see if the fk is logical or deferred, in\r\n-                // which case it must be an auto-inc because otherwise we\r\n-                // wouldn't have recorded it\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n-                if (row2 != null && row2.isValid() && (row2 != row\r\n-                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n-            }\r\n-\r\n-            // see if there are any relation id columns dependent on\r\n-            // auto-inc objects\r\n-            cols = row.getTable().getRelationIdColumns();\r\n-            for (int j = 0; j < cols.length; j++) {\r\n-                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n-                if (sm == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n-                    sm, false);\r\n-                if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n-            }\r\n-        }\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base table for the given instance.\r\n-     */\r\n-    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n-        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n-        while (cls.getJoinablePCSuperclassMapping() != null)\r\n-            cls = cls.getJoinablePCSuperclassMapping();\r\n-        return cls.getTable();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge between the given rows in the given foreign key graph.\r\n-     */\r\n-    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n-        Object fk) {\r\n-        // delay creation of the graph\r\n-        if (graph == null)\r\n-            graph = new Graph();\r\n-\r\n-        row1.setDependent(true);\r\n-        row2.setDependent(true);\r\n-        graph.addNode(row1);\r\n-        graph.addNode(row2);\r\n-\r\n-        // add an edge from row1 to row2, and set the fk causing the\r\n-        // dependency as the user object so we can retrieve it when resolving\r\n-        // circular constraints\r\n-        Edge edge = new Edge(row1, row2, true);\r\n-        edge.setUserObject(fk);\r\n-        graph.addEdge(edge);\r\n-\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given graph of rows in the proper order.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param psMgr The prepared statement manager to use to issue the\r\n-     * statements\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n-        boolean autoAssign)\r\n-        throws SQLException {\r\n-        if (graph == null)\r\n-            return;\r\n-\r\n-        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        Collection insertUpdates = new LinkedList();\r\n-        Collection deleteUpdates = new LinkedList();\r\n-        boolean recalculate;\r\n-\r\n-        // Handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, \r\n-        //   then use an update statement to null A's fk to B before flushing, \r\n-        //   and then flush\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, then flush,\r\n-        //   and after flushing, use an update to set the fk back to A\r\n-        // Depending on where circular dependencies are broken, the  \r\n-        // topological order of the graph nodes has to be re-calculated.\r\n-        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n-                deleteUpdates, insertUpdates);\r\n-        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n-                deleteUpdates, insertUpdates);\r\n-\r\n-        if (recalculate) {\r\n-            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n-        }\r\n-\r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        flush(deleteUpdates, psMgr);\r\n-        Collection nodes = dfa.getSortedNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-        flush(insertUpdates, psMgr);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by delete operations.\r\n-     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n-     * statement to null A's fk to B before deleting B, then delete A.\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param deleteUpdates Collection of update statements that are executed\r\n-     * before the delete operations are flushed \r\n-     */\r\n-    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n-        throws SQLException {\r\n-        PrimaryRow row;\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-\r\n-        // copy where conditions into new update that nulls the fk\r\n-        row = (PrimaryRow) edge.getTo();\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        row.copyInto(update, true);\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-        } else\r\n-            update.setNull((Column) edge.getUserObject());\r\n-\r\n-        deleteUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by insert operations.\r\n-     * If inserted row A has a circular fk to updated/inserted row B,\r\n-     * then null the fk in the B row object, then flush,\r\n-     * and after flushing, use an update to set the fk back to A.\r\n-     * @param row Row to be flushed\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param insertUpdates Collection of update statements that are executed\r\n-     * after the insert/update operations are flushed \r\n-     */\r\n-    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n-        Collection insertUpdates) throws SQLException {\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-        Column col;\r\n-\r\n-        // copy where conditions into new update that sets the fk\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        if (row.getAction() == Row.ACTION_INSERT) {\r\n-            if (row.getPrimaryKey() == null)\r\n-                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-            update.wherePrimaryKey(row.getPrimaryKey());\r\n-        } else {\r\n-            // Row.ACTION_UPDATE\r\n-            row.copyInto(update, true);\r\n-        }\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                row.getForeignKeySet(fk));\r\n-            row.clearForeignKey(fk);\r\n-        } else {\r\n-            col = (Column) edge.getUserObject();\r\n-            update.setRelationId(col, row.getRelationIdSet(col),\r\n-                row.getRelationIdCallback(col));\r\n-            row.clearRelationId(col);\r\n-        }\r\n-\r\n-        insertUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds a nullable foreign key by walking the dependency cycle. \r\n-     * Circular dependencies can be broken at this point.\r\n-     * @param cycle Cycle in the dependency graph.\r\n-     * @return Edge corresponding to a nullable foreign key.\r\n-     */\r\n-    private Edge findBreakableLink(List cycle) {\r\n-        Edge breakableLink = null;\r\n-        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n-            Edge edge = (Edge) iter.next();\r\n-            Object userObject = edge.getUserObject();\r\n-            if (userObject instanceof ForeignKey) {\r\n-                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n-                     breakableLink = edge;\r\n-                     break;\r\n-                 }\r\n-            } else if (userObject instanceof Column) {\r\n-                if (!((Column) userObject).isNotNull()) {\r\n-                    breakableLink = edge;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        return breakableLink;\r\n-    }\r\n-\r\n-    /**\r\n-     * Re-calculates the DepthFirstSearch analysis of the graph \r\n-     * after some of the edges have been removed. Ensures\r\n-     * that the dependency graph is cycle free.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        DepthFirstAnalysis dfa;\r\n-        // clear previous traversal data\r\n-        graph.clearTraversal();\r\n-        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        // make sure that the graph is non-cyclic now\r\n-        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n-        return dfa;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve circular dependencies by identifying and breaking\r\n-     * a nullable foreign key.\r\n-     * @param graph Dependency graph.\r\n-     * @param edges Collection of edges. Each edge indicates a possible \r\n-     * circular dependency\r\n-     * @param deleteUpdates Collection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed before \r\n-     * the rows in the dependency graph are flushed\r\n-     * @param insertUpdates CCollection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed after \r\n-     * the rows in the dependency graph are flushed\r\n-     * @return Depending on where circular dependencies are broken, the  \r\n-     * topological order of the graph nodes has to be re-calculated.\r\n-     */\r\n-    private boolean resolveCycles(Graph graph, Collection edges,\r\n-        Collection deleteUpdates, Collection insertUpdates)\r\n-        throws SQLException {\r\n-        boolean recalculate = false;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            List cycle = edge.getCycle();\r\n-\r\n-            if (cycle != null) {\r\n-                // find a nullable foreign key\r\n-                Edge breakableLink = findBreakableLink(cycle);\r\n-                if (breakableLink == null) {\r\n-                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n-                }\r\n-\r\n-                // topologic node order must be re-calculated,  if the\r\n-                // breakable link is different from the edge where\r\n-                // the circular dependency was originally detected\r\n-                if (edge != breakableLink) {\r\n-                    recalculate = true;\r\n-                }\r\n-\r\n-                if (!breakableLink.isRemovedFromGraph()) {\r\n-\r\n-                    // use a primary row update to prevent setting pk and fk values\r\n-                    // until after flush, to get latest auto-increment values\r\n-                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n-                    if (row.getAction() == Row.ACTION_DELETE) {\r\n-                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n-                    } else {\r\n-                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n-                    }\r\n-                    graph.removeEdge(breakableLink);\r\n-                }\r\n-            }\r\n-        }\r\n-        return recalculate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n-     * and auto-assign settings.\r\n-     */\r\n-    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        return new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given collection of secondary rows.\r\n-     */\r\n-    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n-        if (rows.size() == 0)\r\n-            return;\r\n-\r\n-        RowImpl row;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n-            row = (RowImpl) itr.next();\r\n-            if (row.isValid() && !row.isDependent())\r\n-                psMgr.flush(row);\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\n+import org.apache.openjpa.lib.graph.Edge;\n+import org.apache.openjpa.lib.graph.Graph;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\n+ *\n+ * @since 1.0.0\n+ */\n+public class ConstraintUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ConstraintUpdateManager.class);\n+\n+    public boolean orderDirty() {\n+        return true;\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(false);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // analyze foreign keys\n+        Collection inserts = rmimpl.getInserts();\n+        Collection updates = rmimpl.getUpdates();\n+        Collection deletes = rmimpl.getDeletes();\n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\n+\n+        // flush insert graph, if any\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\n+        try {\n+            flushGraph(graphs[0], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // flush the rest of the inserts and updates; inserts before updates\n+        // because some update fks might reference pks that have to be inserted\n+        flush(inserts, psMgr);\n+        flush(updates, psMgr);\n+\n+        // flush the delete graph, if any\n+        try {\n+            flushGraph(graphs[1], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // put the remainder of the deletes after updates because some updates\n+        // may be nulling fks to rows that are going to be deleted\n+        flush(deletes, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze foreign key dependencies on the given rows\n+     * and create an insert and a delete graph to execute.  The insert\n+     * graph will be flushed before all other rows, and the delete graph will\n+     * be flushed after them.\n+     */\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\n+        // if there are any deletes, we have to map the insert objects on their\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\n+        Map insertMap = null;\n+        OpenJPAStateManager sm;\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\n+                sm = ((Row) itr.next()).getPrimaryKey();\n+                if (sm != null && sm.getObjectId() != null)\n+                    insertMap.put(sm.getObjectId(), sm);\n+            }\n+        }\n+\n+        // first construct the graph for deletes; this may expand to include\n+        // inserts and updates as well if there are any inserts that rely on\n+        // deletes (delete-then-insert-same-pk cases)\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        OpenJPAStateManager fkVal;\n+        boolean ignoreUpdates = true;\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            row2 = getInsertRow(insertMap, rowMgr, row);\n+            if (row2 != null) {\n+                ignoreUpdates = false;\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\n+            }\n+\n+            // now check this row's fks against other deletes\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                // when deleting ref fks they'll just set a where value, so\n+                // check both for fk updates (relation fks) and wheres (ref fks)\n+                fkVal = row.getForeignKeySet(fks[j]);\n+                if (fkVal == null)\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\n+                if (fkVal == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_DELETE, fkVal, false);\n+                if (row2 != null && row2.isValid() && row2 != row)\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\n+                        fks[j]);\n+            }\n+        }\n+\n+        if (ignoreUpdates)\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\n+        else {\n+            // put inserts *and updates* in the delete graph; they all rely\n+            // on each other\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if there is an insert for for the same table and primary\n+     * key values as the given delete row.\n+     */\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\n+        if (insertMap == null)\n+            return null;\n+\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        if (sm == null)\n+            return null;\n+\n+        // look for a new object whose insert id is the same as this delete one\n+        Object oid = sm.getObjectId();\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\n+        if (nsm == null)\n+            return null;\n+\n+        // found new object; get its row\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\n+        return (row == null || row.isValid()) ? row : null;\n+    }\n+\n+    /**\n+     * Analyze the given rows against the inserts, placing dependencies\n+     * in the given graph.\n+     */\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n+        Graph graph) {\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        Column[] cols;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            // check this row's fks against inserts; a logical fk to an auto-inc\n+            // column is treated just as actual database fk because the result\n+            // is the same: the pk row has to be inserted before the fk row\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                if (row.getForeignKeySet(fks[j]) == null)\n+                    continue;\n+\n+                // see if this row is dependent on another.  if it's only\n+                // depenent on itself, see if the fk is logical or deferred, in\n+                // which case it must be an auto-inc because otherwise we\n+                // wouldn't have recorded it\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\n+                if (row2 != null && row2.isValid() && (row2 != row\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\n+            }\n+\n+            // see if there are any relation id columns dependent on\n+            // auto-inc objects\n+            cols = row.getTable().getRelationIdColumns();\n+            for (int j = 0; j < cols.length; j++) {\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\n+                if (sm == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\n+                    sm, false);\n+                if (row2 != null && row2.isValid())\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\n+            }\n+        }\n+        return graph;\n+    }\n+\n+    /**\n+     * Return the base table for the given instance.\n+     */\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        return cls.getTable();\n+    }\n+\n+    /**\n+     * Add an edge between the given rows in the given foreign key graph.\n+     */\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\n+        Object fk) {\n+        // delay creation of the graph\n+        if (graph == null)\n+            graph = new Graph();\n+\n+        row1.setDependent(true);\n+        row2.setDependent(true);\n+        graph.addNode(row1);\n+        graph.addNode(row2);\n+\n+        // add an edge from row1 to row2, and set the fk causing the\n+        // dependency as the user object so we can retrieve it when resolving\n+        // circular constraints\n+        Edge edge = new Edge(row1, row2, true);\n+        edge.setUserObject(fk);\n+        graph.addEdge(edge);\n+\n+        return graph;\n+    }\n+\n+    /**\n+     * Flush the given graph of rows in the proper order.\n+     * @param graph The graph of statements to be walked\n+     * @param psMgr The prepared statement manager to use to issue the\n+     * statements\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n+        boolean autoAssign)\n+        throws SQLException {\n+        if (graph == null)\n+            return;\n+\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        Collection insertUpdates = new LinkedList();\n+        Collection deleteUpdates = new LinkedList();\n+        boolean recalculate;\n+\n+        // Handle circular constraints:\n+        // - if deleted row A has a ciricular fk to deleted row B, \n+        //   then use an update statement to null A's fk to B before flushing, \n+        //   and then flush\n+        // - if inserted row A has a circular fk to updated/inserted row B,\n+        //   then null the fk in the B row object, then flush,\n+        //   and after flushing, use an update to set the fk back to A\n+        // Depending on where circular dependencies are broken, the  \n+        // topological order of the graph nodes has to be re-calculated.\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\n+                deleteUpdates, insertUpdates);\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\n+                deleteUpdates, insertUpdates);\n+\n+        if (recalculate) {\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\n+        }\n+\n+        // flush delete updates to null fks, then all rows in order, then\n+        // the insert updates to set circular fk values\n+        flush(deleteUpdates, psMgr);\n+        Collection nodes = dfa.getSortedNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            psMgr.flush((RowImpl) itr.next());\n+        flush(insertUpdates, psMgr);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by delete operations.\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \n+     * statement to null A's fk to B before deleting B, then delete A.\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param deleteUpdates Collection of update statements that are executed\n+     * before the delete operations are flushed \n+     */\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\n+        throws SQLException {\n+        PrimaryRow row;\n+        RowImpl update;\n+        ForeignKey fk;\n+\n+        // copy where conditions into new update that nulls the fk\n+        row = (PrimaryRow) edge.getTo();\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        row.copyInto(update, true);\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\n+        } else\n+            update.setNull((Column) edge.getUserObject());\n+\n+        deleteUpdates.add(update);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by insert operations.\n+     * If inserted row A has a circular fk to updated/inserted row B,\n+     * then null the fk in the B row object, then flush,\n+     * and after flushing, use an update to set the fk back to A.\n+     * @param row Row to be flushed\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param insertUpdates Collection of update statements that are executed\n+     * after the insert/update operations are flushed \n+     */\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\n+        Collection insertUpdates) throws SQLException {\n+        RowImpl update;\n+        ForeignKey fk;\n+        Column col;\n+\n+        // copy where conditions into new update that sets the fk\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            if (row.getPrimaryKey() == null)\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\n+            update.wherePrimaryKey(row.getPrimaryKey());\n+        } else {\n+            // Row.ACTION_UPDATE\n+            row.copyInto(update, true);\n+        }\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\n+                row.getForeignKeySet(fk));\n+            row.clearForeignKey(fk);\n+        } else {\n+            col = (Column) edge.getUserObject();\n+            update.setRelationId(col, row.getRelationIdSet(col),\n+                row.getRelationIdCallback(col));\n+            row.clearRelationId(col);\n+        }\n+\n+        insertUpdates.add(update);\n+    }\n+\n+    /**\n+     * Finds a nullable foreign key by walking the dependency cycle. \n+     * Circular dependencies can be broken at this point.\n+     * @param cycle Cycle in the dependency graph.\n+     * @return Edge corresponding to a nullable foreign key.\n+     */\n+    private Edge findBreakableLink(List cycle) {\n+        Edge breakableLink = null;\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\n+            Edge edge = (Edge) iter.next();\n+            Object userObject = edge.getUserObject();\n+            if (userObject instanceof ForeignKey) {\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\n+                     breakableLink = edge;\n+                     break;\n+                 }\n+            } else if (userObject instanceof Column) {\n+                if (!((Column) userObject).isNotNull()) {\n+                    breakableLink = edge;\n+                    break;\n+                }\n+            }\n+        }\n+        return breakableLink;\n+    }\n+\n+    /**\n+     * Re-calculates the DepthFirstSearch analysis of the graph \n+     * after some of the edges have been removed. Ensures\n+     * that the dependency graph is cycle free.\n+     * @param graph The graph of statements to be walked\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        DepthFirstAnalysis dfa;\n+        // clear previous traversal data\n+        graph.clearTraversal();\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        // make sure that the graph is non-cyclic now\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\n+        return dfa;\n+    }\n+\n+    /**\n+     * Resolve circular dependencies by identifying and breaking\n+     * a nullable foreign key.\n+     * @param graph Dependency graph.\n+     * @param edges Collection of edges. Each edge indicates a possible \n+     * circular dependency\n+     * @param deleteUpdates Collection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed before \n+     * the rows in the dependency graph are flushed\n+     * @param insertUpdates CCollection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed after \n+     * the rows in the dependency graph are flushed\n+     * @return Depending on where circular dependencies are broken, the  \n+     * topological order of the graph nodes has to be re-calculated.\n+     */\n+    private boolean resolveCycles(Graph graph, Collection edges,\n+        Collection deleteUpdates, Collection insertUpdates)\n+        throws SQLException {\n+        boolean recalculate = false;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            List cycle = edge.getCycle();\n+\n+            if (cycle != null) {\n+                // find a nullable foreign key\n+                Edge breakableLink = findBreakableLink(cycle);\n+                if (breakableLink == null) {\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\n+                }\n+\n+                // topologic node order must be re-calculated,  if the\n+                // breakable link is different from the edge where\n+                // the circular dependency was originally detected\n+                if (edge != breakableLink) {\n+                    recalculate = true;\n+                }\n+\n+                if (!breakableLink.isRemovedFromGraph()) {\n+\n+                    // use a primary row update to prevent setting pk and fk values\n+                    // until after flush, to get latest auto-increment values\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\n+                    if (row.getAction() == Row.ACTION_DELETE) {\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\n+                    } else {\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\n+                    }\n+                    graph.removeEdge(breakableLink);\n+                }\n+            }\n+        }\n+        return recalculate;\n+    }\n+\n+    /**\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\n+     * and auto-assign settings.\n+     */\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        return new DepthFirstAnalysis(graph);\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.size() == 0)\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\n+            row = (RowImpl) itr.next();\n+            if (row.isValid() && !row.isDependent())\n+                psMgr.flush(row);\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"0559d61e68a53bf8b9035b949ec244ae7d28c8ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","status":"modified","additions":183,"deletions":183,"changes":366,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,183 +1,183 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-\r\n-/**\r\n- * <p>Handler for embedded objects as elements of a collection or map.  For\r\n- * embedded objects as fields, use the more powerful\r\n- * {@link EmbedFieldStrategy}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- * @nojavadoc\r\n- */\r\n-public class ElementEmbedValueHandler\r\n-    extends EmbedValueHandler\r\n-    implements RelationId {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ElementEmbedValueHandler.class);\r\n-\r\n-    private ValueMapping _vm = null;\r\n-    private Column[] _cols = null;\r\n-    private Object[] _args = null;\r\n-    private int _nullIdx = -1;\r\n-    private boolean _synthetic = false;\r\n-\r\n-    public Column[] map(ValueMapping vm, String name, ColumnIO io,\r\n-        boolean adapt) {\r\n-        LinkedList cols = new LinkedList();\r\n-        LinkedList args = new LinkedList();\r\n-        super.map(vm, name, io, adapt, cols, args);\r\n-\r\n-        ValueMappingInfo vinfo = vm.getValueInfo();\r\n-        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\r\n-            vm.getFieldMapping().getTable(), adapt);\r\n-        if (nullInd != null)\r\n-            vm.setColumns(new Column[]{ nullInd });\r\n-\r\n-        // record index of null indicator column and whether it is synthetic\r\n-        if (nullInd != null) {\r\n-            _nullIdx = cols.indexOf(nullInd);\r\n-            if (_nullIdx == -1) {\r\n-                cols.addFirst(nullInd);\r\n-                args.addFirst(null);\r\n-                _nullIdx = 0;\r\n-                _synthetic = true;\r\n-            }\r\n-        }\r\n-\r\n-        _vm = vm;\r\n-        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\r\n-        _args = args.toArray();\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public boolean objectValueRequiresLoad(ValueMapping vm) {\r\n-        return true;\r\n-    }\r\n-\r\n-    public Object getResultArgument(ValueMapping vm) {\r\n-        return _args;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(ValueMapping vm, Object val,\r\n-        JDBCStore store) {\r\n-        OpenJPAStateManager em = store.getContext().getStateManager(val);\r\n-        Object rval = null;\r\n-        if (_cols.length > 1)\r\n-            rval = new Object[_cols.length];\r\n-\r\n-        // set null indicator column\r\n-        int idx = 0;\r\n-        if (_synthetic) {\r\n-            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).getNullIndicatorValue(em);\r\n-            if (_cols.length == 1)\r\n-                return cval;\r\n-            ((Object[]) rval)[idx++] = cval;\r\n-        }\r\n-\r\n-        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\r\n-    }\r\n-\r\n-    public Object toObjectValue(ValueMapping vm, Object val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\r\n-        throws SQLException {\r\n-        if (sm == null)\r\n-            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\r\n-                vm));\r\n-\r\n-        // check null indicator first\r\n-        if (_nullIdx != -1) {\r\n-            Object nval;\r\n-            if (_cols.length == 1)\r\n-                nval = val;\r\n-            else\r\n-                nval = ((Object[]) val)[_nullIdx];\r\n-            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).indicatesNull(nval))\r\n-                return null;\r\n-        }\r\n-\r\n-        // create embedded instance\r\n-        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\r\n-        int idx = (_synthetic) ? 1 : 0;\r\n-        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\r\n-\r\n-        // after loading everything from result, load the rest of the\r\n-        // configured fields\r\n-        em.load(fetch);\r\n-        return em.getManagedInstance();\r\n-    }\r\n-\r\n-    /////////////////////////////\r\n-    // RelationId implementation\r\n-    /////////////////////////////\r\n-\r\n-    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\r\n-        return toRelationDataStoreValue(sm, col, 0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursive helper.\r\n-     */\r\n-    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\r\n-        int idx) {\r\n-        FieldMapping field = findField(col, idx);\r\n-        if (field == null)\r\n-            throw new InternalException();\r\n-\r\n-        if (field.getHandler() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        if (field.getStrategy() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\r\n-    }\r\n-\r\n-    /**\r\n-     * Find the first field mapping that uses the given column starting with\r\n-     * the given field index.\r\n-     */\r\n-    private FieldMapping findField(Column col, int idx) {\r\n-        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\r\n-        Column[] cols;\r\n-        for (int i = idx; i < fms.length; i++) {\r\n-            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\r\n-                continue;\r\n-            cols = ((Embeddable) fms[i]).getColumns();\r\n-            for (int j = 0; j < cols.length; j++)\r\n-                if (cols[j] == col)\r\n-                    return fms[i];\r\n-        }\r\n-        return null;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+\n+/**\n+ * <p>Handler for embedded objects as elements of a collection or map.  For\n+ * embedded objects as fields, use the more powerful\n+ * {@link EmbedFieldStrategy}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ * @nojavadoc\n+ */\n+public class ElementEmbedValueHandler\n+    extends EmbedValueHandler\n+    implements RelationId {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ElementEmbedValueHandler.class);\n+\n+    private ValueMapping _vm = null;\n+    private Column[] _cols = null;\n+    private Object[] _args = null;\n+    private int _nullIdx = -1;\n+    private boolean _synthetic = false;\n+\n+    public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        LinkedList cols = new LinkedList();\n+        LinkedList args = new LinkedList();\n+        super.map(vm, name, io, adapt, cols, args);\n+\n+        ValueMappingInfo vinfo = vm.getValueInfo();\n+        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\n+            vm.getFieldMapping().getTable(), adapt);\n+        if (nullInd != null)\n+            vm.setColumns(new Column[]{ nullInd });\n+\n+        // record index of null indicator column and whether it is synthetic\n+        if (nullInd != null) {\n+            _nullIdx = cols.indexOf(nullInd);\n+            if (_nullIdx == -1) {\n+                cols.addFirst(nullInd);\n+                args.addFirst(null);\n+                _nullIdx = 0;\n+                _synthetic = true;\n+            }\n+        }\n+\n+        _vm = vm;\n+        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\n+        _args = args.toArray();\n+        return _cols;\n+    }\n+\n+    public boolean objectValueRequiresLoad(ValueMapping vm) {\n+        return true;\n+    }\n+\n+    public Object getResultArgument(ValueMapping vm) {\n+        return _args;\n+    }\n+\n+    public Object toDataStoreValue(ValueMapping vm, Object val,\n+        JDBCStore store) {\n+        OpenJPAStateManager em = store.getContext().getStateManager(val);\n+        Object rval = null;\n+        if (_cols.length > 1)\n+            rval = new Object[_cols.length];\n+\n+        // set null indicator column\n+        int idx = 0;\n+        if (_synthetic) {\n+            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).getNullIndicatorValue(em);\n+            if (_cols.length == 1)\n+                return cval;\n+            ((Object[]) rval)[idx++] = cval;\n+        }\n+\n+        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\n+    }\n+\n+    public Object toObjectValue(ValueMapping vm, Object val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        if (sm == null)\n+            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\n+                vm));\n+\n+        // check null indicator first\n+        if (_nullIdx != -1) {\n+            Object nval;\n+            if (_cols.length == 1)\n+                nval = val;\n+            else\n+                nval = ((Object[]) val)[_nullIdx];\n+            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).indicatesNull(nval))\n+                return null;\n+        }\n+\n+        // create embedded instance\n+        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\n+        int idx = (_synthetic) ? 1 : 0;\n+        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\n+\n+        // after loading everything from result, load the rest of the\n+        // configured fields\n+        em.load(fetch);\n+        return em.getManagedInstance();\n+    }\n+\n+    /////////////////////////////\n+    // RelationId implementation\n+    /////////////////////////////\n+\n+    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\n+        return toRelationDataStoreValue(sm, col, 0);\n+    }\n+\n+    /**\n+     * Recursive helper.\n+     */\n+    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\n+        int idx) {\n+        FieldMapping field = findField(col, idx);\n+        if (field == null)\n+            throw new InternalException();\n+\n+        if (field.getHandler() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        if (field.getStrategy() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\n+    }\n+\n+    /**\n+     * Find the first field mapping that uses the given column starting with\n+     * the given field index.\n+     */\n+    private FieldMapping findField(Column col, int idx) {\n+        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\n+        Column[] cols;\n+        for (int i = idx; i < fms.length; i++) {\n+            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\n+                continue;\n+            cols = ((Embeddable) fms[i]).getColumns();\n+            for (int j = 0; j < cols.length; j++)\n+                if (cols[j] == col)\n+                    return fms[i];\n+        }\n+        return null;\n+\t}\n+}"},{"sha":"dd15e30c548420973c17eae46d888e15c4873b8c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","status":"modified","additions":250,"deletions":250,"changes":500,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,250 +1,250 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a collection of values in a separate table controlled by a\r\n- * {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerCollectionTableFieldStrategy\r\n-    extends StoreCollectionFieldStrategy\r\n-    implements LRSCollectionFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerCollectionTableFieldStrategy.class);\r\n-\r\n-    private Column[] _cols = null;\r\n-    private ColumnIO _io = null;\r\n-    private boolean _load = false;\r\n-    private boolean _lob = false;\r\n-    private boolean _embed = false;\r\n-\r\n-    public FieldMapping getFieldMapping() {\r\n-        return field;\r\n-    }\r\n-\r\n-    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\r\n-        return ClassMapping.EMPTY_MAPPINGS;\r\n-    }\r\n-\r\n-    public Column[] getElementColumns(ClassMapping elem) {\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public ForeignKey getJoinForeignKey(ClassMapping elem) {\r\n-        return field.getJoinForeignKey();\r\n-    }\r\n-\r\n-    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\r\n-        sel.select(_cols, joins);\r\n-    }\r\n-\r\n-    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _cols, _load);\r\n-    }\r\n-\r\n-    protected Joins join(Joins joins, ClassMapping elem) {\r\n-        return join(joins, false);\r\n-    }\r\n-\r\n-    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\r\n-        return joinRelation(joins, false, false);\r\n-    }\r\n-\r\n-    protected Proxy newLRSProxy() {\r\n-        return new LRSProxyCollection(this);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        if (field.getTypeCode() != JavaTypes.COLLECTION\r\n-            && field.getTypeCode() != JavaTypes.ARRAY)\r\n-            throw new MetaDataException(_loc.get(\"not-coll\", field));\r\n-\r\n-        assertNotMappedBy();\r\n-        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        if (elem.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", elem));\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _io = new ColumnIO();\r\n-        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\r\n-\r\n-        FieldMappingInfo finfo = field.getMappingInfo();\r\n-        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\r\n-        field.setOrderColumn(orderCol);\r\n-        field.setOrderColumnIO(finfo.getColumnIO());\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        for (int i = 0; !_lob && i < _cols.length; i++)\r\n-            _lob = _cols[i].isLob();\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        _embed = elem.getEmbeddedMetaData() != null;\r\n-        _load = elem.getHandler().objectValueRequiresLoad(elem);\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Object vals)\r\n-        throws SQLException {\r\n-        Collection coll;\r\n-        if (field.getTypeCode() == JavaTypes.ARRAY)\r\n-            coll = JavaTypes.toList(vals, field.getElement().getType(),\r\n-                false);\r\n-        else\r\n-            coll = (Collection) vals;\r\n-        if (coll == null || coll.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Column order = field.getOrderColumn();\r\n-        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);\r\n-        int idx = 0;\r\n-        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\r\n-            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\r\n-                _io, true);\r\n-            if (setOrder)\r\n-                row.setInt(order, idx);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object obj = sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (obj instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) obj;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, obj);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(elem, itr.next(), store, delRow,\r\n-                    _cols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            int seq = ct.getNextSequence();\r\n-            Column order = field.getOrderColumn();\r\n-            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\r\n-                false);\r\n-            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\r\n-                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\r\n-                    _io, true);\r\n-                if (setOrder)\r\n-                    addRow.setInt(order, seq);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (order != null)\r\n-                ct.setNextSequence(seq);\r\n-        }\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\r\n-        row.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-        rm.flushAllRows(row);\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        // can't do any combined select with lobs, since they don't allow\r\n-        // select distinct.  cant select eager parallel on embedded, because\r\n-        // during parallel result processing the owning sm won't be available\r\n-        // for each elem\r\n-        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\r\n-            return 0;\r\n-        return super.supportsSelect(sel, type, sm, store, fetch);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _cols, store);\r\n-    }\r\n-\r\n-    public Joins join(Joins joins, boolean forceOuter) {\r\n-        return field.join(joins, forceOuter, true);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a collection of values in a separate table controlled by a\n+ * {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerCollectionTableFieldStrategy\n+    extends StoreCollectionFieldStrategy\n+    implements LRSCollectionFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerCollectionTableFieldStrategy.class);\n+\n+    private Column[] _cols = null;\n+    private ColumnIO _io = null;\n+    private boolean _load = false;\n+    private boolean _lob = false;\n+    private boolean _embed = false;\n+\n+    public FieldMapping getFieldMapping() {\n+        return field;\n+    }\n+\n+    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\n+        return ClassMapping.EMPTY_MAPPINGS;\n+    }\n+\n+    public Column[] getElementColumns(ClassMapping elem) {\n+        return _cols;\n+    }\n+\n+    public ForeignKey getJoinForeignKey(ClassMapping elem) {\n+        return field.getJoinForeignKey();\n+    }\n+\n+    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\n+        sel.select(_cols, joins);\n+    }\n+\n+    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _cols, _load);\n+    }\n+\n+    protected Joins join(Joins joins, ClassMapping elem) {\n+        return join(joins, false);\n+    }\n+\n+    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\n+        return joinRelation(joins, false, false);\n+    }\n+\n+    protected Proxy newLRSProxy() {\n+        return new LRSProxyCollection(this);\n+    }\n+\n+    public void map(boolean adapt) {\n+        if (field.getTypeCode() != JavaTypes.COLLECTION\n+            && field.getTypeCode() != JavaTypes.ARRAY)\n+            throw new MetaDataException(_loc.get(\"not-coll\", field));\n+\n+        assertNotMappedBy();\n+        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        if (elem.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", elem));\n+\n+        field.mapJoin(adapt, true);\n+        _io = new ColumnIO();\n+        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\n+\n+        FieldMappingInfo finfo = field.getMappingInfo();\n+        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\n+        field.setOrderColumn(orderCol);\n+        field.setOrderColumnIO(finfo.getColumnIO());\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        for (int i = 0; !_lob && i < _cols.length; i++)\n+            _lob = _cols[i].isLob();\n+\n+        ValueMapping elem = field.getElementMapping();\n+        _embed = elem.getEmbeddedMetaData() != null;\n+        _load = elem.getHandler().objectValueRequiresLoad(elem);\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Object vals)\n+        throws SQLException {\n+        Collection coll;\n+        if (field.getTypeCode() == JavaTypes.ARRAY)\n+            coll = JavaTypes.toList(vals, field.getElement().getType(),\n+                false);\n+        else\n+            coll = (Collection) vals;\n+        if (coll == null || coll.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        Column order = field.getOrderColumn();\n+        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);\n+        int idx = 0;\n+        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\n+            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\n+                _io, true);\n+            if (setOrder)\n+                row.setInt(order, idx);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object obj = sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (obj instanceof Proxy) {\n+            Proxy proxy = (Proxy) obj;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, obj);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping elem = field.getElementMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(elem, itr.next(), store, delRow,\n+                    _cols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            int seq = ct.getNextSequence();\n+            Column order = field.getOrderColumn();\n+            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\n+                false);\n+            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\n+                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\n+                    _io, true);\n+                if (setOrder)\n+                    addRow.setInt(order, seq);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (order != null)\n+                ct.setNextSequence(seq);\n+        }\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\n+        row.whereForeignKey(field.getJoinForeignKey(), sm);\n+        rm.flushAllRows(row);\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        // can't do any combined select with lobs, since they don't allow\n+        // select distinct.  cant select eager parallel on embedded, because\n+        // during parallel result processing the owning sm won't be available\n+        // for each elem\n+        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\n+            return 0;\n+        return super.supportsSelect(sel, type, sm, store, fetch);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _cols, store);\n+    }\n+\n+    public Joins join(Joins joins, boolean forceOuter) {\n+        return field.join(joins, forceOuter, true);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+}"},{"sha":"0fed898fe8195931a9d1971a2d953046b9f7cb1a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"modified","additions":246,"deletions":246,"changes":492,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,246 +1,246 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.util.*;\r\n-\r\n-/**\r\n- * Mapping for a map of keys and values both controlled by\r\n- * {@link ValueHandler}s.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping cls,\r\n-        OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\r\n-        throws SQLException {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.setLRS(lrs);\r\n-        sel.select(_kcols);\r\n-        sel.select(_vcols);\r\n-        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\r\n-            field.getDefiningMapping(), store);\r\n-        Result res = sel.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _kio = new ColumnIO();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        _kcols = HandlerStrategies.map(key, \r\n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.util.*;\n+\n+/**\n+ * Mapping for a map of keys and values both controlled by\n+ * {@link ValueHandler}s.\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping cls,\n+        OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\n+        throws SQLException {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.setLRS(lrs);\n+        sel.select(_kcols);\n+        sel.select(_vcols);\n+        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\n+            field.getDefiningMapping(), store);\n+        Result res = sel.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _kio = new ColumnIO();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        _kcols = HandlerStrategies.map(key, \n+            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+}"},{"sha":"3731c0620982c87c17cdbdcae618c174cdbf2ace","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":315,"deletions":315,"changes":630,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,315 +1,315 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\r\n- * and whose values are relations to other persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerRelationMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        final ClassMapping[] vals = elem.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_kcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _kio = new ColumnIO();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        _kcols = HandlerStrategies.map(key, \r\n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-\r\n-        if (val.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = val.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\r\n-            val.setForeignKey(fk);\r\n-            val.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\r\n-\r\n-        val.mapConstraints(\"value\", adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(),\r\n-                ctx);\r\n-            val.setForeignKey(row, valsm);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                        _kcols);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                        _kio, true);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\n+ * and whose values are relations to other persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerRelationMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping elem = field.getElementMapping();\n+        final ClassMapping[] vals = elem.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_kcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _kio = new ColumnIO();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        _kcols = HandlerStrategies.map(key, \n+            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+\n+        if (val.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = val.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\n+            val.setForeignKey(fk);\n+            val.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\n+\n+        val.mapConstraints(\"value\", adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(),\n+                ctx);\n+            val.setForeignKey(row, valsm);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    HandlerStrategies.where(key, itr.next(), store, delRow,\n+                        _kcols);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                        _kio, true);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+}"},{"sha":"5af8420cd27e5f3602782dd8db5b02413212406e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","status":"modified","additions":219,"deletions":219,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,219 +1,219 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\r\n-import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.sql.PostgresDictionary;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-\r\n-/**\r\n- * Direct mapping from a stream value to a column.\r\n- *\r\n- * @author Ignacio Andreu\r\n- * @since 1.1.0\r\n- */\r\n-public class LobFieldStrategy extends AbstractFieldStrategy {\r\n-\r\n-    private int fieldType;\r\n-    private boolean isBlob;\r\n-\r\n-    public void map(boolean adapt) {\r\n-        assertNotMappedBy();\r\n-        field.mapJoin(adapt, false);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-        field.getElementMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getElement(), !adapt);\r\n-        field.setStream(true);\r\n-        ValueMappingInfo vinfo = field.getValueInfo();\r\n-        vinfo.assertNoJoin(field, true);\r\n-        vinfo.assertNoForeignKey(field, !adapt);\r\n-        Column tmpCol = new Column();\r\n-        tmpCol.setName(field.getName());\r\n-        tmpCol.setType(fieldType);\r\n-        tmpCol.setJavaType(field.getTypeCode());\r\n-        \r\n-        tmpCol.setSize(-1);\r\n-\r\n-        Column[] cols = vinfo.getColumns(field, field.getName(),\r\n-            new Column[]{ tmpCol }, field.getTable(), adapt);\r\n-\r\n-        field.setColumns(cols);\r\n-        field.setColumnIO(vinfo.getColumnIO());\r\n-        field.mapConstraints(field.getName(), adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Select sel = createSelect(sm, store);\r\n-        store.getDBDictionary().deleteStream(store, sel);\r\n-    }\r\n-    \r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], ob);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], sel);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-                (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\r\n-            return 1;\r\n-        return 0;\r\n-    }\r\n-\r\n-    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode) {\r\n-        sel.select(field.getColumns()[0], field.join(sel));\r\n-        return 1;\r\n-    }\r\n-\r\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res) throws SQLException {\r\n-        Column col = field.getColumns()[0];\r\n-        if (res.contains(col)) {\r\n-            if (isBlob) {\r\n-                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\r\n-            } else {\r\n-                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void assertNotMappedBy() {\r\n-        if (field != null && field.getMappedBy() != null)\r\n-            throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public void setFieldMapping(FieldMapping owner) {\r\n-        field = owner;\r\n-        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\r\n-            instanceof PostgresDictionary) {\r\n-            fieldType = Types.INTEGER;\r\n-            isBlob = true;\r\n-            field.setTypeCode(JavaTypes.INT);\r\n-        } else {\r\n-            if (owner.getType().isAssignableFrom(InputStream.class)) {\r\n-                isBlob = true;\r\n-                fieldType = Types.BLOB;\r\n-            } else if (owner.getType().isAssignableFrom(Reader.class)) {\r\n-                isBlob = false;\r\n-                fieldType = Types.CLOB;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.select(field.getColumns()[0]);\r\n-        sel.selectPrimaryKey(field.getDefiningMapping());\r\n-        sel.wherePrimaryKey\r\n-            (sm.getObjectId(), field.getDefiningMapping(), store);\r\n-        sel.setLob(true);\r\n-        return sel;\r\n-    }\r\n-    \r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.PostgresDictionary;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Direct mapping from a stream value to a column.\n+ *\n+ * @author Ignacio Andreu\n+ * @since 1.1.0\n+ */\n+public class LobFieldStrategy extends AbstractFieldStrategy {\n+\n+    private int fieldType;\n+    private boolean isBlob;\n+\n+    public void map(boolean adapt) {\n+        assertNotMappedBy();\n+        field.mapJoin(adapt, false);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+        field.getElementMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getElement(), !adapt);\n+        field.setStream(true);\n+        ValueMappingInfo vinfo = field.getValueInfo();\n+        vinfo.assertNoJoin(field, true);\n+        vinfo.assertNoForeignKey(field, !adapt);\n+        Column tmpCol = new Column();\n+        tmpCol.setName(field.getName());\n+        tmpCol.setType(fieldType);\n+        tmpCol.setJavaType(field.getTypeCode());\n+        \n+        tmpCol.setSize(-1);\n+\n+        Column[] cols = vinfo.getColumns(field, field.getName(),\n+            new Column[]{ tmpCol }, field.getTable(), adapt);\n+\n+        field.setColumns(cols);\n+        field.setColumnIO(vinfo.getColumnIO());\n+        field.mapConstraints(field.getName(), adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Select sel = createSelect(sm, store);\n+        store.getDBDictionary().deleteStream(store, sel);\n+    }\n+    \n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], ob);\n+            }\n+        }\n+    }\n+\n+    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+    \n+    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], sel);\n+            }\n+        }\n+    }\n+\n+    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+                (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\n+            return 1;\n+        return 0;\n+    }\n+\n+    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode) {\n+        sel.select(field.getColumns()[0], field.join(sel));\n+        return 1;\n+    }\n+\n+    public void load(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res) throws SQLException {\n+        Column col = field.getColumns()[0];\n+        if (res.contains(col)) {\n+            if (isBlob) {\n+                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\n+            } else {\n+                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\n+            }\n+        }\n+    }\n+\n+    protected void assertNotMappedBy() {\n+        if (field != null && field.getMappedBy() != null)\n+            throw new UnsupportedOperationException();\n+    }\n+\n+    public void setFieldMapping(FieldMapping owner) {\n+        field = owner;\n+        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\n+            instanceof PostgresDictionary) {\n+            fieldType = Types.INTEGER;\n+            isBlob = true;\n+            field.setTypeCode(JavaTypes.INT);\n+        } else {\n+            if (owner.getType().isAssignableFrom(InputStream.class)) {\n+                isBlob = true;\n+                fieldType = Types.BLOB;\n+            } else if (owner.getType().isAssignableFrom(Reader.class)) {\n+                isBlob = false;\n+                fieldType = Types.CLOB;\n+            }\n+        }\n+    }\n+\n+    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.select(field.getColumns()[0]);\n+        sel.selectPrimaryKey(field.getDefiningMapping());\n+        sel.wherePrimaryKey\n+            (sm.getObjectId(), field.getDefiningMapping(), store);\n+        sel.setLob(true);\n+        return sel;\n+    }\n+    \n+}"},{"sha":"de51ad531fc306460de12f7a8f3d0513fb4aea57","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import org.apache.openjpa.lib.util.TimestampHelper;\r\n-\r\n-/**\r\n- * Uses a timestamp for optimistic versioning with nanosecond\r\n- * precision.\r\n- *\r\n- * @author Albert Lee\r\n- */\r\n-public class NanoPrecisionTimestampVersionStrategy\r\n-    extends TimestampVersionStrategy {\r\n-\r\n-    public static final String ALIAS = \"nano-timestamp\";\r\n-\r\n-    public String getAlias() {\r\n-        return ALIAS;\r\n-    }\r\n-\r\n-    protected Object nextVersion(Object version) {\r\n-        return TimestampHelper.getNanoPrecisionTimestamp();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import org.apache.openjpa.lib.util.TimestampHelper;\n+\n+/**\n+ * Uses a timestamp for optimistic versioning with nanosecond\n+ * precision.\n+ *\n+ * @author Albert Lee\n+ */\n+public class NanoPrecisionTimestampVersionStrategy\n+    extends TimestampVersionStrategy {\n+\n+    public static final String ALIAS = \"nano-timestamp\";\n+\n+    public String getAlias() {\n+        return ALIAS;\n+    }\n+\n+    protected Object nextVersion(Object version) {\n+        return TimestampHelper.getNanoPrecisionTimestamp();\n+    }\n+}"},{"sha":"35a3a1c619765a5acee6dd0a3de6f37190526a75","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","status":"modified","additions":290,"deletions":290,"changes":580,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,290 +1,290 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are relations to other persistent objects\r\n- * and whose values are controlled by a {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_vcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-\r\n-        if (key.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = key.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\r\n-            key.setForeignKey(fk);\r\n-            key.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\r\n-\r\n-        key.mapConstraints(\"key\", adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        Collection rem = ct.getRemoved();\r\n-        OpenJPAStateManager keysm;\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(field.getKeyMapping());\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are relations to other persistent objects\n+ * and whose values are controlled by a {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_vcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+\n+        if (key.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = key.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\n+            key.setForeignKey(fk);\n+            key.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\n+\n+        key.mapConstraints(\"key\", adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping val = field.getElementMapping();\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            key.setForeignKey(row, keysm);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        Collection rem = ct.getRemoved();\n+        OpenJPAStateManager keysm;\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.setForeignKey(addRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(field.getKeyMapping());\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            store);\n+    }\n+}"},{"sha":"14a15da3e8e378216122c8979dc92e4d1800e29a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":375,"deletions":375,"changes":750,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,375 +1,375 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys and values are both relations to other\r\n- * persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationRelationMapTableFieldStrategy.class);\r\n-\r\n-    private String _keyRelationName = null;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union kunion = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            kunion.abortUnion();\r\n-        kunion.setLRS(lrs);\r\n-        kunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        final ClassMapping[] vals = val.getIndependentTypeMappings();\r\n-        Union vunion = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(val.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            vunion.abortUnion();\r\n-        vunion.setLRS(lrs);\r\n-        vunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        Result kres = null;\r\n-        Result vres = null;\r\n-        try {\r\n-            kres = kunion.execute(store, fetch);\r\n-            vres = vunion.execute(store, fetch);\r\n-            return new Result[]{ kres, vres };\r\n-        } catch (SQLException se) {\r\n-            if (kres != null)\r\n-                kres.close();\r\n-            if (vres != null)\r\n-                vres.close();\r\n-            throw se;\r\n-        }\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        mapTypeJoin(key, \"key\", adapt);\r\n-        mapTypeJoin(val, \"value\", adapt);\r\n-\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    /**\r\n-     * Map the given value's join to its persistent type.\r\n-     */\r\n-    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\r\n-        if (vm.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = vm.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\r\n-            vm.setForeignKey(fk);\r\n-            vm.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\r\n-        vm.mapConstraints(name, adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _keyRelationName = field.getName() + \":key\";\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, RowManager rm, Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = sm.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            val.setForeignKey(row, valsm);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    keysm = RelationStrategies.getStateManager(itr.next(),\r\n-                        ctx);\r\n-                    key.whereForeignKey(delRow, keysm);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    key.setForeignKey(addRow, keysm);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(key);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(_keyRelationName,\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\r\n-            val, store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys and values are both relations to other\n+ * persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationRelationMapTableFieldStrategy.class);\n+\n+    private String _keyRelationName = null;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union kunion = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            kunion.abortUnion();\n+        kunion.setLRS(lrs);\n+        kunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+\n+        ValueMapping val = field.getElementMapping();\n+        final ClassMapping[] vals = val.getIndependentTypeMappings();\n+        Union vunion = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(val.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            vunion.abortUnion();\n+        vunion.setLRS(lrs);\n+        vunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+\n+        Result kres = null;\n+        Result vres = null;\n+        try {\n+            kres = kunion.execute(store, fetch);\n+            vres = vunion.execute(store, fetch);\n+            return new Result[]{ kres, vres };\n+        } catch (SQLException se) {\n+            if (kres != null)\n+                kres.close();\n+            if (vres != null)\n+                vres.close();\n+            throw se;\n+        }\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        mapTypeJoin(key, \"key\", adapt);\n+        mapTypeJoin(val, \"value\", adapt);\n+\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    /**\n+     * Map the given value's join to its persistent type.\n+     */\n+    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\n+        if (vm.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = vm.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\n+            vm.setForeignKey(fk);\n+            vm.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\n+        vm.mapConstraints(name, adapt);\n+    }\n+\n+    public void initialize() {\n+        _keyRelationName = field.getName() + \":key\";\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, RowManager rm, Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = sm.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\n+            key.setForeignKey(row, keysm);\n+            val.setForeignKey(row, valsm);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, rm, map);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    keysm = RelationStrategies.getStateManager(itr.next(),\n+                        ctx);\n+                    key.whereForeignKey(delRow, keysm);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.setForeignKey(addRow, keysm);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    key.setForeignKey(addRow, keysm);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(key);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(_keyRelationName,\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\n+            val, store);\n+    }\n+}"},{"sha":"6da1fbe7d55d491ef51e0956a88dfe694bc1dbda","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":831,"deletions":831,"changes":1662,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,831 +1,831 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-import java.util.Arrays;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Index;\r\n-import org.apache.openjpa.jdbc.schema.Schema;\r\n-import org.apache.openjpa.jdbc.schema.Sequence;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UnsupportedException;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Dictionary for IBM DB2 database.\r\n- */\r\n-public class DB2Dictionary\r\n-    extends AbstractDB2Dictionary {\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DB2Dictionary.class);\r\n-\r\n-    public String optimizeClause = \"optimize for\";\r\n-    public String rowClause = \"row\";\r\n-    protected int db2ServerType = 0;\r\n-    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n-    public static final int db2UDBV81OrEarlier = 2;\r\n-    public static final int db2ZOSV8xOrLater = 3;\r\n-    public static final int db2UDBV82OrLater = 4;\r\n-    public static final int db2ISeriesV5R4OrLater = 5;\r\n-\tprotected static final String forUpdate = \"FOR UPDATE\";\r\n-    protected static final String withURClause = \"WITH UR\";\r\n-    protected static final String withCSClause = \"WITH CS\";\r\n-    protected static final String withRSClause = \"WITH RS\";\r\n-    protected static final String withRRClause = \"WITH RR\";\r\n-    protected static final String useKeepShareLockClause\r\n-        = \"USE AND KEEP SHARE LOCKS\";\r\n-    protected static final String useKeepUpdateLockClause\r\n-        = \"USE AND KEEP UPDATE LOCKS\";\r\n-    protected static final String useKeepExclusiveLockClause\r\n-        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n-    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n-    protected String databaseProductName = \"\";\r\n-    protected String databaseProductVersion = \"\";\r\n-    protected int maj = 0;\r\n-    protected int min = 0;\r\n-    \r\n-    private int defaultBatchLimit = 100;\r\n-\r\n-    public DB2Dictionary() {\r\n-        platform = \"DB2\";\r\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-            + \"SYSIBM.SYSTABLES\";\r\n-        supportsSelectEndIndex = true;\r\n-\r\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n-\r\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n-        sequenceNameSQL = \"SEQNAME = ?\";\r\n-        characterColumnSize = 254;\r\n-\r\n-        binaryTypeName = \"BLOB(1M)\";\r\n-        longVarbinaryTypeName = \"BLOB(1M)\";\r\n-        varbinaryTypeName = \"BLOB(1M)\";\r\n-        clobTypeName = \"CLOB(1M)\";\r\n-        longVarcharTypeName = \"LONG VARCHAR\";\r\n-        datePrecision = MICRO;\r\n-        storeCharsAsNumbers = false;\r\n-\r\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n-        }));\r\n-        systemSchemas = new String(\r\n-                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n-        maxConstraintNameLength = 18;\r\n-        maxIndexNameLength = 18;\r\n-        maxColumnNameLength = 30;\r\n-        supportsDeferredConstraints = false;\r\n-        supportsDefaultDeleteAction = false;\r\n-        supportsAlterTableWithDropColumn = false;\r\n-\r\n-        supportsNullTableForGetColumns = false;\r\n-        requiresCastForMathFunctions = true;\r\n-        requiresCastForComparisons = true;\r\n-\r\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n-        }));\r\n-        \r\n-        super.setBatchLimit(defaultBatchLimit);\r\n-        \r\n-        selectWordSet.add(\"WITH\");\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccessResultSet(Select sel,\r\n-        boolean forUpdate) {\r\n-        return !forUpdate\r\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n-    }\r\n-\r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n-        boolean subselect) {\r\n-        // appends the literal range string, since DB2 is unable to handle\r\n-        // a bound parameter for it\r\n-        // do not generate FETCH FIRST clause for subselect\r\n-        if (!subselect)\r\n-            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-                append(\" ROWS ONLY\");\r\n-    }\r\n-\r\n-    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\r\n-        int idx) {\r\n-        // if this is a literal value, add a cast...\r\n-        Object val = sel.getSelects().get(idx);\r\n-        if (val instanceof Lit)\r\n-            selectSQL.append(\"CAST(\");\r\n-\r\n-        // ... and add the select per super's behavior...\r\n-        super.appendSelect(selectSQL, alias, sel, idx);\r\n-\r\n-        // ... and finish the cast\r\n-        if (val instanceof Lit) {\r\n-            Class c = ((Lit) val).getType();\r\n-            int javaTypeCode = JavaTypes.getTypeCode(c);\r\n-            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\r\n-            String typeName = getTypeName(jdbcTypeCode);\r\n-            selectSQL.append(\" AS \" + typeName);\r\n-\r\n-            // if the literal is a string, use the default char col size\r\n-            // in the cast statement.\r\n-            if (String.class.equals(c))\r\n-                selectSQL.append(\"(\" + characterColumnSize + \")\");\r\n-\r\n-            selectSQL.append(\")\");\r\n-        }\r\n-    }\r\n-\r\n-    public String[] getCreateSequenceSQL(Sequence seq) {\r\n-        String[] sql = super.getCreateSequenceSQL(seq);\r\n-        if (seq.getAllocate() > 1)\r\n-            sql[0] += \" CACHE \" + seq.getAllocate();\r\n-        return sql;\r\n-    }\r\n-\r\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(sequenceSQL);\r\n-        if (schemaName != null || sequenceName != null)\r\n-            buf.append(\" WHERE \");\r\n-        if (schemaName != null) {\r\n-            buf.append(sequenceSchemaSQL);\r\n-            if (sequenceName != null)\r\n-                buf.append(\" AND \");\r\n-        }\r\n-        if (sequenceName != null)\r\n-            buf.append(sequenceNameSQL);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public Connection decorate(Connection conn)\r\n-        throws SQLException {\r\n-        // some versions of the DB2 driver seem to default to\r\n-        // READ_UNCOMMITTED, which will prevent locking from working\r\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n-        // the same instance); if we have not overridden the\r\n-        // transaction isolation in the configuration, default to\r\n-        // TRANSACTION_READ_COMMITTED\r\n-        conn = super.decorate(conn);\r\n-\r\n-        if (conf.getTransactionIsolationConstant() == -1\r\n-            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n-            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n-\r\n-        return conn;\r\n-    }\r\n-\r\n-    public void connectedConfiguration(Connection conn) throws SQLException {\r\n-    \tsuper.connectedConfiguration(conn);\r\n-\r\n-    \tDatabaseMetaData metaData = conn.getMetaData();\r\n-        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n-        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n-        \r\n-        // Determine the type of DB2 database\r\n-        // First check for AS/400\r\n-        getProductVersionMajorMinorForISeries();\r\n-\r\n-        if (maj > 0) {\r\n-            if (isDB2ISeriesV5R3OrEarlier())\r\n-                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n-            else if (isDB2ISeriesV5R4OrLater())\r\n-                db2ServerType = db2ISeriesV5R4OrLater;\r\n-        }\r\n-        \r\n-    \tif (db2ServerType == 0) {\r\n-    \t    if (isJDBC3) {\r\n-    \t        maj = metaData.getDatabaseMajorVersion();\r\n-    \t        min = metaData.getDatabaseMinorVersion();\r\n-    \t    }\r\n-    \t    else\r\n-    \t        getProductVersionMajorMinor();\r\n-\r\n-    \t    // Determine the type of DB2 database for ZOS & UDB\r\n-    \t    if (isDB2UDBV81OrEarlier())\r\n-    \t        db2ServerType = db2UDBV81OrEarlier;\r\n-    \t    else if (isDB2ZOSV8xOrLater())\r\n-    \t        db2ServerType = db2ZOSV8xOrLater;\r\n-    \t    else if (isDB2UDBV82OrLater())\r\n-    \t        db2ServerType = db2UDBV82OrLater;\r\n-        }\r\n-\r\n-        // verify that databae product is supported\r\n-        if (db2ServerType == 0 || maj == 0)\r\n-            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n-                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n-\r\n-    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n-    \t    supportsLockingWithMultipleTables = true;\r\n-    \t    supportsLockingWithInnerJoin = true;\r\n-    \t    supportsLockingWithOuterJoin = true;\r\n-    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n-    \t    if (maj >=9)\r\n-    \t        supportsXMLColumn = true;\r\n-    \t}\r\n-\r\n-        // platform specific settings\r\n-        switch (db2ServerType) {\r\n-        case  db2ZOSV8xOrLater:\r\n-            // DB2 Z/OS \r\n-            characterColumnSize = 255;\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n-                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n-            sequenceNameSQL = \"NAME = ?\";\r\n-            if (maj == 8)\r\n-                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n-                // long to decimal\r\n-                bigintTypeName = \"DECIMAL(31,0)\";\r\n-            break;\r\n-        case db2ISeriesV5R3OrEarlier:\r\n-        case db2ISeriesV5R4OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-                + \"QSYS2.SYSTABLES\";\r\n-            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n-                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n-            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the update clause for the query based on the\r\n-     * updateClause and isolationLevel hints\r\n-     */\r\n-    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n-        boolean isForUpdate, Select sel) {\r\n-        int isolationLevel;\r\n-        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n-        // \"optimize for\" clause appears before \"for update\" clause.\r\n-        StringBuffer forUpdateString = new StringBuffer(\r\n-            getOptimizeClause(sel));\r\n-        try {\r\n-            // Determine the isolationLevel; the fetch\r\n-            // configuration data overrides the persistence.xml value\r\n-            if (fetch != null && fetch.getIsolation() != -1)\r\n-                isolationLevel = fetch.getIsolation();\r\n-            else\r\n-                isolationLevel = conf.getTransactionIsolationConstant();\r\n-\r\n-            if (isForUpdate) {\r\n-                switch(db2ServerType) {\r\n-                case db2ISeriesV5R3OrEarlier:\r\n-                case db2UDBV81OrEarlier:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n-                        forUpdateString.append(\" \").append(forUpdateClause);\r\n-                    else \r\n-                        forUpdateString.append(\" \").append(forUpdate)\r\n-                            .append(\" \").append(withRSClause);\r\n-                    break;\r\n-                case db2ZOSV8xOrLater:\r\n-                case db2UDBV82OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);   \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);                            \r\n-                    }\r\n-                    break;\r\n-                case db2ISeriesV5R4OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);       \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);\r\n-                    }\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        catch (Exception e) {\r\n-            if (log.isTraceEnabled())\r\n-                log.error(e.toString(),e);\r\n-        }\r\n-        return forUpdateString.toString();\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV82OrLater() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n-             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n-             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n-    }\r\n-\r\n-    public boolean isDB2ZOSV8xOrLater() {\r\n-       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n-            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n-            && maj >= 8;\r\n-           \r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n-       return (databaseProductName.indexOf(\"AS\") != -1\r\n-           && ((maj == 5 && min <=3) || maj < 5));\r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R4OrLater() {\r\n-       return databaseProductName.indexOf(\"AS\") != -1\r\n-           && (maj >=6 || (maj == 5 && min >=4));\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV81OrEarlier() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n-            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n-            && ((maj == 8 && min <= 1) || maj < 8);\r\n-    }\r\n-\r\n-    /** Get the version Major/Minor for the ISeries\r\n-     */\r\n-    private void getProductVersionMajorMinorForISeries() {\r\n-        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n-        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n-        // ISeries                               DB2 UDB for AS/400\r\n-        //   (Native)                            V5R4M0\r\n-        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\r\n-        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n-            // default to V5R4\r\n-            maj = 5;\r\n-            min = 4;\r\n-            int index = databaseProductVersion.indexOf('V');\r\n-            if (index != -1) {\r\n-                String s = databaseProductVersion.substring(index);\r\n-                s = s.toUpperCase();\r\n-\r\n-                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n-                    , false);\r\n-                if (stringtokenizer.countTokens() == 3) {\r\n-                    String s1 = stringtokenizer.nextToken();\r\n-                    maj = Integer.parseInt(s1);\r\n-                    String s2 =  stringtokenizer.nextToken();\r\n-                    min = Integer.parseInt(s2);\r\n-                }\r\n-            } else {\r\n-                index = databaseProductVersion.indexOf('0');\r\n-                if (index != -1) {\r\n-                    String s = databaseProductVersion.substring(index);\r\n-                    s = s.toUpperCase();\r\n-\r\n-                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n-                        , false);                    \r\n-                    if (stringtokenizer.countTokens() == 2) {\r\n-                        String s1 = stringtokenizer.nextToken();\r\n-                        maj = Integer.parseInt(s1);\r\n-                        String s2 =  stringtokenizer.nextToken();\r\n-                        min = Integer.parseInt(s2);\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    private void getProductVersionMajorMinor() {\r\n-        // Incase JDBC driver version is lower than 3\r\n-        // use following info to determine Major and Minor \r\n-        //                        CLI    vs      JCC\r\n-        // ZDBV8 DBProdName       DB2            DB2\r\n-        //       DBProdVersion    08.01.0005     DSN08015\r\n-        // ZDBV9                  DB2            DB2\r\n-        //                        09.01.0005     DSN09015\r\n-        // WinV9                  DB2/NT         DB2/NT\r\n-        //                        09.01.0000     SQL09010\r\n-        // SolarisV9                             DB2/SUN64\r\n-        //                                       SQL0901\r\n-        // Linux                  DB2/LINUX      DB2/LINUX\r\n-        //                        09.01.0000     SQL0901\r\n-        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n-            maj = 9;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n-            maj = 8;\r\n-            min = 2;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected String getOptimizeClause(Select sel) {\r\n-        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            buf.append(\" \").append(optimizeClause).append(\" \")\r\n-                .append(String.valueOf(sel.getExpectedResultCount()))\r\n-                .append(\" \").append(rowClause);\r\n-            return buf.toString();\r\n-        }\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n-        Object failed) {\r\n-        if (causes != null && causes.length > 0)\r\n-            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n-        return super.newStoreException(msg, causes, failed);\r\n-    }\r\n-\r\n-    /**\r\n-     *  Append exception information from SQLCA to the exsisting\r\n-     *  exception meassage\r\n-     */\r\n-    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n-       final String GETSQLCA =\"getSqlca\";\r\n-       String exceptionMsg = new String();\r\n-       try {\r\n-            Method sqlcaM2 = sqle.getNextException().getClass()\r\n-                             .getMethod(GETSQLCA,null);\r\n-            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n-                                          new Object[] {});\r\n-            Method  getSqlErrpMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrp\", null);\r\n-            Method  getSqlWarnMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlWarn\", null);\r\n-            Method  getSqlErrdMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrd\", null);\r\n-            StringBuffer errdStr = new StringBuffer();\r\n-\r\n-            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n-            for (int i = 0; i < errds.length; i++)\r\n-                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n-                    append(errds[i]);\r\n-            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n-                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n-                    + \", Errd=\" + errdStr);\r\n-\r\n-            String Warn = new String((char[]) getSqlWarnMethd.\r\n-                    invoke(sqlca, new Object[]{}));\r\n-            if (Warn.trim().length() != 0)\r\n-                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n-            else\r\n-                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n-            msg = msg.concat(exceptionMsg);\r\n-            \r\n-            // for batched execution failures, SQLExceptions are nested\r\n-            SQLException sqle2 = sqle.getNextException();\r\n-            while (sqle2 != null) {                \r\n-                msg = msg.concat(\"\\n\" + sqle2.getMessage());\r\n-                sqle2 = sqle2.getNextException();\r\n-            }\r\n-            \r\n-            return msg;\r\n-        } catch (Throwable t) {\r\n-            return sqle.getMessage();\r\n-        }\r\n-    }\r\n-\r\n-    public int getDb2ServerType() {\r\n-        return db2ServerType;\r\n-    }\r\n-    \r\n-    protected void appendLength(SQLBuffer buf, int type) {\r\n-        if (type == Types.VARCHAR)\r\n-            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n-                append(\")\");\r\n-    }\r\n-\r\n-    /**\r\n-     * If this dictionary supports XML type,\r\n-     * use this method to append xml predicate.\r\n-     * \r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison\r\n-     * @param rhs the right hand side of the comparison\r\n-     * @param lhsxml indicates whether the left operand maps to xml\r\n-     * @param rhsxml indicates whether the right operand maps to xml\r\n-     */\r\n-    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n-        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n-        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n-        if (lhsxml && rhsxml)\r\n-            appendXmlComparison2(buf, op, lhs, rhs);\r\n-        else if (lhsxml)\r\n-            appendXmlComparison1(buf, op, lhs, rhs);\r\n-        else \r\n-            appendXmlComparison1(buf, op, rhs, lhs);\r\n-    }\r\n-\r\n-    /**\r\n-     * Append an xml comparison predicate.\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison\r\n-     */\r\n-    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        boolean castrhs = false;\r\n-        Class rc = Filters.wrap(rhs.getType());\r\n-        int type = 0;\r\n-        if (rhs.isConstant()) {\r\n-            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n-            castrhs = true;\r\n-        }\r\n-        \r\n-        appendXmlExists(buf, lhs);\r\n-\r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        \r\n-        if (castrhs)\r\n-            appendCast(buf, rhs, type);\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\" AS \\\"\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        buf.append(\"\\\")\");\r\n-    }\r\n-    \r\n-    /**\r\n-     * Append an xml comparison predicate. (both operands map to xml column)\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison (maps to xml column)\r\n-     */\r\n-    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        appendXmlExists(buf, lhs);\r\n-        \r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\").append(rhs.getColumnAlias(\r\n-            rhs.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*/\");\r\n-        rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        appendXmlVar(buf, rhs);\r\n-        buf.append(\")\");\r\n-    }\r\n-    \r\n-    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\" AS \").\r\n-            append(\"\\\"\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"\\\"\");        \r\n-    }\r\n-    \r\n-    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(\"XMLEXISTS('\");\r\n-        buf.append(\"$\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*[\");\r\n-        val.appendTo(buf);        \r\n-    }\r\n-    \r\n-    /**\r\n-     * add CAST for a scalar function where operand is a param\r\n-     * \r\n-     * @param func original string\r\n-     * @param target substring to look for\r\n-     * @param asString \r\n-     * @return updated string (func)\r\n-     */\r\n-    private String addCastAsString(String func, String target, \r\n-            String asString) {\r\n-        String fstring = func;\r\n-        if (func.indexOf(target) != -1)\r\n-            fstring = Strings.replace(\r\n-                func, target, \"CAST(\" + target + asString + \")\");\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * add CAST for a function operator where operand is a param\r\n-     * \r\n-     * @param func function name\r\n-     * @param val type\r\n-     * @return updated string (func)\r\n-     */\r\n-    public String addCastAsType(String func, Val val) {\r\n-        String fstring = null;\r\n-        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n-            .getType()), false));\r\n-        if (String.class.equals(val.getType()))\r\n-            type = type + \"(\" + characterColumnSize + \")\";\r\n-        fstring = \"CAST(? AS \" + type + \")\";\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the batch limit. If the batchLimit is -1, change it to 100 for\r\n-     * best performance\r\n-     */\r\n-    public int getBatchLimit() {\r\n-        int limit = super.getBatchLimit();\r\n-        if (limit == UNLIMITED) {\r\n-            limit = defaultBatchLimit;\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\r\n-        }\r\n-        return limit;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the correct CAST function syntax\r\n-     * \r\n-     * @param val operand of cast\r\n-     * @param func original string\r\n-     * @return a String with the correct CAST function syntax\r\n-     */\r\n-    public String getCastFunction(Val val, String func) {\r\n-        if (val instanceof Lit || val instanceof Param)\r\n-            if (func.indexOf(\"VARCHAR\") == -1)\r\n-                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n-        return func;\r\n-    }\r\n-\r\n-    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n-            FilterValue start) {\r\n-        if (find.getValue() != null) { // non constants\r\n-            buf.append(\"(LOCATE(CAST((\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000)), \");\r\n-        } else {\r\n-            // this is a constant\r\n-            buf.append(\"(LOCATE(\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\", \");\r\n-        }\r\n-        if (str.getValue() != null) {\r\n-            buf.append(\"CAST((\");\r\n-            str.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000))\");\r\n-        } else {\r\n-            str.appendTo(buf);\r\n-        }\r\n-        if (start != null) {\r\n-            if (start.getValue() == null) {\r\n-                buf.append(\", CAST((\");\r\n-                start.appendTo(buf);\r\n-                buf.append(\") AS INTEGER) + 1\");\r\n-            } else {\r\n-                buf.append(\", \");\r\n-                start.appendTo(buf);\r\n-            }\r\n-        }\r\n-        buf.append(\") - 1)\");\r\n-    }\r\n-    \r\n-    /** \r\n-     * Cast the specified value to the specified type.\r\n-     *\r\n-     * @param buf the buffer to append the cast to\r\n-     * @param val the value to cast\r\n-     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n-     */\r\n-    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n-\r\n-        // Convert the cast function: \"CAST({0} AS {1})\"\r\n-        int firstParam = castFunction.indexOf(\"{0}\");\r\n-        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n-        String mid = castFunction.substring(firstParam + 3);\r\n-        int secondParam = mid.indexOf(\"{1}\");\r\n-        String post;\r\n-        if (secondParam > -1) {\r\n-            post = mid.substring(secondParam + 3); // \")\"\r\n-            mid = mid.substring(0, secondParam); // \" AS \"\r\n-        } else\r\n-            post = \"\";\r\n-\r\n-        // No need to add CAST if the value is a constant\r\n-        if (val instanceof Lit || val instanceof Param) {\r\n-            buf.append(pre);\r\n-            val.appendTo(buf);\r\n-            buf.append(mid);\r\n-            buf.append(getTypeName(type));\r\n-            appendLength(buf, type);\r\n-            buf.append(post);\r\n-        } else {\r\n-            val.appendTo(buf);\r\n-            String sqlString = buf.getSQL(false);\r\n-            if (sqlString.endsWith(\"?\")) {\r\n-                // case \"(?\" - convert to \"CAST(? AS type\"\r\n-                String typeName = getTypeName(type);\r\n-                if (String.class.equals(val.getType()))\r\n-                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n-                String str = \"CAST(? AS \" + typeName + \")\";\r\n-                buf.replaceSqlString(sqlString.length() - 1,\r\n-                        sqlString.length(), str);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an index if necessary for some database tables\r\n-     */\r\n-    public void createIndexIfNecessary(Schema schema, String table,\r\n-            Column pkColumn) {\r\n-        if (isDB2ZOSV8xOrLater()) {\r\n-            // build the index for the sequence tables\r\n-            // the index name will the fully qualified table name + _IDX\r\n-            Table tab = schema.getTable(table);\r\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n-            idx.setUnique(true);\r\n-            idx.addColumn(pkColumn);\r\n-        }\r\n-    }\r\n-    \r\n-    String nullSafe(String s) {\r\n-    \treturn s == null ? \"\" : s;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Dictionary for IBM DB2 database.\n+ */\n+public class DB2Dictionary\n+    extends AbstractDB2Dictionary {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DB2Dictionary.class);\n+\n+    public String optimizeClause = \"optimize for\";\n+    public String rowClause = \"row\";\n+    protected int db2ServerType = 0;\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\n+    public static final int db2UDBV81OrEarlier = 2;\n+    public static final int db2ZOSV8xOrLater = 3;\n+    public static final int db2UDBV82OrLater = 4;\n+    public static final int db2ISeriesV5R4OrLater = 5;\n+\tprotected static final String forUpdate = \"FOR UPDATE\";\n+    protected static final String withURClause = \"WITH UR\";\n+    protected static final String withCSClause = \"WITH CS\";\n+    protected static final String withRSClause = \"WITH RS\";\n+    protected static final String withRRClause = \"WITH RR\";\n+    protected static final String useKeepShareLockClause\n+        = \"USE AND KEEP SHARE LOCKS\";\n+    protected static final String useKeepUpdateLockClause\n+        = \"USE AND KEEP UPDATE LOCKS\";\n+    protected static final String useKeepExclusiveLockClause\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\n+    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\n+    protected String databaseProductName = \"\";\n+    protected String databaseProductVersion = \"\";\n+    protected int maj = 0;\n+    protected int min = 0;\n+    \n+    private int defaultBatchLimit = 100;\n+\n+    public DB2Dictionary() {\n+        platform = \"DB2\";\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+            + \"SYSIBM.SYSTABLES\";\n+        supportsSelectEndIndex = true;\n+\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n+\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n+        sequenceNameSQL = \"SEQNAME = ?\";\n+        characterColumnSize = 254;\n+\n+        binaryTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        varbinaryTypeName = \"BLOB(1M)\";\n+        clobTypeName = \"CLOB(1M)\";\n+        longVarcharTypeName = \"LONG VARCHAR\";\n+        datePrecision = MICRO;\n+        storeCharsAsNumbers = false;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n+        }));\n+        systemSchemas = new String(\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 18;\n+        maxColumnNameLength = 30;\n+        supportsDeferredConstraints = false;\n+        supportsDefaultDeleteAction = false;\n+        supportsAlterTableWithDropColumn = false;\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n+        }));\n+        \n+        super.setBatchLimit(defaultBatchLimit);\n+        \n+        selectWordSet.add(\"WITH\");\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // appends the literal range string, since DB2 is unable to handle\n+        // a bound parameter for it\n+        // do not generate FETCH FIRST clause for subselect\n+        if (!subselect)\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n+                append(\" ROWS ONLY\");\n+    }\n+\n+    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\n+        int idx) {\n+        // if this is a literal value, add a cast...\n+        Object val = sel.getSelects().get(idx);\n+        if (val instanceof Lit)\n+            selectSQL.append(\"CAST(\");\n+\n+        // ... and add the select per super's behavior...\n+        super.appendSelect(selectSQL, alias, sel, idx);\n+\n+        // ... and finish the cast\n+        if (val instanceof Lit) {\n+            Class c = ((Lit) val).getType();\n+            int javaTypeCode = JavaTypes.getTypeCode(c);\n+            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\n+            String typeName = getTypeName(jdbcTypeCode);\n+            selectSQL.append(\" AS \" + typeName);\n+\n+            // if the literal is a string, use the default char col size\n+            // in the cast statement.\n+            if (String.class.equals(c))\n+                selectSQL.append(\"(\" + characterColumnSize + \")\");\n+\n+            selectSQL.append(\")\");\n+        }\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(sequenceSQL);\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(sequenceSchemaSQL);\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(sequenceNameSQL);\n+        return buf.toString();\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        // some versions of the DB2 driver seem to default to\n+        // READ_UNCOMMITTED, which will prevent locking from working\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\n+        // the same instance); if we have not overridden the\n+        // transaction isolation in the configuration, default to\n+        // TRANSACTION_READ_COMMITTED\n+        conn = super.decorate(conn);\n+\n+        if (conf.getTransactionIsolationConstant() == -1\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\n+\n+        return conn;\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+    \tsuper.connectedConfiguration(conn);\n+\n+    \tDatabaseMetaData metaData = conn.getMetaData();\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\n+        \n+        // Determine the type of DB2 database\n+        // First check for AS/400\n+        getProductVersionMajorMinorForISeries();\n+\n+        if (maj > 0) {\n+            if (isDB2ISeriesV5R3OrEarlier())\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\n+            else if (isDB2ISeriesV5R4OrLater())\n+                db2ServerType = db2ISeriesV5R4OrLater;\n+        }\n+        \n+    \tif (db2ServerType == 0) {\n+    \t    if (isJDBC3) {\n+    \t        maj = metaData.getDatabaseMajorVersion();\n+    \t        min = metaData.getDatabaseMinorVersion();\n+    \t    }\n+    \t    else\n+    \t        getProductVersionMajorMinor();\n+\n+    \t    // Determine the type of DB2 database for ZOS & UDB\n+    \t    if (isDB2UDBV81OrEarlier())\n+    \t        db2ServerType = db2UDBV81OrEarlier;\n+    \t    else if (isDB2ZOSV8xOrLater())\n+    \t        db2ServerType = db2ZOSV8xOrLater;\n+    \t    else if (isDB2UDBV82OrLater())\n+    \t        db2ServerType = db2UDBV82OrLater;\n+        }\n+\n+        // verify that databae product is supported\n+        if (db2ServerType == 0 || maj == 0)\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \n+\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n+    \t    supportsLockingWithMultipleTables = true;\n+    \t    supportsLockingWithInnerJoin = true;\n+    \t    supportsLockingWithOuterJoin = true;\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n+    \t    if (maj >=9)\n+    \t        supportsXMLColumn = true;\n+    \t}\n+\n+        // platform specific settings\n+        switch (db2ServerType) {\n+        case  db2ZOSV8xOrLater:\n+            // DB2 Z/OS \n+            characterColumnSize = 255;\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\n+            sequenceNameSQL = \"NAME = ?\";\n+            if (maj == 8)\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\n+                // long to decimal\n+                bigintTypeName = \"DECIMAL(31,0)\";\n+            break;\n+        case db2ISeriesV5R3OrEarlier:\n+        case db2ISeriesV5R4OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+                + \"QSYS2.SYSTABLES\";\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Get the update clause for the query based on the\n+     * updateClause and isolationLevel hints\n+     */\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n+        boolean isForUpdate, Select sel) {\n+        int isolationLevel;\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n+        // \"optimize for\" clause appears before \"for update\" clause.\n+        StringBuffer forUpdateString = new StringBuffer(\n+            getOptimizeClause(sel));\n+        try {\n+            // Determine the isolationLevel; the fetch\n+            // configuration data overrides the persistence.xml value\n+            if (fetch != null && fetch.getIsolation() != -1)\n+                isolationLevel = fetch.getIsolation();\n+            else\n+                isolationLevel = conf.getTransactionIsolationConstant();\n+\n+            if (isForUpdate) {\n+                switch(db2ServerType) {\n+                case db2ISeriesV5R3OrEarlier:\n+                case db2UDBV81OrEarlier:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\n+                        forUpdateString.append(\" \").append(forUpdateClause);\n+                    else \n+                        forUpdateString.append(\" \").append(forUpdate)\n+                            .append(\" \").append(withRSClause);\n+                    break;\n+                case db2ZOSV8xOrLater:\n+                case db2UDBV82OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);   \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);                            \n+                    }\n+                    break;\n+                case db2ISeriesV5R4OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);       \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            if (log.isTraceEnabled())\n+                log.error(e.toString(),e);\n+        }\n+        return forUpdateString.toString();\n+    }\n+\n+    public boolean isDB2UDBV82OrLater() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\n+    }\n+\n+    public boolean isDB2ZOSV8xOrLater() {\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\n+            && maj >= 8;\n+           \n+    }\n+\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\n+       return (databaseProductName.indexOf(\"AS\") != -1\n+           && ((maj == 5 && min <=3) || maj < 5));\n+    }\n+\n+    public boolean isDB2ISeriesV5R4OrLater() {\n+       return databaseProductName.indexOf(\"AS\") != -1\n+           && (maj >=6 || (maj == 5 && min >=4));\n+    }\n+\n+    public boolean isDB2UDBV81OrEarlier() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \n+            || databaseProductName.indexOf(\"DB2/\") != -1) \n+            && ((maj == 8 && min <= 1) || maj < 8);\n+    }\n+\n+    /** Get the version Major/Minor for the ISeries\n+     */\n+    private void getProductVersionMajorMinorForISeries() {\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n+        // ISeries                               DB2 UDB for AS/400\n+        //   (Native)                            V5R4M0\n+        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\n+            // default to V5R4\n+            maj = 5;\n+            min = 4;\n+            int index = databaseProductVersion.indexOf('V');\n+            if (index != -1) {\n+                String s = databaseProductVersion.substring(index);\n+                s = s.toUpperCase();\n+\n+                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n+                    , false);\n+                if (stringtokenizer.countTokens() == 3) {\n+                    String s1 = stringtokenizer.nextToken();\n+                    maj = Integer.parseInt(s1);\n+                    String s2 =  stringtokenizer.nextToken();\n+                    min = Integer.parseInt(s2);\n+                }\n+            } else {\n+                index = databaseProductVersion.indexOf('0');\n+                if (index != -1) {\n+                    String s = databaseProductVersion.substring(index);\n+                    s = s.toUpperCase();\n+\n+                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n+                        , false);                    \n+                    if (stringtokenizer.countTokens() == 2) {\n+                        String s1 = stringtokenizer.nextToken();\n+                        maj = Integer.parseInt(s1);\n+                        String s2 =  stringtokenizer.nextToken();\n+                        min = Integer.parseInt(s2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void getProductVersionMajorMinor() {\n+        // Incase JDBC driver version is lower than 3\n+        // use following info to determine Major and Minor \n+        //                        CLI    vs      JCC\n+        // ZDBV8 DBProdName       DB2            DB2\n+        //       DBProdVersion    08.01.0005     DSN08015\n+        // ZDBV9                  DB2            DB2\n+        //                        09.01.0005     DSN09015\n+        // WinV9                  DB2/NT         DB2/NT\n+        //                        09.01.0000     SQL09010\n+        // SolarisV9                             DB2/SUN64\n+        //                                       SQL0901\n+        // Linux                  DB2/LINUX      DB2/LINUX\n+        //                        09.01.0000     SQL0901\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\n+            maj = 9;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n+            maj = 8;\n+            min = 2;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        }\n+    }\n+\n+    protected String getOptimizeClause(Select sel) {\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\" \").append(optimizeClause).append(\" \")\n+                .append(String.valueOf(sel.getExpectedResultCount()))\n+                .append(\" \").append(rowClause);\n+            return buf.toString();\n+        }\n+\n+        return \"\";\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        if (causes != null && causes.length > 0)\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\n+        return super.newStoreException(msg, causes, failed);\n+    }\n+\n+    /**\n+     *  Append exception information from SQLCA to the exsisting\n+     *  exception meassage\n+     */\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n+       final String GETSQLCA =\"getSqlca\";\n+       String exceptionMsg = new String();\n+       try {\n+            Method sqlcaM2 = sqle.getNextException().getClass()\n+                             .getMethod(GETSQLCA,null);\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n+                                          new Object[] {});\n+            Method  getSqlErrpMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrp\", null);\n+            Method  getSqlWarnMethd = sqlca.getClass().\n+            getMethod(\"getSqlWarn\", null);\n+            Method  getSqlErrdMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrd\", null);\n+            StringBuffer errdStr = new StringBuffer();\n+\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n+            for (int i = 0; i < errds.length; i++)\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n+                    append(errds[i]);\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\n+                    + \", Errd=\" + errdStr);\n+\n+            String Warn = new String((char[]) getSqlWarnMethd.\n+                    invoke(sqlca, new Object[]{}));\n+            if (Warn.trim().length() != 0)\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\n+            else\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\n+            msg = msg.concat(exceptionMsg);\n+            \n+            // for batched execution failures, SQLExceptions are nested\n+            SQLException sqle2 = sqle.getNextException();\n+            while (sqle2 != null) {                \n+                msg = msg.concat(\"\\n\" + sqle2.getMessage());\n+                sqle2 = sqle2.getNextException();\n+            }\n+            \n+            return msg;\n+        } catch (Throwable t) {\n+            return sqle.getMessage();\n+        }\n+    }\n+\n+    public int getDb2ServerType() {\n+        return db2ServerType;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n+                append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+\n+    /**\n+     * Append an xml comparison predicate.\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = false;\n+        Class rc = Filters.wrap(rhs.getType());\n+        int type = 0;\n+        if (rhs.isConstant()) {\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+            castrhs = true;\n+        }\n+        \n+        appendXmlExists(buf, lhs);\n+\n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        \n+        if (castrhs)\n+            appendCast(buf, rhs, type);\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\" AS \\\"\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        buf.append(\"\\\")\");\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate. (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        appendXmlExists(buf, lhs);\n+        \n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\").append(rhs.getColumnAlias(\n+            rhs.getFieldMapping().getColumns()[0])).\n+            append(\"/*/\");\n+        rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        appendXmlVar(buf, rhs);\n+        buf.append(\")\");\n+    }\n+    \n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\" AS \").\n+            append(\"\\\"\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"\\\"\");        \n+    }\n+    \n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"XMLEXISTS('\");\n+        buf.append(\"$\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"/*[\");\n+        val.appendTo(buf);        \n+    }\n+    \n+    /**\n+     * add CAST for a scalar function where operand is a param\n+     * \n+     * @param func original string\n+     * @param target substring to look for\n+     * @param asString \n+     * @return updated string (func)\n+     */\n+    private String addCastAsString(String func, String target, \n+            String asString) {\n+        String fstring = func;\n+        if (func.indexOf(target) != -1)\n+            fstring = Strings.replace(\n+                func, target, \"CAST(\" + target + asString + \")\");\n+        return fstring;\n+    }\n+\n+    /**\n+     * add CAST for a function operator where operand is a param\n+     * \n+     * @param func function name\n+     * @param val type\n+     * @return updated string (func)\n+     */\n+    public String addCastAsType(String func, Val val) {\n+        String fstring = null;\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\n+            .getType()), false));\n+        if (String.class.equals(val.getType()))\n+            type = type + \"(\" + characterColumnSize + \")\";\n+        fstring = \"CAST(? AS \" + type + \")\";\n+        return fstring;\n+    }\n+\n+    /**\n+     * Return the batch limit. If the batchLimit is -1, change it to 100 for\n+     * best performance\n+     */\n+    public int getBatchLimit() {\n+        int limit = super.getBatchLimit();\n+        if (limit == UNLIMITED) {\n+            limit = defaultBatchLimit;\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\n+        }\n+        return limit;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func) {\n+        if (val instanceof Lit || val instanceof Param)\n+            if (func.indexOf(\"VARCHAR\") == -1)\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\n+        return func;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        if (find.getValue() != null) { // non constants\n+            buf.append(\"(LOCATE(CAST((\");\n+            find.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000)), \");\n+        } else {\n+            // this is a constant\n+            buf.append(\"(LOCATE(\");\n+            find.appendTo(buf);\n+            buf.append(\", \");\n+        }\n+        if (str.getValue() != null) {\n+            buf.append(\"CAST((\");\n+            str.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000))\");\n+        } else {\n+            str.appendTo(buf);\n+        }\n+        if (start != null) {\n+            if (start.getValue() == null) {\n+                buf.append(\", CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER) + 1\");\n+            } else {\n+                buf.append(\", \");\n+                start.appendTo(buf);\n+            }\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+    \n+    /** \n+     * Cast the specified value to the specified type.\n+     *\n+     * @param buf the buffer to append the cast to\n+     * @param val the value to cast\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\n+     */\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n+\n+        // Convert the cast function: \"CAST({0} AS {1})\"\n+        int firstParam = castFunction.indexOf(\"{0}\");\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\n+        String mid = castFunction.substring(firstParam + 3);\n+        int secondParam = mid.indexOf(\"{1}\");\n+        String post;\n+        if (secondParam > -1) {\n+            post = mid.substring(secondParam + 3); // \")\"\n+            mid = mid.substring(0, secondParam); // \" AS \"\n+        } else\n+            post = \"\";\n+\n+        // No need to add CAST if the value is a constant\n+        if (val instanceof Lit || val instanceof Param) {\n+            buf.append(pre);\n+            val.appendTo(buf);\n+            buf.append(mid);\n+            buf.append(getTypeName(type));\n+            appendLength(buf, type);\n+            buf.append(post);\n+        } else {\n+            val.appendTo(buf);\n+            String sqlString = buf.getSQL(false);\n+            if (sqlString.endsWith(\"?\")) {\n+                // case \"(?\" - convert to \"CAST(? AS type\"\n+                String typeName = getTypeName(type);\n+                if (String.class.equals(val.getType()))\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\n+                String str = \"CAST(? AS \" + typeName + \")\";\n+                buf.replaceSqlString(sqlString.length() - 1,\n+                        sqlString.length(), str);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an index if necessary for some database tables\n+     */\n+    public void createIndexIfNecessary(Schema schema, String table,\n+            Column pkColumn) {\n+        if (isDB2ZOSV8xOrLater()) {\n+            // build the index for the sequence tables\n+            // the index name will the fully qualified table name + _IDX\n+            Table tab = schema.getTable(table);\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            idx.setUnique(true);\n+            idx.addColumn(pkColumn);\n+        }\n+    }\n+    \n+    String nullSafe(String s) {\n+    \treturn s == null ? \"\" : s;\n+    }\n+}"},{"sha":"dece0a3254493b20a68b722f1110e9eec408da7f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"modified","additions":155,"deletions":155,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,155 +1,155 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.util.ArrayList;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import javax.xml.parsers.DocumentBuilder;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.xml.XMLFactory;\r\n-import org.apache.openjpa.util.StoreException;\r\n-import org.w3c.dom.Document;\r\n-import org.w3c.dom.Element;\r\n-import org.w3c.dom.NamedNodeMap;\r\n-import org.w3c.dom.Node;\r\n-import org.w3c.dom.NodeList;\r\n-\r\n-/**\r\n- * Parses XML content of SQL Error State codes to populate errro codes for\r\n- * a given Database Dictionary.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class SQLErrorCodeReader {\r\n-\tprivate Log log = null;\r\n-\tpublic static final String ERROR_CODE_DELIMITER = \",\";\r\n-\tpublic static final Map<String, Integer> storeErrorTypes = \r\n-\t\tnew HashMap<String, Integer>();\r\n-\tstatic {\r\n-\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\r\n-\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\r\n-\t\tstoreErrorTypes\r\n-\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\r\n-\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\r\n-\t\tstoreErrorTypes.put(\"referential-integrity\",\r\n-\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\r\n-\r\n-\t}\r\n-\t\r\n-\tprivate static final Localizer _loc = \r\n-\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\r\n-\t\r\n-\tpublic List<String> getDictionaries(InputStream in) {\r\n-\t\tList<String> result = new ArrayList<String>();\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null) {\r\n-\t\t\t\t   result.add(dictionary.getNodeValue());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn result;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Parses given stream of XML content for error codes of the given database\r\n-\t * dictionary name. Populates the given dictionary with the error codes.\r\n-\t * \r\n-\t */\r\n-\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\r\n-\t\tif (in == null || dict == null)\r\n-\t\t\treturn;\r\n-\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null \r\n-\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\r\n-\t\t\t\t\treadErrorCodes(node, dict);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic void readErrorCodes(Node node, DBDictionary dict) {\r\n-\t\tNodeList children = node.getChildNodes();\r\n-\t\tfor (int i = 0; i < children.getLength(); i++) {\r\n-\t\t\tNode child = children.item(i);\r\n-\t\t\tshort nodeType = child.getNodeType();\r\n-\t\t\tif (nodeType == Node.ELEMENT_NODE) {\r\n-\t\t\t\tString errorType = child.getNodeName();\r\n-\t\t\t\tNode textNode = child.getFirstChild();\r\n-\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\r\n-\t\t\t\t\tString errorCodes = textNode.getNodeValue();\r\n-\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\r\n-\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\r\n-\t\t\t\t\t\tfor (String code : codes) {\r\n-\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\r\n-\t\t\t\t\t\t\t\t\tcode.trim());\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.xml.XMLFactory;\n+import org.apache.openjpa.util.StoreException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Parses XML content of SQL Error State codes to populate errro codes for\n+ * a given Database Dictionary.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class SQLErrorCodeReader {\n+\tprivate Log log = null;\n+\tpublic static final String ERROR_CODE_DELIMITER = \",\";\n+\tpublic static final Map<String, Integer> storeErrorTypes = \n+\t\tnew HashMap<String, Integer>();\n+\tstatic {\n+\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\n+\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\n+\t\tstoreErrorTypes\n+\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\n+\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\n+\t\tstoreErrorTypes.put(\"referential-integrity\",\n+\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\n+\n+\t}\n+\t\n+\tprivate static final Localizer _loc = \n+\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\n+\t\n+\tpublic List<String> getDictionaries(InputStream in) {\n+\t\tList<String> result = new ArrayList<String>();\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null) {\n+\t\t\t\t   result.add(dictionary.getNodeValue());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Parses given stream of XML content for error codes of the given database\n+\t * dictionary name. Populates the given dictionary with the error codes.\n+\t * \n+\t */\n+\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\n+\t\tif (in == null || dict == null)\n+\t\t\treturn;\n+\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null \n+\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\n+\t\t\t\t\treadErrorCodes(node, dict);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tstatic void readErrorCodes(Node node, DBDictionary dict) {\n+\t\tNodeList children = node.getChildNodes();\n+\t\tfor (int i = 0; i < children.getLength(); i++) {\n+\t\t\tNode child = children.item(i);\n+\t\t\tshort nodeType = child.getNodeType();\n+\t\t\tif (nodeType == Node.ELEMENT_NODE) {\n+\t\t\t\tString errorType = child.getNodeName();\n+\t\t\t\tNode textNode = child.getFirstChild();\n+\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\n+\t\t\t\t\tString errorCodes = textNode.getNodeValue();\n+\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\n+\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\n+\t\t\t\t\t\tfor (String code : codes) {\n+\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\n+\t\t\t\t\t\t\t\t\tcode.trim());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"c6f72508032ef3c8519795656ef15a9a6a180414","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","status":"modified","additions":882,"deletions":882,"changes":1764,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,882 +1,882 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectOutput;\r\n-import java.sql.CallableStatement;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Savepoint;\r\n-import java.sql.Statement;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.enhance.StateManager;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.Strategy;\r\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.SQLFactory;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * <p>\r\n- * Tests AbstractUpdateManager flush's method exception return behavior.\r\n- * </p>\r\n- * \r\n- * @author Albert Lee\r\n- */\r\n-public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\r\n-\r\n-    private TestUpdateManager updMgr;\r\n-\r\n-    public void setUp() {\r\n-        updMgr = new TestUpdateManager();\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests exception collection returns from UpdateManager flush method is in\r\n-     * the order the original exceptions are thrown.\r\n-     */\r\n-    public void testAddRetrieve() {\r\n-        \r\n-        Collection states = new ArrayList<OpenJPAStateManager>();\r\n-        states.add(new TestOpenJPAStateManager());\r\n-\r\n-        Collection exceps = updMgr.flush(states, new TestJDBCStore());\r\n-\r\n-        assertEquals(3, exceps.size());\r\n-        \r\n-        Iterator<Exception> itr = exceps.iterator();\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.populateRowManager\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.flush\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.customInsert\");\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test update manager.\r\n-     */\r\n-    class TestUpdateManager extends AbstractUpdateManager {\r\n-\r\n-        protected Collection flush(RowManager rowMgr,\r\n-            PreparedStatementManager psMgr, Collection exceps) {\r\n-\r\n-            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\r\n-\r\n-            return exceps;\r\n-        }\r\n-\r\n-        protected PreparedStatementManager newPreparedStatementManager(\r\n-            JDBCStore store, Connection conn) {\r\n-            return new PreparedStatementManagerImpl(store, conn);\r\n-        }\r\n-\r\n-        protected RowManager newRowManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean orderDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        protected Collection populateRowManager(OpenJPAStateManager sm,\r\n-            RowManager rowMgr, JDBCStore store, Collection exceps,\r\n-            Collection customs) {\r\n-            \r\n-            exceps.add(new SQLException(\r\n-                \"TestUpdateManager.populateRowManager\"));\r\n-            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\r\n-                new Strategy() {\r\n-                    public void customDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void customInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                        throw new SQLException(\r\n-                            \"TestUpdateManager.customInsert\");\r\n-                    }\r\n-\r\n-                    public void customUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void delete(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-\r\n-                    public String getAlias() {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void initialize() {\r\n-                    }\r\n-\r\n-                    public void insert(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-\r\n-                    }\r\n-\r\n-                    public Boolean isCustomDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void map(boolean adapt) {\r\n-                    }\r\n-\r\n-                    public void update(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-                }));\r\n-            return exceps;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test state manager.\r\n-     */\r\n-    class TestOpenJPAStateManager implements OpenJPAStateManager {\r\n-\r\n-        public boolean assignObjectId(boolean flush) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean beforeRefresh(boolean refreshAll) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void dirty(int field) {\r\n-        }\r\n-\r\n-        public Object fetch(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean fetchBoolean(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByte(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchChar(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDouble(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchField(int field, boolean transitions) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public float fetchFloat(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchInitialField(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int fetchInt(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLong(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObject(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShort(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchString(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getDirty() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getFlushed() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getIntermediate(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getLoaded() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getLock() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getManagedInstance() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public ClassMetaData getMetaData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public OpenJPAStateManager getOwner() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getOwnerIndex() {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public PCState getPCState() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PersistenceCapable getPersistenceCapable() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getUnloaded(FetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getVersion() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void initialize(Class forType, PCState state) {\r\n-        }\r\n-\r\n-        public boolean isDefaultValue(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isEmbedded() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushed() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushedDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isProvisional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionCheckRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionUpdateRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void load(FetchConfiguration fetch) {\r\n-        }\r\n-\r\n-        public Object newFieldProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object newProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void removed(int field, Object removed, boolean key) {\r\n-        }\r\n-\r\n-        public Object setImplData(Object data, boolean cacheable) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object setImplData(int field, Object data) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setIntermediate(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setLock(Object lock) {\r\n-        }\r\n-\r\n-        public void setNextVersion(Object version) {\r\n-        }\r\n-\r\n-        public void setObjectId(Object oid) {\r\n-        }\r\n-\r\n-        public void setRemote(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setVersion(Object version) {\r\n-        }\r\n-\r\n-        public void store(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeBoolean(int field, boolean externalVal) {\r\n-        }\r\n-\r\n-        public void storeByte(int field, byte externalVal) {\r\n-        }\r\n-\r\n-        public void storeChar(int field, char externalVal) {\r\n-        }\r\n-\r\n-        public void storeDouble(int field, double externalVal) {\r\n-        }\r\n-\r\n-        public void storeField(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeFloat(int field, float externalVal) {\r\n-        }\r\n-\r\n-        public void storeInt(int field, int externalVal) {\r\n-        }\r\n-\r\n-        public void storeLong(int field, long externalVal) {\r\n-        }\r\n-\r\n-        public void storeObject(int field, Object externalVal) {\r\n-        }\r\n-\r\n-        public void storeShort(int field, short externalVal) {\r\n-        }\r\n-\r\n-        public void storeString(int field, String externalVal) {\r\n-        }\r\n-\r\n-        public void accessingField(int idx) {\r\n-        }\r\n-\r\n-        public void dirty(String field) {\r\n-        }\r\n-\r\n-        public Object fetchObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getGenericContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getPCPrimaryKey(Object oid, int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isDeleted() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDetached() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isNew() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isPersistent() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isTransactional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void providedBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur) {\r\n-        }\r\n-\r\n-        public void providedByteField(PersistenceCapable pc, int idx,\r\n-            byte cur) {\r\n-        }\r\n-\r\n-        public void providedCharField(PersistenceCapable pc, int idx, \r\n-            char cur) {\r\n-        }\r\n-\r\n-        public void providedDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur) {\r\n-        }\r\n-\r\n-        public void providedFloatField(PersistenceCapable pc, int idx,\r\n-            float cur) {\r\n-        }\r\n-\r\n-        public void providedIntField(PersistenceCapable pc, int idx, \r\n-            int cur) {\r\n-        }\r\n-\r\n-        public void providedLongField(PersistenceCapable pc, int idx, \r\n-            long cur) {\r\n-        }\r\n-\r\n-        public void providedObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur) {\r\n-        }\r\n-\r\n-        public void providedShortField(PersistenceCapable pc, int idx, \r\n-            short cur) {\r\n-        }\r\n-\r\n-        public void providedStringField(PersistenceCapable pc, int idx,\r\n-            String cur) {\r\n-        }\r\n-\r\n-        public void proxyDetachedDeserialized(int idx) {\r\n-        }\r\n-\r\n-        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte replaceByteField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char replaceCharField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double replaceDoubleField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float replaceFloatField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int replaceIntField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long replaceLongField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object replaceObjectField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short replaceShortField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public StateManager replaceStateManager(StateManager sm) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public String replaceStringField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean serializing() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void settingBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur, boolean next, int set) {\r\n-        }\r\n-\r\n-        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\r\n-            byte next, int set) {\r\n-        }\r\n-\r\n-        public void settingCharField(PersistenceCapable pc, int idx, char cur,\r\n-            char next, int set) {\r\n-        }\r\n-\r\n-        public void settingDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur, double next, int set) {\r\n-        }\r\n-\r\n-        public void settingFloatField(PersistenceCapable pc, int idx,\r\n-            float cur, float next, int set) {\r\n-        }\r\n-\r\n-        public void settingIntField(PersistenceCapable pc, int idx, int cur,\r\n-            int next, int set) {\r\n-        }\r\n-\r\n-        public void settingLongField(PersistenceCapable pc, int idx, long cur,\r\n-            long next, int set) {\r\n-        }\r\n-\r\n-        public void settingObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur, Object next, int set) {\r\n-        }\r\n-\r\n-        public void settingShortField(PersistenceCapable pc, int idx,\r\n-            short cur, short next, int set) {\r\n-        }\r\n-\r\n-        public void settingStringField(PersistenceCapable pc, int idx,\r\n-            String cur, String next, int set) {\r\n-        }\r\n-\r\n-        public boolean writeDetached(ObjectOutput out) throws IOException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void storeBooleanField(int fieldIndex, boolean value) {\r\n-        }\r\n-\r\n-        public void storeByteField(int fieldIndex, byte value) {\r\n-        }\r\n-\r\n-        public void storeCharField(int fieldIndex, char value) {\r\n-        }\r\n-\r\n-        public void storeDoubleField(int fieldIndex, double value) {\r\n-        }\r\n-\r\n-        public void storeFloatField(int fieldIndex, float value) {\r\n-        }\r\n-\r\n-        public void storeIntField(int fieldIndex, int value) {\r\n-        }\r\n-\r\n-        public void storeLongField(int fieldIndex, long value) {\r\n-        }\r\n-\r\n-        public void storeObjectField(int fieldIndex, Object value) {\r\n-        }\r\n-\r\n-        public void storeShortField(int fieldIndex, short value) {\r\n-        }\r\n-\r\n-        public void storeStringField(int fieldIndex, String value) {\r\n-        }\r\n-\r\n-        public boolean fetchBooleanField(int fieldIndex) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByteField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchCharField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDoubleField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float fetchFloatField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int fetchIntField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLongField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObjectField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShortField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchStringField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test connection.\r\n-     */\r\n-    class TestConnection implements Connection {\r\n-\r\n-        public void clearWarnings() throws SQLException {\r\n-        }\r\n-\r\n-        public void close() throws SQLException {\r\n-        }\r\n-\r\n-        public void commit() throws SQLException {\r\n-        }\r\n-\r\n-        public Statement createStatement() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean getAutoCommit() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String getCatalog() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getHoldability() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public DatabaseMetaData getMetaData() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getTransactionIsolation() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLWarning getWarnings() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isClosed() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isReadOnly() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String nativeSQL(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int autoGeneratedKeys) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int[] columnIndexes) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            String[] columnNames) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency,\r\n-            int resultSetHoldability) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback() throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n-        }\r\n-\r\n-        public void setCatalog(String catalog) throws SQLException {\r\n-        }\r\n-\r\n-        public void setHoldability(int holdability) throws SQLException {\r\n-        }\r\n-\r\n-        public void setReadOnly(boolean readOnly) throws SQLException {\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint(String name) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setTransactionIsolation(int level) throws SQLException {\r\n-        }\r\n-\r\n-        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test store manager.\r\n-     */\r\n-    class TestJDBCStore implements JDBCStore {\r\n-\r\n-        public Object find(Object oid, ValueMapping vm,\r\n-            JDBCFetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCConfiguration getConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Connection getConnection() {\r\n-            return new TestConnection();\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public DBDictionary getDBDictionary() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCFetchConfiguration getFetchConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCLockManager getLockManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLFactory getSQLFactory() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void loadSubclasses(ClassMapping mapping) {\r\n-\r\n-        }\r\n-\r\n-        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.io.IOException;\n+import java.io.ObjectOutput;\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Savepoint;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Strategy;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * <p>\n+ * Tests AbstractUpdateManager flush's method exception return behavior.\n+ * </p>\n+ * \n+ * @author Albert Lee\n+ */\n+public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\n+\n+    private TestUpdateManager updMgr;\n+\n+    public void setUp() {\n+        updMgr = new TestUpdateManager();\n+    }\n+\n+    /**\n+     * Tests exception collection returns from UpdateManager flush method is in\n+     * the order the original exceptions are thrown.\n+     */\n+    public void testAddRetrieve() {\n+        \n+        Collection states = new ArrayList<OpenJPAStateManager>();\n+        states.add(new TestOpenJPAStateManager());\n+\n+        Collection exceps = updMgr.flush(states, new TestJDBCStore());\n+\n+        assertEquals(3, exceps.size());\n+        \n+        Iterator<Exception> itr = exceps.iterator();\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.populateRowManager\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.flush\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.customInsert\");\n+    }\n+\n+    /*\n+     * Scaffolding test update manager.\n+     */\n+    class TestUpdateManager extends AbstractUpdateManager {\n+\n+        protected Collection flush(RowManager rowMgr,\n+            PreparedStatementManager psMgr, Collection exceps) {\n+\n+            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\n+\n+            return exceps;\n+        }\n+\n+        protected PreparedStatementManager newPreparedStatementManager(\n+            JDBCStore store, Connection conn) {\n+            return new PreparedStatementManagerImpl(store, conn);\n+        }\n+\n+        protected RowManager newRowManager() {\n+            return null;\n+        }\n+\n+        public boolean orderDirty() {\n+            return false;\n+        }\n+\n+        protected Collection populateRowManager(OpenJPAStateManager sm,\n+            RowManager rowMgr, JDBCStore store, Collection exceps,\n+            Collection customs) {\n+            \n+            exceps.add(new SQLException(\n+                \"TestUpdateManager.populateRowManager\"));\n+            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\n+                new Strategy() {\n+                    public void customDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void customInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                        throw new SQLException(\n+                            \"TestUpdateManager.customInsert\");\n+                    }\n+\n+                    public void customUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void delete(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+\n+                    public String getAlias() {\n+                        return null;\n+                    }\n+\n+                    public void initialize() {\n+                    }\n+\n+                    public void insert(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+\n+                    }\n+\n+                    public Boolean isCustomDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public void map(boolean adapt) {\n+                    }\n+\n+                    public void update(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+                }));\n+            return exceps;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test state manager.\n+     */\n+    class TestOpenJPAStateManager implements OpenJPAStateManager {\n+\n+        public boolean assignObjectId(boolean flush) {\n+            return false;\n+        }\n+\n+        public boolean beforeRefresh(boolean refreshAll) {\n+            return false;\n+        }\n+\n+        public void dirty(int field) {\n+        }\n+\n+        public Object fetch(int field) {\n+            return null;\n+        }\n+\n+        public boolean fetchBoolean(int field) {\n+            return false;\n+        }\n+\n+        public byte fetchByte(int field) {\n+            return 0;\n+        }\n+\n+        public char fetchChar(int field) {\n+            return 0;\n+        }\n+\n+        public double fetchDouble(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchField(int field, boolean transitions) {\n+            return null;\n+        }\n+\n+        public float fetchFloat(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchInitialField(int field) {\n+            return null;\n+        }\n+\n+        public int fetchInt(int field) {\n+            return 0;\n+        }\n+\n+        public long fetchLong(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchObject(int field) {\n+            return null;\n+        }\n+\n+        public short fetchShort(int field) {\n+            return 0;\n+        }\n+\n+        public String fetchString(int field) {\n+            return null;\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public BitSet getDirty() {\n+            return null;\n+        }\n+\n+        public BitSet getFlushed() {\n+            return null;\n+        }\n+\n+        public Object getId() {\n+            return null;\n+        }\n+\n+        public Object getImplData() {\n+            return null;\n+        }\n+\n+        public Object getImplData(int field) {\n+            return null;\n+        }\n+\n+        public Object getIntermediate(int field) {\n+            return null;\n+        }\n+\n+        public BitSet getLoaded() {\n+            return null;\n+        }\n+\n+        public Object getLock() {\n+            return null;\n+        }\n+\n+        public Object getManagedInstance() {\n+            return null;\n+        }\n+\n+        public ClassMetaData getMetaData() {\n+            return null;\n+        }\n+\n+        public Object getObjectId() {\n+            return null;\n+        }\n+\n+        public OpenJPAStateManager getOwner() {\n+            return null;\n+        }\n+\n+        public int getOwnerIndex() {\n+            return 0;\n+        }\n+\n+        public PCState getPCState() {\n+            return null;\n+        }\n+\n+        public PersistenceCapable getPersistenceCapable() {\n+            return null;\n+        }\n+\n+        public BitSet getUnloaded(FetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public Object getVersion() {\n+            return null;\n+        }\n+\n+        public void initialize(Class forType, PCState state) {\n+        }\n+\n+        public boolean isDefaultValue(int field) {\n+            return false;\n+        }\n+\n+        public boolean isEmbedded() {\n+            return false;\n+        }\n+\n+        public boolean isFlushed() {\n+            return false;\n+        }\n+\n+        public boolean isFlushedDirty() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable(int field) {\n+            return false;\n+        }\n+\n+        public boolean isProvisional() {\n+            return false;\n+        }\n+\n+        public boolean isVersionCheckRequired() {\n+            return false;\n+        }\n+\n+        public boolean isVersionUpdateRequired() {\n+            return false;\n+        }\n+\n+        public void load(FetchConfiguration fetch) {\n+        }\n+\n+        public Object newFieldProxy(int field) {\n+            return null;\n+        }\n+\n+        public Object newProxy(int field) {\n+            return null;\n+        }\n+\n+        public void removed(int field, Object removed, boolean key) {\n+        }\n+\n+        public Object setImplData(Object data, boolean cacheable) {\n+            return null;\n+        }\n+\n+        public Object setImplData(int field, Object data) {\n+            return null;\n+        }\n+\n+        public void setIntermediate(int field, Object value) {\n+        }\n+\n+        public void setLock(Object lock) {\n+        }\n+\n+        public void setNextVersion(Object version) {\n+        }\n+\n+        public void setObjectId(Object oid) {\n+        }\n+\n+        public void setRemote(int field, Object value) {\n+        }\n+\n+        public void setVersion(Object version) {\n+        }\n+\n+        public void store(int field, Object value) {\n+        }\n+\n+        public void storeBoolean(int field, boolean externalVal) {\n+        }\n+\n+        public void storeByte(int field, byte externalVal) {\n+        }\n+\n+        public void storeChar(int field, char externalVal) {\n+        }\n+\n+        public void storeDouble(int field, double externalVal) {\n+        }\n+\n+        public void storeField(int field, Object value) {\n+        }\n+\n+        public void storeFloat(int field, float externalVal) {\n+        }\n+\n+        public void storeInt(int field, int externalVal) {\n+        }\n+\n+        public void storeLong(int field, long externalVal) {\n+        }\n+\n+        public void storeObject(int field, Object externalVal) {\n+        }\n+\n+        public void storeShort(int field, short externalVal) {\n+        }\n+\n+        public void storeString(int field, String externalVal) {\n+        }\n+\n+        public void accessingField(int idx) {\n+        }\n+\n+        public void dirty(String field) {\n+        }\n+\n+        public Object fetchObjectId() {\n+            return null;\n+        }\n+\n+        public Object getGenericContext() {\n+            return null;\n+        }\n+\n+        public Object getPCPrimaryKey(Object oid, int field) {\n+            return null;\n+        }\n+\n+        public boolean isDeleted() {\n+            return false;\n+        }\n+\n+        public boolean isDetached() {\n+            return false;\n+        }\n+\n+        public boolean isDirty() {\n+            return false;\n+        }\n+\n+        public boolean isNew() {\n+            return false;\n+        }\n+\n+        public boolean isPersistent() {\n+            return false;\n+        }\n+\n+        public boolean isTransactional() {\n+            return false;\n+        }\n+\n+        public void providedBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur) {\n+        }\n+\n+        public void providedByteField(PersistenceCapable pc, int idx,\n+            byte cur) {\n+        }\n+\n+        public void providedCharField(PersistenceCapable pc, int idx, \n+            char cur) {\n+        }\n+\n+        public void providedDoubleField(PersistenceCapable pc, int idx,\n+            double cur) {\n+        }\n+\n+        public void providedFloatField(PersistenceCapable pc, int idx,\n+            float cur) {\n+        }\n+\n+        public void providedIntField(PersistenceCapable pc, int idx, \n+            int cur) {\n+        }\n+\n+        public void providedLongField(PersistenceCapable pc, int idx, \n+            long cur) {\n+        }\n+\n+        public void providedObjectField(PersistenceCapable pc, int idx,\n+            Object cur) {\n+        }\n+\n+        public void providedShortField(PersistenceCapable pc, int idx, \n+            short cur) {\n+        }\n+\n+        public void providedStringField(PersistenceCapable pc, int idx,\n+            String cur) {\n+        }\n+\n+        public void proxyDetachedDeserialized(int idx) {\n+        }\n+\n+        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\n+            return false;\n+        }\n+\n+        public byte replaceByteField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public char replaceCharField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public double replaceDoubleField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public float replaceFloatField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public int replaceIntField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public long replaceLongField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public Object replaceObjectField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public short replaceShortField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public StateManager replaceStateManager(StateManager sm) {\n+            return null;\n+        }\n+\n+        public String replaceStringField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public boolean serializing() {\n+            return false;\n+        }\n+\n+        public void settingBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur, boolean next, int set) {\n+        }\n+\n+        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\n+            byte next, int set) {\n+        }\n+\n+        public void settingCharField(PersistenceCapable pc, int idx, char cur,\n+            char next, int set) {\n+        }\n+\n+        public void settingDoubleField(PersistenceCapable pc, int idx,\n+            double cur, double next, int set) {\n+        }\n+\n+        public void settingFloatField(PersistenceCapable pc, int idx,\n+            float cur, float next, int set) {\n+        }\n+\n+        public void settingIntField(PersistenceCapable pc, int idx, int cur,\n+            int next, int set) {\n+        }\n+\n+        public void settingLongField(PersistenceCapable pc, int idx, long cur,\n+            long next, int set) {\n+        }\n+\n+        public void settingObjectField(PersistenceCapable pc, int idx,\n+            Object cur, Object next, int set) {\n+        }\n+\n+        public void settingShortField(PersistenceCapable pc, int idx,\n+            short cur, short next, int set) {\n+        }\n+\n+        public void settingStringField(PersistenceCapable pc, int idx,\n+            String cur, String next, int set) {\n+        }\n+\n+        public boolean writeDetached(ObjectOutput out) throws IOException {\n+            return false;\n+        }\n+\n+        public void storeBooleanField(int fieldIndex, boolean value) {\n+        }\n+\n+        public void storeByteField(int fieldIndex, byte value) {\n+        }\n+\n+        public void storeCharField(int fieldIndex, char value) {\n+        }\n+\n+        public void storeDoubleField(int fieldIndex, double value) {\n+        }\n+\n+        public void storeFloatField(int fieldIndex, float value) {\n+        }\n+\n+        public void storeIntField(int fieldIndex, int value) {\n+        }\n+\n+        public void storeLongField(int fieldIndex, long value) {\n+        }\n+\n+        public void storeObjectField(int fieldIndex, Object value) {\n+        }\n+\n+        public void storeShortField(int fieldIndex, short value) {\n+        }\n+\n+        public void storeStringField(int fieldIndex, String value) {\n+        }\n+\n+        public boolean fetchBooleanField(int fieldIndex) {\n+            return false;\n+        }\n+\n+        public byte fetchByteField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public char fetchCharField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public double fetchDoubleField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public float fetchFloatField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public int fetchIntField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public long fetchLongField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public Object fetchObjectField(int fieldIndex) {\n+            return null;\n+        }\n+\n+        public short fetchShortField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public String fetchStringField(int fieldIndex) {\n+            return null;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test connection.\n+     */\n+    class TestConnection implements Connection {\n+\n+        public void clearWarnings() throws SQLException {\n+        }\n+\n+        public void close() throws SQLException {\n+        }\n+\n+        public void commit() throws SQLException {\n+        }\n+\n+        public Statement createStatement() throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean getAutoCommit() throws SQLException {\n+            return false;\n+        }\n+\n+        public String getCatalog() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getHoldability() throws SQLException {\n+            return 0;\n+        }\n+\n+        public DatabaseMetaData getMetaData() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getTransactionIsolation() throws SQLException {\n+            return 0;\n+        }\n+\n+        public Map<String, Class<?>> getTypeMap() throws SQLException {\n+            return null;\n+        }\n+\n+        public SQLWarning getWarnings() throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean isClosed() throws SQLException {\n+            return false;\n+        }\n+\n+        public boolean isReadOnly() throws SQLException {\n+            return false;\n+        }\n+\n+        public String nativeSQL(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int autoGeneratedKeys) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int[] columnIndexes) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            String[] columnNames) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency,\n+            int resultSetHoldability) throws SQLException {\n+            return null;\n+        }\n+\n+        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void rollback() throws SQLException {\n+        }\n+\n+        public void rollback(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void setAutoCommit(boolean autoCommit) throws SQLException {\n+        }\n+\n+        public void setCatalog(String catalog) throws SQLException {\n+        }\n+\n+        public void setHoldability(int holdability) throws SQLException {\n+        }\n+\n+        public void setReadOnly(boolean readOnly) throws SQLException {\n+        }\n+\n+        public Savepoint setSavepoint() throws SQLException {\n+            return null;\n+        }\n+\n+        public Savepoint setSavepoint(String name) throws SQLException {\n+            return null;\n+        }\n+\n+        public void setTransactionIsolation(int level) throws SQLException {\n+        }\n+\n+        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test store manager.\n+     */\n+    class TestJDBCStore implements JDBCStore {\n+\n+        public Object find(Object oid, ValueMapping vm,\n+            JDBCFetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public JDBCConfiguration getConfiguration() {\n+            return null;\n+        }\n+\n+        public Connection getConnection() {\n+            return new TestConnection();\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public DBDictionary getDBDictionary() {\n+            return null;\n+        }\n+\n+        public JDBCFetchConfiguration getFetchConfiguration() {\n+            return null;\n+        }\n+\n+        public JDBCLockManager getLockManager() {\n+            return null;\n+        }\n+\n+        public SQLFactory getSQLFactory() {\n+            return null;\n+        }\n+\n+        public void loadSubclasses(ClassMapping mapping) {\n+\n+        }\n+\n+        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"8d1bf94ad53d916c4461e21230ecc51d9565ea79","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","status":"modified","additions":91,"deletions":91,"changes":182,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Responsible for marshalling and unmarshalling objects between memory and\r\n- * durable cache.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public interface CacheMarshaller {\r\n-\r\n-    /**\r\n-     * Load and return an instance of the type handled by this marshaller.\r\n-     * If the type implements {@link Configurable}, then this method will invoke\r\n-     * {@link Configurable#setConfiguration}, \r\n-     * {@link Configurable#startConfiguration()}, and\r\n-     * {@link Configurable#endConfiguration()} on the instance before returning.\r\n-     */\r\n-    public Object load();\r\n-\r\n-    /**\r\n-     * Store <code>o</code> into the cache.\r\n-     */\r\n-    public void store(Object o);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     * A value for this parameter is required.\r\n-     */\r\n-    public void setId(String id);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     */\r\n-    public String getId();\r\n-\r\n-    /**\r\n-     * The {@link ValidationPolicy} that this marshaller should use.\r\n-     * A value for this parameter is required. The class will be instantiated\r\n-     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\r\n-     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\r\n-     * be taken through the appropriate lifecycle.\r\n-     */\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException;\r\n-\r\n-    /**\r\n-     * Validation policies are responsible for computing whether or not a\r\n-     * cached data structure is valid for the current context.\r\n-     * <p/>\r\n-     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\r\n-     * return an object equivalent to <code>o</code> in the expected case.\r\n-     * <p/>\r\n-     * Implementations of this class will often also implement\r\n-     * {@link Configurable} in order to receive the current\r\n-     * {@link Configuration}.\r\n-     */\r\n-    public interface ValidationPolicy {\r\n-        /**\r\n-         * Returns an object that this policy considers to be valid, based\r\n-         * on <code>o</code>. If <code>o</code> is not valid, this method\r\n-         * will return <code>null</code>.\r\n-         */\r\n-        public Object getValidData(Object o);\r\n-\r\n-        /**\r\n-         * Return an object that the {@link CacheMarshaller} should store.\r\n-         */\r\n-        public Object getCacheableData(Object o);\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Responsible for marshalling and unmarshalling objects between memory and\n+ * durable cache.\n+ *\n+ * @since 1.1.0\n+ */\n+public interface CacheMarshaller {\n+\n+    /**\n+     * Load and return an instance of the type handled by this marshaller.\n+     * If the type implements {@link Configurable}, then this method will invoke\n+     * {@link Configurable#setConfiguration}, \n+     * {@link Configurable#startConfiguration()}, and\n+     * {@link Configurable#endConfiguration()} on the instance before returning.\n+     */\n+    public Object load();\n+\n+    /**\n+     * Store <code>o</code> into the cache.\n+     */\n+    public void store(Object o);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     * A value for this parameter is required.\n+     */\n+    public void setId(String id);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     */\n+    public String getId();\n+\n+    /**\n+     * The {@link ValidationPolicy} that this marshaller should use.\n+     * A value for this parameter is required. The class will be instantiated\n+     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\n+     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\n+     * be taken through the appropriate lifecycle.\n+     */\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException;\n+\n+    /**\n+     * Validation policies are responsible for computing whether or not a\n+     * cached data structure is valid for the current context.\n+     * <p/>\n+     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\n+     * return an object equivalent to <code>o</code> in the expected case.\n+     * <p/>\n+     * Implementations of this class will often also implement\n+     * {@link Configurable} in order to receive the current\n+     * {@link Configuration}.\n+     */\n+    public interface ValidationPolicy {\n+        /**\n+         * Returns an object that this policy considers to be valid, based\n+         * on <code>o</code>. If <code>o</code> is not valid, this method\n+         * will return <code>null</code>.\n+         */\n+        public Object getValidData(Object o);\n+\n+        /**\n+         * Return an object that the {@link CacheMarshaller} should store.\n+         */\n+        public Object getCacheableData(Object o);\n+    }\n }\n\\ No newline at end of file"},{"sha":"40684bb0fb541b822fec70ab67d85ca4e22a14f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,253 +1,253 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.io.BufferedInputStream;\r\n-import java.io.BufferedOutputStream;\r\n-import java.io.File;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.OutputStream;\r\n-import java.net.URL;\r\n-import java.util.Enumeration;\r\n-import java.util.List;\r\n-import java.util.ArrayList;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Default {@link CacheMarshaller} implementation that writes data\r\n- * to a specified file and reads data from a specified file or URL.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallerImpl\r\n-    implements CacheMarshaller, Configurable {\r\n-\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallerImpl.class);\r\n-\r\n-    private String _id;\r\n-    private ValidationPolicy _validationPolicy;\r\n-    private OpenJPAConfiguration _conf;\r\n-    private Log _log;\r\n-    private File _outputFile;\r\n-    private URL _inputURL;\r\n-\r\n-    // temporary storage for resource location specification\r\n-    private String _inputResourceLocation;\r\n-    \r\n-    private boolean _consumeErrors = true;\r\n-\r\n-    public Object load() {\r\n-        if (_inputURL == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\r\n-            return null;\r\n-        }\r\n-\r\n-        Object o = null;\r\n-        ObjectInputStream in = null;\r\n-        try {\r\n-            in = new ObjectInputStream(new BufferedInputStream(\r\n-                _inputURL.openStream()));\r\n-\r\n-            o = in.readObject();\r\n-            o = _validationPolicy.getValidData(o);\r\n-\r\n-            if (o != null && o.getClass().isArray()) {\r\n-                Object[] array = (Object[]) o;\r\n-                for (int i = 0; i < array.length; i++)\r\n-                    configure(array[i]);\r\n-            } else {\r\n-                configure(o);\r\n-            }\r\n-\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-loaded\",\r\n-                    o == null ? null : o.getClass().getName(), _inputURL));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\r\n-                        _inputURL), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-load-exception-fatal\",\r\n-                        _inputURL),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (in != null)\r\n-                try { in.close(); } catch (IOException e) { }\r\n-        }\r\n-\r\n-        return o;\r\n-    }\r\n-\r\n-    private void configure(Object o) {\r\n-        if (o instanceof Configurable) {\r\n-            ((Configurable) o).setConfiguration(_conf);\r\n-            ((Configurable) o).startConfiguration();\r\n-            ((Configurable) o).endConfiguration();\r\n-        }\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-        if (_outputFile == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\r\n-            return;\r\n-        }\r\n-        OutputStream out = null;\r\n-        try {\r\n-            out = new FileOutputStream(_outputFile);\r\n-            ObjectOutputStream oos =\r\n-                new ObjectOutputStream(new BufferedOutputStream(out));\r\n-            Object toStore = _validationPolicy.getCacheableData(o);\r\n-            oos.writeObject(toStore);\r\n-            oos.flush();\r\n-            out.flush();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-stored\",\r\n-                    o.getClass().getName(), _outputFile));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (out != null) {\r\n-                try { out.close(); } catch (IOException ioe) { }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void setOutputFile(File file) {\r\n-        _outputFile = file;\r\n-    }\r\n-\r\n-    public File getOutputFile() {\r\n-        return _outputFile;\r\n-    }\r\n-\r\n-    public void setInputURL(URL url) {\r\n-        _inputURL = url;\r\n-    }\r\n-\r\n-    public void setInputResource(String resource) {\r\n-        _inputResourceLocation = resource;\r\n-    }\r\n-\r\n-    public void setConsumeSerializationErrors(boolean consume) {\r\n-        _consumeErrors = consume;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return _id;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        _id = id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException {\r\n-        String name = Configurations.getClassName(policy);\r\n-        String props = Configurations.getProperties(policy);\r\n-        _validationPolicy = (ValidationPolicy)\r\n-            Configurations.newInstance(name, _conf, props, null);\r\n-    }\r\n-\r\n-    public ValidationPolicy getValidationPolicy() {\r\n-        return _validationPolicy;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        _conf = (OpenJPAConfiguration) conf;\r\n-        _log = conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_inputResourceLocation != null && _inputURL != null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\r\n-                    .getMessage());\r\n-        if (_inputResourceLocation != null)\r\n-            setInputUrlFromResourceLocation();\r\n-\r\n-        if (_validationPolicy == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-validation-policy\",\r\n-                    getClass().getName()).getMessage());\r\n-        if (_id == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-id\",\r\n-                    getClass().getName()).getMessage());\r\n-    }\r\n-\r\n-    private void setInputUrlFromResourceLocation() {\r\n-        try {\r\n-            ClassLoader cl = _conf.getClassResolverInstance()\r\n-                .getClassLoader(getClass(), null);\r\n-            List list = new ArrayList();\r\n-            for (Enumeration e = cl.getResources(_inputResourceLocation);\r\n-                e.hasMoreElements(); )\r\n-                list.add(e);\r\n-\r\n-            if (list.size() > 1) {\r\n-                if (_consumeErrors) {\r\n-                    if (_log.isWarnEnabled())\r\n-                        _log.warn(_loc.get(\r\n-                            \"cache-marshaller-multiple-resources-warn\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                } else {\r\n-                    throw new IllegalStateException(\r\n-                        _loc.get(\"cache-marshaller-multiple-resources\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                }\r\n-            }\r\n-\r\n-            if (!list.isEmpty())\r\n-                _inputURL = (URL) list.get(0);\r\n-        } catch (IOException ioe) {\r\n-            IllegalStateException ise = new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-bad-url\", getId(),\r\n-                    _inputResourceLocation).getMessage());\r\n-            ise.initCause(ioe);\r\n-            throw ise;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Default {@link CacheMarshaller} implementation that writes data\n+ * to a specified file and reads data from a specified file or URL.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallerImpl\n+    implements CacheMarshaller, Configurable {\n+\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallerImpl.class);\n+\n+    private String _id;\n+    private ValidationPolicy _validationPolicy;\n+    private OpenJPAConfiguration _conf;\n+    private Log _log;\n+    private File _outputFile;\n+    private URL _inputURL;\n+\n+    // temporary storage for resource location specification\n+    private String _inputResourceLocation;\n+    \n+    private boolean _consumeErrors = true;\n+\n+    public Object load() {\n+        if (_inputURL == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\n+            return null;\n+        }\n+\n+        Object o = null;\n+        ObjectInputStream in = null;\n+        try {\n+            in = new ObjectInputStream(new BufferedInputStream(\n+                _inputURL.openStream()));\n+\n+            o = in.readObject();\n+            o = _validationPolicy.getValidData(o);\n+\n+            if (o != null && o.getClass().isArray()) {\n+                Object[] array = (Object[]) o;\n+                for (int i = 0; i < array.length; i++)\n+                    configure(array[i]);\n+            } else {\n+                configure(o);\n+            }\n+\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-loaded\",\n+                    o == null ? null : o.getClass().getName(), _inputURL));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\n+                        _inputURL), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-load-exception-fatal\",\n+                        _inputURL),\n+                    e);\n+            }\n+        } finally {\n+            if (in != null)\n+                try { in.close(); } catch (IOException e) { }\n+        }\n+\n+        return o;\n+    }\n+\n+    private void configure(Object o) {\n+        if (o instanceof Configurable) {\n+            ((Configurable) o).setConfiguration(_conf);\n+            ((Configurable) o).startConfiguration();\n+            ((Configurable) o).endConfiguration();\n+        }\n+    }\n+\n+    public void store(Object o) {\n+        if (_outputFile == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\n+            return;\n+        }\n+        OutputStream out = null;\n+        try {\n+            out = new FileOutputStream(_outputFile);\n+            ObjectOutputStream oos =\n+                new ObjectOutputStream(new BufferedOutputStream(out));\n+            Object toStore = _validationPolicy.getCacheableData(o);\n+            oos.writeObject(toStore);\n+            oos.flush();\n+            out.flush();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-stored\",\n+                    o.getClass().getName(), _outputFile));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile),\n+                    e);\n+            }\n+        } finally {\n+            if (out != null) {\n+                try { out.close(); } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    public void setOutputFile(File file) {\n+        _outputFile = file;\n+    }\n+\n+    public File getOutputFile() {\n+        return _outputFile;\n+    }\n+\n+    public void setInputURL(URL url) {\n+        _inputURL = url;\n+    }\n+\n+    public void setInputResource(String resource) {\n+        _inputResourceLocation = resource;\n+    }\n+\n+    public void setConsumeSerializationErrors(boolean consume) {\n+        _consumeErrors = consume;\n+    }\n+\n+    public String getId() {\n+        return _id;\n+    }\n+\n+    public void setId(String id) {\n+        _id = id;\n+    }\n+\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException {\n+        String name = Configurations.getClassName(policy);\n+        String props = Configurations.getProperties(policy);\n+        _validationPolicy = (ValidationPolicy)\n+            Configurations.newInstance(name, _conf, props, null);\n+    }\n+\n+    public ValidationPolicy getValidationPolicy() {\n+        return _validationPolicy;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (OpenJPAConfiguration) conf;\n+        _log = conf.getConfigurationLog();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_inputResourceLocation != null && _inputURL != null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\n+                    .getMessage());\n+        if (_inputResourceLocation != null)\n+            setInputUrlFromResourceLocation();\n+\n+        if (_validationPolicy == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-validation-policy\",\n+                    getClass().getName()).getMessage());\n+        if (_id == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-id\",\n+                    getClass().getName()).getMessage());\n+    }\n+\n+    private void setInputUrlFromResourceLocation() {\n+        try {\n+            ClassLoader cl = _conf.getClassResolverInstance()\n+                .getClassLoader(getClass(), null);\n+            List list = new ArrayList();\n+            for (Enumeration e = cl.getResources(_inputResourceLocation);\n+                e.hasMoreElements(); )\n+                list.add(e);\n+\n+            if (list.size() > 1) {\n+                if (_consumeErrors) {\n+                    if (_log.isWarnEnabled())\n+                        _log.warn(_loc.get(\n+                            \"cache-marshaller-multiple-resources-warn\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                } else {\n+                    throw new IllegalStateException(\n+                        _loc.get(\"cache-marshaller-multiple-resources\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                }\n+            }\n+\n+            if (!list.isEmpty())\n+                _inputURL = (URL) list.get(0);\n+        } catch (IOException ioe) {\n+            IllegalStateException ise = new IllegalStateException(\n+                _loc.get(\"cache-marshaller-bad-url\", getId(),\n+                    _inputResourceLocation).getMessage());\n+            ise.initCause(ioe);\n+            throw ise;\n+        }\n+    }\n+}"},{"sha":"e0efef07e32d41743f552706ff487e660d72aac0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","status":"modified","additions":121,"deletions":121,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,121 +1,121 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.conf.PluginListValue;\r\n-import org.apache.openjpa.conf.NoOpCacheMarshaller;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * A configuration value for handling and accessing cache marshallers.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallersValue\r\n-    extends PluginListValue {\r\n-\r\n-    private static final String KEY = \"CacheMarshallers\";\r\n-    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\r\n-        = new NoOpCacheMarshaller();\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallersValue.class);\r\n-\r\n-    private Configuration _conf;\r\n-    private Map _marshallers;\r\n-    private boolean _initialized;\r\n-\r\n-    public CacheMarshallersValue(Configuration conf) {\r\n-        super(KEY);\r\n-        _conf = conf;\r\n-        setAlias(\"default\", CacheMarshallerImpl.class.getName());\r\n-        setAlias(\"none\", null);\r\n-        setDefault(\"none\");\r\n-        setString(\"none\");\r\n-        setScope(getClass());\r\n-    }\r\n-\r\n-    public Object instantiate(Class elemType, Configuration conf,\r\n-        boolean fatal) {\r\n-        CacheMarshaller[] ms = (CacheMarshaller[])\r\n-            super.instantiate(elemType, conf, fatal);\r\n-        if (ms != null) {\r\n-            _marshallers = new HashMap();\r\n-            for (int i = 0; i < ms.length; i++) {\r\n-                String mid = ms[i].getId();\r\n-                if (mid != null)\r\n-                    _marshallers.put(mid, ms[i]);\r\n-            }\r\n-        } else {\r\n-            _marshallers = null;\r\n-        }\r\n-        return ms;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public CacheMarshaller getMarshallerById(String id) {\r\n-        initialize();\r\n-\r\n-        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\r\n-        if (cm == null) {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\r\n-            return NO_OP_CACHE_MARSHALLER;\r\n-        } else {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\r\n-                    cm.getClass().getName()));\r\n-            return cm;\r\n-        }\r\n-    }\r\n-\r\n-    private Log getLog() {\r\n-        return _conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public static CacheMarshaller getMarshallerById(Configuration c, String id){\r\n-        CacheMarshallersValue v =\r\n-            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\r\n-        return v.getMarshallerById(id);\r\n-    }\r\n-\r\n-    public Map getInstancesAsMap() {\r\n-        return _marshallers;\r\n-    }\r\n-\r\n-    protected synchronized void initialize() {\r\n-        if (!_initialized) {\r\n-            instantiate(CacheMarshaller.class, _conf);\r\n-            _initialized = true;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.conf.PluginListValue;\n+import org.apache.openjpa.conf.NoOpCacheMarshaller;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * A configuration value for handling and accessing cache marshallers.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallersValue\n+    extends PluginListValue {\n+\n+    private static final String KEY = \"CacheMarshallers\";\n+    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\n+        = new NoOpCacheMarshaller();\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallersValue.class);\n+\n+    private Configuration _conf;\n+    private Map _marshallers;\n+    private boolean _initialized;\n+\n+    public CacheMarshallersValue(Configuration conf) {\n+        super(KEY);\n+        _conf = conf;\n+        setAlias(\"default\", CacheMarshallerImpl.class.getName());\n+        setAlias(\"none\", null);\n+        setDefault(\"none\");\n+        setString(\"none\");\n+        setScope(getClass());\n+    }\n+\n+    public Object instantiate(Class elemType, Configuration conf,\n+        boolean fatal) {\n+        CacheMarshaller[] ms = (CacheMarshaller[])\n+            super.instantiate(elemType, conf, fatal);\n+        if (ms != null) {\n+            _marshallers = new HashMap();\n+            for (int i = 0; i < ms.length; i++) {\n+                String mid = ms[i].getId();\n+                if (mid != null)\n+                    _marshallers.put(mid, ms[i]);\n+            }\n+        } else {\n+            _marshallers = null;\n+        }\n+        return ms;\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public CacheMarshaller getMarshallerById(String id) {\n+        initialize();\n+\n+        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\n+        if (cm == null) {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\n+            return NO_OP_CACHE_MARSHALLER;\n+        } else {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\n+                    cm.getClass().getName()));\n+            return cm;\n+        }\n+    }\n+\n+    private Log getLog() {\n+        return _conf.getConfigurationLog();\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public static CacheMarshaller getMarshallerById(Configuration c, String id){\n+        CacheMarshallersValue v =\n+            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\n+        return v.getMarshallerById(id);\n+    }\n+\n+    public Map getInstancesAsMap() {\n+        return _marshallers;\n+    }\n+\n+    protected synchronized void initialize() {\n+        if (!_initialized) {\n+            instantiate(CacheMarshaller.class, _conf);\n+            _initialized = true;\n+        }\n+    }\n+}"},{"sha":"854f1a64843d8521f52481bd35c43975ca4ce3db","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,202 +1,202 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.Bootstrap;\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.meta.QueryMetaData;\r\n-import org.apache.openjpa.meta.SequenceMetaData;\r\n-\r\n-/**\r\n- * Performs maintenance tasks on the metadata caches accessible via the\r\n- * {@link CacheMarshaller} architecture.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataCacheMaintenance {\r\n-\r\n-    private final BrokerFactory factory;\r\n-    private final OpenJPAConfiguration conf;\r\n-    private final boolean devpath;\r\n-    private Log log;\r\n-\r\n-    public static void main(String[] args) {\r\n-        Options opts = new Options();\r\n-        args = opts.setFromCmdLine(args);\r\n-        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\r\n-            true);\r\n-\r\n-        ConfigurationProvider cp = new MapConfigurationProvider(opts);\r\n-        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\r\n-        try {\r\n-            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\r\n-                factory, devpath);\r\n-\r\n-            if (args.length != 1) {\r\n-                usage();\r\n-                return;\r\n-            }\r\n-\r\n-            if (\"store\".equals(args[0]))\r\n-                maint.store();\r\n-            else if (\"dump\".equals(args[0]))\r\n-                maint.dump();\r\n-            else\r\n-                usage();\r\n-        } finally {\r\n-            factory.close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated logging is routed to the logging system now.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\r\n-        boolean verbose) {\r\n-        this(factory, devpath);\r\n-    }\r\n-\r\n-    /**\r\n-     * @param factory The {@link BrokerFactory} for which cached metadata\r\n-     * should be built.\r\n-     * @param devpath Whether or not to scan the development environment paths\r\n-     * to find persistent types to store.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\r\n-        this.factory = factory;\r\n-        this.conf = factory.getConfiguration();\r\n-        this.devpath = devpath;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\r\n-    }\r\n-\r\n-    public void setLog(Log log) {\r\n-        this.log = log;\r\n-    }\r\n-\r\n-    private static int usage() {\r\n-        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\r\n-            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\r\n-        return -1;\r\n-    }\r\n-\r\n-    /**\r\n-     * The metadata repository for the factory that this instance was\r\n-     * constructed with will be serialized, along with any query\r\n-     * compilations etc. that have been created for the factory.\r\n-     */\r\n-    public void store() {\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        repos.setSourceMode(MetaDataRepository.MODE_ALL);\r\n-        Collection types = repos.loadPersistentTypes(devpath, null);\r\n-        for (Iterator iter = types.iterator(); iter.hasNext(); )\r\n-            repos.getMetaData((Class) iter.next(), null, true);\r\n-\r\n-        loadQueries();\r\n-\r\n-        log.info(\"The following data will be stored: \");\r\n-        log(repos, conf.getQueryCompilationCacheInstance());\r\n-\r\n-        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .store(new Object[] {\r\n-                repos, conf.getQueryCompilationCacheInstance()\r\n-            });\r\n-    }\r\n-\r\n-    private void loadQueries() {\r\n-        Broker broker = factory.newBroker();\r\n-        try {\r\n-            QueryMetaData[] qmds =\r\n-                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                loadQuery(broker, qmds[i]);\r\n-        } finally {\r\n-            broker.close();\r\n-        }\r\n-    }\r\n-\r\n-    private void loadQuery(Broker broker, QueryMetaData qmd) {\r\n-        try {\r\n-            Query q = broker.newQuery(qmd.getLanguage(), null);\r\n-            qmd.setInto(q);\r\n-            q.compile();\r\n-        } catch (Exception e) {\r\n-            if (log.isTraceEnabled()) {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage(), e);\r\n-            } else {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void dump() {\r\n-        Object[] os = (Object[])\r\n-            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .load();\r\n-        if (os == null) {\r\n-            log.info(\"No cached data was found\");\r\n-            return;\r\n-        }\r\n-        MetaDataRepository repos = (MetaDataRepository) os[0];\r\n-        Map qcc = (Map) os[1];\r\n-\r\n-        log.info(\"The following data was found: \");\r\n-        log(repos, qcc);\r\n-    }\r\n-\r\n-    private void log(MetaDataRepository repos, Map qcc) {\r\n-        ClassMetaData[] metas = repos.getMetaDatas();\r\n-        log.info(\"  Types: \" + metas.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < metas.length; i++)\r\n-                log.trace(\"    \" + metas[i].getDescribedType().getName());\r\n-\r\n-        QueryMetaData[] qmds = repos.getQueryMetaDatas();\r\n-        log.info(\"  Queries: \" + qmds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                log.trace(\"    \" + qmds[i].getName() + \": \"\r\n-                    + qmds[i].getQueryString());\r\n-\r\n-        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\r\n-        log.info(\"  Sequences: \" + smds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < smds.length; i++)\r\n-                log.trace(\"    \" + smds[i].getName());\r\n-\r\n-        log.info(\"  Compiled queries: \"\r\n-            + (qcc == null ? \"0\" : \"\" + qcc.size()));\r\n-        if (log.isTraceEnabled() && qcc != null)\r\n-            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\r\n-                log.trace(\"    \" + iter.next());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.QueryMetaData;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+\n+/**\n+ * Performs maintenance tasks on the metadata caches accessible via the\n+ * {@link CacheMarshaller} architecture.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataCacheMaintenance {\n+\n+    private final BrokerFactory factory;\n+    private final OpenJPAConfiguration conf;\n+    private final boolean devpath;\n+    private Log log;\n+\n+    public static void main(String[] args) {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\n+            true);\n+\n+        ConfigurationProvider cp = new MapConfigurationProvider(opts);\n+        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\n+        try {\n+            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\n+                factory, devpath);\n+\n+            if (args.length != 1) {\n+                usage();\n+                return;\n+            }\n+\n+            if (\"store\".equals(args[0]))\n+                maint.store();\n+            else if (\"dump\".equals(args[0]))\n+                maint.dump();\n+            else\n+                usage();\n+        } finally {\n+            factory.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated logging is routed to the logging system now.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\n+        boolean verbose) {\n+        this(factory, devpath);\n+    }\n+\n+    /**\n+     * @param factory The {@link BrokerFactory} for which cached metadata\n+     * should be built.\n+     * @param devpath Whether or not to scan the development environment paths\n+     * to find persistent types to store.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\n+        this.factory = factory;\n+        this.conf = factory.getConfiguration();\n+        this.devpath = devpath;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n+    }\n+\n+    public void setLog(Log log) {\n+        this.log = log;\n+    }\n+\n+    private static int usage() {\n+        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\n+            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\n+        return -1;\n+    }\n+\n+    /**\n+     * The metadata repository for the factory that this instance was\n+     * constructed with will be serialized, along with any query\n+     * compilations etc. that have been created for the factory.\n+     */\n+    public void store() {\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        repos.setSourceMode(MetaDataRepository.MODE_ALL);\n+        Collection types = repos.loadPersistentTypes(devpath, null);\n+        for (Iterator iter = types.iterator(); iter.hasNext(); )\n+            repos.getMetaData((Class) iter.next(), null, true);\n+\n+        loadQueries();\n+\n+        log.info(\"The following data will be stored: \");\n+        log(repos, conf.getQueryCompilationCacheInstance());\n+\n+        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .store(new Object[] {\n+                repos, conf.getQueryCompilationCacheInstance()\n+            });\n+    }\n+\n+    private void loadQueries() {\n+        Broker broker = factory.newBroker();\n+        try {\n+            QueryMetaData[] qmds =\n+                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\n+            for (int i = 0; i < qmds.length; i++)\n+                loadQuery(broker, qmds[i]);\n+        } finally {\n+            broker.close();\n+        }\n+    }\n+\n+    private void loadQuery(Broker broker, QueryMetaData qmd) {\n+        try {\n+            Query q = broker.newQuery(qmd.getLanguage(), null);\n+            qmd.setInto(q);\n+            q.compile();\n+        } catch (Exception e) {\n+            if (log.isTraceEnabled()) {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage(), e);\n+            } else {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void dump() {\n+        Object[] os = (Object[])\n+            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .load();\n+        if (os == null) {\n+            log.info(\"No cached data was found\");\n+            return;\n+        }\n+        MetaDataRepository repos = (MetaDataRepository) os[0];\n+        Map qcc = (Map) os[1];\n+\n+        log.info(\"The following data was found: \");\n+        log(repos, qcc);\n+    }\n+\n+    private void log(MetaDataRepository repos, Map qcc) {\n+        ClassMetaData[] metas = repos.getMetaDatas();\n+        log.info(\"  Types: \" + metas.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < metas.length; i++)\n+                log.trace(\"    \" + metas[i].getDescribedType().getName());\n+\n+        QueryMetaData[] qmds = repos.getQueryMetaDatas();\n+        log.info(\"  Queries: \" + qmds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < qmds.length; i++)\n+                log.trace(\"    \" + qmds[i].getName() + \": \"\n+                    + qmds[i].getQueryString());\n+\n+        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\n+        log.info(\"  Sequences: \" + smds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < smds.length; i++)\n+                log.trace(\"    \" + smds[i].getName());\n+\n+        log.info(\"  Compiled queries: \"\n+            + (qcc == null ? \"0\" : \"\" + qcc.size()));\n+        if (log.isTraceEnabled() && qcc != null)\n+            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\n+                log.trace(\"    \" + iter.next());\n+    }\n+}"},{"sha":"c027a5271c0d1b73161c75f08a698830accbc227","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.conf.CacheMarshallersValue;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-\r\n-/**\r\n- * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\r\n- * to cache the metadata repository between executions.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataRepositoryValue\r\n-    extends PluginValue {\r\n-\r\n-    private static final String KEY = \"MetaDataRepository\";\r\n-\r\n-    public MetaDataRepositoryValue() {\r\n-        super(KEY, false);\r\n-        String[] aliases = new String[] {\r\n-            \"default\",\r\n-            MetaDataRepository.class.getName()\r\n-        };\r\n-        setAliases(aliases);\r\n-        setDefault(aliases[0]);\r\n-        setString(aliases[0]);\r\n-    }\r\n-\r\n-    public Object instantiate(Class type, Configuration c, boolean fatal) {\r\n-        MetaDataRepository repos = null;\r\n-        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\r\n-\r\n-        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\r\n-            conf, MetaDataCacheMaintenance.class.getName())\r\n-            .load();\r\n-        if (os != null) {\r\n-            repos = (MetaDataRepository) os[0];\r\n-            if (os[1] != null)\r\n-                // It's a bit odd that we do this in MetaDataRepositoryValue.\r\n-                // We need to serialize all the various bits of configuration\r\n-                // together; maybe we can move the caching logic somewhere\r\n-                // else?\r\n-                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\r\n-        }\r\n-\r\n-        if (repos == null)\r\n-            return super.instantiate(type, c, fatal);\r\n-        else\r\n-            return repos;\r\n-    }\r\n-\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.conf.CacheMarshallersValue;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\n+ * to cache the metadata repository between executions.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataRepositoryValue\n+    extends PluginValue {\n+\n+    private static final String KEY = \"MetaDataRepository\";\n+\n+    public MetaDataRepositoryValue() {\n+        super(KEY, false);\n+        String[] aliases = new String[] {\n+            \"default\",\n+            MetaDataRepository.class.getName()\n+        };\n+        setAliases(aliases);\n+        setDefault(aliases[0]);\n+        setString(aliases[0]);\n+    }\n+\n+    public Object instantiate(Class type, Configuration c, boolean fatal) {\n+        MetaDataRepository repos = null;\n+        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\n+\n+        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\n+            conf, MetaDataCacheMaintenance.class.getName())\n+            .load();\n+        if (os != null) {\n+            repos = (MetaDataRepository) os[0];\n+            if (os[1] != null)\n+                // It's a bit odd that we do this in MetaDataRepositoryValue.\n+                // We need to serialize all the various bits of configuration\n+                // together; maybe we can move the caching logic somewhere\n+                // else?\n+                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\n+        }\n+\n+        if (repos == null)\n+            return super.instantiate(type, c, fatal);\n+        else\n+            return repos;\n+    }\n+\n+\n+}"},{"sha":"3413add2a563d0da4016caef5419766c0a5bd10f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,48 +1,48 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-/**\r\n- * Implementation of {@link CacheMarshaller} that does nothing.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class NoOpCacheMarshaller\r\n-    implements CacheMarshaller {\r\n-\r\n-    private String id;\r\n-\r\n-    public Object load() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy) {\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+/**\n+ * Implementation of {@link CacheMarshaller} that does nothing.\n+ *\n+ * @since 1.1.0\n+ */\n+public class NoOpCacheMarshaller\n+    implements CacheMarshaller {\n+\n+    private String id;\n+\n+    public Object load() {\n+        return null;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setValidationPolicy(String policy) {\n+    }\n+\n+    public void store(Object o) {\n+    }\n+}"},{"sha":"a8e5bb124bc013c11c3e4a2172f39148dd737a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Adds datastore based extension to ProductDerivation.  \r\n- *\r\n- * @since 0.4.1\r\n- * @author Pinaki Poddar\r\n- */\r\n-public interface OpenJPAProductDerivation extends ProductDerivation {\r\n-\r\n-    public static final int TYPE_SPEC = 0;\r\n-    public static final int TYPE_STORE = 200;\r\n-    public static final int TYPE_SPEC_STORE = 300;\r\n-    public static final int TYPE_PRODUCT_STORE = 400;\r\n-\r\n-    /**\r\n-     * Load default alias options into the given map.  Each entry maps an\r\n-     * alias to a broker factory class name.  Replace anything previously \r\n-     * under the desired keys.\r\n-     */\r\n-    public void putBrokerFactoryAliases(Map aliases);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+import java.util.Map;\n+\n+/**\n+ * Adds datastore based extension to ProductDerivation.  \n+ *\n+ * @since 0.4.1\n+ * @author Pinaki Poddar\n+ */\n+public interface OpenJPAProductDerivation extends ProductDerivation {\n+\n+    public static final int TYPE_SPEC = 0;\n+    public static final int TYPE_STORE = 200;\n+    public static final int TYPE_SPEC_STORE = 300;\n+    public static final int TYPE_PRODUCT_STORE = 400;\n+\n+    /**\n+     * Load default alias options into the given map.  Each entry maps an\n+     * alias to a broker factory class name.  Replace anything previously \n+     * under the desired keys.\n+     */\n+    public void putBrokerFactoryAliases(Map aliases);\n+}"},{"sha":"df3cd84bdb3baa1fd3f379059a7954cd65cc11aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,66 +1,66 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Compute validity based on whether or not the cached data is from the same\r\n- * version of Kodo as the current install. This also checks OpenJPA version\r\n- * information in case the OpenJPA jars were independently updated.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class OpenJPAVersionAndConfigurationTypeValidationPolicy\r\n-    implements ValidationPolicy, Configurable {\r\n-\r\n-    private String confClassName;\r\n-\r\n-    public Object getCacheableData(Object o) {\r\n-        return new Object[] {\r\n-            OpenJPAVersion.VERSION_ID,\r\n-            confClassName,\r\n-            o,\r\n-        };\r\n-    }\r\n-\r\n-    public Object getValidData(Object o) {\r\n-        Object[] array = (Object[]) o;\r\n-        if (array.length != 3)\r\n-            return null;\r\n-\r\n-        if (OpenJPAVersion.VERSION_ID.equals(array[0])\r\n-            && confClassName.equals(array[1]))\r\n-            return array[2];\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        confClassName = conf.getClass().getName();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Compute validity based on whether or not the cached data is from the same\n+ * version of Kodo as the current install. This also checks OpenJPA version\n+ * information in case the OpenJPA jars were independently updated.\n+ *\n+ * @since 1.1.0\n+ */\n+public class OpenJPAVersionAndConfigurationTypeValidationPolicy\n+    implements ValidationPolicy, Configurable {\n+\n+    private String confClassName;\n+\n+    public Object getCacheableData(Object o) {\n+        return new Object[] {\n+            OpenJPAVersion.VERSION_ID,\n+            confClassName,\n+            o,\n+        };\n+    }\n+\n+    public Object getValidData(Object o) {\n+        Object[] array = (Object[]) o;\n+        if (array.length != 3)\n+            return null;\n+\n+        if (OpenJPAVersion.VERSION_ID.equals(array[0])\n+            && confClassName.equals(array[1]))\n+            return array[2];\n+        else\n+            return null;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        confClassName = conf.getClass().getName();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"c7546b4abe705c72f28028ba71ef505054f02860","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,95 +1,95 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Hashtable;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.ParseException;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A cache of compiled queries.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.9.6 (also existed in prior versions of Kodo)\r\n- * @nojavadoc\r\n- */\r\n-public class QueryCompilationCacheValue\r\n-    extends PluginValue {\r\n-\r\n-    public static final String[] ALIASES = {\r\n-        \"true\", CacheMap.class.getName(),\r\n-        \"all\", ConcurrentHashMap.class.getName(),\r\n-        \"false\", null,\r\n-    };\r\n-\r\n-    public QueryCompilationCacheValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-\r\n-    public Object newInstance(String clsName, Class type,\r\n-        Configuration conf, boolean fatal) {\r\n-        // make sure map handles concurrency\r\n-        Map map;\r\n-        \r\n-        try {\r\n-            map = (Map) super.newInstance(clsName, type, conf, fatal);\r\n-        } catch (ParseException pe) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the ParseException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        } catch (IllegalArgumentException iae) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the IllegalArgumentException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        }\r\n-\r\n-        if (map != null && !(map instanceof Hashtable)\r\n-            && !(map instanceof CacheMap)\r\n-            && !(map instanceof\r\n-                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\r\n-            && !(map instanceof java.util.concurrent.ConcurrentMap))\r\n-            map = Collections.synchronizedMap(map);\r\n-        return map;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.ParseException;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A cache of compiled queries.\n+ *\n+ * @author Abe White\n+ * @since 0.9.6 (also existed in prior versions of Kodo)\n+ * @nojavadoc\n+ */\n+public class QueryCompilationCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+\n+    public QueryCompilationCacheValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // make sure map handles concurrency\n+        Map map;\n+        \n+        try {\n+            map = (Map) super.newInstance(clsName, type, conf, fatal);\n+        } catch (ParseException pe) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the ParseException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        } catch (IllegalArgumentException iae) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the IllegalArgumentException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        }\n+\n+        if (map != null && !(map instanceof Hashtable)\n+            && !(map instanceof CacheMap)\n+            && !(map instanceof\n+                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\n+            && !(map instanceof java.util.concurrent.ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+\t}\n+}"},{"sha":"82a10701a88de2cf5a5986d90be182c173c65797","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":455,"deletions":455,"changes":910,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,455 +1,455 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-\r\n-/**\r\n- * Abstract {@link DataCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractDataCache\r\n-    extends AbstractConcurrentEventManager\r\n-    implements DataCache, Configurable {\r\n-\r\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractDataCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    private String _name = null;\r\n-    private boolean _closed = false;\r\n-    private String _schedule = null;\r\n-\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        _name = name;\r\n-    }\r\n-\r\n-    public String getEvictionSchedule() {\r\n-        return _schedule;\r\n-    }\r\n-\r\n-    public void setEvictionSchedule(String s) {\r\n-        _schedule = s;\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (_schedule != null && !\"\".equals(_schedule)) {\r\n-            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n-            if (scheduler != null)\r\n-                scheduler.scheduleEviction(this, _schedule);\r\n-        }\r\n-    }\r\n-\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes) {\r\n-        // remove all objects in deletes list\r\n-        removeAllInternal(deletes);\r\n-\r\n-        // next, add all the new additions\r\n-        putAllInternal(additions);\r\n-        putAllInternal(newUpdates);\r\n-\r\n-        // possibly add the existing updates, depending on the\r\n-        // semantics of the cache, as dictated by recacheUpdates()\r\n-        if (recacheUpdates())\r\n-            putAllInternal(existingUpdates);\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            Collection addIds = new ArrayList(additions.size());\r\n-            Collection upIds = new ArrayList(newUpdates.size());\r\n-            Collection exIds = new ArrayList(existingUpdates.size());\r\n-\r\n-            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n-                addIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n-                upIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n-                exIds.add(((DataCachePCData) iter.next()).getId());\r\n-\r\n-            log.trace(s_loc.get(\"cache-commit\",\r\n-                new Object[]{ addIds, upIds, exIds, deletes }));\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        return o != null;\r\n-    }\r\n-\r\n-    public BitSet containsAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (contains(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public DataCachePCData get(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-\r\n-        return o;\r\n-    }\r\n-\r\n-    public DataCachePCData put(DataCachePCData data) {\r\n-        DataCachePCData o = putInternal(data.getId(), data);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public void update(DataCachePCData data) {\r\n-        if (recacheUpdates())\r\n-            putInternal(data.getId(), data);\r\n-    }\r\n-\r\n-    public DataCachePCData remove(Object key) {\r\n-        DataCachePCData o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public BitSet removeAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (remove(iter.next()) != null)\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the objects of the given class from the cache.\r\n-     */\r\n-    public void removeAll(Class cls, boolean subClasses) {\r\n-        removeAllInternal(cls, subClasses);\r\n-    }\r\n-\r\n-    public boolean pin(Object key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet pinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (pin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void pinAll(Class cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-pin\", getName()));\r\n-    }\r\n-\r\n-    public boolean unpin(Object key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet unpinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (unpin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void unpinAll(Class cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addExpirationListener(ExpirationListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeExpirationListener(ExpirationListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n-            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n-        } else {\r\n-            // drop all the committed OIDs, excepting brand\r\n-            // new OIDs. brand new OIDs either won't be in\r\n-            // the cache, or if they are, will be more up to date\r\n-            removeAllInternal(event.getUpdatedObjectIds());\r\n-            removeAllInternal(event.getDeletedObjectIds());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoke when a key is removed from this cache. Propagates the\r\n-     * expiration event on to all expiration listeners registered\r\n-     * with this class.\r\n-     */\r\n-    protected void keyRemoved(Object key, boolean expired) {\r\n-        // Notify any expiration listeners of the expiration.\r\n-        if (hasListeners())\r\n-            fireEvent(new ExpirationEvent(this, key, expired));\r\n-\r\n-        if (expired && log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-expired\", key));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return <code>true</code> if updates to data already in the\r\n-     * cache (either in {@link #commit} or the {@link #update})\r\n-     * should be put back into the cache. Returns false by default.\r\n-     */\r\n-    protected boolean recacheUpdates() {\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the object for the given oid.\r\n-     */\r\n-    protected abstract DataCachePCData getInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Add the given object to the cache, returning the old object under the\r\n-     * given oid.\r\n-     */\r\n-    protected abstract DataCachePCData putInternal(Object oid,\r\n-        DataCachePCData pc);\r\n-\r\n-    /**\r\n-     * All all of the given objects to the cache.\r\n-     */\r\n-    protected void putAllInternal(Collection pcs) {\r\n-        DataCachePCData pc;\r\n-        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n-            pc = (DataCachePCData) iter.next();\r\n-            putInternal(pc.getId(), pc);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the object under the given oid from the cache.\r\n-     */\r\n-    protected abstract DataCachePCData removeInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Evict objects in cache by class.\r\n-     */\r\n-    protected abstract void removeAllInternal(Class cls, boolean subclasses);\r\n-\r\n-    /**\r\n-     * Remove all objects under the given oids from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection oids) {\r\n-        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n-            removeInternal(iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove all objects of the given class names from the cache.\r\n-     */\r\n-    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n-        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n-        if (classes == null)\r\n-            return;\r\n-\r\n-        Class cls;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n-            cls = (Class) iter.next();\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n-            removeAllInternal(cls, false);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(Object oid);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_name == null)\r\n-            setName(NAME_DEFAULT);\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        ExpirationListener listen = (ExpirationListener) listener;\r\n-        ExpirationEvent ev = (ExpirationEvent) event;\r\n-        try {\r\n-            listen.onExpire(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-    /**\r\n-     * Returns the objects for the given key List.\r\n-     */\r\n-    public Map getAll(List keys) {\r\n-        Map resultMap = new HashMap(keys.size());\r\n-        for(int i=0; i<keys.size(); i++)\r\n-            resultMap.put(keys.get(i), get(keys.get(i)));\r\n-        return resultMap;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+\n+/**\n+ * Abstract {@link DataCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractDataCache\n+    extends AbstractConcurrentEventManager\n+    implements DataCache, Configurable {\n+\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractDataCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private String _name = null;\n+    private boolean _closed = false;\n+    private String _schedule = null;\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+\n+    public String getEvictionSchedule() {\n+        return _schedule;\n+    }\n+\n+    public void setEvictionSchedule(String s) {\n+        _schedule = s;\n+    }\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (_schedule != null && !\"\".equals(_schedule)) {\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\n+            if (scheduler != null)\n+                scheduler.scheduleEviction(this, _schedule);\n+        }\n+    }\n+\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes) {\n+        // remove all objects in deletes list\n+        removeAllInternal(deletes);\n+\n+        // next, add all the new additions\n+        putAllInternal(additions);\n+        putAllInternal(newUpdates);\n+\n+        // possibly add the existing updates, depending on the\n+        // semantics of the cache, as dictated by recacheUpdates()\n+        if (recacheUpdates())\n+            putAllInternal(existingUpdates);\n+\n+        if (log.isTraceEnabled()) {\n+            Collection addIds = new ArrayList(additions.size());\n+            Collection upIds = new ArrayList(newUpdates.size());\n+            Collection exIds = new ArrayList(existingUpdates.size());\n+\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\n+                addIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\n+                upIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\n+                exIds.add(((DataCachePCData) iter.next()).getId());\n+\n+            log.trace(s_loc.get(\"cache-commit\",\n+                new Object[]{ addIds, upIds, exIds, deletes }));\n+        }\n+    }\n+\n+    public boolean contains(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+        return o != null;\n+    }\n+\n+    public BitSet containsAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (contains(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public DataCachePCData get(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+\n+        return o;\n+    }\n+\n+    public DataCachePCData put(DataCachePCData data) {\n+        DataCachePCData o = putInternal(data.getId(), data);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public void update(DataCachePCData data) {\n+        if (recacheUpdates())\n+            putInternal(data.getId(), data);\n+    }\n+\n+    public DataCachePCData remove(Object key) {\n+        DataCachePCData o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public BitSet removeAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (remove(iter.next()) != null)\n+                set.set(i);\n+        return set;\n+    }\n+\n+    /**\n+     * Remove the objects of the given class from the cache.\n+     */\n+    public void removeAll(Class cls, boolean subClasses) {\n+        removeAllInternal(cls, subClasses);\n+    }\n+\n+    public boolean pin(Object key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet pinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (pin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void pinAll(Class cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-pin\", getName()));\n+    }\n+\n+    public boolean unpin(Object key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet unpinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (unpin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void unpinAll(Class cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addExpirationListener(ExpirationListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeExpirationListener(ExpirationListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    public String toString() {\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\n+        } else {\n+            // drop all the committed OIDs, excepting brand\n+            // new OIDs. brand new OIDs either won't be in\n+            // the cache, or if they are, will be more up to date\n+            removeAllInternal(event.getUpdatedObjectIds());\n+            removeAllInternal(event.getDeletedObjectIds());\n+        }\n+    }\n+\n+    /**\n+     * Invoke when a key is removed from this cache. Propagates the\n+     * expiration event on to all expiration listeners registered\n+     * with this class.\n+     */\n+    protected void keyRemoved(Object key, boolean expired) {\n+        // Notify any expiration listeners of the expiration.\n+        if (hasListeners())\n+            fireEvent(new ExpirationEvent(this, key, expired));\n+\n+        if (expired && log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-expired\", key));\n+    }\n+\n+    /**\n+     * Return <code>true</code> if updates to data already in the\n+     * cache (either in {@link #commit} or the {@link #update})\n+     * should be put back into the cache. Returns false by default.\n+     */\n+    protected boolean recacheUpdates() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the object for the given oid.\n+     */\n+    protected abstract DataCachePCData getInternal(Object oid);\n+\n+    /**\n+     * Add the given object to the cache, returning the old object under the\n+     * given oid.\n+     */\n+    protected abstract DataCachePCData putInternal(Object oid,\n+        DataCachePCData pc);\n+\n+    /**\n+     * All all of the given objects to the cache.\n+     */\n+    protected void putAllInternal(Collection pcs) {\n+        DataCachePCData pc;\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\n+            pc = (DataCachePCData) iter.next();\n+            putInternal(pc.getId(), pc);\n+        }\n+    }\n+\n+    /**\n+     * Remove the object under the given oid from the cache.\n+     */\n+    protected abstract DataCachePCData removeInternal(Object oid);\n+\n+    /**\n+     * Evict objects in cache by class.\n+     */\n+    protected abstract void removeAllInternal(Class cls, boolean subclasses);\n+\n+    /**\n+     * Remove all objects under the given oids from the cache.\n+     */\n+    protected void removeAllInternal(Collection oids) {\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\n+            removeInternal(iter.next());\n+    }\n+\n+    /**\n+     * Remove all objects of the given class names from the cache.\n+     */\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\n+        if (classes == null)\n+            return;\n+\n+        Class cls;\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n+            cls = (Class) iter.next();\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\n+            removeAllInternal(cls, false);\n+        }\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(Object oid);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(Object oid);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_name == null)\n+            setName(NAME_DEFAULT);\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        ExpirationListener listen = (ExpirationListener) listener;\n+        ExpirationEvent ev = (ExpirationEvent) event;\n+        try {\n+            listen.onExpire(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+\t\t}\n+\t}\n+\n+    /**\n+     * Returns the objects for the given key List.\n+     */\n+    public Map getAll(List keys) {\n+        Map resultMap = new HashMap(keys.size());\n+        for(int i=0; i<keys.size(); i++)\n+            resultMap.put(keys.get(i), get(keys.get(i)));\n+        return resultMap;\n+    }\n+}"},{"sha":"7a6beb97c91ff0e8290bb29e4ee67d95954ddf53","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":322,"deletions":322,"changes":644,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,322 +1,322 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * Abstract {@link QueryCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractQueryCache\r\n-    extends AbstractConcurrentEventManager \r\n-    implements QueryCache, Configurable {\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractQueryCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    private boolean _closed = false;\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-    }\r\n-\r\n-    public void onTypesChanged(TypesChangedEvent ev) {\r\n-        writeLock();\r\n-        Collection keys = null;\r\n-        try {\r\n-            if (hasListeners())\r\n-                fireEvent(ev);\r\n-            keys = keySet();\r\n-        } finally {\r\n-            writeUnlock();\r\n-        }\r\n-\r\n-        QueryKey qk;\r\n-        List removes = null;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext();) {\r\n-            qk = (QueryKey) iter.next();\r\n-            if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n-                if (removes == null)\r\n-                    removes = new ArrayList();\r\n-                removes.add(qk);\r\n-            }\r\n-        }\r\n-        if (removes != null)\r\n-            removeAllInternal(removes);\r\n-    }\r\n-\r\n-    public QueryResult get(QueryKey key) {\r\n-        QueryResult o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n-        QueryResult o = putInternal(qk, oids);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", qk));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public QueryResult remove(QueryKey key) {\r\n-        QueryResult o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public boolean pin(QueryKey key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public boolean unpin(QueryKey key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addTypesChangedListener(TypesChangedListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits, by delegating to\r\n-     * {@link #onTypesChanged}.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        // drop all committed classes\r\n-        Set classes = Caches.addTypesByName(conf,\r\n-            event.getPersistedTypeNames(), null);\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n-                classes);\r\n-            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n-                classes);\r\n-        } else {\r\n-            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n-            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n-        }\r\n-        if (classes != null)\r\n-            onTypesChanged(new TypesChangedEvent(this, classes));\r\n-    }\r\n-\r\n-    /**\r\n-     * Build up a set of classes for the given oids.\r\n-     */\r\n-    private Set addTypes(Collection oids, Set classes) {\r\n-        if (oids.isEmpty())\r\n-            return classes;\r\n-        if (classes == null)\r\n-            classes = new HashSet();\r\n-\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        ClassMetaData meta;\r\n-        Object oid;\r\n-        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n-            oid = itr.next();\r\n-            if (oid instanceof Id)\r\n-                classes.add(((Id) oid).getType());\r\n-            else {\r\n-                // ok if no metadata for oid; that just means the pc type\r\n-                // probably hasn't been loaded into this JVM yet, and therefore\r\n-                // there's no chance that it's in the cache anyway\r\n-                meta = repos.getMetaData(oid, null, false);\r\n-                if (meta != null)\r\n-                    classes.add(meta.getDescribedType());\r\n-            }\r\n-        }\r\n-        return classes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a threadsafe view of the keys in this cache. This collection\r\n-     * must be iterable without risk of concurrent modification exceptions.\r\n-     * It does not have to implement contains() efficiently or use set\r\n-     * semantics.\r\n-     */\r\n-    protected abstract Collection keySet();\r\n-\r\n-    /**\r\n-     * Return the list for the given key.\r\n-     */\r\n-    protected abstract QueryResult getInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Add the given result to the cache, returning the old result under the\r\n-     * given key.\r\n-     */\r\n-    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n-\r\n-    /**\r\n-     * Remove the result under the given key from the cache.\r\n-     */\r\n-    protected abstract QueryResult removeInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Remove all results under the given keys from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection qks) {\r\n-        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n-            removeInternal((QueryKey) iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(QueryKey qk);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        TypesChangedListener listen = (TypesChangedListener) listener;\r\n-        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n-        try {\r\n-            listen.onTypesChanged(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Individual query results will be registered as types changed\r\n-     * listeners. We want such query results to be gc'd once\r\n-     * the only reference is held by the list of expiration listeners.\r\n-     */\r\n-    protected Collection newListenerCollection() {\r\n-        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * Abstract {@link QueryCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractQueryCache\n+    extends AbstractConcurrentEventManager \n+    implements QueryCache, Configurable {\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractQueryCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private boolean _closed = false;\n+\n+    public void initialize(DataCacheManager manager) {\n+    }\n+\n+    public void onTypesChanged(TypesChangedEvent ev) {\n+        writeLock();\n+        Collection keys = null;\n+        try {\n+            if (hasListeners())\n+                fireEvent(ev);\n+            keys = keySet();\n+        } finally {\n+            writeUnlock();\n+        }\n+\n+        QueryKey qk;\n+        List removes = null;\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            qk = (QueryKey) iter.next();\n+            if (qk.changeInvalidatesQuery(ev.getTypes())) {\n+                if (removes == null)\n+                    removes = new ArrayList();\n+                removes.add(qk);\n+            }\n+        }\n+        if (removes != null)\n+            removeAllInternal(removes);\n+    }\n+\n+    public QueryResult get(QueryKey key) {\n+        QueryResult o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\n+        QueryResult o = putInternal(qk, oids);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", qk));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public QueryResult remove(QueryKey key) {\n+        QueryResult o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public boolean pin(QueryKey key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public boolean unpin(QueryKey key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addTypesChangedListener(TypesChangedListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits, by delegating to\n+     * {@link #onTypesChanged}.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        // drop all committed classes\n+        Set classes = Caches.addTypesByName(conf,\n+            event.getPersistedTypeNames(), null);\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\n+                classes);\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\n+                classes);\n+        } else {\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\n+        }\n+        if (classes != null)\n+            onTypesChanged(new TypesChangedEvent(this, classes));\n+    }\n+\n+    /**\n+     * Build up a set of classes for the given oids.\n+     */\n+    private Set addTypes(Collection oids, Set classes) {\n+        if (oids.isEmpty())\n+            return classes;\n+        if (classes == null)\n+            classes = new HashSet();\n+\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        ClassMetaData meta;\n+        Object oid;\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\n+            oid = itr.next();\n+            if (oid instanceof Id)\n+                classes.add(((Id) oid).getType());\n+            else {\n+                // ok if no metadata for oid; that just means the pc type\n+                // probably hasn't been loaded into this JVM yet, and therefore\n+                // there's no chance that it's in the cache anyway\n+                meta = repos.getMetaData(oid, null, false);\n+                if (meta != null)\n+                    classes.add(meta.getDescribedType());\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * Return a threadsafe view of the keys in this cache. This collection\n+     * must be iterable without risk of concurrent modification exceptions.\n+     * It does not have to implement contains() efficiently or use set\n+     * semantics.\n+     */\n+    protected abstract Collection keySet();\n+\n+    /**\n+     * Return the list for the given key.\n+     */\n+    protected abstract QueryResult getInternal(QueryKey qk);\n+\n+    /**\n+     * Add the given result to the cache, returning the old result under the\n+     * given key.\n+     */\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\n+\n+    /**\n+     * Remove the result under the given key from the cache.\n+     */\n+    protected abstract QueryResult removeInternal(QueryKey qk);\n+\n+    /**\n+     * Remove all results under the given keys from the cache.\n+     */\n+    protected void removeAllInternal(Collection qks) {\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\n+            removeInternal((QueryKey) iter.next());\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(QueryKey qk);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(QueryKey qk);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        TypesChangedListener listen = (TypesChangedListener) listener;\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\n+        try {\n+            listen.onTypesChanged(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+        }\n+    }\n+\n+    /**\n+     * Individual query results will be registered as types changed\n+     * listeners. We want such query results to be gc'd once\n+     * the only reference is held by the list of expiration listeners.\n+     */\n+    protected Collection newListenerCollection() {\n+        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\n+\t}\n+}"},{"sha":"28e7e211ced156204672294e6c9cd7f36797c6b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":248,"deletions":248,"changes":496,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,248 +1,248 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.security.AccessController;\r\n-import java.text.DateFormat;\r\n-import java.text.SimpleDateFormat;\r\n-import java.util.Calendar;\r\n-import java.util.Date;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Cron-style cache eviction. Understands schedules based on cron format:\r\n- * <code>minute hour mday month wday</code>\r\n- * For example:\r\n- * <code>15,30 6,19 2,10 1 2 </code>\r\n- * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n- * of January when its a Monday.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class DataCacheScheduler\r\n-    implements Runnable {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DataCacheScheduler.class);\r\n-\r\n-    private Map _caches = new ConcurrentHashMap();\r\n-    private boolean _stop = false;\r\n-    private int _interval = 2;\r\n-    private Log _log;\r\n-    private Thread _thread;\r\n-\r\n-    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n-        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public int getInterval() {\r\n-        return _interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public void setInterval(int interval) {\r\n-        _interval = interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * Stop the associated thread if there and stop the current runnable.\r\n-     */\r\n-    public synchronized void stop() {\r\n-        _stop = true;\r\n-    }\r\n-\r\n-    private boolean isStopped() {\r\n-        return _stop;\r\n-    }\r\n-\r\n-    /**\r\n-     * Schedule the given cache for eviction. Starts the scheduling thread\r\n-     * if not started.\r\n-     */\r\n-    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n-        if (times == null)\r\n-            return;\r\n-\r\n-        Schedule schedule = new Schedule(times);\r\n-        _caches.put(cache, schedule);\r\n-        _stop = false;\r\n-        if (_thread == null) {\r\n-            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\r\n-                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\r\n-                    .getMessage()));\r\n-            _thread.start();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the given cache from scheduling.\r\n-     */\r\n-    public synchronized void removeFromSchedule(DataCache cache) {\r\n-        _caches.remove(cache);\r\n-        if (_caches.size() == 0)\r\n-            stop();\r\n-    }\r\n-\r\n-    public void run() {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n-\r\n-        Date lastRun = new Date();\r\n-        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n-        while (!isStopped()) {\r\n-            try {\r\n-                Thread.sleep(_interval * 60 * 1000);\r\n-\r\n-                Date now = new Date();\r\n-                DataCache cache;\r\n-                Schedule schedule;\r\n-                Map.Entry entry;\r\n-                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n-                    entry = (Map.Entry) i.next();\r\n-                    cache = (DataCache) entry.getKey();\r\n-                    schedule = (Schedule) entry.getValue();\r\n-                    if (schedule.matches(lastRun, now)) {\r\n-                        if (_log.isTraceEnabled())\r\n-                            _log.trace(_loc.get(\"scheduler-clear\",\r\n-                                cache.getName(), fom.format(now)));\r\n-                        evict(cache);\r\n-                    }\r\n-                }\r\n-                lastRun = now;\r\n-            } catch (Exception e) {\r\n-                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        _log.info(_loc.get(\"scheduler-stop\"));\r\n-        synchronized (this) {\r\n-            if (isStopped())\r\n-                _thread = null; // be sure to deref the thread so it can restart\r\n-        }\r\n-    }\r\n-\r\n-    protected void evict(DataCache cache) {\r\n-        cache.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Simple class which represents the given time schedule.\r\n-     */\r\n-    private static class Schedule {\r\n-\r\n-        static final int[] WILDCARD = new int[0];\r\n-        static final int[] UNITS = {\r\n-            Calendar.MONTH,\r\n-            Calendar.DAY_OF_MONTH,\r\n-            Calendar.DAY_OF_WEEK,\r\n-            Calendar.HOUR_OF_DAY,\r\n-            Calendar.MINUTE\r\n-        };\r\n-        final int[] month;\r\n-        final int[] dayOfMonth;\r\n-        final int[] dayOfWeek;\r\n-        final int[] hour;\r\n-        final int[] min;\r\n-\r\n-        public Schedule(String date) {\r\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n-            if (token.countTokens() != 5)\r\n-                throw new UserException(_loc.get(\"bad-count\", date)).\r\n-                    setFatal(true);\r\n-            try {\r\n-                min = parse(token.nextToken(), 0, 60);\r\n-                hour = parse(token.nextToken(), 0, 24);\r\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n-                month = parse(token.nextToken(), 1, 13);\r\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        private int[] parse(String token, int min, int max) {\r\n-            if (\"*\".equals(token.trim()))\r\n-                return WILDCARD;\r\n-            String[] tokens = Strings.split(token, \",\", 0);\r\n-            int [] times = new int[tokens.length];\r\n-            for (int i = 0; i < tokens.length; i++) {\r\n-                try {\r\n-                    times[i] = Integer.parseInt(tokens[i]);\r\n-                } catch (Throwable t) {\r\n-                    throw new UserException(_loc.get(\"not-number\", token)).\r\n-                        setFatal(true);\r\n-                }\r\n-                if (times[i] < min || times[i] >= max)\r\n-                    throw new UserException(_loc.get(\"not-range\", token,\r\n-                        String.valueOf(min), String.valueOf(max))).\r\n-                        setFatal(true);\r\n-            }\r\n-            return times;\r\n-        }\r\n-\r\n-        boolean matches(Date last, Date now) {\r\n-            Calendar time = Calendar.getInstance();\r\n-            time.setTime(now);\r\n-            time.set(Calendar.SECOND, 0);\r\n-            time.set(Calendar.MILLISECOND, 0);\r\n-\r\n-            int[][] all =\r\n-                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n-            return matches(last, now, time, all, 0);\r\n-        }\r\n-\r\n-        private boolean matches(Date last, Date now, Calendar time,\r\n-            int[][] times, int depth) {\r\n-            if (depth == UNITS.length) {\r\n-                Date compare = time.getTime();\r\n-                return compare.compareTo(last) >= 0 &&\r\n-                    compare.compareTo(now) < 0;\r\n-            }\r\n-\r\n-            if (times[depth] != WILDCARD) {\r\n-                for (int i = 0; i < times[depth].length; i++) {\r\n-                    time.set(UNITS[depth], times[depth][i]);\r\n-                    if (matches(last, now, time, times, depth + 1))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-            return matches(last, now, time, times, depth + 1);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.security.AccessController;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.util.InvalidStateException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * Cron-style cache eviction. Understands schedules based on cron format:\n+ * <code>minute hour mday month wday</code>\n+ * For example:\n+ * <code>15,30 6,19 2,10 1 2 </code>\n+ * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\n+ * of January when its a Monday.\n+ *\n+ * @author Steve Kim\n+ */\n+public class DataCacheScheduler\n+    implements Runnable {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DataCacheScheduler.class);\n+\n+    private Map _caches = new ConcurrentHashMap();\n+    private boolean _stop = false;\n+    private int _interval = 2;\n+    private Log _log;\n+    private Thread _thread;\n+\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public int getInterval() {\n+        return _interval;\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public void setInterval(int interval) {\n+        _interval = interval;\n+    }\n+\n+    /**\n+     * Stop the associated thread if there and stop the current runnable.\n+     */\n+    public synchronized void stop() {\n+        _stop = true;\n+    }\n+\n+    private boolean isStopped() {\n+        return _stop;\n+    }\n+\n+    /**\n+     * Schedule the given cache for eviction. Starts the scheduling thread\n+     * if not started.\n+     */\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\n+        if (times == null)\n+            return;\n+\n+        Schedule schedule = new Schedule(times);\n+        _caches.put(cache, schedule);\n+        _stop = false;\n+        if (_thread == null) {\n+            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\n+                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\n+                    .getMessage()));\n+            _thread.start();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Remove the given cache from scheduling.\n+     */\n+    public synchronized void removeFromSchedule(DataCache cache) {\n+        _caches.remove(cache);\n+        if (_caches.size() == 0)\n+            stop();\n+    }\n+\n+    public void run() {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\n+\n+        Date lastRun = new Date();\n+        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\n+        while (!isStopped()) {\n+            try {\n+                Thread.sleep(_interval * 60 * 1000);\n+\n+                Date now = new Date();\n+                DataCache cache;\n+                Schedule schedule;\n+                Map.Entry entry;\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\n+                    entry = (Map.Entry) i.next();\n+                    cache = (DataCache) entry.getKey();\n+                    schedule = (Schedule) entry.getValue();\n+                    if (schedule.matches(lastRun, now)) {\n+                        if (_log.isTraceEnabled())\n+                            _log.trace(_loc.get(\"scheduler-clear\",\n+                                cache.getName(), fom.format(now)));\n+                        evict(cache);\n+                    }\n+                }\n+                lastRun = now;\n+            } catch (Exception e) {\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        _log.info(_loc.get(\"scheduler-stop\"));\n+        synchronized (this) {\n+            if (isStopped())\n+                _thread = null; // be sure to deref the thread so it can restart\n+        }\n+    }\n+\n+    protected void evict(DataCache cache) {\n+        cache.clear();\n+    }\n+\n+    /**\n+     * Simple class which represents the given time schedule.\n+     */\n+    private static class Schedule {\n+\n+        static final int[] WILDCARD = new int[0];\n+        static final int[] UNITS = {\n+            Calendar.MONTH,\n+            Calendar.DAY_OF_MONTH,\n+            Calendar.DAY_OF_WEEK,\n+            Calendar.HOUR_OF_DAY,\n+            Calendar.MINUTE\n+        };\n+        final int[] month;\n+        final int[] dayOfMonth;\n+        final int[] dayOfWeek;\n+        final int[] hour;\n+        final int[] min;\n+\n+        public Schedule(String date) {\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n+            if (token.countTokens() != 5)\n+                throw new UserException(_loc.get(\"bad-count\", date)).\n+                    setFatal(true);\n+            try {\n+                min = parse(token.nextToken(), 0, 60);\n+                hour = parse(token.nextToken(), 0, 24);\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\n+                month = parse(token.nextToken(), 1, 13);\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\n+            } catch (Throwable t) {\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        private int[] parse(String token, int min, int max) {\n+            if (\"*\".equals(token.trim()))\n+                return WILDCARD;\n+            String[] tokens = Strings.split(token, \",\", 0);\n+            int [] times = new int[tokens.length];\n+            for (int i = 0; i < tokens.length; i++) {\n+                try {\n+                    times[i] = Integer.parseInt(tokens[i]);\n+                } catch (Throwable t) {\n+                    throw new UserException(_loc.get(\"not-number\", token)).\n+                        setFatal(true);\n+                }\n+                if (times[i] < min || times[i] >= max)\n+                    throw new UserException(_loc.get(\"not-range\", token,\n+                        String.valueOf(min), String.valueOf(max))).\n+                        setFatal(true);\n+            }\n+            return times;\n+        }\n+\n+        boolean matches(Date last, Date now) {\n+            Calendar time = Calendar.getInstance();\n+            time.setTime(now);\n+            time.set(Calendar.SECOND, 0);\n+            time.set(Calendar.MILLISECOND, 0);\n+\n+            int[][] all =\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\n+            return matches(last, now, time, all, 0);\n+        }\n+\n+        private boolean matches(Date last, Date now, Calendar time,\n+            int[][] times, int depth) {\n+            if (depth == UNITS.length) {\n+                Date compare = time.getTime();\n+                return compare.compareTo(last) >= 0 &&\n+                    compare.compareTo(now) < 0;\n+            }\n+\n+            if (times[depth] != WILDCARD) {\n+                for (int i = 0; i < times[depth].length; i++) {\n+                    time.set(UNITS[depth], times[depth][i]);\n+                    if (matches(last, now, time, times, depth + 1))\n+                        return true;\n+                }\n+            }\n+            return matches(last, now, time, times, depth + 1);\n+\t\t}\n+\t}\n+}"},{"sha":"6b615df8cdbf5c8dcba5c3e6545049241f378ecf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":670,"deletions":670,"changes":1340,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,670 +1,670 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.io.Serializable;\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collections;\r\n-import java.util.Date;\r\n-import java.util.List;\r\n-import java.util.Locale;\r\n-import java.util.Map;\r\n-import java.util.TreeMap;\r\n-\r\n-import org.apache.commons.collections.map.LinkedMap;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ObjectNotFoundException;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n- * the query, and can determine whether or not the query has been dirtied.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @since 0.2.5.0\r\n- */\r\n-public class QueryCacheStoreQuery\r\n-    implements StoreQuery {\r\n-\r\n-    private final StoreQuery _query;\r\n-    private final QueryCache _cache;\r\n-    private StoreContext _sctx;\r\n-    private MetaDataRepository _repos;\r\n-\r\n-    /**\r\n-     * Create a new instance that delegates to <code>query</code> if no\r\n-     * cached results are available.\r\n-     */\r\n-    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n-        _query = query;\r\n-        _cache = cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link QueryCache} that this object is associated with.\r\n-     */\r\n-    public QueryCache getCache() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Delegate.\r\n-     */\r\n-    public StoreQuery getDelegate() {\r\n-        return _query;\r\n-    }\r\n-\r\n-    /**\r\n-     * Look in the query cache for a result for the given query\r\n-     * key. Only look if this query is being executed outside a\r\n-     * transaction or in a transaction with IgnoreChanges set to true\r\n-     * or in a transaction with IgnoreChanges set to false but in which\r\n-     * none of the classes involved in this query have been touched.\r\n-     *  Caching is not used when using object locking.\r\n-     * This is because we must obtain locks on the\r\n-     * data, and it is likely that making n trips to the database to\r\n-     * make the locks will be slower than running the query against\r\n-     * the database.\r\n-     *  If the fetch configuration has query caching disabled,\r\n-     * then this method returns <code>null</code>.\r\n-     *  Return the list if we meet the above criteria and if a list\r\n-     * is found for <code>qk</code>. Else, return\r\n-     * <code>null</code>.\r\n-     *  This implementation means that queries against the cache\r\n-     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n-     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n-     * a transaction.\r\n-     */\r\n-    private List checkCache(QueryKey qk) {\r\n-        if (qk == null)\r\n-            return null;\r\n-        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n-        if (!fetch.getQueryCacheEnabled())\r\n-            return null;\r\n-        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n-            return null;\r\n-\r\n-        // get the cached data\r\n-        QueryResult res = _cache.get(qk);\r\n-        if (res == null)\r\n-            return null;\r\n-        if (res.isEmpty())\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        int projs = getContext().getProjectionAliases().length;\r\n-        if (projs == 0) {\r\n-            // make sure the data cache contains the oids for the query result;\r\n-            // if it doesn't, then using the result could be slower than not\r\n-            // using it because of the individual by-oid lookups\r\n-            ClassMetaData meta = _repos.getMetaData(getContext().\r\n-                getCandidateType(), _sctx.getClassLoader(), true);\r\n-            if (meta.getDataCache() == null)\r\n-                return null;\r\n-\r\n-            BitSet idxs = meta.getDataCache().containsAll(res);\r\n-\r\n-            // eventually we should optimize this to figure out how many objects\r\n-            // the cache is missing and if only a few do a bulk fetch for them\r\n-            int len = idxs.length();\r\n-            if (len < res.size())\r\n-                return null;\r\n-            for (int i = 0; i < len; i++)\r\n-                if (!idxs.get(i))\r\n-                    return null;\r\n-        }\r\n-        return new CachedList(res, projs != 0, _sctx);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrap the result object provider returned by our delegate in a\r\n-     * caching provider.\r\n-     */\r\n-    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n-        QueryKey key) {\r\n-        if (key == null)\r\n-            return rop;\r\n-        return new CachingResultObjectProvider(rop, getContext().\r\n-            getProjectionAliases().length > 0, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy a projection element for caching / returning.\r\n-     */\r\n-    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n-        if (obj == null)\r\n-            return null;\r\n-        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n-            case JavaTypes.STRING:\r\n-            case JavaTypes.BOOLEAN_OBJ:\r\n-            case JavaTypes.BYTE_OBJ:\r\n-            case JavaTypes.CHAR_OBJ:\r\n-            case JavaTypes.DOUBLE_OBJ:\r\n-            case JavaTypes.FLOAT_OBJ:\r\n-            case JavaTypes.INT_OBJ:\r\n-            case JavaTypes.LONG_OBJ:\r\n-            case JavaTypes.SHORT_OBJ:\r\n-            case JavaTypes.BIGDECIMAL:\r\n-            case JavaTypes.BIGINTEGER:\r\n-            case JavaTypes.OID:\r\n-                return obj;\r\n-            case JavaTypes.DATE:\r\n-                return ((Date) obj).clone();\r\n-            case JavaTypes.LOCALE:\r\n-                return ((Locale) obj).clone();\r\n-            default:\r\n-                if (obj instanceof CachedObjectId)\r\n-                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n-                Object oid = ctx.getObjectId(obj);\r\n-                if (oid != null)\r\n-                    return new CachedObjectId(oid);\r\n-                return obj;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the result object based on its cached oid.\r\n-     */\r\n-    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n-        if (oid == null)\r\n-            return null;\r\n-\r\n-        Object obj = sctx.find(oid, null, null, null, 0);\r\n-        if (obj == null)\r\n-            throw new ObjectNotFoundException(oid);\r\n-        return obj;\r\n-    }\r\n-\r\n-    public Object writeReplace()\r\n-        throws ObjectStreamException {\r\n-        return _query;\r\n-    }\r\n-\r\n-    public QueryContext getContext() {\r\n-        return _query.getContext();\r\n-    }\r\n-\r\n-    public void setContext(QueryContext qctx) {\r\n-        _query.setContext(qctx);\r\n-        _sctx = qctx.getStoreContext();\r\n-        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\r\n-    }\r\n-\r\n-    public boolean setQuery(Object query) {\r\n-        return _query.setQuery(query);\r\n-    }\r\n-\r\n-    public FilterListener getFilterListener(String tag) {\r\n-        return _query.getFilterListener(tag);\r\n-    }\r\n-\r\n-    public AggregateListener getAggregateListener(String tag) {\r\n-        return _query.getAggregateListener(tag);\r\n-    }\r\n-\r\n-    public Object newCompilationKey() {\r\n-        return _query.newCompilationKey();\r\n-    }\r\n-\r\n-    public Object newCompilation() {\r\n-        return _query.newCompilation();\r\n-    }\r\n-\r\n-    public void populateFromCompilation(Object comp) {\r\n-        _query.populateFromCompilation(comp);\r\n-    }\r\n-\r\n-    public void invalidateCompilation() {\r\n-        _query.invalidateCompilation();\r\n-    }\r\n-\r\n-    public boolean supportsDataStoreExecution() {\r\n-        return _query.supportsDataStoreExecution();\r\n-    }\r\n-\r\n-    public boolean supportsInMemoryExecution() {\r\n-        return _query.supportsInMemoryExecution();\r\n-    }\r\n-\r\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n-        return _query.newInMemoryExecutor(meta, subs);\r\n-    }\r\n-\r\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n-        return new QueryCacheExecutor(ex, meta, subs);\r\n-    }\r\n-\r\n-    public boolean supportsAbstractExecutors() {\r\n-        return _query.supportsAbstractExecutors();\r\n-    }\r\n-\r\n-    public boolean requiresCandidateType() {\r\n-        return _query.requiresCandidateType();\r\n-    }\r\n-\r\n-    public boolean requiresParameterDeclarations() {\r\n-        return _query.requiresParameterDeclarations();\r\n-    }\r\n-\r\n-    public boolean supportsParameterDeclarations() {\r\n-        return _query.supportsParameterDeclarations();\r\n-    }\r\n- \r\n-    public Object evaluate(Object value, Object ob, Object[] params,\r\n-        OpenJPAStateManager sm) {\r\n-        return _query.evaluate(value, ob, params, sm);         \r\n-    }\r\n-\r\n-    /**\r\n-     * Caching executor.\r\n-     */\r\n-    private static class QueryCacheExecutor\r\n-        implements Executor {\r\n-\r\n-        private final Executor _ex;\r\n-        private final Class _candidate;\r\n-        private final boolean _subs;\r\n-\r\n-        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n-            boolean subs) {\r\n-            _ex = ex;\r\n-            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n-            _subs = subs;\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n-                _ex.isPacking(q), params, _candidate, _subs, range.start, \r\n-                range.end);\r\n-            List cached = cq.checkCache(key);\r\n-            if (cached != null)\r\n-                return new ListResultObjectProvider(cached);\r\n-\r\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n-                params, range);\r\n-            return cq.wrapResult(rop, key);\r\n-        }\r\n-\r\n-        /**\r\n-         * Clear the cached queries associated with the access path\r\n-         * classes in the query. This is done when bulk operations\r\n-         * (such as deletes or updates) are performed so that the\r\n-         * cache remains up-to-date.\r\n-         */\r\n-        private void clearAccessPath(StoreQuery q) {\r\n-            if (q == null)\r\n-                return;\r\n-\r\n-            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n-            if (cmd == null || cmd.length == 0)\r\n-                return;\r\n-\r\n-            List classes = new ArrayList(cmd.length);\r\n-            for (int i = 0; i < cmd.length; i++)\r\n-                classes.add(cmd[i].getDescribedType());\r\n-\r\n-            // evict from the query cache\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n-                (q.getContext(), classes));\r\n-\r\n-            // evict from the data cache\r\n-            for (int i = 0; i < cmd.length; i++) {\r\n-                if (cmd[i].getDataCache() != null)\r\n-                    cmd[i].getDataCache().removeAll(\r\n-                        cmd[i].getDescribedType(), true);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeDelete(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeDelete(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeUpdate(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            return EMPTY_STRINGS;\r\n-        }\r\n-\r\n-        public void validate(StoreQuery q) {\r\n-            _ex.validate(unwrap(q));\r\n-        }\r\n-        \r\n-        public void getRange(StoreQuery q, Object[] params, Range range) {\r\n-            _ex.getRange(q, params, range); \r\n-        }\r\n-\r\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n-            Object resultObject, int orderIndex) {\r\n-            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n-                orderIndex);\r\n-        }\r\n-\r\n-        public boolean[] getAscending(StoreQuery q) {\r\n-            return _ex.getAscending(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isPacking(StoreQuery q) {\r\n-            return _ex.isPacking(unwrap(q));\r\n-        }\r\n-\r\n-        public String getAlias(StoreQuery q) {\r\n-            return _ex.getAlias(unwrap(q));\r\n-        }\r\n-\r\n-        public Class getResultClass(StoreQuery q) {\r\n-            return _ex.getResultClass(unwrap(q));\r\n-        }\r\n-\r\n-        public String[] getProjectionAliases(StoreQuery q) {\r\n-            return _ex.getProjectionAliases(unwrap(q));\r\n-        }\r\n-\r\n-        public Class[] getProjectionTypes(StoreQuery q) {\r\n-            return _ex.getProjectionTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n-            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n-        }\r\n-\r\n-        public int getOperation(StoreQuery q) {\r\n-            return _ex.getOperation(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isAggregate(StoreQuery q) {\r\n-            return _ex.isAggregate(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean hasGrouping(StoreQuery q) {\r\n-            return _ex.hasGrouping(unwrap(q));\r\n-        }\r\n-\r\n-        public LinkedMap getParameterTypes(StoreQuery q) {\r\n-            return _ex.getParameterTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public Map getUpdates(StoreQuery q) {\r\n-            return _ex.getUpdates(unwrap(q));\r\n-        }\r\n-\r\n-        private static StoreQuery unwrap(StoreQuery q) {\r\n-            return ((QueryCacheStoreQuery) q).getDelegate();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Result list implementation for a cached query result. Package-protected\r\n-     * for testing.\r\n-     */\r\n-    public static class CachedList\r\n-        extends AbstractList\r\n-        implements Serializable {\r\n-\r\n-        private final QueryResult _res;\r\n-        private final boolean _proj;\r\n-        private final StoreContext _sctx;\r\n-\r\n-        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n-            _res = res;\r\n-            _proj = proj;\r\n-            _sctx = ctx;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            if (!_proj)\r\n-                return fromObjectId(_res.get(idx), _sctx);\r\n-\r\n-            Object[] cached = (Object[]) _res.get(idx);\r\n-            if (cached == null)\r\n-                return null;\r\n-            Object[] uncached = new Object[cached.length];\r\n-            for (int i = 0; i < cached.length; i++)\r\n-                uncached[i] = copyProjection(cached[i], _sctx);\r\n-            return uncached;\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _res.size();\r\n-        }\r\n-\r\n-        public Object writeReplace()\r\n-            throws ObjectStreamException {\r\n-            return new ArrayList(this);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n-     * all the OIDs in this list and registers that list with the\r\n-     * query cache. Abandons monitoring and registering if one of the classes\r\n-     * in the access path is modified while the query results are being loaded.\r\n-     */\r\n-    private class CachingResultObjectProvider\r\n-        implements ResultObjectProvider, TypesChangedListener {\r\n-\r\n-        private final ResultObjectProvider _rop;\r\n-        private final boolean _proj;\r\n-        private final QueryKey _qk;\r\n-        private final TreeMap _data = new TreeMap();\r\n-        private boolean _maintainCache = true;\r\n-        private int _pos = -1;\r\n-\r\n-        // used to determine list size without necessarily calling size(),\r\n-        // which may require a DB trip or return Integer.MAX_VALUE\r\n-        private int _max = -1;\r\n-        private int _size = Integer.MAX_VALUE;\r\n-\r\n-        /**\r\n-         * Constructor. Supply delegate result provider and our query key.\r\n-         */\r\n-        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n-            boolean proj, QueryKey key) {\r\n-            _rop = rop;\r\n-            _proj = proj;\r\n-            _qk = key;\r\n-            _cache.addTypesChangedListener(this);\r\n-        }\r\n-\r\n-        /**\r\n-         * Stop caching.\r\n-         */\r\n-        private void abortCaching() {\r\n-            if (!_maintainCache)\r\n-                return;\r\n-\r\n-            // this can be called via an event from another thread\r\n-            synchronized (this) {\r\n-                // it's important that we set this flag first so that any\r\n-                // subsequent calls to this object are bypassed.\r\n-                _maintainCache = false;\r\n-                _cache.removeTypesChangedListener(this);\r\n-                _data.clear();\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Check whether we've buffered all results, while optionally adding\r\n-         * the given result.\r\n-         */\r\n-        private void checkFinished(Object obj, boolean result) {\r\n-            // this can be called at the same time as abortCaching via\r\n-            // a types changed event\r\n-            boolean finished = false;\r\n-            synchronized (this) {\r\n-                if (_maintainCache) {\r\n-                    if (result) {\r\n-                        Integer index = Numbers.valueOf(_pos);\r\n-                        if (!_data.containsKey(index)) {\r\n-                            Object cached;\r\n-                            if (obj == null)\r\n-                                cached = null;\r\n-                            else if (!_proj)\r\n-                                cached = _sctx.getObjectId(obj);\r\n-                            else {\r\n-                                Object[] arr = (Object[]) obj;\r\n-                                Object[] cp = new Object[arr.length];\r\n-                                for (int i = 0; i < arr.length; i++)\r\n-                                    cp[i] = copyProjection(arr[i], _sctx);\r\n-                                cached = cp;\r\n-                            }\r\n-                            if (cached != null)\r\n-                                _data.put(index, cached);\r\n-                        }\r\n-                    }\r\n-                    finished = _size == _data.size();\r\n-                }\r\n-            }\r\n-\r\n-            if (finished) {\r\n-                // an abortCaching call can sneak in here via onExpire; the\r\n-                // cache is locked during event firings, so the lock here will\r\n-                // wait for it (or will force the next firing to wait)\r\n-                _cache.writeLock();\r\n-                try {\r\n-                    // make sure we didn't abort\r\n-                    if (_maintainCache) {\r\n-                        QueryResult res = null;\r\n-                        synchronized (this) {\r\n-                            res = new QueryResult(_qk, _data.values());\r\n-                        }\r\n-                        _cache.put(_qk, res);\r\n-                        abortCaching();\r\n-                    }\r\n-                }\r\n-                finally {\r\n-                    _cache.writeUnlock();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        public boolean supportsRandomAccess() {\r\n-            return _rop.supportsRandomAccess();\r\n-        }\r\n-\r\n-        public void open()\r\n-            throws Exception {\r\n-            _rop.open();\r\n-        }\r\n-\r\n-        public Object getResultObject()\r\n-            throws Exception {\r\n-            Object obj = _rop.getResultObject();\r\n-            checkFinished(obj, true);\r\n-            return obj;\r\n-        }\r\n-\r\n-        public boolean next()\r\n-            throws Exception {\r\n-            _pos++;\r\n-            boolean next = _rop.next();\r\n-            if (!next && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (next && _pos > _max)\r\n-                _max = _pos;\r\n-            return next;\r\n-        }\r\n-\r\n-        public boolean absolute(int pos)\r\n-            throws Exception {\r\n-            _pos = pos;\r\n-            boolean valid = _rop.absolute(pos);\r\n-            if (!valid && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (valid && _pos > _max)\r\n-                _max = _pos;\r\n-            return valid;\r\n-        }\r\n-\r\n-        public int size()\r\n-            throws Exception {\r\n-            if (_size != Integer.MAX_VALUE)\r\n-                return _size;\r\n-            int size = _rop.size();\r\n-            _size = size;\r\n-            checkFinished(null, false);\r\n-            return size;\r\n-        }\r\n-\r\n-        public void reset()\r\n-            throws Exception {\r\n-            _rop.reset();\r\n-            _pos = -1;\r\n-        }\r\n-\r\n-        public void close()\r\n-            throws Exception {\r\n-            abortCaching();\r\n-            _rop.close();\r\n-        }\r\n-\r\n-        public void handleCheckedException(Exception e) {\r\n-            _rop.handleCheckedException(e);\r\n-        }\r\n-\r\n-        public void onTypesChanged(TypesChangedEvent ev) {\r\n-            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n-                abortCaching();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Struct to recognize cached oids.\r\n-     */\r\n-    private static class CachedObjectId {\r\n-\r\n-        public final Object oid;\r\n-\r\n-        public CachedObjectId (Object oid)\r\n-\t\t{\r\n-\t\t\tthis.oid = oid;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\n+ * the query, and can determine whether or not the query has been dirtied.\n+ *\n+ * @author Patrick Linskey\n+ * @since 0.2.5.0\n+ */\n+public class QueryCacheStoreQuery\n+    implements StoreQuery {\n+\n+    private final StoreQuery _query;\n+    private final QueryCache _cache;\n+    private StoreContext _sctx;\n+    private MetaDataRepository _repos;\n+\n+    /**\n+     * Create a new instance that delegates to <code>query</code> if no\n+     * cached results are available.\n+     */\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\n+        _query = query;\n+        _cache = cache;\n+    }\n+\n+    /**\n+     * Return the {@link QueryCache} that this object is associated with.\n+     */\n+    public QueryCache getCache() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Delegate.\n+     */\n+    public StoreQuery getDelegate() {\n+        return _query;\n+    }\n+\n+    /**\n+     * Look in the query cache for a result for the given query\n+     * key. Only look if this query is being executed outside a\n+     * transaction or in a transaction with IgnoreChanges set to true\n+     * or in a transaction with IgnoreChanges set to false but in which\n+     * none of the classes involved in this query have been touched.\n+     *  Caching is not used when using object locking.\n+     * This is because we must obtain locks on the\n+     * data, and it is likely that making n trips to the database to\n+     * make the locks will be slower than running the query against\n+     * the database.\n+     *  If the fetch configuration has query caching disabled,\n+     * then this method returns <code>null</code>.\n+     *  Return the list if we meet the above criteria and if a list\n+     * is found for <code>qk</code>. Else, return\n+     * <code>null</code>.\n+     *  This implementation means that queries against the cache\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\n+     * a transaction.\n+     */\n+    private List checkCache(QueryKey qk) {\n+        if (qk == null)\n+            return null;\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\n+        if (!fetch.getQueryCacheEnabled())\n+            return null;\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\n+            return null;\n+\n+        // get the cached data\n+        QueryResult res = _cache.get(qk);\n+        if (res == null)\n+            return null;\n+        if (res.isEmpty())\n+            return Collections.EMPTY_LIST;\n+\n+        int projs = getContext().getProjectionAliases().length;\n+        if (projs == 0) {\n+            // make sure the data cache contains the oids for the query result;\n+            // if it doesn't, then using the result could be slower than not\n+            // using it because of the individual by-oid lookups\n+            ClassMetaData meta = _repos.getMetaData(getContext().\n+                getCandidateType(), _sctx.getClassLoader(), true);\n+            if (meta.getDataCache() == null)\n+                return null;\n+\n+            BitSet idxs = meta.getDataCache().containsAll(res);\n+\n+            // eventually we should optimize this to figure out how many objects\n+            // the cache is missing and if only a few do a bulk fetch for them\n+            int len = idxs.length();\n+            if (len < res.size())\n+                return null;\n+            for (int i = 0; i < len; i++)\n+                if (!idxs.get(i))\n+                    return null;\n+        }\n+        return new CachedList(res, projs != 0, _sctx);\n+    }\n+\n+    /**\n+     * Wrap the result object provider returned by our delegate in a\n+     * caching provider.\n+     */\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\n+        QueryKey key) {\n+        if (key == null)\n+            return rop;\n+        return new CachingResultObjectProvider(rop, getContext().\n+            getProjectionAliases().length > 0, key);\n+    }\n+\n+    /**\n+     * Copy a projection element for caching / returning.\n+     */\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\n+        if (obj == null)\n+            return null;\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\n+            case JavaTypes.STRING:\n+            case JavaTypes.BOOLEAN_OBJ:\n+            case JavaTypes.BYTE_OBJ:\n+            case JavaTypes.CHAR_OBJ:\n+            case JavaTypes.DOUBLE_OBJ:\n+            case JavaTypes.FLOAT_OBJ:\n+            case JavaTypes.INT_OBJ:\n+            case JavaTypes.LONG_OBJ:\n+            case JavaTypes.SHORT_OBJ:\n+            case JavaTypes.BIGDECIMAL:\n+            case JavaTypes.BIGINTEGER:\n+            case JavaTypes.OID:\n+                return obj;\n+            case JavaTypes.DATE:\n+                return ((Date) obj).clone();\n+            case JavaTypes.LOCALE:\n+                return ((Locale) obj).clone();\n+            default:\n+                if (obj instanceof CachedObjectId)\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\n+                Object oid = ctx.getObjectId(obj);\n+                if (oid != null)\n+                    return new CachedObjectId(oid);\n+                return obj;\n+        }\n+    }\n+\n+    /**\n+     * Return the result object based on its cached oid.\n+     */\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\n+        if (oid == null)\n+            return null;\n+\n+        Object obj = sctx.find(oid, null, null, null, 0);\n+        if (obj == null)\n+            throw new ObjectNotFoundException(oid);\n+        return obj;\n+    }\n+\n+    public Object writeReplace()\n+        throws ObjectStreamException {\n+        return _query;\n+    }\n+\n+    public QueryContext getContext() {\n+        return _query.getContext();\n+    }\n+\n+    public void setContext(QueryContext qctx) {\n+        _query.setContext(qctx);\n+        _sctx = qctx.getStoreContext();\n+        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\n+    }\n+\n+    public boolean setQuery(Object query) {\n+        return _query.setQuery(query);\n+    }\n+\n+    public FilterListener getFilterListener(String tag) {\n+        return _query.getFilterListener(tag);\n+    }\n+\n+    public AggregateListener getAggregateListener(String tag) {\n+        return _query.getAggregateListener(tag);\n+    }\n+\n+    public Object newCompilationKey() {\n+        return _query.newCompilationKey();\n+    }\n+\n+    public Object newCompilation() {\n+        return _query.newCompilation();\n+    }\n+\n+    public void populateFromCompilation(Object comp) {\n+        _query.populateFromCompilation(comp);\n+    }\n+\n+    public void invalidateCompilation() {\n+        _query.invalidateCompilation();\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return _query.supportsDataStoreExecution();\n+    }\n+\n+    public boolean supportsInMemoryExecution() {\n+        return _query.supportsInMemoryExecution();\n+    }\n+\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n+        return _query.newInMemoryExecutor(meta, subs);\n+    }\n+\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\n+        return new QueryCacheExecutor(ex, meta, subs);\n+    }\n+\n+    public boolean supportsAbstractExecutors() {\n+        return _query.supportsAbstractExecutors();\n+    }\n+\n+    public boolean requiresCandidateType() {\n+        return _query.requiresCandidateType();\n+    }\n+\n+    public boolean requiresParameterDeclarations() {\n+        return _query.requiresParameterDeclarations();\n+    }\n+\n+    public boolean supportsParameterDeclarations() {\n+        return _query.supportsParameterDeclarations();\n+    }\n+ \n+    public Object evaluate(Object value, Object ob, Object[] params,\n+        OpenJPAStateManager sm) {\n+        return _query.evaluate(value, ob, params, sm);         \n+    }\n+\n+    /**\n+     * Caching executor.\n+     */\n+    private static class QueryCacheExecutor\n+        implements Executor {\n+\n+        private final Executor _ex;\n+        private final Class _candidate;\n+        private final boolean _subs;\n+\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n+            boolean subs) {\n+            _ex = ex;\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\n+            _subs = subs;\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n+            Range range) {\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\n+                _ex.isPacking(q), params, _candidate, _subs, range.start, \n+                range.end);\n+            List cached = cq.checkCache(key);\n+            if (cached != null)\n+                return new ListResultObjectProvider(cached);\n+\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n+                params, range);\n+            return cq.wrapResult(rop, key);\n+        }\n+\n+        /**\n+         * Clear the cached queries associated with the access path\n+         * classes in the query. This is done when bulk operations\n+         * (such as deletes or updates) are performed so that the\n+         * cache remains up-to-date.\n+         */\n+        private void clearAccessPath(StoreQuery q) {\n+            if (q == null)\n+                return;\n+\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\n+            if (cmd == null || cmd.length == 0)\n+                return;\n+\n+            List classes = new ArrayList(cmd.length);\n+            for (int i = 0; i < cmd.length; i++)\n+                classes.add(cmd[i].getDescribedType());\n+\n+            // evict from the query cache\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\n+                (q.getContext(), classes));\n+\n+            // evict from the data cache\n+            for (int i = 0; i < cmd.length; i++) {\n+                if (cmd[i].getDataCache() != null)\n+                    cmd[i].getDataCache().removeAll(\n+                        cmd[i].getDescribedType(), true);\n+            }\n+        }\n+\n+        public Number executeDelete(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeDelete(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeUpdate(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n+            Range range) {\n+            return EMPTY_STRINGS;\n+        }\n+\n+        public void validate(StoreQuery q) {\n+            _ex.validate(unwrap(q));\n+        }\n+        \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+            _ex.getRange(q, params, range); \n+        }\n+\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\n+            Object resultObject, int orderIndex) {\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\n+                orderIndex);\n+        }\n+\n+        public boolean[] getAscending(StoreQuery q) {\n+            return _ex.getAscending(unwrap(q));\n+        }\n+\n+        public boolean isPacking(StoreQuery q) {\n+            return _ex.isPacking(unwrap(q));\n+        }\n+\n+        public String getAlias(StoreQuery q) {\n+            return _ex.getAlias(unwrap(q));\n+        }\n+\n+        public Class getResultClass(StoreQuery q) {\n+            return _ex.getResultClass(unwrap(q));\n+        }\n+\n+        public String[] getProjectionAliases(StoreQuery q) {\n+            return _ex.getProjectionAliases(unwrap(q));\n+        }\n+\n+        public Class[] getProjectionTypes(StoreQuery q) {\n+            return _ex.getProjectionTypes(unwrap(q));\n+        }\n+\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\n+        }\n+\n+        public int getOperation(StoreQuery q) {\n+            return _ex.getOperation(unwrap(q));\n+        }\n+\n+        public boolean isAggregate(StoreQuery q) {\n+            return _ex.isAggregate(unwrap(q));\n+        }\n+\n+        public boolean hasGrouping(StoreQuery q) {\n+            return _ex.hasGrouping(unwrap(q));\n+        }\n+\n+        public LinkedMap getParameterTypes(StoreQuery q) {\n+            return _ex.getParameterTypes(unwrap(q));\n+        }\n+\n+        public Map getUpdates(StoreQuery q) {\n+            return _ex.getUpdates(unwrap(q));\n+        }\n+\n+        private static StoreQuery unwrap(StoreQuery q) {\n+            return ((QueryCacheStoreQuery) q).getDelegate();\n+        }\n+    }\n+\n+    /**\n+     * Result list implementation for a cached query result. Package-protected\n+     * for testing.\n+     */\n+    public static class CachedList\n+        extends AbstractList\n+        implements Serializable {\n+\n+        private final QueryResult _res;\n+        private final boolean _proj;\n+        private final StoreContext _sctx;\n+\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\n+            _res = res;\n+            _proj = proj;\n+            _sctx = ctx;\n+        }\n+\n+        public Object get(int idx) {\n+            if (!_proj)\n+                return fromObjectId(_res.get(idx), _sctx);\n+\n+            Object[] cached = (Object[]) _res.get(idx);\n+            if (cached == null)\n+                return null;\n+            Object[] uncached = new Object[cached.length];\n+            for (int i = 0; i < cached.length; i++)\n+                uncached[i] = copyProjection(cached[i], _sctx);\n+            return uncached;\n+        }\n+\n+        public int size() {\n+            return _res.size();\n+        }\n+\n+        public Object writeReplace()\n+            throws ObjectStreamException {\n+            return new ArrayList(this);\n+        }\n+    }\n+\n+    /**\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\n+     * all the OIDs in this list and registers that list with the\n+     * query cache. Abandons monitoring and registering if one of the classes\n+     * in the access path is modified while the query results are being loaded.\n+     */\n+    private class CachingResultObjectProvider\n+        implements ResultObjectProvider, TypesChangedListener {\n+\n+        private final ResultObjectProvider _rop;\n+        private final boolean _proj;\n+        private final QueryKey _qk;\n+        private final TreeMap _data = new TreeMap();\n+        private boolean _maintainCache = true;\n+        private int _pos = -1;\n+\n+        // used to determine list size without necessarily calling size(),\n+        // which may require a DB trip or return Integer.MAX_VALUE\n+        private int _max = -1;\n+        private int _size = Integer.MAX_VALUE;\n+\n+        /**\n+         * Constructor. Supply delegate result provider and our query key.\n+         */\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\n+            boolean proj, QueryKey key) {\n+            _rop = rop;\n+            _proj = proj;\n+            _qk = key;\n+            _cache.addTypesChangedListener(this);\n+        }\n+\n+        /**\n+         * Stop caching.\n+         */\n+        private void abortCaching() {\n+            if (!_maintainCache)\n+                return;\n+\n+            // this can be called via an event from another thread\n+            synchronized (this) {\n+                // it's important that we set this flag first so that any\n+                // subsequent calls to this object are bypassed.\n+                _maintainCache = false;\n+                _cache.removeTypesChangedListener(this);\n+                _data.clear();\n+            }\n+        }\n+\n+        /**\n+         * Check whether we've buffered all results, while optionally adding\n+         * the given result.\n+         */\n+        private void checkFinished(Object obj, boolean result) {\n+            // this can be called at the same time as abortCaching via\n+            // a types changed event\n+            boolean finished = false;\n+            synchronized (this) {\n+                if (_maintainCache) {\n+                    if (result) {\n+                        Integer index = Numbers.valueOf(_pos);\n+                        if (!_data.containsKey(index)) {\n+                            Object cached;\n+                            if (obj == null)\n+                                cached = null;\n+                            else if (!_proj)\n+                                cached = _sctx.getObjectId(obj);\n+                            else {\n+                                Object[] arr = (Object[]) obj;\n+                                Object[] cp = new Object[arr.length];\n+                                for (int i = 0; i < arr.length; i++)\n+                                    cp[i] = copyProjection(arr[i], _sctx);\n+                                cached = cp;\n+                            }\n+                            if (cached != null)\n+                                _data.put(index, cached);\n+                        }\n+                    }\n+                    finished = _size == _data.size();\n+                }\n+            }\n+\n+            if (finished) {\n+                // an abortCaching call can sneak in here via onExpire; the\n+                // cache is locked during event firings, so the lock here will\n+                // wait for it (or will force the next firing to wait)\n+                _cache.writeLock();\n+                try {\n+                    // make sure we didn't abort\n+                    if (_maintainCache) {\n+                        QueryResult res = null;\n+                        synchronized (this) {\n+                            res = new QueryResult(_qk, _data.values());\n+                        }\n+                        _cache.put(_qk, res);\n+                        abortCaching();\n+                    }\n+                }\n+                finally {\n+                    _cache.writeUnlock();\n+                }\n+            }\n+        }\n+\n+        public boolean supportsRandomAccess() {\n+            return _rop.supportsRandomAccess();\n+        }\n+\n+        public void open()\n+            throws Exception {\n+            _rop.open();\n+        }\n+\n+        public Object getResultObject()\n+            throws Exception {\n+            Object obj = _rop.getResultObject();\n+            checkFinished(obj, true);\n+            return obj;\n+        }\n+\n+        public boolean next()\n+            throws Exception {\n+            _pos++;\n+            boolean next = _rop.next();\n+            if (!next && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (next && _pos > _max)\n+                _max = _pos;\n+            return next;\n+        }\n+\n+        public boolean absolute(int pos)\n+            throws Exception {\n+            _pos = pos;\n+            boolean valid = _rop.absolute(pos);\n+            if (!valid && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (valid && _pos > _max)\n+                _max = _pos;\n+            return valid;\n+        }\n+\n+        public int size()\n+            throws Exception {\n+            if (_size != Integer.MAX_VALUE)\n+                return _size;\n+            int size = _rop.size();\n+            _size = size;\n+            checkFinished(null, false);\n+            return size;\n+        }\n+\n+        public void reset()\n+            throws Exception {\n+            _rop.reset();\n+            _pos = -1;\n+        }\n+\n+        public void close()\n+            throws Exception {\n+            abortCaching();\n+            _rop.close();\n+        }\n+\n+        public void handleCheckedException(Exception e) {\n+            _rop.handleCheckedException(e);\n+        }\n+\n+        public void onTypesChanged(TypesChangedEvent ev) {\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\n+                abortCaching();\n+        }\n+    }\n+\n+    /**\n+     * Struct to recognize cached oids.\n+     */\n+    private static class CachedObjectId {\n+\n+        public final Object oid;\n+\n+        public CachedObjectId (Object oid)\n+\t\t{\n+\t\t\tthis.oid = oid;\n+\t\t}\n+\t}\n+}"},{"sha":"3904232254b3c6af09c6ebad37e46f7795acdc6f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can convert a positional index for a\r\n- * {@link FieldMetaData} that uses property access into the underlying\r\n- * field name. Instances of {@link DynamicPersistenceCapable} for types\r\n- * that use property access will implement this interface.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface AttributeTranslator {\r\n-    public String pcAttributeIndexToFieldName(int i);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can convert a positional index for a\n+ * {@link FieldMetaData} that uses property access into the underlying\n+ * field name. Instances of {@link DynamicPersistenceCapable} for types\n+ * that use property access will implement this interface.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface AttributeTranslator {\n+    public String pcAttributeIndexToFieldName(int i);\n+}"},{"sha":"66fa6057c6af1df883d1dd1b1114f7b6f974c7a4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.instrument.Instrumentation;\r\n-import java.lang.instrument.ClassFileTransformer;\r\n-import java.lang.instrument.ClassDefinition;\r\n-import java.lang.instrument.UnmodifiableClassException;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.Method;\r\n-import java.security.ProtectionDomain;\r\n-import java.util.Map;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.ArrayList;\r\n-import java.io.IOException;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing classes. Supports Java 5 VMs that\r\n- * have a javaagent installed on the command line as well as newer VMs without\r\n- * any javaagent flag.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ClassRedefiner {\r\n-\r\n-    private static final Localizer _loc = \r\n-        Localizer.forPackage(ClassRedefiner.class);\r\n-\r\n-    private static Boolean _canRedefine = null;\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, this method will redefine\r\n-     * all the element's methods such that field accesses are intercepted\r\n-     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\r\n-     * this method is a no-op.\r\n-     */\r\n-    public static void redefineClasses(OpenJPAConfiguration conf,\r\n-        final Map<Class,byte[]> classes) {\r\n-        if (classes == null || classes.size() == 0 || !canRedefineClasses())\r\n-            return;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        Instrumentation inst = null;\r\n-        ClassFileTransformer t = null;\r\n-        try {\r\n-            inst = InstrumentationFactory.getInstrumentation();\r\n-\r\n-            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\r\n-            if (JavaVersions.VERSION >= 6) {\r\n-                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\r\n-\r\n-                t = new ClassFileTransformer() {\r\n-                    public byte[] transform(ClassLoader loader, String clsName,\r\n-                        Class<?> classBeingRedefined, ProtectionDomain pd,\r\n-                        byte[] classfileBuffer) {\r\n-                        return classes.get(classBeingRedefined);\r\n-                    }\r\n-                };\r\n-                \r\n-                // these are Java 6 methods, and we don't have a Java 6 build\r\n-                // module yet. The cost of reflection here is negligible\r\n-                // compared to the redefinition / enhancement costs in total,\r\n-                // so this should not be a big problem.\r\n-                Method meth = inst.getClass().getMethod(\"addTransformer\",\r\n-                    new Class[] { ClassFileTransformer.class, boolean.class });\r\n-                meth.invoke(inst, new Object[] { t, true });\r\n-                meth = inst.getClass().getMethod(\"retransformClasses\",\r\n-                    new Class[] { array.getClass() });\r\n-                meth.invoke(inst, new Object[] { array });\r\n-            } else {\r\n-                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\r\n-                // in a Java 5 context, we can use class redefinition instead\r\n-                ClassDefinition[] defs = new ClassDefinition[array.length];\r\n-                for (int i = 0; i < defs.length; i++)\r\n-                    defs[i] = new ClassDefinition(array[i],\r\n-                        classes.get(array[i]));\r\n-                inst.redefineClasses(defs);\r\n-            }\r\n-        } catch (NoSuchMethodException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (IllegalAccessException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (InvocationTargetException e) {\r\n-            throw new UserException(e.getCause());\r\n-        } catch (IOException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (UnmodifiableClassException e) {\r\n-            throw new InternalException(e);\r\n-        } finally {\r\n-            if (inst != null && t != null)\r\n-                inst.removeTransformer(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return whether or not this VM has an instrumentation installed that\r\n-     * permits redefinition of classes. This assumes that all the arguments\r\n-     * will be modifiable classes according to\r\n-     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\r\n-     * only checks whether or not an instrumentation is available and\r\n-     * if retransformation is possible.\r\n-     */\r\n-    public static boolean canRedefineClasses() {\r\n-        if (_canRedefine == null) {\r\n-            try {\r\n-                Instrumentation inst = InstrumentationFactory\r\n-                    .getInstrumentation();\r\n-                if (inst == null) {\r\n-                    _canRedefine = Boolean.FALSE;\r\n-                } else if (JavaVersions.VERSION == 5) {\r\n-                    // if inst is non-null and we're using Java 5,\r\n-                    // isRetransformClassesSupported isn't available,\r\n-                    // so we use the more basic class redefinition\r\n-                    // instead.\r\n-                    _canRedefine = Boolean.TRUE;\r\n-                } else {\r\n-                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\r\n-                        \"isRetransformClassesSupported\").invoke(inst);\r\n-                }\r\n-            } catch (Exception e) {\r\n-                _canRedefine = Boolean.FALSE;\r\n-            }\r\n-        }\r\n-        return _canRedefine.booleanValue();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.ClassDefinition;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Redefines the method bodies of existing classes. Supports Java 5 VMs that\n+ * have a javaagent installed on the command line as well as newer VMs without\n+ * any javaagent flag.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ClassRedefiner {\n+\n+    private static final Localizer _loc = \n+        Localizer.forPackage(ClassRedefiner.class);\n+\n+    private static Boolean _canRedefine = null;\n+\n+    /**\n+     * For each element in <code>classes</code>, this method will redefine\n+     * all the element's methods such that field accesses are intercepted\n+     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\n+     * this method is a no-op.\n+     */\n+    public static void redefineClasses(OpenJPAConfiguration conf,\n+        final Map<Class,byte[]> classes) {\n+        if (classes == null || classes.size() == 0 || !canRedefineClasses())\n+            return;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        Instrumentation inst = null;\n+        ClassFileTransformer t = null;\n+        try {\n+            inst = InstrumentationFactory.getInstrumentation();\n+\n+            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\n+            if (JavaVersions.VERSION >= 6) {\n+                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\n+\n+                t = new ClassFileTransformer() {\n+                    public byte[] transform(ClassLoader loader, String clsName,\n+                        Class<?> classBeingRedefined, ProtectionDomain pd,\n+                        byte[] classfileBuffer) {\n+                        return classes.get(classBeingRedefined);\n+                    }\n+                };\n+                \n+                // these are Java 6 methods, and we don't have a Java 6 build\n+                // module yet. The cost of reflection here is negligible\n+                // compared to the redefinition / enhancement costs in total,\n+                // so this should not be a big problem.\n+                Method meth = inst.getClass().getMethod(\"addTransformer\",\n+                    new Class[] { ClassFileTransformer.class, boolean.class });\n+                meth.invoke(inst, new Object[] { t, true });\n+                meth = inst.getClass().getMethod(\"retransformClasses\",\n+                    new Class[] { array.getClass() });\n+                meth.invoke(inst, new Object[] { array });\n+            } else {\n+                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\n+                // in a Java 5 context, we can use class redefinition instead\n+                ClassDefinition[] defs = new ClassDefinition[array.length];\n+                for (int i = 0; i < defs.length; i++)\n+                    defs[i] = new ClassDefinition(array[i],\n+                        classes.get(array[i]));\n+                inst.redefineClasses(defs);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new InternalException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new UserException(e.getCause());\n+        } catch (IOException e) {\n+            throw new InternalException(e);\n+        } catch (ClassNotFoundException e) {\n+            throw new InternalException(e);\n+        } catch (UnmodifiableClassException e) {\n+            throw new InternalException(e);\n+        } finally {\n+            if (inst != null && t != null)\n+                inst.removeTransformer(t);\n+        }\n+    }\n+\n+    /**\n+     * @return whether or not this VM has an instrumentation installed that\n+     * permits redefinition of classes. This assumes that all the arguments\n+     * will be modifiable classes according to\n+     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\n+     * only checks whether or not an instrumentation is available and\n+     * if retransformation is possible.\n+     */\n+    public static boolean canRedefineClasses() {\n+        if (_canRedefine == null) {\n+            try {\n+                Instrumentation inst = InstrumentationFactory\n+                    .getInstrumentation();\n+                if (inst == null) {\n+                    _canRedefine = Boolean.FALSE;\n+                } else if (JavaVersions.VERSION == 5) {\n+                    // if inst is non-null and we're using Java 5,\n+                    // isRetransformClassesSupported isn't available,\n+                    // so we use the more basic class redefinition\n+                    // instead.\n+                    _canRedefine = Boolean.TRUE;\n+                } else {\n+                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\n+                        \"isRetransformClassesSupported\").invoke(inst);\n+                }\n+            } catch (Exception e) {\n+                _canRedefine = Boolean.FALSE;\n+            }\n+        }\n+        return _canRedefine.booleanValue();\n+    }\n }\n\\ No newline at end of file"},{"sha":"78614624c6c833d8ecaa23f13903ad1c11a50d5a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances that implement this marker interface are dynamically-generated\r\n- * subtypes of managed types that were loaded before being enhanced.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface DynamicPersistenceCapable {\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances that implement this marker interface are dynamically-generated\n+ * subtypes of managed types that were loaded before being enhanced.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface DynamicPersistenceCapable {\n+}"},{"sha":"f7f4d44cffc234752c58d0975cdd1e6a1f203eab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":302,"deletions":302,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,302 +1,302 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.BytecodeWriter;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Files;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.GeneratedClasses;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.bytecode.BCClass;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing unenhanced classes to make them\r\n- * notify state managers of mutations.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ManagedClassSubclasser {\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        ManagedClassSubclasser.class);\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, creates and registers a\r\n-     * new subclass that implements {@link PersistenceCapable}, and prepares\r\n-     * OpenJPA to handle new instances of the unenhanced type. If this is\r\n-     * invoked in a Java 6 environment, this method will redefine the methods\r\n-     * for each class in the argument list such that field accesses are\r\n-     * intercepted in-line. If invoked in a Java 5 environment, this\r\n-     * redefinition is not possible; in these contexts, when using field\r\n-     * access, OpenJPA will need to do state comparisons to detect any change\r\n-     * to any instance at any time, and when using property access, OpenJPA\r\n-     * will need to do state comparisons to detect changes to newly inserted\r\n-     * instances after a flush has been called.\r\n-     *\r\n-     * @return the new subclasses, or <code>null</code> if <code>classes</code>\r\n-     * is <code>null</code>.\r\n-     * @throws UserException if <code>conf</code> requires build-time\r\n-     * enhancement and <code>classes</code> includes unenhanced types.\r\n-     *\r\n-     * @since 1.0.0\r\n-     */\r\n-    public static List<Class> prepareUnenhancedClasses(\r\n-        final OpenJPAConfiguration conf,\r\n-        final Collection<? extends Class> classes,\r\n-        final ClassLoader envLoader) {\r\n-        if (classes == null)\r\n-            return null;\r\n-        if (classes.size() == 0)\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        if (conf.getRuntimeUnenhancedClassesConstant()\r\n-            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\r\n-            Collection unenhanced = new ArrayList();\r\n-            for (Class cls : classes)\r\n-                if (!PersistenceCapable.class.isAssignableFrom(cls))\r\n-                    unenhanced.add(cls);\r\n-            if (unenhanced.size() > 0) {\r\n-                Message msg = _loc.get(\"runtime-optimization-disabled\",\r\n-                    unenhanced);\r\n-                if (conf.getRuntimeUnenhancedClassesConstant()\r\n-                    == RuntimeUnenhancedClasssesModes.WARN)\r\n-                    log.warn(msg);\r\n-                else\r\n-                    throw new UserException(msg);\r\n-            }\r\n-            return null;\r\n-        }\r\n-\r\n-        boolean redefine = ClassRedefiner.canRedefineClasses();\r\n-        if (redefine)\r\n-            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\r\n-                classes));\r\n-        else\r\n-            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\r\n-                classes));\r\n-\r\n-        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\r\n-        final List subs = new ArrayList(classes.size());\r\n-        final List ints = new ArrayList(classes.size());\r\n-        Set<Class> unspecified = null;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n-            final Class cls = (Class) iter.next();\r\n-            final PCEnhancer enhancer = new PCEnhancer(conf, cls); \r\n-\r\n-            enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n-                public void write(BCClass bc) throws IOException {\r\n-                    ManagedClassSubclasser.write(bc, enhancer, map,\r\n-                        cls, subs, ints);\r\n-                }\r\n-            });\r\n-            if (redefine)\r\n-                enhancer.setRedefine(true);\r\n-            enhancer.setCreateSubclass(true);\r\n-            enhancer.setAddDefaultConstructor(true);\r\n-\r\n-            // set this before enhancement as well as after since enhancement\r\n-            // uses a different metadata repository, and the metadata config\r\n-            // matters in the enhancement contract. Don't do any warning here,\r\n-            // since we'll issue warnings when we do the final metadata\r\n-            // reconfiguration at the end of this method.\r\n-            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\r\n-\r\n-            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\r\n-                classes, unspecified);\r\n-\r\n-            int runResult = enhancer.run();\r\n-            if (runResult == PCEnhancer.ENHANCE_PC) {\r\n-                try {\r\n-                    enhancer.record();\r\n-                } catch (IOException e) {\r\n-                    // our impl of BytecodeWriter doesn't throw IOException\r\n-                    throw new InternalException(e);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        if (unspecified != null && !unspecified.isEmpty())\r\n-            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\r\n-                classes, unspecified));\r\n-\r\n-        ClassRedefiner.redefineClasses(conf, map);\r\n-        for (Class cls : map.keySet()) {\r\n-            setIntercepting(conf, envLoader, cls);\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        }\r\n-        for (Class cls : (Collection<Class>) subs)\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        for (Class cls : (Collection<Class>) ints)\r\n-            setIntercepting(conf, envLoader, cls);\r\n-\r\n-        return subs;\r\n-    }\r\n-\r\n-    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\r\n-            unspecified);\r\n-\r\n-        for (FieldMetaData fmd : meta.getFields()) {\r\n-            if (fmd.isTransient())\r\n-                continue;\r\n-            if (fmd.isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getType(), classes,\r\n-                    unspecified);\r\n-            if (fmd.getElement() != null && fmd.getElement().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getKey() != null && fmd.getKey().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getValue() != null && fmd.getValue().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\r\n-                    classes, unspecified);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static Set<Class> collectUnspecifiedType(Class cls,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        if (cls != null && !classes.contains(cls)\r\n-            && !ImplHelper.isManagedType(null, cls)) {\r\n-            if (unspecified == null)\r\n-                unspecified = new HashSet<Class>();\r\n-            unspecified.add(cls);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static void configureMetaData(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        configureMetaData(meta, conf, redefineAvailable, true);\r\n-    }\r\n-\r\n-    private static void configureMetaData(ClassMetaData meta,\r\n-        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\r\n-\r\n-        setDetachedState(meta);\r\n-\r\n-        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\r\n-            && !redefineAvailable) {\r\n-            // only warn about declared fields; superclass fields will be\r\n-            // warned about when the superclass is handled\r\n-            for (FieldMetaData fmd : meta.getDeclaredFields()) {\r\n-                switch (fmd.getTypeCode()) {\r\n-                    case JavaTypes.COLLECTION:\r\n-                    case JavaTypes.MAP:\r\n-                        // we can lazily load these, since we own the\r\n-                        // relationship container\r\n-                        break;\r\n-                    default:\r\n-                        if (!fmd.isInDefaultFetchGroup()\r\n-                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\r\n-                            Log log = conf.getLog(\r\n-                                OpenJPAConfiguration.LOG_ENHANCE);\r\n-                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\r\n-                                meta.getDescribedType().getName(),\r\n-                                fmd.getName()));\r\n-                            fmd.setInDefaultFetchGroup(true);\r\n-                        }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void write(BCClass bc, PCEnhancer enhancer,\r\n-        Map<Class, byte[]> map, Class cls, List subs, List ints)\r\n-        throws IOException {\r\n-\r\n-        if (bc == enhancer.getManagedTypeBytecode()) {\r\n-            // if it was already defined, don't put it in the map,\r\n-            // but do set the metadata accordingly.\r\n-            if (enhancer.isAlreadyRedefined())\r\n-                ints.add(bc.getType());\r\n-            else if (JavaVersions.VERSION >= 5) {\r\n-                map.put(bc.getType(), bc.toByteArray());\r\n-                debugBytecodes(bc);\r\n-            }\r\n-        } else {\r\n-            if (!enhancer.isAlreadySubclassed()) {\r\n-                debugBytecodes(bc);\r\n-                \r\n-                // this is the new subclass\r\n-                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\r\n-                    cls, PersistenceCapable.class);\r\n-                subs.add(GeneratedClasses.loadBCClass(bc, loader));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void debugBytecodes(BCClass bc) throws IOException {\r\n-        // Write the bytecodes to disk for debugging purposes.\r\n-        if (\"true\".equals(System.getProperty(\r\n-            ManagedClassSubclasser.class.getName() + \".dumpBytecodes\")))\r\n-        {\r\n-            File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\r\n-            File dir = new File(tmp, \"openjpa\");\r\n-            dir = new File(dir, \"pcsubclasses\");\r\n-            dir.mkdirs();\r\n-            dir = Files.getPackageFile(dir, bc.getPackageName(), true);\r\n-            File f = new File(dir, bc.getClassName() + \".class\");\r\n-            System.err.println(\"Writing to \" + f);\r\n-            bc.write(f);\r\n-        }\r\n-    }\r\n-\r\n-    private static void setIntercepting(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        meta.setIntercepting(true);\r\n-    }\r\n-\r\n-    /**\r\n-     * If the metadata is configured to use a synthetic\r\n-     * detached state, reset it to not use a detached\r\n-     * state field, since we can't add fields when redefining.\r\n-     */\r\n-    private static void setDetachedState(ClassMetaData meta) {\r\n-        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\r\n-            meta.setDetachedState(null);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.BytecodeWriter;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.GeneratedClasses;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+import serp.bytecode.BCClass;\n+\n+/**\n+ * Redefines the method bodies of existing unenhanced classes to make them\n+ * notify state managers of mutations.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ManagedClassSubclasser {\n+    private static final Localizer _loc = Localizer.forPackage(\n+        ManagedClassSubclasser.class);\n+\n+    /**\n+     * For each element in <code>classes</code>, creates and registers a\n+     * new subclass that implements {@link PersistenceCapable}, and prepares\n+     * OpenJPA to handle new instances of the unenhanced type. If this is\n+     * invoked in a Java 6 environment, this method will redefine the methods\n+     * for each class in the argument list such that field accesses are\n+     * intercepted in-line. If invoked in a Java 5 environment, this\n+     * redefinition is not possible; in these contexts, when using field\n+     * access, OpenJPA will need to do state comparisons to detect any change\n+     * to any instance at any time, and when using property access, OpenJPA\n+     * will need to do state comparisons to detect changes to newly inserted\n+     * instances after a flush has been called.\n+     *\n+     * @return the new subclasses, or <code>null</code> if <code>classes</code>\n+     * is <code>null</code>.\n+     * @throws UserException if <code>conf</code> requires build-time\n+     * enhancement and <code>classes</code> includes unenhanced types.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static List<Class> prepareUnenhancedClasses(\n+        final OpenJPAConfiguration conf,\n+        final Collection<? extends Class> classes,\n+        final ClassLoader envLoader) {\n+        if (classes == null)\n+            return null;\n+        if (classes.size() == 0)\n+            return Collections.EMPTY_LIST;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        if (conf.getRuntimeUnenhancedClassesConstant()\n+            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\n+            Collection unenhanced = new ArrayList();\n+            for (Class cls : classes)\n+                if (!PersistenceCapable.class.isAssignableFrom(cls))\n+                    unenhanced.add(cls);\n+            if (unenhanced.size() > 0) {\n+                Message msg = _loc.get(\"runtime-optimization-disabled\",\n+                    unenhanced);\n+                if (conf.getRuntimeUnenhancedClassesConstant()\n+                    == RuntimeUnenhancedClasssesModes.WARN)\n+                    log.warn(msg);\n+                else\n+                    throw new UserException(msg);\n+            }\n+            return null;\n+        }\n+\n+        boolean redefine = ClassRedefiner.canRedefineClasses();\n+        if (redefine)\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\n+                classes));\n+        else\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\n+                classes));\n+\n+        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\n+        final List subs = new ArrayList(classes.size());\n+        final List ints = new ArrayList(classes.size());\n+        Set<Class> unspecified = null;\n+        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\n+            final Class cls = (Class) iter.next();\n+            final PCEnhancer enhancer = new PCEnhancer(conf, cls); \n+\n+            enhancer.setBytecodeWriter(new BytecodeWriter() {\n+                public void write(BCClass bc) throws IOException {\n+                    ManagedClassSubclasser.write(bc, enhancer, map,\n+                        cls, subs, ints);\n+                }\n+            });\n+            if (redefine)\n+                enhancer.setRedefine(true);\n+            enhancer.setCreateSubclass(true);\n+            enhancer.setAddDefaultConstructor(true);\n+\n+            // set this before enhancement as well as after since enhancement\n+            // uses a different metadata repository, and the metadata config\n+            // matters in the enhancement contract. Don't do any warning here,\n+            // since we'll issue warnings when we do the final metadata\n+            // reconfiguration at the end of this method.\n+            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\n+\n+            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\n+                classes, unspecified);\n+\n+            int runResult = enhancer.run();\n+            if (runResult == PCEnhancer.ENHANCE_PC) {\n+                try {\n+                    enhancer.record();\n+                } catch (IOException e) {\n+                    // our impl of BytecodeWriter doesn't throw IOException\n+                    throw new InternalException(e);\n+                }\n+            }\n+        }\n+\n+        if (unspecified != null && !unspecified.isEmpty())\n+            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\n+                classes, unspecified));\n+\n+        ClassRedefiner.redefineClasses(conf, map);\n+        for (Class cls : map.keySet()) {\n+            setIntercepting(conf, envLoader, cls);\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        }\n+        for (Class cls : (Collection<Class>) subs)\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        for (Class cls : (Collection<Class>) ints)\n+            setIntercepting(conf, envLoader, cls);\n+\n+        return subs;\n+    }\n+\n+    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\n+            unspecified);\n+\n+        for (FieldMetaData fmd : meta.getFields()) {\n+            if (fmd.isTransient())\n+                continue;\n+            if (fmd.isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getType(), classes,\n+                    unspecified);\n+            if (fmd.getElement() != null && fmd.getElement().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\n+                    classes, unspecified);\n+            if (fmd.getKey() != null && fmd.getKey().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\n+                    classes, unspecified);\n+            if (fmd.getValue() != null && fmd.getValue().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\n+                    classes, unspecified);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static Set<Class> collectUnspecifiedType(Class cls,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        if (cls != null && !classes.contains(cls)\n+            && !ImplHelper.isManagedType(null, cls)) {\n+            if (unspecified == null)\n+                unspecified = new HashSet<Class>();\n+            unspecified.add(cls);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static void configureMetaData(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        configureMetaData(meta, conf, redefineAvailable, true);\n+    }\n+\n+    private static void configureMetaData(ClassMetaData meta,\n+        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\n+\n+        setDetachedState(meta);\n+\n+        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\n+            && !redefineAvailable) {\n+            // only warn about declared fields; superclass fields will be\n+            // warned about when the superclass is handled\n+            for (FieldMetaData fmd : meta.getDeclaredFields()) {\n+                switch (fmd.getTypeCode()) {\n+                    case JavaTypes.COLLECTION:\n+                    case JavaTypes.MAP:\n+                        // we can lazily load these, since we own the\n+                        // relationship container\n+                        break;\n+                    default:\n+                        if (!fmd.isInDefaultFetchGroup()\n+                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\n+                            Log log = conf.getLog(\n+                                OpenJPAConfiguration.LOG_ENHANCE);\n+                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\n+                                meta.getDescribedType().getName(),\n+                                fmd.getName()));\n+                            fmd.setInDefaultFetchGroup(true);\n+                        }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void write(BCClass bc, PCEnhancer enhancer,\n+        Map<Class, byte[]> map, Class cls, List subs, List ints)\n+        throws IOException {\n+\n+        if (bc == enhancer.getManagedTypeBytecode()) {\n+            // if it was already defined, don't put it in the map,\n+            // but do set the metadata accordingly.\n+            if (enhancer.isAlreadyRedefined())\n+                ints.add(bc.getType());\n+            else if (JavaVersions.VERSION >= 5) {\n+                map.put(bc.getType(), bc.toByteArray());\n+                debugBytecodes(bc);\n+            }\n+        } else {\n+            if (!enhancer.isAlreadySubclassed()) {\n+                debugBytecodes(bc);\n+                \n+                // this is the new subclass\n+                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\n+                    cls, PersistenceCapable.class);\n+                subs.add(GeneratedClasses.loadBCClass(bc, loader));\n+            }\n+        }\n+    }\n+\n+    private static void debugBytecodes(BCClass bc) throws IOException {\n+        // Write the bytecodes to disk for debugging purposes.\n+        if (\"true\".equals(System.getProperty(\n+            ManagedClassSubclasser.class.getName() + \".dumpBytecodes\")))\n+        {\n+            File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\n+            File dir = new File(tmp, \"openjpa\");\n+            dir = new File(dir, \"pcsubclasses\");\n+            dir.mkdirs();\n+            dir = Files.getPackageFile(dir, bc.getPackageName(), true);\n+            File f = new File(dir, bc.getClassName() + \".class\");\n+            System.err.println(\"Writing to \" + f);\n+            bc.write(f);\n+        }\n+    }\n+\n+    private static void setIntercepting(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        meta.setIntercepting(true);\n+    }\n+\n+    /**\n+     * If the metadata is configured to use a synthetic\n+     * detached state, reset it to not use a detached\n+     * state field, since we can't add fields when redefining.\n+     */\n+    private static void setDetachedState(ClassMetaData meta) {\n+        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\n+            meta.setDetachedState(null);\n+    }\n+}"},{"sha":"ebdd746c8638de5766fb5d0add78c927b6d4b0fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can provide an underlying instance.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface ManagedInstanceProvider {\r\n-    public Object getManagedInstance();\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can provide an underlying instance.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface ManagedInstanceProvider {\n+    public Object getManagedInstance();\n+}"},{"sha":"dd95fa2373bcaeb3004ad6b707946bd68f72d661","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1077,"deletions":1077,"changes":2154,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,1077 +1,1077 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.AbstractPCData;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCData;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCMethod;\r\n-import serp.bytecode.Code;\r\n-import serp.bytecode.Constants;\r\n-import serp.bytecode.ExceptionHandler;\r\n-import serp.bytecode.Instruction;\r\n-import serp.bytecode.JumpInstruction;\r\n-import serp.bytecode.LookupSwitchInstruction;\r\n-\r\n-/**\r\n- * Generates {@link PCData} instances which avoid primitve wrappers\r\n- * to optimize memory use and performance at the cost of slightly higher\r\n- * startup time.\r\n- *\r\n- * @author Steve Kim\r\n- * @nojavadoc\r\n- * @since 0.3.2\r\n- */\r\n-public class PCDataGenerator\r\n-    extends DynamicStorageGenerator {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (PCDataGenerator.class);\r\n-\r\n-    protected static final String POSTFIX = \"$openjpapcdata\";\r\n-\r\n-    private final Map _generated = new ConcurrentHashMap();\r\n-    private final OpenJPAConfiguration _conf;\r\n-    private final Log _log;\r\n-\r\n-    public PCDataGenerator(OpenJPAConfiguration conf) {\r\n-        _conf = conf;\r\n-        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the configuration.\r\n-     */\r\n-    public OpenJPAConfiguration getConfiguration() {\r\n-        return _conf;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a {@link PCData} instance for the given oid and metadata.\r\n-     */\r\n-    public PCData generatePCData(Object oid, ClassMetaData meta) {\r\n-        if (meta == null)\r\n-            return null;\r\n-        Class type = meta.getDescribedType();\r\n-        DynamicStorage storage = (DynamicStorage) _generated.get(type);\r\n-        if (storage == null) {\r\n-            storage = generateStorage(meta);\r\n-            _generated.put(type, storage);\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\r\n-        }\r\n-        DynamicPCData data = (DynamicPCData) storage.newInstance();\r\n-        data.setId(oid);\r\n-        data.setStorageGenerator(this);\r\n-        finish(data, meta);\r\n-        return data;\r\n-    }\r\n-\r\n-    /**\r\n-     * Actually generate the factory instance.\r\n-     */\r\n-    private DynamicStorage generateStorage(ClassMetaData meta) {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"pcdata-generate\", meta));\r\n-\r\n-        FieldMetaData[] fields = meta.getFields();\r\n-        int[] types = new int[fields.length];\r\n-        for (int i = 0; i < types.length; i++)\r\n-            types[i] = replaceType(fields[i]);\r\n-        return generateStorage(types, meta);\r\n-    }\r\n-\r\n-    /**\r\n-     * Perform any final actions before the pcdata is returned to client code.\r\n-     */\r\n-    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n-    }\r\n-\r\n-    protected int getCreateFieldMethods(int typeCode) {\r\n-        if (typeCode >= JavaTypes.OBJECT)\r\n-            return POLICY_SILENT;\r\n-        // don't bother creating set/get<Primitive> methods\r\n-        return POLICY_EMPTY;\r\n-    }\r\n-\r\n-    protected void declareClasses(BCClass bc) {\r\n-        super.declareClasses(bc);\r\n-        bc.declareInterface(DynamicPCData.class);\r\n-        bc.setSuperclass(AbstractPCData.class);\r\n-    }\r\n-\r\n-    protected final String getClassName(Object obj) {\r\n-        return getUniqueName(((ClassMetaData) obj).getDescribedType());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a unique name for the given type's pcdata implementation.\r\n-     */\r\n-    protected String getUniqueName(Class type) {\r\n-        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\r\n-    }\r\n-\r\n-    protected final void decorate(Object obj, BCClass bc, int[] types) {\r\n-        super.decorate(obj, bc, types);\r\n-        ClassMetaData meta = (ClassMetaData) obj;\r\n-\r\n-        enhanceConstructor(bc);\r\n-        addBaseFields(bc);\r\n-        addImplDataMethods(bc, meta);\r\n-        addFieldImplDataMethods(bc, meta);\r\n-        addVersionMethods(bc);\r\n-        addGetType(bc, meta);\r\n-        addLoadMethod(bc, meta);\r\n-        addLoadWithFieldsMethod(bc, meta);\r\n-        addStoreMethods(bc, meta);\r\n-        addNewEmbedded(bc);\r\n-        addGetData(bc);\r\n-        decorate(bc, meta);\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply additional decoration to generated class.\r\n-     */\r\n-    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n-    }\r\n-\r\n-    /**\r\n-     * Enhance constructor to initialize fields\r\n-     */\r\n-    private void enhanceConstructor(BCClass bc) {\r\n-        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\r\n-        Code code = cons.getCode(false);\r\n-        code.afterLast();\r\n-        code.previous();\r\n-\r\n-        // private BitSet loaded = new BitSet();\r\n-        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\r\n-        loaded.setFinal(true);\r\n-        code.aload().setThis();\r\n-        code.anew().setType(BitSet.class);\r\n-        code.dup();\r\n-        code.constant().setValue(bc.getFields().length);\r\n-        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\r\n-            new Class[]{ int.class });\r\n-        code.putfield().setField(loaded);\r\n-\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Have to load the type since it may not be available to the\r\n-     * same classloader (i.e. rar vs. ear). The context classloader\r\n-     * (i.e. the user app classloader) should be fine.\r\n-     */\r\n-    private void addGetType(BCClass bc, ClassMetaData meta) {\r\n-        BCField type = bc.declareField(\"type\", Class.class);\r\n-        type.setStatic(true);\r\n-        type.makePrivate();\r\n-        // public Class getType() {\r\n-        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\r\n-        getter.makePublic();\r\n-        Code code = getter.getCode(true);\r\n-        // if (type == null) {\r\n-        // \t\ttry {\r\n-        // \t\t\ttype = Class.forName\r\n-        // \t\t\t\t(meta.getDescribedType().getName(), true,\r\n-        // \t\t\t\tThread.currentThread().getContextClassLoader());\r\n-        // \t\t} catch (ClassNotFoundException cnfe) {\r\n-        // \t\t\tthrow new InternalException();\r\n-        // \t\t}\r\n-        // }\r\n-        code.getstatic().setField(type);\r\n-\r\n-        Collection jumps = new LinkedList();\r\n-        jumps.add(code.ifnonnull());\r\n-        ExceptionHandler handler = code.addExceptionHandler();\r\n-\r\n-        handler.setTryStart(code.constant().setValue\r\n-            (meta.getDescribedType().getName()));\r\n-        code.constant().setValue(true);\r\n-        code.invokestatic().setMethod(Thread.class, \"currentThread\",\r\n-            Thread.class, null);\r\n-        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\r\n-            ClassLoader.class, null);\r\n-        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\r\n-            new Class[]{ String.class, boolean.class, ClassLoader.class });\r\n-        code.putstatic().setField(type);\r\n-        Instruction go2 = code.go2();\r\n-        jumps.add(go2);\r\n-        handler.setTryEnd(go2);\r\n-        handler.setCatch(ClassNotFoundException.class);\r\n-        handler.setHandlerStart(throwException\r\n-            (code, InternalException.class));\r\n-        setTarget(code.getstatic().setField(type), jumps);\r\n-        code.areturn();\r\n-\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Declare standard dynamic pcdata fields.\r\n-     */\r\n-    private void addBaseFields(BCClass bc) {\r\n-        addBeanField(bc, \"id\", Object.class);\r\n-        BCField field = addBeanField(bc, \"storageGenerator\",\r\n-            PCDataGenerator.class);\r\n-        field.setAccessFlags(field.getAccessFlags()\r\n-            | Constants.ACCESS_TRANSIENT);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing class-level impl data.\r\n-     */\r\n-    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n-        // void storeImplData(OpenJPAStateManager);\r\n-        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        BCField impl = null;\r\n-        if (!usesImplData(meta))\r\n-            code.vreturn();\r\n-        else {\r\n-            // if (sm.isImplDataCacheable())\r\n-            // \t\tsetImplData(sm.getImplData());\r\n-            impl = addBeanField(bc, \"implData\", Object.class);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"isImplDataCacheable\", boolean.class, null);\r\n-            JumpInstruction ifins = code.ifeq();\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, null);\r\n-            code.invokevirtual().setMethod(\"setImplData\", void.class,\r\n-                new Class[]{ Object.class });\r\n-            ifins.setTarget(code.vreturn());\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-\r\n-        // void loadImplData(OpenJPAStateManager);\r\n-        meth = bc.declareMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        code = meth.getCode(true);\r\n-        if (!usesImplData(meta))\r\n-            code.vreturn();\r\n-        else {\r\n-            // if (sm.getImplData() == null && implData != null)\r\n-            // \t\tsm.setImplData(impl, true);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, null);\r\n-            JumpInstruction ifins = code.ifnonnull();\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            JumpInstruction ifins2 = code.ifnull();\r\n-            code.aload().setParam(0);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            code.constant().setValue(true);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"setImplData\", void.class,\r\n-                new Class[]{ Object.class, boolean.class });\r\n-            Instruction ins = code.vreturn();\r\n-            ifins.setTarget(ins);\r\n-            ifins2.setTarget(ins);\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing class-level impl data.\r\n-     */\r\n-    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n-        // public void loadImplData(OpenJPAStateManager sm, int i)\r\n-        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class });\r\n-        meth.makePrivate();\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        int count = countImplDataFields(meta);\r\n-        BCField impl = null;\r\n-        if (count == 0)\r\n-            code.vreturn();\r\n-        else {\r\n-            // Object[] fieldImpl\r\n-            impl = bc.declareField(\"fieldImpl\", Object[].class);\r\n-            impl.makePrivate();\r\n-\r\n-            // if (fieldImpl != null)\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            JumpInstruction ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-\r\n-            // Object obj = null;\r\n-            int obj = code.getNextLocalsIndex();\r\n-            ifins.setTarget(code.constant().setNull());\r\n-            code.astore().setLocal(obj);\r\n-\r\n-            // establish switch target, then move before it\r\n-            Instruction target = code.aload().setLocal(obj);\r\n-            code.previous();\r\n-\r\n-            // switch(i)\r\n-            code.iload().setParam(1);\r\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n-            FieldMetaData[] fields = meta.getFields();\r\n-            int cacheable = 0;\r\n-            for (int i = 0; i < fields.length; i++) {\r\n-                if (!usesImplData(fields[i]))\r\n-                    continue;\r\n-                // case x: obj = fieldImpl[y]; break;\r\n-                lswitch.addCase(i, code.aload().setThis());\r\n-                code.getfield().setField(impl);\r\n-                code.constant().setValue(cacheable++);\r\n-                code.aaload();\r\n-                code.astore().setLocal(obj);\r\n-                code.go2().setTarget(target);\r\n-            }\r\n-            lswitch.setDefaultTarget(target);\r\n-\r\n-            // if (obj != null)\r\n-            code.next();    // jump back over target\r\n-            ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-\r\n-            // sm.setImplData(index, impl);\r\n-            ifins.setTarget(code.aload().setParam(0));\r\n-            code.iload().setParam(1);\r\n-            code.aload().setLocal(obj);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"setImplData\", void.class,\r\n-                new Class[]{ int.class, Object.class });\r\n-            code.vreturn();\r\n-        }\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-\r\n-        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\r\n-        meth = bc.declareMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n-        code = meth.getCode(true);\r\n-        if (count == 0)\r\n-            code.vreturn();\r\n-        else {\r\n-            // int arrIdx = -1;\r\n-            // switch(index)\r\n-            int arrIdx = code.getNextLocalsIndex();\r\n-            code.constant().setValue(-1);\r\n-            code.istore().setLocal(arrIdx);\r\n-            code.iload().setParam(1);\r\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n-\r\n-            // establish switch target, then move before it\r\n-            Instruction switchTarget = code.iload().setLocal(arrIdx);\r\n-            code.previous();\r\n-\r\n-            FieldMetaData[] fields = meta.getFields();\r\n-            int cacheable = 0;\r\n-            for (int i = 0; i < fields.length; i++) {\r\n-                if (!usesImplData(fields[i]))\r\n-                    continue;\r\n-                // case x: arrIdx = y; break;\r\n-                lswitch.addCase(i, code.constant().setValue(cacheable++));\r\n-                code.istore().setLocal(arrIdx);\r\n-                code.go2().setTarget(switchTarget);\r\n-            }\r\n-            lswitch.setDefaultTarget(switchTarget);\r\n-            code.next();    // step over switch target\r\n-\r\n-            // if (arrIdx != -1)\r\n-            code.constant().setValue(-1);\r\n-            JumpInstruction ifins = code.ificmpne();\r\n-            code.vreturn();\r\n-\r\n-            // create null target, then move before it\r\n-            Instruction nullTarget = code.aload().setThis();\r\n-            code.previous();\r\n-\r\n-            // if (loaded)\r\n-            ifins.setTarget(code.iload().setParam(2));\r\n-            code.ifeq().setTarget(nullTarget);\r\n-\r\n-            // Object obj = sm.getImplData(index)\r\n-            int obj = code.getNextLocalsIndex();\r\n-            code.aload().setParam(0);\r\n-            code.iload().setParam(1);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, new Class[]{ int.class });\r\n-            code.astore().setLocal(obj);\r\n-\r\n-            // if (obj != null)\r\n-            code.aload().setLocal(obj);\r\n-            code.ifnull().setTarget(nullTarget);\r\n-\r\n-            // if (fieldImpl == null)\r\n-            // \t\tfieldImpl = new Object[fields];\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            ifins = code.ifnonnull();\r\n-            code.aload().setThis();\r\n-            code.constant().setValue(count);\r\n-            code.anewarray().setType(Object.class);\r\n-            code.putfield().setField(impl);\r\n-\r\n-            // fieldImpl[arrIdx] = obj;\r\n-            // return;\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(impl);\r\n-            code.iload().setLocal(arrIdx);\r\n-            code.aload().setLocal(obj);\r\n-            code.aastore();\r\n-            code.vreturn();\r\n-\r\n-            // if (fieldImpl != null)\r\n-            // \t\tfieldImpl[index] = null;\r\n-            code.next(); // step over nullTarget\r\n-            code.getfield().setField(impl);\r\n-            ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(impl);\r\n-            code.iload().setLocal(arrIdx);\r\n-            code.constant().setNull();\r\n-            code.aastore();\r\n-            code.vreturn();\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing version data.\r\n-     */\r\n-    protected void addVersionMethods(BCClass bc) {\r\n-        // void storeVersion(OpenJPAStateManager sm);\r\n-        addBeanField(bc, \"version\", Object.class);\r\n-        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        // version = sm.getVersion();\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface()\r\n-            .setMethod(OpenJPAStateManager.class, \"getVersion\",\r\n-                Object.class, null);\r\n-        code.putfield().setField(\"version\", Object.class);\r\n-        code.vreturn();\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-\r\n-        // void loadVersion(OpenJPAStateManager sm)\r\n-        meth = bc.declareMethod(\"loadVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        code = meth.getCode(true);\r\n-\r\n-        // if (sm.getVersion() == null)\r\n-        // \t\tsm.setVersion(version);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getVersion\", Object.class, null);\r\n-        JumpInstruction ifins = code.ifnonnull();\r\n-        code.aload().setParam(0);\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"version\", Object.class);\r\n-        code.invokeinterface()\r\n-            .setMethod(OpenJPAStateManager.class, \"setVersion\",\r\n-                void.class, new Class[]{ Object.class });\r\n-        ifins.setTarget(code.vreturn());\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\r\n-        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\r\n-        // \t\tObject context)\r\n-        Code code = addLoadMethod(bc, false);\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        Collection jumps2;\r\n-\t\t\r\n-        int local = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(local);\r\n-        int inter = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(inter);\r\n-\r\n-        int objectCount = 0;\r\n-        boolean intermediate;\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            jumps2 = new LinkedList();\r\n-            intermediate = usesIntermediate(fmds[i]);\r\n-            setTarget(code.aload().setThis(), jumps);\r\n-            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            jumps.add(code.ifne());\r\n-\r\n-            if (intermediate)\r\n-                addLoadIntermediate(code, i, objectCount, jumps2, inter);\r\n-            jumps2.add(code.go2());\r\n-\r\n-            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\r\n-            setTarget(code.aload().setParam(1), jumps);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmds[i].getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class,\r\n-                \"getField\", FieldMetaData.class, new Class[]{int.class});\r\n-            code.invokeinterface().setMethod (FetchConfiguration.class, \r\n-                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\r\n-            code.constant().setValue(FetchConfiguration.FETCH_NONE);\r\n-            jumps2.add(code.ificmpeq());\r\n-            addLoad(bc, code, fmds[i], objectCount, local, false);\r\n-\r\n-            jumps = jumps2;\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\r\n-        Code code = addLoadMethod(bc, true);\r\n-        // public void load(OpenJPAStateManager sm, BitSet fields,\r\n-        // \t\tFetchConfiguration fetch, Object conn)\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        Collection jumps2;\r\n-        int objectCount = 0;\r\n-        boolean intermediate;\r\n-        int local = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(local);\r\n-        int inter = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(inter);\r\n-\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            jumps2 = new LinkedList();\r\n-            intermediate = usesIntermediate(fmds[i]);\r\n-            // if (fields.get(i))\r\n-            // {\r\n-            // \t\tif (loaded.get(i))\r\n-            setTarget(code.aload().setParam(1), jumps);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            jumps2.add(code.ifeq());\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            if (intermediate)\r\n-                jumps.add(code.ifeq());\r\n-            else\r\n-                jumps2.add(code.ifeq());\r\n-\r\n-            addLoad(bc, code, fmds[i], objectCount, local, true);\r\n-            if (usesImplData(fmds[i])) {\r\n-                // loadImplData(sm, i);\r\n-                code.aload().setThis();\r\n-                code.aload().setParam(0);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n-                    new Class[]{ OpenJPAStateManager.class, int.class });\r\n-            }\r\n-\r\n-            // fields.clear(i);\r\n-            code.aload().setParam(1);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n-                new Class[] { int.class });\r\n-\r\n-            jumps2.add(code.go2());\r\n-\r\n-            if (intermediate)\r\n-                setTarget(addLoadIntermediate\r\n-                    (code, i, objectCount, jumps2, inter), jumps);\r\n-\r\n-            jumps = jumps2;\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Declare and start the base load method.\r\n-     */\r\n-    private Code addLoadMethod(BCClass bc, boolean fields) {\r\n-        Class[] args = null;\r\n-        if (fields)\r\n-            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\r\n-                FetchConfiguration.class, Object.class };\r\n-        else\r\n-            args = new Class[]{ OpenJPAStateManager.class,\r\n-                FetchConfiguration.class, Object.class };\r\n-        BCMethod load = bc.declareMethod(\"load\", void.class, args);\r\n-        Code code = load.getCode(true);\r\n-\r\n-        //loadVersion(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"loadVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        //loadImplData(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        return code;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add the field load.\r\n-     */\r\n-    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\r\n-        int objectCount, int local, boolean fields) {\r\n-        int index = fmd.getIndex();\r\n-        int typeCode = replaceType(fmd);\r\n-        Instruction first;\r\n-        if (typeCode < JavaTypes.OBJECT) {\r\n-            // sm.store<type>(i, field<i>)\r\n-            Class type = forType(fmd.getTypeCode());\r\n-            first = code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(getFieldName(index), type);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"store\" + StringUtils.capitalize(type.getName()),\r\n-                void.class, new Class[]{ int.class, type });\r\n-        } else {\r\n-            // fmd = sm.getMetaData().getField(i);\r\n-            int offset = fields ? 1 : 0;\r\n-            first = code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\r\n-                FieldMetaData.class, new Class[]{ int.class });\r\n-            code.astore().setLocal(local);\r\n-            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\r\n-            // \t\tfetch, context);\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.aload().setLocal(local);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"objects\", Object[].class);\r\n-            code.constant().setValue(objectCount);\r\n-            code.aaload();\r\n-            code.aload().setParam(1 + offset);\r\n-            code.aload().setParam(2 + offset);\r\n-            code.invokevirtual().setMethod(bc.getName(), \"toField\",\r\n-                Object.class.getName(), toStrings(new Class[]{ \r\n-                OpenJPAStateManager.class, FieldMetaData.class,\r\n-                Object.class, FetchConfiguration.class, Object.class }));\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"storeField\", void.class,\r\n-                new Class[]{ int.class, Object.class });\r\n-        }\r\n-        return first;\r\n-    }\r\n-\r\n-    /**\r\n-     * Load intermediate data if possible.\r\n-     */\r\n-    private Instruction addLoadIntermediate(Code code, int index,\r\n-        int objectCount, Collection jumps2, int inter) {\r\n-        // {\r\n-        // \t\tObject inter = objects[objectCount];\r\n-        Instruction first = code.aload().setThis();\r\n-        code.getfield().setField(\"objects\", Object[].class);\r\n-        code.constant().setValue(objectCount);\r\n-        code.aaload();\r\n-        code.astore().setLocal(inter);\r\n-        // \t\tif (inter != null && !sm.getLoaded().get(index))\r\n-        code.aload().setLocal(inter);\r\n-        jumps2.add(code.ifnull());\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getLoaded\", BitSet.class, null);\r\n-        code.constant().setValue(index);\r\n-        code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-            boolean.class, new Class[]{ int.class });\r\n-        jumps2.add(code.ifne());\r\n-        //\t\t\tsm.setIntermediate(index, inter);\r\n-        //\t}  // end else\r\n-        code.aload().setParam(0);\r\n-        code.constant().setValue(index);\r\n-        code.aload().setLocal(inter);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"setIntermediate\", void.class,\r\n-            new Class[]{ int.class, Object.class });\r\n-        return first;\r\n-    }\r\n-\r\n-    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\r\n-        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\r\n-        addStoreMethod(bc, meta, true);\r\n-        // i.e. void store(OpenJPAStateManager sm);\r\n-        addStoreMethod(bc, meta, false);\r\n-    }\r\n-\r\n-    private void addStoreMethod(BCClass bc, ClassMetaData meta,\r\n-        boolean fields) {\r\n-        BCMethod store;\r\n-        if (fields)\r\n-            store = bc.declareMethod(\"store\", void.class,\r\n-                new Class[]{ OpenJPAStateManager.class, BitSet.class });\r\n-        else\r\n-            store = bc.declareMethod(\"store\", void.class,\r\n-                new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = store.getCode(true);\r\n-\r\n-        // initialize();\r\n-        code.aload().setThis();\r\n-        code.invokevirtual().setMethod(\"initialize\", void.class, null);\r\n-\r\n-        // storeVersion(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"storeVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        // storeImplData(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        int objectCount = 0;\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            if (fields) {\r\n-                //  if (fields != null && fields.get(index))\r\n-                setTarget(code.aload().setParam(1), jumps);\r\n-                jumps.add(code.ifnull());\r\n-                code.aload().setParam(1);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifeq());\r\n-            } else {\r\n-                // if (sm.getLoaded().get(index)))\r\n-                setTarget(code.aload().setParam(0), jumps);\r\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                    \"getLoaded\", BitSet.class, null);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifeq());\r\n-            }\r\n-            addStore(bc, code, fmds[i], objectCount);\r\n-            if (usesIntermediate(fmds[i])) {\r\n-                JumpInstruction elseIns = code.go2();\r\n-                // else if (!loaded.get(index))\r\n-                setTarget(code.aload().setThis(), jumps);\r\n-                jumps.add(elseIns);\r\n-                code.getfield().setField(\"loaded\", BitSet.class);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifne());\r\n-                // Object val = sm.getIntermediate(index);\r\n-                // if (val != null)\r\n-                // \t\tobjects[objectCount] = val;\r\n-                code.aload().setParam(0);\r\n-                code.constant().setValue(i);\r\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                    \"getIntermediate\", Object.class, new Class[]{ int.class });\r\n-                int local = code.getNextLocalsIndex();\r\n-                code.astore().setLocal(local);\r\n-                code.aload().setLocal(local);\r\n-                jumps.add(code.ifnull());\r\n-                code.aload().setThis();\r\n-                code.getfield().setField(\"objects\", Object[].class);\r\n-                code.constant().setValue(objectCount);\r\n-                code.aload().setLocal(local);\r\n-                code.aastore();\r\n-            }\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\r\n-        int objectCount) {\r\n-        int typeCode = replaceType(fmd);\r\n-        int index = fmd.getIndex();\r\n-        if (typeCode < JavaTypes.OBJECT) {\r\n-            Class type = forType(typeCode);\r\n-            // field<i> = sm.fetch<Type>(index)\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"fetch\" + StringUtils.capitalize(type.getName()), type,\r\n-                new Class[]{ int.class });\r\n-            code.putfield().setField(getFieldName(index), type);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n-                new Class[]{ int.class });\r\n-        } else {\r\n-            // Object val = toData(sm.getMetaData().getField(index),\r\n-            // \t\tsm.fetchField(index, false), sm.getContext());\r\n-            int local = code.getNextLocalsIndex();\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class,\r\n-                \"getField\", FieldMetaData.class, new Class[]{ int.class });\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.constant().setValue(false);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"fetchField\", Object.class, new Class[]\r\n-                { int.class, boolean.class });\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getContext\", StoreContext.class, null);\r\n-            code.invokevirtual().setMethod(bc.getName(), \"toData\",\r\n-                Object.class.getName(), toStrings(new Class []{\r\n-                FieldMetaData.class, Object.class, StoreContext.class }));\r\n-            code.astore().setLocal(local);\r\n-\r\n-            // if (val == NULL) {\r\n-            // \t\tval = null;\r\n-            // \t\tloaded.clear(index);\r\n-            // \t} else\r\n-            // \t\tloaded.set(index);\r\n-            // \tobjects[objectCount] = val;\r\n-            code.aload().setLocal(local);\r\n-            code.getstatic().setField(AbstractPCData.class, \"NULL\",\r\n-                Object.class);\r\n-            JumpInstruction ifins = code.ifacmpne();\r\n-            code.constant().setNull();\r\n-            code.astore().setLocal(local);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n-                new Class[]{ int.class });\r\n-            JumpInstruction go2 = code.go2();\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n-                new Class[]{ int.class });\r\n-            go2.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(\"objects\", Object[].class);\r\n-            code.constant().setValue(objectCount);\r\n-            code.aload().setLocal(local);\r\n-            code.aastore();\r\n-        }\r\n-        if (!usesImplData(fmd))\r\n-            return;\r\n-\r\n-        // storeImplData(sm, i, loaded.get(i);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.constant().setValue(index);\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"loaded\", BitSet.class);\r\n-        code.constant().setValue(index);\r\n-        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\r\n-            new Class[]{ int.class });\r\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n-    }\r\n-\r\n-    private void addNewEmbedded(BCClass bc) {\r\n-        // void newEmbeddedPCData(OpenJPAStateManager embedded)\r\n-        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-        // return getStorageGenerator().generatePCData\r\n-        // \t\t(sm.getId(), sm.getMetaData());\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getId\", Object.class, null);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getMetaData\", ClassMetaData.class, null);\r\n-        code.invokevirtual().setMethod(PCDataGenerator.class,\r\n-            \"generatePCData\", PCData.class, new Class[]\r\n-            { Object.class, ClassMetaData.class });\r\n-        code.areturn();\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    private void addGetData(BCClass bc) {\r\n-        // return getObjectField(i);\r\n-        BCMethod method = bc.declareMethod(\"getData\", Object.class,\r\n-            new Class[]{ int.class });\r\n-        Code code = method.getCode(true);\r\n-        code.aload().setThis();\r\n-        code.iload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"getObject\", Object.class,\r\n-            new Class[]{ int.class });\r\n-        code.areturn();\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    /////////////\r\n-    // Utilities\r\n-    /////////////\r\n-\r\n-    /**\r\n-     * Return a valid {@link JavaTypes} constant for the given field\r\n-     */\r\n-    protected int replaceType(FieldMetaData fmd) {\r\n-        if (usesIntermediate(fmd))\r\n-            return JavaTypes.OBJECT;\r\n-        return fmd.getTypeCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given field uses a cacheable intermediate value.\r\n-     */\r\n-    protected boolean usesIntermediate(FieldMetaData fmd) {\r\n-        return fmd.usesIntermediate();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given type might have cacheable class-level impl data.\r\n-     */\r\n-    protected boolean usesImplData(ClassMetaData meta) {\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given field might have cacheable impl data.\r\n-     */\r\n-    protected boolean usesImplData(FieldMetaData fmd) {\r\n-        return fmd.usesImplData() == null;\r\n-    }\r\n-\r\n-    /**\r\n-     * The number of fields with cacheable impl data.\r\n-     */\r\n-    private int countImplDataFields(ClassMetaData meta) {\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        int count = 0;\r\n-        for (int i = 0; i < fmds.length; i++)\r\n-            if (usesImplData(fmds[i]))\r\n-                count++;\r\n-        return count;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add method which defers to AbstractPCData.\r\n-     */\r\n-    protected void callAbstractPCData(BCClass bc, String name, Class retType,\r\n-        Class[] args) {\r\n-        BCMethod meth = bc.declareMethod(name, retType, args);\r\n-        Code code = meth.getCode(true);\r\n-        code.aload().setThis();\r\n-        for (int i = 0; i < args.length; i++)\r\n-            code.xload().setParam(i).setType(args[i]);\r\n-        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\r\n-            args);\r\n-        if (!void.class.equals(retType))\r\n-            code.xreturn().setType(retType);\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the collection of {@link JumpInstruction}s to the given instruction,\r\n-     * clearing the collection in the process.\r\n-     */\r\n-    protected void setTarget(Instruction ins, Collection jumps) {\r\n-        for (Iterator it = jumps.iterator(); it.hasNext();)\r\n-            ((JumpInstruction) it.next()).setTarget(ins);\r\n-        jumps.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Transform the given array of classes to strings.\r\n-     */\r\n-    private static String[] toStrings(Class[] cls) {\r\n-        String[] strings = new String[cls.length];\r\n-        for (int i = 0; i < strings.length; i++)\r\n-            strings[i] = cls[i].getName();\r\n-        return strings;\r\n-    }\r\n-\r\n-    /**\r\n-     * Dynamic {@link PCData}s generated will implement this interface\r\n-     * to simplify initialization.\r\n-     */\r\n-    public static interface DynamicPCData extends PCData {\r\n-\r\n-        public void setId(Object oid);\r\n-\r\n-        public PCDataGenerator getStorageGenerator();\r\n-\r\n-        public void setStorageGenerator (PCDataGenerator generator);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.AbstractPCData;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCData;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InternalException;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Code;\n+import serp.bytecode.Constants;\n+import serp.bytecode.ExceptionHandler;\n+import serp.bytecode.Instruction;\n+import serp.bytecode.JumpInstruction;\n+import serp.bytecode.LookupSwitchInstruction;\n+\n+/**\n+ * Generates {@link PCData} instances which avoid primitve wrappers\n+ * to optimize memory use and performance at the cost of slightly higher\n+ * startup time.\n+ *\n+ * @author Steve Kim\n+ * @nojavadoc\n+ * @since 0.3.2\n+ */\n+public class PCDataGenerator\n+    extends DynamicStorageGenerator {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCDataGenerator.class);\n+\n+    protected static final String POSTFIX = \"$openjpapcdata\";\n+\n+    private final Map _generated = new ConcurrentHashMap();\n+    private final OpenJPAConfiguration _conf;\n+    private final Log _log;\n+\n+    public PCDataGenerator(OpenJPAConfiguration conf) {\n+        _conf = conf;\n+        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+    }\n+\n+    /**\n+     * Return the configuration.\n+     */\n+    public OpenJPAConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    /**\n+     * Return a {@link PCData} instance for the given oid and metadata.\n+     */\n+    public PCData generatePCData(Object oid, ClassMetaData meta) {\n+        if (meta == null)\n+            return null;\n+        Class type = meta.getDescribedType();\n+        DynamicStorage storage = (DynamicStorage) _generated.get(type);\n+        if (storage == null) {\n+            storage = generateStorage(meta);\n+            _generated.put(type, storage);\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\n+        }\n+        DynamicPCData data = (DynamicPCData) storage.newInstance();\n+        data.setId(oid);\n+        data.setStorageGenerator(this);\n+        finish(data, meta);\n+        return data;\n+    }\n+\n+    /**\n+     * Actually generate the factory instance.\n+     */\n+    private DynamicStorage generateStorage(ClassMetaData meta) {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"pcdata-generate\", meta));\n+\n+        FieldMetaData[] fields = meta.getFields();\n+        int[] types = new int[fields.length];\n+        for (int i = 0; i < types.length; i++)\n+            types[i] = replaceType(fields[i]);\n+        return generateStorage(types, meta);\n+    }\n+\n+    /**\n+     * Perform any final actions before the pcdata is returned to client code.\n+     */\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\n+    }\n+\n+    protected int getCreateFieldMethods(int typeCode) {\n+        if (typeCode >= JavaTypes.OBJECT)\n+            return POLICY_SILENT;\n+        // don't bother creating set/get<Primitive> methods\n+        return POLICY_EMPTY;\n+    }\n+\n+    protected void declareClasses(BCClass bc) {\n+        super.declareClasses(bc);\n+        bc.declareInterface(DynamicPCData.class);\n+        bc.setSuperclass(AbstractPCData.class);\n+    }\n+\n+    protected final String getClassName(Object obj) {\n+        return getUniqueName(((ClassMetaData) obj).getDescribedType());\n+    }\n+\n+    /**\n+     * Creates a unique name for the given type's pcdata implementation.\n+     */\n+    protected String getUniqueName(Class type) {\n+        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\n+    }\n+\n+    protected final void decorate(Object obj, BCClass bc, int[] types) {\n+        super.decorate(obj, bc, types);\n+        ClassMetaData meta = (ClassMetaData) obj;\n+\n+        enhanceConstructor(bc);\n+        addBaseFields(bc);\n+        addImplDataMethods(bc, meta);\n+        addFieldImplDataMethods(bc, meta);\n+        addVersionMethods(bc);\n+        addGetType(bc, meta);\n+        addLoadMethod(bc, meta);\n+        addLoadWithFieldsMethod(bc, meta);\n+        addStoreMethods(bc, meta);\n+        addNewEmbedded(bc);\n+        addGetData(bc);\n+        decorate(bc, meta);\n+    }\n+\n+    /**\n+     * Apply additional decoration to generated class.\n+     */\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\n+    }\n+\n+    /**\n+     * Enhance constructor to initialize fields\n+     */\n+    private void enhanceConstructor(BCClass bc) {\n+        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\n+        Code code = cons.getCode(false);\n+        code.afterLast();\n+        code.previous();\n+\n+        // private BitSet loaded = new BitSet();\n+        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\n+        loaded.setFinal(true);\n+        code.aload().setThis();\n+        code.anew().setType(BitSet.class);\n+        code.dup();\n+        code.constant().setValue(bc.getFields().length);\n+        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\n+            new Class[]{ int.class });\n+        code.putfield().setField(loaded);\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Have to load the type since it may not be available to the\n+     * same classloader (i.e. rar vs. ear). The context classloader\n+     * (i.e. the user app classloader) should be fine.\n+     */\n+    private void addGetType(BCClass bc, ClassMetaData meta) {\n+        BCField type = bc.declareField(\"type\", Class.class);\n+        type.setStatic(true);\n+        type.makePrivate();\n+        // public Class getType() {\n+        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\n+        getter.makePublic();\n+        Code code = getter.getCode(true);\n+        // if (type == null) {\n+        // \t\ttry {\n+        // \t\t\ttype = Class.forName\n+        // \t\t\t\t(meta.getDescribedType().getName(), true,\n+        // \t\t\t\tThread.currentThread().getContextClassLoader());\n+        // \t\t} catch (ClassNotFoundException cnfe) {\n+        // \t\t\tthrow new InternalException();\n+        // \t\t}\n+        // }\n+        code.getstatic().setField(type);\n+\n+        Collection jumps = new LinkedList();\n+        jumps.add(code.ifnonnull());\n+        ExceptionHandler handler = code.addExceptionHandler();\n+\n+        handler.setTryStart(code.constant().setValue\n+            (meta.getDescribedType().getName()));\n+        code.constant().setValue(true);\n+        code.invokestatic().setMethod(Thread.class, \"currentThread\",\n+            Thread.class, null);\n+        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\n+            ClassLoader.class, null);\n+        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\n+            new Class[]{ String.class, boolean.class, ClassLoader.class });\n+        code.putstatic().setField(type);\n+        Instruction go2 = code.go2();\n+        jumps.add(go2);\n+        handler.setTryEnd(go2);\n+        handler.setCatch(ClassNotFoundException.class);\n+        handler.setHandlerStart(throwException\n+            (code, InternalException.class));\n+        setTarget(code.getstatic().setField(type), jumps);\n+        code.areturn();\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Declare standard dynamic pcdata fields.\n+     */\n+    private void addBaseFields(BCClass bc) {\n+        addBeanField(bc, \"id\", Object.class);\n+        BCField field = addBeanField(bc, \"storageGenerator\",\n+            PCDataGenerator.class);\n+        field.setAccessFlags(field.getAccessFlags()\n+            | Constants.ACCESS_TRANSIENT);\n+    }\n+\n+    /**\n+     * Add methods for loading and storing class-level impl data.\n+     */\n+    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\n+        // void storeImplData(OpenJPAStateManager);\n+        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+\n+        BCField impl = null;\n+        if (!usesImplData(meta))\n+            code.vreturn();\n+        else {\n+            // if (sm.isImplDataCacheable())\n+            // \t\tsetImplData(sm.getImplData());\n+            impl = addBeanField(bc, \"implData\", Object.class);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"isImplDataCacheable\", boolean.class, null);\n+            JumpInstruction ifins = code.ifeq();\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, null);\n+            code.invokevirtual().setMethod(\"setImplData\", void.class,\n+                new Class[]{ Object.class });\n+            ifins.setTarget(code.vreturn());\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+\n+        // void loadImplData(OpenJPAStateManager);\n+        meth = bc.declareMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        code = meth.getCode(true);\n+        if (!usesImplData(meta))\n+            code.vreturn();\n+        else {\n+            // if (sm.getImplData() == null && implData != null)\n+            // \t\tsm.setImplData(impl, true);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, null);\n+            JumpInstruction ifins = code.ifnonnull();\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            JumpInstruction ifins2 = code.ifnull();\n+            code.aload().setParam(0);\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            code.constant().setValue(true);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"setImplData\", void.class,\n+                new Class[]{ Object.class, boolean.class });\n+            Instruction ins = code.vreturn();\n+            ifins.setTarget(ins);\n+            ifins2.setTarget(ins);\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Add methods for loading and storing class-level impl data.\n+     */\n+    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\n+        // public void loadImplData(OpenJPAStateManager sm, int i)\n+        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class });\n+        meth.makePrivate();\n+        Code code = meth.getCode(true);\n+\n+        int count = countImplDataFields(meta);\n+        BCField impl = null;\n+        if (count == 0)\n+            code.vreturn();\n+        else {\n+            // Object[] fieldImpl\n+            impl = bc.declareField(\"fieldImpl\", Object[].class);\n+            impl.makePrivate();\n+\n+            // if (fieldImpl != null)\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            JumpInstruction ifins = code.ifnonnull();\n+            code.vreturn();\n+\n+            // Object obj = null;\n+            int obj = code.getNextLocalsIndex();\n+            ifins.setTarget(code.constant().setNull());\n+            code.astore().setLocal(obj);\n+\n+            // establish switch target, then move before it\n+            Instruction target = code.aload().setLocal(obj);\n+            code.previous();\n+\n+            // switch(i)\n+            code.iload().setParam(1);\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\n+            FieldMetaData[] fields = meta.getFields();\n+            int cacheable = 0;\n+            for (int i = 0; i < fields.length; i++) {\n+                if (!usesImplData(fields[i]))\n+                    continue;\n+                // case x: obj = fieldImpl[y]; break;\n+                lswitch.addCase(i, code.aload().setThis());\n+                code.getfield().setField(impl);\n+                code.constant().setValue(cacheable++);\n+                code.aaload();\n+                code.astore().setLocal(obj);\n+                code.go2().setTarget(target);\n+            }\n+            lswitch.setDefaultTarget(target);\n+\n+            // if (obj != null)\n+            code.next();    // jump back over target\n+            ifins = code.ifnonnull();\n+            code.vreturn();\n+\n+            // sm.setImplData(index, impl);\n+            ifins.setTarget(code.aload().setParam(0));\n+            code.iload().setParam(1);\n+            code.aload().setLocal(obj);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"setImplData\", void.class,\n+                new Class[]{ int.class, Object.class });\n+            code.vreturn();\n+        }\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+\n+        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\n+        meth = bc.declareMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n+        code = meth.getCode(true);\n+        if (count == 0)\n+            code.vreturn();\n+        else {\n+            // int arrIdx = -1;\n+            // switch(index)\n+            int arrIdx = code.getNextLocalsIndex();\n+            code.constant().setValue(-1);\n+            code.istore().setLocal(arrIdx);\n+            code.iload().setParam(1);\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\n+\n+            // establish switch target, then move before it\n+            Instruction switchTarget = code.iload().setLocal(arrIdx);\n+            code.previous();\n+\n+            FieldMetaData[] fields = meta.getFields();\n+            int cacheable = 0;\n+            for (int i = 0; i < fields.length; i++) {\n+                if (!usesImplData(fields[i]))\n+                    continue;\n+                // case x: arrIdx = y; break;\n+                lswitch.addCase(i, code.constant().setValue(cacheable++));\n+                code.istore().setLocal(arrIdx);\n+                code.go2().setTarget(switchTarget);\n+            }\n+            lswitch.setDefaultTarget(switchTarget);\n+            code.next();    // step over switch target\n+\n+            // if (arrIdx != -1)\n+            code.constant().setValue(-1);\n+            JumpInstruction ifins = code.ificmpne();\n+            code.vreturn();\n+\n+            // create null target, then move before it\n+            Instruction nullTarget = code.aload().setThis();\n+            code.previous();\n+\n+            // if (loaded)\n+            ifins.setTarget(code.iload().setParam(2));\n+            code.ifeq().setTarget(nullTarget);\n+\n+            // Object obj = sm.getImplData(index)\n+            int obj = code.getNextLocalsIndex();\n+            code.aload().setParam(0);\n+            code.iload().setParam(1);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, new Class[]{ int.class });\n+            code.astore().setLocal(obj);\n+\n+            // if (obj != null)\n+            code.aload().setLocal(obj);\n+            code.ifnull().setTarget(nullTarget);\n+\n+            // if (fieldImpl == null)\n+            // \t\tfieldImpl = new Object[fields];\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            ifins = code.ifnonnull();\n+            code.aload().setThis();\n+            code.constant().setValue(count);\n+            code.anewarray().setType(Object.class);\n+            code.putfield().setField(impl);\n+\n+            // fieldImpl[arrIdx] = obj;\n+            // return;\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(impl);\n+            code.iload().setLocal(arrIdx);\n+            code.aload().setLocal(obj);\n+            code.aastore();\n+            code.vreturn();\n+\n+            // if (fieldImpl != null)\n+            // \t\tfieldImpl[index] = null;\n+            code.next(); // step over nullTarget\n+            code.getfield().setField(impl);\n+            ifins = code.ifnonnull();\n+            code.vreturn();\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(impl);\n+            code.iload().setLocal(arrIdx);\n+            code.constant().setNull();\n+            code.aastore();\n+            code.vreturn();\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Add methods for loading and storing version data.\n+     */\n+    protected void addVersionMethods(BCClass bc) {\n+        // void storeVersion(OpenJPAStateManager sm);\n+        addBeanField(bc, \"version\", Object.class);\n+        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+\n+        // version = sm.getVersion();\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokeinterface()\n+            .setMethod(OpenJPAStateManager.class, \"getVersion\",\n+                Object.class, null);\n+        code.putfield().setField(\"version\", Object.class);\n+        code.vreturn();\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+\n+        // void loadVersion(OpenJPAStateManager sm)\n+        meth = bc.declareMethod(\"loadVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        code = meth.getCode(true);\n+\n+        // if (sm.getVersion() == null)\n+        // \t\tsm.setVersion(version);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getVersion\", Object.class, null);\n+        JumpInstruction ifins = code.ifnonnull();\n+        code.aload().setParam(0);\n+        code.aload().setThis();\n+        code.getfield().setField(\"version\", Object.class);\n+        code.invokeinterface()\n+            .setMethod(OpenJPAStateManager.class, \"setVersion\",\n+                void.class, new Class[]{ Object.class });\n+        ifins.setTarget(code.vreturn());\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n+        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\n+        // \t\tObject context)\n+        Code code = addLoadMethod(bc, false);\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        Collection jumps2;\n+\t\t\n+        int local = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(local);\n+        int inter = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(inter);\n+\n+        int objectCount = 0;\n+        boolean intermediate;\n+        for (int i = 0; i < fmds.length; i++) {\n+            jumps2 = new LinkedList();\n+            intermediate = usesIntermediate(fmds[i]);\n+            setTarget(code.aload().setThis(), jumps);\n+            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            jumps.add(code.ifne());\n+\n+            if (intermediate)\n+                addLoadIntermediate(code, i, objectCount, jumps2, inter);\n+            jumps2.add(code.go2());\n+\n+            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\n+            setTarget(code.aload().setParam(1), jumps);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmds[i].getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class,\n+                \"getField\", FieldMetaData.class, new Class[]{int.class});\n+            code.invokeinterface().setMethod (FetchConfiguration.class, \n+                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\n+            code.constant().setValue(FetchConfiguration.FETCH_NONE);\n+            jumps2.add(code.ificmpeq());\n+            addLoad(bc, code, fmds[i], objectCount, local, false);\n+\n+            jumps = jumps2;\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n+        Code code = addLoadMethod(bc, true);\n+        // public void load(OpenJPAStateManager sm, BitSet fields,\n+        // \t\tFetchConfiguration fetch, Object conn)\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        Collection jumps2;\n+        int objectCount = 0;\n+        boolean intermediate;\n+        int local = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(local);\n+        int inter = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(inter);\n+\n+        for (int i = 0; i < fmds.length; i++) {\n+            jumps2 = new LinkedList();\n+            intermediate = usesIntermediate(fmds[i]);\n+            // if (fields.get(i))\n+            // {\n+            // \t\tif (loaded.get(i))\n+            setTarget(code.aload().setParam(1), jumps);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            jumps2.add(code.ifeq());\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            if (intermediate)\n+                jumps.add(code.ifeq());\n+            else\n+                jumps2.add(code.ifeq());\n+\n+            addLoad(bc, code, fmds[i], objectCount, local, true);\n+            if (usesImplData(fmds[i])) {\n+                // loadImplData(sm, i);\n+                code.aload().setThis();\n+                code.aload().setParam(0);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(\"loadImplData\", void.class,\n+                    new Class[]{ OpenJPAStateManager.class, int.class });\n+            }\n+\n+            // fields.clear(i);\n+            code.aload().setParam(1);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n+                new Class[] { int.class });\n+\n+            jumps2.add(code.go2());\n+\n+            if (intermediate)\n+                setTarget(addLoadIntermediate\n+                    (code, i, objectCount, jumps2, inter), jumps);\n+\n+            jumps = jumps2;\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Declare and start the base load method.\n+     */\n+    private Code addLoadMethod(BCClass bc, boolean fields) {\n+        Class[] args = null;\n+        if (fields)\n+            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\n+                FetchConfiguration.class, Object.class };\n+        else\n+            args = new Class[]{ OpenJPAStateManager.class,\n+                FetchConfiguration.class, Object.class };\n+        BCMethod load = bc.declareMethod(\"load\", void.class, args);\n+        Code code = load.getCode(true);\n+\n+        //loadVersion(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"loadVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        //loadImplData(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        return code;\n+    }\n+\n+    /**\n+     * Add the field load.\n+     */\n+    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\n+        int objectCount, int local, boolean fields) {\n+        int index = fmd.getIndex();\n+        int typeCode = replaceType(fmd);\n+        Instruction first;\n+        if (typeCode < JavaTypes.OBJECT) {\n+            // sm.store<type>(i, field<i>)\n+            Class type = forType(fmd.getTypeCode());\n+            first = code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.aload().setThis();\n+            code.getfield().setField(getFieldName(index), type);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"store\" + StringUtils.capitalize(type.getName()),\n+                void.class, new Class[]{ int.class, type });\n+        } else {\n+            // fmd = sm.getMetaData().getField(i);\n+            int offset = fields ? 1 : 0;\n+            first = code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmd.getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\n+                FieldMetaData.class, new Class[]{ int.class });\n+            code.astore().setLocal(local);\n+            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\n+            // \t\tfetch, context);\n+            code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.aload().setLocal(local);\n+            code.aload().setThis();\n+            code.getfield().setField(\"objects\", Object[].class);\n+            code.constant().setValue(objectCount);\n+            code.aaload();\n+            code.aload().setParam(1 + offset);\n+            code.aload().setParam(2 + offset);\n+            code.invokevirtual().setMethod(bc.getName(), \"toField\",\n+                Object.class.getName(), toStrings(new Class[]{ \n+                OpenJPAStateManager.class, FieldMetaData.class,\n+                Object.class, FetchConfiguration.class, Object.class }));\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"storeField\", void.class,\n+                new Class[]{ int.class, Object.class });\n+        }\n+        return first;\n+    }\n+\n+    /**\n+     * Load intermediate data if possible.\n+     */\n+    private Instruction addLoadIntermediate(Code code, int index,\n+        int objectCount, Collection jumps2, int inter) {\n+        // {\n+        // \t\tObject inter = objects[objectCount];\n+        Instruction first = code.aload().setThis();\n+        code.getfield().setField(\"objects\", Object[].class);\n+        code.constant().setValue(objectCount);\n+        code.aaload();\n+        code.astore().setLocal(inter);\n+        // \t\tif (inter != null && !sm.getLoaded().get(index))\n+        code.aload().setLocal(inter);\n+        jumps2.add(code.ifnull());\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getLoaded\", BitSet.class, null);\n+        code.constant().setValue(index);\n+        code.invokevirtual().setMethod(BitSet.class, \"get\",\n+            boolean.class, new Class[]{ int.class });\n+        jumps2.add(code.ifne());\n+        //\t\t\tsm.setIntermediate(index, inter);\n+        //\t}  // end else\n+        code.aload().setParam(0);\n+        code.constant().setValue(index);\n+        code.aload().setLocal(inter);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"setIntermediate\", void.class,\n+            new Class[]{ int.class, Object.class });\n+        return first;\n+    }\n+\n+    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\n+        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\n+        addStoreMethod(bc, meta, true);\n+        // i.e. void store(OpenJPAStateManager sm);\n+        addStoreMethod(bc, meta, false);\n+    }\n+\n+    private void addStoreMethod(BCClass bc, ClassMetaData meta,\n+        boolean fields) {\n+        BCMethod store;\n+        if (fields)\n+            store = bc.declareMethod(\"store\", void.class,\n+                new Class[]{ OpenJPAStateManager.class, BitSet.class });\n+        else\n+            store = bc.declareMethod(\"store\", void.class,\n+                new Class[]{ OpenJPAStateManager.class });\n+        Code code = store.getCode(true);\n+\n+        // initialize();\n+        code.aload().setThis();\n+        code.invokevirtual().setMethod(\"initialize\", void.class, null);\n+\n+        // storeVersion(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"storeVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        // storeImplData(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        int objectCount = 0;\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fields) {\n+                //  if (fields != null && fields.get(index))\n+                setTarget(code.aload().setParam(1), jumps);\n+                jumps.add(code.ifnull());\n+                code.aload().setParam(1);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifeq());\n+            } else {\n+                // if (sm.getLoaded().get(index)))\n+                setTarget(code.aload().setParam(0), jumps);\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                    \"getLoaded\", BitSet.class, null);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifeq());\n+            }\n+            addStore(bc, code, fmds[i], objectCount);\n+            if (usesIntermediate(fmds[i])) {\n+                JumpInstruction elseIns = code.go2();\n+                // else if (!loaded.get(index))\n+                setTarget(code.aload().setThis(), jumps);\n+                jumps.add(elseIns);\n+                code.getfield().setField(\"loaded\", BitSet.class);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifne());\n+                // Object val = sm.getIntermediate(index);\n+                // if (val != null)\n+                // \t\tobjects[objectCount] = val;\n+                code.aload().setParam(0);\n+                code.constant().setValue(i);\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                    \"getIntermediate\", Object.class, new Class[]{ int.class });\n+                int local = code.getNextLocalsIndex();\n+                code.astore().setLocal(local);\n+                code.aload().setLocal(local);\n+                jumps.add(code.ifnull());\n+                code.aload().setThis();\n+                code.getfield().setField(\"objects\", Object[].class);\n+                code.constant().setValue(objectCount);\n+                code.aload().setLocal(local);\n+                code.aastore();\n+            }\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\n+        int objectCount) {\n+        int typeCode = replaceType(fmd);\n+        int index = fmd.getIndex();\n+        if (typeCode < JavaTypes.OBJECT) {\n+            Class type = forType(typeCode);\n+            // field<i> = sm.fetch<Type>(index)\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"fetch\" + StringUtils.capitalize(type.getName()), type,\n+                new Class[]{ int.class });\n+            code.putfield().setField(getFieldName(index), type);\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n+                new Class[]{ int.class });\n+        } else {\n+            // Object val = toData(sm.getMetaData().getField(index),\n+            // \t\tsm.fetchField(index, false), sm.getContext());\n+            int local = code.getNextLocalsIndex();\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmd.getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class,\n+                \"getField\", FieldMetaData.class, new Class[]{ int.class });\n+            code.aload().setParam(0);\n+            code.constant().setValue(fmd.getIndex());\n+            code.constant().setValue(false);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"fetchField\", Object.class, new Class[]\n+                { int.class, boolean.class });\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getContext\", StoreContext.class, null);\n+            code.invokevirtual().setMethod(bc.getName(), \"toData\",\n+                Object.class.getName(), toStrings(new Class []{\n+                FieldMetaData.class, Object.class, StoreContext.class }));\n+            code.astore().setLocal(local);\n+\n+            // if (val == NULL) {\n+            // \t\tval = null;\n+            // \t\tloaded.clear(index);\n+            // \t} else\n+            // \t\tloaded.set(index);\n+            // \tobjects[objectCount] = val;\n+            code.aload().setLocal(local);\n+            code.getstatic().setField(AbstractPCData.class, \"NULL\",\n+                Object.class);\n+            JumpInstruction ifins = code.ifacmpne();\n+            code.constant().setNull();\n+            code.astore().setLocal(local);\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n+                new Class[]{ int.class });\n+            JumpInstruction go2 = code.go2();\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n+                new Class[]{ int.class });\n+            go2.setTarget(code.aload().setThis());\n+            code.getfield().setField(\"objects\", Object[].class);\n+            code.constant().setValue(objectCount);\n+            code.aload().setLocal(local);\n+            code.aastore();\n+        }\n+        if (!usesImplData(fmd))\n+            return;\n+\n+        // storeImplData(sm, i, loaded.get(i);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.constant().setValue(index);\n+        code.aload().setThis();\n+        code.getfield().setField(\"loaded\", BitSet.class);\n+        code.constant().setValue(index);\n+        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\n+            new Class[]{ int.class });\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n+    }\n+\n+    private void addNewEmbedded(BCClass bc) {\n+        // void newEmbeddedPCData(OpenJPAStateManager embedded)\n+        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+        // return getStorageGenerator().generatePCData\n+        // \t\t(sm.getId(), sm.getMetaData());\n+        code.aload().setThis();\n+        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getId\", Object.class, null);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getMetaData\", ClassMetaData.class, null);\n+        code.invokevirtual().setMethod(PCDataGenerator.class,\n+            \"generatePCData\", PCData.class, new Class[]\n+            { Object.class, ClassMetaData.class });\n+        code.areturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private void addGetData(BCClass bc) {\n+        // return getObjectField(i);\n+        BCMethod method = bc.declareMethod(\"getData\", Object.class,\n+            new Class[]{ int.class });\n+        Code code = method.getCode(true);\n+        code.aload().setThis();\n+        code.iload().setParam(0);\n+        code.invokevirtual().setMethod(\"getObject\", Object.class,\n+            new Class[]{ int.class });\n+        code.areturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    /////////////\n+    // Utilities\n+    /////////////\n+\n+    /**\n+     * Return a valid {@link JavaTypes} constant for the given field\n+     */\n+    protected int replaceType(FieldMetaData fmd) {\n+        if (usesIntermediate(fmd))\n+            return JavaTypes.OBJECT;\n+        return fmd.getTypeCode();\n+    }\n+\n+    /**\n+     * Whether the given field uses a cacheable intermediate value.\n+     */\n+    protected boolean usesIntermediate(FieldMetaData fmd) {\n+        return fmd.usesIntermediate();\n+    }\n+\n+    /**\n+     * Whether the given type might have cacheable class-level impl data.\n+     */\n+    protected boolean usesImplData(ClassMetaData meta) {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether the given field might have cacheable impl data.\n+     */\n+    protected boolean usesImplData(FieldMetaData fmd) {\n+        return fmd.usesImplData() == null;\n+    }\n+\n+    /**\n+     * The number of fields with cacheable impl data.\n+     */\n+    private int countImplDataFields(ClassMetaData meta) {\n+        FieldMetaData[] fmds = meta.getFields();\n+        int count = 0;\n+        for (int i = 0; i < fmds.length; i++)\n+            if (usesImplData(fmds[i]))\n+                count++;\n+        return count;\n+    }\n+\n+    /**\n+     * Add method which defers to AbstractPCData.\n+     */\n+    protected void callAbstractPCData(BCClass bc, String name, Class retType,\n+        Class[] args) {\n+        BCMethod meth = bc.declareMethod(name, retType, args);\n+        Code code = meth.getCode(true);\n+        code.aload().setThis();\n+        for (int i = 0; i < args.length; i++)\n+            code.xload().setParam(i).setType(args[i]);\n+        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\n+            args);\n+        if (!void.class.equals(retType))\n+            code.xreturn().setType(retType);\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    /**\n+     * Set the collection of {@link JumpInstruction}s to the given instruction,\n+     * clearing the collection in the process.\n+     */\n+    protected void setTarget(Instruction ins, Collection jumps) {\n+        for (Iterator it = jumps.iterator(); it.hasNext();)\n+            ((JumpInstruction) it.next()).setTarget(ins);\n+        jumps.clear();\n+    }\n+\n+    /**\n+     * Transform the given array of classes to strings.\n+     */\n+    private static String[] toStrings(Class[] cls) {\n+        String[] strings = new String[cls.length];\n+        for (int i = 0; i < strings.length; i++)\n+            strings[i] = cls[i].getName();\n+        return strings;\n+    }\n+\n+    /**\n+     * Dynamic {@link PCData}s generated will implement this interface\n+     * to simplify initialization.\n+     */\n+    public static interface DynamicPCData extends PCData {\n+\n+        public void setId(Object oid);\n+\n+        public PCDataGenerator getStorageGenerator();\n+\n+        public void setStorageGenerator (PCDataGenerator generator);\n+\t}\n+}"},{"sha":"454e16efb8ad24e24cc0604eef9b9b250428add6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":288,"deletions":288,"changes":576,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,288 +1,288 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.ReferenceMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-\r\n-/**\r\n- * Tracks registered persistence-capable classes.\r\n- *\r\n- * @since 0.4.0\r\n- * @author Abe White\r\n- */\r\n-public class PCRegistry {\r\n-    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (PCRegistry.class);\r\n-\r\n-    // map of pc classes to meta structs; weak so the VM can GC classes\r\n-    private static final Map _metas = new ConcurrentReferenceHashMap\r\n-        (ReferenceMap.WEAK, ReferenceMap.HARD);\r\n-\r\n-    // register class listeners\r\n-    private static final Collection _listeners = new LinkedList();\r\n-\r\n-    /**\r\n-     * Register a {@link RegisterClassListener}.\r\n-     */\r\n-    public static void addRegisterClassListener(RegisterClassListener rcl) {\r\n-        if (rcl == null)\r\n-            return;\r\n-\r\n-        // we have to be positive that every listener gets notified for\r\n-        // every class, so lots of locking\r\n-        synchronized (_listeners) {\r\n-            _listeners.add(rcl);\r\n-        }\r\n-        synchronized (_metas) {\r\n-            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\r\n-                rcl.register((Class) itr.next());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Removes a {@link RegisterClassListener}.\r\n-     */\r\n-    public static void removeRegisterClassListener(RegisterClassListener rcl) {\r\n-        synchronized (_listeners) {\r\n-            _listeners.remove(rcl);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the field names for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static String[] getFieldNames(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.fieldNames;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the field types for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static Class[] getFieldTypes(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.fieldTypes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the persistent superclass for a <code>PersistenceCapable</code>\r\n-     * class, or null if none. The superclass may or may not implement\r\n-     * {@link PersistenceCapable}, depending on the access type of the class.\r\n-     */\r\n-    public static Class getPersistentSuperclass(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.pcSuper;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new instance of the class and assign its state manager.\r\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n-     */\r\n-    public static PersistenceCapable newInstance(Class pcClass,\r\n-        StateManager sm, boolean clear) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new instance of the class and assign its state manager and oid.\r\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n-     */\r\n-    public static PersistenceCapable newInstance(Class pcClass,\r\n-        StateManager sm, Object oid, boolean clear) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the persistence-capable type for <code>type</code>. This might\r\n-     * be a generated subclass of <code>type</code>.\r\n-     *\r\n-     * @since 1.1.0\r\n-     */\r\n-    public static Class getPCType(Class type) {\r\n-        Meta meta = getMeta(type);\r\n-        return (meta.pc == null) ? null : meta.pc.getClass();\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new identity object for the given\r\n-     * <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static Object newObjectId(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new identity object for the given\r\n-     * <code>PersistenceCapable</code> class, using the <code>String</code>\r\n-     * form of the constructor.\r\n-     */\r\n-    public static Object newObjectId(Class pcClass, String str) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the alias for the given type.\r\n-     */\r\n-    public static String getTypeAlias(Class pcClass) {\r\n-        return getMeta(pcClass).alias;\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy fields from an outside source to the key fields in the identity\r\n-     * object.\r\n-     */\r\n-    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\r\n-        Object oid) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        if (meta.pc == null)\r\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n-\r\n-        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy fields to an outside source from the key fields in the identity\r\n-     * object.\r\n-     */\r\n-    public static void copyKeyFieldsFromObjectId(Class pcClass,\r\n-        FieldConsumer fm, Object oid) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        if (meta.pc == null)\r\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n-\r\n-        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\r\n-    }\r\n-\r\n-    /**\r\n-     * Register metadata by class.\r\n-     *\r\n-     * @param fieldTypes managed field types\r\n-     * @param fieldFlags managed field flags\r\n-     * @param sup the most immediate persistent superclass\r\n-     * @param pcClass the <code>PersistenceCapable</code> class\r\n-     * @param fieldNames managed field names\r\n-     * @param alias the class alias\r\n-     * @param pc an instance of the class, if not abstract\r\n-     */\r\n-    public static void register(Class pcClass, String[] fieldNames,\r\n-        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\r\n-        PersistenceCapable pc) {\r\n-        if (pcClass == null)\r\n-            throw new NullPointerException();\r\n-\r\n-        // we have to be positive that every listener gets notified for\r\n-        // every class, so lots of locking\r\n-        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\r\n-        synchronized (_metas) {\r\n-            _metas.put(pcClass, meta);\r\n-        }\r\n-        synchronized (_listeners) {\r\n-            for (Iterator i = _listeners.iterator(); i.hasNext();)\r\n-                ((RegisterClassListener) i.next()).register(pcClass);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * De-Register all metadata associated with the given ClassLoader. \r\n-     * Allows ClassLoaders to be garbage collected.\r\n-     *\r\n-     * @param cl the ClassLoader\r\n-     */\r\n-    public static void deRegister(ClassLoader cl) {\r\n-        synchronized (_metas) {\r\n-            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\r\n-                Class pcClass = (Class) i.next();\r\n-                if (pcClass.getClassLoader() == cl) {\r\n-                    _metas.remove(pcClass);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Returns a collection of class objects of the registered\r\n-     * persistence-capable classes.\r\n-     */\r\n-    public static Collection getRegisteredTypes() {\r\n-        return Collections.unmodifiableCollection(_metas.keySet());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns <code>true</code> if <code>cls</code> is already registered.\r\n-     */\r\n-    public static boolean isRegistered(Class cls) {\r\n-        return _metas.containsKey(cls);\r\n-    }\r\n-\r\n-    /**\r\n-     * Look up the metadata for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    private static Meta getMeta(Class pcClass) {\r\n-        Meta ret = (Meta) _metas.get(pcClass);\r\n-        if (ret == null)\r\n-            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\r\n-                getMessage());\r\n-        return ret;\r\n-    }\r\n-\r\n-    /**\r\n-     * Listener for persistent class registration events.\r\n-     */\r\n-    public static interface RegisterClassListener {\r\n-\r\n-        public void register(Class cls);\r\n-    }\r\n-\r\n-    /**\r\n-     * This is a helper class to manage metadata per persistence-capable class.\r\n-     */\r\n-    private static class Meta {\r\n-\r\n-        public final PersistenceCapable pc;\r\n-        public final String[] fieldNames;\r\n-        public final Class[] fieldTypes;\r\n-        public final Class pcSuper;\r\n-        public final String alias;\r\n-\r\n-        public Meta(PersistenceCapable pc, String[] fieldNames,\r\n-            Class[] fieldTypes, Class pcSuper, String alias) {\r\n-            this.pc = pc;\r\n-            this.fieldNames = fieldNames;\r\n-            this.fieldTypes = fieldTypes;\r\n-            this.pcSuper = pcSuper;\r\n-\t\t\tthis.alias = alias;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InvalidStateException;\n+\n+/**\n+ * Tracks registered persistence-capable classes.\n+ *\n+ * @since 0.4.0\n+ * @author Abe White\n+ */\n+public class PCRegistry {\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCRegistry.class);\n+\n+    // map of pc classes to meta structs; weak so the VM can GC classes\n+    private static final Map _metas = new ConcurrentReferenceHashMap\n+        (ReferenceMap.WEAK, ReferenceMap.HARD);\n+\n+    // register class listeners\n+    private static final Collection _listeners = new LinkedList();\n+\n+    /**\n+     * Register a {@link RegisterClassListener}.\n+     */\n+    public static void addRegisterClassListener(RegisterClassListener rcl) {\n+        if (rcl == null)\n+            return;\n+\n+        // we have to be positive that every listener gets notified for\n+        // every class, so lots of locking\n+        synchronized (_listeners) {\n+            _listeners.add(rcl);\n+        }\n+        synchronized (_metas) {\n+            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\n+                rcl.register((Class) itr.next());\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link RegisterClassListener}.\n+     */\n+    public static void removeRegisterClassListener(RegisterClassListener rcl) {\n+        synchronized (_listeners) {\n+            _listeners.remove(rcl);\n+        }\n+    }\n+\n+    /**\n+     * Get the field names for a <code>PersistenceCapable</code> class.\n+     */\n+    public static String[] getFieldNames(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.fieldNames;\n+    }\n+\n+    /**\n+     * Get the field types for a <code>PersistenceCapable</code> class.\n+     */\n+    public static Class[] getFieldTypes(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.fieldTypes;\n+    }\n+\n+    /**\n+     * Return the persistent superclass for a <code>PersistenceCapable</code>\n+     * class, or null if none. The superclass may or may not implement\n+     * {@link PersistenceCapable}, depending on the access type of the class.\n+     */\n+    public static Class getPersistentSuperclass(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.pcSuper;\n+    }\n+\n+    /**\n+     * Create a new instance of the class and assign its state manager.\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n+     */\n+    public static PersistenceCapable newInstance(Class pcClass,\n+        StateManager sm, boolean clear) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\n+    }\n+\n+    /**\n+     * Create a new instance of the class and assign its state manager and oid.\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n+     */\n+    public static PersistenceCapable newInstance(Class pcClass,\n+        StateManager sm, Object oid, boolean clear) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\n+    }\n+\n+    /**\n+     * Return the persistence-capable type for <code>type</code>. This might\n+     * be a generated subclass of <code>type</code>.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static Class getPCType(Class type) {\n+        Meta meta = getMeta(type);\n+        return (meta.pc == null) ? null : meta.pc.getClass();\n+    }\n+\n+    /**\n+     * Create a new identity object for the given\n+     * <code>PersistenceCapable</code> class.\n+     */\n+    public static Object newObjectId(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\n+    }\n+\n+    /**\n+     * Create a new identity object for the given\n+     * <code>PersistenceCapable</code> class, using the <code>String</code>\n+     * form of the constructor.\n+     */\n+    public static Object newObjectId(Class pcClass, String str) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\n+    }\n+\n+    /**\n+     * Return the alias for the given type.\n+     */\n+    public static String getTypeAlias(Class pcClass) {\n+        return getMeta(pcClass).alias;\n+    }\n+\n+    /**\n+     * Copy fields from an outside source to the key fields in the identity\n+     * object.\n+     */\n+    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\n+        Object oid) {\n+        Meta meta = getMeta(pcClass);\n+        if (meta.pc == null)\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n+\n+        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\n+    }\n+\n+    /**\n+     * Copy fields to an outside source from the key fields in the identity\n+     * object.\n+     */\n+    public static void copyKeyFieldsFromObjectId(Class pcClass,\n+        FieldConsumer fm, Object oid) {\n+        Meta meta = getMeta(pcClass);\n+        if (meta.pc == null)\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n+\n+        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\n+    }\n+\n+    /**\n+     * Register metadata by class.\n+     *\n+     * @param fieldTypes managed field types\n+     * @param fieldFlags managed field flags\n+     * @param sup the most immediate persistent superclass\n+     * @param pcClass the <code>PersistenceCapable</code> class\n+     * @param fieldNames managed field names\n+     * @param alias the class alias\n+     * @param pc an instance of the class, if not abstract\n+     */\n+    public static void register(Class pcClass, String[] fieldNames,\n+        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\n+        PersistenceCapable pc) {\n+        if (pcClass == null)\n+            throw new NullPointerException();\n+\n+        // we have to be positive that every listener gets notified for\n+        // every class, so lots of locking\n+        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\n+        synchronized (_metas) {\n+            _metas.put(pcClass, meta);\n+        }\n+        synchronized (_listeners) {\n+            for (Iterator i = _listeners.iterator(); i.hasNext();)\n+                ((RegisterClassListener) i.next()).register(pcClass);\n+        }\n+    }\n+\n+    /**\n+     * De-Register all metadata associated with the given ClassLoader. \n+     * Allows ClassLoaders to be garbage collected.\n+     *\n+     * @param cl the ClassLoader\n+     */\n+    public static void deRegister(ClassLoader cl) {\n+        synchronized (_metas) {\n+            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\n+                Class pcClass = (Class) i.next();\n+                if (pcClass.getClassLoader() == cl) {\n+                    _metas.remove(pcClass);\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns a collection of class objects of the registered\n+     * persistence-capable classes.\n+     */\n+    public static Collection getRegisteredTypes() {\n+        return Collections.unmodifiableCollection(_metas.keySet());\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if <code>cls</code> is already registered.\n+     */\n+    public static boolean isRegistered(Class cls) {\n+        return _metas.containsKey(cls);\n+    }\n+\n+    /**\n+     * Look up the metadata for a <code>PersistenceCapable</code> class.\n+     */\n+    private static Meta getMeta(Class pcClass) {\n+        Meta ret = (Meta) _metas.get(pcClass);\n+        if (ret == null)\n+            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\n+                getMessage());\n+        return ret;\n+    }\n+\n+    /**\n+     * Listener for persistent class registration events.\n+     */\n+    public static interface RegisterClassListener {\n+\n+        public void register(Class cls);\n+    }\n+\n+    /**\n+     * This is a helper class to manage metadata per persistence-capable class.\n+     */\n+    private static class Meta {\n+\n+        public final PersistenceCapable pc;\n+        public final String[] fieldNames;\n+        public final Class[] fieldTypes;\n+        public final Class pcSuper;\n+        public final String alias;\n+\n+        public Meta(PersistenceCapable pc, String[] fieldNames,\n+            Class[] fieldTypes, Class pcSuper, String alias) {\n+            this.pc = pc;\n+            this.fieldNames = fieldNames;\n+            this.fieldTypes = fieldTypes;\n+            this.pcSuper = pcSuper;\n+\t\t\tthis.alias = alias;\n+\t\t}\n+\t}\n+}"},{"sha":"aef221a3223762557d2d3c570628c63e318767b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"modified","additions":272,"deletions":272,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,272 +1,272 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.Method;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCMethod;\r\n-\r\n-/**\r\n- *\t<p>Validates that a given type meets the JPA contract, plus a few\r\n- *  OpenJPA-specific additions for subclassing / redefinition:\r\n- *\r\n- *\t<ul>\r\n- * \t\t<li>must have an accessible no-args constructor</li>\r\n- * \t\t<li>must be a public or protected class</li>\r\n- * \t\t<li>must not be final</li>\r\n- * \t\t<li>must not extend an enhanced class</li>\r\n- *\t\t<li>all persistent data represented by accessible setter/getter\r\n- * \t\t\tmethods (persistent properties)</li>\r\n- * \t\t<li>if versioning is to be used, exactly one persistent property for\r\n- * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\r\n- *\r\n- * \t\t<li>When using property access, the backing field for a persistent\r\n- *          property must be:\r\n- * \t\t\t<ul>\r\n- * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\r\n- * \t\t\t\t<li>private</li>\r\n- * \t\t\t\t<li>set only in the designated setter,\r\n- * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\r\n- * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\r\n- * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\r\n- * \t\t\t\t<li>read only in the designated getter and the\r\n- * \t\t\t\t\tconstructor.</li>\r\n- *\t\t\t</ul>\r\n- * \t\t</li>\r\n- * \t</ul>\r\n- *\r\n- * \t<p>If you use this technique and use the <code>new</code> keyword instead of\r\n- * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\r\n- *  with persistent-new-flushed instances, since OpenJPA cannot in this case\r\n- *  track what happens to such an instance.</p>\r\n- *\r\n- * \t@since 1.0.0\r\n- */\r\n-public class PCSubclassValidator {\r\n-\r\n-    private static final Localizer loc =\r\n-        Localizer.forPackage(PCSubclassValidator.class);\r\n-\r\n-    private final ClassMetaData meta;\r\n-    private final BCClass pc;\r\n-    private final Log log;\r\n-    private final boolean failOnContractViolations;\r\n-\r\n-    private Collection errors;\r\n-    private Collection contractViolations;\r\n-\r\n-    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\r\n-        boolean enforceContractViolations) {\r\n-        this.meta = meta;\r\n-        this.pc = bc;\r\n-        this.log = log;\r\n-        this.failOnContractViolations = enforceContractViolations;\r\n-    }\r\n-\r\n-    public void assertCanSubclass() {\r\n-        Class superclass = meta.getDescribedType();\r\n-        String name = superclass.getName();\r\n-        if (superclass.isInterface())\r\n-            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\r\n-        if (Modifier.isFinal(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\r\n-        if (Modifier.isPrivate(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\r\n-        if (PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\r\n-\r\n-        try {\r\n-            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\r\n-            if (!(Modifier.isProtected(c.getModifiers())\r\n-                || Modifier.isPublic(c.getModifiers())))\r\n-                addError(loc.get(\"subclasser-private-ctor\", name), meta);\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            addError(loc.get(\"subclasser-no-void-ctor\", name),\r\n-                meta);\r\n-        }\r\n-\r\n-        // if the BCClass we loaded is already pc and the superclass is not,\r\n-        // then we should never get here, so let's make sure that the\r\n-        // calling context is caching correctly by throwing an exception.\r\n-        if (pc.isInstanceOf(PersistenceCapable.class) &&\r\n-            !PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            throw new InternalException(\r\n-                loc.get(\"subclasser-class-already-pc\", name));\r\n-\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\r\n-            checkPropertiesAreInterceptable();\r\n-\r\n-        if (errors != null && !errors.isEmpty())\r\n-            throw new UserException(errors.toString());\r\n-        else if (contractViolations != null &&\r\n-            !contractViolations.isEmpty() && log.isWarnEnabled())\r\n-            log.warn(contractViolations.toString());\r\n-    }\r\n-\r\n-    private void checkPropertiesAreInterceptable() {\r\n-        // just considers accessor methods for now.\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            Method getter = (Method) fmds[i].getBackingMember();\r\n-            if (getter == null) {\r\n-                addError(loc.get(\"subclasser-no-getter\",\r\n-                    fmds[i].getName()), fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\r\n-\r\n-            Method setter = setterForField(fmds[i]);\r\n-            if (setter == null) {\r\n-                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\r\n-                    fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\r\n-            if (assignedField == null)\r\n-                continue;\r\n-\r\n-            if (assignedField != returnedField)\r\n-                addContractViolation(loc.get\r\n-                    (\"subclasser-setter-getter-field-mismatch\",\r\n-                        fmds[i].getName(), returnedField,assignedField),\r\n-                    fmds[i]);\r\n-\r\n-            // ### scan through all the rest of the class to make sure it\r\n-            // ### doesn't use the field.\r\n-        }\r\n-    }\r\n-\r\n-    private Method setterForField(FieldMetaData fmd) {\r\n-        try {\r\n-            return fmd.getDeclaringType().getDeclaredMethod(\r\n-                \"set\" + StringUtils.capitalize(fmd.getName()),\r\n-                new Class[]{ fmd.getDeclaredType() });\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the name of the field that is returned by <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         returned, or if it cannot be determined what is returned.\r\n-     */\r\n-    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-getter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the field that is set in <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         set, or if it cannot be determined what is set.\r\n-     */\r\n-    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-setter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    private BCMethod getBCMethod(Method meth) {\r\n-        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\r\n-        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\r\n-    }\r\n-\r\n-    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        String className = fmd.getDefiningMetaData().\r\n-            getDescribedType().getName();\r\n-        if (!(Modifier.isProtected(meth.getModifiers())\r\n-            || Modifier.isPublic(meth.getModifiers())))\r\n-            addError(loc.get(\"subclasser-private-accessors-unsupported\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isFinal(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-final-methods-not-allowed\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isNative(meth.getModifiers()))\r\n-            addContractViolation(loc.get\r\n-                (\"subclasser-native-methods-not-allowed\", className,\r\n-                    meth.getName()),\r\n-                fmd);\r\n-        if (Modifier.isStatic(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-static-methods-not-supported\",\r\n-                className, meth.getName()), fmd);\r\n-    }\r\n-\r\n-    private void addError(Message s, ClassMetaData cls) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-meta\", s,\r\n-            cls.getDescribedType().getName(),\r\n-            cls.getSourceFile()));\r\n-    }\r\n-\r\n-    private void addError(Message s, FieldMetaData fmd) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-field\", s,\r\n-            fmd.getFullName(),\r\n-            fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-\r\n-    private void addContractViolation(Message m, FieldMetaData fmd) {\r\n-        // add the violation as an error in case we're processing violations\r\n-        // as errors; this keeps them in the order that they were found rather\r\n-        // than just adding the violations to the end of the list.\r\n-        if (failOnContractViolations)\r\n-            addError(m, fmd);\r\n-\r\n-        if (contractViolations == null)\r\n-            contractViolations = new ArrayList();\r\n-\r\n-        contractViolations.add(loc.get\r\n-            (\"subclasser-contract-violation-field\", m.getMessage(),\r\n-                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.lib.log.Log;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCMethod;\n+\n+/**\n+ *\t<p>Validates that a given type meets the JPA contract, plus a few\n+ *  OpenJPA-specific additions for subclassing / redefinition:\n+ *\n+ *\t<ul>\n+ * \t\t<li>must have an accessible no-args constructor</li>\n+ * \t\t<li>must be a public or protected class</li>\n+ * \t\t<li>must not be final</li>\n+ * \t\t<li>must not extend an enhanced class</li>\n+ *\t\t<li>all persistent data represented by accessible setter/getter\n+ * \t\t\tmethods (persistent properties)</li>\n+ * \t\t<li>if versioning is to be used, exactly one persistent property for\n+ * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\n+ *\n+ * \t\t<li>When using property access, the backing field for a persistent\n+ *          property must be:\n+ * \t\t\t<ul>\n+ * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\n+ * \t\t\t\t<li>private</li>\n+ * \t\t\t\t<li>set only in the designated setter,\n+ * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\n+ * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\n+ * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\n+ * \t\t\t\t<li>read only in the designated getter and the\n+ * \t\t\t\t\tconstructor.</li>\n+ *\t\t\t</ul>\n+ * \t\t</li>\n+ * \t</ul>\n+ *\n+ * \t<p>If you use this technique and use the <code>new</code> keyword instead of\n+ * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\n+ *  with persistent-new-flushed instances, since OpenJPA cannot in this case\n+ *  track what happens to such an instance.</p>\n+ *\n+ * \t@since 1.0.0\n+ */\n+public class PCSubclassValidator {\n+\n+    private static final Localizer loc =\n+        Localizer.forPackage(PCSubclassValidator.class);\n+\n+    private final ClassMetaData meta;\n+    private final BCClass pc;\n+    private final Log log;\n+    private final boolean failOnContractViolations;\n+\n+    private Collection errors;\n+    private Collection contractViolations;\n+\n+    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\n+        boolean enforceContractViolations) {\n+        this.meta = meta;\n+        this.pc = bc;\n+        this.log = log;\n+        this.failOnContractViolations = enforceContractViolations;\n+    }\n+\n+    public void assertCanSubclass() {\n+        Class superclass = meta.getDescribedType();\n+        String name = superclass.getName();\n+        if (superclass.isInterface())\n+            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\n+        if (Modifier.isFinal(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\n+        if (Modifier.isPrivate(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\n+        if (PersistenceCapable.class.isAssignableFrom(superclass))\n+            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\n+\n+        try {\n+            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\n+            if (!(Modifier.isProtected(c.getModifiers())\n+                || Modifier.isPublic(c.getModifiers())))\n+                addError(loc.get(\"subclasser-private-ctor\", name), meta);\n+        }\n+        catch (NoSuchMethodException e) {\n+            addError(loc.get(\"subclasser-no-void-ctor\", name),\n+                meta);\n+        }\n+\n+        // if the BCClass we loaded is already pc and the superclass is not,\n+        // then we should never get here, so let's make sure that the\n+        // calling context is caching correctly by throwing an exception.\n+        if (pc.isInstanceOf(PersistenceCapable.class) &&\n+            !PersistenceCapable.class.isAssignableFrom(superclass))\n+            throw new InternalException(\n+                loc.get(\"subclasser-class-already-pc\", name));\n+\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\n+            checkPropertiesAreInterceptable();\n+\n+        if (errors != null && !errors.isEmpty())\n+            throw new UserException(errors.toString());\n+        else if (contractViolations != null &&\n+            !contractViolations.isEmpty() && log.isWarnEnabled())\n+            log.warn(contractViolations.toString());\n+    }\n+\n+    private void checkPropertiesAreInterceptable() {\n+        // just considers accessor methods for now.\n+        FieldMetaData[] fmds = meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            Method getter = (Method) fmds[i].getBackingMember();\n+            if (getter == null) {\n+                addError(loc.get(\"subclasser-no-getter\",\n+                    fmds[i].getName()), fmds[i]);\n+                continue;\n+            }\n+            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\n+\n+            Method setter = setterForField(fmds[i]);\n+            if (setter == null) {\n+                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\n+                    fmds[i]);\n+                continue;\n+            }\n+            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\n+            if (assignedField == null)\n+                continue;\n+\n+            if (assignedField != returnedField)\n+                addContractViolation(loc.get\n+                    (\"subclasser-setter-getter-field-mismatch\",\n+                        fmds[i].getName(), returnedField,assignedField),\n+                    fmds[i]);\n+\n+            // ### scan through all the rest of the class to make sure it\n+            // ### doesn't use the field.\n+        }\n+    }\n+\n+    private Method setterForField(FieldMetaData fmd) {\n+        try {\n+            return fmd.getDeclaringType().getDeclaredMethod(\n+                \"set\" + StringUtils.capitalize(fmd.getName()),\n+                new Class[]{ fmd.getDeclaredType() });\n+        }\n+        catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @return the name of the field that is returned by <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         returned, or if it cannot be determined what is returned.\n+     */\n+    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-getter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    /**\n+     * @return the field that is set in <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         set, or if it cannot be determined what is set.\n+     */\n+    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-setter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    private BCMethod getBCMethod(Method meth) {\n+        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\n+        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\n+    }\n+\n+    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\n+        String className = fmd.getDefiningMetaData().\n+            getDescribedType().getName();\n+        if (!(Modifier.isProtected(meth.getModifiers())\n+            || Modifier.isPublic(meth.getModifiers())))\n+            addError(loc.get(\"subclasser-private-accessors-unsupported\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isFinal(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-final-methods-not-allowed\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isNative(meth.getModifiers()))\n+            addContractViolation(loc.get\n+                (\"subclasser-native-methods-not-allowed\", className,\n+                    meth.getName()),\n+                fmd);\n+        if (Modifier.isStatic(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-static-methods-not-supported\",\n+                className, meth.getName()), fmd);\n+    }\n+\n+    private void addError(Message s, ClassMetaData cls) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-meta\", s,\n+            cls.getDescribedType().getName(),\n+            cls.getSourceFile()));\n+    }\n+\n+    private void addError(Message s, FieldMetaData fmd) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-field\", s,\n+            fmd.getFullName(),\n+            fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+\n+    private void addContractViolation(Message m, FieldMetaData fmd) {\n+        // add the violation as an error in case we're processing violations\n+        // as errors; this keeps them in the order that they were found rather\n+        // than just adding the violations to the end of the list.\n+        if (failOnContractViolations)\n+            addError(m, fmd);\n+\n+        if (contractViolations == null)\n+            contractViolations = new ArrayList();\n+\n+        contractViolations.add(loc.get\n+            (\"subclasser-contract-violation-field\", m.getMessage(),\n+                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+}"},{"sha":"b49ad7e8630bddcb873e2a4747bfb1dcc6d51d94","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"modified","additions":237,"deletions":237,"changes":474,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,237 +1,237 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.InvocationHandler;\r\n-import java.lang.reflect.Proxy;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Field;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * Helper methods for managed types that use method redefinition for field\r\n- * tracking.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class RedefinitionHelper {\r\n-\r\n-    /**\r\n-     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\r\n-     * {@link StateManagerImpl}.\r\n-     */\r\n-    public static void dirtyCheck(StateManager sm) {\r\n-        if (sm instanceof StateManagerImpl)\r\n-            ((StateManagerImpl) sm).dirtyCheck();\r\n-    }\r\n-\r\n-    /**\r\n-     * Notify the state manager for <code>o</code> (if any) that a field\r\n-     * is about to be accessed.\r\n-     */\r\n-    public static void accessingField(Object o, int absoluteIndex) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.accessingField(absoluteIndex);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, boolean cur,\r\n-        boolean next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingBooleanField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, char cur, char next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingCharField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, byte cur, byte next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingByteField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, short cur, short next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingShortField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, int cur, int next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingIntField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, long cur, long next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingLongField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, float cur, float next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingFloatField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, double cur,\r\n-        double next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingDoubleField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, String cur,\r\n-        String next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingStringField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, Object cur,\r\n-        Object next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingObjectField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a container instance that will delegate back to the state\r\n-     * manager to emulate lazy loading. This is used by PC subclasses for\r\n-     * unenhanced types that could not be redefined, and thus do not have\r\n-     * field-interception capabilities. Do this for all collection and\r\n-     * map field types, even if they are in the dfg, in case the fetch\r\n-     * groups are reset at runtime.\r\n-     *\r\n-     * @since 1.1.0\r\n-     */\r\n-    public static void assignLazyLoadProxies(StateManagerImpl sm) {\r\n-        FieldMetaData[] fmds = sm.getMetaData().getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            switch (fmds[i].getTypeCode()) {\r\n-                case JavaTypes.COLLECTION:\r\n-                case JavaTypes.MAP:\r\n-                    PersistenceCapable pc = sm.getPersistenceCapable();\r\n-                    Field field = (Field) fmds[i].getBackingMember();\r\n-                    Reflection.set(pc, field,\r\n-                        newLazyLoadingProxy(fmds[i].getDeclaredType(), i, sm));\r\n-                    break;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static Object newLazyLoadingProxy(Class type, final int idx,\r\n-        final StateManagerImpl sm) {\r\n-        InvocationHandler handler = new InvocationHandler() {\r\n-\r\n-            public Object invoke(Object proxy, Method method, Object[] args)\r\n-                throws Throwable {\r\n-                // this will replace the field in the instance, so the dynamic\r\n-                // proxy should only be called the first time a\r\n-                // lazy-load-proxied field is used in normal usage.\r\n-                Object delegate = sm.fetch(idx);\r\n-                return method.invoke(delegate, args);\r\n-            }\r\n-        };\r\n-        return Proxy.newProxyInstance(type.getClassLoader(),\r\n-            new Class[] { type }, handler);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * Helper methods for managed types that use method redefinition for field\n+ * tracking.\n+ *\n+ * @since 1.0.0\n+ */\n+public class RedefinitionHelper {\n+\n+    /**\n+     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\n+     * {@link StateManagerImpl}.\n+     */\n+    public static void dirtyCheck(StateManager sm) {\n+        if (sm instanceof StateManagerImpl)\n+            ((StateManagerImpl) sm).dirtyCheck();\n+    }\n+\n+    /**\n+     * Notify the state manager for <code>o</code> (if any) that a field\n+     * is about to be accessed.\n+     */\n+    public static void accessingField(Object o, int absoluteIndex) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.accessingField(absoluteIndex);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, boolean cur,\n+        boolean next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingBooleanField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, char cur, char next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingCharField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, byte cur, byte next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingByteField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, short cur, short next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingShortField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, int cur, int next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingIntField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, long cur, long next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingLongField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, float cur, float next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingFloatField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, double cur,\n+        double next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingDoubleField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, String cur,\n+        String next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingStringField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, Object cur,\n+        Object next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingObjectField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Create a container instance that will delegate back to the state\n+     * manager to emulate lazy loading. This is used by PC subclasses for\n+     * unenhanced types that could not be redefined, and thus do not have\n+     * field-interception capabilities. Do this for all collection and\n+     * map field types, even if they are in the dfg, in case the fetch\n+     * groups are reset at runtime.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static void assignLazyLoadProxies(StateManagerImpl sm) {\n+        FieldMetaData[] fmds = sm.getMetaData().getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            switch (fmds[i].getTypeCode()) {\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    PersistenceCapable pc = sm.getPersistenceCapable();\n+                    Field field = (Field) fmds[i].getBackingMember();\n+                    Reflection.set(pc, field,\n+                        newLazyLoadingProxy(fmds[i].getDeclaredType(), i, sm));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private static Object newLazyLoadingProxy(Class type, final int idx,\n+        final StateManagerImpl sm) {\n+        InvocationHandler handler = new InvocationHandler() {\n+\n+            public Object invoke(Object proxy, Method method, Object[] args)\n+                throws Throwable {\n+                // this will replace the field in the instance, so the dynamic\n+                // proxy should only be called the first time a\n+                // lazy-load-proxied field is used in normal usage.\n+                Object delegate = sm.fetch(idx);\n+                return method.invoke(delegate, args);\n+            }\n+        };\n+        return Proxy.newProxyInstance(type.getClassLoader(),\n+            new Class[] { type }, handler);\n+    }\n+}"},{"sha":"d3bce1033e51876f7dfcb0ea500663fefa881cd3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":387,"deletions":387,"changes":774,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,387 +1,387 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Serializable;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Method;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.ApplicationIds;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.ObjectId;\r\n-\r\n-/**\r\n- * Implementation of the {@link PersistenceCapable} interface that can handle\r\n- * the persistence-capable contract for instances that were not enhanced\r\n- * before class load time.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ReflectingPersistenceCapable\r\n-    implements PersistenceCapable, ManagedInstanceProvider, Serializable {\r\n-\r\n-    private Object o;\r\n-    private StateManager sm;\r\n-\r\n-    // this will be reconstituted in readObject()\r\n-    private transient PersistenceCapable pcSubclassInstance;\r\n-\r\n-    // this will reconstituted by a call to pcReplaceStateManager() by the\r\n-    // instance that has a reference to the deserialized data\r\n-    private transient ClassMetaData meta;\r\n-\r\n-    private boolean serializationUserVisible = true;\r\n-\r\n-    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\r\n-        this.o = o;\r\n-        Class type = o.getClass();\r\n-        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n-        meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(type, null, true);\r\n-    }\r\n-\r\n-    public int pcGetEnhancementContractVersion() {\r\n-        return PCEnhancer.ENHANCER_VERSION;\r\n-    }\r\n-\r\n-    public Object pcGetGenericContext() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getGenericContext();\r\n-    }\r\n-\r\n-    public StateManager pcGetStateManager() {\r\n-        return sm;\r\n-    }\r\n-\r\n-    public void pcReplaceStateManager(StateManager sm) {\r\n-        this.sm = sm;\r\n-        if (meta == null && sm instanceof OpenJPAStateManager)\r\n-            meta = ((OpenJPAStateManager) sm).getMetaData();\r\n-    }\r\n-\r\n-    public void pcProvideField(int i) {\r\n-        Object value = getValue(i, o);\r\n-        switch (meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                sm.providedBooleanField(this, i, value == null ? false :\r\n-                    ((Boolean) value).booleanValue());\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                sm.providedByteField(this, i, value == null ? 0 :\r\n-                    ((Byte) value).byteValue());\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                sm.providedCharField(this, i, value == null ? 0 :\r\n-                    ((Character) value).charValue());\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                sm.providedDoubleField(this, i, value == null ? 0 :\r\n-                    ((Double) value).doubleValue());\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                sm.providedFloatField(this, i, value == null ? 0 :\r\n-                    ((Float) value).floatValue());\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                sm.providedIntField(this, i, value == null ? 0 :\r\n-                    ((Integer) value).intValue());\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                sm.providedLongField(this, i, value == null ? 0 :\r\n-                    ((Long) value).longValue());\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                sm.providedShortField(this, i, value == null ? 0 :\r\n-                    ((Short) value).shortValue());\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                sm.providedStringField(this, i, (String) value);\r\n-                break;\r\n-            default:\r\n-                sm.providedObjectField(this, i, value);\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcProvideFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcProvideField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcReplaceField(int i) {\r\n-        switch(meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                setValue(i, o, Boolean.valueOf(\r\n-                    sm.replaceBooleanField(this, i)));\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                setValue(i, o, new Character(sm.replaceCharField(this, i)));\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                setValue(i, o, new Long(sm.replaceLongField(this, i)));\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                setValue(i, o, new Short(sm.replaceShortField(this, i)));\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                setValue(i, o, sm.replaceStringField(this, i));\r\n-                break;\r\n-            default:\r\n-                setValue(i, o, sm.replaceObjectField(this, i));\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcReplaceFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcReplaceField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcCopyField(Object fromObject, int i) {\r\n-        // this doesn't need switch treatment because we're just\r\n-        // reflecting on both sides, bypassing field managers.\r\n-        setValue(i, o, getValue(i, fromObject));\r\n-    }\r\n-\r\n-    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\r\n-        if (fromObject instanceof ReflectingPersistenceCapable)\r\n-            fromObject = ((ReflectingPersistenceCapable) fromObject)\r\n-                .getManagedInstance();\r\n-        \r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcCopyField(fromObject, fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcDirty(String fieldName) {\r\n-        if (sm != null)\r\n-            sm.dirty(fieldName);\r\n-    }\r\n-\r\n-    public Object pcFetchObjectId() {\r\n-        if (sm != null)\r\n-            return sm.fetchObjectId();\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public Object pcGetVersion() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getVersion();\r\n-    }\r\n-\r\n-    public boolean pcIsDirty() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else {\r\n-            if (sm instanceof StateManagerImpl)\r\n-                ((StateManagerImpl) sm).dirtyCheck();\r\n-            return sm.isDirty();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean pcIsTransactional() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isTransactional();\r\n-    }\r\n-\r\n-    public boolean pcIsPersistent() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isPersistent();\r\n-    }\r\n-\r\n-    public boolean pcIsNew() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isNew();\r\n-    }\r\n-\r\n-    public boolean pcIsDeleted() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isDeleted();\r\n-    }\r\n-\r\n-    // null == unknown\r\n-    public Boolean pcIsDetached() {\r\n-        if (sm != null)\r\n-            return Boolean.valueOf(sm.isDetached());\r\n-\r\n-        // ##### we could do a lot more here if a detached state field\r\n-        // ##### was specified.\r\n-        return null;\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, clear);\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\r\n-        boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\r\n-    }\r\n-\r\n-    public Object pcNewObjectIdInstance() {\r\n-        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\r\n-        Object[] pks = new Object[pkFields.length];\r\n-        for (int i = 0; i < pkFields.length; i++)\r\n-            pks[i] = getValue(pkFields[i].getIndex(), o);\r\n-        return ApplicationIds.fromPKValues(pks, meta);\r\n-    }\r\n-    \r\n-    public Object pcNewObjectIdInstance(Object oid) {\r\n-        return pcSubclassInstance.pcNewObjectIdInstance(oid);\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(Object oid) {\r\n-        Object target;\r\n-        if (oid instanceof ObjectId)\r\n-            target = ((ObjectId) oid).getId();\r\n-        else\r\n-            target = oid;\r\n-\r\n-        FieldMetaData[] pks = meta.getPrimaryKeyFields();\r\n-        for (int i = 0; i < pks.length; i++) {\r\n-            Object val = getValue(pks[i].getIndex(), o);\r\n-            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\r\n-                true);\r\n-            Reflection.set(target, f, val);\r\n-        }\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\r\n-        Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object pcGetDetachedState() {\r\n-        // ##### we can implement this if a state field has been set\r\n-        return null;\r\n-    }\r\n-\r\n-    public void pcSetDetachedState(Object state) {\r\n-        // StateManagerImpl will invoke this with null during instance\r\n-        // initialization\r\n-        if (state != null)\r\n-            throw new UnsupportedOperationException();\r\n-        // ##### we can implement this if a state field has been set\r\n-    }\r\n-\r\n-    public void pcSetSerializationUserVisible(boolean userVisible) {\r\n-        serializationUserVisible = userVisible;\r\n-    }\r\n-\r\n-    public boolean pcIsSerializationUserVisible() {\r\n-        return serializationUserVisible;\r\n-    }\r\n-\r\n-    public Object getManagedInstance() {\r\n-        return o;\r\n-    }\r\n-\r\n-    private Object getValue(int i, Object o) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            Field field = Reflection.findField(meta.getDescribedType(),\r\n-                toFieldName(i), true);\r\n-            return Reflection.get(o, field);\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            return Reflection.get(o, field);\r\n-        }\r\n-    }\r\n-\r\n-    private String toFieldName(int i) {\r\n-        if (pcSubclassInstance instanceof AttributeTranslator)\r\n-            return ((AttributeTranslator) pcSubclassInstance)\r\n-                .pcAttributeIndexToFieldName(i);\r\n-        else\r\n-            return meta.getField(i).getName();\r\n-    }\r\n-\r\n-    private void setValue(int i, Object o, Object val) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findSetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                Reflection.set(o, meth, val);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                Reflection.set(o, field, val);\r\n-            }\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            Reflection.set(o, field, val);\r\n-        }\r\n-    }\r\n-\r\n-    private void writeObject(ObjectOutputStream out) throws IOException {\r\n-        out.defaultWriteObject();\r\n-        out.writeObject(meta.getDescribedType());\r\n-    }\r\n-\r\n-    private void readObject(ObjectInputStream in)\r\n-        throws ClassNotFoundException, IOException {\r\n-        in.defaultReadObject();\r\n-        Class type = (Class) in.readObject();\r\n-        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n-        ImplHelper.registerPersistenceCapable(this);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.ObjectId;\n+\n+/**\n+ * Implementation of the {@link PersistenceCapable} interface that can handle\n+ * the persistence-capable contract for instances that were not enhanced\n+ * before class load time.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ReflectingPersistenceCapable\n+    implements PersistenceCapable, ManagedInstanceProvider, Serializable {\n+\n+    private Object o;\n+    private StateManager sm;\n+\n+    // this will be reconstituted in readObject()\n+    private transient PersistenceCapable pcSubclassInstance;\n+\n+    // this will reconstituted by a call to pcReplaceStateManager() by the\n+    // instance that has a reference to the deserialized data\n+    private transient ClassMetaData meta;\n+\n+    private boolean serializationUserVisible = true;\n+\n+    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\n+        this.o = o;\n+        Class type = o.getClass();\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\n+        meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(type, null, true);\n+    }\n+\n+    public int pcGetEnhancementContractVersion() {\n+        return PCEnhancer.ENHANCER_VERSION;\n+    }\n+\n+    public Object pcGetGenericContext() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getGenericContext();\n+    }\n+\n+    public StateManager pcGetStateManager() {\n+        return sm;\n+    }\n+\n+    public void pcReplaceStateManager(StateManager sm) {\n+        this.sm = sm;\n+        if (meta == null && sm instanceof OpenJPAStateManager)\n+            meta = ((OpenJPAStateManager) sm).getMetaData();\n+    }\n+\n+    public void pcProvideField(int i) {\n+        Object value = getValue(i, o);\n+        switch (meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                sm.providedBooleanField(this, i, value == null ? false :\n+                    ((Boolean) value).booleanValue());\n+                break;\n+            case JavaTypes.BYTE:\n+                sm.providedByteField(this, i, value == null ? 0 :\n+                    ((Byte) value).byteValue());\n+                break;\n+            case JavaTypes.CHAR:\n+                sm.providedCharField(this, i, value == null ? 0 :\n+                    ((Character) value).charValue());\n+                break;\n+            case JavaTypes.DOUBLE:\n+                sm.providedDoubleField(this, i, value == null ? 0 :\n+                    ((Double) value).doubleValue());\n+                break;\n+            case JavaTypes.FLOAT:\n+                sm.providedFloatField(this, i, value == null ? 0 :\n+                    ((Float) value).floatValue());\n+                break;\n+            case JavaTypes.INT:\n+                sm.providedIntField(this, i, value == null ? 0 :\n+                    ((Integer) value).intValue());\n+                break;\n+            case JavaTypes.LONG:\n+                sm.providedLongField(this, i, value == null ? 0 :\n+                    ((Long) value).longValue());\n+                break;\n+            case JavaTypes.SHORT:\n+                sm.providedShortField(this, i, value == null ? 0 :\n+                    ((Short) value).shortValue());\n+                break;\n+            case JavaTypes.STRING:\n+                sm.providedStringField(this, i, (String) value);\n+                break;\n+            default:\n+                sm.providedObjectField(this, i, value);\n+                break;\n+        }\n+    }\n+\n+    public void pcProvideFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcProvideField(fieldIndices[i]);\n+    }\n+\n+    public void pcReplaceField(int i) {\n+        switch(meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                setValue(i, o, Boolean.valueOf(\n+                    sm.replaceBooleanField(this, i)));\n+                break;\n+            case JavaTypes.BYTE:\n+                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\n+                break;\n+            case JavaTypes.CHAR:\n+                setValue(i, o, new Character(sm.replaceCharField(this, i)));\n+                break;\n+            case JavaTypes.DOUBLE:\n+                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\n+                break;\n+            case JavaTypes.FLOAT:\n+                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\n+                break;\n+            case JavaTypes.INT:\n+                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\n+                break;\n+            case JavaTypes.LONG:\n+                setValue(i, o, new Long(sm.replaceLongField(this, i)));\n+                break;\n+            case JavaTypes.SHORT:\n+                setValue(i, o, new Short(sm.replaceShortField(this, i)));\n+                break;\n+            case JavaTypes.STRING:\n+                setValue(i, o, sm.replaceStringField(this, i));\n+                break;\n+            default:\n+                setValue(i, o, sm.replaceObjectField(this, i));\n+                break;\n+        }\n+    }\n+\n+    public void pcReplaceFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcReplaceField(fieldIndices[i]);\n+    }\n+\n+    public void pcCopyField(Object fromObject, int i) {\n+        // this doesn't need switch treatment because we're just\n+        // reflecting on both sides, bypassing field managers.\n+        setValue(i, o, getValue(i, fromObject));\n+    }\n+\n+    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\n+        if (fromObject instanceof ReflectingPersistenceCapable)\n+            fromObject = ((ReflectingPersistenceCapable) fromObject)\n+                .getManagedInstance();\n+        \n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcCopyField(fromObject, fieldIndices[i]);\n+    }\n+\n+    public void pcDirty(String fieldName) {\n+        if (sm != null)\n+            sm.dirty(fieldName);\n+    }\n+\n+    public Object pcFetchObjectId() {\n+        if (sm != null)\n+            return sm.fetchObjectId();\n+        else\n+            return null;\n+    }\n+\n+    public Object pcGetVersion() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getVersion();\n+    }\n+\n+    public boolean pcIsDirty() {\n+        if (sm == null)\n+            return false;\n+        else {\n+            if (sm instanceof StateManagerImpl)\n+                ((StateManagerImpl) sm).dirtyCheck();\n+            return sm.isDirty();\n+        }\n+    }\n+\n+    public boolean pcIsTransactional() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isTransactional();\n+    }\n+\n+    public boolean pcIsPersistent() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isPersistent();\n+    }\n+\n+    public boolean pcIsNew() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isNew();\n+    }\n+\n+    public boolean pcIsDeleted() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isDeleted();\n+    }\n+\n+    // null == unknown\n+    public Boolean pcIsDetached() {\n+        if (sm != null)\n+            return Boolean.valueOf(sm.isDetached());\n+\n+        // ##### we could do a lot more here if a detached state field\n+        // ##### was specified.\n+        return null;\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, clear);\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\n+        boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\n+    }\n+\n+    public Object pcNewObjectIdInstance() {\n+        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\n+        Object[] pks = new Object[pkFields.length];\n+        for (int i = 0; i < pkFields.length; i++)\n+            pks[i] = getValue(pkFields[i].getIndex(), o);\n+        return ApplicationIds.fromPKValues(pks, meta);\n+    }\n+    \n+    public Object pcNewObjectIdInstance(Object oid) {\n+        return pcSubclassInstance.pcNewObjectIdInstance(oid);\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(Object oid) {\n+        Object target;\n+        if (oid instanceof ObjectId)\n+            target = ((ObjectId) oid).getId();\n+        else\n+            target = oid;\n+\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\n+        for (int i = 0; i < pks.length; i++) {\n+            Object val = getValue(pks[i].getIndex(), o);\n+            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\n+                true);\n+            Reflection.set(target, f, val);\n+        }\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\n+        Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public Object pcGetDetachedState() {\n+        // ##### we can implement this if a state field has been set\n+        return null;\n+    }\n+\n+    public void pcSetDetachedState(Object state) {\n+        // StateManagerImpl will invoke this with null during instance\n+        // initialization\n+        if (state != null)\n+            throw new UnsupportedOperationException();\n+        // ##### we can implement this if a state field has been set\n+    }\n+\n+    public void pcSetSerializationUserVisible(boolean userVisible) {\n+        serializationUserVisible = userVisible;\n+    }\n+\n+    public boolean pcIsSerializationUserVisible() {\n+        return serializationUserVisible;\n+    }\n+\n+    public Object getManagedInstance() {\n+        return o;\n+    }\n+\n+    private Object getValue(int i, Object o) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            Field field = Reflection.findField(meta.getDescribedType(),\n+                toFieldName(i), true);\n+            return Reflection.get(o, field);\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            return Reflection.get(o, field);\n+        }\n+    }\n+\n+    private String toFieldName(int i) {\n+        if (pcSubclassInstance instanceof AttributeTranslator)\n+            return ((AttributeTranslator) pcSubclassInstance)\n+                .pcAttributeIndexToFieldName(i);\n+        else\n+            return meta.getField(i).getName();\n+    }\n+\n+    private void setValue(int i, Object o, Object val) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            if (!meta.isIntercepting()) {\n+                Method meth = Reflection.findSetter(meta.getDescribedType(),\n+                    meta.getField(i).getName(), true);\n+                Reflection.set(o, meth, val);\n+            } else {\n+                Field field = Reflection.findField(meta.getDescribedType(),\n+                    toFieldName(i), true);\n+                Reflection.set(o, field, val);\n+            }\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            Reflection.set(o, field, val);\n+        }\n+    }\n+\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(meta.getDescribedType());\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws ClassNotFoundException, IOException {\n+        in.defaultReadObject();\n+        Class type = (Class) in.readObject();\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\n+        ImplHelper.registerPersistenceCapable(this);\n+    }\n+}"},{"sha":"a37b53753593756a5f49f37ab603b0875a6df885","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\r\n- * configuration setting.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface RuntimeUnenhancedClassesModes {\r\n-    public final static int SUPPORTED = 0;\r\n-    public final static int UNSUPPORTED = 1;\r\n-    public final static int WARN = 2;\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\n+ * configuration setting.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface RuntimeUnenhancedClassesModes {\n+    public final static int SUPPORTED = 0;\n+    public final static int UNSUPPORTED = 1;\n+    public final static int WARN = 2;\n }\n\\ No newline at end of file"},{"sha":"41848ae2942c0d72bac8123c2663ba6124caaa31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\r\n- * configuration setting.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface RuntimeUnenhancedClasssesModes {\r\n-    public final static int SUPPORTED = 0;\r\n-    public final static int UNSUPPORTED = 1;\r\n-    public final static int WARN = 2;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\n+ * configuration setting.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface RuntimeUnenhancedClasssesModes {\n+    public final static int SUPPORTED = 0;\n+    public final static int UNSUPPORTED = 1;\n+    public final static int WARN = 2;\n+}"},{"sha":"4c2ba87e2c6a9ef03124fb598aae0218f6e25e95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab","patch":"@@ -1,56 +1,56 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import java.util.EventObject;\r\n-\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-\r\n-/**\r\n- * Event fired when a {@link BrokerFactory} is created.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class BrokerFactoryEvent\r\n-    extends EventObject {\r\n-\r\n-    /**\r\n-     * Fired after a {@link BrokerFactory} has been fully created.\r\n-     * This happens after the factory has been made read-only.\r\n-     */\r\n-    public static final int BROKER_FACTORY_CREATED = 0;\r\n-\r\n-    private int eventType;\r\n-\r\n-    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\r\n-        super(brokerFactory);\r\n-        this.eventType = eventType;\r\n-    }\r\n-\r\n-    public BrokerFactory getBrokerFactory() {\r\n-        return (BrokerFactory) getSource();\r\n-    }\r\n-\r\n-    /**\r\n-     * @return one of the event type codes defined in this event class.\r\n-     */\r\n-    public int getEventType() {\r\n-        return eventType;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import java.util.EventObject;\n+\n+import org.apache.openjpa.kernel.BrokerFactory;\n+\n+/**\n+ * Event fired when a {@link BrokerFactory} is created.\n+ *\n+ * @since 1.0.0\n+ */\n+public class BrokerFactoryEvent\n+    extends EventObject {\n+\n+    /**\n+     * Fired after a {@link BrokerFactory} has been fully created.\n+     * This happens after the factory has been made read-only.\n+     */\n+    public static final int BROKER_FACTORY_CREATED = 0;\n+\n+    private int eventType;\n+\n+    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\n+        super(brokerFactory);\n+        this.eventType = eventType;\n+    }\n+\n+    public BrokerFactory getBrokerFactory() {\n+        return (BrokerFactory) getSource();\n+    }\n+\n+    /**\n+     * @return one of the event type codes defined in this event class.\n+     */\n+    public int getEventType() {\n+        return eventType;\n+    }\n+}"},{"sha":"183e7ebf4084b11e2a3b6588a4bbe9abcccdeb35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"35f129c5d49ba00ddd51f06f3bfb309fe75488a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a0525a0537b3f5e769415a113612e75d39d3d540","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7af19bb90d32c6ac853a103a4fb374285a9a3383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"3168a6b6aa71e54c4b4400dfbb1b1a75c2efe179","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b796f26cf675ee1a52718f0b65dcd5c1c88ffb5c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"079d80239f3b1dc8179ae77eaff57ce13703d992","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":948,"deletions":948,"changes":1896,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b8062348dc244aba3751546c022e54e4afe13b42","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"modified","additions":129,"deletions":129,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a9f24b061c04bc6b2fa11379e73d520eb16548ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8672e4d80a55f13f0d1bb98f03cdf2a0fa693ced","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":827,"deletions":827,"changes":1654,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"273fdbb3298a45d3e7612364838389310edde60c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":190,"deletions":190,"changes":380,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"58d70bcbb978e90f1d65cddc419f893c33202788","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":4755,"deletions":4755,"changes":9510,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"24f2a95960eafd07e42bb11c8a0a9ce48a2c6522","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":949,"deletions":949,"changes":1898,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5d300f96c55f2b1f87e9a919b79fb540cd93ea56","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":353,"deletions":353,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a6527f7c91c76763b1754e69e965e0a9fbd73503","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","status":"modified","additions":309,"deletions":309,"changes":618,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5f7faa86a0ee8bbfab330f78f33d3acb377051aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":2162,"deletions":2162,"changes":4324,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ccd1c21743b71fa5744d9095f2b21792dd51aa3f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":325,"deletions":325,"changes":650,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"22cc0c736135c53610c163baa098d22a3d6ce901","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":388,"deletions":388,"changes":776,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2ac03497fe2144db0bdb0b31425dd872e5d14db6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"modified","additions":149,"deletions":149,"changes":298,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b5aa972b4fb87ff1a09254f3aa2ec68300d48be2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"55a597610226c591557dba9cd68d6f1f66a83dd2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d885a5d1e74a40c5343c45de7c10b25db0415683","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":642,"deletions":642,"changes":1284,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"16168945faa8b8f594bb874de7ee8cccf0e09631","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a305b59d6e26332ad8faae53fe971f874880d0c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":326,"deletions":326,"changes":652,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5f2991981cc80e5c9959c4fe9d4d2362ff69ce89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"3f9e0713b9c1430ccf348f299d7c0b9ade40c850","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":1662,"deletions":1662,"changes":3324,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2cd29655ee8bb3f2c404ce82835ceecf12123688","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f60c8ca8fc296ca72a8d49f3f5de3106e4524987","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ce0958229f1aec56780e61974d3e32f908c1d0dd","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"modified","additions":93,"deletions":93,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2237cde18e6ccb4fdf2a66b61154985473d41b92","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"eb8f78a3b557ae31d3954fda5bf242b6a71615c0","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"94b98bf8e5253d78219852b530e1777a6be16662","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c61b2bcc5a3eb5ba46f1c6f8f44825977b778595","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"modified","additions":721,"deletions":721,"changes":1442,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"55d9a2699e2fa0068e1554cb011b46595a15a602","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"modified","additions":138,"deletions":138,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e40e160910ef01d40326a0b10f353465a76c7eb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"modified","additions":145,"deletions":145,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f1f5001cf0da8c0c7d9a01cd62bb96df94a7f054","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":358,"deletions":358,"changes":716,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"aa57109b62f5fcfde616c78983d9928b955271b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":222,"deletions":222,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"77f9d74ead100310ffe8136d3f3039c8b5b5d95f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b9c67ff6daef47f8283e81ae68d4682c458c69ca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9ece659a36b83abf2776a321fac1b2178f77d51d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"66fdd78027af10c57c3ebfe7cc7b29bb36ab8aee","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6f3b4e03facbf8a58630a4147c9e9ea6792e37dd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"modified","additions":773,"deletions":773,"changes":1546,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b9714b1281cd241dee2d21bf4cc166e318db0b91","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"modified","additions":295,"deletions":295,"changes":590,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7b178d91fa04cd32f64af1de3f3123247719d3b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"24c258087591b23bd6cbe13f6daa48e01689aecf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"modified","additions":368,"deletions":368,"changes":736,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7c05693c780b214a0efb09f474eed944ca92ffde","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"modified","additions":193,"deletions":193,"changes":386,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9eebc566c3e3ad02e0a90637e22163f10eda369b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"modified","additions":167,"deletions":167,"changes":334,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"82a3edcf6f3963bc8dd2b1f6e8ba431593b76e2c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f5a04ea7fa0ad931de33dcf88f530285aa2e3de1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"modified","additions":302,"deletions":302,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"96dfd32f5775291b461256dda8a6e040de456d1f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","status":"modified","additions":61,"deletions":61,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e5dadba9ad3c167c40956e52b231945d82e484c5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"modified","additions":416,"deletions":416,"changes":832,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c001a4cf0bafd1740024602aeaed921d999ab751","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"modified","additions":128,"deletions":128,"changes":256,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"fcea58dd616124f857324a3784039d3b59f9c6fd","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e06648dc6642844a5e502df682eb7213b41f2abc","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1df285153bb30953b5a7799b6be28fdd79b236bb","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":152,"deletions":152,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"3b21530ffeb82b4c131a042d4b88c688da26bc08","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"49a389f0b97f54634eba55fb5023a18f5c47f72e","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":1115,"deletions":1115,"changes":2230,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"bfb6538f3d8c2517b0663ab7572f2292ed3a82f8","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","status":"modified","additions":100,"deletions":100,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6110d8e41c3e69050541117f7e8875b1b8f9e1f1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":400,"deletions":400,"changes":800,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a39620107e864578a1cdb44e391b902778e5b1ea","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","status":"modified","additions":179,"deletions":179,"changes":358,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"4f40d52d1443f582cb5c186222e6ed57043d6b7b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"af682fbeb733a71a207594b5c765f63e166fb6aa","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a4c2062c0ff1f2734d41024a68dbf13f4917573c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9dfb75c97d39d3efca09d6aabfafa01606f364f4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8dbf2233247539a53bb698a4e4c04a3bc4c8cf97","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7046272f7a74cb0d4d7054b74a2b1ea2b6c38bcf","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0505c5967fa011c6d963b839ce259a85f9b20701","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"89472aa62ec0d9881eb6f9469e2717a6712659b4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"dfc13a52f052a659d6289067f42942f6b925b775","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"20d1709f275fa3c76b490b6f1bd7b31d3ee473d3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"391b0af45d9c0adb90f687e5a35c3d77bf15d4c5","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8ff0946554d1aaa52033097b0c7fd065e07f1a48","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"05d6fcde0394e991850aff86957ca97dd8d36298","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"629247b9aff77c6224707c89958ef5b7ab2dc737","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b7401d43e8f01190208c14e49f73ad378b1ab03d","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b083800e50d1903e8c2ac64fe98e56479854375c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a439e55c32c88ec5e0ac75a86cfa38a1c8635f20","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8a3b4a0e0caa1614854772304bf8ffa8db74db91","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","status":"modified","additions":198,"deletions":198,"changes":396,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7e315428ec7a1d6f34010a48ba1b3d2a5e355435","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","status":"modified","additions":70,"deletions":70,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e8739b1b8e556e93bfecb92913c0ca43e87005b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","status":"modified","additions":171,"deletions":171,"changes":342,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c05392f3a85917081c6ba8459a308d961c23ed81","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","status":"modified","additions":136,"deletions":136,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0b446c0836128120930005157c584cb26f5a2cea","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":609,"deletions":609,"changes":1218,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c3ab5d217aed21ba58efb48c0555c60f8e5d360b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"4348b23b976d9c8a7f360eb57a57167c8add4f8c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"15392bfde1faefb596162be1ed6198ac641438f0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"44077384fc3daa7e93cb4052d0648cdaf87e143e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1dd81d1539c1dfc524583f48b273a3eb6b414ca6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ed60af83394108bd9f2ea9d2d5d700d6c624ee92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"36f3949ec4b1728119b9caaee47252435180e149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"866bbc5bee6c06761bd90ff06e72babfc23f3f20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1e69bf9170405d7cfe5dcc6cf5bcfdbaf565cc25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"01b3294f53a3e05549e31cc2eb14f66c63943caf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"116ed5014cb1b3849dc1f84fdbd01b7ae567a5be","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","status":"modified","additions":118,"deletions":118,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"638018e5ac44a2effc583b577274faedc43e25dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"130d78820ee6cea5e401485d1fcbca1aaef28393","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"287c5e321aa492fe4a9f63e1bf3a9c6c8f107ac9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"33298a5cf356431f08bd4f939007db1f2b045389","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f79a4c9b6e48486661631c90007b1a794cd5cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0b101412e10ad756e28c4daf13e566277a434856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","status":"modified","additions":88,"deletions":88,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"03e33912f6de6f6a27ba78fc31a9cd86f2c2b3ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"modified","additions":122,"deletions":122,"changes":244,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"acfbaa2c3928a3f7646aa6f60d22acb2b42c6c51","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"31c009a84689d904afc140ea1f9bb69bf7af8cda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d8780d021fbbfe217ff4712a3530da767e9728c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ac928a6c7adaf9207f13a4dd18d4cb216a4cdd8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1044e0f3c99938d343149dab394caa6080d1362c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f034ac9ecdc41b73c7312dcfa41c669634e46c03","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","status":"modified","additions":69,"deletions":69,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a8bdbcef7fd78109dd7f15c26da2f4cf48158960","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"027e973a88f738aa871562a7517d5013ede409f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","status":"modified","additions":25,"deletions":25,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"22efc08eed127653ccf7d9f0babf4c140e24a931","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"modified","additions":96,"deletions":96,"changes":192,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"de4cfa30a848eba647d418771a08575506bceac7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"79331c7248bf9c206d7d10f68299054c65a06776","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ef19b8f1ef93b8b12e96c6edee65fcab5c2e1789","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5bca64e0d83fac455829c82d17728c7d79f9c039","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b44ff2fedb2a7d4cdc7312509682e7c788748b82","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","status":"modified","additions":32,"deletions":32,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"26f684183541e3b1f98b051f0cd1e291892b2dd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d9172f21616f9858b8c256dda7bb474ab54be5ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"77ed7187289d221aa425477eb377e373002a997d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0c9f8697b41b87115e18f0e3e912811f2669d46d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"36e7328d2d8d100873b8a268e01b1168bf1c1cbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7239aace49a18303b4adaa5bcdb79aff82f39258","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":90,"deletions":90,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7888c89ed91b0bb5857359327b12f619e234650d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"38750bf59d402bb7b830ccffc97511e9a7a1e78c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2b24115d765f95ed1c43b45171ec1c5e79c1e9a3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":211,"deletions":211,"changes":422,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"01cab7f45ec4f508f2aa511549a4ad5b0b26f4a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","status":"modified","additions":286,"deletions":286,"changes":572,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a546d39478b7fec6d7840911c2e0038552098709","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"486f23f1430b174438c8f6afcd7e0f725191a5cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8cd9dd9a549307a45f53d6cad198bff68f331913","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"57e983837a2e9da0892947a0459e9e55cd992c4f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"769b5418b3946911ee424325e091a602cf21da5e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"61a9ee6ca4a50ecd7592c85a03ca4cff68d66559","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e77c4bfacffaaae558a995290ebf0734f8ca3b1d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ff3e7a71f7673566c53d9c4ed0b70c6326c91600","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","status":"modified","additions":445,"deletions":445,"changes":890,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e5b9204e62c902c39a0262b7fd1f86e4d74f2d81","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f240d27db0a753ecef0458f3dd56a0579fddf673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"63dc8813a393366d422650aab0ce1188a5af5fd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6fa77b9f1eaa2f5563602aeb4c3d8c6f19cab349","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f71250591c2878f6b02a10c47155f4bcf503f88d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"562ed6a8a38448f1230b85c05ee02c8c9961e04d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8a17714ecedc2542781768ec80ea8fcb76bd23d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0ecf316290b6c9e9dd08f83d16dc5e133896bd48","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"511e32b10d9dde2438dac41c21731553ceabf936","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"710445075eba806c59d80a88d537e917f43fc7b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"4499cfa0ed296ecd65d3163d531af191d2375f25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"61f740e34c5140094d448a0df8e487a8441174bb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","status":"modified","additions":155,"deletions":155,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f6b9a378d1cd0db051afa7bfa5e9567ec445d715","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6c680f396d953f78380404fb7c53026040fed2a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ff573eff5db794e1a128e4f7209978da5c23005b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8beb7ab736ea24ff0f777abb321cb8a5b19792d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"08c5920215ae8121adaee83d21602274327d6cdc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e1c413cf1ca7a42ed395e7f747ca2f6b13e87cca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","status":"modified","additions":110,"deletions":110,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6326fb12e05103be11935ee00ac1efd00382db6d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"fe7f17ea3e95b774098448eef593afe8be488e96","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","status":"modified","additions":78,"deletions":78,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"29ef0d070c99d97ac2707708937f8ecd1bc52111","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b78fe8d34b60149ceba969d635985fd299593a58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9f39748f856f82b36ec6152fee95f089bb8ed8bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f757ff86a6e1f86f55aa3f6b7173a5059bcb8955","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","status":"modified","additions":133,"deletions":133,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"024f593908da3157525e49ff538b6aa685d020ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","status":"modified","additions":59,"deletions":59,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"41acca647d76dc7bee81b89539bccd93052de9f3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","status":"modified","additions":265,"deletions":265,"changes":530,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"98b6176f22261466a72ecd7c26e0638e661e34bd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","status":"modified","additions":140,"deletions":140,"changes":280,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a373c898c81d2ffbf7bc9b77b72bcca5136ae7af","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","status":"modified","additions":140,"deletions":140,"changes":280,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2f2fd083403c7a6b9e97c2368b6efef062f471e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","status":"modified","additions":264,"deletions":264,"changes":528,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6ee4ae17455a1a8637077e453cd5f638978134ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","status":"modified","additions":265,"deletions":265,"changes":530,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b22458cc6143b5204db1219c6c2e3de0062580d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","status":"modified","additions":116,"deletions":116,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0ca620f486359f9370ec7fcf20d94025b51f96bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d8c70b9af7747f39e499c94610b3e0cd52063578","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","status":"modified","additions":70,"deletions":70,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"300e6fbad2264f5e474d8ed30c4aa4cebfb18491","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0462985119eb9c1b8feb88affb9edb539ee50d44","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5bad087a25cd38528f6f1e7d2f2124ad01449f2a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","status":"modified","additions":123,"deletions":123,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"4f551bfcf01f18d30639d0fae4296b76b8e0c011","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","status":"modified","additions":131,"deletions":131,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"13174c1ef0989368bf1cc9918294b0dad57745a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","status":"modified","additions":113,"deletions":113,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"834cca869264f4a3127f2dad70b20a4f4ce58de4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","status":"modified","additions":146,"deletions":146,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e061cdca25f310a0cf013bb33a69138b7eedcefe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","status":"modified","additions":121,"deletions":121,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c754b40f20c44e28415b5663f4cb42c1320083fc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","status":"modified","additions":146,"deletions":146,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5a680fa5af905185838b58fc88c38e47d613bbfe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","status":"modified","additions":108,"deletions":108,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"56ed85ff73428d677ff85387afa97db2bbe2b5e7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","status":"modified","additions":240,"deletions":240,"changes":480,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9cbecb9786c2fa711b3bcf838296389c1bb6bf75","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","status":"modified","additions":311,"deletions":311,"changes":622,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8ef6311a2dee019b77e31557b0f3135c63af960a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","status":"modified","additions":165,"deletions":165,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8c398b4e04aa979f6c0d947d8fb5f338c0db4282","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a81e004d425a4afef344dd691bbb2b339d386cff","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"14ed9500140971013af596eee67f2cb192d8a8e9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7026713b1ada04fd7bacbf9f12834f351aa2fcbb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"24bc9e9bbd011a778544ba0e9d914f9ba9115139","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","status":"modified","additions":83,"deletions":83,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0e46ead850839e783ef043cd417d189b1aced8d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ded0639941433ef2fde6adea577426554e8f74a6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5f408b2884f472aacdd84e60ed5ac1f42bf789d0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0093c448b09e36cce2cc21f04415c64a8c3ce2c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7109223ca16d0a06d9c646a55765d6289b202a43","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7ab7564dda1798643a6caa9c2fb04bbafa5c0bd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a182ea322e2784a4be8db1a0ea83827f64ae1845","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"3d896513025b897a1f3b94b3baf8d8d45bd64f2f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7a6fd4547e1020717c9ebbe07f63f03c5754522d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b2a3406c2e2bee92f039d3a4944cd07dabfa5534","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b4f1373c24538ff1768639aa3b6eec37ca22b3f4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5370d5a3d215a85ed924ac49f2da6e17584980c7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","status":"modified","additions":45,"deletions":45,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"9fe8e3a6e5e32c04af5afa5201ae04313289d7db","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"74d4c7d38fdcca6c215748404dbbb6b1ff24df6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b8e3013656cf8ed84a06e193f343ec626cc223f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6dcc1844cf8705ac2c6937c5636329b4afe09168","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6cc2c14503f468a8c149564890f83c7877de9b83","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","status":"modified","additions":26,"deletions":26,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d09cb344752a4d9eb2db9851d702f2d38c367d1b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","status":"modified","additions":84,"deletions":84,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"dcd4e03497cd90a963ab7a07d7ad363b016e8943","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e8c9768e8505b2f46857da9cf44a6c29d6fef3ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","status":"modified","additions":101,"deletions":101,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"390ea719213f48751f84b6ba4e17e27b4dacd4fb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c2d468f3a15ebca093b9ba46fcc0c15d431a7db7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e9ff8e0ecdd7c0cca36ec7e4591683119d1eec72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0f0c554e640bdeceabe09ac2a9a169e1754a83d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c2b3ea52e0ea94db2797192d51fb6d293a679188","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","status":"modified","additions":67,"deletions":67,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"91f840332afa5053d99e63ec73a53dad26f26eb5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7e911402fd6bf2711def106b7e2f09be835ae18a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","status":"modified","additions":40,"deletions":40,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"abacdb1a3612986a17a2dd3f576b3afea328a414","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","status":"modified","additions":85,"deletions":85,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c28a2ed9d17b58638dee6d303b4890c5ef289bf0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","status":"modified","additions":106,"deletions":106,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c59ca3618bc35f36901c9fd968aa85f427f1df20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f9f8e156e5f1c747699d7651011c844d5837367c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"b165dbb1750d40e24921c2ff31c91b138eacd8e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"55e81e5d5e341a998f7c6796345ee77fe587f149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","status":"modified","additions":36,"deletions":36,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/EntityDDListener2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8d1a74af0b13cdb9eb761b0317eaf63e939e9687","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/FlightSchedule.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7127e1e08f2fcf75b1f65a9cb232b6d5beed43ed","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","status":"modified","additions":23,"deletions":23,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDD.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5263cceae28f4d74d3843f0364842b6ed4a1435f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","status":"modified","additions":89,"deletions":89,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"d3f9c840a8960ae21a926e65277a509f248f04ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","status":"modified","additions":105,"deletions":105,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntity2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5738e3e6e8023c77318b2f4a4c06b99298fb0581","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LifeCycleDDEntitySub.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c3fcefcbea1ebfc7620e7339a639436e01bc63c1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/LongNameValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"5d8185294ef4cf5ea739c0bb4fa41c27fcd4d556","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NameValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2cc2b47657e17fb19ec8144b5298d523305049e4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","status":"modified","additions":26,"deletions":26,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/NamedEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"f5ffbce1bb65688cbbbb127c0a3f0d92775ad972","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","status":"modified","additions":102,"deletions":102,"changes":204,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Schedule.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"894ce58c92605cbd72190e5c62f76321e66ff0df","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/StringValidator.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7f5af1ad9143762663e609549c78a0b038f2d94d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/TxRollbackEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1636b5f94097537c4c36b926e5d9e4afcc7a6302","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/TestQueryCache.java","status":"modified","additions":183,"deletions":183,"changes":366,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/TestQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/TestQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/TestQueryCache.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"1ab7d99a3b78db6799f105c60615b2a12b9be4e0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","status":"modified","additions":89,"deletions":89,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwned.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"caf7ff8787327210e41cd3aa584ebae8bcfb6971","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/BidirectionalOne2OneOwner.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"379003f88e5515e1bbeb0da1c9ac55dda7a8ef24","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity1.java","status":"modified","additions":99,"deletions":99,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"db3e279b1eeb380f14132dcfcbd285045c1b06d3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity2.java","status":"modified","additions":82,"deletions":82,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/Entity2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"520657eb5e593e11db75a16c660653e34f0e66d0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","status":"modified","additions":77,"deletions":77,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwned.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"558d85a86660487a0ed88bd022a2030fd8ab9988","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/common/apps/UnidirectionalOne2OneOwner.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"05ed3493fdc58c53daa645febc953b936b41d33c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"2b13764fba949b3424a444de42a01302ff964f61","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"39ef5ea8a20dc9cb3f99473fa076cb127f478357","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"7d009a87d32d1172de6c9ff85930bc296bc81b12","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"621180768fcf366cdd8521186941159331987896","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","status":"modified","additions":114,"deletions":114,"changes":228,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0b09aa1aa8b628fa59c818f02da6fd6936e1ae8d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Address.java","status":"modified","additions":94,"deletions":94,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Address.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Address.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Address.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c3405f1dd639f8d394cb8f7b1bd45a4219055ded","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ArtCourse.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ArtCourse.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ArtCourse.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ArtCourse.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"8ab45f11b88bed25e9d725259bce628307129454","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","status":"modified","additions":98,"deletions":98,"changes":196,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"74a6f9b9a0f4addfd88519310917dd0d4478f66f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ComplexEmbeddedPC.java","status":"modified","additions":77,"deletions":77,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ComplexEmbeddedPC.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ComplexEmbeddedPC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ComplexEmbeddedPC.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"0d73f98ed824fb9cc664982c665ef38e5c31b4ec","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Course.java","status":"modified","additions":82,"deletions":82,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Course.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Course.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Course.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"eba988c794a2265e5351af322a5a75fc30c21a79","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Department.java","status":"modified","additions":70,"deletions":70,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Department.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Department.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Department.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"75d01759ee8e14ae64d6abfad4bfa824fc94e7a1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedOwnerPC.java","status":"modified","additions":158,"deletions":158,"changes":316,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedOwnerPC.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedOwnerPC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedOwnerPC.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"404ce1d0ca546f63ad73a146940d6b23390c43dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedPC.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedPC.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedPC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/EmbeddedPC.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"04f6da6d2f33fbc0763e6e16c40597cb0beab9a0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity1.java","status":"modified","additions":117,"deletions":117,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a535cc75a647a8b7fceb2eec6400fce847f16135","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity2.java","status":"modified","additions":99,"deletions":99,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Entity2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"e0077a43959e355c0126d17287ac122eebcb009d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/FemaleUser.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/FemaleUser.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/FemaleUser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/FemaleUser.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"463ff2617ae49f3a278c44f8a9a3d13cda777983","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/MaleUser.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/MaleUser.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/MaleUser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/MaleUser.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"a74e3b45a459293047343ea9e53bc13dd3750aa9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest1.java","status":"modified","additions":143,"deletions":143,"changes":286,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest1.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest1.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"ffda367060053f3f25ae1d5629b21f3d5aeb5c11","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest2.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest2.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/RuntimeTest2.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"c968e1ab045c983896091499387b7e933166091f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ScienceCourse.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ScienceCourse.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ScienceCourse.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/ScienceCourse.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"bfe3b9d614da2a79ff264aef42fe58c14cdcd26e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Student.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Student.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Student.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/Student.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"fe473bc064cb10847de0c81bfa6de9fa6f451068","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","status":"modified","additions":1216,"deletions":1216,"changes":2432,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"11be3beeae39e4a1de9f7172f27cf124d7154e74","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/BufferedLogFactory.java","status":"modified","additions":101,"deletions":101,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/BufferedLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/BufferedLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/BufferedLogFactory.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"99a58814f0e2755b512d9e4f4ef3fe8795603a38","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/Bug.java","status":"modified","additions":80,"deletions":80,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/Bug.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/Bug.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/Bug.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"44f95ff18284ce96d02f539629e07aa38dd401e5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/conf/TestKodoConfiguration.java","status":"modified","additions":230,"deletions":230,"changes":460,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/conf/TestKodoConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/conf/TestKodoConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/conf/TestKodoConfiguration.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"6f438b1c3b829701daaa24ee1eefe41f72d50832","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheLoadTest.java","status":"modified","additions":178,"deletions":178,"changes":356,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheLoadTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheLoadTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheLoadTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"fa09b23c94bf2464987d8d4b1c25111ea72b3c4d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTest.java","status":"modified","additions":1591,"deletions":1591,"changes":3182,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTest.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTest.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"55c0117a89a21adaec11749bf7eba5fa24c8938a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestBroker.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestBroker.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestBroker.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"},{"sha":"767ecb20846f00a800c7911bb2f0d5b66e2a6bd3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestHelper.java","status":"modified","additions":118,"deletions":118,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestHelper.java","raw_url":"https://github.com/apache/openjpa/raw/115af5954d8ba917d83b7dceb181b01257c359ab/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/CacheTestHelper.java?ref=115af5954d8ba917d83b7dceb181b01257c359ab"}]}

