{"sha":"12839b6bd9090eb84d1944584c9ea73aaa8b44fa","node_id":"MDY6Q29tbWl0MjA2MzY0OjEyODM5YjZiZDkwOTBlYjg0ZDE5NDQ1ODRjOWVhNzNhYWE4YjQ0ZmE=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-02-06T20:26:14Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-02-06T20:26:14Z"},"message":"Adding new (source code + pom.xml + doc) for Slice \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@619145 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9007c46d3f7b0f26c42d4620daffe9a29d0940da","url":"https://api.github.com/repos/apache/openjpa/git/trees/9007c46d3f7b0f26c42d4620daffe9a29d0940da"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/12839b6bd9090eb84d1944584c9ea73aaa8b44fa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/12839b6bd9090eb84d1944584c9ea73aaa8b44fa","html_url":"https://github.com/apache/openjpa/commit/12839b6bd9090eb84d1944584c9ea73aaa8b44fa","comments_url":"https://api.github.com/repos/apache/openjpa/commits/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/comments","author":null,"committer":null,"parents":[{"sha":"2a3ee08d92302b82349f1e9e3d7964d01d7f9a04","url":"https://api.github.com/repos/apache/openjpa/commits/2a3ee08d92302b82349f1e9e3d7964d01d7f9a04","html_url":"https://github.com/apache/openjpa/commit/2a3ee08d92302b82349f1e9e3d7964d01d7f9a04"}],"stats":{"total":5391,"additions":5387,"deletions":4},"files":[{"sha":"56f345e367bcdc51d9e0283635ba2f5121c74dd2","filename":"openjpa-project/src/doc/manual/manual.xml","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-project/src/doc/manual/manual.xml","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-project/src/doc/manual/manual.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/manual.xml?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -46,7 +46,8 @@\n     <!ENTITY ref_guide_deploy.xml SYSTEM \"ref_guide_deploy.xml\">\n     <!ENTITY ref_guide_runtime.xml SYSTEM \"ref_guide_runtime.xml\">\n     <!ENTITY ref_guide_caching.xml SYSTEM \"ref_guide_caching.xml\">\n-    <!ENTITY ref_guide_remote.xml SYSTEM \"ref_guide_remote.xml\">\n+    <!ENTITY ref_guide_remote.xml SYSTEM \"ref_guide_remote.xml\">\r\n+    <!ENTITY ref_guide_slice.xml SYSTEM \"ref_guide_slice.xml\">\n     <!ENTITY ref_guide_integration.xml SYSTEM \"ref_guide_integration.xml\">\n     <!ENTITY ref_guide_optimization.xml SYSTEM \"ref_guide_optimization.xml\">\n     <!ENTITY samples_guide.xml SYSTEM \"samples_guide.xml\">\n@@ -100,7 +101,8 @@\n         &ref_guide_deploy.xml;\n         &ref_guide_runtime.xml;\n         &ref_guide_caching.xml;\n-        &ref_guide_remote.xml;\n+        &ref_guide_remote.xml;\r\n+        &ref_guide_slice.xml;\n         &ref_guide_integration.xml;\n         &ref_guide_optimization.xml;\n     </part>"},{"sha":"5b13a7481d989216222ff59b0e0f83dd4ebeed24","filename":"openjpa-project/src/doc/manual/ref_guide_slice.xml","status":"added","additions":498,"deletions":0,"changes":498,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-project/src/doc/manual/ref_guide_slice.xml","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-project/src/doc/manual/ref_guide_slice.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_slice.xml?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,498 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n+<!--\r\n+ Licensed to the Apache Software Foundation (ASF) under one\r\n+ or more contributor license agreements.  See the NOTICE file\r\n+ distributed with this work for additional information\r\n+ regarding copyright ownership.  The ASF licenses this file\r\n+ to you under the Apache License, Version 2.0 (the\r\n+ \"License\"); you may not use this file except in compliance\r\n+ with the License.  You may obtain a copy of the License at\r\n+ \r\n+ http://www.apache.org/licenses/LICENSE-2.0\r\n+ \r\n+ Unless required by applicable law or agreed to in writing,\r\n+ software distributed under the License is distributed on an\r\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ KIND, either express or implied.  See the License for the\r\n+ specific language governing permissions and limitations\r\n+ under the License.   \r\n+-->\r\n+<chapter id=\"ref_guide_slice\">\r\n+  <title>\r\n+    Distributed Persistence\r\n+  </title>\r\n+  <para>\r\n+  The standard JPA runtime environment works with a <emphasis>single</emphasis>\r\n+  database instance. OpenJPA can be extended via plug-in to work with \r\n+  multiple databases within the same transaction without any change to the \r\n+  existing application. This capability of OpenJPA for distributed \r\n+  database environment is called <emphasis>Slice</emphasis> and is explained in \r\n+  the following sections.\r\n+  </para>\r\n+  \r\n+  <section id=\"slice_overview\">\r\n+    <title>Overview</title>\r\n+    <para>\r\n+    Enterprise applications are increasingly deployed for distributed database\r\n+    environments. The reasons for distributed, often horizontally-partitioned \r\n+    database environment can be to counter massive data growth, to \r\n+    support multiple external clients on a hosted platform or many other \r\n+    practical scenarios that can benefit from data partitioning.\r\n+    </para>\r\n+    \r\n+    <para>\r\n+    Any JPA-based user application has to address serious technical and conceptual\r\n+    challenges to directly interact with a set of physical databases\r\n+    within a single transaction. \r\n+    Slice encapsulates the complexity of distributed database environment \r\n+    via the abstraction of <emphasis>virtual</emphasis> database which internally \r\n+    manages multiple physical databases. We refer each physical database instance \r\n+    as <emphasis>slice</emphasis>. \r\n+    <emphasis>Virtualization</emphasis> of distributed databases \r\n+    makes OpenJPA object management kernel and \r\n+    the user application to work in the same way as in the case of a single physical \r\n+    database.\r\n+    </para>\r\n+  </section>\r\n+  \r\n+    <section id=\"Features and Limitations\">\r\n+       <title>Salient Features</title>\r\n+         <section><title>Transparency</title>\r\n+            <para>\r\n+              The existing application or the persistent domain featureSelection requires \r\n+              <emphasis>no change</emphasis> to upgrade from a single database \r\n+              to a distributed database environment. \r\n+            </para>\r\n+         </section>\r\n+         \r\n+         <section><title>Custom Distribution Policy</title>\r\n+            <para>\r\n+             User application decides how the newly persistent instances be \r\n+             distributed across the database slices. The data\r\n+             distribution policy across the slices may be based on the attribute \r\n+             of the data itself. For example, all Customer whose first name begins with\r\n+             character 'A' to 'M' will be stored in one slice while names\r\n+             beginning with 'N' to 'Z' will be stored in another slice. \r\n+             <para>\r\n+             This custom data distribution policy is specified by implementing  \r\n+             <classname>org.apache.openjpa.slice.DistributionPolicy</classname>\r\n+             interface by the user application.\r\n+             </para>\r\n+          \r\n+             <para> \r\n+             Slice tracks the original database for existing instances. When\r\n+             an application issues a query, the resultant instances can be loaded \r\n+             from different slices. This tracking is important as subsequent\r\n+             update to any of these instances is committed to the appropriate \r\n+             original database slice. \r\n+            </para>\r\n+            <para>\r\n+            <warning>Currently, there is no provision for migrating an \r\n+            existing instance from one slice to another.\r\n+            </warning>\r\n+            </para>\r\n+         </section>\r\n+         \r\n+         <section><title>Heterogeneous Database</title>\r\n+            <para> \r\n+              Each slice can be configured independently with its own JDBC \r\n+              driver and other connection parameters. Hence the target database \r\n+              environment can constitute of heterogeneous databases. \r\n+            </para>\r\n+        </section>\r\n+        \r\n+        <section><title>Parallel Execution</title>\r\n+            <para> \r\n+              All database operations such as query, commit or flush operates\r\n+              in parallel across the database slices. The execution threading\r\n+              policy is configurable. \r\n+            </para>\r\n+         </section>\r\n+         \r\n+         <section><title>Distributed Query</title>\r\n+            <para>\r\n+            The queries are executed across all slices and the results are\r\n+            merged into a single list. The query result that includes \r\n+            <code>ORDER BY</code> clause are sorted correctly by merging \r\n+            results from each individual slice. \r\n+            </para>\r\n+            The queries that specify an aggregate projection such as \r\n+            <code>COUNT()</code>, <code>MAX()</code>, <code>MIN()</code> \r\n+            and <code>SUM()</code>\r\n+            are correctly evaluated <emphasis>only if</emphasis> they \r\n+            return a single result.\r\n+            <para>\r\n+            </para>\r\n+            <para>\r\n+            <warning>\r\n+            The aggregate operation <code>AVG()</code> is not supported.\r\n+            </warning>\r\n+            </para>\r\n+         </section>\r\n+         \r\n+         <section><title>Distributed Transaction</title>\r\n+            <para> \r\n+            The database slices participate in a global transaction provided\r\n+            each slice is configured with a XA-complaint JDBC driver, even\r\n+            when the persistence unit is configured for <code>RESOURCE_LOCAL</code>\r\n+            transaction.\r\n+            </para>\r\n+            <para>\r\n+            <warning>\r\n+            If any of the configured slices is not XA-complaint <emphasis>and</emphasis> \r\n+            the persistence unit is configured for <code>RESOURCE_LOCAL</code>\r\n+            transaction then each slice is committed without any two-phase\r\n+            commit protocol. If commit on any slice fails, then atomic nature of\r\n+            the transaction is not ensured.\r\n+            </warning>\r\n+            </para>\r\n+          </section>\r\n+   \r\n+    \r\n+    \r\n+        \r\n+         <section id=\"collocation_constraint\"><title>Collocation Constraint</title>\r\n+            <para> \r\n+            No relationship can exist across database slices. In O-R mapping parlance,\r\n+            this condition translates to the limitation that the closure of an object graph must be \r\n+            <emphasis>collocated</emphasis> in the same database.\r\n+            For example, consider a domain featureSelection where Person relates to Adress.\r\n+            Person X refers to Address A while Person Y refers to Address B. \r\n+            Collocation Constraint means that <emphasis>both</emphasis> X and A \r\n+            must be stored in the same\r\n+            database slice. Similarly Y and B must be stored in a single slice.\r\n+            </para>\r\n+            <para>\r\n+            Slice, however, helps to maintain collocation constraint automatically.\r\n+            The instances in the closure set of any newly persistent instance \r\n+            reachable via cascaded relationship is stored in the same slice.\r\n+            The user-defined distribution policy requires to supply the slice \r\n+            for the root instance only.\r\n+            </para>\r\n+         </section>\r\n+    </section>\r\n+  \r\n+  <section id=\"slice_configuration\">\r\n+    <title>Usage</title>\r\n+    <para>\r\n+     Slice is activated via the following property settings:\r\n+    </para>\r\n+    <section>\r\n+      <title>How to activate Slice Runtime?</title>\r\n+      <para>\r\n+       The basic configuration property is \r\n+       <programlisting> \r\n+        <![CDATA[ <property name=\"openjpa.BrokerFactory\" value=\"slice\"/>]]>\r\n+       </programlisting> \r\n+       This critical configuration activates a specialized factory class aliased\r\n+       as <code>slice</code> to create object management kernel that\r\n+       can work against multiple databases.  \r\n+      </para>\r\n+    </section> \r\n+    \r\n+    <section>\r\n+      <title>How to configure each database slice?</title>\r\n+      <para>\r\n+      Each database slice is identified by a logical name unique within a\r\n+      persistent unit. The list of the slices is specified by <code>slice.Names</code> property.\r\n+      For example, specify three slices named <code>\"One\"</code>, \r\n+      <code>\"Two\"</code> and <code>\"Three\"</code> as follows:\r\n+      <programlisting>\r\n+      <![CDATA[ <property name=\"slice.Names\" value=\"One, Two, Three\"/>]]>\r\n+      </programlisting>\r\n+      </para>\r\n+      <para>\r\n+      This property is not mandatory. If this property is not specified then\r\n+      the configuration is scanned for logical slice names. Any property\r\n+      of the form <code>slice.XYZ.abc</code> will register a slice with logical\r\n+      name <code>\"XYZ\"</code>.\r\n+      </para>\r\n+      <para>\r\n+      The order of the names can be significant if no <code>slice.Master</code>\r\n+      property is specified. \r\n+      </para>\r\n+      \r\n+      <para>\r\n+       Each database slice can be configured independently. For example, the\r\n+       following configuration will register two slices with logical name \r\n+       <code>One</code> and <code>Two</code>.\r\n+       <programlisting> \r\n+        <![CDATA[<property name=\"slice.One.ConnectionURL\" value=\"jdbc:mysql:localhost//slice1\"/>\r\n+        <property name=\"slice.Two.ConnectionURL\" value=\"jdbc:mysql:localhost//slice2\"/>]]>\r\n+       </programlisting> \r\n+      </para>\r\n+      \r\n+      <para>\r\n+       Any OpenJPA specific property can be configured per slice basis. \r\n+       For example, the following configuration will use two different JDBC \r\n+       drivers for slice <code>One</code> and <code>Two</code>.\r\n+       <programlisting> \r\n+        <![CDATA[<property name=\"slice.One.ConnectionDriverName\" value=\"com.mysql.jdbc.Driver\"/>\r\n+        <property name=\"slice.Two.ConnectionDriverName\" value=\"com.mysql.jdbc.jdbc2.optional.MysqlXADataSource\"/>]]>\r\n+       </programlisting> \r\n+      </para>\r\n+      \r\n+      <para>\r\n+        Any property if unspecified for a particular slice will be defaulted by\r\n+        corresponding OpenJPA property. For example, consider following three slices\r\n+        <programlisting> \r\n+         <![CDATA[<property name=\"slice.One.ConnectionURL\"          value=\"jdbc:mysql:localhost//slice1\"/>\r\n+         <property name=\"slice.Two.ConnectionURL\"          value=\"jdbc:mysql:localhost//slice2\"/>\r\n+         <property name=\"slice.Three.ConnectionURL\"        value=\"jdbc:oracle:localhost//slice3\"/>\r\n+\r\n+         <property name=\"openjpa.ConnectionDriverName\"     value=\"com.mysql.jdbc.Driver\"/>\r\n+         <property name=\"slice.Three.ConnectionDriverName\" value=\"oracle.jdbc.Driver\"/>]]>\r\n+        </programlisting> \r\n+        In this example, <code>Three</code> will use slice-specific\r\n+        <code>oracle.jdbc.Driver</code> driver while slice\r\n+        <code>One</code> and <code>Two</code> will use\r\n+        the driver <code>com.mysql.jdbc.Driver</code> as \r\n+        specified by <code>openjpa.ConnectionDriverName</code> \r\n+        property value.\r\n+      </para>\r\n+    </section>\r\n+     \r\n+    <section id=\"distribution_policy\">\r\n+       <title>Implement DistributionPolicy interface</title>\r\n+       <para>\r\n+        Slice needs to determine which slice will persist a new instance. \r\n+        The application can only decide this policy (for example, \r\n+        all PurchaseOrders before April 30 goes to slice <code>One</code>,\r\n+        all the rest goes to slice <code>Two</code>). This is why\r\n+        the application has to implement \r\n+        <code>org.apache.openjpa.slice.DistributionPolicy</code> and\r\n+        specify the implementation class in configuration\r\n+        <programlisting> \r\n+         <![CDATA[ <property name=\"slice.DistributionPolicy\" value=\"com.acme.foo.MyOptimialDistributionPolicy\"/>]]>\r\n+        </programlisting>\r\n+       </para>\r\n+       \r\n+       <para>\r\n+        The interface <code>org.apache.openjpa.slice.DistributionPolicy</code>\r\n+        is simple with a single method. The complete listing of the\r\n+        documented interface follows:\r\n+       <programlisting> \r\n+       <![CDATA[ \r\n+public interface DistributionPolicy {\r\n+    /**\r\n+     * Gets the name of the slice where a given instance will be stored.\r\n+     *  \r\n+     * @param pc The newly persistent or to-be-merged object. \r\n+     * @param slices name of the configured slices.\r\n+     * @param context persistence context managing the given instance.\r\n+     * \r\n+     * @return identifier of the slice. This name must match one of the\r\n+     * configured slice names. \r\n+     * @see DistributedConfiguration#getSliceNames()\r\n+     */\r\n+    String distribute(Object pc, List<String> slices, Object context);\r\n+}\r\n+]]>\r\n+       </programlisting>\r\n+        </para>\r\n+        \r\n+        <para>\r\n+        While implementing a distribution policy the most important thing to\r\n+        remember is <link linkend=\"collocation_constraint\">collocation constraint</link>.\r\n+        Because Slice can not establish or query any cross-database relationship, all the\r\n+        related instances must be stored in the same database slice. \r\n+ \r\n+        Slice can determine the closure of a root object by traversal of \r\n+        cascaded relationships. Hence user-defined policy has to only decide the\r\n+        database for the root instance that is the explicit argument to \r\n+        <code>EntityManager.persist()</code> call.\r\n+        Slice will ensure that all other related instances that gets persisted by cascade\r\n+        is assigned to the same database slice as that of the root instance.\r\n+        However, the user-defined distribution policy must return the\r\n+        same slice identifier for the instances that are logically related but\r\n+        not cascaded for persist. \r\n+        </para>\r\n+    </section>\r\n+    \r\n+    <section>\r\n+    </section>\r\n+  </section>\r\n+  \r\n+  <title>Configuration Properties</title>\r\n+    <para>\r\n+    The properties to configure Slice can be classified in two broad groups.\r\n+The <emphasis>global</emphasis> properties apply to all the slices, for example,\r\n+the thread pool used to execute the queries in parallel or the transaction \r\n+manager used to coordinate transaction across multiple slices. \r\n+The <emphasis>per-slice</emphasis> properties apply to individual slice, for example,\r\n+the JDBC connection URL of a slice.\r\n+   </para>\r\n+   \r\n+   <section>\r\n+     <title>Global Properties</title>\r\n+     \r\n+     <section>\r\n+        <title>slice.DistributionPolicy</title>\r\n+        <para>\r\n+         This <emphasis>mandatory</emphasis> plug-in property determines how newly\r\n+         persistent instances are distributed across individual slices. \r\n+         The value of this property is a fully-qualified class name that implements\r\n+         <ulink url=\"../javadoc/org/apache/openjpa/slice/DistributionPolicy.html\">\r\n+         <classname>org.apache.openjpa.slice.DistributionPolicy</classname>\r\n+         </ulink> interface.\r\n+        </para>\r\n+     </section>\r\n+     \r\n+     <section><title>slice.Lenient</title>\r\n+      <para>\r\n+        This boolean plug-in property controls the behavior when one or more slice \r\n+        can not be connected or unavailable for some other reasons.\r\n+        If <code>true</code>, the unreachable slices are ignored. If \r\n+        <code>false</code> then any unreachable slice will raise an exception\r\n+        during startup.\r\n+        </para>\r\n+        <para>\r\n+        By default this value is set to <code>false</code> i.e. all configured\r\n+        slices must be available.\r\n+        </para> \r\n+     </section>\r\n+\r\n+     <section>\r\n+      <title>slice.Master</title>\r\n+      <para>\r\n+       This plug-in property can be used to identify the name of the master slice. \r\n+       Master slice is used when a primary key is to be generated from a database sequence. \r\n+       </para>\r\n+       <para>\r\n+        By default the master slice is the first slice in the list of configured slice names. \r\n+       </para>\r\n+       <para>\r\n+              <warning>\r\n+              Currently, there is no provision to use sequence from \r\n+              multiple database slices.\r\n+              </warning>\r\n+       </para>\r\n+     </section>\r\n+    \r\n+     <section>\r\n+        <title>slice.Names</title>\r\n+        <para>\r\n+         This plug-in property can be used to register the logical slice names.\r\n+         The value of this property is comma-separated list of slice names. \r\n+         The ordering of the names in this list is \r\n+         <emphasis>significant</emphasis> because \r\n+         <link linkend=\"distribution_policy\">DistributionPolicy</link> receives \r\n+         the input argument of the slice names in the same order.\r\n+        </para>\r\n+        <para>\r\n+        If logical slice names are not registered explicitly via this property,\r\n+        then all logical slice names available in the persistence unit are \r\n+        registered. The ordering of the slice names in this case is alphabetical.  \r\n+        </para>\r\n+        <para>\r\n+        If logical slice names are registered explicitly via this property, then\r\n+        any logical slice that is available in the persistence unit but excluded\r\n+        from this list is ignored. \r\n+        </para>\r\n+     </section>\r\n+    \r\n+     <section>\r\n+        <title>slice.ThreadingPolicy</title>\r\n+        <para>\r\n+        This plug-in property determines the nature of thread pool being used \r\n+        for database operations such as query or flush on individual slices. \r\n+        The value of the property is a \r\n+        fully-qualified class name that implements \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ExecutorService.html\">\r\n+        <classname>java.util.concurrent.ExecutorService</classname>\r\n+        </ulink> interface.  \r\n+        Two pre-defined pools can be chosen via their aliases namely \r\n+        <code>fixed</code> or <code>cached</code>.\r\n+        </para>\r\n+        <para>\r\n+        The pre-defined alias <code>cached</code> activates a \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool()\">cached thread pool</ulink>. \r\n+        A cached thread pool creates new threads as needed, but will reuse \r\n+        previously constructed threads when they are available. This pool \r\n+        is suitable in scenarios that execute many short-lived asynchronous tasks.\r\n+        The way Slice uses the thread pool to execute database operations is \r\n+        akin to such scenario and hence <code>cached</code> is the default \r\n+        value for this plug-in property.  \r\n+        </para>\r\n+        <para>\r\n+        The <code>fixed</code> alias activates a \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool(int)\">fixed thread pool</ulink>.\r\n+        The fixed thread pool can be further parameterized with \r\n+        <code>CorePoolSize</code>, <code>MaximumPoolSize</code>, \r\n+        <code>KeepAliveTime</code> and <code>RejectedExecutionHandler</code>. \r\n+        The meaning of these parameters are described in \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.html\">JavaDoc</ulink>.\r\n+        The users can exercise finer control on thread pool behavior via these\r\n+        parameters.\r\n+        By default, the core pool size is <code>10</code>, maximum pool size is\r\n+        also <code>10</code>, keep alive time is <code>60</code> seconds and \r\n+        rejected execution is \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html\">aborted</ulink>.\r\n+        </para>\r\n+        <para>\r\n+        Both of the pre-defined aliases can be parameterized with a fully-qualified\r\n+        class name that implements \r\n+        <ulink url=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadFactory.html\">\r\n+        <classname>java.util.concurrent.ThreadFactory</classname>\r\n+        </ulink> interface.\r\n+        </para>\r\n+     </section>\r\n+      \r\n+     <section>\r\n+      <title>slice.TransactionPolicy</title>\r\n+      <para>\r\n+      This plug-in property determines the policy for transaction commit \r\n+      across multiple slices. The value of this property is a fully-qualified \r\n+      class name that implements \r\n+      <ulink url=\"http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/transaction/TransactionManager.html\">\r\n+      <classname>javax.transaction.TransactionManager</classname> \r\n+      </ulink> interface. \r\n+      </para>\r\n+      <para>\r\n+      Three pre-defined policies can be chosen\r\n+      by their aliases namely <code>default</code>,\r\n+      <code>xa</code> and <code>jndi</code>. \r\n+      </para>\r\n+      <para>\r\n+      The <code>default</code> policy employs \r\n+      a Transaction Manager that commits or rolls back transaction on individual\r\n+      slices <emphasis>without</emphasis> a two-phase commit protocol. \r\n+      It does <emphasis>not</emphasis>\r\n+      guarantee atomic nature of transaction across all the slices because if\r\n+      one or more slice fails to commit, there is no way to rollback the transaction\r\n+      on other slices that committed successfully.\r\n+      </para>\r\n+      <para>\r\n+      The <code>xa</code> policy employs a Transaction Manager that that commits \r\n+      or rolls back transaction on individual\r\n+      slices using a two-phase commit protocol. The prerequisite to use this scheme\r\n+      is, of course, that all the slices must be configured to use\r\n+      XA-complaint JDBC driver. \r\n+      </para>\r\n+      <para>\r\n+      The <code>jndi</code> policy employs a Transaction Manager by looking up the\r\n+      JNDI context. The prerequisite to use this transaction\r\n+      manager is, of course, that all the slices must be configured to use\r\n+      XA-complaint JDBC driver. \r\n+      <warning>This JNDI based policy is not available currently.</warning>\r\n+      </para>\r\n+    </section>\r\n+   </section>\r\n+   \r\n+   <section>\r\n+     <title>Per-Slice Properties</title>\r\n+     <para>\r\n+     Any OpenJPA property can be configured for each individual slice. The property name\r\n+     is of the form <code>slice.[Logical slice name].[OpenJPA Property Name]</code>.\r\n+     For example, <code>slice.One.ConnectionURL</code> where <code>One</code>\r\n+     is the logical slice name and <code>ConnectionURL</code> is a OpenJPA property\r\n+     name. \r\n+     </para>\r\n+     <para>\r\n+     If a property is not configured for a specific slice, then the value for\r\n+     the property equals to the corresponding <code>openjpa.*</code> property.\r\n+     </para>\r\n+   </section>\r\n+  \r\n+</chapter>\r\n+  \n\\ No newline at end of file"},{"sha":"120c041db0434c2617c19197763c3b9756bc4598","filename":"openjpa-slice/pom.xml","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/pom.xml?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,61 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n+<!--\r\n+ Licensed to the Apache Software Foundation (ASF) under one\r\n+ or more contributor license agreements.  See the NOTICE file\r\n+ distributed with this work for additional information\r\n+ regarding copyright ownership.  The ASF licenses this file\r\n+ to you under the Apache License, Version 2.0 (the\r\n+ \"License\"); you may not use this file except in compliance\r\n+ with the License.  You may obtain a copy of the License at\r\n+ \r\n+ http://www.apache.org/licenses/LICENSE-2.0\r\n+ \r\n+ Unless required by applicable law or agreed to in writing,\r\n+ software distributed under the License is distributed on an\r\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ KIND, either express or implied.  See the License for the\r\n+ specific language governing permissions and limitations\r\n+ under the License.   \r\n+-->\r\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n+    <modelVersion>4.0.0</modelVersion>\r\n+    <groupId>org.apache.openjpa</groupId>\r\n+    <artifactId>openjpa-slice</artifactId>\r\n+    <packaging>jar</packaging>\r\n+    <name>OpenJPA Slice</name>\r\n+    <description>OpenJPA Slice</description>\r\n+    <url>http://openjpa.apache.org</url>\r\n+    <parent>\r\n+        <groupId>org.apache.openjpa</groupId>\r\n+        <artifactId>openjpa-parent</artifactId>\r\n+        <version>1.1.0-SNAPSHOT</version>\r\n+    </parent>\r\n+    <dependencies>\r\n+        <dependency>\r\n+            <groupId>org.apache.openjpa</groupId>\r\n+            <artifactId>openjpa-kernel</artifactId>\r\n+            <version>${pom.version}</version>\r\n+            <scope>compile</scope>\r\n+        </dependency>\r\n+        <dependency>\r\n+            <groupId>org.apache.openjpa</groupId>\r\n+            <artifactId>openjpa-jdbc</artifactId>\r\n+            <version>${pom.version}</version>\r\n+            <scope>compile</scope>\r\n+        </dependency>\r\n+    </dependencies>\r\n+    <build>\r\n+        <plugins>\r\n+            <plugin>\r\n+                <groupId>org.apache.maven.plugins</groupId>\r\n+                <artifactId>maven-compiler-plugin</artifactId>\r\n+                <configuration>\r\n+                    <source>1.5</source>\r\n+                    <target>1.5</target>\r\n+                </configuration>\r\n+            </plugin>\r\n+        </plugins>\r\n+    </build>\r\n+</project>\r"},{"sha":"b092e4812e7a4979dbf5d56e903b612d47d89899","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedBrokerImpl.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,82 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n+import org.apache.openjpa.kernel.OpCallbacks;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * A specialized Broker to associate slice identifiers with the StateManagers as\r\n+ * they are persisted in a cascade. This intervention helps the user to define\r\n+ * distribution policy only for root instances i.e. the instances that are\r\n+ * explicit argument to persist() call. The cascaded instances are assigned the\r\n+ * same slice to honor collocation constraint.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+@SuppressWarnings(\"serial\")\r\n+public class DistributedBrokerImpl extends BrokerImpl {\r\n+\tprivate transient String slice;\r\n+\r\n+\tprivate static final Localizer _loc =\r\n+\t\t\tLocalizer.forPackage(DistributedBrokerImpl.class);\r\n+\r\n+\t/**\r\n+\t * Assigns slice identifier to the resultant StateManager as initialized by\r\n+\t * the super class implementation. The slice identifier is decided by\r\n+\t * {@link DistributionPolicy} for given <code>pc</code> if it is a root\r\n+\t * instance i.e. the argument of the user application's persist() call. The\r\n+\t * cascaded instances are detected by non-empty status of the current\r\n+\t * operating set. The slice is assigned only if a StateManager has never\r\n+\t * been assigned before.\r\n+\t */\r\n+\tpublic OpenJPAStateManager persist(Object pc, Object id, boolean explicit,\r\n+\t\t\tOpCallbacks call) {\r\n+\t\tOpenJPAStateManager sm = getStateManager(pc);\r\n+\t\tif (getOperatingSet().isEmpty()\r\n+\t\t\t\t&& (sm == null || sm.getImplData() == null)) {\r\n+\t\t\tslice = getSlice(pc);\r\n+\t\t}\r\n+\t\tsm = super.persist(pc, id, explicit, call);\r\n+\t\tif (sm.getImplData() == null)\r\n+\t\t\tsm.setImplData(slice, true);\r\n+\r\n+\t\treturn sm;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Gets the slice by the user-defined distribution policy.\r\n+\t */\r\n+\tString getSlice(Object pc) {\r\n+\t\tDistributedConfiguration conf =\r\n+\t\t\t\t(DistributedConfiguration) getConfiguration();\r\n+\t\tString slice =\r\n+\t\t\t\t(conf.getDistributionPolicyInstance().distribute(pc, conf\r\n+\t\t\t\t\t\t.getActiveSliceNames(), this));\r\n+\t\tif (!conf.getActiveSliceNames().contains(slice))\r\n+\t\t\tthrow new UserException(_loc.get(\"bad-policy-slice\", new Object[] {\r\n+\t\t\t\t\tconf.getDistributionPolicyInstance().getClass().getName(),\r\n+\t\t\t\t\tslice, pc, conf.getActiveSliceNames() }));\r\n+\t\treturn slice;\r\n+\t}\r\n+}\r"},{"sha":"0a2ad774d70da0cd49453aa836992d2d01513bfe","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributedConfiguration.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,78 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+\r\n+/**\r\n+ * A configuration for multiple data stores, each referred as <em>slice</em>.\r\n+ * This configuration allows each underlying slice be configured with its\r\n+ * own specific configuration properties such as JDBC Driver or connection\r\n+ * user/password etc. <br>\r\n+ * This configuration also extends by adding a {@link DistributionPolicy \r\n+ * DistributionPolicy} that governs how new instances be distributed\r\n+ * among the slices.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public interface DistributedConfiguration extends OpenJPAConfiguration {\r\n+\t/**\r\n+\t * Gets the active slice identifiers. This list is determined by the\r\n+\t * configuration properties either by explicit listing in \r\n+\t * <code>slice.Names</code> property or by scanning <code>slice.*.*</code>\r\n+\t * properties.\r\n+\t * <br> \r\n+\t * The ordering of the slice identifiers is determined when they are\r\n+\t * specified explicitly in <code>slice.Names</code> property or \r\n+\t * ordered alphabetically when found by scanning the properties.\r\n+\t * <br>\r\n+\t * This list always returns the identifiers that are <em>active</em>, slices\r\n+\t * that can not be connected to are not included in this list.\r\n+\t */\r\n+\tList<String> getActiveSliceNames();\r\n+\t\r\n+\t/**\r\n+\t * Gets the available slice identifiers irrespective of their status.\r\n+\t * @return\r\n+\t */\r\n+    List<String> getAvailableSliceNames();\r\n+\r\n+\t\r\n+\t/**\r\n+\t * Gets the slices of given status.\r\n+\t * @param statuses list of status flags. If null, returns all slices \r\n+\t * irrespective of status;\r\n+\t */\r\n+\tList<Slice> getSlices(Slice.Status...statuses);\r\n+\t\r\n+\t/**\r\n+\t * Gets the Slice for a given name.\r\n+\t * Exception is raised if the given slice is not configured.\r\n+\t */\r\n+\tSlice getSlice(String sliceName);\r\n+\t\r\n+\t/**\r\n+\t * Gets the policy that governs how new instances will be distributed across\r\n+\t * the available slices.\r\n+\t */\r\n+\tDistributionPolicy getDistributionPolicyInstance();\r\n+}\r"},{"sha":"2d407045778988b95f2ba55824bdf63fedb4c038","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/DistributionPolicy.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,46 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.List;\r\n+\r\n+\r\n+/**\r\n+ * Policy to select one of the physical databases referred as <em>slice</em>\r\n+ * in which a given persistent instance will be stored.\r\n+ *  \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public interface DistributionPolicy {\r\n+\t/**\r\n+\t * Gets the name of the slice where a given instance will be stored.\r\n+\t *  \r\n+\t * @param pc The newly persistent or to-be-merged object. \r\n+\t * @param slices list of names of the configured slices. The ordering of \r\n+\t * the list is either explicit (by the <code>slice.Names</code> property)\r\n+\t * or implicit i.e. alphabetic if <code>slice.Names</code> is unspecified.  \r\n+\t * @param context generic persistence context managing the given instance.\r\n+\t * \r\n+\t * @return identifier of the slice. This name must match one of the\r\n+\t * configured slice names. \r\n+\t * @see DistributedConfiguration#getActiveSliceNames()\r\n+\t */\r\n+\tString distribute(Object pc, List<String> slices, Object context);\r\n+}\r"},{"sha":"bad8210cb0169fc7017ec81b942dc7264b5527cc","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ExecutorServiceValue.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,112 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.concurrent.BlockingQueue;\r\n+import java.util.concurrent.Callable;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.PriorityBlockingQueue;\r\n+import java.util.concurrent.RejectedExecutionHandler;\r\n+import java.util.concurrent.ThreadFactory;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.event.RemoteCommitProvider;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Value type used to represent a {@link ExecutorService}.\r\n+ * This value controls the thread pool parameters. The thread pool is used\r\n+ * to execute the queries.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * @nojavadoc\r\n+ */\r\n+\r\n+public class ExecutorServiceValue extends PluginValue {\r\n+    private static List<String> known =\r\n+            Arrays.asList(new String[] { \"cached\", \"fixed\" });\r\n+\r\n+    private static Localizer _loc =\r\n+            Localizer.forPackage(ExecutorServiceValue.class);\r\n+\r\n+    public ExecutorServiceValue() {\r\n+        super(\"ThreadingPolicy\", true);\r\n+        setDefault(\"cached\");\r\n+    }\r\n+\r\n+    public void setProperties(String props) {\r\n+        super.setProperties(props);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures a cached or fixed thread pool.\r\n+     */\r\n+    @Override\r\n+    public Object instantiate(Class type, Configuration conf, boolean fatal) {\r\n+        Object obj = null;\r\n+        int defaultSize = 10;\r\n+        String cls = getClassName();\r\n+        if (!known.contains(cls))\r\n+            cls = \"cached\";\r\n+\r\n+        Options opts = Configurations.parseProperties(getProperties());\r\n+\r\n+        ThreadFactory factory = null;\r\n+        if (opts.containsKey(\"ThreadFactory\")) {\r\n+            String fName = opts.getProperty(\"ThreadFactory\");\r\n+            try {\r\n+                factory = (ThreadFactory) Class.forName(fName).newInstance();\r\n+                Configurations.configureInstance(factory, conf, opts,\r\n+                        getProperty());\r\n+            } catch (Throwable t) {\r\n+                throw new UserException(_loc.get(\"bad-thread-factory\", fName), t);\r\n+            } finally {\r\n+                opts.removeProperty(\"ThreadFactory\");\r\n+            }\r\n+        } else {\r\n+            factory = Executors.defaultThreadFactory();\r\n+        }\r\n+        if (\"cached\".equals(cls)) {\r\n+            obj = Executors.newCachedThreadPool(factory);\r\n+        } else if (\"fixed\".equals(cls)) {\r\n+            long keepAliveTime = 60L;\r\n+            if (opts.containsKey(\"KeepAliveTime\")) {\r\n+                keepAliveTime = opts.getLongProperty(\"KeepAliveTime\");\r\n+                opts.removeLongProperty(\"KeepAliveTime\");\r\n+            }\r\n+            obj = new ThreadPoolExecutor(defaultSize, defaultSize,\r\n+                            keepAliveTime, TimeUnit.SECONDS,\r\n+                            new PriorityBlockingQueue<Runnable>(), factory);\r\n+\r\n+            Configurations.configureInstance(obj, conf, opts, getProperty());\r\n+        }\r\n+        set(obj, true);\r\n+        return obj;\r\n+    }\r\n+}\r"},{"sha":"5293773d3ac9aa17265e19a2c95d1e2b9e252de6","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/ProductDerivation.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,50 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAProductDerivation;\r\n+import org.apache.openjpa.lib.conf.AbstractProductDerivation;\r\n+import org.apache.openjpa.slice.jdbc.DistributedJDBCBrokerFactory;\r\n+\r\n+/**\r\n+ * Derives configuration for Slice.\r\n+ * Introduces a specialized BrokerFactory aliased as <code>slice</code>.\r\n+ * All Slice specific configuration is prefixed as <code>slice.XXX</code>\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class ProductDerivation extends AbstractProductDerivation implements\r\n+\t\tOpenJPAProductDerivation {\r\n+\r\n+\t@SuppressWarnings(\"unchecked\")\r\n+\tpublic void putBrokerFactoryAliases(Map m) {\r\n+\t\tm.put(\"slice\", DistributedJDBCBrokerFactory.class.getName());\r\n+\t}\r\n+\r\n+\tpublic String getConfigurationPrefix() {\r\n+\t\treturn \"slice\";\r\n+\t}\r\n+\r\n+\tpublic int getType() {\r\n+\t\treturn TYPE_FEATURE;\r\n+\t}\r\n+}\r"},{"sha":"b653396064f4e209f17cb491de6f851b22a77f1b","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/Slice.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,98 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+\r\n+/**\r\n+ * Represents a database slice of immutable logical name.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class Slice implements Comparable<Slice> {\r\n+    public enum Status {\r\n+        NOT_INITIALIZED, \r\n+        ACTIVE, \r\n+        INACTIVE, // configured but not available\r\n+        EXCLUDED  // configured but not used\r\n+    }; \r\n+    \r\n+    private final String name;\r\n+    private transient final OpenJPAConfiguration conf;\r\n+    private transient Status status;\r\n+    \r\n+    /**\r\n+     * Supply the logical name and configuration.\r\n+     */\r\n+    public Slice(String name, OpenJPAConfiguration conf) {\r\n+        this.name = name;\r\n+        this.conf = conf;\r\n+        this.status = Status.NOT_INITIALIZED;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the immutable logical name.\r\n+     */\r\n+    public String getName() {\r\n+        return name;\r\n+    }\r\n+    \r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return conf;\r\n+    }\r\n+    \r\n+    public Status getStatus() {\r\n+        return status;\r\n+    }\r\n+    \r\n+    public void setStatus(Status status) {\r\n+        this.status = status;\r\n+    }\r\n+    \r\n+    public boolean isActive() {\r\n+        return status == Status.ACTIVE;\r\n+    }\r\n+    \r\n+    public String toString() {\r\n+        return name;\r\n+    }\r\n+    \r\n+    public int compareTo(Slice other) {\r\n+        return name.compareTo(other.name);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Equals by name.\r\n+     */\r\n+    @Override\r\n+    public boolean equals(Object other) {\r\n+        if (this == other) return true;\r\n+        if (other == null) return false;\r\n+        if (other instanceof Slice) {\r\n+            return name.equals(((Slice)other).getName());\r\n+        }\r\n+        return false;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int hashCode() {\r\n+        return name.hashCode();\r\n+    }\r\n+}\r"},{"sha":"aee3a4d939a833f9b6a26702c343a53c1c6633f3","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SlicePersistence.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,50 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.kernel.StateManagerImpl;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * A helper to determine the slice identifier of an instance.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class SlicePersistence {\r\n+\t/**\r\n+\t * Get the slice identifier for the given instance if it is a managed\r\n+\t * instance and has been assigned to a slice.\r\n+\t * \r\n+\t * @return name of the slice, if any. null otherwise.\r\n+\t */\r\n+\tpublic static String getSlice(Object obj) {\r\n+\t\tif (obj == null)\r\n+\t\t\treturn null;\r\n+\t\tPersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, null);\r\n+\t\tif (pc == null)\r\n+\t\t\treturn null;\r\n+\t\tStateManagerImpl sm = (StateManagerImpl)pc.pcGetStateManager();\r\n+\t\tif (sm == null)\r\n+\t\t\treturn null;\r\n+\t\tObject slice = sm.getImplData();\r\n+\t\treturn (slice instanceof String) ? (String)slice : null;\r\n+\t}\r\n+}\r"},{"sha":"28b444dc1b8bfb633bc46d0afce881083047d852","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceVersion.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceVersion.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/SliceVersion.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,55 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice;\r\n+\r\n+import java.io.InputStream;\r\n+import java.util.Properties;\r\n+\r\n+public class SliceVersion  {\r\n+    public static final String VERSION;\r\n+    public static final String REVISION;\r\n+    \r\n+    static {\r\n+        Properties revisionProps = new Properties();\r\n+        try {\r\n+            InputStream in = SliceVersion.class.getResourceAsStream\r\n+                (\"/META-INF/org.apache.openjpa.slice.revision.properties\");\r\n+            if (in != null) {\r\n+                try {\r\n+                    revisionProps.load(in);\r\n+                } finally {\r\n+                    in.close();\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+        }\r\n+\r\n+        VERSION = revisionProps.getProperty(\"slice.version\", \"0.0.0\");\r\n+        REVISION = revisionProps.getProperty(\"revision.number\");\r\n+    }\r\n+    \r\n+    public static void main(String[] args) {\r\n+        System.out.println(new SliceVersion());\r\n+    }\r\n+    \r\n+    public String toString() {\r\n+        return \"Slice Version \" + VERSION + \" [revision \"+REVISION+\"]\";\r\n+    }\r\n+\r\n+}\r"},{"sha":"4b815d31c0c04924e093cb360969b7bffc260f17","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/AggregateResultObjectProvider.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/AggregateResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/AggregateResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/AggregateResultObjectProvider.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,120 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\r\n+import org.apache.openjpa.kernel.exps.Value;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.util.InternalException;\r\n+\r\n+public class AggregateResultObjectProvider implements ResultObjectProvider {\r\n+    private final ResultObjectProvider[] _rops;\r\n+    private final StoreQuery _query;\r\n+    private final QueryExpressions[] _exps;\r\n+    private Object _single;\r\n+    private boolean _opened;\r\n+\r\n+    public AggregateResultObjectProvider(ResultObjectProvider[] rops, \r\n+            StoreQuery q, QueryExpressions[] exps) {\r\n+        _rops = rops;\r\n+        _query = q;\r\n+        _exps = exps;\r\n+    }\r\n+    \r\n+    public boolean absolute(int pos) throws Exception {\r\n+        return false;\r\n+    }\r\n+\r\n+    public void close() throws Exception {\r\n+        _opened = false;\r\n+        for (ResultObjectProvider rop:_rops)\r\n+            rop.close();\r\n+    }\r\n+\r\n+    public Object getResultObject() throws Exception {\r\n+        if (!_opened)\r\n+            throw new InternalException(this + \" not-open\");\r\n+        return _single;\r\n+    }\r\n+\r\n+    public void handleCheckedException(Exception e) {\r\n+        _rops[0].handleCheckedException(e);\r\n+    }\r\n+\r\n+    public boolean next() throws Exception {\r\n+        if (!_opened) {\r\n+            open();\r\n+        }\r\n+            \r\n+        if (_single != null)\r\n+            return false;\r\n+        \r\n+        Value[] values = _exps[0].projections;\r\n+        Object[] single = new Object[values.length]; \r\n+        for (int i=0; i<values.length; i++) {\r\n+            Value v = values[i];\r\n+            boolean isAggregate = v.isAggregate();\r\n+            int op = decideOperationType(v);\r\n+            for (ResultObjectProvider rop:_rops) {\r\n+                rop.next();\r\n+                Object[] row = (Object[]) rop.getResultObject();\r\n+                switch (op) {\r\n+                case 2: single[i] = count(single[i],row[i]);\r\n+                break;\r\n+                default : single[i] = row[i];\r\n+                }\r\n+            } \r\n+        }\r\n+        \r\n+        _single = single;\r\n+        return true;\r\n+    }\r\n+    \r\n+    int decideOperationType(Value v) {\r\n+        String cls = v.getClass().getName();\r\n+        if (cls.equals(\"org.apache.openjpa.jdbc.kernel.exps.Sum\"))\r\n+            return 1;\r\n+        if (cls.equals(\"org.apache.openjpa.jdbc.kernel.exps.Count\"))\r\n+            return 2;\r\n+        return 0;\r\n+    }\r\n+    long count(Object current, Object other) {\r\n+        if (current == null)\r\n+            return (Long) other;\r\n+        return (Long)current + (Long)other;\r\n+    }\r\n+\r\n+    public void open() throws Exception {\r\n+        for (ResultObjectProvider rop:_rops)\r\n+            rop.open();\r\n+        _opened = true;\r\n+    }\r\n+\r\n+    public void reset() throws Exception {\r\n+    }\r\n+\r\n+    public int size() throws Exception {\r\n+        return 1;\r\n+    }\r\n+\r\n+    public boolean supportsRandomAccess() {\r\n+         return false;\r\n+    }\r\n+}\r"},{"sha":"c04c7731238d5e8ac02b6aab6820b8c80827e1d5","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedConnection.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,263 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.sql.CallableStatement;\r\n+import java.sql.Connection;\r\n+import java.sql.DatabaseMetaData;\r\n+import java.sql.PreparedStatement;\r\n+import java.sql.SQLException;\r\n+import java.sql.SQLWarning;\r\n+import java.sql.Savepoint;\r\n+import java.sql.Statement;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * A virtual connection that contains multiple physical connections.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+class DistributedConnection implements Connection {\r\n+\tprivate final List<Connection> real;\r\n+\tprivate final Connection master;\r\n+\r\n+\tpublic DistributedConnection(List<Connection> connections) {\r\n+\t\tif (connections == null || connections.isEmpty())\r\n+\t\t\tthrow new NullPointerException();\r\n+\t\treal = connections;\r\n+\t\tmaster = connections.get(0);\r\n+\t}\r\n+\t\r\n+\tpublic boolean contains(Connection c) {\r\n+\t\treturn real.contains(c);\r\n+\t}\r\n+\r\n+\tpublic void clearWarnings() throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.clearWarnings();\r\n+\t}\r\n+\r\n+\tpublic void close() throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.close();\r\n+\t}\r\n+\r\n+\tpublic void commit() throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.commit();\r\n+\t}\r\n+\r\n+\tpublic Statement createStatement() throws SQLException {\r\n+\t\tDistributedStatement ret = new DistributedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.createStatement());\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic Statement createStatement(int arg0, int arg1) throws SQLException {\r\n+\t\tDistributedStatement ret = new DistributedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.createStatement(arg0, arg1));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic Statement createStatement(int arg0, int arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tDistributedStatement ret = new DistributedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.createStatement(arg0, arg1, arg2));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic boolean getAutoCommit() throws SQLException {\r\n+\t\treturn master.getAutoCommit();\r\n+\t}\r\n+\r\n+\tpublic String getCatalog() throws SQLException {\r\n+\t\treturn master.getCatalog();\r\n+\t}\r\n+\r\n+\tpublic int getHoldability() throws SQLException {\r\n+\t\treturn master.getHoldability();\r\n+\t}\r\n+\r\n+\tpublic DatabaseMetaData getMetaData() throws SQLException {\r\n+\t\treturn master.getMetaData();\r\n+\t}\r\n+\r\n+\tpublic int getTransactionIsolation() throws SQLException {\r\n+\t\treturn master.getTransactionIsolation();\r\n+\t}\r\n+\r\n+\tpublic Map<String, Class<?>> getTypeMap() throws SQLException {\r\n+\t\treturn master.getTypeMap();\r\n+\t}\r\n+\r\n+\tpublic SQLWarning getWarnings() throws SQLException {\r\n+\t\treturn master.getWarnings();\r\n+\t}\r\n+\r\n+\tpublic boolean isClosed() throws SQLException {\r\n+\t\tboolean ret = false;\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret &= c.isClosed();\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic boolean isReadOnly() throws SQLException {\r\n+\t\tboolean ret = false;\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret &= c.isReadOnly();\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic String nativeSQL(String arg0) throws SQLException {\r\n+\t\treturn master.nativeSQL(arg0);\r\n+\t}\r\n+\r\n+\tpublic CallableStatement prepareCall(String arg0) throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic CallableStatement prepareCall(String arg0, int arg1, int arg2,\r\n+\t\t\tint arg3) throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0) throws SQLException {\r\n+\t\t// TODO: Big hack\r\n+\t\tif (arg0.startsWith(\"SELECT SEQUENCE_VALUE FROM OPENJPA_SEQUENCE_TABLE\"))\r\n+\t\t\treturn master.prepareStatement(arg0);\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0, int[] arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0, String[] arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0, arg1));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic PreparedStatement prepareStatement(String arg0, int arg1, int arg2,\r\n+\t\t\tint arg3) throws SQLException {\r\n+\t\tDistributedPreparedStatement ret = new DistributedPreparedStatement(this);\r\n+\t\tfor (Connection c : real) {\r\n+\t\t\tret.add(c.prepareStatement(arg0, arg1, arg2));\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic void releaseSavepoint(Savepoint arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.releaseSavepoint(arg0);\r\n+\t}\r\n+\r\n+\tpublic void rollback() throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.rollback();\r\n+\t}\r\n+\r\n+\tpublic void rollback(Savepoint arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.rollback(arg0);\r\n+\t}\r\n+\r\n+\tpublic void setAutoCommit(boolean arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setAutoCommit(arg0);\r\n+\t}\r\n+\r\n+\tpublic void setCatalog(String arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setCatalog(arg0);\r\n+\t}\r\n+\r\n+\tpublic void setHoldability(int arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setHoldability(arg0);\r\n+\t}\r\n+\r\n+\tpublic void setReadOnly(boolean arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setReadOnly(arg0);\r\n+\t}\r\n+\r\n+\tpublic Savepoint setSavepoint() throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic Savepoint setSavepoint(String arg0) throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic void setTransactionIsolation(int arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setTransactionIsolation(arg0);\r\n+\t}\r\n+\r\n+\tpublic void setTypeMap(Map<String, Class<?>> arg0) throws SQLException {\r\n+\t\tfor (Connection c : real)\r\n+\t\t\tc.setTypeMap(arg0);\r\n+\t}\r\n+}\r"},{"sha":"d3826216b1f342b5062c528dfc652eec71cf360e","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedDataSource.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,102 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.io.PrintWriter;\r\n+import java.sql.Connection;\r\n+import java.sql.SQLException;\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+\r\n+import javax.sql.DataSource;\r\n+import javax.sql.XADataSource;\r\n+\r\n+import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\r\n+\r\n+/**\r\n+ * A virtual datasource that contains many physical datasources.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedDataSource extends DecoratingDataSource implements\r\n+\t\tIterable<DataSource> {\r\n+\tprivate List<DataSource> real = new ArrayList<DataSource>();\r\n+\tprivate DataSource master;\r\n+\t\r\n+\tpublic DistributedDataSource(List<DataSource> dataSources) {\r\n+\t\tsuper(dataSources.get(0));\r\n+\t\treal = dataSources;\r\n+\t\tmaster = dataSources.get(0);\r\n+\t}\r\n+\t\r\n+\tConnection getConnection(DataSource ds) throws SQLException {\r\n+\t\tif (ds instanceof DecoratingDataSource)\r\n+\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate());\r\n+\t\tif (ds instanceof XADataSource)\r\n+\t\t\treturn ((XADataSource)ds).getXAConnection().getConnection();\r\n+\t\treturn ds.getConnection();\r\n+\t}\r\n+\t\r\n+\tConnection getConnection(DataSource ds, String user, String pwd) throws SQLException {\r\n+\t\tif (ds instanceof DecoratingDataSource)\r\n+\t\t\treturn getConnection(((DecoratingDataSource)ds).getInnermostDelegate(), user, pwd);\r\n+\t\tif (ds instanceof XADataSource)\r\n+\t\t\treturn ((XADataSource)ds).getXAConnection(user, pwd).getConnection();\r\n+\t\treturn ds.getConnection(user, pwd);\r\n+\t}\r\n+\r\n+\tpublic Iterator<DataSource> iterator() {\r\n+\t\treturn real.iterator();\r\n+\t}\r\n+\r\n+\tpublic Connection getConnection() throws SQLException {\r\n+\t\tList<Connection> c = new ArrayList<Connection>();\r\n+\t\tfor (DataSource ds : real)\r\n+\t\t\tc.add(ds.getConnection());\r\n+\t\treturn new DistributedConnection(c);\r\n+\t}\r\n+\r\n+\tpublic Connection getConnection(String username, String password)\r\n+\t\t\tthrows SQLException {\r\n+\t\tList<Connection> c = new ArrayList<Connection>();\r\n+\t\tfor (DataSource ds : real)\r\n+\t\t\tc.add(ds.getConnection(username, password));\r\n+\t\treturn new DistributedConnection(c);\r\n+\t}\r\n+\r\n+\tpublic PrintWriter getLogWriter() throws SQLException {\r\n+\t\treturn master.getLogWriter();\r\n+\t}\r\n+\r\n+\tpublic int getLoginTimeout() throws SQLException {\r\n+\t\treturn master.getLoginTimeout();\r\n+\t}\r\n+\r\n+\tpublic void setLogWriter(PrintWriter out) throws SQLException {\r\n+\t\tfor (DataSource ds:real)\r\n+\t\t\tds.setLogWriter(out);\r\n+\t}\r\n+\r\n+\tpublic void setLoginTimeout(int seconds) throws SQLException {\r\n+\t\tfor (DataSource ds:real)\r\n+\t\t\tds.setLoginTimeout(seconds);\r\n+\t}\r\n+}\r"},{"sha":"1db49207193271737bba1e4b0b546ea51ca4f327","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCBrokerFactory.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,107 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAVersion;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\r\n+import org.apache.openjpa.kernel.Bootstrap;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.slice.SliceVersion;\r\n+\r\n+/**\r\n+ * A factory for distributed JDBC datastores.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+@SuppressWarnings(\"serial\")\r\n+public class DistributedJDBCBrokerFactory extends JDBCBrokerFactory {\r\n+\tprivate static final Localizer _loc = \r\n+\t    Localizer.forPackage(DistributedJDBCBrokerFactory.class);\r\n+\t/**\r\n+\t * Factory method for constructing a factory from properties. Invoked from\r\n+\t * {@link Bootstrap#newBrokerFactory}.\r\n+\t */\r\n+\tpublic static DistributedJDBCBrokerFactory newInstance(\r\n+\t\t\tConfigurationProvider cp) {\r\n+\t\tDistributedJDBCConfigurationImpl conf =\r\n+\t\t\t\tnew DistributedJDBCConfigurationImpl(cp);\r\n+\t\tcp.setInto(conf);\r\n+\t\treturn new DistributedJDBCBrokerFactory(conf);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Factory method for obtaining a possibly-pooled factory from properties.\r\n+\t * Invoked from {@link Bootstrap#getBrokerFactory}.\r\n+\t */\r\n+\tpublic static JDBCBrokerFactory getInstance(ConfigurationProvider cp) {\r\n+\t    Map properties = cp.getProperties();\r\n+\t    Object key = toPoolKey(properties);\r\n+\t\tDistributedJDBCBrokerFactory factory =\r\n+\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\r\n+\t\tif (factory != null)\r\n+\t\t\treturn factory;\r\n+\r\n+\t\tfactory = newInstance(cp);\r\n+\t\tpool(key, factory);\r\n+\t\treturn factory;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Factory method for constructing a factory from a configuration.\r\n+\t */\r\n+\tpublic static synchronized JDBCBrokerFactory getInstance(\r\n+\t\t\tJDBCConfiguration conf) {\r\n+\t    Map properties = conf.toProperties(false);\r\n+\t    Object key = toPoolKey(properties);\r\n+\t\tDistributedJDBCBrokerFactory factory =\r\n+\t\t\t\t(DistributedJDBCBrokerFactory) getPooledFactoryForKey(key);\r\n+\t\tif (factory != null)\r\n+\t\t\treturn factory;\r\n+\r\n+\t\tfactory = new DistributedJDBCBrokerFactory(\r\n+\t\t        (DistributedJDBCConfiguration) conf);\r\n+\t\tpool(key, factory);\r\n+\t\treturn factory;\r\n+\t}\r\n+\r\n+\tpublic DistributedJDBCBrokerFactory(DistributedJDBCConfiguration conf) {\r\n+\t\tsuper(conf);\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tpublic DistributedJDBCConfiguration getConfiguration() {\r\n+\t    return (DistributedJDBCConfiguration)super.getConfiguration();\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected StoreManager newStoreManager() {\r\n+\t\treturn new DistributedStoreManager(getConfiguration());\r\n+\t}\r\n+\t\r\n+    @Override\r\n+    protected Object getFactoryInitializationBanner() {\r\n+        return _loc.get(\"factory-init\", new SliceVersion());\r\n+    }\r\n+}\r"},{"sha":"1aeae41277b68fc0184bf3c2892557cc90e1dff6","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfiguration.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.util.concurrent.ExecutorService;\r\n+\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.slice.DistributedConfiguration;\r\n+import org.apache.openjpa.slice.Slice;\r\n+\r\n+/**\r\n+ * A distributed configuration that is a ordered collection of \r\n+ * JDBCConfigurations.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public interface DistributedJDBCConfiguration extends JDBCConfiguration, \r\n+\tDistributedConfiguration {\r\n+    /**\r\n+     * Gets the master slice.\r\n+     */\r\n+    Slice getMaster();\r\n+    \r\n+    /**\r\n+     * Gets the TransactionManager instance being used.\r\n+     */\r\n+    TransactionManager getTransactionManagerInstance();\r\n+    \r\n+    /**\r\n+     * Gets the alias for TransactionManager being used.\r\n+     */\r\n+    String getTransactionManager();\r\n+    \r\n+    /**\r\n+     * Gets the alias for ExecutorService being used.\r\n+     */\r\n+    \r\n+    String getExecutorService();\r\n+    \r\n+    /**\r\n+     * Gets the ExecutorService being used.\r\n+     */\r\n+    ExecutorService getExecutorServiceInstance();\r\n+}\r"},{"sha":"3dc33fd63cfefe99b394b0f9846da1db6f53503f","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","status":"added","additions":480,"deletions":0,"changes":480,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedJDBCConfigurationImpl.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,480 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.SQLException;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import java.util.concurrent.ExecutorService;\r\n+\r\n+import javax.sql.DataSource;\r\n+import javax.sql.XADataSource;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\r\n+import org.apache.openjpa.jdbc.schema.DataSourceFactory;\r\n+import org.apache.openjpa.lib.conf.BooleanValue;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.lib.conf.StringListValue;\r\n+import org.apache.openjpa.lib.conf.StringValue;\r\n+import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\r\n+import org.apache.openjpa.lib.jdbc.DelegatingDataSource;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.log.LogFactory;\r\n+import org.apache.openjpa.lib.log.LogFactoryImpl;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.slice.DistributedBrokerImpl;\r\n+import org.apache.openjpa.slice.DistributionPolicy;\r\n+import org.apache.openjpa.slice.ExecutorServiceValue;\r\n+import org.apache.openjpa.slice.Slice;\r\n+import org.apache.openjpa.slice.SliceVersion;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Implements a distributed configuration of JDBCStoreManagers.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+public class DistributedJDBCConfigurationImpl extends JDBCConfigurationImpl\r\n+        implements DistributedJDBCConfiguration {\r\n+\r\n+    private final List<Slice> _slices = new ArrayList<Slice>();\r\n+    private List<String> _activeSliceNames = new ArrayList<String>();\r\n+    private Slice _master;\r\n+    \r\n+    private DecoratingDataSource virtualDataSource;\r\n+    protected BooleanValue lenientPlugin;\r\n+    protected StringValue masterPlugin;\r\n+    protected StringListValue namesPlugin;\r\n+    protected PluginValue txnMgrPlugin;\r\n+    protected ExecutorServiceValue executorServicePlugin;\r\n+    protected PluginValue distributionPolicyPlugin;\r\n+\r\n+    private static Localizer _loc =\r\n+            Localizer.forPackage(DistributedJDBCConfigurationImpl.class);\r\n+    public static final String PREFIX_SLICE = \"slice.\";\r\n+    public static final String PREFIX_OPENJPA = \"openjpa.\";\r\n+\r\n+    /**\r\n+     * Configure itself as well as underlying slices.\r\n+     * \r\n+     */\r\n+    public DistributedJDBCConfigurationImpl(ConfigurationProvider cp) {\r\n+        super(true, false);\r\n+        Map p = cp.getProperties();\r\n+        String pUnit = getPersistenceUnitName(p);\r\n+        setDiagnosticContext(pUnit);\r\n+        Log log = getConfigurationLog();\r\n+        log.info(_loc.get(\"config-init\", SliceVersion.VERSION));\r\n+        \r\n+        brokerPlugin.setString(DistributedBrokerImpl.class.getName());\r\n+        \r\n+        distributionPolicyPlugin = addPlugin(\"DistributionPolicy\", true);\r\n+        distributionPolicyPlugin.setDynamic(true);\r\n+        \r\n+        lenientPlugin = addBoolean(\"Lenient\");\r\n+        \r\n+        masterPlugin = addString(\"Master\");\r\n+        \r\n+        namesPlugin = addStringList(\"Names\");\r\n+        \r\n+        txnMgrPlugin = addPlugin(\"TransactionPolicy\", true);\r\n+        txnMgrPlugin.setAlias(\"default\", \r\n+                \"org.apache.openjpa.slice.transaction.NaiveTransactionManager\");\r\n+        txnMgrPlugin.setAlias(\"xa\", \r\n+                \"org.apache.openjpa.slice.transaction.DistributedTransactionManager\");\r\n+        txnMgrPlugin.setAlias(\"jndi\", \r\n+                \"org.apache.openjpa.slice.transaction.LookUpTransactionManager\");\r\n+        txnMgrPlugin.setDefault(\"default\");\r\n+        txnMgrPlugin.setString(\"default\");\r\n+        \r\n+        \r\n+        executorServicePlugin = new ExecutorServiceValue();\r\n+        addValue(executorServicePlugin);\r\n+        \r\n+        setSlices(p);\r\n+    }\r\n+    \r\n+    private String getPersistenceUnitName(Map p) {\r\n+        Object unit = p.get(PREFIX_OPENJPA+id.getProperty());\r\n+        return (unit == null) ? \"?\" : unit.toString();\r\n+    }\r\n+    \r\n+    private void setDiagnosticContext(String unit) {\r\n+        LogFactory logFactory = getLogFactory();\r\n+        if (logFactory instanceof LogFactoryImpl) {\r\n+            ((LogFactoryImpl)logFactory).setDiagnosticContext(unit);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the name of the active slices.\r\n+     */\r\n+    public List<String> getActiveSliceNames() {\r\n+        if (_activeSliceNames.isEmpty()) {\r\n+            for (Slice slice:_slices)\r\n+                if (slice.isActive())\r\n+                    _activeSliceNames.add(slice.getName());\r\n+        }\r\n+        return _activeSliceNames;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the name of the available slices.\r\n+     */\r\n+    public List<String> getAvailableSliceNames() {\r\n+        List<String> result = new ArrayList<String>();\r\n+        for (Slice slice:_slices)\r\n+            result.add(slice.getName());\r\n+        return result;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the slices of given status. Null returns all irrespective of status.\r\n+     */\r\n+    public List<Slice> getSlices(Slice.Status...statuses) {\r\n+        if (statuses == null)\r\n+            return Collections.unmodifiableList(_slices);\r\n+        List<Slice> result = new ArrayList<Slice>();\r\n+        for (Slice slice:_slices) {\r\n+            for (Slice.Status status:statuses)\r\n+                if (slice.getStatus().equals(status))\r\n+                    result.add(slice);\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the master slice. \r\n+     */\r\n+    public Slice getMaster() {\r\n+        return _master;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the configuration for given slice.\r\n+     */\r\n+    public Slice getSlice(String name) {\r\n+        for (Slice slice:_slices)\r\n+            if (slice.getName().equals(name))\r\n+                return slice;\r\n+        throw new UserException(_loc.get(\"slice-not-found\", name,\r\n+                    getActiveSliceNames()));\r\n+    }\r\n+\r\n+    public DistributionPolicy getDistributionPolicyInstance() {\r\n+        if (distributionPolicyPlugin.get() == null) {\r\n+            distributionPolicyPlugin.instantiate(DistributionPolicy.class,\r\n+                    this, true);\r\n+        }\r\n+        return (DistributionPolicy) distributionPolicyPlugin.get();\r\n+    }\r\n+\r\n+    public void setDistributionPolicyInstance(String val) {\r\n+        distributionPolicyPlugin.set(val);\r\n+    }\r\n+\r\n+    public Object getConnectionFactory() {\r\n+        if (virtualDataSource == null) {\r\n+            DistributedDataSource ds = createDistributedDataStore();\r\n+            virtualDataSource =\r\n+                    DataSourceFactory.installDBDictionary(\r\n+                            getDBDictionaryInstance(), ds, this, false);\r\n+        }\r\n+        return virtualDataSource;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a virtual DistributedDataSource as a composite of individual\r\n+     * slices as per configuration, optionally ignoring slices that can not be\r\n+     * connected.\r\n+     */\r\n+    private DistributedDataSource createDistributedDataStore() {\r\n+        List<DataSource> dataSources = new ArrayList<DataSource>();\r\n+        boolean isLenient = lenientPlugin.get();\r\n+        boolean isXA = true;\r\n+        for (Slice slice : _slices) {\r\n+            JDBCConfiguration conf = (JDBCConfiguration)slice.getConfiguration();\r\n+            Log log = conf.getConfigurationLog();\r\n+            String url = getConnectionInfo(conf);\r\n+            if (log.isInfoEnabled())\r\n+                log.info(_loc.get(\"slice-connect\", slice, url));\r\n+            try {\r\n+                DataSource ds = DataSourceFactory.newDataSource(conf, false);\r\n+                DecoratingDataSource dds = new DecoratingDataSource(ds);\r\n+                ds = DataSourceFactory.installDBDictionary(\r\n+                        conf.getDBDictionaryInstance(), dds, conf, false);\r\n+                if (verifyDataSource(slice, ds)) {\r\n+                    dataSources.add(ds);\r\n+                    isXA &= isXACompliant(ds);\r\n+                }\r\n+            } catch (Throwable ex) {\r\n+                handleBadConnection(isLenient, slice, ex);\r\n+            }\r\n+        }\r\n+        DistributedDataSource result = new DistributedDataSource(dataSources);\r\n+        return result;\r\n+    }\r\n+\r\n+    String getConnectionInfo(OpenJPAConfiguration conf) {\r\n+        String result = conf.getConnectionURL();\r\n+        if (result == null) {\r\n+            result = conf.getConnectionDriverName();\r\n+            String props = conf.getConnectionProperties();\r\n+            if (props != null)\r\n+                result += \"(\" + props + \")\";\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    boolean isXACompliant(DataSource ds) {\r\n+        if (ds instanceof DelegatingDataSource)\r\n+            return ((DelegatingDataSource) ds).getInnermostDelegate() \r\n+               instanceof XADataSource;\r\n+        return ds instanceof XADataSource;\r\n+    }\r\n+\r\n+    /**\r\n+     * Verify that a connection can be established to the given slice. If\r\n+     * connection can not be established then slice is set to INACTIVE state.\r\n+     */\r\n+    private boolean verifyDataSource(Slice slice, DataSource ds) {\r\n+        Connection con = null;\r\n+        try {\r\n+            con = ds.getConnection();\r\n+            slice.setStatus(Slice.Status.ACTIVE);\r\n+            if (con == null) {\r\n+                slice.setStatus(Slice.Status.INACTIVE);\r\n+                return false;\r\n+            }\r\n+            return true;\r\n+        } catch (SQLException ex) {\r\n+            slice.setStatus(Slice.Status.INACTIVE);\r\n+            return false;\r\n+        } finally {\r\n+            if (con != null)\r\n+                try {\r\n+                    con.close();\r\n+                } catch (SQLException ex) {\r\n+                    // ignore\r\n+                }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Either throw a user exception or add the configuration to the given list,\r\n+     * based on <code>isLenient</code>.\r\n+     */\r\n+    private void handleBadConnection(boolean isLenient, Slice slice,\r\n+            Throwable ex) {\r\n+        OpenJPAConfiguration conf = slice.getConfiguration();\r\n+        String url = conf.getConnectionURL();\r\n+        Log log = getLog(LOG_RUNTIME);\r\n+        if (isLenient) {\r\n+            if (ex != null) {\r\n+                log.warn(_loc.get(\"slice-connect-known-warn\", slice, url, ex\r\n+                        .getCause()));\r\n+            } else {\r\n+                log.warn(_loc.get(\"slice-connect-warn\", slice, url));\r\n+            }\r\n+        } else if (ex != null) {\r\n+            throw new UserException(_loc.get(\"slice-connect-known-error\",\r\n+                    slice, url, ex), ex.getCause());\r\n+        } else {\r\n+            throw new UserException(_loc.get(\"slice-connect-error\", slice, url));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Create individual slices with configurations from the given properties.\r\n+     */\r\n+    void setSlices(Map original) {\r\n+        List<String> sliceNames = findSlices(original);\r\n+        Log log = getConfigurationLog();\r\n+        if (sliceNames.isEmpty()) {\r\n+            throw new UserException(_loc.get(\"slice-none-configured\"));\r\n+        } \r\n+        for (String key : sliceNames) {\r\n+            JDBCConfiguration child = new JDBCConfigurationImpl();\r\n+            child.fromProperties(createSliceProperties(original, key));\r\n+            child.setId(PREFIX_SLICE + key);\r\n+            Slice slice = new Slice(key, child);\r\n+            _slices.add(slice);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(_loc.get(\"slice-configuration\", key, child\r\n+                        .toProperties(false)));\r\n+        }\r\n+        setMaster();\r\n+    }\r\n+\r\n+    /**\r\n+     * Finds the slices. If <code>slice.Names</code> property is available\r\n+     * then the slices are ordered in the way they are listed. Otherwise scans\r\n+     * all available slices by looking for property of the form\r\n+     * <code>slice.XYZ.abc</code> where <code>XYZ</code> is the slice\r\n+     * identifier and <code>abc</code> is openjpa property name. The slices\r\n+     * are then ordered alphabetically.\r\n+     */\r\n+    private List<String> findSlices(Map p) {\r\n+        List<String> sliceNames = new ArrayList<String>();\r\n+        \r\n+        Log log = getConfigurationLog();\r\n+        String key = PREFIX_SLICE+namesPlugin.getProperty();\r\n+        boolean explicit = p.containsKey(key);\r\n+        if (explicit) {\r\n+            String[] values = p.get(key).toString().split(\"\\\\,\");\r\n+            for (String name:values)\r\n+                if (!sliceNames.contains(name.trim()))\r\n+                    sliceNames.add(name.trim());\r\n+        } else {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(_loc.get(\"no-slice-names\"));\r\n+            sliceNames = scanForSliceNames(p);\r\n+            Collections.sort(sliceNames);\r\n+        }\r\n+        if (log.isInfoEnabled()) {\r\n+            log.info(_loc.get(\"slice-available\", sliceNames));\r\n+        }\r\n+        return sliceNames;\r\n+    }\r\n+    \r\n+    private List<String> scanForSliceNames(Map p) {\r\n+        List<String> sliceNames = new ArrayList<String>();\r\n+        for (Object o : p.keySet()) {\r\n+            String key = o.toString();\r\n+            if (key.startsWith(PREFIX_SLICE) && key.split(\"\\\\.\").length > 2) {\r\n+                String sliceName =\r\n+                    chopTail(chopHead(o.toString(), PREFIX_SLICE), \".\");\r\n+                if (!sliceNames.contains(sliceName))\r\n+                    sliceNames.add(sliceName);\r\n+            }\r\n+        }\r\n+        return sliceNames;\r\n+    }\r\n+\r\n+    static String chopHead(String s, String head) {\r\n+        if (s.startsWith(head))\r\n+            return s.substring(head.length());\r\n+        return s;\r\n+    }\r\n+\r\n+    static String chopTail(String s, String tail) {\r\n+        int i = s.lastIndexOf(tail);\r\n+        if (i == -1)\r\n+            return s;\r\n+        return s.substring(0, i);\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates given <code>slice</code> specific configuration properties from\r\n+     * given <code>original</code> key-value map. The rules are\r\n+     * <LI> if key begins with <code>\"slice.XXX.\"</code> where\r\n+     * <code>XXX</code> is the given slice name, then replace\r\n+     * <code>\"slice.XXX.</code> with <code>openjpa.</code>.\r\n+     * <LI>if key begins with <code>\"slice.\"</code> but not with\r\n+     * <code>\"slice.XXX.\"</code>, the ignore i.e. any property of other\r\n+     * slices or global slice property e.g.\r\n+     * <code>slice.DistributionPolicy</code>\r\n+     * <code>if key starts with <code>\"openjpa.\"</code> and a corresponding\r\n+     * <code>\"slice.XXX.\"</code> property does not exist, then use this as\r\n+     * default property\r\n+     * <code>property with any other prefix is simply copied\r\n+     *\r\n+     */\r\n+    Map createSliceProperties(Map original, String slice) {\r\n+        Map result = new Properties();\r\n+        String prefix = PREFIX_SLICE + slice + \".\";\r\n+        for (Object o : original.keySet()) {\r\n+            String key = o.toString();\r\n+            if (key.startsWith(prefix)) {\r\n+                String newKey = PREFIX_OPENJPA + key.substring(prefix.length());\r\n+                result.put(newKey, original.get(o));\r\n+            } else if (key.startsWith(PREFIX_SLICE)) {\r\n+                // ignore keys that are in 'slice.' namespace but not this slice\r\n+            } else if (key.startsWith(PREFIX_OPENJPA)) {\r\n+                String newKey = prefix + key.substring(PREFIX_OPENJPA.length());\r\n+                if (!original.containsKey(newKey))\r\n+                    result.put(key, original.get(o));\r\n+            } else { // keys that are neither \"openjpa\" nor \"slice\" namespace\r\n+                result.put(key, original.get(o));\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /**\r\n+     * Determine the master slice.\r\n+     */\r\n+    private void setMaster() {\r\n+        String masterSlice = masterPlugin.get();\r\n+        Log log = getConfigurationLog();\r\n+        List<Slice> activeSlices = getSlices(null);\r\n+        if (masterSlice == null || masterSlice.length() == 0) {\r\n+            _master = activeSlices.get(0);\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(_loc.get(\"no-master-slice\", _master));\r\n+            return;\r\n+        }\r\n+        for (Slice slice:activeSlices)\r\n+            if (slice.getName().equals(masterSlice))\r\n+                _master = slice;\r\n+        if (_master == null) {\r\n+            _master = activeSlices.get(0);\r\n+        }\r\n+    }\r\n+    \r\n+    public String getTransactionManager() {\r\n+        return txnMgrPlugin.getString();\r\n+    }\r\n+\r\n+    public void setTransactionManager(TransactionManager txnManager) {\r\n+        txnMgrPlugin.set(txnManager);\r\n+    }\r\n+\r\n+    public TransactionManager getTransactionManagerInstance() {\r\n+        if (txnMgrPlugin.get() == null) {\r\n+            txnMgrPlugin.instantiate(TransactionManager.class, this);\r\n+        }\r\n+        return (TransactionManager) txnMgrPlugin.get();\r\n+    }\r\n+\r\n+    public String getExecutorService() {\r\n+        return executorServicePlugin.getString();\r\n+    }\r\n+\r\n+    public void setExecutorService(ExecutorService txnManager) {\r\n+        executorServicePlugin.set(txnManager);\r\n+    }\r\n+\r\n+    public ExecutorService getExecutorServiceInstance() {\r\n+        if (executorServicePlugin.get() == null) {\r\n+            executorServicePlugin.instantiate(ExecutorService.class, this);\r\n+        }\r\n+        return (ExecutorService) executorServicePlugin.get();\r\n+    }\r\n+    \r\n+}\r"},{"sha":"1b83c48135210fdb1c090c1cbf5175efc6defbc3","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","status":"added","additions":429,"deletions":0,"changes":429,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedPreparedStatement.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,429 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.io.InputStream;\r\n+import java.io.Reader;\r\n+import java.math.BigDecimal;\r\n+import java.net.URL;\r\n+import java.sql.Array;\r\n+import java.sql.Blob;\r\n+import java.sql.Clob;\r\n+import java.sql.Date;\r\n+import java.sql.ParameterMetaData;\r\n+import java.sql.PreparedStatement;\r\n+import java.sql.Ref;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Time;\r\n+import java.sql.Timestamp;\r\n+import java.util.Calendar;\r\n+\r\n+/**\r\n+ * A virtual PreparedStaement that delegates to a set of actual PreparedStatements.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedPreparedStatement extends DistributedTemplate<PreparedStatement>\r\n+\t\timplements PreparedStatement {\r\n+\r\n+\tDistributedPreparedStatement(DistributedConnection c) {\r\n+\t\tsuper(c);\r\n+\t}\r\n+\r\n+\tpublic void clearParameters() throws SQLException {\r\n+\t\tfor (PreparedStatement s : this)\r\n+\t\t\ts.clearParameters();\r\n+\t}\r\n+\r\n+\tpublic boolean execute() throws SQLException {\r\n+\t\tboolean ret = true;\r\n+\t\tfor (PreparedStatement s : this)\r\n+\t\t\tret = s.execute() & ret;\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic ResultSet executeQuery() throws SQLException {\r\n+\t\tDistributedResultSet mrs = new DistributedResultSet();\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tmrs.add(t.executeQuery());\r\n+\t\treturn mrs;\r\n+\t}\r\n+\r\n+\tpublic int executeUpdate() throws SQLException {\r\n+\t\tint ret = 0;\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tret += t.executeUpdate();\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic ResultSetMetaData getMetaData() throws SQLException {\r\n+\t\treturn master.getMetaData();\r\n+\t}\r\n+\r\n+\tpublic ParameterMetaData getParameterMetaData() throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic void setArray(int i, Array x) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setArray(i, x);\r\n+\t}\r\n+\r\n+\tpublic void setAsciiStream(int arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setAsciiStream(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setBigDecimal(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setBinaryStream(int arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setBinaryStream(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setBlob(int arg0, Blob arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setBlob(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setBoolean(int arg0, boolean arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setBoolean(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setByte(int arg0, byte arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setByte(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setBytes(int arg0, byte[] arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setBytes(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setCharacterStream(int arg0, Reader arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setCharacterStream(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setClob(int arg0, Clob arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setClob(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setDate(int arg0, Date arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setDate(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setDate(int arg0, Date arg1, Calendar arg2) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setDate(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setDouble(int arg0, double arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setDouble(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setFloat(int arg0, float arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setFloat(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setInt(int arg0, int arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setInt(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setLong(int arg0, long arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setLong(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setNull(int arg0, int arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setNull(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setNull(int arg0, int arg1, String arg2) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setNull(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setObject(int arg0, Object arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setObject(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setObject(int arg0, Object arg1, int arg2) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setObject(arg0, arg1, arg2);\r\n+\t}\r\n+\r\n+\tpublic void setObject(int arg0, Object arg1, int arg2, int arg3)\r\n+\t\t\tthrows SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setObject(arg0, arg1, arg2, arg3);\r\n+\t}\r\n+\r\n+\tpublic void setRef(int arg0, Ref arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setRef(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setShort(int arg0, short arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setShort(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic void setString(int arg0, String arg1) throws SQLException {\r\n+\t\tfor (PreparedStatement t : this)\r\n+\t\t\tt.setString(arg0, arg1);\r\n+\t}\r\n+\r\n+\t public void setTime(int arg0, Time arg1) throws SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setTime(arg0, arg1);\r\n+\t }\r\n+\t\r\n+\t public void setTime(int arg0, Time arg1, Calendar arg2) throws\r\n+\t SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setTime(arg0, arg1, arg2);\r\n+\t }\r\n+\t\r\n+\t public void setTimestamp(int arg0, Timestamp arg1) throws SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setTimestamp(arg0, arg1);\r\n+\t }\r\n+\t\r\n+\t public void setTimestamp(int arg0, Timestamp arg1, Calendar arg2)\r\n+\t throws SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setTimestamp(arg0, arg1, arg2);\r\n+\t }\r\n+\t\r\n+\t public void setURL(int arg0, URL arg1) throws SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setURL(arg0, arg1);\r\n+\t }\r\n+\t\r\n+\t public void setUnicodeStream(int arg0, InputStream arg1, int arg2)\r\n+\t throws SQLException {\r\n+\t\t\tfor (PreparedStatement t : this)\r\n+\t\t\t\tt.setUnicodeStream(arg0, arg1, arg2);\r\n+\t }\r\n+\t\r\n+\t public void addBatch() throws SQLException {\r\n+\t\t\t\tfor (PreparedStatement t:this)\r\n+\t\t\t\t\tt.addBatch();\r\n+\t }\r\n+\t\r\n+\t// public void cancel() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void clearBatch() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void clearWarnings() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void close() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public boolean execute(String arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public boolean execute(String arg0, int arg1) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public boolean execute(String arg0, int[] arg1) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public boolean execute(String arg0, String[] arg1) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public int[] executeBatch() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public ResultSet executeQuery(String arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public int executeUpdate(String arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int executeUpdate(String arg0, int arg1) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int executeUpdate(String arg0, int[] arg1) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int executeUpdate(String arg0, String[] arg1) throws SQLException\r\n+\t// {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public Connection getConnection() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public int getFetchDirection() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int getFetchSize() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public ResultSet getGeneratedKeys() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public int getMaxFieldSize() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int getMaxRows() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public boolean getMoreResults() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public boolean getMoreResults(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return false;\r\n+\t// }\r\n+\t//\r\n+\t// public int getQueryTimeout() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public ResultSet getResultSet() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public int getResultSetConcurrency() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int getResultSetHoldability() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int getResultSetType() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public int getUpdateCount() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return 0;\r\n+\t// }\r\n+\t//\r\n+\t// public SQLWarning getWarnings() throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t// return null;\r\n+\t// }\r\n+\t//\r\n+\t// public void setCursorName(String arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setEscapeProcessing(boolean arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setFetchDirection(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setFetchSize(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setMaxFieldSize(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setMaxRows(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\t//\r\n+\t// public void setQueryTimeout(int arg0) throws SQLException {\r\n+\t// // TODO Auto-generated method stub\r\n+\t//\r\n+\t// }\r\n+\r\n+}\r"},{"sha":"58cf5e2b79a6a6dfccc033f38313343957323ddf","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","status":"added","additions":763,"deletions":0,"changes":763,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedResultSet.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,763 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.io.InputStream;\r\n+import java.io.Reader;\r\n+import java.math.BigDecimal;\r\n+import java.net.URL;\r\n+import java.sql.Array;\r\n+import java.sql.Blob;\r\n+import java.sql.Clob;\r\n+import java.sql.Date;\r\n+import java.sql.Ref;\r\n+import java.sql.ResultSet;\r\n+import java.sql.ResultSetMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.SQLWarning;\r\n+import java.sql.Statement;\r\n+import java.sql.Time;\r\n+import java.sql.Timestamp;\r\n+import java.util.Calendar;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * A chain of ResultSet.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedResultSet implements ResultSet {\r\n+\tLinkedList<ResultSet> comps = new LinkedList<ResultSet>();\r\n+\tResultSet current;\r\n+\tint cursor = -1;\r\n+\t\r\n+\t/**\r\n+\t * Adds the ResultSet only if it has rows.\r\n+\t */\r\n+\tpublic void add(ResultSet rs) {\r\n+\t\ttry {\r\n+\t\t\tif (rs.first())\r\n+\t\t\t\tcomps.add(rs);\r\n+\t\t} catch (SQLException e) {\r\n+\t\t\t// ignore\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tpublic boolean absolute(int arg0) throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic void afterLast() throws SQLException {\r\n+\t\tcurrent = null;\r\n+\t\tcursor  = comps.size();\r\n+\t}\r\n+\r\n+\tpublic void beforeFirst() throws SQLException {\r\n+\t\tcurrent = null;\r\n+\t\tcursor  = -1;\r\n+\t}\r\n+\r\n+\tpublic void cancelRowUpdates() throws SQLException {\r\n+\t\tthrow new UnsupportedOperationException();\r\n+\t}\r\n+\r\n+\tpublic void clearWarnings() throws SQLException {\r\n+\t\tfor (ResultSet rs:comps)\r\n+\t\t\trs.clearWarnings();\r\n+\t}\r\n+\r\n+\tpublic void close() throws SQLException {\r\n+\t\tfor (ResultSet rs:comps)\r\n+\t\t\trs.close();\r\n+\t}\r\n+\r\n+\tpublic void deleteRow() throws SQLException {\r\n+\t\tcurrent.deleteRow();\r\n+\t}\r\n+\r\n+\tpublic int findColumn(String arg0) throws SQLException {\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic boolean first() throws SQLException {\r\n+\t\tif (comps.isEmpty()) return false;\r\n+\t\tcursor = 0;\r\n+\t\tcurrent = comps.get(0);\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n+\tpublic Array getArray(int arg0) throws SQLException {\r\n+\t\treturn current.getArray(arg0);\r\n+\t}\r\n+\r\n+\tpublic Array getArray(String arg0) throws SQLException {\r\n+\t\treturn current.getArray(arg0);\r\n+\t}\r\n+\r\n+\tpublic InputStream getAsciiStream(int arg0) throws SQLException {\r\n+\t\treturn current.getAsciiStream(arg0);\r\n+\t}\r\n+\r\n+\tpublic InputStream getAsciiStream(String arg0) throws SQLException {\r\n+\t\treturn current.getAsciiStream(arg0);\r\n+\t}\r\n+\r\n+\tpublic BigDecimal getBigDecimal(int arg0) throws SQLException {\r\n+\t\treturn current.getBigDecimal(arg0);\r\n+\t}\r\n+\r\n+\tpublic BigDecimal getBigDecimal(String arg0) throws SQLException {\r\n+\t\treturn current.getBigDecimal(arg0);\r\n+\t}\r\n+\r\n+\tpublic BigDecimal getBigDecimal(int arg0, int arg1) throws SQLException {\r\n+\t\treturn current.getBigDecimal(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic BigDecimal getBigDecimal(String arg0, int arg1) throws SQLException {\r\n+\t\treturn current.getBigDecimal(arg0, arg1);\r\n+\t}\r\n+\r\n+\tpublic InputStream getBinaryStream(int arg0) throws SQLException {\r\n+\t\treturn current.getBinaryStream(arg0);\r\n+\t}\r\n+\r\n+\tpublic InputStream getBinaryStream(String arg0) throws SQLException {\r\n+\t\treturn current.getBinaryStream(arg0);\r\n+\t}\r\n+\r\n+\tpublic Blob getBlob(int arg0) throws SQLException {\r\n+\t\treturn current.getBlob(arg0);\r\n+\t}\r\n+\r\n+\tpublic Blob getBlob(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic boolean getBoolean(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic boolean getBoolean(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic byte getByte(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic byte getByte(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic byte[] getBytes(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic byte[] getBytes(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Reader getCharacterStream(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Reader getCharacterStream(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Clob getClob(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Clob getClob(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic int getConcurrency() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic String getCursorName() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Date getDate(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Date getDate(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Date getDate(int arg0, Calendar arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Date getDate(String arg0, Calendar arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic double getDouble(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic double getDouble(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic int getFetchDirection() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic int getFetchSize() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic float getFloat(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic float getFloat(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic int getInt(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic int getInt(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic long getLong(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic long getLong(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic ResultSetMetaData getMetaData() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Object getObject(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Object getObject(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Object getObject(int arg0, Map<String, Class<?>> arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Object getObject(String arg0, Map<String, Class<?>> arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Ref getRef(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Ref getRef(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic int getRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic short getShort(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic short getShort(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic Statement getStatement() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic String getString(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic String getString(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Time getTime(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Time getTime(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Time getTime(int arg0, Calendar arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Time getTime(String arg0, Calendar arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Timestamp getTimestamp(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Timestamp getTimestamp(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Timestamp getTimestamp(int arg0, Calendar arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic Timestamp getTimestamp(String arg0, Calendar arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic int getType() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tpublic URL getURL(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic URL getURL(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic InputStream getUnicodeStream(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic InputStream getUnicodeStream(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic SQLWarning getWarnings() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\tpublic void insertRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic boolean isAfterLast() throws SQLException {\r\n+\t\treturn current == null && cursor >= comps.size();\r\n+\t}\r\n+\r\n+\tpublic boolean isBeforeFirst() throws SQLException {\r\n+\t\treturn current == null && cursor<0;\r\n+\t}\r\n+\r\n+\tpublic boolean isFirst() throws SQLException {\r\n+\t\treturn current != null && current.isFirst() && cursor==0;\r\n+\t}\r\n+\r\n+\tpublic boolean isLast() throws SQLException {\r\n+\t\treturn current != null && current.isLast() && cursor==comps.size()-1;\r\n+\t}\r\n+\r\n+\tpublic boolean last() throws SQLException {\r\n+\t\tif (comps.isEmpty()) return false;\r\n+\t\tcursor = comps.size()-1;\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic void moveToCurrentRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void moveToInsertRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic boolean next() throws SQLException {\r\n+\t\tif (current == null) {\r\n+\t\t\tcurrent = comps.get(0);\r\n+\t\t\tcursor = 0;\r\n+\t\t}\r\n+\t\tif (current.next())\r\n+\t\t\treturn true;\r\n+\t\tcursor++;\r\n+\t\tif (cursor<comps.size())\r\n+\t\t\tcurrent = comps.get(cursor);\r\n+\t\treturn cursor<comps.size();\r\n+\t}\r\n+\r\n+\tpublic boolean previous() throws SQLException {\r\n+\t\treturn current.previous();\r\n+\t}\r\n+\r\n+\tpublic void refreshRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic boolean relative(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic boolean rowDeleted() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic boolean rowInserted() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic boolean rowUpdated() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic void setFetchDirection(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void setFetchSize(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateArray(int arg0, Array arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateArray(String arg0, Array arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateAsciiStream(int arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateAsciiStream(String arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBigDecimal(int arg0, BigDecimal arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBigDecimal(String arg0, BigDecimal arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBinaryStream(int arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBinaryStream(String arg0, InputStream arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBlob(int arg0, Blob arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBlob(String arg0, Blob arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBoolean(int arg0, boolean arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBoolean(String arg0, boolean arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateByte(int arg0, byte arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateByte(String arg0, byte arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBytes(int arg0, byte[] arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateBytes(String arg0, byte[] arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateCharacterStream(int arg0, Reader arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateCharacterStream(String arg0, Reader arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateClob(int arg0, Clob arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateClob(String arg0, Clob arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateDate(int arg0, Date arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateDate(String arg0, Date arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateDouble(int arg0, double arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateDouble(String arg0, double arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateFloat(int arg0, float arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateFloat(String arg0, float arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateInt(int arg0, int arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateInt(String arg0, int arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateLong(int arg0, long arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateLong(String arg0, long arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateNull(int arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateNull(String arg0) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateObject(int arg0, Object arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateObject(String arg0, Object arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateObject(int arg0, Object arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateObject(String arg0, Object arg1, int arg2)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateRef(int arg0, Ref arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateRef(String arg0, Ref arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateRow() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateShort(int arg0, short arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateShort(String arg0, short arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateString(int arg0, String arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateString(String arg0, String arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateTime(int arg0, Time arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateTime(String arg0, Time arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateTimestamp(int arg0, Timestamp arg1) throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic void updateTimestamp(String arg0, Timestamp arg1)\r\n+\t\t\tthrows SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\r\n+\t}\r\n+\r\n+\tpublic boolean wasNull() throws SQLException {\r\n+\t\t// TODO Auto-generated method stub\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+}\r"},{"sha":"5a75a5bf8652bef4df5c5d9eb41f086f6b1e5d23","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStatement.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.sql.Statement;\r\n+\r\n+/**\r\n+ * A virtual Statement that delegates to many actual Statements.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedStatement extends DistributedTemplate<Statement>  {\r\n+\tpublic DistributedStatement(DistributedConnection c) {\r\n+\t\tsuper(c);\r\n+\t}\r\n+}\r"},{"sha":"89abb4999aeac62cfdb7295650b9fd839197f09c","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","status":"added","additions":494,"deletions":0,"changes":494,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,494 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.concurrent.Callable;\r\n+import java.util.concurrent.ExecutionException;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Future;\r\n+\r\n+import javax.naming.ConfigurationException;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.jdbc.kernel.ConnectionInfo;\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\r\n+import org.apache.openjpa.jdbc.sql.Result;\r\n+import org.apache.openjpa.jdbc.sql.ResultSetResult;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCState;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.slice.DistributionPolicy;\r\n+import org.apache.openjpa.slice.transaction.DistributedNaiveTransaction;\r\n+import org.apache.openjpa.slice.transaction.DistributedTransactionManager;\r\n+import org.apache.openjpa.slice.transaction.NaiveTransactionManager;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.StoreException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * A Store manager for multiple physical databases referred as <em>slice</em>.\r\n+ * This receiver behaves like a Transaction Manager as it implements two-phase\r\n+ * commit protocol if all the component slices is XA-complaint. The actions are\r\n+ * delegated to the underlying slices. The actions are executed in parallel\r\n+ * threads whenever possible such as flushing or query. <br>\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+class DistributedStoreManager extends JDBCStoreManager {\r\n+    private final List<SliceStoreManager> _slices;\r\n+    private JDBCStoreManager _master;\r\n+    private boolean isXA;\r\n+    private TransactionManager _tm;\r\n+    private final DistributedJDBCConfiguration _conf;\r\n+    private Log _log;\r\n+    private static final Localizer _loc =\r\n+            Localizer.forPackage(DistributedStoreManager.class);\r\n+    private static ExecutorService threadPool = Executors.newCachedThreadPool();\r\n+\r\n+    /**\r\n+     * Constructs a set of child StoreManagers each connected to a physical\r\n+     * DataSource.\r\n+     * \r\n+     * The supplied configuration carries multiple URL for underlying physical\r\n+     * slices. The first slice is referred as <em>master</em> and is used to\r\n+     * get Sequence based entity identifiers.\r\n+     */\r\n+    public DistributedStoreManager(DistributedJDBCConfiguration conf) {\r\n+        super();\r\n+        _conf = conf;\r\n+        _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+        _slices = new ArrayList<SliceStoreManager>();\r\n+        for (String name : conf.getActiveSliceNames()) {\r\n+            SliceStoreManager slice = new SliceStoreManager\r\n+                (conf.getSlice(name));\r\n+            _slices.add(slice);\r\n+            if (slice.getName().equals(conf.getMaster().getName()))\r\n+                _master = slice;\r\n+        }\r\n+    }\r\n+\r\n+    public DistributedJDBCConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decides the index of the StoreManager by first looking at the\r\n+     * implementation data. If not found then {@link DistributionPolicy\r\n+     * DistributionPolicy} determines the target store for new instances and\r\n+     * additional connection info is used to estimate for the existing\r\n+     * instances.\r\n+     */\r\n+    protected String findSliceName(OpenJPAStateManager sm, Object info) {\r\n+        boolean hasIndex = hasSlice(sm);\r\n+        if (hasIndex)\r\n+            return sm.getImplData().toString();\r\n+        String slice = estimateSlice(sm, info);\r\n+        if (slice == null)\r\n+            return assignSlice(sm);\r\n+        return slice;\r\n+    }\r\n+\r\n+    private boolean hasSlice(OpenJPAStateManager sm) {\r\n+        return sm.getImplData() != null;\r\n+    }\r\n+\r\n+    private String assignSlice(OpenJPAStateManager sm) {\r\n+        PersistenceCapable pc = sm.getPersistenceCapable();\r\n+        String slice =\r\n+                _conf.getDistributionPolicyInstance().distribute(pc,\r\n+                        _conf.getActiveSliceNames(), getContext());\r\n+        if (!_conf.getActiveSliceNames().contains(slice)) {\r\n+            throw new UserException(_loc.get(\"bad-policy-slice\", new Object[] {\r\n+                    _conf.getDistributionPolicyInstance().getClass().getName(),\r\n+                    slice, sm.getPersistenceCapable(), \r\n+                    _conf.getActiveSliceNames() }));\r\n+        }\r\n+        sm.setImplData(slice, true);\r\n+        return slice;\r\n+    }\r\n+\r\n+    /**\r\n+     * The additional edata is used, if possible, to find the StoreManager\r\n+     * managing the given StateManager. If the additional data is unavailable\r\n+     * then return null.\r\n+     * \r\n+     */\r\n+    private String estimateSlice(OpenJPAStateManager sm, Object edata) {\r\n+        if (edata == null || !(edata instanceof ConnectionInfo))\r\n+            return null;\r\n+\r\n+        Result result = ((ConnectionInfo) edata).result;\r\n+        if (result instanceof ResultSetResult) {\r\n+            JDBCStore store = ((ResultSetResult) result).getStore();\r\n+            for (SliceStoreManager slice : _slices) {\r\n+                if (slice == store) {\r\n+                    String sliceId = slice.getName();\r\n+                    sm.setImplData(sliceId, true);\r\n+                    return sliceId;\r\n+                }\r\n+            }\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Selects a child StoreManager where the given instance resides.\r\n+     */\r\n+    private StoreManager selectStore(OpenJPAStateManager sm, Object edata) {\r\n+        String name = findSliceName(sm, edata);\r\n+        SliceStoreManager slice = lookup(name);\r\n+        if (slice == null)\r\n+            throw new InternalException(_loc.get(\"wrong-slice\", name, sm));\r\n+        return slice;\r\n+    }\r\n+\r\n+    public boolean assignField(OpenJPAStateManager sm, int field,\r\n+            boolean preFlush) {\r\n+        return selectStore(sm, null).assignField(sm, field, preFlush);\r\n+    }\r\n+\r\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\r\n+        return _master.assignObjectId(sm, preFlush);\r\n+    }\r\n+\r\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\r\n+            PCState toState) {\r\n+        _master.beforeStateChange(sm, fromState, toState);\r\n+    }\r\n+\r\n+    public void begin() {\r\n+        TransactionManager tm = getTransactionManager();\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            try {\r\n+                Transaction txn = tm.getTransaction();\r\n+                if (isXA) {\r\n+                    txn.enlistResource(slice.getXAConnection().getXAResource());\r\n+                } else { // This is the only place where casting to our\r\n+                         // internal implementation classes become necessary\r\n+                    ((DistributedNaiveTransaction) txn).enlistResource(slice);\r\n+                }\r\n+            } catch (Exception e) {\r\n+                throw new InternalException(e);\r\n+            }\r\n+        }\r\n+\r\n+        try {\r\n+            tm.begin();\r\n+        } catch (Exception e) {\r\n+            throw new StoreException(e);\r\n+        }\r\n+    }\r\n+\r\n+    Log getLog(SliceStoreManager slice) {\r\n+        return slice.getConfiguration()\r\n+                .getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+    }\r\n+\r\n+    public void beginOptimistic() {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            slice.beginOptimistic();\r\n+    }\r\n+\r\n+    public boolean cancelAll() {\r\n+        boolean ret = true;\r\n+        for (SliceStoreManager slice : _slices)\r\n+            ret = slice.cancelAll() & ret;\r\n+        return ret;\r\n+    }\r\n+\r\n+    public void close() {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            slice.close();\r\n+    }\r\n+\r\n+    public void commit() {\r\n+        TransactionManager tm = getTransactionManager();\r\n+        try {\r\n+            tm.commit();\r\n+        } catch (Exception e) {\r\n+            throw new StoreException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public int compareVersion(OpenJPAStateManager sm, Object v1, Object v2) {\r\n+        return selectStore(sm, null).compareVersion(sm, v1, v2);\r\n+    }\r\n+\r\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\r\n+        return _master.copyDataStoreId(oid, meta);\r\n+    }\r\n+\r\n+    public ResultObjectProvider executeExtent(ClassMetaData meta,\r\n+            boolean subclasses, FetchConfiguration fetch) {\r\n+        ResultObjectProvider[] tmp = new ResultObjectProvider[_slices.size()];\r\n+        int i = 0;\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            tmp[i++] = slice.executeExtent(meta, subclasses, fetch);\r\n+        }\r\n+        return new MergedResultObjectProvider(tmp);\r\n+    }\r\n+\r\n+    public boolean exists(OpenJPAStateManager sm, Object edata) {\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            if (slice.exists(sm, edata)) {\r\n+                sm.setImplData(slice.getName(), true);\r\n+                return true;\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Flush the given StateManagers after binning them to respective physical\r\n+     * slices.\r\n+     */\r\n+    public Collection flush(Collection sms) {\r\n+        Collection exceptions = new ArrayList();\r\n+        List<Future<Collection>> futures = new ArrayList<Future<Collection>>();\r\n+        Map<String, List<OpenJPAStateManager>> subsets = bin(sms, null);\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            List<OpenJPAStateManager> subset = subsets.get(slice.getName());\r\n+            if (subset.isEmpty())\r\n+                continue;\r\n+            futures.add(threadPool.submit(new Flusher(slice, subset)));\r\n+        }\r\n+        for (Future<Collection> future : futures) {\r\n+            Collection error;\r\n+            try {\r\n+                error = future.get();\r\n+                if (!(error == null || error.isEmpty())) {\r\n+                    exceptions.addAll(error);\r\n+                }\r\n+            } catch (InterruptedException e) {\r\n+                throw new StoreException(e);\r\n+            } catch (ExecutionException e) {\r\n+                throw new StoreException(e.getCause());\r\n+            }\r\n+        }\r\n+        return exceptions;\r\n+    }\r\n+\r\n+    /**\r\n+     * Separate the given list of StateManagers in separate lists for each slice \r\n+     * by the associated slice identifier of each StateManager.\r\n+     * @param sms\r\n+     * @param edata\r\n+     * @return\r\n+     */\r\n+    private Map<String, List<OpenJPAStateManager>> bin(\r\n+            Collection/*<StateManage>*/ sms, Object edata) {\r\n+        Map<String, List<OpenJPAStateManager>> subsets =\r\n+                new HashMap<String, List<OpenJPAStateManager>>();\r\n+        for (SliceStoreManager slice : _slices)\r\n+            subsets.put(slice.getName(), new ArrayList<OpenJPAStateManager>());\r\n+        for (Object x : sms) {\r\n+            OpenJPAStateManager sm = (OpenJPAStateManager) x;\r\n+            String slice = findSliceName(sm, edata);\r\n+            subsets.get(slice).add(sm);\r\n+        }\r\n+        return subsets;\r\n+    }\r\n+\r\n+    public Object getClientConnection() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\r\n+        return _master.getDataStoreIdSequence(forClass);\r\n+    }\r\n+\r\n+    public Class getDataStoreIdType(ClassMetaData meta) {\r\n+        return _master.getDataStoreIdType(meta);\r\n+    }\r\n+\r\n+    public Class getManagedType(Object oid) {\r\n+        return _master.getManagedType(oid);\r\n+    }\r\n+\r\n+    public Seq getValueSequence(FieldMetaData forField) {\r\n+        return _master.getValueSequence(forField);\r\n+    }\r\n+\r\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\r\n+            FetchConfiguration fetch, Object edata) {\r\n+        if (edata instanceof ConnectionInfo) {\r\n+            String slice = findSliceName(sm, (ConnectionInfo) edata);\r\n+            if (slice != null)\r\n+                return lookup(slice).initialize(sm, state, fetch, edata);\r\n+        }\r\n+        // not a part of Query result load. Look into the slices till found\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            if (slice.initialize(sm, state, fetch, edata)) {\r\n+                sm.setImplData(slice.getName(), true);\r\n+                return true;\r\n+            }\r\n+        }\r\n+        return false;\r\n+\r\n+    }\r\n+\r\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\r\n+            FetchConfiguration fetch, int lockLevel, Object edata) {\r\n+        return selectStore(sm, edata).load(sm, fields, fetch, lockLevel, edata);\r\n+    }\r\n+\r\n+    public Collection loadAll(Collection sms, PCState state, int load,\r\n+            FetchConfiguration fetch, Object edata) {\r\n+        Map<String, List<OpenJPAStateManager>> subsets = bin(sms, edata);\r\n+        Collection result = new ArrayList();\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            List<OpenJPAStateManager> subset = subsets.get(slice.getName());\r\n+            if (subset.isEmpty())\r\n+                continue;\r\n+            Collection tmp = slice.loadAll(subset, state, load, fetch, edata);\r\n+            if (tmp != null && !tmp.isEmpty())\r\n+                result.addAll(tmp);\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    public Object newDataStoreId(Object oidVal, ClassMetaData meta) {\r\n+        return _master.newDataStoreId(oidVal, meta);\r\n+    }\r\n+\r\n+    public FetchConfiguration newFetchConfiguration() {\r\n+        return _master.newFetchConfiguration();\r\n+    }\r\n+\r\n+    /**\r\n+     * Construct a distributed query to be executed against all the slices.\r\n+     */\r\n+    public StoreQuery newQuery(String language) {\r\n+        ExpressionParser parser = QueryLanguages.parserForLanguage(language);\r\n+        DistributedStoreQuery ret = new DistributedStoreQuery(this, parser);\r\n+        for (SliceStoreManager slice : _slices) {\r\n+            ret.add(slice.newQuery(language));\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    public void releaseConnection() {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            slice.releaseConnection();\r\n+\r\n+    }\r\n+\r\n+    public void retainConnection() {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            slice.retainConnection();\r\n+    }\r\n+\r\n+    public void rollback() {\r\n+        TransactionManager tm = getTransactionManager();\r\n+        try {\r\n+            tm.rollback();\r\n+        } catch (Exception e) {\r\n+            throw new StoreException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public void rollbackOptimistic() {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            slice.rollbackOptimistic();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the context for this receiver and all its underlying slices.\r\n+     */\r\n+    public void setContext(StoreContext ctx) {\r\n+        super.setContext(ctx);\r\n+        isXA = true;\r\n+        for (SliceStoreManager store : _slices) {\r\n+            store.setContext(ctx, \r\n+                    (JDBCConfiguration)store.getSlice().getConfiguration());\r\n+            isXA &= store.isXAEnabled();\r\n+        }\r\n+        _tm = getTransactionManager();\r\n+    }\r\n+\r\n+    private SliceStoreManager lookup(String name) {\r\n+        for (SliceStoreManager slice : _slices)\r\n+            if (slice.getName().equals(name))\r\n+                return slice;\r\n+        return null;\r\n+    }\r\n+\r\n+    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\r\n+        return selectStore(sm, edata).syncVersion(sm, edata);\r\n+    }\r\n+\r\n+    protected TransactionManager getTransactionManager() {\r\n+        if (_tm == null) {\r\n+            _tm = getConfiguration().getTransactionManagerInstance();\r\n+            String alias = getConfiguration().getTransactionManager();\r\n+            boolean is2pc = !(_tm instanceof NaiveTransactionManager);\r\n+            if (isXA) { \r\n+                if (!is2pc) { \r\n+                    _log.warn(_loc.get(\"resource-xa-tm-not-2pc\", alias));\r\n+                    isXA = false;\r\n+                }\r\n+            } else if (is2pc) {\r\n+                throw new UserException(_loc.get(\"resource-not-xa-tm-2pc\", \r\n+                        alias));\r\n+            } \r\n+        }\r\n+        return _tm;\r\n+    }\r\n+\r\n+    private static class Flusher implements Callable<Collection> {\r\n+        final SliceStoreManager store;\r\n+        final Collection toFlush;\r\n+\r\n+        Flusher(SliceStoreManager store, Collection toFlush) {\r\n+            this.store = store;\r\n+            this.toFlush = toFlush;\r\n+        }\r\n+\r\n+        public Collection call() throws Exception {\r\n+            return store.flush(toFlush);\r\n+        }\r\n+    }\r\n+\r\n+}\r"},{"sha":"3e58077d8b53e88d99aa6e074477cca039b08bc4","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","status":"added","additions":231,"deletions":0,"changes":231,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,231 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.concurrent.Callable;\r\n+import java.util.concurrent.ExecutionException;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Future;\r\n+\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\r\n+import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n+import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.StoreException;\r\n+\r\n+/**\r\n+ * A query for distributed databases.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+@SuppressWarnings(\"serial\")\r\n+class DistributedStoreQuery extends JDBCStoreQuery {\r\n+\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\r\n+\tprivate ExpressionParser _parser;\r\n+\t\r\n+\tpublic DistributedStoreQuery(JDBCStore store, ExpressionParser parser) {\r\n+\t\tsuper(store, parser);\r\n+\t\t_parser = parser;\r\n+\t\t\r\n+\t}\r\n+\t\r\n+\tvoid add(StoreQuery q) {\r\n+\t\t_queries.add(q);\r\n+\t}\r\n+\t\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+    \tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \r\n+    \t\t\tctx.getCompilation());\r\n+        for (StoreQuery q:_queries) {\r\n+        \tex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n+        }\r\n+        return ex;\r\n+    }\r\n+    \r\n+    public void setContext(QueryContext ctx) {\r\n+    \tsuper.setContext(ctx);\r\n+    \tfor (StoreQuery q:_queries) \r\n+    \t\tq.setContext(ctx); \r\n+    }\r\n+    \r\n+    public ExecutorService getExecutorServiceInstance() {\r\n+        DistributedJDBCConfiguration conf = \r\n+            ((DistributedJDBCConfiguration)getStore().getConfiguration());\r\n+        return conf.getExecutorServiceInstance();\r\n+    }\r\n+\r\n+\t/**\r\n+\t * Executes queries on multiple databases.\r\n+\t * \r\n+\t * @author Pinaki Poddar \r\n+\t *\r\n+\t */\r\n+\tpublic static class ParallelExecutor extends \r\n+\t\tExpressionStoreQuery.DataStoreExecutor {\r\n+\t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n+\t\tprivate DistributedStoreQuery owner = null;\r\n+\t\tprivate ExecutorService threadPool = null;\r\n+\t\t\r\n+\t\tpublic void addExecutor(Executor ex) {\r\n+\t\t\texecutors.add(ex);\r\n+\t\t}\r\n+\t\t\r\n+        public ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta, \r\n+        \t\tboolean subclasses, ExpressionParser parser, Object parsed) {\r\n+        \tsuper(dsq, meta, subclasses, parser, parsed);\r\n+        \towner = dsq;\r\n+        \tthreadPool = ((DistributedJDBCConfiguration)dsq.getStore()\r\n+        \t        .getConfiguration()).getExecutorServiceInstance();\r\n+        }\r\n+        \r\n+        /**\r\n+         * Each child query must be executed with slice context and not the \r\n+         * given query context.\r\n+         */\r\n+        public ResultObjectProvider executeQuery(StoreQuery q,\r\n+                final Object[] params, final Range range) {\r\n+        \tResultObjectProvider[] tmp = new ResultObjectProvider[executors.size()];\r\n+        \tfinal Iterator<StoreQuery> qs = owner._queries.iterator();\r\n+        \tfinal List<Future<ResultObjectProvider>> futures = \r\n+        \t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n+        \tint i = 0;\r\n+        \tfor (Executor ex:executors)  {\r\n+        \t\tQueryExecutor call = new QueryExecutor();\r\n+        \t\tcall.executor = ex;\r\n+        \t\tcall.query    = qs.next();\r\n+        \t\tcall.params   = params;\r\n+        \t\tcall.range    = range;\r\n+        \t\tfutures.add(threadPool.submit(call)); \r\n+        \t}\r\n+        \tfor (Future<ResultObjectProvider> future:futures) {\r\n+        \t\ttry {\r\n+\t\t\t\t\ttmp[i++] = future.get();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+        \t}\r\n+        \tboolean[] ascending = getAscending(q);\r\n+        \tboolean isAscending = ascending.length > 0;\r\n+        \tboolean isUnique    = q.getContext().isUnique();\r\n+        \tif (isUnique) {\r\n+        \t    \r\n+        \t    return new UniqueResultObjectProvider(tmp, q, getQueryExpressions());\r\n+        \t}\r\n+        \tif (isAscending) {\r\n+        \t    return new OrderingMergedResultObjectProvider(tmp, ascending, \r\n+                  (Executor[])executors.toArray(new Executor[executors.size()]),\r\n+                  q, params);\r\n+        \t}\r\n+        \treturn new MergedResultObjectProvider(tmp);\r\n+        }\r\n+        \r\n+        public Number executeDelete(StoreQuery q, Object[] params) {\r\n+        \tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+        \tfinal List<Future<Number>> futures = new ArrayList<Future<Number>>();\r\n+        \tfor (Executor ex:executors) {\r\n+        \t\tDeleteExecutor call = new DeleteExecutor();\r\n+        \t\tcall.executor = ex;\r\n+        \t\tcall.query    = qs.next();\r\n+        \t\tcall.params   = params;\r\n+        \t\tfutures.add(threadPool.submit(call)); \r\n+        \t}\r\n+        \tint N = 0;\r\n+        \tfor (Future<Number> future:futures) {\r\n+        \t\ttry {\r\n+            \t\tNumber n = future.get();\r\n+            \t\tif (n != null) \r\n+            \t\t\tN += n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+        \t}\r\n+        \treturn new Integer(N);\r\n+        }\r\n+        \r\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n+        \tIterator<StoreQuery> qs = owner._queries.iterator();\r\n+        \tfinal List<Future<Number>> futures = new ArrayList<Future<Number>>();\r\n+        \tfor (Executor ex:executors) {\r\n+        \t\tUpdateExecutor call = new UpdateExecutor();\r\n+        \t\tcall.executor = ex;\r\n+        \t\tcall.query    = qs.next();\r\n+        \t\tcall.params   = params;\r\n+        \t\tfutures.add(threadPool.submit(call)); \r\n+        \t}\r\n+        \tint N = 0;\r\n+        \tfor (Future<Number> future:futures) {\r\n+        \t\ttry {\r\n+            \t\tNumber n = future.get();\r\n+            \t\tif (n != null) \r\n+            \t\t\tN += n.intValue();\r\n+\t\t\t\t} catch (InterruptedException e) {\r\n+\t\t\t\t\tthrow new RuntimeException(e);\r\n+\t\t\t\t} catch (ExecutionException e) {\r\n+\t\t\t\t\tthrow new StoreException(e.getCause());\r\n+\t\t\t\t}\r\n+        \t}\r\n+        \treturn new Integer(N);\r\n+        }\r\n+\r\n+\t}\r\n+\t\r\n+\tstatic  class QueryExecutor implements Callable<ResultObjectProvider> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\t\tRange range;\r\n+\t\tpublic ResultObjectProvider call() throws Exception {\r\n+\t\t\treturn executor.executeQuery(query, params, range);\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tstatic  class DeleteExecutor implements Callable<Number> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\t\tpublic Number call() throws Exception {\r\n+\t\t\treturn executor.executeDelete(query, params);\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tstatic  class UpdateExecutor implements Callable<Number> {\r\n+\t\tStoreQuery query;\r\n+\t\tExecutor executor;\r\n+\t\tObject[] params;\r\n+\t\tpublic Number call() throws Exception {\r\n+\t\t\treturn executor.executeDelete(query, params);\r\n+\t\t}\r\n+\t}\r\n+}\r\n+\r"},{"sha":"b44aa557c64b8a5118e5374bc0478236fc9f0477","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","status":"added","additions":273,"deletions":0,"changes":273,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedTemplate.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,273 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.SQLWarning;\r\n+import java.sql.Statement;\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+\r\n+/**\r\n+ * A template for multiple Statements being executed by multiple connections.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedTemplate<T extends Statement> \r\n+\timplements Statement, Iterable<T> {\r\n+\tprotected List<T> stmts = new ArrayList<T>();\r\n+\tprotected final DistributedConnection con;\r\n+\tprotected T master;\r\n+\t\r\n+\tpublic DistributedTemplate(DistributedConnection c) {\r\n+\t\tcon = c;\r\n+\t}\r\n+\t\r\n+\tpublic Iterator<T> iterator() {\r\n+\t\treturn stmts.iterator();\r\n+\t}\r\n+\t\r\n+\tpublic void add(T s) {\r\n+\t\tif (stmts.isEmpty())\r\n+\t\t\tmaster = s;\r\n+\t\ttry {\r\n+\t\t\tif (!con.contains(s.getConnection()))\r\n+\t\t\t\tthrow new IllegalArgumentException(s + \" has different connection\");\r\n+\t\t\tstmts.add(s);\r\n+\t\t} catch (SQLException e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\tpublic void addBatch(String sql) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.addBatch(sql);\r\n+\t}\r\n+\r\n+\tpublic void cancel() throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.cancel();\r\n+\t}\r\n+\r\n+\tpublic void clearBatch() throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.clearBatch();\r\n+\t}\r\n+\r\n+\tpublic void clearWarnings() throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.clearWarnings();\r\n+\t}\r\n+\r\n+\tpublic void close() throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.close();\r\n+\t}\r\n+\r\n+\tpublic boolean execute(String arg0) throws SQLException {\r\n+\t\tboolean ret = true;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret = s.execute(arg0) & ret;\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic boolean execute(String arg0, int arg1) throws SQLException {\r\n+\t\tboolean ret = true;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret = s.execute(arg0, arg1) & ret;\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic boolean execute(String arg0, int[] arg1) throws SQLException {\r\n+\t\tboolean ret = true;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret = s.execute(arg0, arg1) & ret;\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic boolean execute(String arg0, String[] arg1) throws SQLException {\r\n+\t\tboolean ret = true;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret = s.execute(arg0, arg1) & ret;\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic int[] executeBatch() throws SQLException {\r\n+\t\tint[] ret = new int[0];\r\n+\t\tfor (Statement s:this) {\r\n+\t\t\tint[] tmp = s.executeBatch();\r\n+\t\t\tret = new int[ret.length + tmp.length];\r\n+\t\t\tSystem.arraycopy(tmp, 0, ret, ret.length-tmp.length, tmp.length);\r\n+\t\t}\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic ResultSet executeQuery() throws SQLException {\r\n+\t\tDistributedResultSet rs = new DistributedResultSet();\r\n+\t\tfor (T s:this)\r\n+\t\t\trs.add(s.executeQuery(null));\r\n+\t\treturn rs;\r\n+\t}\r\n+\r\n+\tpublic ResultSet executeQuery(String arg0) throws SQLException {\r\n+\t\tDistributedResultSet rs = new DistributedResultSet();\r\n+\t\tfor (T s:this)\r\n+\t\t\trs.add(s.executeQuery(arg0));\r\n+\t\treturn rs;\r\n+\t}\r\n+\r\n+\tpublic int executeUpdate(String arg0) throws SQLException {\r\n+\t\tint ret = 0;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret += s.executeUpdate(arg0);\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic int executeUpdate(String arg0, int arg1) throws SQLException {\r\n+\t\tint ret = 0;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret += s.executeUpdate(arg0, arg1);\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic int executeUpdate(String arg0, int[] arg1) throws SQLException {\r\n+\t\tint ret = 0;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret += s.executeUpdate(arg0, arg1);\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic int executeUpdate(String arg0, String[] arg1) throws SQLException {\r\n+\t\tint ret = 0;\r\n+\t\tfor (T s:this)\r\n+\t\t\tret += s.executeUpdate(arg0, arg1);\r\n+\t\treturn ret;\r\n+\t}\r\n+\r\n+\tpublic Connection getConnection() throws SQLException {\r\n+\t\treturn con;\r\n+\t}\r\n+\r\n+\tpublic int getFetchDirection() throws SQLException {\r\n+\t\treturn master.getFetchDirection();\r\n+\t}\r\n+\r\n+\tpublic int getFetchSize() throws SQLException {\r\n+\t\treturn master.getFetchSize();\r\n+\t}\r\n+\r\n+\tpublic ResultSet getGeneratedKeys() throws SQLException {\r\n+\t\tDistributedResultSet mrs = new DistributedResultSet();\r\n+\t\tfor (T s:this)\r\n+\t\t\tmrs.add(s.getGeneratedKeys());\r\n+\t\treturn mrs;\r\n+\t}\r\n+\r\n+\tpublic int getMaxFieldSize() throws SQLException {\r\n+\t\treturn master.getMaxFieldSize();\r\n+\t}\r\n+\r\n+\tpublic int getMaxRows() throws SQLException {\r\n+\t\treturn master.getMaxRows();\r\n+\t}\r\n+\r\n+\tpublic boolean getMoreResults() throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\tif (s.getMoreResults())\r\n+\t\t\t\treturn true;\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic boolean getMoreResults(int arg0) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\tif (s.getMoreResults(arg0))\r\n+\t\t\t\treturn true;\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tpublic int getQueryTimeout() throws SQLException {\r\n+\t\treturn master.getQueryTimeout();\r\n+\t}\r\n+\r\n+\tpublic ResultSet getResultSet() throws SQLException {\r\n+\t\tDistributedResultSet rs = new DistributedResultSet();\r\n+\t\tfor (T s:this)\r\n+\t\t\trs.add(s.getResultSet());\r\n+\t\treturn rs;\r\n+\t}\r\n+\r\n+\tpublic int getResultSetConcurrency() throws SQLException {\r\n+\t\treturn master.getResultSetConcurrency();\r\n+\t}\r\n+\r\n+\tpublic int getResultSetHoldability() throws SQLException {\r\n+\t\treturn master.getResultSetHoldability();\r\n+\t}\r\n+\r\n+\tpublic int getResultSetType() throws SQLException {\r\n+\t\treturn master.getResultSetType();\r\n+\t}\r\n+\r\n+\tpublic int getUpdateCount() throws SQLException {\r\n+\t\treturn master.getUpdateCount();\r\n+\t}\r\n+\r\n+\tpublic SQLWarning getWarnings() throws SQLException {\r\n+\t\treturn master.getWarnings();\r\n+\t}\r\n+\r\n+\tpublic void setCursorName(String name) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setCursorName(name);\r\n+\t}\r\n+\r\n+\tpublic void setEscapeProcessing(boolean flag) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setEscapeProcessing(flag);\r\n+\t}\r\n+\r\n+\tpublic void setFetchDirection(int dir) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setFetchDirection(dir);\r\n+\t}\r\n+\r\n+\tpublic void setFetchSize(int size) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setFetchSize(size);\r\n+\t}\r\n+\r\n+\tpublic void setMaxFieldSize(int size) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setMaxFieldSize(size);\r\n+\t}\r\n+\r\n+\tpublic void setMaxRows(int n) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setMaxFieldSize(n);\r\n+\t}\r\n+\t\r\n+\tpublic void setQueryTimeout(int n) throws SQLException {\r\n+\t\tfor (T s:this)\r\n+\t\t\ts.setMaxFieldSize(n);\r\n+\t}\r\n+}\r"},{"sha":"02d4b54890b6e72b1ef9301446ef04665e1e8cb4","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/SliceStoreManager.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,113 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.SQLException;\r\n+\r\n+import javax.sql.DataSource;\r\n+import javax.sql.XAConnection;\r\n+import javax.sql.XADataSource;\r\n+\r\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\r\n+import org.apache.openjpa.lib.jdbc.DelegatingDataSource;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.slice.Slice;\r\n+import org.apache.openjpa.util.InternalException;\r\n+\r\n+/**\r\n+ * A specialized JDBCStoreManager for XA-complaint DataSource.\r\n+ * If the configured DataSource is not XA-complaint, behaves as the super \r\n+ * implementation.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class SliceStoreManager extends JDBCStoreManager {\r\n+\tprivate final Slice _slice;\r\n+\tprivate Boolean isXAEnabled;\r\n+\tprivate XAConnection xcon;\r\n+\t\r\n+\tprivate static final Localizer _loc = \r\n+\t\tLocalizer.forPackage(SliceStoreManager.class);\r\n+\t\r\n+\t/**\r\n+\t * Construct with immutable logical name of the slice. \r\n+\t */\r\n+\tpublic SliceStoreManager(Slice slice) {\r\n+\t\t_slice = slice;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Gets the slice for which this receiver is working.\r\n+\t */\r\n+\tpublic Slice getSlice() {\r\n+\t    return _slice;\r\n+\t}\r\n+\t\r\n+\tpublic String getName() {\r\n+\t    return _slice.getName();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Gets the connection via XAConnection if the datasource is XA-complaint.\r\n+\t * Otherwise, behaves exactly as the super implementation. \r\n+\t */\r\n+\t@Override\r\n+\tprotected RefCountConnection connectInternal() throws SQLException { \r\n+\t\tif (!isXAEnabled)\r\n+\t\t\treturn super.connectInternal();\r\n+\t\tXADataSource xds = getXADataSource();\r\n+\t\txcon = xds.getXAConnection();\r\n+\t\tConnection con = xcon.getConnection();\r\n+\t\treturn new RefCountConnection(con);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Gets the XAConnection if connected and XA-complaint. Otherwise null.\r\n+\t */\r\n+\tpublic XAConnection getXAConnection() {\r\n+\t\treturn xcon;\r\n+\t}\r\n+\t\r\n+\tprivate XADataSource getXADataSource() {\r\n+\t\tif (!isXAEnabled())\r\n+\t\t\tthrow new InternalException(_loc.get(\"slice-not-xa\", this));\r\n+\t\treturn (XADataSource)getInnerDataSource();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Affirms if the configured DataSource is XA-complaint.\r\n+\t * Can return null if the context has not been set yet.\r\n+\t */\r\n+\tpublic boolean isXAEnabled() {\r\n+\t\tif (isXAEnabled == null) {\r\n+\t\t\tisXAEnabled = getInnerDataSource() instanceof XADataSource;\r\n+\t\t}\r\n+\t\treturn isXAEnabled.booleanValue();\r\n+\t}\r\n+\t\r\n+\tprivate DataSource getInnerDataSource() {\r\n+\t\tDataSource parent = super.getDataSource();\r\n+\t\tDataSource real = (parent instanceof DelegatingDataSource) ?\r\n+\t\t\t\t((DelegatingDataSource)parent).getInnermostDelegate() \r\n+\t\t\t\t: parent;\r\n+\t\treturn real;\r\n+\t}\r\n+}\r"},{"sha":"3639867d8a40998877a3530f28d0096e0ee4a67c","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/UniqueResultObjectProvider.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,148 @@\n+package org.apache.openjpa.slice.jdbc;\r\n+\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\r\n+import org.apache.openjpa.kernel.exps.Value;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Aggregates individual single query results from different databases.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class UniqueResultObjectProvider implements ResultObjectProvider {\r\n+    private final ResultObjectProvider[] _rops;\r\n+    private final StoreQuery _query;\r\n+    private final QueryExpressions[] _exps;\r\n+    private Object _single;\r\n+    private boolean _opened;\r\n+    \r\n+    private static final String COUNT = \"Count\";\r\n+    private static final String MAX   = \"Max\";\r\n+    private static final String MIN   = \"Min\";\r\n+    private static final String SUM   = \"Sum\";\r\n+    \r\n+    private static final Localizer _loc =\r\n+        Localizer.forPackage(UniqueResultObjectProvider.class);\r\n+    \r\n+    public UniqueResultObjectProvider(ResultObjectProvider[] rops, \r\n+            StoreQuery q, QueryExpressions[] exps) {\r\n+        _rops = rops;\r\n+        _query = q;\r\n+        _exps = exps;\r\n+    }\r\n+    \r\n+    public boolean absolute(int pos) throws Exception {\r\n+        return false;\r\n+    }\r\n+\r\n+    public void close() throws Exception {\r\n+        _opened = false;\r\n+        for (ResultObjectProvider rop:_rops)\r\n+            rop.close();\r\n+    }\r\n+\r\n+    public Object getResultObject() throws Exception {\r\n+        if (!_opened)\r\n+            throw new InternalException(_loc.get(\"not-open\"));\r\n+        return _single;\r\n+    }\r\n+\r\n+    public void handleCheckedException(Exception e) {\r\n+        _rops[0].handleCheckedException(e);\r\n+    }\r\n+\r\n+    public boolean next() throws Exception {\r\n+        if (!_opened) {\r\n+            open();\r\n+        }\r\n+            \r\n+        if (_single != null)\r\n+            return false;\r\n+        \r\n+        Value[] values = _exps[0].projections;\r\n+        Object[] single = new Object[values.length]; \r\n+        for (int i=0; i<values.length; i++) {\r\n+            Value v = values[i];\r\n+            boolean isAggregate = v.isAggregate();\r\n+            String op = v.getClass().getSimpleName();\r\n+            for (ResultObjectProvider rop:_rops) {\r\n+                rop.next();\r\n+                Object[] row = (Object[]) rop.getResultObject();\r\n+                if (isAggregate) {\r\n+                    if (COUNT.equals(op)) {\r\n+                        single[i] = count(single[i], row[i]);\r\n+                    } else if (MAX.equals(op)) {\r\n+                        single[i] = max(single[i], row[i]);\r\n+                    } else if (MIN.equals(op)) {\r\n+                        single[i] = min(single[i], row[i]);\r\n+                    } else if (SUM.equals(op)) {\r\n+                        single[i] = sum(single[i], row[i]);\r\n+                    } else {\r\n+                        throw new UnsupportedOperationException\r\n+                            (_loc.get(\"aggregate-unsupported\", op).toString());\r\n+                    }\r\n+                } else {\r\n+                    single[i] = row[i];\r\n+                }\r\n+            }\r\n+        }\r\n+        _single = single;\r\n+        return true;\r\n+    }\r\n+    \r\n+    Object count(Object current, Object other) {\r\n+        if (current == null)\r\n+            return other;\r\n+        return ((Number)current).longValue() + ((Number)other).longValue();\r\n+    }\r\n+    \r\n+    Object max(Object current, Object other) {\r\n+        if (current == null)\r\n+            return other;\r\n+        \r\n+        return Math.max(((Number)current).doubleValue(), \r\n+                ((Number)other).doubleValue());\r\n+    }\r\n+    \r\n+    Object min(Object current, Object other) {\r\n+        if (current == null)\r\n+            return other;\r\n+        return Math.min(((Number)current).doubleValue(), \r\n+                ((Number)other).doubleValue());\r\n+    }\r\n+    \r\n+    Object sum(Object current, Object other) {\r\n+        if (current == null)\r\n+            return other;\r\n+        return (((Number)current).doubleValue() +\r\n+                ((Number)other).doubleValue());\r\n+    }\r\n+\r\n+\r\n+\r\n+    public void open() throws Exception {\r\n+        for (ResultObjectProvider rop:_rops)\r\n+            rop.open();\r\n+        _opened = true;\r\n+    }\r\n+\r\n+    public void reset() throws Exception {\r\n+        _single = null;\r\n+        for (ResultObjectProvider rop : _rops) {\r\n+            rop.reset();\r\n+        }\r\n+    }\r\n+\r\n+    public int size() throws Exception {\r\n+        return 1;\r\n+    }\r\n+\r\n+    public boolean supportsRandomAccess() {\r\n+         return false;\r\n+    }\r\n+}\r"},{"sha":"3d9efdf9fddb24cfa5f806018fae2b5e986e9b97","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/package.html","status":"added","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/package.html","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/package.html?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,11 @@\n+<HTML>\r\n+<BODY>\r\n+Implements Distributed version of JDBCStoreManager and JDBCStoreQuery. \r\n+\r\n+This package contains implementaions of OpenJPA interfaces using a distribution\r\n+template pattern. Distribution template pattern for <code>T</code> is \r\n+defined as a type <code>T'</code>\r\n+such that <code>T' extends T implements Iterable<T></code> i.e.<code>T'</code> \r\n+is a special <code>T</code> that also contains many <code>T</code>. \r\n+</BODY>\r\n+</HTML>\n\\ No newline at end of file"},{"sha":"3f0c2b674a0d8678737437ec04efb60b43cab502","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/package.html","status":"added","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/package.html","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/package.html?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,8 @@\n+<HTML>\r\n+<BODY>\r\n+Extended OpenJPA Interfaces for distributed databases.\r\n+\r\n+This package contains interface definitions for distribution policy and\r\n+distributed configuration.\r\n+</BODY>\r\n+</HTML>\n\\ No newline at end of file"},{"sha":"a02403d63cefb9de5299a55ccd281f629fa13d0a","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedNaiveTransaction.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedNaiveTransaction.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedNaiveTransaction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedNaiveTransaction.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,75 @@\n+package org.apache.openjpa.slice.transaction;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+\r\n+import javax.transaction.HeuristicMixedException;\r\n+import javax.transaction.HeuristicRollbackException;\r\n+import javax.transaction.RollbackException;\r\n+import javax.transaction.Synchronization;\r\n+import javax.transaction.SystemException;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+import javax.transaction.xa.XAResource;\r\n+\r\n+import org.apache.openjpa.slice.jdbc.SliceStoreManager;\r\n+\r\n+public class DistributedNaiveTransaction implements Transaction {\r\n+    private Set<SliceStoreManager> _slices = new HashSet<SliceStoreManager>();\r\n+    private Set<Synchronization> _syncs = new HashSet<Synchronization>();\r\n+    private final TransactionManager _tm;\r\n+    private int _status;\r\n+    private boolean _rollbackOnly;\r\n+\r\n+    DistributedNaiveTransaction(TransactionManager tm) {\r\n+        _tm = tm;\r\n+    }\r\n+\r\n+    public void commit() throws HeuristicMixedException,\r\n+            HeuristicRollbackException, RollbackException, SecurityException,\r\n+            SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean delistResource(XAResource arg0, int arg1)\r\n+            throws IllegalStateException, SystemException {\r\n+        return _slices.remove(arg0);\r\n+    }\r\n+\r\n+    public boolean enlistResource(XAResource arg0)\r\n+            throws IllegalStateException, RollbackException, SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean enlistResource(SliceStoreManager arg0)\r\n+            throws IllegalStateException, RollbackException, SystemException {\r\n+        return _slices.add(arg0);\r\n+    }\r\n+\r\n+    public int getStatus() throws SystemException {\r\n+        return _status;\r\n+    }\r\n+\r\n+    public void registerSynchronization(Synchronization arg0)\r\n+            throws IllegalStateException, RollbackException, SystemException {\r\n+        _syncs.add(arg0);\r\n+    }\r\n+\r\n+    public void rollback() throws IllegalStateException, SystemException {\r\n+        _tm.rollback();\r\n+    }\r\n+\r\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\r\n+        _rollbackOnly = true;\r\n+    }\r\n+    \r\n+    public boolean isRollbackOnly() {\r\n+        return _rollbackOnly;\r\n+    }\r\n+\r\n+    Set<SliceStoreManager> getEnlistedResources() {\r\n+        return Collections.unmodifiableSet(_slices);\r\n+    }\r\n+\r\n+}\r"},{"sha":"eb2c668209dc359929811e3631acc040eb0daec4","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedTransactionManager.java","status":"added","additions":191,"deletions":0,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedTransactionManager.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedTransactionManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedTransactionManager.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,191 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.transaction;\r\n+\r\n+import static javax.transaction.xa.XAResource.TMJOIN;\r\n+import static javax.transaction.xa.XAResource.TMNOFLAGS;\r\n+import static javax.transaction.xa.XAResource.TMSUCCESS;\r\n+\r\n+import java.util.Set;\r\n+\r\n+import javax.transaction.HeuristicMixedException;\r\n+import javax.transaction.HeuristicRollbackException;\r\n+import javax.transaction.InvalidTransactionException;\r\n+import javax.transaction.NotSupportedException;\r\n+import javax.transaction.RollbackException;\r\n+import javax.transaction.SystemException;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+import javax.transaction.xa.XAException;\r\n+import javax.transaction.xa.XAResource;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+\r\n+/**\r\n+ * A simple (naive?) implementation for distributed transaction across \r\n+ * XA-complaint data sources. \r\n+ * Assumes begin() and commit() being called on the same thread.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+public class DistributedTransactionManager implements TransactionManager {\r\n+    private final ThreadLocal<DistributedXATransaction> txns =\r\n+            new ThreadLocal<DistributedXATransaction>();\r\n+    private static final Localizer _loc =\r\n+            Localizer.forPackage(DistributedTransactionManager.class);\r\n+\r\n+    public void begin() throws NotSupportedException, SystemException {\r\n+        DistributedXATransaction txn = getTransaction(false);\r\n+        int i = 1;\r\n+        Set<XAResource> resources = txn.getEnlistedResources();\r\n+        for (XAResource resource : resources) {\r\n+            try {\r\n+                XAResource existing = isSame(resource, resources);\r\n+                XID branch = txn.getXID().branch(i++);\r\n+                int flag = (existing == null) ? TMNOFLAGS : TMJOIN;\r\n+                resource.start(branch, flag);\r\n+            } catch (Exception e) {\r\n+                throw new SystemException(e.toString());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void commit() throws HeuristicMixedException,\r\n+            HeuristicRollbackException, IllegalStateException,\r\n+            RollbackException, SecurityException, SystemException {\r\n+        DistributedXATransaction txn = getTransaction(true);\r\n+        Set<XAResource> resources = txn.getEnlistedResources();\r\n+        int branchId = 1;\r\n+        boolean nextPhase = true;\r\n+        for (XAResource resource : resources) {\r\n+            XID branch = txn.getXID().branch(branchId++);\r\n+            try {\r\n+                resource.end(branch, TMSUCCESS);\r\n+                resource.prepare(branch);\r\n+            } catch (XAException e) {\r\n+                nextPhase = false;\r\n+            }\r\n+        }\r\n+\r\n+        branchId = 1; // reset\r\n+        if (!nextPhase) {\r\n+            for (XAResource resource : resources) {\r\n+                try {\r\n+                    XID branch = txn.getXID().branch(branchId++);\r\n+                    resource.forget(branch);\r\n+                } catch (XAException e) {\r\n+                    // ignore\r\n+                }\r\n+                throw new SystemException(_loc.get(\"prepare-failed\")\r\n+                        .getMessage());\r\n+            }\r\n+        }\r\n+\r\n+        branchId = 1; // reset\r\n+        for (XAResource resource : resources) {\r\n+            XID branch = txn.getXID().branch(branchId++);\r\n+            try {\r\n+                resource.commit(branch, false);\r\n+            } catch (XAException e) {\r\n+                throw new SystemException(e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public int getStatus() throws SystemException {\r\n+        return getTransaction().getStatus();\r\n+    }\r\n+\r\n+    public Transaction getTransaction() throws SystemException {\r\n+        return getTransaction(false);\r\n+    }\r\n+\r\n+    public void resume(Transaction arg0) throws IllegalStateException,\r\n+            InvalidTransactionException, SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void rollback() throws IllegalStateException, SecurityException,\r\n+            SystemException {\r\n+        DistributedXATransaction txn = getTransaction(true);\r\n+        Set<XAResource> slices = txn.getEnlistedResources();\r\n+        int branchId = 1;\r\n+        for (XAResource slice : slices) {\r\n+            XID branch = txn.getXID().branch(branchId++);\r\n+            try {\r\n+                slice.end(branch, XAResource.TMFAIL);\r\n+                slice.rollback(branch);\r\n+            } catch (XAException e) {\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\r\n+        getTransaction().setRollbackOnly();\r\n+    }\r\n+\r\n+    public void setTransactionTimeout(int arg0) throws SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Transaction suspend() throws SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    XAResource isSame(XAResource rm, Set<XAResource> others) {\r\n+        for (XAResource other : others)\r\n+            try {\r\n+                if (rm != other && other.isSameRM(rm))\r\n+                    return other;\r\n+            } catch (XAException e) {\r\n+                e.printStackTrace();\r\n+            }\r\n+        return null;\r\n+    }\r\n+\r\n+    String toString(Object o) {\r\n+        return o.getClass().getSimpleName() + \"@\"\r\n+                + Long.toHexString(System.identityHashCode(o));\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the transaction associated with the current thread. \r\n+     * \r\n+     * @param mustExist if true, a transaction must be associated with the \r\n+     * current thread a priori. If false, the current thread has no associated\r\n+     * transaction, a new transaction is created with a global identifier \r\n+     * and associated with the current thread.\r\n+     */\r\n+    DistributedXATransaction getTransaction(boolean mustExist) {\r\n+        DistributedXATransaction txn = txns.get();\r\n+        if (txn == null) {\r\n+            if (mustExist)\r\n+                throw new IllegalStateException(_loc.get(\"no-txn-on-thread\",\r\n+                        Thread.currentThread().getName()).getMessage());\r\n+            byte[] global =\r\n+                    Long.toHexString(System.currentTimeMillis()).getBytes();\r\n+            XID xid = new XID(0, global, new byte[] { 0x1 });\r\n+            txn = new DistributedXATransaction(xid, this);\r\n+            txns.set(txn);\r\n+        }\r\n+        return txn;\r\n+    }\r\n+\r\n+}\r"},{"sha":"f5db827d5e0bd32ee376e463086b208330ae63aa","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedXATransaction.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedXATransaction.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedXATransaction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/DistributedXATransaction.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,82 @@\n+package org.apache.openjpa.slice.transaction;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+\r\n+import javax.transaction.HeuristicMixedException;\r\n+import javax.transaction.HeuristicRollbackException;\r\n+import javax.transaction.RollbackException;\r\n+import javax.transaction.Synchronization;\r\n+import javax.transaction.SystemException;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+import javax.transaction.xa.XAResource;\r\n+\r\n+/**\r\n+ * Internal implementation of a Transaction with an internal global transaction\r\n+ * identifier scheme.\r\n+ * \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+class DistributedXATransaction implements Transaction {\r\n+    private static ThreadLocal<Transaction> _trans = new ThreadLocal<Transaction>();\r\n+    private Set<XAResource> _slices = new HashSet<XAResource>();\r\n+    private Set<Synchronization> _syncs = new HashSet<Synchronization>();\r\n+    private final TransactionManager _tm;\r\n+    private final XID xid;\r\n+    private int _status;\r\n+    private boolean _rollbackOnly;\r\n+    \r\n+    /**\r\n+     * Construct with \r\n+     * @param xid\r\n+     * @param tm\r\n+     */\r\n+    DistributedXATransaction(XID xid, TransactionManager tm) {\r\n+        this.xid = xid;\r\n+        this._tm = tm;\r\n+    }\r\n+    \r\n+    public XID getXID() {\r\n+        return xid;\r\n+    }\r\n+    \r\n+    public void commit() throws HeuristicMixedException,\r\n+            HeuristicRollbackException, RollbackException, SecurityException,\r\n+            SystemException {\r\n+        _tm.commit();\r\n+    }\r\n+\r\n+    public boolean delistResource(XAResource arg0, int arg1)\r\n+            throws IllegalStateException, SystemException {\r\n+        return _slices.remove(arg0);\r\n+    }\r\n+\r\n+    public boolean enlistResource(XAResource arg0)\r\n+            throws IllegalStateException, RollbackException, SystemException {\r\n+        return _slices.add(arg0);\r\n+    }\r\n+\r\n+    public int getStatus() throws SystemException {\r\n+        return _status;\r\n+    }\r\n+\r\n+    public void registerSynchronization(Synchronization arg0)\r\n+            throws IllegalStateException, RollbackException, SystemException {\r\n+        _syncs.add(arg0);\r\n+    }\r\n+\r\n+    public void rollback() throws IllegalStateException, SystemException {\r\n+        _tm.rollback();\r\n+    }\r\n+\r\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\r\n+        _rollbackOnly = true;\r\n+    }\r\n+    \r\n+    Set<XAResource> getEnlistedResources() {\r\n+        return Collections.unmodifiableSet(_slices);\r\n+    }\r\n+}\r"},{"sha":"507bfb9891ab1882e6e4ca95636f0a86b292dd13","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/NaiveTransactionManager.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/NaiveTransactionManager.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/NaiveTransactionManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/NaiveTransactionManager.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,96 @@\n+package org.apache.openjpa.slice.transaction;\r\n+\r\n+import java.util.Set;\r\n+\r\n+import javax.transaction.HeuristicMixedException;\r\n+import javax.transaction.HeuristicRollbackException;\r\n+import javax.transaction.InvalidTransactionException;\r\n+import javax.transaction.NotSupportedException;\r\n+import javax.transaction.RollbackException;\r\n+import javax.transaction.SystemException;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.slice.jdbc.SliceStoreManager;\r\n+\r\n+/**\r\n+ * A fake transaction manager which runs a serial commit or rollback across\r\n+ * the enlisted non-XA resources without any two-phase commit protocol. \r\n+ *  \r\n+ * @author Pinaki Poddar \r\n+ *\r\n+ */\r\n+public class NaiveTransactionManager implements TransactionManager {\r\n+    private final ThreadLocal<DistributedNaiveTransaction> _txns = \r\n+        new ThreadLocal<DistributedNaiveTransaction>();\r\n+    private static final Localizer _loc = \r\n+        Localizer.forPackage(NaiveTransactionManager.class);\r\n+\r\n+    public void begin() throws NotSupportedException, SystemException {\r\n+        DistributedNaiveTransaction txn = getTransaction(false);\r\n+        Set<SliceStoreManager> slices = txn.getEnlistedResources();\r\n+        for (SliceStoreManager slice : slices) {\r\n+            slice.getConnection();\r\n+            slice.begin();\r\n+        }\r\n+    }\r\n+\r\n+    public void commit() throws HeuristicMixedException,\r\n+            HeuristicRollbackException, IllegalStateException,\r\n+            RollbackException, SecurityException, SystemException {\r\n+        DistributedNaiveTransaction txn = getTransaction(false);\r\n+        Set<SliceStoreManager> slices = txn.getEnlistedResources();\r\n+        for (SliceStoreManager slice : slices) {\r\n+            slice.commit();\r\n+        }\r\n+    }\r\n+\r\n+    public int getStatus() throws SystemException {\r\n+        return getTransaction().getStatus();\r\n+    }\r\n+\r\n+    public Transaction getTransaction() throws SystemException {\r\n+        return getTransaction(false);\r\n+    }\r\n+\r\n+    public void resume(Transaction arg0) throws IllegalStateException,\r\n+            InvalidTransactionException, SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void rollback() throws IllegalStateException, SecurityException,\r\n+            SystemException {\r\n+        DistributedNaiveTransaction txn = getTransaction(false);\r\n+        Set<SliceStoreManager> slices = txn.getEnlistedResources();\r\n+        for (SliceStoreManager slice : slices) {\r\n+            slice.commit();\r\n+        }\r\n+    }\r\n+\r\n+    public void setRollbackOnly() throws IllegalStateException, SystemException {\r\n+        getTransaction().setRollbackOnly();\r\n+    }\r\n+\r\n+    public void setTransactionTimeout(int arg0) throws SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Transaction suspend() throws SystemException {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+    \r\n+    DistributedNaiveTransaction getTransaction(boolean mustExist) {\r\n+        DistributedNaiveTransaction txn = _txns.get();\r\n+        if (txn == null) {\r\n+            if (mustExist)\r\n+                throw new IllegalStateException(_loc.get(\"no-txn-on-thread\",\r\n+                        Thread.currentThread().getName()).getMessage());\r\n+            txn = new DistributedNaiveTransaction(this);\r\n+            _txns.set(txn);\r\n+        }\r\n+        return txn;\r\n+    }\r\n+\r\n+\r\n+}\r"},{"sha":"cf272c2622bde4498669b51ae3e785b01e1fb2d0","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/XID.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/XID.java","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/XID.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/XID.java?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,83 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.slice.transaction;\r\n+\r\n+import javax.transaction.xa.Xid;\r\n+\r\n+/**\r\n+ * Internally used Global Transaction Identifier for two-phase distributed\r\n+ * commit protocol.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+class XID implements Xid {\r\n+    private final int format;\r\n+    private final byte[] global;\r\n+    private final byte[] branch;\r\n+\r\n+    public XID(int format, byte[] global, byte[] branch) {\r\n+        super();\r\n+        this.format = format;\r\n+        this.global = global;\r\n+        this.branch = branch;\r\n+    }\r\n+\r\n+    public byte[] getBranchQualifier() {\r\n+        return branch;\r\n+    }\r\n+\r\n+    public int getFormatId() {\r\n+        return format;\r\n+    }\r\n+\r\n+    public byte[] getGlobalTransactionId() {\r\n+        return global;\r\n+    }\r\n+\r\n+    XID branch(Number number) {\r\n+        return branch((number == null) ? \"null\" : number.toString());\r\n+    }\r\n+    \r\n+    XID branch(String branch) {\r\n+        return new XID(format, global, branch.getBytes());\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return new String(global) + \":\" + new String(branch);\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other instanceof XID) {\r\n+            XID that = (XID) other;\r\n+            return format == that.format && equals(global, that.global)\r\n+                    && equals(branch, that.branch);\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    boolean equals(byte[] a, byte[] b) {\r\n+        if (a == null && b == null)\r\n+            return true;\r\n+        if (a == null || b == null)\r\n+            return false;\r\n+        return new String(a).equals(new String(b));\r\n+    }\r\n+\r\n+}\r"},{"sha":"e94f2780f983170d43aa20da213499008dfa6b20","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/package.html","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/package.html","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/transaction/package.html?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,10 @@\n+<HTML>\r\n+<BODY>\r\n+Implements TransactionManager to manage transactions across the database\r\n+slices. This package provides two flavors of TransactionManager: one provides\r\n+two-phase commit protocol when all underlying database slices is XA-complaint;\r\n+while the other runs commit/rollback simply looping across all database slices\r\n+when one or more underlying database slices is not XA-complaint and hence does \r\n+not guarantee atomic nature of transaction.  \r\n+</BODY>\r\n+</HTML> \n\\ No newline at end of file"},{"sha":"d380f743bc1107bb0fe88f39d40228808d971d80","filename":"openjpa-slice/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","status":"added","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,18 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\r\n+# or more contributor license agreements.  See the NOTICE file\r\n+# distributed with this work for additional information\r\n+# regarding copyright ownership.  The ASF licenses this file\r\n+# to you under the Apache License, Version 2.0 (the\r\n+# \"License\"); you may not use this file except in compliance\r\n+# with the License.  You may obtain a copy of the License at\r\n+#\r\n+# http://www.apache.org/licenses/LICENSE-2.0\r\n+#\r\n+# Unless required by applicable law or agreed to in writing,\r\n+# software distributed under the License is distributed on an\r\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+# KIND, either express or implied.  See the License for the\r\n+# specific language governing permissions and limitations\r\n+# under the License.\r\n+\r\n+org.apache.openjpa.slice.ProductDerivation\n\\ No newline at end of file"},{"sha":"38241d52f3898cdd2edbf97101cf9d39569049d9","filename":"openjpa-slice/src/main/resources/org/apache/openjpa/slice/jdbc/localizer.properties","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/jdbc/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/jdbc/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/resources/org/apache/openjpa/slice/jdbc/localizer.properties?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,49 @@\n+slice-not-found: No slice named \"{0}\" can be found. Available slices are \"{1}\"\r\n+slice-no-url: Slice \"{0}\" has no database URL. Specify a valid database URL \\\r\n+\tas the value of \"slice.{0}.ConnectionURL\" property. ConnectionURL is the \\\r\n+\tonly mandatory property of a slice. If any other slice property \\\r\n+\tis not specified, then the corresponding openjpa.* property value is used \\\r\n+\tas default.\r\n+slice-none-configured: No slice has been configured. Specify slice.XYZ as \\\r\n+\tproperty name to register a slice named XYZ.\r\n+slice-configuration: Slice \"{0}\" configured with \"{1}\"\r\n+slice-available: Detected slices \"{0}\" in configuration.\r\n+no-url: No ConnectionURL property has been specified.\r\n+wrong-url: URL \"{0}\" is invalid as database URL.\r\n+wrong-slice: Wrong slice \"{0}\" for \"{1}\"\r\n+slice-connect: Connecting to slice \"{0}\" at URL \"{1}\"\r\n+slice-connect-warn: Failed to connect to slice \"{0}\". Slice \"{0}\" will be \\\r\n+\tignored as configuration is set as lenient.\r\n+slice-connect-known-warn: Failed to connect to due to \"{2}. \\\r\n+\tSlice \"{0}\" will be ignored as configuration is set as lenient.\r\n+slice-connect-error: Failed to connect to URL \"{1}\"\r\n+slice-connect-known-error: Failed to connect to URL \"{1} due to {2}\r\n+bad-policy-slice:Distribution policy \"{0}\" has returned invalid slice \\\r\n+\t\"{1}\" for \"{2}\". The valid slices are {3}. This error may happen \\\r\n+\twhen one or more of the originally configured slices are unavailable \\\r\n+\tand Lenient property is set to true.\r\n+slice-xa-enabled: All slices \"{0}\" is XA-complaint and hence store transaction \\\r\n+\twill use a two-phase commit protocol even if the persistent unit is \\\r\n+\tconfigured for non-JTA transaction.\r\n+slice-xa-disabled: Not all active slices \"{0}\" is XA-complaint and hence store \\\r\n+\ttransaction will not use a two-phase commit protocol. If persistent unit \\\r\n+\tis configured for JTA transaction then the slices will participate in \\\r\n+\tglobal transaction but otherwise the atomic nature of commit across all \\\r\n+\tslices is not guaranteed.  \r\n+two-phase: \"{3}\".{0}\"(xid=[{4}]] Connection={1} XAConnection={2} \r\n+factory-init: Starting {0}\r\n+config-init: Configuring Slice {0}\r\n+no-slice-names: Slice identifiers are not listed in [slice.Names] property. \\\r\n+\tThe configuration will be scanned to determine slice identifiers.\r\n+no-master-slice: No master slice has been configured explicitly in \\\r\n+\t[slice.Master] property. The first slice \"{0}\" in the list of configured \\\r\n+\tslices will be used as master. \r\n+resource-xa-tm-not-2pc: All slices is using XA-complaint driver but the \\\r\n+\tconfigured \"{0}\" transaction manager is not capable of enlisting XA-aware \\\r\n+\tresources. See slice.TransactionManager property documentation to  \\\r\n+\tconfigure XA-aware Transaction Manager capable for two-phase commit.\r\n+resource-not-xa-tm-2pc: One or more slices is not using XA-complaint driver \\\r\n+\tbut the configured \"{0}\" transaction manager can only enlist XA-aware \\\r\n+\tresource. \r\n+not-open: The underlying result sets are not open.\r\n+aggregate-unsupported: The query uses unsupported aggregate operation \"{0}\".  \r"},{"sha":"0fb8ca855a68bac5a0196bdb8b77c1e568fcd0fc","filename":"openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","status":"added","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/resources/org/apache/openjpa/slice/localizer.properties?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,4 @@\n+bad-policy-slice:Distribution policy \"{0}\" has returned invalid slice \\\r\n+\t\"{1}\" for \"{2}\". The valid slices are {3}. This error may happen \\\r\n+\twhen one or more of the originally configured slices are unavailable \\\r\n+\tand Lenient property is set to true.\n\\ No newline at end of file"},{"sha":"c5e215f1d9f371ac7cea0787df6ff8b3f5f08b71","filename":"openjpa-slice/src/main/resources/org/apache/openjpa/slice/transaction/localizer.properties","status":"added","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/transaction/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/openjpa-slice/src/main/resources/org/apache/openjpa/slice/transaction/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/resources/org/apache/openjpa/slice/transaction/localizer.properties?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -0,0 +1,3 @@\n+no-txn-on-thread: No transaction is associated with current thread \"{0}\"\r\n+prepare-failed: one or more XA-complaint resources have failed to prepare for \\\r\n+\tcommit during the first phase of a two-phase commit protocol.\n\\ No newline at end of file"},{"sha":"44f44c42e7db4b3df69a27dbf660332c9ba1692d","filename":"pom.xml","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/12839b6bd9090eb84d1944584c9ea73aaa8b44fa/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=12839b6bd9090eb84d1944584c9ea73aaa8b44fa","patch":"@@ -84,7 +84,8 @@\n         <module>openjpa-lib</module>\n         <module>openjpa-kernel</module>\n         <module>openjpa-jdbc</module>\n-        <module>openjpa-xmlstore</module>\n+        <module>openjpa-xmlstore</module>\r\n+        <module>openjpa-slice</module>\r\n         <module>openjpa-all</module>\n         <module>openjpa-project</module>\n         <module>openjpa-integration</module>\n@@ -100,7 +101,8 @@\n                 <module>openjpa-persistence</module>\n                 <module>openjpa-persistence-jdbc</module>\n                 <module>openjpa-kernel-5</module>\n-                <module>openjpa-jdbc-5</module>\n+                <module>openjpa-jdbc-5</module>\r\n+                <module>openjpa-slice</module>\r\n                 <module>openjpa-examples</module>\n             </modules>\n         </profile>"}]}

