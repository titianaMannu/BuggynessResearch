{"sha":"15b0b59f25f755a96a6fdebf9d94a61e208ecbde","node_id":"MDY6Q29tbWl0MjA2MzY0OjE1YjBiNTlmMjVmNzU1YTk2YTZmZGViZjlkOTRhNjFlMjA4ZWNiZGU=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-05-11T16:12:07Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2007-05-11T16:12:07Z"},"message":"OPENJPA-230. Updated patch based on an out-of-band patch from Vishal. This version avoids interrupts while still handling guaranteed delivery of messages in the queue.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@537221 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b63288733de82ddbaf8fda4e275ead2423fbb6c1","url":"https://api.github.com/repos/apache/openjpa/git/trees/b63288733de82ddbaf8fda4e275ead2423fbb6c1"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/15b0b59f25f755a96a6fdebf9d94a61e208ecbde","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/15b0b59f25f755a96a6fdebf9d94a61e208ecbde","html_url":"https://github.com/apache/openjpa/commit/15b0b59f25f755a96a6fdebf9d94a61e208ecbde","comments_url":"https://api.github.com/repos/apache/openjpa/commits/15b0b59f25f755a96a6fdebf9d94a61e208ecbde/comments","author":null,"committer":null,"parents":[{"sha":"9eaec94118049ad189d237519d9dc366a4a7733c","url":"https://api.github.com/repos/apache/openjpa/commits/9eaec94118049ad189d237519d9dc366a4a7733c","html_url":"https://github.com/apache/openjpa/commit/9eaec94118049ad189d237519d9dc366a4a7733c"}],"stats":{"total":96,"additions":63,"deletions":33},"files":[{"sha":"c94b7eaa2550b87f3f3e39ee5157fc48a4289c86","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":63,"deletions":33,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/15b0b59f25f755a96a6fdebf9d94a61e208ecbde/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/15b0b59f25f755a96a6fdebf9d94a61e208ecbde/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=15b0b59f25f755a96a6fdebf9d94a61e208ecbde","patch":"@@ -25,7 +25,6 @@\n import java.io.InputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.OptionalDataException;\n import java.io.OutputStream;\n import java.net.InetAddress;\n import java.net.ServerSocket;\n@@ -40,6 +39,8 @@\n import java.util.LinkedList;\n import java.util.Map;\n import java.util.Set;\n+import java.util.List;\n+import java.util.Collections;\n \n import org.apache.commons.pool.PoolableObjectFactory;\n import org.apache.commons.pool.impl.GenericObjectPool;\n@@ -50,6 +51,7 @@\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.Serialization;\n import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n+import org.apache.openjpa.lib.util.concurrent.Concurrent;\n \n import serp.util.Strings;\n \n@@ -68,14 +70,14 @@\n \n     private static final int DEFAULT_PORT = 5636;\n \n-    private static Localizer s_loc = Localizer.forPackage\n+    private static final Localizer s_loc = Localizer.forPackage\n         (TCPRemoteCommitProvider.class);\n     private static long s_idSequence = System.currentTimeMillis();\n \n     //\tA map of listen ports to listeners in this JVM. We might\n     //\twant to look into allowing same port, different interface --\n     //\tthat is not currently possible in a single JVM.\n-    private static Map s_portListenerMap = new HashMap();\n+    private static final Map s_portListenerMap = new HashMap();\n \n     private long _id;\n     private byte[] _localhost;\n@@ -85,7 +87,8 @@\n     private int _recoveryTimeMillis = 15000;\n     private TCPPortListener _listener;\n     private BroadcastQueue _broadcastQueue = new BroadcastQueue();\n-    private LinkedList _broadcastThreads = new LinkedList();\n+    private final List _broadcastThreads = Collections.synchronizedList(\n+        new LinkedList());\n \n     private ArrayList _addresses = new ArrayList();\n     private ReentrantLock _addressesLock;\n@@ -177,7 +180,7 @@ public void setNumBroadcastThreads(int numBroadcastThreads) {\n                 // Threads will not end until they send another pk.\n                 for (int i = numBroadcastThreads; i < cur; i++) {\n                     BroadcastWorkerThread worker = (BroadcastWorkerThread)\n-                        _broadcastThreads.removeFirst();\n+                        _broadcastThreads.remove(0);\n                     worker.setRunning(false);\n                 }\n             } else if (cur < numBroadcastThreads) {\n@@ -186,7 +189,7 @@ public void setNumBroadcastThreads(int numBroadcastThreads) {\n                     BroadcastWorkerThread wt = new BroadcastWorkerThread();\n                     wt.setDaemon(true);\n                     wt.start();\n-                    _broadcastThreads.addLast(wt);\n+                    _broadcastThreads.add(wt);\n                 }\n             }\n         }\n@@ -364,23 +367,25 @@ public void close() {\n         if (_listener != null)\n             _listener.removeProvider(this);\n \n+        // Remove Broadcast Threads then close sockets.\n+        _broadcastQueue.close();\n+\n+        // Wait for _broadcastThreads to get cleaned up.\n+        while(!_broadcastThreads.isEmpty()) {\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException ie) {\n+                // Ignore.\n+            }\n+        }\n+        \n         _addressesLock.lock();\n         try {\n             for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n                 ((HostAddress) iter.next()).close();\n         } finally {\n             _addressesLock.unlock();\n         }\n-\n-        // We are done transmitting. Interrupt any worker threads.\n-        synchronized (_broadcastThreads) {\n-            Thread worker;\n-            for (Iterator iter = _broadcastThreads.iterator();\n-                iter.hasNext();) {\n-                worker = (Thread) iter.next();\n-                worker.interrupt();\n-            }\n-        }\n     }\n \n     /**\n@@ -390,18 +395,38 @@ public void close() {\n      */\n     private static class BroadcastQueue {\n \n-        LinkedList _packetQueue = new LinkedList();\n+        private LinkedList _packetQueue = new LinkedList();\n+        private boolean _closed = false;\n+\n+        public synchronized void close() {\n+            _closed = true;\n+            notifyAll();\n+        }\n+\n+        public synchronized boolean isClosed() {\n+            return _closed;\n+        }\n \n         public synchronized void addPacket(byte[] bytes) {\n             _packetQueue.addLast(bytes);\n             notify();\n         }\n \n+        /**\n+         * @return the bytes defining the packet to process, or\n+         * <code>null</code> if the queue is empty.\n+         */\n         public synchronized byte[] removePacket()\n             throws InterruptedException {\n-            while (_packetQueue.isEmpty())\n+            // only wait if the queue is still open. This allows processing\n+            // of events in the queue to continue, while avoiding sleeping\n+            // during shutdown.\n+            while (!_closed && _packetQueue.isEmpty())\n                 wait();\n-            return (byte[]) _packetQueue.removeFirst();\n+            if (_packetQueue.isEmpty())\n+                return null;\n+            else\n+                return (byte[]) _packetQueue.removeFirst();\n         }\n     }\n \n@@ -416,19 +441,28 @@ public synchronized void addPacket(byte[] bytes) {\n         public void run() {\n             while (_keepRunning) {\n                 try {\n-                    // This will block until there is a packet to send.\n+                    // This will block until there is a packet to send, or\n+                    // until the queue is closed.\n                     byte[] bytes = _broadcastQueue.removePacket();\n-                    sendUpdatePacket(bytes);\n+                    if (bytes != null)\n+                        sendUpdatePacket(bytes);\n+                    else if (_broadcastQueue.isClosed())\n+                        _keepRunning = false;\n                 } catch (InterruptedException e) {\n                     // End the thread.\n                     break;\n                 }\n             }\n+            remove();\n         }\n \n         public void setRunning(boolean keepRunning) {\n             _keepRunning = keepRunning;\n         }\n+        \n+        private void remove() {\n+            _broadcastThreads.remove(this);\n+        }\n     }\n \n     /**\n@@ -437,14 +471,11 @@ public void setRunning(boolean keepRunning) {\n     private static class TCPPortListener\n         implements Runnable {\n \n-        private static Localizer s_loc = Localizer.forPackage\n-            (TCPPortListener.class);\n-\n         private final Log _log;\n         private ServerSocket _receiveSocket;\n         private Thread _acceptThread;\n         private Set _receiverThreads = new HashSet();\n-        private Set _providers = new HashSet();\n+        private final Set _providers = new HashSet();\n \n         /**\n          * Cache the local IP address\n@@ -466,7 +497,7 @@ public void setRunning(boolean keepRunning) {\n          * Construct a new TCPPortListener configured to use the specified port.\n          */\n         private TCPPortListener(int port, Log log)\n-            throws UnknownHostException, IOException {\n+            throws IOException {\n             _port = port;\n             _log = log;\n             _receiveSocket = new ServerSocket(_port);\n@@ -637,19 +668,19 @@ public void run() {\n                                     + \":\" + _s.getPort()));\n                         }\n                         break;\n-                    } catch (Exception e) {\n+                    } catch (Throwable e) {\n                         if (_log.isWarnEnabled())\n                             _log.warn(s_loc.get(\"tcp-receive-error\"), e);\n                         break;\n-                    } catch (Throwable t) {\n                     }\n                 }\n                 // We are done receiving on this socket and this worker\n                 // thread is terminating.\n                 try {\n                     _in.close();\n-                    _s.close();\n-                } catch (Exception e) {\n+                    if (_s != null)\n+                        _s.close();\n+                } catch (IOException e) {\n                     _log.warn(s_loc.get(\"tcp-close-socket-error\",\n                         _s.getInetAddress().getHostAddress() + \":\"\n                             + _s.getPort()), e);\n@@ -658,11 +689,10 @@ public void run() {\n \n             /**\n              * Process an {@link InputStream} containing objects written\n-             * by {@link TCPRemoteCommitProvider#broadcastCommitInfo}.\n+             * by {@link TCPRemoteCommitProvider#broadcast(RemoteCommitEvent)}.\n              */\n             private void handle(InputStream in)\n-                throws IOException, ClassNotFoundException,\n-                OptionalDataException {\n+                throws IOException, ClassNotFoundException {\n                 // This will block waiting for the next\n                 ObjectInputStream ois = \n                     new Serialization.ClassResolvingObjectInputStream(in);"}]}

