{"sha":"163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","node_id":"MDY6Q29tbWl0MjA2MzY0OjE2M2NjMmEyMmM5NjYyZmU3OWRkOGVlYWNjMGZkOWZiMTk3YTY1NjU=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-30T03:43:16Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-30T03:43:16Z"},"message":"Framework for allowing ranges in query strings to be specified as parameters\n(not needed for JPQL, but for others).  Also consolidated some internal query\nframework APIs.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@438338 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"67c2c249edc0a5c2cb4e6a52858ed6de2925f635","url":"https://api.github.com/repos/apache/openjpa/git/trees/67c2c249edc0a5c2cb4e6a52858ed6de2925f635"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","html_url":"https://github.com/apache/openjpa/commit/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","comments_url":"https://api.github.com/repos/apache/openjpa/commits/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/comments","author":null,"committer":null,"parents":[{"sha":"47ead9315d338cb0dfd8e79c2fc6cdbe8a3608e0","url":"https://api.github.com/repos/apache/openjpa/commits/47ead9315d338cb0dfd8e79c2fc6cdbe8a3608e0","html_url":"https://github.com/apache/openjpa/commit/47ead9315d338cb0dfd8e79c2fc6cdbe8a3608e0"}],"stats":{"total":781,"additions":348,"deletions":433},"files":[{"sha":"31ec30b58ac24884f6eb9829fd79596ccb7a953c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":23,"deletions":30,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -130,10 +130,10 @@ protected ExpressionFactory getExpressionFactory(ClassMetaData meta) {\n     protected ResultObjectProvider executeQuery(Executor ex,\n         ClassMetaData base, ClassMetaData[] metas, boolean subclasses,\n         ExpressionFactory[] facts, QueryExpressions[] exps, Object[] params,\n-        boolean lrs, long startIdx, long endIdx) {\n+        Range range) {\n         if (metas.length > 1 && exps[0].isAggregate())\n-            throw new UserException(Localizer.forPackage(JDBCStoreQuery.class)\n-                .get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n+            throw new UserException(Localizer.forPackage(JDBCStoreQuery.class).\n+                get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n \n         ClassMapping[] mappings = (ClassMapping[]) metas;\n         JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) \n@@ -143,12 +143,12 @@ protected ResultObjectProvider executeQuery(Executor ex,\n             fetch.addJoins(Arrays.asList(exps[0].fetchPaths));\n         }\n \n-        int eager = calculateEagerMode(exps[0], startIdx, endIdx);\n+        int eager = calculateEagerMode(exps[0], range.start, range.end);\n         int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n         DBDictionary dict = _store.getDBDictionary();\n         long start = (mappings.length == 1 && dict.supportsSelectStartIndex) \n-            ? startIdx : 0L;\n-        long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n+            ? range.start : 0L;\n+        long end = (dict.supportsSelectEndIndex) ? range.end : Long.MAX_VALUE;\n \n         // add selects with populate WHERE conditions to list\n         List sels = new ArrayList(mappings.length);\n@@ -165,8 +165,8 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         // we might want to use lrs settings if we can't use the range\n         if (sels.size() > 1)\n             start = 0L;\n-        lrs = lrs || (fetch.getFetchBatchSize() >= 0 && (start != startIdx \n-            || end != endIdx));\n+        boolean lrs = range.lrs || (fetch.getFetchBatchSize() >= 0 \n+            && (start != range.start || end != range.end));\n \n         ResultObjectProvider[] rops = null;\n         ResultObjectProvider rop = null;\n@@ -209,9 +209,9 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         }\n \n         // need to fake result range?\n-        if ((rops != null && endIdx != Long.MAX_VALUE) || start != startIdx\n-            || end != endIdx)\n-            rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+        if ((rops != null && range.end != Long.MAX_VALUE) \n+            || start != range.start || end != range.end)\n+            rop = new RangeResultObjectProvider(rop, range.start, range.end);\n         return rop;\n     }\n \n@@ -226,7 +226,6 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         final BitSet[] paged = (exps[0].projections.length > 0) ? null\n             : new BitSet[mappings.length];\n         union.select(new Union.Selector() {\n-\n             public void select(Select sel, int idx) {\n                 BitSet bits = populateSelect(sel, mappings[idx], subclasses,\n                     (JDBCExpressionFactory) facts[idx], exps[idx], params,\n@@ -392,11 +391,11 @@ private static boolean hasVerticalSubclasses(ClassMapping mapping) {\n      * or the query is unique, use an eager setting of single. Otherwise use\n      * an eager mode of multiple.\n      */\n-    private int calculateEagerMode(QueryExpressions exps, long startIdx,\n-        long endIdx) {\n-        if (exps.projections.length > 0 || startIdx >= endIdx)\n+    private int calculateEagerMode(QueryExpressions exps, long start,\n+        long end) {\n+        if (exps.projections.length > 0 || start >= end)\n             return EagerFetchModes.EAGER_NONE;\n-        if (endIdx - startIdx == 1 || ctx.isUnique())\n+        if (end - start == 1 || ctx.isUnique())\n             return EagerFetchModes.EAGER_JOIN;\n         return EagerFetchModes.EAGER_PARALLEL;\n     }\n@@ -479,19 +478,13 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n                     count += stmnt.executeUpdate();\n                 } finally {\n                     if (stmnt != null)\n-                        try {\n-                            stmnt.close();\n-                        } catch (SQLException se) {\n-                        }\n+                        try { stmnt.close(); } catch (SQLException se) {}\n                 }\n             }\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, ctx, _store.getDBDictionary());\n         } finally {\n-            try {\n-                conn.close();\n-            } catch (SQLException se) {\n-            }\n+            try { conn.close(); } catch (SQLException se) {}\n         }\n         return Numbers.valueOf(count);\n     }\n@@ -572,22 +565,22 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n \n     protected String[] getDataStoreActions(ClassMetaData base,\n         ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n-        QueryExpressions[] exps, Object[] params, long startIdx, long endIdx) {\n+        QueryExpressions[] exps, Object[] params, Range range) {\n         ClassMapping[] mappings = (ClassMapping[]) metas;\n-        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx\n-            .getFetchConfiguration();\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx.\n+            getFetchConfiguration();\n         if (exps[0].fetchPaths != null) {\n             fetch.addFields(Arrays.asList(exps[0].fetchPaths));\n             fetch.addJoins(Arrays.asList(exps[0].fetchPaths));\n         }\n \n-        int eager = calculateEagerMode(exps[0], startIdx, endIdx);\n+        int eager = calculateEagerMode(exps[0], range.start, range.end);\n         eager = Math.min(eager, JDBCFetchConfiguration.EAGER_JOIN);\n         int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n         DBDictionary dict = _store.getDBDictionary();\n         long start = (mappings.length == 1 && dict.supportsSelectStartIndex) \n-            ? startIdx : 0L;\n-        long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n+            ? range.start : 0L;\n+        long end = (dict.supportsSelectEndIndex) ? range.end : Long.MAX_VALUE;\n \n         // add selects with populate WHERE conditions to list\n         List sels = new ArrayList(mappings.length);"},{"sha":"241b1accd9e1fe3b3860bc5c528453fb4e76c6d4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -184,7 +184,7 @@ public SQLExecutor(SQLStoreQuery q, ClassMetaData candidate) {\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx) {\n+            Object[] params, Range range) {\n             JDBCStore store = ((SQLStoreQuery) q).getStore();\n             DBDictionary dict = store.getDBDictionary();\n             String sql = q.getContext().getQueryString();\n@@ -209,11 +209,11 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n             PreparedStatement stmnt = null;\n             try {\n                 // use the right method depending on sel vs. proc, lrs setting\n-                if (_select && !lrs)\n+                if (_select && !range.lrs)\n                     stmnt = buf.prepareStatement(conn);\n                 else if (_select)\n                     stmnt = buf.prepareStatement(conn, fetch, -1, -1);\n-                else if (!lrs)\n+                else if (!range.lrs)\n                     stmnt = buf.prepareCall(conn);\n                 else\n                     stmnt = buf.prepareCall(conn, fetch, -1, -1);\n@@ -240,13 +240,13 @@ else if (q.getContext().getCandidateType() != null)\n                 throw SQLExceptions.getStore(se, dict);\n             }\n \n-            if (startIdx != 0 || endIdx != Long.MAX_VALUE)\n-                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+            if (range.start != 0 || range.end != Long.MAX_VALUE)\n+                rop = new RangeResultObjectProvider(rop, range.start,range.end);\n             return rop;\n         }\n \n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            Range range) {\n             return new String[]{ q.getContext().getQueryString() };\n         }\n "},{"sha":"f2c99a6cca708be60ef68e36a9407e350a3bda50","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","status":"modified","additions":1,"deletions":7,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -48,8 +48,6 @@\n     private Class _type = null;\n     private ClassMetaData _meta = null;\n     private QueryExpressions _exps = null;\n-    private long _startIdx = 0;\n-    private long _endIdx = Long.MAX_VALUE;\n \n     /**\n      * Constructor. Supply candidate, whether subclasses are included in\n@@ -100,11 +98,8 @@ public String getCandidateAlias() {\n         return _alias;\n     }\n \n-    public void setQueryExpressions(QueryExpressions query, long startIdx,\n-        long endIdx) {\n+    public void setQueryExpressions(QueryExpressions query) {\n         _exps = query;\n-        _startIdx = startIdx;\n-        _endIdx = endIdx;\n     }\n \n     public void initialize(Select sel, JDBCStore store, boolean nullTest) {\n@@ -180,7 +175,6 @@ private void appendTo(SQLBuffer sql, int index, Select sel,\n             _cons.CACHE_NULL, fetch);\n         _cons.select(store, _candidate, _subs, sel, _exps, params,\n             fetch, fetch.EAGER_NONE);\n-        sel.setRange(_startIdx, _endIdx);\n \n         if (size)\n             sql.appendCount(sel, fetch);"},{"sha":"2c23d1e12db369f08a0ae0e426bdc0fcfb54920f","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -22,7 +22,8 @@ update-failed-no-failed-obj: Database operation failed. Update count for SQL \\\n virtual-mapping: Cannot instantiate virtual mapping \"{0}\".\n press-key-end: Server running.  Press enter to stop.\n no-server-conf: There is no persistence server configured.\n-server-usage: Usage: java org.apache.openjpa.jdbc.kernel.StartPersistenceServer\\n\\\n+server-usage: Usage: \\\n+    java org.apache.openjpa.jdbc.kernel.StartPersistenceServer\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]* \n cant-lock-on-load: The database is unable to lock this query.  Each object \\\n@@ -42,7 +43,7 @@ batch-not-supported: The update count for the statement was an invalid \\\n \tvalue ({0}). This indicates that your database or JDBC driver does not \\\n \thave complete support for executing batch statements. Batch \\\n \tfunctionality should be disabled by including \"BatchLimit=0\" in \\\n-\tyour org.apache.openjpa.jdbc.DBDictionary configuration property. Statement: {1}\n+\tyour openjpa.jdbc.DBDictionary configuration property. Statement: {1}\n bad-synch-mappings: Invalid SynchronizeMappings operation (\"{0}\") specified. \\\n \tValid operations are: {1}\n make-native-seq: Creating sequence.\n@@ -59,7 +60,8 @@ bad-seq-type: This sequence of type \"{0}\" cannot generate values for \\\n no-seq-sql: Error instantiating named sequence \"{0}\": Your database dictionary \\\n \tdoes not support native sequences.  To tell the dictionary how to select \\\n \tsequence values, use:\\n\\\n-\torg.apache.openjpa.jdbc.DBDictionary: NextSequenceQuery=\"SELECT NEXT VALUE FOR \\{0\\}\"\\n\\\n+\topenjpa.jdbc.DBDictionary: NextSequenceQuery=\"SELECT NEXT VALUE \\\n+    FOR \\{0\\}\"\\n\\\n \tWhere the above string is replaced with the proper SQL for your database.\n invalid-seq-sql: No rows returned for sql \"{0}\".  Check your configuration.\n insert-seq: Inserting row for this mapping into sequence table.\n@@ -72,7 +74,8 @@ seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.TableJDBCSeq\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]*\\n\\\n \t\\t-action/-a <add | drop | get | set> [value]\n-clstable-seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq\\n\\\n+clstable-seq-usage: Usage: \\\n+    java org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]*\\n\\\n \t\\t-action/-a <add | drop | get | set>\\n\\"},{"sha":"6290ba900879e31d2d707a878096d90cc4176149","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -0,0 +1,94 @@\n+package org.apache.openjpa.ant;\n+\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.enhance.ApplicationIdTool;\n+import org.apache.openjpa.lib.ant.AbstractTask;\n+import org.apache.openjpa.lib.conf.ConfigurationImpl;\n+import org.apache.openjpa.lib.util.CodeFormat;\n+import org.apache.openjpa.lib.util.Files;\n+\n+/**\n+ * <p>Executes the application id tool on the specified files.  This task\n+ * can take the following arguments:\n+ * <ul>\n+ * <li><code>directory</code></li>\n+ * <li><code>ignoreErrors</code></li>\n+ * <li><code>name</code></li>\n+ * <li><code>suffix</code></li>\n+ * <li><code>token</code></li>\n+ * </ul>\n+ * It can also take an embedded <code>codeFormat</code> element with attributes\n+ * for the bean properties of the {@link CodeFormat}.</p>\n+ */\n+public class ApplicationIdToolTask\n+    extends AbstractTask {\n+\n+    protected ApplicationIdTool.Flags flags = new ApplicationIdTool.Flags();\n+    protected String dirName = null;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public ApplicationIdToolTask() {\n+        flags.format = new CodeFormat();\n+    }\n+\n+    /**\n+     * Set the output directory we want the enhancer to write to.\n+     */\n+    public void setDirectory(String dirName) {\n+        this.dirName = dirName;\n+    }\n+\n+    /**\n+     * Set whether to ignore errors.\n+     */\n+    public void setIgnoreErrors(boolean ignoreErrors) {\n+        flags.ignoreErrors = ignoreErrors;\n+    }\n+\n+    /**\n+     * Set the name of the identity class; with this option you must supply\n+     * exactly one class to run on.\n+     */\n+    public void setName(String name) {\n+        flags.name = name;\n+    }\n+\n+    /**\n+     * Set a suffix to append to persistent classes to form their identity\n+     * class name.\n+     */\n+    public void setSuffix(String suffix) {\n+        flags.suffix = suffix;\n+    }\n+\n+    /**\n+     * Set the token to separate stringified primary key field values.\n+     */\n+    public void setToken(String token) {\n+        flags.token = token;\n+    }\n+\n+    /**\n+     * Create the embedded code format element.\n+     */\n+    public Object createCodeFormat() {\n+        return flags.format;\n+    }\n+\n+    protected ConfigurationImpl newConfiguration() {\n+        return new OpenJPAConfigurationImpl();\n+    }\n+\n+    protected void executeOn(String[] files)\n+        throws IOException, ClassNotFoundException {\n+        flags.directory = (dirName == null) ? null\n+            : Files.getFile(dirName, getClassLoader());\n+        ApplicationIdTool.run((OpenJPAConfiguration) getConfiguration(), files,\n+            flags, getClassLoader ());\n+\t}\n+}"},{"sha":"ebe7c7259a1f44b4520df7eaab52bc4900869639","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":9,"deletions":34,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -293,30 +293,17 @@ public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n-            boolean lrs, long startIdx, long endIdx) {\n+            Range range) {\n             QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n             QueryKey key = QueryKey.newInstance(cq.getContext(),\n-                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\n+                _ex.isPacking(q), params, _candidate, _subs, range.start, \n+                range.end);\n             List cached = cq.checkCache(key);\n             if (cached != null)\n                 return new ListResultObjectProvider(cached);\n \n             ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n-                params, lrs, startIdx, endIdx);\n-            return cq.wrapResult(rop, key);\n-        }\n-\n-        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\n-            boolean lrs, long startIdx, long endIdx) {\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\n-                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\n-            List cached = cq.checkCache(key);\n-            if (cached != null)\n-                return new ListResultObjectProvider(cached);\n-\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n-                params, lrs, startIdx, endIdx);\n+                params, range);\n             return cq.wrapResult(rop, key);\n         }\n \n@@ -351,14 +338,6 @@ public Number executeDelete(StoreQuery q, Object[] params) {\n             }\n         }\n \n-        public Number executeDelete(StoreQuery q, Map params) {\n-            try {\n-                return _ex.executeDelete(unwrap(q), params);\n-            } finally {\n-                clearAccesssPath(q);\n-            }\n-        }\n-\n         public Number executeUpdate(StoreQuery q, Object[] params) {\n             try {\n                 return _ex.executeUpdate(unwrap(q), params);\n@@ -367,22 +346,18 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n             }\n         }\n \n-        public Number executeUpdate(StoreQuery q, Map params) {\n-            try {\n-                return _ex.executeUpdate(unwrap(q), params);\n-            } finally {\n-                clearAccesssPath(q);\n-            }\n-        }\n-\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            Range range) {\n             return EMPTY_STRINGS;\n         }\n \n         public void validate(StoreQuery q) {\n             _ex.validate(unwrap(q));\n         }\n+        \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+            _ex.getRange(q, params, range); \n+        }\n \n         public Object getOrderingValue(StoreQuery q, Object[] params,\n             Object resultObject, int orderIndex) {"},{"sha":"4b6c4305931ffe18a1a34fd9ca9bc1c445ec586a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":4,"deletions":18,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -107,39 +107,25 @@ public boolean supportsParameterDeclarations() {\n     public static abstract class AbstractExecutor\n         implements Executor {\n \n-        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\n-            boolean lrs, long startIdx, long endIdx) {\n-            Object[] arr = q.getContext().toParameterArray\n-                (q.getContext().getParameterTypes(), params);\n-            return executeQuery(q, arr, lrs, startIdx, endIdx);\n-        }\n-\n         public Number executeDelete(StoreQuery q, Object[] params) {\n             return q.getContext().deleteInMemory(this, params);\n         }\n \n-        public Number executeDelete(StoreQuery q, Map params) {\n-            return executeDelete(q, q.getContext().toParameterArray\n-                (q.getContext().getParameterTypes(), params));\n-        }\n-\n         public Number executeUpdate(StoreQuery q, Object[] params) {\n             return q.getContext().updateInMemory(this, params);\n         }\n \n-        public Number executeUpdate(StoreQuery q, Map params) {\n-            return executeUpdate(q, q.getContext().toParameterArray\n-                (q.getContext().getParameterTypes(), params));\n-        }\n-\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            Range range) {\n             return EMPTY_STRINGS;\n         }\n \n         public void validate(StoreQuery q) {\n         }\n \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+        }\n+\n         public Object getOrderingValue(StoreQuery q, Object[] params,\n             Object resultObject, int orderIndex) {\n             return null;"},{"sha":"529d277ad0fadec39be73fb9feed1d88a53e7635","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","status":"modified","additions":0,"deletions":8,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -403,14 +403,6 @@ public void declareParameters(String params) {\n         }\n     }\n \n-    public Object[] toParameterArray(LinkedMap paramTypes, Map params) {\n-        try {\n-            return _query.toParameterArray(paramTypes, params);\n-        } catch (RuntimeException re) {\n-            throw translate(re);\n-        }\n-    }\n-\n     public Number deleteInMemory(StoreQuery.Executor ex, Object[] params) {\n         try {\n             return _query.deleteInMemory(ex, params);"},{"sha":"e4595fc66cdad480527fc0df47b6401c62395c8e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","status":"modified","additions":39,"deletions":45,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -27,6 +27,7 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.kernel.exps.AbstractExpressionVisitor;\n import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.Constant;\n import org.apache.openjpa.kernel.exps.ExpressionFactory;\n import org.apache.openjpa.kernel.exps.ExpressionParser;\n import org.apache.openjpa.kernel.exps.FilterListener;\n@@ -177,18 +178,13 @@ public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n      * each base type\n      * @param parsed the parsed query values\n      * @param params parameter values, or empty array\n-     * @param lrs whether the result will be handled as a potentially\n-     * large result set, or will be consumed greedily\n-     * @param startIdx 0-based inclusive index for first result to return\n-     * from result object provider\n-     * @param endIdx 0-based exclusive index for last result to return\n-     * from result object provider, or {@link Long#MAX_VALUE} for no max\n+     * @param range result range\n      * @return a provider for matching objects\n      */\n     protected ResultObjectProvider executeQuery(Executor ex,\n         ClassMetaData base, ClassMetaData[] types, boolean subclasses,\n         ExpressionFactory[] facts, QueryExpressions[] parsed, Object[] params,\n-        boolean lrs, long startIdx, long endIdx) {\n+        Range range) {\n         throw new UnsupportedException();\n     }\n \n@@ -246,16 +242,12 @@ protected Number executeUpdate(Executor ex, ClassMetaData base,\n      * each base type\n      * @param parsed the parsed query values\n      * @param params parameter values, or empty array\n-     * @param startIdx 0-based inclusive index for first result to return\n-     * from result object provider\n-     * @param endIdx 0-based exclusive index for last result to return\n-     * from result object provider, or {@link Long#MAX_VALUE} for no max\n+     * @param range result range\n      * @return a textual description of the query to execute\n      */\n     protected String[] getDataStoreActions(Executor ex, ClassMetaData base,\n         ClassMetaData[] types, boolean subclasses, ExpressionFactory[] facts,\n-        QueryExpressions[] parsed, Object[] params, long startIdx,\n-        long endIdx) {\n+        QueryExpressions[] parsed, Object[] params, Range range) {\n         return StoreQuery.EMPTY_STRINGS;\n     }\n \n@@ -328,6 +320,30 @@ public final void validate(StoreQuery q) {\n             ValidateGroupingExpressionVisitor.validate(q.getContext(), exps); \n         }\n \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+            QueryExpressions exps = assertQueryExpression();\n+            if (exps.range.length == 0)\n+                return;\n+\n+            if (exps.range.length == 2 \n+                && exps.range[0] instanceof Constant\n+                && exps.range[1] instanceof Constant) {\n+                try {\n+                    range.start = ((Number) ((Constant) exps.range[0]).\n+                        getValue(params)).longValue();\n+                    range.end = ((Number) ((Constant) exps.range[1]).\n+                        getValue(params)).longValue();\n+                    return;\n+                } catch (ClassCastException cce) {\n+                    // fall through to exception below\n+                } catch (NullPointerException npe) {\n+                    // fall through to exception below\n+                }\n+            }\n+            throw new UserException(_loc.get(\"only-range-constants\",\n+                q.getContext().getQueryString()));\n+        }\n+\n         public final Class getResultClass(StoreQuery q) {\n             return assertQueryExpression().resultClass;\n         }\n@@ -464,7 +480,7 @@ public InMemoryExecutor(ExpressionStoreQuery q,\n             _subs = subclasses;\n             _factory = new InMemoryExpressionFactory();\n \n-            _exps = new QueryExpressions[]{\n+            _exps = new QueryExpressions[] {\n                 parser.eval(parsed, q, _factory, _meta)\n             };\n             if (_exps[0].projections.length == 0)\n@@ -488,7 +504,7 @@ public InMemoryExecutor(ExpressionStoreQuery q,\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx) {\n+            Object[] params, Range range) {\n             // execute in memory for candidate collection;\n             // also execute in memory for transactional extents\n             Collection coll = q.getContext().getCandidateCollection();\n@@ -539,19 +555,13 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n             results = _factory.distinct(_exps[0], coll == null, results);\n \n             ResultObjectProvider rop = new ListResultObjectProvider(results);\n-            if (startIdx != 0 || endIdx != Long.MAX_VALUE)\n-                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+            if (range.start != 0 || range.end != Long.MAX_VALUE)\n+                rop = new RangeResultObjectProvider(rop, range.start,range.end);\n             return rop;\n         }\n \n-        public ResultObjectProvider executeQuery(StoreQuery q,\n-            Map params, boolean lrs, long startIdx, long endIdx) {\n-            return executeQuery(q, q.getContext().toParameterArray\n-                (getParameterTypes(q), params), lrs, startIdx, endIdx);\n-        }\n-\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            Range range) {\n             // in memory queries have no datastore actions to perform\n             return StoreQuery.EMPTY_STRINGS;\n         }\n@@ -646,16 +656,10 @@ public DataStoreExecutor(ExpressionStoreQuery q,\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx) {\n-            lrs = lrs && !isAggregate(q) && !hasGrouping(q);\n+            Object[] params, Range range) {\n+            range.lrs &= !isAggregate(q) && !hasGrouping(q);\n             return ((ExpressionStoreQuery) q).executeQuery(this, _meta, _metas,\n-                _subs, _facts, _exps, params, lrs, startIdx, endIdx);\n-        }\n-\n-        public ResultObjectProvider executeQuery(StoreQuery q,\n-            Map params, boolean lrs, long startIdx, long endIdx) {\n-            return executeQuery(q, q.getContext().toParameterArray\n-                (getParameterTypes(q), params), lrs, startIdx, endIdx);\n+                _subs, _facts, _exps, params, range);\n         }\n \n         public Number executeDelete(StoreQuery q, Object[] params) {\n@@ -666,11 +670,6 @@ public Number executeDelete(StoreQuery q, Object[] params) {\n             return num;\n         }\n \n-        public Number executeDelete(StoreQuery q, Map params) {\n-            return executeDelete(q, q.getContext().toParameterArray\n-                (getParameterTypes(q), params));\n-        }\n-\n         public Number executeUpdate(StoreQuery q, Object[] params) {\n             Number num = ((ExpressionStoreQuery) q).executeUpdate(this, _meta,\n                 _metas, _subs, _facts, _exps, params);\n@@ -679,15 +678,10 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n             return num;\n         }\n \n-        public Number executeUpdate(StoreQuery q, Map params) {\n-            return executeUpdate(q, q.getContext().toParameterArray\n-                (getParameterTypes(q), params));\n-        }\n-\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            Range range) {\n             return ((ExpressionStoreQuery) q).getDataStoreActions(this, _meta,\n-                _metas, _subs, _facts, _exps, params, startIdx, endIdx);\n+                _metas, _subs, _facts, _exps, params, range);\n         }\n \n         public Object getOrderingValue(StoreQuery q, Object[] params,"},{"sha":"efff616283a6be4c3e04ff9380cdc84ff01453ae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -135,7 +135,7 @@ public MethodExecutor(MethodStoreQuery q, ClassMetaData candidate,\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx) {\n+            Object[] params, Range range) {\n             // convert the parameters into a map\n             Map paramMap;\n             if (params.length == 0)\n@@ -148,19 +148,14 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n                     itr.hasNext(); idx++)\n                     paramMap.put(itr.next(), params[idx]);\n             }\n-            return executeQuery(q, paramMap, lrs, startIdx, endIdx);\n-        }\n \n-        public ResultObjectProvider executeQuery(StoreQuery q,\n-            Map params, boolean lrs, long startIdx, long endIdx) {\n             FetchConfiguration fetch = q.getContext().getFetchConfiguration();\n             StoreContext sctx = q.getContext().getStoreContext();\n-\n             ResultObjectProvider rop;\n             Object[] args;\n             if (_inMem) {\n                 args = new Object[]{ sctx, _meta, (_subs) ? Boolean.TRUE\n-                    : Boolean.FALSE, null, params, fetch };\n+                    : Boolean.FALSE, null, paramMap, fetch };\n \n                 Iterator itr = null;\n                 Collection coll = q.getContext().getCandidateCollection();\n@@ -192,12 +187,12 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n             } else {\n                 // datastore\n                 args = new Object[]{ sctx, _meta, (_subs) ? Boolean.TRUE\n-                    : Boolean.FALSE, params, fetch };\n+                    : Boolean.FALSE, paramMap, fetch };\n                 rop = (ResultObjectProvider) invoke(q, args);\n             }\n \n-            if (startIdx != 0 || endIdx != Long.MAX_VALUE)\n-                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+            if (range.start != 0 || range.end != Long.MAX_VALUE)\n+                rop = new RangeResultObjectProvider(rop, range.start,range.end);\n             return rop;\n         }\n "},{"sha":"485ef1519978e250d53b1c251ade73dc49e6b3d3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -248,11 +248,6 @@\n      */\n     public Collection getAggregateListeners();\n \n-    /**\n-     * Helper method to transform the given parameters into an array.\n-     */\n-    public Object[] toParameterArray(LinkedMap paramTypes, Map params);\n-\n     /**\n      * Helper method to delete the objects found by executing a query on\n      * the given executor."},{"sha":"b3dc2fc93dabc7d6bf9bcca76e123eede49c1762","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":62,"deletions":202,"changes":264,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -104,6 +104,7 @@\n     private Class _resultClass = null;\n     private transient long _startIdx = 0;\n     private transient long _endIdx = Long.MAX_VALUE;\n+    private transient boolean _rangeSet = false;\n \n     // remember the list of all the results we have returned so we\n     // can free their resources when close or closeAll is called\n@@ -486,35 +487,13 @@ public void setResultType(Class cls) {\n     }\n \n     public long getStartRange() {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_startIdx != 0 || _endIdx != Long.MAX_VALUE\n-                || _compiled != null || _query == null || _broker == null)\n-                return _startIdx;\n-\n-            // check again after compilation; maybe encoded in string\n-            compileForCompilation();\n-            return _startIdx;\n-        } finally {\n-            unlock();\n-        }\n+        assertOpen();\n+        return _startIdx;\n     }\n \n     public long getEndRange() {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_startIdx != 0 || _endIdx != Long.MAX_VALUE\n-                || _compiled != null || _query == null || _broker == null)\n-                return _endIdx;\n-\n-            // check again after compilation; maybe encoded in string\n-            compileForCompilation();\n-            return _endIdx;\n-        } finally {\n-            unlock();\n-        }\n+        assertOpen();\n+        return _endIdx;\n     }\n \n     public void setRange(long start, long end) {\n@@ -532,6 +511,7 @@ public void setRange(long start, long end) {\n             // allowed modification: no read-only check\n             _startIdx = start;\n             _endIdx = end;\n+            _rangeSet = true;\n         } finally {\n             unlock();\n         }\n@@ -703,7 +683,7 @@ else if (_subclasses)\n                 else\n                     es[i] = _storeQuery.newDataStoreExecutor(metas[i], true);\n             }\n-            return new MergedExecutor(es, this);\n+            return new MergedExecutor(es);\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (RuntimeException re) {\n@@ -799,16 +779,18 @@ private Object execute(int operation, Map params) {\n                 StoreQuery.Executor ex = (isInMemory(operation))\n                     ? compileForInMemory(comp) : compileForDataStore(comp);\n \n-                assertParameters(ex, params);\n+                Object[] arr = (params.isEmpty()) ? StoreQuery.EMPTY_OBJECTS :\n+                    toParameterArray(ex.getParameterTypes(_storeQuery), params);\n+                assertParameters(ex, arr);\n                 if (_log.isTraceEnabled())\n                     logExecution(operation, params);\n \n                 if (operation == OP_SELECT)\n-                    return execute(ex, params);\n+                    return execute(ex, arr);\n                 if (operation == OP_DELETE)\n-                    return delete(ex, params);\n+                    return delete(ex, arr);\n                 if (operation == OP_UPDATE)\n-                    return update(ex, params);\n+                    return update(ex, arr);\n                 throw new UnsupportedException();\n             } catch (OpenJPAException ke) {\n                 throw ke;\n@@ -847,7 +829,7 @@ public long updateAll(Map params) {\n         return ((Number) execute(OP_UPDATE, params)).longValue();\n     }\n \n-    public Object[] toParameterArray(LinkedMap paramTypes, Map params) {\n+    private Object[] toParameterArray(LinkedMap paramTypes, Map params) {\n         if (params == null || params.isEmpty())\n             return StoreQuery.EMPTY_OBJECTS;\n \n@@ -940,65 +922,25 @@ private boolean isInMemory(int operation) {\n     private Object execute(StoreQuery.Executor ex, Object[] params)\n         throws Exception {\n         // if this is an impossible result range, return null / empty list\n-        if (_startIdx >= _endIdx)\n+        StoreQuery.Range range = new StoreQuery.Range(_startIdx, _endIdx);\n+        if (!_rangeSet)\n+            ex.getRange(_storeQuery, params, range);\n+        if (range.start >= range.end)\n             return emptyResult(ex);\n \n         // execute; if we have a result class or we have only one result\n         // and so need to remove it from its array, wrap in a packing rop\n-        boolean lrs = isLRS();\n-        ResultObjectProvider rop = ex.executeQuery(_storeQuery, params, lrs,\n-            _startIdx, _endIdx);\n+        range.lrs = isLRS(range.start, range.end);\n+        ResultObjectProvider rop = ex.executeQuery(_storeQuery, params, range);\n         try {\n-            return toResult(ex, rop, lrs);\n+            return toResult(ex, rop, range);\n         } catch (Exception e) {\n             if (rop != null)\n                 try { rop.close(); } catch (Exception e2) {}\n             throw e;\n         }\n     }\n \n-    /**\n-     * Execute the query using the given compilation, executor, and parameter\n-     * values. All other execute methods delegate to this one or to\n-     * {@link #execute(StoreQuery.Executor,Object[])} after validation and\n-     * locking.\n-     */\n-    private Object execute(StoreQuery.Executor ex, Map params)\n-        throws Exception {\n-        // if this is an impossible result range, return null / empty list\n-        if (_startIdx >= _endIdx)\n-            return emptyResult(ex);\n-\n-        // execute; if we have a result class or we have only one result\n-        // and so need to remove it from its array, wrap in a packing rop\n-        boolean lrs = isLRS();\n-        ResultObjectProvider rop = ex.executeQuery(_storeQuery, params, lrs,\n-            _startIdx, _endIdx);\n-        try {\n-            return toResult(ex, rop, lrs);\n-        } catch (Exception e) {\n-            if (rop != null)\n-                try {\n-                    rop.close();\n-                } catch (Exception e2) {\n-                }\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * Delete the query using the given executor, and parameter\n-     * values. All other execute methods delegate to this one or to\n-     * {@link #delete(StoreQuery.Executor,Object[])} after validation and\n-     * locking. The return value will be a Number indicating the number of\n-     * instances deleted.\n-     */\n-    private Number delete(StoreQuery.Executor ex, Map params)\n-        throws Exception {\n-        assertBulkModify();\n-        return ex.executeDelete(_storeQuery, params);\n-    }\n-\n     /**\n      * Delete the query using the given executor, and parameter\n      * values. All other execute methods delegate to this one or to\n@@ -1008,7 +950,7 @@ private Number delete(StoreQuery.Executor ex, Map params)\n      */\n     private Number delete(StoreQuery.Executor ex, Object[] params)\n         throws Exception {\n-        assertBulkModify();\n+        assertBulkModify(ex, params);\n         return ex.executeDelete(_storeQuery, params);\n     }\n \n@@ -1030,19 +972,6 @@ public Number deleteInMemory(StoreQuery.Executor executor,\n         }\n     }\n \n-    /**\n-     * Update the query using the given executor and parameter\n-     * values. All other execute methods delegate to this one or to\n-     * {@link #update(StoreQuery.Executor,Object[])} after validation and\n-     * locking. The return value will be a Number indicating the number of\n-     * instances updated.\n-     */\n-    private Number update(StoreQuery.Executor ex, Map params)\n-        throws Exception {\n-        assertBulkModify();\n-        return ex.executeUpdate(_storeQuery, params);\n-    }\n-\n     /**\n      * Update the query using the given compilation, executor, and parameter\n      * values. All other execute methods delegate to this one or to\n@@ -1052,7 +981,7 @@ private Number update(StoreQuery.Executor ex, Map params)\n      */\n     private Number update(StoreQuery.Executor ex, Object[] params)\n         throws Exception {\n-        assertBulkModify();\n+        assertBulkModify(ex, params);\n         return ex.executeUpdate(_storeQuery, params);\n     }\n \n@@ -1086,7 +1015,7 @@ private void updateInMemory(Object ob, Object[] params) {\n             Map.Entry e = (Map.Entry) it.next();\n             FieldMetaData fmd = (FieldMetaData) e.getKey();\n             if (!(e.getValue() instanceof Constant))\n-                throw new UserException(_loc.get(\"only-update-primitives\"));\n+                throw new UserException(_loc.get(\"only-update-constants\"));\n             Constant value = (Constant) e.getValue();\n             Object val = value.getValue(params);\n \n@@ -1195,8 +1124,8 @@ private void logExecution(int op, Map params) {\n     /**\n      * Return whether this should be treated as a potential large result set.\n      */\n-    private boolean isLRS() {\n-        long range = _endIdx - _startIdx;\n+    private boolean isLRS(long start, long end) {\n+        long range = end - start;\n         return _fc.getFetchBatchSize() >= 0\n             && !(range <= _fc.getFetchBatchSize()\n             || (_fc.getFetchBatchSize() == 0 && range <= 50));\n@@ -1206,7 +1135,7 @@ private boolean isLRS() {\n      * Return the query result for the given result object provider.\n      */\n     protected Object toResult(StoreQuery.Executor ex, ResultObjectProvider rop,\n-        boolean lrs)\n+        StoreQuery.Range range)\n         throws Exception {\n         // pack projections if necessary\n         String[] aliases = ex.getProjectionAliases(_storeQuery);\n@@ -1220,13 +1149,13 @@ protected Object toResult(StoreQuery.Executor ex, ResultObjectProvider rop,\n         // if single result, extract it\n         if (_unique == Boolean.TRUE || (aliases.length > 0\n             && !ex.hasGrouping(_storeQuery) && ex.isAggregate(_storeQuery)))\n-            return singleResult(rop);\n+            return singleResult(rop, range);\n \n         // now that we've executed the query, we can call isAggregate and\n         // hasGrouping efficiently\n         boolean detach = (_broker.getAutoDetach() &\n             AutoDetach.DETACH_NONTXREAD) > 0 && !_broker.isActive();\n-        lrs = lrs && !ex.isAggregate(_storeQuery)\n+        boolean lrs = range.lrs && !ex.isAggregate(_storeQuery)\n             && !ex.hasGrouping(_storeQuery);\n         ResultList res = (!detach && lrs) ? _fc.newResultList(rop)\n             : new EagerResultList(rop);\n@@ -1281,7 +1210,8 @@ private Object emptyResult(StoreQuery.Executor ex) {\n      * Extract an expected single result from the given provider. Used when\n      * the result is an ungrouped aggregate or the unique flag is set to true.\n      */\n-    private Object singleResult(ResultObjectProvider rop)\n+    private Object singleResult(ResultObjectProvider rop, \n+        StoreQuery.Range range)\n         throws Exception {\n         rop.open();\n         try {\n@@ -1293,7 +1223,7 @@ private Object singleResult(ResultObjectProvider rop)\n             Object single = null;\n             if (next) {\n                 single = rop.getResultObject();\n-                if (_endIdx != _startIdx + 1 && rop.next())\n+                if (range.end != range.start + 1 && rop.next())\n                     throw new InvalidStateException(_loc.get(\"not-unique\",\n                         _class, _query));\n             }\n@@ -1397,10 +1327,13 @@ private void closeResults(boolean force) {\n             assertOpen();\n \n             StoreQuery.Executor ex = compileForExecutor();\n-            assertParameters(ex, params);\n             Object[] arr = toParameterArray(ex.getParameterTypes(_storeQuery),\n                 params);\n-            return ex.getDataStoreActions(_storeQuery, arr, _startIdx, _endIdx);\n+            assertParameters(ex, arr);\n+            StoreQuery.Range range = new StoreQuery.Range(_startIdx, _endIdx);\n+            if (!_rangeSet)\n+                ex.getRange(_storeQuery, arr, range);\n+            return ex.getDataStoreActions(_storeQuery, arr, range);\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (Exception e) {\n@@ -1654,44 +1587,16 @@ private void assertCandidateType() {\n      * Check that we are in a state to be able to perform a bulk operation;\n      * also flush the current modfications if any elements are currently dirty.\n      */\n-    private void assertBulkModify() {\n+    private void assertBulkModify(StoreQuery.Executor ex, Object[] params) {\n         _broker.assertActiveTransaction();\n         if (_startIdx != 0 || _endIdx != Long.MAX_VALUE)\n             throw new UserException(_loc.get(\"no-modify-range\"));\n         if (_resultClass != null)\n             throw new UserException(_loc.get(\"no-modify-resultclass\"));\n-    }\n-\n-    /**\n-     * Checks that the passed parameters match the declarations.\n-     */\n-    private void assertParameters(StoreQuery.Executor ex, Map params) {\n-        if (!_storeQuery.requiresParameterDeclarations())\n-            return;\n-\n-        // check that all declared parameters are given compatible values\n-        LinkedMap paramTypes = ex.getParameterTypes(_storeQuery);\n-        if (paramTypes != null && !paramTypes.isEmpty()) {\n-            Map.Entry entry;\n-            for (Iterator itr = paramTypes.entrySet().iterator();\n-                itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                if (!params.containsKey(entry.getKey()))\n-                    throw new UserException(_loc.get(\"unbound-param\",\n-                        entry.getKey()));\n-                if (((Class) entry.getValue()).isPrimitive()\n-                    && params.get(entry.getKey()) == null)\n-                    throw new UserException(_loc.get(\"null-primitive-param\",\n-                        entry.getKey()));\n-            }\n-        }\n-\n-        // check that there are no extra params\n-        int typeCount = (paramTypes == null) ? 0 : paramTypes.size();\n-        int paramCount = (params == null) ? 0 : params.size();\n-        if (paramCount > typeCount)\n-            throw new UserException(_loc.get(\"extra-params\", new Object[]\n-                { new Integer(typeCount), new Integer(paramCount) }));\n+        StoreQuery.Range range = new StoreQuery.Range();\n+        ex.getRange(_storeQuery, params, range);\n+        if (range.start != 0 || range.end != Long.MAX_VALUE)\n+            throw new UserException(_loc.get(\"no-modify-range\"));\n     }\n \n     /**\n@@ -1708,7 +1613,7 @@ protected void assertParameters(StoreQuery.Executor ex, Object[] params) {\n                 paramTypes.keySet()));\n         if (typeCount < params.length)\n             throw new UserException(_loc.get(\"extra-params\", new Object[]\n-                { new Integer(typeCount), new Integer(params.length) }));\n+                { String.valueOf(typeCount), String.valueOf(params.length) }));\n \n         Iterator itr = paramTypes.entrySet().iterator();\n         Map.Entry entry;\n@@ -1761,31 +1666,28 @@ public String toString() {\n         implements StoreQuery.Executor {\n \n         private final StoreQuery.Executor[] _executors;\n-        private final QueryContext _ctx;\n \n-        public MergedExecutor(StoreQuery.Executor[] executors,\n-            QueryContext ctx) {\n+        public MergedExecutor(StoreQuery.Executor[] executors) {\n             _executors = executors;\n-            _ctx = ctx;\n         }\n \n         public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx) {\n+            Object[] params, StoreQuery.Range range) {\n             if (_executors.length == 1)\n-                return _executors[0].executeQuery(q, params, lrs, startIdx,\n-                    endIdx);\n+                return _executors[0].executeQuery(q, params, range);\n \n             // use lrs settings if we couldn't take advantage of the start index\n             // so that hopefully the skip to the start will be efficient\n-            lrs = lrs || (startIdx > 0\n-                && _ctx.getFetchConfiguration().getFetchBatchSize() >= 0);\n+            StoreQuery.Range ropRange = new StoreQuery.Range(0, range.end);\n+            ropRange.lrs = range.lrs || (range.start > 0 && q.getContext().\n+                getFetchConfiguration().getFetchBatchSize() >= 0);\n \n             // execute the query; we cannot use the lower bound of the result\n             // range, but we can take advantage of the upper bound\n             ResultObjectProvider[] rops =\n                 new ResultObjectProvider[_executors.length];\n             for (int i = 0; i < _executors.length; i++)\n-                rops[i] = _executors[i].executeQuery(q, params, lrs, 0, endIdx);\n+                rops[i] = _executors[i].executeQuery(q, params, ropRange);\n \n             boolean[] asc = _executors[0].getAscending(q);\n             ResultObjectProvider rop;\n@@ -1796,41 +1698,9 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n                     _executors, q, params);\n \n             // if there is a lower bound, wrap in range rop\n-            if (startIdx != 0)\n-                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n-            return rop;\n-        }\n-\n-        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\n-            boolean lrs, long startIdx, long endIdx) {\n-            if (_executors.length == 1)\n-                return _executors[0].executeQuery(q, params, lrs, startIdx,\n-                    endIdx);\n-\n-            // use lrs settings if we couldn't take advantage of the start index\n-            // so that hopefully the skip to the start will be efficient\n-            lrs = lrs || (startIdx > 0\n-                && _ctx.getFetchConfiguration().getFetchBatchSize() >= 0);\n-\n-            // execute the query; we cannot use the lower bound of the result\n-            // range, but we can take advantage of the upper bound\n-            ResultObjectProvider[] rops =\n-                new ResultObjectProvider[_executors.length];\n-            for (int i = 0; i < _executors.length; i++)\n-                rops[i] = _executors[i].executeQuery(q, params, lrs, 0, endIdx);\n-\n-            boolean[] asc = _executors[0].getAscending(q);\n-            ResultObjectProvider rop;\n-            if (asc.length == 0)\n-                rop = new MergedResultObjectProvider(rops);\n-            else\n-                rop = new OrderingMergedResultObjectProvider(rops, asc,\n-                    _executors, q, _ctx.toParameterArray\n-                    (_executors[0].getParameterTypes(q), params));\n-\n-            // if there is a lower bound, wrap in range rop\n-            if (startIdx != 0)\n-                rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n+            if (range.start != 0)\n+                rop = new RangeResultObjectProvider(rop, range.start, \n+                    range.end);\n             return rop;\n         }\n \n@@ -1841,38 +1711,23 @@ public Number executeDelete(StoreQuery q, Object[] params) {\n             return Numbers.valueOf(num);\n         }\n \n-        public Number executeDelete(StoreQuery q, Map params) {\n-            long num = 0;\n-            for (int i = 0; i < _executors.length; i++)\n-                num += _executors[i].executeDelete(q, params).longValue();\n-            return Numbers.valueOf(num);\n-        }\n-\n         public Number executeUpdate(StoreQuery q, Object[] params) {\n             long num = 0;\n             for (int i = 0; i < _executors.length; i++)\n                 num += _executors[i].executeUpdate(q, params).longValue();\n             return Numbers.valueOf(num);\n         }\n \n-        public Number executeUpdate(StoreQuery q, Map params) {\n-            long num = 0;\n-            for (int i = 0; i < _executors.length; i++)\n-                num += _executors[i].executeUpdate(q, params).longValue();\n-            return Numbers.valueOf(num);\n-        }\n-\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx) {\n+            StoreQuery.Range range) {\n             if (_executors.length == 1)\n-                return _executors[0].getDataStoreActions(q, params,\n-                    startIdx, endIdx);\n+                return _executors[0].getDataStoreActions(q, params, range);\n \n             List results = new ArrayList(_executors.length);\n+            StoreQuery.Range ropRange = new StoreQuery.Range(0L, range.end);\n             String[] actions;\n             for (int i = 0; i < _executors.length; i++) {\n-                actions = _executors[i].getDataStoreActions(q, params, 0,\n-                    endIdx);\n+                actions = _executors[i].getDataStoreActions(q, params,ropRange);\n                 if (actions != null && actions.length > 0)\n                     results.addAll(Arrays.asList(actions));\n             }\n@@ -1883,6 +1738,11 @@ public void validate(StoreQuery q) {\n             _executors[0].validate(q);\n         }\n \n+        public void getRange(StoreQuery q, Object[] params, \n+            StoreQuery.Range range) {\n+            _executors[0].getRange(q, params, range);\n+        }\n+\n         public Object getOrderingValue(StoreQuery q, Object[] params,\n             Object resultObject, int idx) {\n             // unfortunately, at this point (must be a merged rop containing"},{"sha":"46c853a182dcdccf892b0b88aa540fa89b057ad5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -89,9 +89,12 @@ public boolean proxy(boolean reset, boolean replaceNull) {\n                 proxy = checkProxy();\n                 if (proxy == null) {\n                     proxy = (Proxy) _sm.newFieldProxy(field);\n-                    if (objval != null)\n-                        ((Calendar) proxy).setTime(((Calendar) objval).\n-                            getTime());\n+                    if (objval != null) {\n+                        Calendar pcal = (Calendar) proxy;\n+                        Calendar ocal = (Calendar) objval;\n+                        pcal.setTime(ocal.getTime());\n+                        pcal.setTimeZone(ocal.getTimeZone());\n+                    }\n                     ret = true;\n                 }\n                 break;"},{"sha":"cfa30f5341be6dd36d59cf9c6ba01fb8382d1fb9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":26,"deletions":24,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -158,6 +158,23 @@\n      */\n     public boolean supportsParameterDeclarations();\n \n+    /**\n+     * A query result range.\n+     */\n+    public static class Range {\n+        public long start = 0L;\n+        public long end = Long.MAX_VALUE;\n+        public boolean lrs = false;\n+\n+        public Range() {\n+        }\n+\n+        public Range(long start, long end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+    }\n+\n     /**\n      * An executor provides a uniform interface to the mechanism for executing\n      * either an in-memory or datastore query. In the common case, the\n@@ -179,54 +196,39 @@\n          * aggregate and does not have grouping\n          * @see #isPacking\n          */\n-        public ResultObjectProvider executeQuery(StoreQuery q,\n-            Object[] params, boolean lrs, long startIdx, long endIdx);\n-\n-        /**\n-         * Return the result of executing this query with the given parameter\n-         * values. Most implementation will use\n-         * {@link QueryContext#toParameterArray} to transform the parameters\n-         * into an array and invoke the array version of this method.\n-         */\n-        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\n-            boolean lrs, long startIdx, long endIdx);\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n+            Range range);\n \n         /**\n          * Deleted the objects that result from the execution of the\n          * query, retuning the number of objects that were deleted.\n          */\n         public Number executeDelete(StoreQuery q, Object[] params);\n \n-        /**\n-         * Deleted the objects that result from the execution of the\n-         * query, retuning the number of objects that were deleted.\n-         */\n-        public Number executeDelete(StoreQuery q, Map params);\n-\n         /**\n          * Updates the objects that result from the execution of the\n          * query, retuning the number of objects that were updated.\n          */\n         public Number executeUpdate(StoreQuery q, Object[] params);\n \n-        /**\n-         * Updates the objects that result from the execution of the\n-         * query, retuning the number of objects that were updated.\n-         */\n-        public Number executeUpdate(StoreQuery q, Map params);\n-\n         /**\n          * Return a description of the commands that will be sent to\n          * the datastore in order to execute the query.\n          */\n         public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            long startIdx, long endIdx);\n+            Range range);\n \n         /**\n          * Validate components of query.\n          */\n         public void validate(StoreQuery q);\n \n+        /**\n+         * Mutate the given range to set any range information stored in \n+         * the query string and/or parameters.\n+         */\n+        public void getRange(StoreQuery q, Object[] params, Range range);\n+\n         /**\n          * Extract the value of the <code>orderIndex</code>th ordering\n          * expression in {@link Query#getOrderingClauses} from the"},{"sha":"23eafa1509e491d51a70c78e5f8157f9774f6c21","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -16,12 +16,11 @@\n package org.apache.openjpa.kernel.exps;\n \n /**\n- * Interface for any constant value.\n+ * Interface for any query constant value.\n  *\n  * @author Marc Prud'hommeaux\n  */\n-public interface Constant\n-    extends Value {\n+public interface Constant {\n \n     /**\n      * Return the value for this constant given the specified parameters."},{"sha":"e9e4972f1b702601d0b0eb27cd52d12c7c39067e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -22,7 +22,7 @@\n  * @nojavadoc\n  */\n public interface Literal\n-    extends Constant {\n+    extends Value, Constant {\n \n     public static final int TYPE_UNKNOWN = 0;\n     public static final int TYPE_NUMBER = 1;"},{"sha":"ef8bb04f390ebfcbdf367f52053beb44f5a05c1c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -22,7 +22,7 @@\n  * @nojavadoc\n  */\n public interface Parameter\n-    extends Constant {\n+    extends Value, Constant {\n \n     /**\n      * Set the index of this parameter."},{"sha":"a8a1ec7bc507be16448c0c6666e06f275aa9fc69","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","status":"modified","additions":16,"deletions":2,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -15,6 +15,8 @@\n  */\n package org.apache.openjpa.kernel.exps;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.apache.commons.collections.map.LinkedMap;\n@@ -40,8 +42,7 @@\n     /**\n      * Map of {@link FieldMetaData},{@link Value} for update statements.\n      */\n-    public Map updates = null;\n-\n+    public Map updates = Collections.EMPTY_MAP;\n     public int distinct = DISTINCT_AUTO;\n     public String alias = null;\n     public Value[] projections = EMPTY_VALUES;\n@@ -59,8 +60,12 @@\n     public int operation = QueryOperations.OP_SELECT;\n     public ClassMetaData[] accessPath = StoreQuery.EMPTY_METAS;\n     public String[] fetchPaths = StoreQuery.EMPTY_STRINGS;\n+    public Value[] range = EMPTY_VALUES;\n     private Boolean _aggregate = null;\n \n+    /**\n+     * Whether this is an aggregate results.\n+     */\n     public boolean isAggregate() {\n         if (projections.length == 0)\n             return false; \n@@ -70,6 +75,15 @@ public boolean isAggregate() {\n         return _aggregate.booleanValue();    \n     }\n \n+    /**\n+     * Add an update.\n+     */\n+    public void putUpdate(FieldMetaData fmd, Value val) {\n+        if (updates == Collections.EMPTY_MAP)\n+            updates = new HashMap();\n+        updates.put(fmd, val);\n+    }\n+\n     /**\n      * Visitor to determine whether our projections are aggregates.\n      */"},{"sha":"86666082d7597418b0b7bbd2407f2157cd74c7b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -42,8 +42,7 @@ public String getCandidateAlias() {\n         return _alias;\n     }\n \n-    public void setQueryExpressions(QueryExpressions q, long startIdx,\n-        long endIdx) {\n+    public void setQueryExpressions(QueryExpressions q) {\n     }\n \n     public Class getType() {"},{"sha":"f73e58de0df669fb274594296f9f9f4964f7951f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -32,6 +32,5 @@\n     /**\n      * Set the parsed subquery.\n      */\n-    public void setQueryExpressions(QueryExpressions query, long startIdx,\n-        long endIdx);\n+    public void setQueryExpressions(QueryExpressions query);\n }"},{"sha":"51d845adfdbe6016e0c9afed33d5e6a99bf87c03","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":2,"deletions":14,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -444,30 +444,18 @@ protected Expression evalFetchJoins(QueryExpressions exps) {\n     protected void evalSetClause(QueryExpressions exps) {\n         // handle SET field = value\n         JPQLNode[] nodes = root().findChildrenByID(JJTUPDATEITEM);\n-\n-        Map updates = null;\n-\n         for (int i = 0; nodes != null && i < nodes.length; i++) {\n-            if (updates == null)\n-                updates = new HashMap();\n-\n             FieldMetaData field = getPath(firstChild(nodes[i])).last();\n             Value val = getValue(onlyChild(lastChild(nodes[i])));\n-\n-            updates.put(field, val);\n+            exps.putUpdate(field, val);\n         }\n-\n-        if (updates != null)\n-            exps.updates = updates;\n     }\n \n     private Expression evalWhereClause(QueryExpressions exps) {\n         // evaluate the WHERE clause\n         JPQLNode whereNode = root().findChildByID(JJTWHERE, false);\n-\n         if (whereNode == null)\n             return null;\n-\n         return (Expression) eval(whereNode);\n     }\n \n@@ -1110,7 +1098,7 @@ private Value getSubquery(JPQLNode node) {\n \n         try {\n             QueryExpressions subexp = getQueryExpressions();\n-            subq.setQueryExpressions(subexp, 0, Long.MAX_VALUE);\n+            subq.setQueryExpressions(subexp);\n             return subq;\n         } finally {\n             // remove the subquery parse context"},{"sha":"309537eb78bd0d99dbe1d85a423cd3576f685a4b","filename":"openjpa-kernel/src/main/java/sun/misc/Perf.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/sun/misc/Perf.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/java/sun/misc/Perf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/sun/misc/Perf.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -0,0 +1,28 @@\n+package sun.misc;\n+\n+/**\n+ * Compilation stub for pre-1.4.2 JREs. Thanks to it, the whole backport\n+ * concurrency package compiles and works with 1.4.2 as well as wih earlier \n+ * JREs, and takes advantage of native Perf class when running on 1.4.2 while \n+ * seamlessly falling back to System.currentTimeMillis() on previous JREs. This\n+ * class should NOT be included in the binary distribution of backport.\n+ *\n+ * @author Dawid Kurzyniec\n+ * @version 1.0\n+ */\n+public final class Perf {\n+\n+    private static final Perf perf = new Perf();\n+\n+    public static Perf getPerf() { return perf; }\n+\n+    private Perf() {}\n+\n+    public long highResCounter() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    public long highResFrequency() {\n+        return 1000L;\n+    }\n+}"},{"sha":"23d61a7bb2f07b19c85ea61fb7dc2dfaac80ebc6","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -4,8 +4,6 @@ in-mem-subquery: Subqueries are not supported for queries that execute \\\n not-comp: The evaluation of the ordering expression of this query produced \\\n \tnon-comparable values \"{0}\" and \"{1}\".  Please check that the ordering \\\n \tclause is valid.\n-bad-wild: The wildcard string \"{0}\" is invalid.\n-bad-regexp: The regular expression string \"{0}\" is invalid.\n agg-in-filter: If you use an aggregate function in a query filter, you must \\\n \tmake sure to only invoke the aggregate on collections.\n parse-error: An error occurred while parsing the query filter \"{1}\". \\"},{"sha":"e0e094935d7cb87cc4289621272b6fdc866b06c3","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":11,"deletions":7,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -166,7 +166,9 @@ inverse-consistency: An inverse inconsistency in the object featureSelection was \\\n \tdetected while flushing the field \"{0}\" of the instance with id \"{1}\" \\\n \tin context \"{2}\".\n no-brokerfactory: You did not name the factory class with the required \\\n-\tproperty org.apache.openjpa.BrokerFactory.\n+\tproperty openjpa.BrokerFactory.  Normally this property defaults \\\n+    appropriately; have you forgotten to include all the OpenJPA jars in your \\\n+    classpath?\n brokerfactory-excep: There was an error when invoking the static \\\n \tgetInstance method on the named factory class \"{0}\".  See the \\\n \tnested exception for details.\n@@ -226,7 +228,7 @@ force-in-mem: This query on type \"{0}\" must load the entire candidate class \\\n \tthere are dirty instances that may affect the query''s outcome in the \\\n \tcache.\n cant-exec-inmem: Queries of this type (\"{0}\") cannot be executed in-memory. \\\n-\tEither set IgnoreCache to true, set the org.apache.openjpa.FlushBeforeQueries \\\n+\tEither set IgnoreCache to true, set the openjpa.FlushBeforeQueries \\\n \tproperty to true, or execute the query before changing any instances in \\\n \tthe transaction.\n executing-query: Executing query: {0}\n@@ -269,9 +271,9 @@ bad-method-class: You set the method name of this openjpa.MethodQL query to \\\n \t\"{1}\", but class \"{0}\" is not a valid class name.  Make sure to fully \\\n \tqualify the class name or to import its package into this query if the \\\n \tclass is not in the query candidate class'' package. \n-method-not-static: Method \"{0}\" named in the org.apache.openjpa.MethodQL query must be static.\n+method-not-static: Method \"{0}\" named in the MethodQL query must be static.\n no-method: You must set the query filter to the name of the method to execute \\\n-\tfor this org.apache.openjpa.MethodQL query instance.\n+\tfor this MethodQL query instance.\n method-error: There was an error invoking method \"{0}\" with arguments \"{1}\".\n bad-param-type: The type \"{0}\" as used in the parameter declarations \\\n \tcould not be found in the imports.\n@@ -295,13 +297,15 @@ bad-inmem-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Object, \\\n \ttrue.\n bad-datastore-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Map, \\\n \tFetchConfiguration)\" is not declared in type \"{1}\".  Check \\\n-\tthe method name supplied in your org.apache.openjpa.MethodQL query filter.  OpenJPA is \\\n+\tthe method name supplied in your MethodQL query filter.  OpenJPA is \\\n \tattempting to execute this query against the datastore; if you implemented \\\n \tthe in-memory method instead (a method with the same signature but with an \\\n \tObject argument) and want this query to execute in-memory, supplly a \\\n \tCollection of candidates to filter.\n-only-update-primitives: Bulk update queries when executed in memory \\\n-\tmay only change the value of primitives and simple Object fields.\n+only-update-constants: Bulk update queries when executed in memory \\\n+\tmay only update to constant values.\n+only-range-constants: Range values must be numeric constants.  Illegal query: \\\n+    {0}\n no-savepoint-copy: Unable to copy field \"{0}\" for savepoint.\n savepoint-exists: A savepoint with the name \"{0}\" already exists.  \\\n \tEach savepoint name must be unique."},{"sha":"bc01a7a66b0eb4810c4ac28315b9c1c538fc756e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -31,7 +31,7 @@\n      */\n     protected final ExclusiveLock lock;\n \n-    /* *\n+    /**\n      * Create a new CondVar that relies on the given mutual exclusion lock.\n      * @param lock A non-reentrant mutual exclusion lock.\n      */"},{"sha":"aac1120667e1ceda52255d79f1688a64428d9728","filename":"openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/163cc2a22c9662fe79dd8eeacc0fd9fb197a6565/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/resources/org/apache/openjpa/persistence/jdbc/localizer.properties?ref=163cc2a22c9662fe79dd8eeacc0fd9fb197a6565","patch":"@@ -16,8 +16,8 @@ bad-second: \"{0}\" declares a secondary table on columns that do not support \\\n unique-constraints: Detected declared unique constraints on \"{0}\".  OpenJPA \\\n \tdoes not yet support the @UniqueConstraint annotation.\n inconsist-col-attrs: Detected inconsistent values of \"unique\" on different \\\n-\tcolumns of \"{0}\".  OpenJPA does not yet support different per-column unique \\\n-\tvalues.  All columns for this mapping must use the same values.\n+\tcolumns of \"{0}\".  OpenJPA does not yet support different per-column \\\n+    unique values.  All columns for this mapping must use the same values.\n pk-as-fk: The \"usePKasFK\" attribute is not yet supported.  Mapping your \\\n \tOneToOne using JoinColumns that match your id property columns will work.\n no-override-name: Missing \"name\" property on mapping override for \"{0}\"."}]}

