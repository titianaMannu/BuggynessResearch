{"sha":"17c6580e4ce21e706513f77586372d9bf257a244","node_id":"MDY6Q29tbWl0MjA2MzY0OjE3YzY1ODBlNGNlMjFlNzA2NTEzZjc3NTg2MzcyZDliZjI1N2EyNDQ=","commit":{"author":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-01-30T16:19:59Z"},"committer":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-01-30T16:19:59Z"},"message":"Changes for JIRA OPENJPA-116 issue.\n\nAdded a test to ensure that the EntityManager was still open before executing the getDelegate() code.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@501445 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"da38947c28a1ff09cd6f26cf3db2d0649daea9a2","url":"https://api.github.com/repos/apache/openjpa/git/trees/da38947c28a1ff09cd6f26cf3db2d0649daea9a2"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/17c6580e4ce21e706513f77586372d9bf257a244","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/17c6580e4ce21e706513f77586372d9bf257a244","html_url":"https://github.com/apache/openjpa/commit/17c6580e4ce21e706513f77586372d9bf257a244","comments_url":"https://api.github.com/repos/apache/openjpa/commits/17c6580e4ce21e706513f77586372d9bf257a244/comments","author":null,"committer":null,"parents":[{"sha":"e4bf0444a43d336d54f05765cef4bcc1ca623f04","url":"https://api.github.com/repos/apache/openjpa/commits/e4bf0444a43d336d54f05765cef4bcc1ca623f04","html_url":"https://github.com/apache/openjpa/commit/e4bf0444a43d336d54f05765cef4bcc1ca623f04"}],"stats":{"total":2217,"additions":1109,"deletions":1108},"files":[{"sha":"eae53b3c8615bb3a40a2a29047a8a6d33bd363c1","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":1109,"deletions":1108,"changes":2217,"blob_url":"https://github.com/apache/openjpa/blob/17c6580e4ce21e706513f77586372d9bf257a244/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/17c6580e4ce21e706513f77586372d9bf257a244/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=17c6580e4ce21e706513f77586372d9bf257a244","patch":"@@ -1,1108 +1,1109 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.persistence;\n-\n-import java.lang.reflect.Array;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityTransaction;\n-import javax.persistence.FlushModeType;\n-import javax.persistence.LockModeType;\n-import javax.persistence.Query;\n-import javax.resource.ResourceException;\n-import javax.resource.cci.ConnectionMetaData;\n-import javax.resource.cci.Interaction;\n-import javax.resource.cci.LocalTransaction;\n-import javax.resource.cci.ResultSetInfo;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.ee.ManagedRuntime;\n-import org.apache.openjpa.kernel.Broker;\n-import org.apache.openjpa.kernel.DelegatingBroker;\n-import org.apache.openjpa.kernel.FindCallbacks;\n-import org.apache.openjpa.kernel.LockLevels;\n-import org.apache.openjpa.kernel.OpCallbacks;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.kernel.QueryFlushModes;\n-import org.apache.openjpa.kernel.QueryLanguages;\n-import org.apache.openjpa.kernel.Seq;\n-import org.apache.openjpa.kernel.jpql.JPQLParser;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.QueryMetaData;\n-import org.apache.openjpa.meta.SequenceMetaData;\n-import org.apache.openjpa.util.Exceptions;\n-import org.apache.openjpa.util.ImplHelper;\n-import org.apache.openjpa.util.RuntimeExceptionTranslator;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Implementation of {@link EntityManager} interface.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class EntityManagerImpl\n-    implements OpenJPAEntityManager, FindCallbacks, OpCallbacks {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (EntityManagerImpl.class);\n-\n-    private final DelegatingBroker _broker;\n-    private final EntityManagerFactoryImpl _emf;\n-    private FetchPlan _fetch = null;\n-\n-    /**\n-     * Constructor; supply factory and delegate.\n-     */\n-    public EntityManagerImpl(EntityManagerFactoryImpl factory,\n-        Broker broker) {\n-        _emf = factory;\n-        RuntimeExceptionTranslator translator =\n-            PersistenceExceptions.getRollbackTranslator(this);\n-        _broker = new DelegatingBroker(broker, translator);\n-        _broker.setImplicitBehavior(this, translator);\n-    }\n-\n-    /**\n-     * Broker delegate.\n-     */\n-    public Broker getBroker() {\n-        return _broker.getDelegate();\n-    }\n-\n-    public ConnectionMetaData getMetaData()\n-        throws ResourceException {\n-        return _broker.getMetaData();\n-    }\n-\n-    public Interaction createInteraction()\n-        throws ResourceException {\n-        assertOpen();\n-        return _broker.createInteraction();\n-    }\n-\n-    public LocalTransaction getLocalTransaction()\n-        throws ResourceException {\n-        return this;\n-    }\n-\n-    public ResultSetInfo getResultSetInfo()\n-        throws ResourceException {\n-        return _broker.getResultSetInfo();\n-    }\n-\n-    public OpenJPAEntityManagerFactory getEntityManagerFactory() {\n-        return _emf;\n-    }\n-\n-    public OpenJPAConfiguration getConfiguration() {\n-        return _broker.getConfiguration();\n-    }\n-\n-    public FetchPlan getFetchPlan() {\n-        assertOpen();\n-        _broker.lock();\n-        try {\n-            if (_fetch == null)\n-                _fetch = _emf.toFetchPlan(_broker, \n-                    _broker.getFetchConfiguration());\n-            return _fetch;\n-        } finally {\n-            _broker.unlock();\n-        }\n-    }\n-\n-    public int getConnectionRetainMode() {\n-        return _broker.getConnectionRetainMode();\n-    }\n-\n-    public boolean isManaged() {\n-        return _broker.isManaged();\n-    }\n-\n-    public ManagedRuntime getManagedRuntime() {\n-        return _broker.getManagedRuntime();\n-    }\n-\n-    public boolean getSyncWithManagedTransactions() {\n-        return _broker.getSyncWithManagedTransactions();\n-    }\n-\n-    public void setSyncWithManagedTransactions(boolean sync) {\n-        assertOpen();\n-        _broker.setSyncWithManagedTransactions(sync);\n-    }\n-\n-    public ClassLoader getClassLoader() {\n-        return _broker.getClassLoader();\n-    }\n-\n-    public String getConnectionUserName() {\n-        return _broker.getConnectionUserName();\n-    }\n-\n-    public String getConnectionPassword() {\n-        return _broker.getConnectionPassword();\n-    }\n-\n-    public boolean getMultithreaded() {\n-        return _broker.getMultithreaded();\n-    }\n-\n-    public void setMultithreaded(boolean multithreaded) {\n-        assertOpen();\n-        _broker.setMultithreaded(multithreaded);\n-    }\n-\n-    public boolean getIgnoreChanges() {\n-        return _broker.getIgnoreChanges();\n-    }\n-\n-    public void setIgnoreChanges(boolean val) {\n-        assertOpen();\n-        _broker.setIgnoreChanges(val);\n-    }\n-\n-    public boolean getNontransactionalRead() {\n-        return _broker.getNontransactionalRead();\n-    }\n-\n-    public void setNontransactionalRead(boolean val) {\n-        assertOpen();\n-        _broker.setNontransactionalRead(val);\n-    }\n-\n-    public boolean getNontransactionalWrite() {\n-        return _broker.getNontransactionalWrite();\n-    }\n-\n-    public void setNontransactionalWrite(boolean val) {\n-        assertOpen();\n-        _broker.setNontransactionalWrite(val);\n-    }\n-\n-    public boolean getOptimistic() {\n-        return _broker.getOptimistic();\n-    }\n-\n-    public void setOptimistic(boolean val) {\n-        assertOpen();\n-        _broker.setOptimistic(val);\n-    }\n-\n-    public int getRestoreState() {\n-        return _broker.getRestoreState();\n-    }\n-\n-    public void setRestoreState(int val) {\n-        assertOpen();\n-        _broker.setRestoreState(val);\n-    }\n-\n-    public boolean getRetainState() {\n-        return _broker.getRetainState();\n-    }\n-\n-    public void setRetainState(boolean val) {\n-        assertOpen();\n-        _broker.setRetainState(val);\n-    }\n-\n-    public int getAutoClear() {\n-        return _broker.getAutoClear();\n-    }\n-\n-    public void setAutoClear(int val) {\n-        assertOpen();\n-        _broker.setAutoClear(val);\n-    }\n-\n-    public int getDetachState() {\n-        return _broker.getDetachState();\n-    }\n-\n-    public void setDetachState(int mode) {\n-        assertOpen();\n-        _broker.setDetachState(mode);\n-    }\n-\n-    public int getAutoDetach() {\n-        return _broker.getAutoDetach();\n-    }\n-\n-    public void setAutoDetach(int flags) {\n-        assertOpen();\n-        _broker.setAutoDetach(flags);\n-    }\n-\n-    public void setAutoDetach(int flag, boolean on) {\n-        assertOpen();\n-        _broker.setAutoDetach(flag, on);\n-    }\n-\n-    public boolean getEvictFromStoreCache() {\n-        return _broker.getEvictFromDataCache();\n-    }\n-\n-    public void setEvictFromStoreCache(boolean evict) {\n-        assertOpen();\n-        _broker.setEvictFromDataCache(evict);\n-    }\n-\n-    public boolean getPopulateStoreCache() {\n-        return _broker.getPopulateDataCache();\n-    }\n-\n-    public void setPopulateStoreCache(boolean cache) {\n-        assertOpen();\n-        _broker.setPopulateDataCache(cache);\n-    }\n-\n-    public boolean isLargeTransaction() {\n-        return _broker.isLargeTransaction();\n-    }\n-\n-    public void setLargeTransaction(boolean largeTransaction) {\n-        assertOpen();\n-        _broker.setLargeTransaction(largeTransaction);\n-    }\n-\n-    public Object getUserObject(Object key) {\n-        return _broker.getUserObject(key);\n-    }\n-\n-    public Object putUserObject(Object key, Object val) {\n-        assertOpen();\n-        return _broker.putUserObject(key, val);\n-    }\n-\n-    public void addTransactionListener(Object listener) {\n-        assertOpen();\n-        _broker.addTransactionListener(listener);\n-    }\n-\n-    public void removeTransactionListener(Object listener) {\n-        assertOpen();\n-        _broker.removeTransactionListener(listener);\n-    }\n-\n-    public int getTransactionListenerCallbackMode() {\n-        return _broker.getTransactionListenerCallbackMode();\n-    }\n-\n-    public void setTransactionListenerCallbackMode(int mode) {\n-        assertOpen();\n-        _broker.setTransactionListenerCallbackMode(mode);\n-    }\n-\n-    public void addLifecycleListener(Object listener, Class... classes) {\n-        assertOpen();\n-        _broker.addLifecycleListener(listener, classes);\n-    }\n-\n-    public void removeLifecycleListener(Object listener) {\n-        assertOpen();\n-        _broker.removeLifecycleListener(listener);\n-    }\n-\n-    public int getLifecycleListenerCallbackMode() {\n-        return _broker.getLifecycleListenerCallbackMode();\n-    }\n-\n-    public void setLifecycleListenerCallbackMode(int mode) {\n-        assertOpen();\n-        _broker.setLifecycleListenerCallbackMode(mode);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T getReference(Class<T> cls, Object oid) {\n-        assertOpen();\n-        oid = _broker.newObjectId(cls, oid);\n-        return (T) _broker.find(oid, false, this);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T find(Class<T> cls, Object oid) {\n-        assertOpen();\n-        oid = _broker.newObjectId(cls, oid);\n-        return (T) _broker.find(oid, true, this);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T[] findAll(Class<T> cls, Object... oids) {\n-        if (oids.length == 0)\n-            return (T[]) Array.newInstance(cls, 0);\n-        Collection<T> ret = findAll(cls, Arrays.asList(oids));\n-        return ret.toArray((T[]) Array.newInstance(cls, ret.size()));\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> Collection<T> findAll(final Class<T> cls, Collection oids) {\n-        assertOpen();\n-        Object[] objs = _broker.findAll(oids, true, new FindCallbacks() {\n-            public Object processArgument(Object oid) {\n-                return _broker.newObjectId(cls, oid);\n-            }\n-\n-            public Object processReturn(Object oid, OpenJPAStateManager sm) {\n-                return EntityManagerImpl.this.processReturn(oid, sm);\n-            }\n-        });\n-        return (Collection<T>) Arrays.asList(objs);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T findCached(Class<T> cls, Object oid) {\n-        assertOpen();\n-        return (T) _broker.findCached(_broker.newObjectId(cls, oid), this);\n-    }\n-\n-    public Class getObjectIdClass(Class cls) {\n-        assertOpen();\n-        if (cls == null)\n-            return null;\n-        return OpenJPAPersistence.fromOpenJPAObjectIdClass\n-                (_broker.getObjectIdType(cls));\n-    }\n-\n-    public EntityTransaction getTransaction() {\n-        if (_broker.isManaged())\n-            throw new InvalidStateException(_loc.get(\"get-managed-trans\"),\n-                null, null, false);\n-        return this;\n-    }\n-\n-    public void joinTransaction() {\n-        assertOpen();\n-        if (!_broker.syncWithManagedTransaction())\n-            throw new TransactionRequiredException(_loc.get\n-                (\"no-managed-trans\"), null, null, false);\n-    }\n-\n-    public void begin() {\n-        _broker.begin();\n-    }\n-\n-    public void commit() {\n-        try {\n-            _broker.commit();\n-        } catch (RollbackException e) {\n-            throw e;\n-        } catch (IllegalStateException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            // RollbackExceptions are special and aren't handled by the\n-            // normal exception translator, since the spec says they\n-            // should be thrown whenever the commit fails for any reason at\n-            // all, wheras the exception translator handles exceptions that\n-            // are caused for specific reasons\n-            throw new RollbackException(e);\n-        }\n-    }\n-\n-    public void rollback() {\n-        _broker.rollback();\n-    }\n-\n-    public void commitAndResume() {\n-        _broker.commitAndResume();\n-    }\n-\n-    public void rollbackAndResume() {\n-        _broker.rollbackAndResume();\n-    }\n-\n-    public boolean getRollbackOnly() {\n-        if (!isActive())\n-            throw new IllegalStateException(_loc.get(\"no-transaction\")\n-                .getMessage());\n-\n-        return _broker.getRollbackOnly();\n-    }\n-\n-    public void setRollbackOnly() {\n-        _broker.setRollbackOnly();\n-    }\n-\n-    public void setSavepoint(String name) {\n-        assertOpen();\n-        _broker.setSavepoint(name);\n-    }\n-\n-    public void rollbackToSavepoint() {\n-        assertOpen();\n-        _broker.rollbackToSavepoint();\n-    }\n-\n-    public void rollbackToSavepoint(String name) {\n-        assertOpen();\n-        _broker.rollbackToSavepoint(name);\n-    }\n-\n-    public void releaseSavepoint() {\n-        assertOpen();\n-        _broker.releaseSavepoint();\n-    }\n-\n-    public void releaseSavepoint(String name) {\n-        assertOpen();\n-        _broker.releaseSavepoint(name);\n-    }\n-\n-    public void flush() {\n-        assertOpen();\n-        _broker.assertActiveTransaction();\n-        _broker.flush();\n-    }\n-\n-    public void preFlush() {\n-        assertOpen();\n-        _broker.preFlush();\n-    }\n-\n-    public void validateChanges() {\n-        assertOpen();\n-        _broker.validateChanges();\n-    }\n-\n-    public boolean isActive() {\n-        return isOpen() && _broker.isActive();\n-    }\n-\n-    public boolean isStoreActive() {\n-        return _broker.isStoreActive();\n-    }\n-\n-    public void beginStore() {\n-        _broker.beginStore();\n-    }\n-\n-    public boolean contains(Object entity) {\n-        assertOpen();\n-        if (entity == null)\n-            return false;\n-        OpenJPAStateManager sm = _broker.getStateManager(entity);\n-        if (sm == null && !ImplHelper.isManagedType(entity.getClass()))\n-            throw new ArgumentException(_loc.get(\"not-entity\",\n-                entity.getClass()), null, null, true);\n-        return sm != null && !sm.isDeleted();\n-    }\n-\n-    public boolean containsAll(Object... entities) {\n-        for (Object entity : entities)\n-            if (!contains(entity))\n-                return false;\n-        return true;\n-    }\n-\n-    public boolean containsAll(Collection entities) {\n-        for (Object entity : entities)\n-            if (!contains(entity))\n-                return false;\n-        return true;\n-    }\n-\n-    public void persist(Object entity) {\n-        assertOpen();\n-        _broker.persist(entity, this);\n-    }\n-\n-    public void persistAll(Object... entities) {\n-        persistAll(Arrays.asList(entities));\n-    }\n-\n-    public void persistAll(Collection entities) {\n-        assertOpen();\n-        _broker.persistAll(entities, this);\n-    }\n-\n-    public void remove(Object entity) {\n-        assertOpen();\n-        _broker.delete(entity, this);\n-    }\n-\n-    public void removeAll(Object... entities) {\n-        removeAll(Arrays.asList(entities));\n-    }\n-\n-    public void removeAll(Collection entities) {\n-        assertOpen();\n-        _broker.deleteAll(entities, this);\n-    }\n-\n-    public void release(Object entity) {\n-        assertOpen();\n-        _broker.release(entity, this);\n-    }\n-\n-    public void releaseAll(Collection entities) {\n-        assertOpen();\n-        _broker.releaseAll(entities, this);\n-    }\n-\n-    public void releaseAll(Object... entities) {\n-        releaseAll(Arrays.asList(entities));\n-    }\n-\n-    public void refresh(Object entity) {\n-        assertOpen();\n-        _broker.assertWriteOperation();\n-        _broker.refresh(entity, this);\n-    }\n-\n-    public void refreshAll() {\n-        assertOpen();\n-        _broker.assertWriteOperation();\n-        _broker.refreshAll(_broker.getTransactionalObjects(), this);\n-    }\n-\n-    public void refreshAll(Collection entities) {\n-        assertOpen();\n-        _broker.assertWriteOperation();\n-        _broker.refreshAll(entities, this);\n-    }\n-\n-    public void refreshAll(Object... entities) {\n-        refreshAll(Arrays.asList(entities));\n-    }\n-\n-    public void retrieve(Object entity) {\n-        assertOpen();\n-        _broker.retrieve(entity, true, this);\n-    }\n-\n-    public void retrieveAll(Collection entities) {\n-        assertOpen();\n-        _broker.retrieveAll(entities, true, this);\n-    }\n-\n-    public void retrieveAll(Object... entities) {\n-        retrieveAll(Arrays.asList(entities));\n-    }\n-\n-    public void evict(Object entity) {\n-        assertOpen();\n-        _broker.evict(entity, this);\n-    }\n-\n-    public void evictAll(Collection entities) {\n-        assertOpen();\n-        _broker.evictAll(entities, this);\n-    }\n-\n-    public void evictAll(Object... entities) {\n-        evictAll(Arrays.asList(entities));\n-    }\n-\n-    public void evictAll() {\n-        assertOpen();\n-        _broker.evictAll(this);\n-    }\n-\n-    public void evictAll(Class cls) {\n-        assertOpen();\n-        _broker.evictAll(_broker.newExtent(cls, true), this);\n-    }\n-\n-    public void evictAll(Extent extent) {\n-        assertOpen();\n-        _broker.evictAll(extent.getDelegate(), this);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T detach(T entity) {\n-        assertOpen();\n-        return (T) _broker.detach(entity, this);\n-    }\n-\n-    public Object[] detachAll(Object... entities) {\n-        assertOpen();\n-        return _broker.detachAll(Arrays.asList(entities), this);\n-    }\n-\n-    public Collection detachAll(Collection entities) {\n-        assertOpen();\n-        return Arrays.asList(_broker.detachAll(entities, this));\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T merge(T entity) {\n-        assertOpen();\n-        return (T) _broker.attach(entity, true, this);\n-    }\n-\n-    public Object[] mergeAll(Object... entities) {\n-        if (entities.length == 0)\n-            return new Object[0];\n-        return mergeAll(Arrays.asList(entities)).toArray();\n-    }\n-\n-    public Collection mergeAll(Collection entities) {\n-        assertOpen();\n-        return Arrays.asList(_broker.attachAll(entities, true, this));\n-    }\n-\n-    public void transactional(Object entity, boolean updateVersion) {\n-        assertOpen();\n-        _broker.transactional(entity, updateVersion, this);\n-    }\n-\n-    public void transactionalAll(Collection objs, boolean updateVersion) {\n-        assertOpen();\n-        _broker.transactionalAll(objs, updateVersion, this);\n-    }\n-\n-    public void transactionalAll(Object[] objs, boolean updateVersion) {\n-        assertOpen();\n-        _broker.transactionalAll(Arrays.asList(objs), updateVersion, this);\n-    }\n-\n-    public void nontransactional(Object entity) {\n-        assertOpen();\n-        _broker.nontransactional(entity, this);\n-    }\n-\n-    public void nontransactionalAll(Collection objs) {\n-        assertOpen();\n-        _broker.nontransactionalAll(objs, this);\n-    }\n-\n-    public void nontransactionalAll(Object[] objs) {\n-        assertOpen();\n-        _broker.nontransactionalAll(Arrays.asList(objs), this);\n-    }\n-\n-    public Generator getNamedGenerator(String name) {\n-        assertOpen();\n-        try {\n-            SequenceMetaData meta = _broker.getConfiguration().\n-                getMetaDataRepositoryInstance().getSequenceMetaData(name,\n-                _broker.getClassLoader(), true);\n-            Seq seq = meta.getInstance(_broker.getClassLoader());\n-            return new GeneratorImpl(seq, name, _broker, null);\n-        } catch (RuntimeException re) {\n-            throw PersistenceExceptions.toPersistenceException(re);\n-        }\n-    }\n-\n-    public Generator getIdGenerator(Class forClass) {\n-        assertOpen();\n-        try {\n-            ClassMetaData meta = _broker.getConfiguration().\n-                getMetaDataRepositoryInstance().getMetaData(forClass,\n-                _broker.getClassLoader(), true);\n-            Seq seq = _broker.getIdentitySequence(meta);\n-            return (seq == null) ? null : new GeneratorImpl(seq, null, _broker,\n-                meta);\n-        } catch (Exception e) {\n-            throw PersistenceExceptions.toPersistenceException(e);\n-        }\n-    }\n-\n-    public Generator getFieldGenerator(Class forClass, String fieldName) {\n-        assertOpen();\n-        try {\n-            ClassMetaData meta = _broker.getConfiguration().\n-                getMetaDataRepositoryInstance().getMetaData(forClass,\n-                _broker.getClassLoader(), true);\n-            FieldMetaData fmd = meta.getField(fieldName);\n-            if (fmd == null)\n-                throw new ArgumentException(_loc.get(\"no-named-field\",\n-                    forClass, fieldName), null, null, false);\n-\n-            Seq seq = _broker.getValueSequence(fmd);\n-            return (seq == null) ? null : new GeneratorImpl(seq, null, _broker,\n-                meta);\n-        } catch (Exception e) {\n-            throw PersistenceExceptions.toPersistenceException(e);\n-        }\n-    }\n-\n-    public <T> Extent<T> createExtent(Class<T> cls, boolean subclasses) {\n-        assertOpen();\n-        return new ExtentImpl<T>(this, _broker.newExtent(cls, subclasses));\n-    }\n-\n-    public OpenJPAQuery createQuery(String query) {\n-        return createQuery(JPQLParser.LANG_JPQL, query);\n-    }\n-\n-    public OpenJPAQuery createQuery(String language, String query) {\n-        assertOpen();\n-        return new QueryImpl(this, _broker.newQuery(language, query));\n-    }\n-\n-    public OpenJPAQuery createQuery(Query query) {\n-        if (query == null)\n-            return createQuery((String) null);\n-        assertOpen();\n-        org.apache.openjpa.kernel.Query q = ((QueryImpl) query).getDelegate();\n-        return new QueryImpl(this, _broker.newQuery(q.getLanguage(),\n-            q));\n-    }\n-\n-    public OpenJPAQuery createNamedQuery(String name) {\n-        assertOpen();\n-        try {\n-            QueryMetaData meta = _broker.getConfiguration().\n-                getMetaDataRepositoryInstance().getQueryMetaData(null, name,\n-                _broker.getClassLoader(), true);\n-            org.apache.openjpa.kernel.Query del =\n-                _broker.newQuery(meta.getLanguage(), null);\n-            meta.setInto(del);\n-            del.compile();\n-\n-            OpenJPAQuery q = new QueryImpl(this, del);\n-            String[] hints = meta.getHintKeys();\n-            Object[] values = meta.getHintValues();\n-            for (int i = 0; i < hints.length; i++)\n-                q.setHint(hints[i], values[i]);\n-            return q;\n-        } catch (RuntimeException re) {\n-            throw PersistenceExceptions.toPersistenceException(re);\n-        }\n-    }\n-\n-    public OpenJPAQuery createNativeQuery(String query) {\n-        validateSQL(query);\n-        return createQuery(QueryLanguages.LANG_SQL, query);\n-    }\n-\n-    public OpenJPAQuery createNativeQuery(String query, Class cls) {\n-        return createNativeQuery(query).setResultClass(cls);\n-    }\n-\n-    public OpenJPAQuery createNativeQuery(String query, String mappingName) {\n-        assertOpen();\n-        validateSQL(query);\n-        org.apache.openjpa.kernel.Query kernelQuery = _broker.newQuery(\n-            QueryLanguages.LANG_SQL, query);\n-        kernelQuery.setResultMapping(null, mappingName);\n-        return new QueryImpl(this, kernelQuery);\n-    }\n-\n-    /**\n-     * Validate that the user provided SQL.\n-     */\n-    private static void validateSQL(String query) {\n-        if (StringUtils.trimToNull(query) == null)\n-            throw new ArgumentException(_loc.get(\"no-sql\"), null, null, false);\n-    }\n-\n-    public void setFlushMode(FlushModeType flushMode) {\n-        assertOpen();\n-        _broker.getFetchConfiguration().setFlushBeforeQueries\n-            (toFlushBeforeQueries(flushMode));\n-    }\n-\n-    public FlushModeType getFlushMode() {\n-        assertOpen();\n-        return fromFlushBeforeQueries(_broker.getFetchConfiguration().\n-            getFlushBeforeQueries());\n-    }\n-\n-    /**\n-     * Translate our internal flush constant to a flush mode enum value.\n-     */\n-    static FlushModeType fromFlushBeforeQueries(int flush) {\n-        switch (flush) {\n-            case QueryFlushModes.FLUSH_TRUE:\n-                return FlushModeType.AUTO;\n-            case QueryFlushModes.FLUSH_FALSE:\n-                return FlushModeType.COMMIT;\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    /**\n-     * Translate a flush mode enum value to our internal flush constant.\n-     */\n-    static int toFlushBeforeQueries(FlushModeType flushMode) {\n-        // choose default for null\n-        if (flushMode == null)\n-            return QueryFlushModes.FLUSH_WITH_CONNECTION;\n-        if (flushMode == FlushModeType.AUTO)\n-            return QueryFlushModes.FLUSH_TRUE;\n-        if (flushMode == FlushModeType.COMMIT)\n-            return QueryFlushModes.FLUSH_FALSE;\n-        throw new ArgumentException(flushMode.toString(), null, null, false);\n-    }\n-\n-    public void clear() {\n-        assertOpen();\n-        _broker.detachAll(this);\n-    }\n-\n-    public Object getDelegate() {\n-        return this;\n-    }\n-\n-    public LockModeType getLockMode(Object entity) {\n-        assertOpen();\n-        return fromLockLevel(_broker.getLockLevel(entity));\n-    }\n-\n-    public void lock(Object entity, LockModeType mode) {\n-        assertOpen();\n-        _broker.lock(entity, toLockLevel(mode), -1, this);\n-    }\n-\n-    public void lock(Object entity) {\n-        assertOpen();\n-        _broker.lock(entity, this);\n-    }\n-\n-    public void lock(Object entity, LockModeType mode, int timeout) {\n-        assertOpen();\n-        _broker.lock(entity, toLockLevel(mode), timeout, this);\n-    }\n-\n-    public void lockAll(Collection entities) {\n-        assertOpen();\n-        _broker.lockAll(entities, this);\n-    }\n-\n-    public void lockAll(Collection entities, LockModeType mode, int timeout) {\n-        assertOpen();\n-        _broker.lockAll(entities, toLockLevel(mode), timeout, this);\n-    }\n-\n-    public void lockAll(Object... entities) {\n-        lockAll(Arrays.asList(entities));\n-    }\n-\n-    public void lockAll(Object[] entities, LockModeType mode, int timeout) {\n-        lockAll(Arrays.asList(entities), mode, timeout);\n-    }\n-\n-    /**\n-     * Translate our internal lock level to a javax.persistence enum value.\n-     */\n-    static LockModeType fromLockLevel(int level) {\n-        if (level < LockLevels.LOCK_READ)\n-            return null;\n-        if (level < LockLevels.LOCK_WRITE)\n-            return LockModeType.READ;\n-        return LockModeType.WRITE;\n-    }\n-\n-    /**\n-     * Translate the javax.persistence enum value to our internal lock level.\n-     */\n-    static int toLockLevel(LockModeType mode) {\n-        if (mode == null)\n-            return LockLevels.LOCK_NONE;\n-        if (mode == LockModeType.READ)\n-            return LockLevels.LOCK_READ;\n-        if (mode == LockModeType.WRITE)\n-            return LockLevels.LOCK_WRITE;\n-        throw new ArgumentException(mode.toString(), null, null, true);\n-    }\n-\n-    public boolean cancelAll() {\n-        return _broker.cancelAll();\n-    }\n-\n-    public Object getConnection() {\n-        return _broker.getConnection();\n-    }\n-\n-    public Collection getManagedObjects() {\n-        return _broker.getManagedObjects();\n-    }\n-\n-    public Collection getTransactionalObjects() {\n-        return _broker.getTransactionalObjects();\n-    }\n-\n-    public Collection getPendingTransactionalObjects() {\n-        return _broker.getPendingTransactionalObjects();\n-    }\n-\n-    public Collection getDirtyObjects() {\n-        return _broker.getDirtyObjects();\n-    }\n-\n-    public boolean getOrderDirtyObjects() {\n-        return _broker.getOrderDirtyObjects();\n-    }\n-\n-    public void setOrderDirtyObjects(boolean order) {\n-        assertOpen();\n-        _broker.setOrderDirtyObjects(order);\n-    }\n-\n-    public void dirtyClass(Class cls) {\n-        assertOpen();\n-        _broker.dirtyType(cls);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<Class> getPersistedClasses() {\n-        return (Collection<Class>) _broker.getPersistedTypes();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<Class> getUpdatedClasses() {\n-        return (Collection<Class>) _broker.getUpdatedTypes();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<Class> getRemovedClasses() {\n-        return (Collection<Class>) _broker.getDeletedTypes();\n-    }\n-\n-    public <T> T createInstance(Class<T> cls) {\n-        assertOpen();\n-        return (T) _broker.newInstance(cls);\n-    }\n-\n-    public void close() {\n-        assertOpen();\n-        _broker.close();\n-    }\n-\n-    public boolean isOpen() {\n-        return !_broker.isCloseInvoked();\n-    }\n-\n-    public void dirty(Object o, String field) {\n-        assertOpen();\n-        OpenJPAStateManager sm = _broker.getStateManager(o);\n-        try {\n-            if (sm != null)\n-                sm.dirty(field);\n-        } catch (Exception e) {\n-            throw PersistenceExceptions.toPersistenceException(e);\n-        }\n-    }\n-\n-    public Object getObjectId(Object o) {\n-        assertOpen();\n-        return OpenJPAPersistence.fromOpenJPAObjectId(_broker.getObjectId(o));\n-    }\n-\n-    public boolean isDirty(Object o) {\n-        assertOpen();\n-        return _broker.isDirty(o);\n-    }\n-\n-    public boolean isTransactional(Object o) {\n-        assertOpen();\n-        return _broker.isTransactional(o);\n-    }\n-\n-    public boolean isPersistent(Object o) {\n-        assertOpen();\n-        return _broker.isPersistent(o);\n-    }\n-\n-    public boolean isNewlyPersistent(Object o) {\n-        assertOpen();\n-        return _broker.isNew(o);\n-    }\n-\n-    public boolean isRemoved(Object o) {\n-        assertOpen();\n-        return _broker.isDeleted(o);\n-    }\n-\n-    public boolean isDetached(Object entity) {\n-        assertOpen();\n-        return _broker.isDetached(entity);\n-    }\n-\n-    public Object getVersion(Object o) {\n-        assertOpen();\n-        return _broker.getVersion(o);\n-    }\n-\n-    /**\n-     * Throw appropriate exception if entity manager is closed.\n-     */\n-    void assertOpen() {\n-        // only throw when broker wouldn't throw anyway, because we prefer\n-        // the broker's more detailed exception when available\n-        if (!_broker.isClosed() && _broker.isCloseInvoked())\n-            throw new InvalidStateException(_loc.get(\"close-invoked\"), null,\n-                null, true);\n-    }\n-\n-    ////////////////////////////////\n-    // FindCallbacks implementation\n-    ////////////////////////////////\n-\n-    public Object processArgument(Object arg) {\n-        return arg;\n-    }\n-\n-    public Object processReturn(Object oid, OpenJPAStateManager sm) {\n-        return (sm == null || sm.isDeleted()) ? null : sm.getManagedInstance();\n-    }\n-\n-    //////////////////////////////\n-    // OpCallbacks implementation\n-    //////////////////////////////\n-\n-    public int processArgument(int op, Object obj, OpenJPAStateManager sm) {\n-        switch (op) {\n-            case OP_DELETE:\n-                // cascade through non-persistent non-detached instances\n-                if (sm == null && !_broker.isDetached(obj))\n-                    return ACT_CASCADE;\n-                if (sm != null && !sm.isDetached() && !sm.isPersistent())\n-                    return ACT_CASCADE;\n-                // ignore deleted instances\n-                if (sm != null && sm.isDeleted())\n-                    return ACT_NONE;\n-                break;\n-            case OP_ATTACH:\n-                // die on removed\n-                if (sm != null && sm.isDeleted())\n-                    throw new UserException(_loc.get(\"removed\",\n-                        Exceptions.toString(obj))).setFailedObject(obj);\n-                // cascade through managed instances\n-                if (sm != null && !sm.isDetached())\n-                    return ACT_CASCADE;\n-                break;\n-            case OP_REFRESH:\n-                // die on unmanaged instances\n-                if (sm == null)\n-                    throw new UserException(_loc.get(\"not-managed\",\n-                        Exceptions.toString(obj))).setFailedObject(obj);\n-                break;\n-        }\n-        return ACT_RUN | ACT_CASCADE;\n-    }\n-\n-    public int hashCode() {\n-        return _broker.hashCode();\n-    }\n-\n-    public boolean equals(Object other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof EntityManagerImpl))\n-            return false;\n-        return _broker.equals(((EntityManagerImpl) other)._broker);\n-\t}\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityTransaction;\r\n+import javax.persistence.FlushModeType;\r\n+import javax.persistence.LockModeType;\r\n+import javax.persistence.Query;\r\n+import javax.resource.ResourceException;\r\n+import javax.resource.cci.ConnectionMetaData;\r\n+import javax.resource.cci.Interaction;\r\n+import javax.resource.cci.LocalTransaction;\r\n+import javax.resource.cci.ResultSetInfo;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.DelegatingBroker;\r\n+import org.apache.openjpa.kernel.FindCallbacks;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.OpCallbacks;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.QueryFlushModes;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.jpql.JPQLParser;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.QueryMetaData;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Implementation of {@link EntityManager} interface.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class EntityManagerImpl\r\n+    implements OpenJPAEntityManager, FindCallbacks, OpCallbacks {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (EntityManagerImpl.class);\r\n+\r\n+    private final DelegatingBroker _broker;\r\n+    private final EntityManagerFactoryImpl _emf;\r\n+    private FetchPlan _fetch = null;\r\n+\r\n+    /**\r\n+     * Constructor; supply factory and delegate.\r\n+     */\r\n+    public EntityManagerImpl(EntityManagerFactoryImpl factory,\r\n+        Broker broker) {\r\n+        _emf = factory;\r\n+        RuntimeExceptionTranslator translator =\r\n+            PersistenceExceptions.getRollbackTranslator(this);\r\n+        _broker = new DelegatingBroker(broker, translator);\r\n+        _broker.setImplicitBehavior(this, translator);\r\n+    }\r\n+\r\n+    /**\r\n+     * Broker delegate.\r\n+     */\r\n+    public Broker getBroker() {\r\n+        return _broker.getDelegate();\r\n+    }\r\n+\r\n+    public ConnectionMetaData getMetaData()\r\n+        throws ResourceException {\r\n+        return _broker.getMetaData();\r\n+    }\r\n+\r\n+    public Interaction createInteraction()\r\n+        throws ResourceException {\r\n+        assertOpen();\r\n+        return _broker.createInteraction();\r\n+    }\r\n+\r\n+    public LocalTransaction getLocalTransaction()\r\n+        throws ResourceException {\r\n+        return this;\r\n+    }\r\n+\r\n+    public ResultSetInfo getResultSetInfo()\r\n+        throws ResourceException {\r\n+        return _broker.getResultSetInfo();\r\n+    }\r\n+\r\n+    public OpenJPAEntityManagerFactory getEntityManagerFactory() {\r\n+        return _emf;\r\n+    }\r\n+\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _broker.getConfiguration();\r\n+    }\r\n+\r\n+    public FetchPlan getFetchPlan() {\r\n+        assertOpen();\r\n+        _broker.lock();\r\n+        try {\r\n+            if (_fetch == null)\r\n+                _fetch = _emf.toFetchPlan(_broker,\r\n+                    _broker.getFetchConfiguration());\r\n+            return _fetch;\r\n+        } finally {\r\n+            _broker.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public int getConnectionRetainMode() {\r\n+        return _broker.getConnectionRetainMode();\r\n+    }\r\n+\r\n+    public boolean isManaged() {\r\n+        return _broker.isManaged();\r\n+    }\r\n+\r\n+    public ManagedRuntime getManagedRuntime() {\r\n+        return _broker.getManagedRuntime();\r\n+    }\r\n+\r\n+    public boolean getSyncWithManagedTransactions() {\r\n+        return _broker.getSyncWithManagedTransactions();\r\n+    }\r\n+\r\n+    public void setSyncWithManagedTransactions(boolean sync) {\r\n+        assertOpen();\r\n+        _broker.setSyncWithManagedTransactions(sync);\r\n+    }\r\n+\r\n+    public ClassLoader getClassLoader() {\r\n+        return _broker.getClassLoader();\r\n+    }\r\n+\r\n+    public String getConnectionUserName() {\r\n+        return _broker.getConnectionUserName();\r\n+    }\r\n+\r\n+    public String getConnectionPassword() {\r\n+        return _broker.getConnectionPassword();\r\n+    }\r\n+\r\n+    public boolean getMultithreaded() {\r\n+        return _broker.getMultithreaded();\r\n+    }\r\n+\r\n+    public void setMultithreaded(boolean multithreaded) {\r\n+        assertOpen();\r\n+        _broker.setMultithreaded(multithreaded);\r\n+    }\r\n+\r\n+    public boolean getIgnoreChanges() {\r\n+        return _broker.getIgnoreChanges();\r\n+    }\r\n+\r\n+    public void setIgnoreChanges(boolean val) {\r\n+        assertOpen();\r\n+        _broker.setIgnoreChanges(val);\r\n+    }\r\n+\r\n+    public boolean getNontransactionalRead() {\r\n+        return _broker.getNontransactionalRead();\r\n+    }\r\n+\r\n+    public void setNontransactionalRead(boolean val) {\r\n+        assertOpen();\r\n+        _broker.setNontransactionalRead(val);\r\n+    }\r\n+\r\n+    public boolean getNontransactionalWrite() {\r\n+        return _broker.getNontransactionalWrite();\r\n+    }\r\n+\r\n+    public void setNontransactionalWrite(boolean val) {\r\n+        assertOpen();\r\n+        _broker.setNontransactionalWrite(val);\r\n+    }\r\n+\r\n+    public boolean getOptimistic() {\r\n+        return _broker.getOptimistic();\r\n+    }\r\n+\r\n+    public void setOptimistic(boolean val) {\r\n+        assertOpen();\r\n+        _broker.setOptimistic(val);\r\n+    }\r\n+\r\n+    public int getRestoreState() {\r\n+        return _broker.getRestoreState();\r\n+    }\r\n+\r\n+    public void setRestoreState(int val) {\r\n+        assertOpen();\r\n+        _broker.setRestoreState(val);\r\n+    }\r\n+\r\n+    public boolean getRetainState() {\r\n+        return _broker.getRetainState();\r\n+    }\r\n+\r\n+    public void setRetainState(boolean val) {\r\n+        assertOpen();\r\n+        _broker.setRetainState(val);\r\n+    }\r\n+\r\n+    public int getAutoClear() {\r\n+        return _broker.getAutoClear();\r\n+    }\r\n+\r\n+    public void setAutoClear(int val) {\r\n+        assertOpen();\r\n+        _broker.setAutoClear(val);\r\n+    }\r\n+\r\n+    public int getDetachState() {\r\n+        return _broker.getDetachState();\r\n+    }\r\n+\r\n+    public void setDetachState(int mode) {\r\n+        assertOpen();\r\n+        _broker.setDetachState(mode);\r\n+    }\r\n+\r\n+    public int getAutoDetach() {\r\n+        return _broker.getAutoDetach();\r\n+    }\r\n+\r\n+    public void setAutoDetach(int flags) {\r\n+        assertOpen();\r\n+        _broker.setAutoDetach(flags);\r\n+    }\r\n+\r\n+    public void setAutoDetach(int flag, boolean on) {\r\n+        assertOpen();\r\n+        _broker.setAutoDetach(flag, on);\r\n+    }\r\n+\r\n+    public boolean getEvictFromStoreCache() {\r\n+        return _broker.getEvictFromDataCache();\r\n+    }\r\n+\r\n+    public void setEvictFromStoreCache(boolean evict) {\r\n+        assertOpen();\r\n+        _broker.setEvictFromDataCache(evict);\r\n+    }\r\n+\r\n+    public boolean getPopulateStoreCache() {\r\n+        return _broker.getPopulateDataCache();\r\n+    }\r\n+\r\n+    public void setPopulateStoreCache(boolean cache) {\r\n+        assertOpen();\r\n+        _broker.setPopulateDataCache(cache);\r\n+    }\r\n+\r\n+    public boolean isLargeTransaction() {\r\n+        return _broker.isLargeTransaction();\r\n+    }\r\n+\r\n+    public void setLargeTransaction(boolean largeTransaction) {\r\n+        assertOpen();\r\n+        _broker.setLargeTransaction(largeTransaction);\r\n+    }\r\n+\r\n+    public Object getUserObject(Object key) {\r\n+        return _broker.getUserObject(key);\r\n+    }\r\n+\r\n+    public Object putUserObject(Object key, Object val) {\r\n+        assertOpen();\r\n+        return _broker.putUserObject(key, val);\r\n+    }\r\n+\r\n+    public void addTransactionListener(Object listener) {\r\n+        assertOpen();\r\n+        _broker.addTransactionListener(listener);\r\n+    }\r\n+\r\n+    public void removeTransactionListener(Object listener) {\r\n+        assertOpen();\r\n+        _broker.removeTransactionListener(listener);\r\n+    }\r\n+\r\n+    public int getTransactionListenerCallbackMode() {\r\n+        return _broker.getTransactionListenerCallbackMode();\r\n+    }\r\n+\r\n+    public void setTransactionListenerCallbackMode(int mode) {\r\n+        assertOpen();\r\n+        _broker.setTransactionListenerCallbackMode(mode);\r\n+    }\r\n+\r\n+    public void addLifecycleListener(Object listener, Class... classes) {\r\n+        assertOpen();\r\n+        _broker.addLifecycleListener(listener, classes);\r\n+    }\r\n+\r\n+    public void removeLifecycleListener(Object listener) {\r\n+        assertOpen();\r\n+        _broker.removeLifecycleListener(listener);\r\n+    }\r\n+\r\n+    public int getLifecycleListenerCallbackMode() {\r\n+        return _broker.getLifecycleListenerCallbackMode();\r\n+    }\r\n+\r\n+    public void setLifecycleListenerCallbackMode(int mode) {\r\n+        assertOpen();\r\n+        _broker.setLifecycleListenerCallbackMode(mode);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T getReference(Class<T> cls, Object oid) {\r\n+        assertOpen();\r\n+        oid = _broker.newObjectId(cls, oid);\r\n+        return (T) _broker.find(oid, false, this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T find(Class<T> cls, Object oid) {\r\n+        assertOpen();\r\n+        oid = _broker.newObjectId(cls, oid);\r\n+        return (T) _broker.find(oid, true, this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T[] findAll(Class<T> cls, Object... oids) {\r\n+        if (oids.length == 0)\r\n+            return (T[]) Array.newInstance(cls, 0);\r\n+        Collection<T> ret = findAll(cls, Arrays.asList(oids));\r\n+        return ret.toArray((T[]) Array.newInstance(cls, ret.size()));\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> Collection<T> findAll(final Class<T> cls, Collection oids) {\r\n+        assertOpen();\r\n+        Object[] objs = _broker.findAll(oids, true, new FindCallbacks() {\r\n+            public Object processArgument(Object oid) {\r\n+                return _broker.newObjectId(cls, oid);\r\n+            }\r\n+\r\n+            public Object processReturn(Object oid, OpenJPAStateManager sm) {\r\n+                return EntityManagerImpl.this.processReturn(oid, sm);\r\n+            }\r\n+        });\r\n+        return (Collection<T>) Arrays.asList(objs);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T findCached(Class<T> cls, Object oid) {\r\n+        assertOpen();\r\n+        return (T) _broker.findCached(_broker.newObjectId(cls, oid), this);\r\n+    }\r\n+\r\n+    public Class getObjectIdClass(Class cls) {\r\n+        assertOpen();\r\n+        if (cls == null)\r\n+            return null;\r\n+        return OpenJPAPersistence.fromOpenJPAObjectIdClass\r\n+                (_broker.getObjectIdType(cls));\r\n+    }\r\n+\r\n+    public EntityTransaction getTransaction() {\r\n+        if (_broker.isManaged())\r\n+            throw new InvalidStateException(_loc.get(\"get-managed-trans\"),\r\n+                null, null, false);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void joinTransaction() {\r\n+        assertOpen();\r\n+        if (!_broker.syncWithManagedTransaction())\r\n+            throw new TransactionRequiredException(_loc.get\r\n+                (\"no-managed-trans\"), null, null, false);\r\n+    }\r\n+\r\n+    public void begin() {\r\n+        _broker.begin();\r\n+    }\r\n+\r\n+    public void commit() {\r\n+        try {\r\n+            _broker.commit();\r\n+        } catch (RollbackException e) {\r\n+            throw e;\r\n+        } catch (IllegalStateException e) {\r\n+            throw e;\r\n+        } catch (Exception e) {\r\n+            // RollbackExceptions are special and aren't handled by the\r\n+            // normal exception translator, since the spec says they\r\n+            // should be thrown whenever the commit fails for any reason at\r\n+            // all, wheras the exception translator handles exceptions that\r\n+            // are caused for specific reasons\r\n+            throw new RollbackException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public void rollback() {\r\n+        _broker.rollback();\r\n+    }\r\n+\r\n+    public void commitAndResume() {\r\n+        _broker.commitAndResume();\r\n+    }\r\n+\r\n+    public void rollbackAndResume() {\r\n+        _broker.rollbackAndResume();\r\n+    }\r\n+\r\n+    public boolean getRollbackOnly() {\r\n+        if (!isActive())\r\n+            throw new IllegalStateException(_loc.get(\"no-transaction\")\r\n+                .getMessage());\r\n+\r\n+        return _broker.getRollbackOnly();\r\n+    }\r\n+\r\n+    public void setRollbackOnly() {\r\n+        _broker.setRollbackOnly();\r\n+    }\r\n+\r\n+    public void setSavepoint(String name) {\r\n+        assertOpen();\r\n+        _broker.setSavepoint(name);\r\n+    }\r\n+\r\n+    public void rollbackToSavepoint() {\r\n+        assertOpen();\r\n+        _broker.rollbackToSavepoint();\r\n+    }\r\n+\r\n+    public void rollbackToSavepoint(String name) {\r\n+        assertOpen();\r\n+        _broker.rollbackToSavepoint(name);\r\n+    }\r\n+\r\n+    public void releaseSavepoint() {\r\n+        assertOpen();\r\n+        _broker.releaseSavepoint();\r\n+    }\r\n+\r\n+    public void releaseSavepoint(String name) {\r\n+        assertOpen();\r\n+        _broker.releaseSavepoint(name);\r\n+    }\r\n+\r\n+    public void flush() {\r\n+        assertOpen();\r\n+        _broker.assertActiveTransaction();\r\n+        _broker.flush();\r\n+    }\r\n+\r\n+    public void preFlush() {\r\n+        assertOpen();\r\n+        _broker.preFlush();\r\n+    }\r\n+\r\n+    public void validateChanges() {\r\n+        assertOpen();\r\n+        _broker.validateChanges();\r\n+    }\r\n+\r\n+    public boolean isActive() {\r\n+        return isOpen() && _broker.isActive();\r\n+    }\r\n+\r\n+    public boolean isStoreActive() {\r\n+        return _broker.isStoreActive();\r\n+    }\r\n+\r\n+    public void beginStore() {\r\n+        _broker.beginStore();\r\n+    }\r\n+\r\n+    public boolean contains(Object entity) {\r\n+        assertOpen();\r\n+        if (entity == null)\r\n+            return false;\r\n+        OpenJPAStateManager sm = _broker.getStateManager(entity);\r\n+        if (sm == null && !ImplHelper.isManagedType(entity.getClass()))\r\n+            throw new ArgumentException(_loc.get(\"not-entity\",\r\n+                entity.getClass()), null, null, true);\r\n+        return sm != null && !sm.isDeleted();\r\n+    }\r\n+\r\n+    public boolean containsAll(Object... entities) {\r\n+        for (Object entity : entities)\r\n+            if (!contains(entity))\r\n+                return false;\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean containsAll(Collection entities) {\r\n+        for (Object entity : entities)\r\n+            if (!contains(entity))\r\n+                return false;\r\n+        return true;\r\n+    }\r\n+\r\n+    public void persist(Object entity) {\r\n+        assertOpen();\r\n+        _broker.persist(entity, this);\r\n+    }\r\n+\r\n+    public void persistAll(Object... entities) {\r\n+        persistAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void persistAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.persistAll(entities, this);\r\n+    }\r\n+\r\n+    public void remove(Object entity) {\r\n+        assertOpen();\r\n+        _broker.delete(entity, this);\r\n+    }\r\n+\r\n+    public void removeAll(Object... entities) {\r\n+        removeAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void removeAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.deleteAll(entities, this);\r\n+    }\r\n+\r\n+    public void release(Object entity) {\r\n+        assertOpen();\r\n+        _broker.release(entity, this);\r\n+    }\r\n+\r\n+    public void releaseAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.releaseAll(entities, this);\r\n+    }\r\n+\r\n+    public void releaseAll(Object... entities) {\r\n+        releaseAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void refresh(Object entity) {\r\n+        assertOpen();\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refresh(entity, this);\r\n+    }\r\n+\r\n+    public void refreshAll() {\r\n+        assertOpen();\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refreshAll(_broker.getTransactionalObjects(), this);\r\n+    }\r\n+\r\n+    public void refreshAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refreshAll(entities, this);\r\n+    }\r\n+\r\n+    public void refreshAll(Object... entities) {\r\n+        refreshAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void retrieve(Object entity) {\r\n+        assertOpen();\r\n+        _broker.retrieve(entity, true, this);\r\n+    }\r\n+\r\n+    public void retrieveAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.retrieveAll(entities, true, this);\r\n+    }\r\n+\r\n+    public void retrieveAll(Object... entities) {\r\n+        retrieveAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void evict(Object entity) {\r\n+        assertOpen();\r\n+        _broker.evict(entity, this);\r\n+    }\r\n+\r\n+    public void evictAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.evictAll(entities, this);\r\n+    }\r\n+\r\n+    public void evictAll(Object... entities) {\r\n+        evictAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void evictAll() {\r\n+        assertOpen();\r\n+        _broker.evictAll(this);\r\n+    }\r\n+\r\n+    public void evictAll(Class cls) {\r\n+        assertOpen();\r\n+        _broker.evictAll(_broker.newExtent(cls, true), this);\r\n+    }\r\n+\r\n+    public void evictAll(Extent extent) {\r\n+        assertOpen();\r\n+        _broker.evictAll(extent.getDelegate(), this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T detach(T entity) {\r\n+        assertOpen();\r\n+        return (T) _broker.detach(entity, this);\r\n+    }\r\n+\r\n+    public Object[] detachAll(Object... entities) {\r\n+        assertOpen();\r\n+        return _broker.detachAll(Arrays.asList(entities), this);\r\n+    }\r\n+\r\n+    public Collection detachAll(Collection entities) {\r\n+        assertOpen();\r\n+        return Arrays.asList(_broker.detachAll(entities, this));\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T merge(T entity) {\r\n+        assertOpen();\r\n+        return (T) _broker.attach(entity, true, this);\r\n+    }\r\n+\r\n+    public Object[] mergeAll(Object... entities) {\r\n+        if (entities.length == 0)\r\n+            return new Object[0];\r\n+        return mergeAll(Arrays.asList(entities)).toArray();\r\n+    }\r\n+\r\n+    public Collection mergeAll(Collection entities) {\r\n+        assertOpen();\r\n+        return Arrays.asList(_broker.attachAll(entities, true, this));\r\n+    }\r\n+\r\n+    public void transactional(Object entity, boolean updateVersion) {\r\n+        assertOpen();\r\n+        _broker.transactional(entity, updateVersion, this);\r\n+    }\r\n+\r\n+    public void transactionalAll(Collection objs, boolean updateVersion) {\r\n+        assertOpen();\r\n+        _broker.transactionalAll(objs, updateVersion, this);\r\n+    }\r\n+\r\n+    public void transactionalAll(Object[] objs, boolean updateVersion) {\r\n+        assertOpen();\r\n+        _broker.transactionalAll(Arrays.asList(objs), updateVersion, this);\r\n+    }\r\n+\r\n+    public void nontransactional(Object entity) {\r\n+        assertOpen();\r\n+        _broker.nontransactional(entity, this);\r\n+    }\r\n+\r\n+    public void nontransactionalAll(Collection objs) {\r\n+        assertOpen();\r\n+        _broker.nontransactionalAll(objs, this);\r\n+    }\r\n+\r\n+    public void nontransactionalAll(Object[] objs) {\r\n+        assertOpen();\r\n+        _broker.nontransactionalAll(Arrays.asList(objs), this);\r\n+    }\r\n+\r\n+    public Generator getNamedGenerator(String name) {\r\n+        assertOpen();\r\n+        try {\r\n+            SequenceMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepositoryInstance().getSequenceMetaData(name,\r\n+                _broker.getClassLoader(), true);\r\n+            Seq seq = meta.getInstance(_broker.getClassLoader());\r\n+            return new GeneratorImpl(seq, name, _broker, null);\r\n+        } catch (RuntimeException re) {\r\n+            throw PersistenceExceptions.toPersistenceException(re);\r\n+        }\r\n+    }\r\n+\r\n+    public Generator getIdGenerator(Class forClass) {\r\n+        assertOpen();\r\n+        try {\r\n+            ClassMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepositoryInstance().getMetaData(forClass,\r\n+                _broker.getClassLoader(), true);\r\n+            Seq seq = _broker.getIdentitySequence(meta);\r\n+            return (seq == null) ? null : new GeneratorImpl(seq, null, _broker,\r\n+                meta);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public Generator getFieldGenerator(Class forClass, String fieldName) {\r\n+        assertOpen();\r\n+        try {\r\n+            ClassMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepositoryInstance().getMetaData(forClass,\r\n+                _broker.getClassLoader(), true);\r\n+            FieldMetaData fmd = meta.getField(fieldName);\r\n+            if (fmd == null)\r\n+                throw new ArgumentException(_loc.get(\"no-named-field\",\r\n+                    forClass, fieldName), null, null, false);\r\n+\r\n+            Seq seq = _broker.getValueSequence(fmd);\r\n+            return (seq == null) ? null : new GeneratorImpl(seq, null, _broker,\r\n+                meta);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public <T> Extent<T> createExtent(Class<T> cls, boolean subclasses) {\r\n+        assertOpen();\r\n+        return new ExtentImpl<T>(this, _broker.newExtent(cls, subclasses));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(String query) {\r\n+        return createQuery(JPQLParser.LANG_JPQL, query);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(String language, String query) {\r\n+        assertOpen();\r\n+        return new QueryImpl(this, _broker.newQuery(language, query));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(Query query) {\r\n+        if (query == null)\r\n+            return createQuery((String) null);\r\n+        assertOpen();\r\n+        org.apache.openjpa.kernel.Query q = ((QueryImpl) query).getDelegate();\r\n+        return new QueryImpl(this, _broker.newQuery(q.getLanguage(),\r\n+            q));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNamedQuery(String name) {\r\n+        assertOpen();\r\n+        try {\r\n+            QueryMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepositoryInstance().getQueryMetaData(null, name,\r\n+                _broker.getClassLoader(), true);\r\n+            org.apache.openjpa.kernel.Query del =\r\n+                _broker.newQuery(meta.getLanguage(), null);\r\n+            meta.setInto(del);\r\n+            del.compile();\r\n+\r\n+            OpenJPAQuery q = new QueryImpl(this, del);\r\n+            String[] hints = meta.getHintKeys();\r\n+            Object[] values = meta.getHintValues();\r\n+            for (int i = 0; i < hints.length; i++)\r\n+                q.setHint(hints[i], values[i]);\r\n+            return q;\r\n+        } catch (RuntimeException re) {\r\n+            throw PersistenceExceptions.toPersistenceException(re);\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query) {\r\n+        validateSQL(query);\r\n+        return createQuery(QueryLanguages.LANG_SQL, query);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query, Class cls) {\r\n+        return createNativeQuery(query).setResultClass(cls);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query, String mappingName) {\r\n+        assertOpen();\r\n+        validateSQL(query);\r\n+        org.apache.openjpa.kernel.Query kernelQuery = _broker.newQuery(\r\n+            QueryLanguages.LANG_SQL, query);\r\n+        kernelQuery.setResultMapping(null, mappingName);\r\n+        return new QueryImpl(this, kernelQuery);\r\n+    }\r\n+\r\n+    /**\r\n+     * Validate that the user provided SQL.\r\n+     */\r\n+    private static void validateSQL(String query) {\r\n+        if (StringUtils.trimToNull(query) == null)\r\n+            throw new ArgumentException(_loc.get(\"no-sql\"), null, null, false);\r\n+    }\r\n+\r\n+    public void setFlushMode(FlushModeType flushMode) {\r\n+        assertOpen();\r\n+        _broker.getFetchConfiguration().setFlushBeforeQueries\r\n+            (toFlushBeforeQueries(flushMode));\r\n+    }\r\n+\r\n+    public FlushModeType getFlushMode() {\r\n+        assertOpen();\r\n+        return fromFlushBeforeQueries(_broker.getFetchConfiguration().\r\n+            getFlushBeforeQueries());\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate our internal flush constant to a flush mode enum value.\r\n+     */\r\n+    static FlushModeType fromFlushBeforeQueries(int flush) {\r\n+        switch (flush) {\r\n+            case QueryFlushModes.FLUSH_TRUE:\r\n+                return FlushModeType.AUTO;\r\n+            case QueryFlushModes.FLUSH_FALSE:\r\n+                return FlushModeType.COMMIT;\r\n+            default:\r\n+                return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate a flush mode enum value to our internal flush constant.\r\n+     */\r\n+    static int toFlushBeforeQueries(FlushModeType flushMode) {\r\n+        // choose default for null\r\n+        if (flushMode == null)\r\n+            return QueryFlushModes.FLUSH_WITH_CONNECTION;\r\n+        if (flushMode == FlushModeType.AUTO)\r\n+            return QueryFlushModes.FLUSH_TRUE;\r\n+        if (flushMode == FlushModeType.COMMIT)\r\n+            return QueryFlushModes.FLUSH_FALSE;\r\n+        throw new ArgumentException(flushMode.toString(), null, null, false);\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        assertOpen();\r\n+        _broker.detachAll(this);\r\n+    }\r\n+\r\n+    public Object getDelegate() {\r\n+        _broker.assertOpen();\r\n+        return this;\r\n+    }\r\n+\r\n+    public LockModeType getLockMode(Object entity) {\r\n+        assertOpen();\r\n+        return fromLockLevel(_broker.getLockLevel(entity));\r\n+    }\r\n+\r\n+    public void lock(Object entity, LockModeType mode) {\r\n+        assertOpen();\r\n+        _broker.lock(entity, toLockLevel(mode), -1, this);\r\n+    }\r\n+\r\n+    public void lock(Object entity) {\r\n+        assertOpen();\r\n+        _broker.lock(entity, this);\r\n+    }\r\n+\r\n+    public void lock(Object entity, LockModeType mode, int timeout) {\r\n+        assertOpen();\r\n+        _broker.lock(entity, toLockLevel(mode), timeout, this);\r\n+    }\r\n+\r\n+    public void lockAll(Collection entities) {\r\n+        assertOpen();\r\n+        _broker.lockAll(entities, this);\r\n+    }\r\n+\r\n+    public void lockAll(Collection entities, LockModeType mode, int timeout) {\r\n+        assertOpen();\r\n+        _broker.lockAll(entities, toLockLevel(mode), timeout, this);\r\n+    }\r\n+\r\n+    public void lockAll(Object... entities) {\r\n+        lockAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void lockAll(Object[] entities, LockModeType mode, int timeout) {\r\n+        lockAll(Arrays.asList(entities), mode, timeout);\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate our internal lock level to a javax.persistence enum value.\r\n+     */\r\n+    static LockModeType fromLockLevel(int level) {\r\n+        if (level < LockLevels.LOCK_READ)\r\n+            return null;\r\n+        if (level < LockLevels.LOCK_WRITE)\r\n+            return LockModeType.READ;\r\n+        return LockModeType.WRITE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the javax.persistence enum value to our internal lock level.\r\n+     */\r\n+    static int toLockLevel(LockModeType mode) {\r\n+        if (mode == null)\r\n+            return LockLevels.LOCK_NONE;\r\n+        if (mode == LockModeType.READ)\r\n+            return LockLevels.LOCK_READ;\r\n+        if (mode == LockModeType.WRITE)\r\n+            return LockLevels.LOCK_WRITE;\r\n+        throw new ArgumentException(mode.toString(), null, null, true);\r\n+    }\r\n+\r\n+    public boolean cancelAll() {\r\n+        return _broker.cancelAll();\r\n+    }\r\n+\r\n+    public Object getConnection() {\r\n+        return _broker.getConnection();\r\n+    }\r\n+\r\n+    public Collection getManagedObjects() {\r\n+        return _broker.getManagedObjects();\r\n+    }\r\n+\r\n+    public Collection getTransactionalObjects() {\r\n+        return _broker.getTransactionalObjects();\r\n+    }\r\n+\r\n+    public Collection getPendingTransactionalObjects() {\r\n+        return _broker.getPendingTransactionalObjects();\r\n+    }\r\n+\r\n+    public Collection getDirtyObjects() {\r\n+        return _broker.getDirtyObjects();\r\n+    }\r\n+\r\n+    public boolean getOrderDirtyObjects() {\r\n+        return _broker.getOrderDirtyObjects();\r\n+    }\r\n+\r\n+    public void setOrderDirtyObjects(boolean order) {\r\n+        assertOpen();\r\n+        _broker.setOrderDirtyObjects(order);\r\n+    }\r\n+\r\n+    public void dirtyClass(Class cls) {\r\n+        assertOpen();\r\n+        _broker.dirtyType(cls);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getPersistedClasses() {\r\n+        return (Collection<Class>) _broker.getPersistedTypes();\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getUpdatedClasses() {\r\n+        return (Collection<Class>) _broker.getUpdatedTypes();\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getRemovedClasses() {\r\n+        return (Collection<Class>) _broker.getDeletedTypes();\r\n+    }\r\n+\r\n+    public <T> T createInstance(Class<T> cls) {\r\n+        assertOpen();\r\n+        return (T) _broker.newInstance(cls);\r\n+    }\r\n+\r\n+    public void close() {\r\n+        assertOpen();\r\n+        _broker.close();\r\n+    }\r\n+\r\n+    public boolean isOpen() {\r\n+        return !_broker.isCloseInvoked();\r\n+    }\r\n+\r\n+    public void dirty(Object o, String field) {\r\n+        assertOpen();\r\n+        OpenJPAStateManager sm = _broker.getStateManager(o);\r\n+        try {\r\n+            if (sm != null)\r\n+                sm.dirty(field);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public Object getObjectId(Object o) {\r\n+        assertOpen();\r\n+        return OpenJPAPersistence.fromOpenJPAObjectId(_broker.getObjectId(o));\r\n+    }\r\n+\r\n+    public boolean isDirty(Object o) {\r\n+        assertOpen();\r\n+        return _broker.isDirty(o);\r\n+    }\r\n+\r\n+    public boolean isTransactional(Object o) {\r\n+        assertOpen();\r\n+        return _broker.isTransactional(o);\r\n+    }\r\n+\r\n+    public boolean isPersistent(Object o) {\r\n+        assertOpen();\r\n+        return _broker.isPersistent(o);\r\n+    }\r\n+\r\n+    public boolean isNewlyPersistent(Object o) {\r\n+        assertOpen();\r\n+        return _broker.isNew(o);\r\n+    }\r\n+\r\n+    public boolean isRemoved(Object o) {\r\n+        assertOpen();\r\n+        return _broker.isDeleted(o);\r\n+    }\r\n+\r\n+    public boolean isDetached(Object entity) {\r\n+        assertOpen();\r\n+        return _broker.isDetached(entity);\r\n+    }\r\n+\r\n+    public Object getVersion(Object o) {\r\n+        assertOpen();\r\n+        return _broker.getVersion(o);\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw appropriate exception if entity manager is closed.\r\n+     */\r\n+    void assertOpen() {\r\n+        // only throw when broker wouldn't throw anyway, because we prefer\r\n+        // the broker's more detailed exception when available\r\n+        if (!_broker.isClosed() && _broker.isCloseInvoked())\r\n+            throw new InvalidStateException(_loc.get(\"close-invoked\"), null,\r\n+                null, true);\r\n+    }\r\n+\r\n+    ////////////////////////////////\r\n+    // FindCallbacks implementation\r\n+    ////////////////////////////////\r\n+\r\n+    public Object processArgument(Object arg) {\r\n+        return arg;\r\n+    }\r\n+\r\n+    public Object processReturn(Object oid, OpenJPAStateManager sm) {\r\n+        return (sm == null || sm.isDeleted()) ? null : sm.getManagedInstance();\r\n+    }\r\n+\r\n+    //////////////////////////////\r\n+    // OpCallbacks implementation\r\n+    //////////////////////////////\r\n+\r\n+    public int processArgument(int op, Object obj, OpenJPAStateManager sm) {\r\n+        switch (op) {\r\n+            case OP_DELETE:\r\n+                // cascade through non-persistent non-detached instances\r\n+                if (sm == null && !_broker.isDetached(obj))\r\n+                    return ACT_CASCADE;\r\n+                if (sm != null && !sm.isDetached() && !sm.isPersistent())\r\n+                    return ACT_CASCADE;\r\n+                // ignore deleted instances\r\n+                if (sm != null && sm.isDeleted())\r\n+                    return ACT_NONE;\r\n+                break;\r\n+            case OP_ATTACH:\r\n+                // die on removed\r\n+                if (sm != null && sm.isDeleted())\r\n+                    throw new UserException(_loc.get(\"removed\",\r\n+                        Exceptions.toString(obj))).setFailedObject(obj);\r\n+                // cascade through managed instances\r\n+                if (sm != null && !sm.isDetached())\r\n+                    return ACT_CASCADE;\r\n+                break;\r\n+            case OP_REFRESH:\r\n+                // die on unmanaged instances\r\n+                if (sm == null)\r\n+                    throw new UserException(_loc.get(\"not-managed\",\r\n+                        Exceptions.toString(obj))).setFailedObject(obj);\r\n+                break;\r\n+        }\r\n+        return ACT_RUN | ACT_CASCADE;\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _broker.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof EntityManagerImpl))\r\n+            return false;\r\n+        return _broker.equals(((EntityManagerImpl) other)._broker);\r\n+    }\r\n+}\r"}]}

