{"sha":"1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","node_id":"MDY6Q29tbWl0MjA2MzY0OjFmZWRlNjI2ZTJjYWQxNmY3YmI0ZDc3ZGQ5ZmMzMjcwYThiNmIzMzE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-11T00:35:10Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-11T00:35:10Z"},"message":"core OpenJPA object management code, plus a sample flat-file XML-based back-end. This submission does not include the OpenJPA JDBC back-end, and also doesn't include any additional tests yet.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@420667 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6e080044f1fb52a550e884c40416eef820cc8eb9","url":"https://api.github.com/repos/apache/openjpa/git/trees/6e080044f1fb52a550e884c40416eef820cc8eb9"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","html_url":"https://github.com/apache/openjpa/commit/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","comments_url":"https://api.github.com/repos/apache/openjpa/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/comments","author":null,"committer":null,"parents":[{"sha":"00652be8fdb0007e6b0b624a370b9837c2854019","url":"https://api.github.com/repos/apache/openjpa/commits/00652be8fdb0007e6b0b624a370b9837c2854019","html_url":"https://github.com/apache/openjpa/commit/00652be8fdb0007e6b0b624a370b9837c2854019"}],"stats":{"total":109324,"additions":104070,"deletions":5254},"files":[{"sha":"3f5f0335e13cee8ba9b2a164333870315e92bf8f","filename":"openjpa-kernel-5/pom.xml","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/pom.xml?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,51 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-kernel-5</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Kernel 1.5</name>\n+    <description>Kernel 1.5</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-kernel</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"0edcd16f63bc836fc49b91c6d66136d7e0a23f56","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"added","additions":219,"deletions":0,"changes":219,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,219 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation. Licensed under the Apache\r\n+ * License, Version 2.0 (the \"License\"); you may not use this file except in\r\n+ * compliance with the License. You may obtain a copy of the License at\r\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\r\n+ * or agreed to in writing, software distributed under the License is\r\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied. See the License for the specific language\r\n+ * governing permissions and limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.UnsupportedEncodingException;\r\n+import java.lang.instrument.ClassFileTransformer;\r\n+import java.lang.instrument.IllegalClassFormatException;\r\n+import java.security.ProtectionDomain;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import serp.bytecode.Project;\r\n+\r\n+/**\r\n+ * Transformer that makes persistent classes implement the\r\n+ * {@link PersistenceCapable} interface at runtime.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class PCClassFileTransformer implements ClassFileTransformer {\r\n+\r\n+    private static final Localizer _loc = Localizer\r\n+        .forPackage(PCClassFileTransformer.class);\r\n+\r\n+    private final MetaDataRepository _repos;\r\n+    private final PCEnhancer.Flags _flags;\r\n+    private final ClassLoader _loader;\r\n+    private final Log _log;\r\n+    private final Set _names;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param repos  metadata repository to use internally\r\n+     * @param opts   enhancer configuration options\r\n+     * @param loader temporary class loader for loading intermediate\r\n+     *               classes\r\n+     */\r\n+    public PCClassFileTransformer(MetaDataRepository repos, Options opts,\r\n+        ClassLoader loader) {\r\n+        this(repos, toFlags(opts), loader, opts.removeBooleanProperty(\r\n+            \"scanDevPath\", \"ScanDevPath\", false));\r\n+    }\r\n+\r\n+    /**\r\n+     * Create enhancer flags from the given options.\r\n+     */\r\n+    private static PCEnhancer.Flags toFlags(Options opts) {\r\n+        PCEnhancer.Flags flags = new PCEnhancer.Flags();\r\n+        flags.addDefaultConstructor = opts.removeBooleanProperty(\r\n+            \"addDefaultConstructor\", \"AddDefaultConstructor\",\r\n+            flags.addDefaultConstructor);\r\n+        flags.enforcePropertyRestrictions = opts.removeBooleanProperty(\r\n+            \"enforcePropertyRestrictions\", \"EnforcePropertyRestrictions\",\r\n+            flags.enforcePropertyRestrictions);\r\n+        return flags;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param repos   metadata repository to use internally\r\n+     * @param flags   enhancer configuration\r\n+     * @param loader  temporary class loader for loading intermediate\r\n+     *                classes\r\n+     * @param devscan whether to scan the dev classpath for persistent types\r\n+     *                if none are configured\r\n+     */\r\n+    public PCClassFileTransformer(MetaDataRepository repos,\r\n+        PCEnhancer.Flags flags, ClassLoader loader, boolean devscan) {\r\n+        _repos = repos;\r\n+        _log = repos.getConfiguration()\r\n+            .getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+        _flags = flags;\r\n+        _loader = loader;\r\n+        _names = repos.getPersistentTypeNames(devscan, loader);\r\n+        if (_names == null && _log.isInfoEnabled())\r\n+            _log.info(_loc.get(\"runtime-enhance-pcclasses\"));\r\n+    }\r\n+\r\n+    public byte[] transform(ClassLoader loader, String className, Class redef,\r\n+        ProtectionDomain domain, byte[] bytes)\r\n+        throws IllegalClassFormatException {\r\n+        if (loader == _loader)\r\n+            return null;\r\n+        try {\r\n+            Boolean enhance = needsEnhance(className, redef, bytes);\r\n+            if (enhance != null && _log.isTraceEnabled())\r\n+                _log.trace(_loc\r\n+                    .get(\"needs-runtime-enhance\", className, enhance));\r\n+            if (enhance != Boolean.TRUE)\r\n+                return null;\r\n+            PCEnhancer enhancer = new PCEnhancer(_repos.getConfiguration(),\r\n+                new Project().loadClass(new ByteArrayInputStream(bytes),\r\n+                    _loader), _repos);\r\n+            enhancer.setAddDefaultConstructor(_flags.addDefaultConstructor);\r\n+            enhancer\r\n+                .setEnforcePropertyRestrictions(\r\n+                    _flags.enforcePropertyRestrictions);\r\n+            if (enhancer.run() == PCEnhancer.ENHANCE_NONE)\r\n+                return null;\r\n+            return enhancer.getBytecode().toByteArray();\r\n+        } catch (Throwable t) {\r\n+            _log.warn(_loc.get(\"cft-exception-thrown\", className), t);\r\n+            if (t instanceof RuntimeException)\r\n+                throw (RuntimeException) t;\r\n+            if (t instanceof IllegalClassFormatException)\r\n+                throw (IllegalClassFormatException) t;\r\n+            throw new GeneralException(t);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether the given class needs enhancement.\r\n+     */\r\n+    private Boolean needsEnhance(String clsName, Class redef, byte[] bytes) {\r\n+        if (redef != null) {\r\n+            Class[] intfs = redef.getInterfaces();\r\n+            for (int i = 0; i < intfs.length; i++)\r\n+                if (PersistenceCapable.class.getName().equals(\r\n+                    intfs[i].getName()))\r\n+                    return Boolean.valueOf(!isEnhanced(bytes));\r\n+            return null;\r\n+        }\r\n+        if (_names != null) {\r\n+            if (_names.contains(clsName.replace('/', '.')))\r\n+                return Boolean.valueOf(!isEnhanced(bytes));\r\n+            return null;\r\n+        }\r\n+        if (clsName.startsWith(\"java/\") || clsName.startsWith(\"javax/\"))\r\n+            return null;\r\n+        if (isEnhanced(bytes))\r\n+            return Boolean.FALSE;\r\n+        try {\r\n+            Class c = Class.forName(clsName.replace('/', '.'), false, _loader);\r\n+            if (_repos.getMetaData(c, null, false) != null)\r\n+                return Boolean.TRUE;\r\n+            return null;\r\n+        } catch (RuntimeException re) {\r\n+            throw re;\r\n+        } catch (Throwable t) {\r\n+            throw new GeneralException(t);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Analyze the bytecode to see if the given class definition implements\r\n+     * {@link PersistenceCapable}.\r\n+     */\r\n+    private static boolean isEnhanced(byte[] b) {\r\n+        // each entry is the index in the byte array of the data for a const\r\n+        // pool entry\r\n+        int[] entries = new int[readUnsignedShort(b, 8)];\r\n+        int idx = 10;\r\n+        for (int i = 1; i < entries.length; i++) {\r\n+            entries[i] = idx + 1; // skip entry type\r\n+            switch (b[idx]) {\r\n+                case 1: // utf8\r\n+                    idx += 3 + readUnsignedShort(b, idx + 1);\r\n+                    break;\r\n+                case 3: // integer\r\n+                case 4: // float\r\n+                case 9: // field\r\n+                case 10: // method\r\n+                case 11: // interface method\r\n+                case 12: // name\r\n+                    idx += 5;\r\n+                    break;\r\n+                case 5: // long\r\n+                case 6: // double\r\n+                    idx += 9;\r\n+                    i++; // wide entry\r\n+                    break;\r\n+                default:\r\n+                    idx += 3;\r\n+            }\r\n+        }\r\n+        idx += 6;\r\n+        int ifaces = readUnsignedShort(b, idx);\r\n+        int clsEntry, utfEntry, len;\r\n+        String name;\r\n+        for (int i = 0; i < ifaces; i++) {\r\n+            idx += 2;\r\n+            clsEntry = readUnsignedShort(b, idx);\r\n+            utfEntry = readUnsignedShort(b, entries[clsEntry]);\r\n+            len = readUnsignedShort(b, entries[utfEntry]);\r\n+            try {\r\n+                name = new String(b, entries[utfEntry] + 2, len, \"UTF-8\");\r\n+                if (\"openjpa/enhance/PersistenceCapable\".equals(name))\r\n+                    return true;\r\n+            } catch (UnsupportedEncodingException uee) {\r\n+                throw new ClassFormatError(uee.toString());\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Read an unsigned short from the given array at the given offset.\r\n+     */\r\n+    private static int readUnsignedShort(byte[] b, int idx) {\r\n+        return ((b[idx] & 0xFF) << 8) | (b[idx + 1] & 0xFF);\r\n+    }\r\n+}\r"},{"sha":"864397835cc36ec41cad53404a59aec94fd1a1cd","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,65 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation. Licensed under the Apache\r\n+ * License, Version 2.0 (the \"License\"); you may not use this file except in\r\n+ * compliance with the License. You may obtain a copy of the License at\r\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\r\n+ * or agreed to in writing, software distributed under the License is\r\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied. See the License for the specific language\r\n+ * governing permissions and limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.lang.instrument.Instrumentation;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import org.apache.openjpa.lib.util.TemporaryClassLoader;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ClassResolver;\r\n+\r\n+/**\r\n+ * Java agent that makes persistent classes implement the\r\n+ * {@link PersistenceCapable} interface at runtime. The agent is launched at JVM\r\n+ * startup from the command line:\r\n+ * <p/>\r\n+ * <code>java -javaagent:org.apache.openjpa.jar[=&lt;options&gt;]</code> The\r\n+ * options string should be formatted as a OpenJPA plugin, and may contain any\r\n+ * properties understood by the OpenJPA enhancer or any configuration\r\n+ * properties. For example:\r\n+ * <p/>\r\n+ * <code>java -javaagent:org.apache.openjpa.jar=JdoEnhance=true,LicenseKey=xxx</code>\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class PCEnhancerAgent {\r\n+\r\n+    public static void premain(String args, Instrumentation inst) {\r\n+        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\r\n+        Options opts = Configurations.parseProperties(args);\r\n+        Configurations.populateConfiguration(conf, opts);\r\n+\r\n+        // don't allow connections\r\n+        conf.setConnectionUserName(null);\r\n+        conf.setConnectionPassword(null);\r\n+        conf.setConnectionURL(null);\r\n+        conf.setConnectionDriverName(null);\r\n+        conf.setConnectionFactoryName(null);\r\n+        // set single class resolver\r\n+        final ClassLoader tmpLoader = new TemporaryClassLoader(Thread\r\n+            .currentThread().getContextClassLoader());\r\n+        conf.setClassResolver(new ClassResolver() {\r\n+\r\n+            public ClassLoader getClassLoader(Class context, ClassLoader env) {\r\n+                return tmpLoader;\r\n+            }\r\n+        });\r\n+        conf.setReadOnly(true);\r\n+        conf.instantiateAll(); // avoid threading issues\r\n+        PCClassFileTransformer transformer = new PCClassFileTransformer(\r\n+            new MetaDataRepository(conf), opts, tmpLoader);\r\n+        inst.addTransformer(transformer);\r\n+    }\r\n+}\r"},{"sha":"ef2c9780e165c676e0d1cb56797f67554461cd4f","filename":"openjpa-kernel/pom.xml","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,137 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-kernel</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Kernel</name>\n+    <description>Kernel</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-lib</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>javax.jms</groupId>\n+            <artifactId>jms</artifactId>\n+            <version>1.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>javax.resource</groupId>\n+            <artifactId>connector</artifactId>\n+            <version>1.0</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+        <dependency>\n+\n+            <groupId>javax.transaction</groupId>\n+            <artifactId>jta</artifactId>\n+            <version>1.0.1B</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.3</source>\n+                    <target>1.3</target>\n+                </configuration>\n+\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>javacc-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>jjtree-jpql</id>\n+                        <phase>generate-sources</phase>\n+                        <configuration>\n+                            <sourceDirectory>\n+                                ${basedir}/src/main/jjtree/org/apache/openjpa/kernel/jpql</sourceDirectory>\n+                            <outputDirectory>\n+                                ${project.build.directory}/generated-sources/jjtree/org/apache/openjpa/kernel/jpql</outputDirectory>\n+                            <buildNodeFiles>false</buildNodeFiles>\n+                        </configuration>\n+                        <goals>\n+                            <goal>jjtree</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>javacc-jpql</id>\n+                        <phase>generate-sources</phase>\n+                        <configuration>\n+                            <sourceDirectory>\n+                                ${project.build.directory}/generated-sources/jjtree/org/apache/openjpa/kernel/jpql</sourceDirectory>\n+                            <outputDirectory>\n+                                ${project.build.directory}/generated-sources/javacc/org/apache/openjpa/kernel/jpql</outputDirectory>\n+                        </configuration>\n+                        <goals>\n+                            <goal>javacc</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <phase>process-sources</phase>\n+                        <configuration>\n+                            <tasks>\n+                                <delete\n+                                    file=\"${project.build.directory}/generated-sources/javacc/org/apache/openjpa/kernel/jpql/ParseException.java\"/>\n+                            </tasks>\n+                        </configuration>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <configuration>\n+                    <archive>\n+                        <manifestEntries>\n+                            <Premain-Class>\n+                                org.apache.openjpa.enhance.PCEnhancerAgent</Premain-Class>\n+                        </manifestEntries>\n+                    </archive>\n+                </configuration>\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"6a2a1b49094ccbd043397b27268ef6530606aa71","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,127 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.abstractstore;\r\n+\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\r\n+import org.apache.openjpa.kernel.Bootstrap;\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * {@link BrokerFactory} implementation for use with the\r\n+ * {@link AbstractStoreManager}. This provides integration into the\r\n+ * {@link Bootstrap#getBrokerFactory} bootstrapping mechanism, to facilitate\r\n+ * the process of creating a subclass of {@link AbstractStoreManager}. New\r\n+ * store manager implementations need not extend this class. Instead, set the\r\n+ * <code>org.apache.openjpa.BrokerFactory</code> configuration property to\r\n+ * <code>abstractstore</code>,\r\n+ * and set the <code>org.apache.openjpa.abstractstore.AbstractStoreManager</code>\r\n+ * configuration property to the full class name of your implementation.\r\n+ * Additionally, you can optionally create your own\r\n+ * <code>BrokerFactory</code> implementation. However, we recommend that you\r\n+ * use the <code>AbstractStoreBrokerFactory</code>, as it deals with pooling\r\n+ * and bootstrapping from a {@link Map} object(the strategy used by\r\n+ * {@link Bootstrap} to create a factory in a vendor-neutral manner).\r\n+ */\r\n+public class AbstractStoreBrokerFactory extends AbstractBrokerFactory {\r\n+\r\n+    /**\r\n+     * The property name under which to name the concrete store manager\r\n+     * class for this runtime.\r\n+     */\r\n+    public static final String PROP_ABSTRACT_STORE =\r\n+        \"org.apache.openjpa.abstractstore.AbstractStoreManager\";\r\n+    private static final Localizer s_loc = Localizer.forPackage\r\n+        (AbstractStoreBrokerFactory.class);\r\n+    private String _storeCls = null;\r\n+    private String _storeProps = null;\r\n+    private String _platform = null;\r\n+\r\n+    /**\r\n+     * Factory method for obtaining a possibly-pooled {@link BrokerFactory}\r\n+     * from properties. Invoked from {@link Bootstrap#getBrokerFactory}.\r\n+     */\r\n+    public static AbstractStoreBrokerFactory getInstance\r\n+        (ConfigurationProvider cp) {\r\n+        AbstractStoreBrokerFactory factory = (AbstractStoreBrokerFactory)\r\n+            getPooledFactory(cp.getProperties());\r\n+        if (factory != null)\r\n+            return factory;\r\n+        factory = newInstance(cp);\r\n+        factory.pool();\r\n+        return factory;\r\n+    }\r\n+\r\n+    /**\r\n+     * Factory method for constructing a {@link BrokerFactory}\r\n+     * from properties. Invoked from {@link Bootstrap#newBrokerFactory}.\r\n+     */\r\n+    public static AbstractStoreBrokerFactory newInstance\r\n+        (ConfigurationProvider cp) {\r\n+        // use a tmp store manager to get metadata about the capabilities of\r\n+        // this runtime\r\n+        Map map = cp.getProperties();\r\n+        String storePlugin = (String) map.get(PROP_ABSTRACT_STORE);\r\n+        String storeCls = Configurations.getClassName(storePlugin);\r\n+        String storeProps = Configurations.getProperties(storePlugin);\r\n+        AbstractStoreManager store = createStoreManager(storeCls, storeProps);\r\n+        // populate configuration\r\n+        OpenJPAConfiguration conf = store.newConfiguration();\r\n+        cp.setInto(conf);\r\n+        conf.supportedOptions().removeAll(store.getUnsupportedOptions());\r\n+        // create and pool a new factory\r\n+        return new AbstractStoreBrokerFactory(conf, storeCls, storeProps,\r\n+            store.getPlatform());\r\n+    }\r\n+\r\n+    /**\r\n+     * Construct the factory with the given settings.\r\n+     */\r\n+    protected AbstractStoreBrokerFactory(OpenJPAConfiguration conf,\r\n+        String storeCls, String storeProps, String platform) {\r\n+        super(conf);\r\n+        _storeCls = storeCls;\r\n+        _storeProps = storeProps;\r\n+        _platform = platform;\r\n+    }\r\n+\r\n+    public Properties getProperties() {\r\n+        Properties props = super.getProperties();\r\n+        props.setProperty(\"Platform\", _platform);\r\n+        return props;\r\n+    }\r\n+\r\n+    protected StoreManager newStoreManager() {\r\n+        return createStoreManager(_storeCls, _storeProps);\r\n+    }\r\n+\r\n+    private static AbstractStoreManager createStoreManager(String cls,\r\n+        String props) {\r\n+        AbstractStoreManager store = (AbstractStoreManager) Configurations.\r\n+            newInstance(cls, AbstractStoreManager.class.getClassLoader());\r\n+        Configurations.configureInstance(store, null, props,\r\n+            PROP_ABSTRACT_STORE);\r\n+        if (store == null)\r\n+            throw new UserException(s_loc.get(\"no-store-manager\",\r\n+                PROP_ABSTRACT_STORE)).setFatal(true);\r\n+        return store;\r\n+    }\r\n+}\r"},{"sha":"f984b2e3becd25dfc33310b60f2ddc2e3821cc38","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","status":"added","additions":507,"deletions":0,"changes":507,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,507 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.abstractstore;\r\n+\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchConfigurationImpl;\r\n+import org.apache.openjpa.kernel.FetchState;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCState;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueStrategies;\r\n+import org.apache.openjpa.util.ApplicationIds;\r\n+import org.apache.openjpa.util.Id;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * Abstract store manager implementation to ease development of custom\r\n+ * OpenJPA back-ends. A concrete subclass must define implementations for the\r\n+ * following methods:\r\n+ * <ul>\r\n+ * <li>{@link StoreManager#exists}</li>\r\n+ * <li>{@link #initialize}</li>\r\n+ * <li>{@link #load}</li>\r\n+ * <li>{@link\r\n+ * #flush(Collection,Collection,Collection,Collection,Collection)}</li>\r\n+ * <li>{@link #executeExtent}</li>\r\n+ * </ul> Additionally, subclasses should not attempt to acquire resources\r\n+ * until {@link #open} has been called. Store manager instances might be\r\n+ * created to call metadata methods such as {@link #newConfiguration} or\r\n+ * {@link #getUnsupportedOptions} and never opened. These instances should\r\n+ * not consume any data store resources.\r\n+ * Notes:\r\n+ * <ul>\r\n+ * <li>The {@link StoreManager#initialize} method is responsible\r\n+ * for creating new instances of objects freshly loaded from the\r\n+ * database. The method will be invoked with a {@link OpenJPAStateManager}\r\n+ * that the newly-loaded object should be associated with. To create the\r\n+ * new object and set up this association correctly, the implementation\r\n+ * should use the {@link OpenJPAStateManager#initialize} method.</li>\r\n+ * <li>If your data store supports some sort of transaction or\r\n+ * unit of work, you should override the {@link #begin}, {@link #commit},\r\n+ * and {@link #rollback} methods.</li>\r\n+ * <li>This class provides no infrastructure support for optimistic\r\n+ * transactions. To provide optimistic transaction support:\r\n+ * <ul>\r\n+ * <li>Override {@link #beginOptimistic}, {@link #rollbackOptimistic},\r\n+ * and {@link #syncVersion}.</li>\r\n+ * <li>Override {@link #getUnsupportedOptions} to not include {@link\r\n+ * OpenJPAConfiguration#OPTION_OPTIMISTIC} in the list of unsupported\r\n+ * options.</li>\r\n+ * <li>Ensure that your flush implementation sets the next\r\n+ * version for each modified object via the {@link\r\n+ * OpenJPAStateManager#setNextVersion} method.</li>\r\n+ * <li>If your version object does not implement {@link Comparable},\r\n+ * override {@link #compareVersion}, which relies on the\r\n+ * {@link Comparable#compareTo} method.</li>\r\n+ * </ul></li>\r\n+ * <li>If your data store supports a mechanism for automatically\r\n+ * generating and managing identity values(or if you want to\r\n+ * provide that facility on top of your data store), implement\r\n+ * the {@link #getDataStoreIdSequence} method if you want to use a\r\n+ * <code>long</code> as your datastore identity type and are\r\n+ * happy with OpenJPA's {@link Id} class. To use another datastore identity\r\n+ * type, override {@link #getManagedType},\r\n+ * {@link #getDataStoreIdType}, {@link #copyDataStoreId}, and\r\n+ * {@link #newDataStoreId} instead. In either case, override\r\n+ * {@link #getUnsupportedOptions} to not include\r\n+ * {@link OpenJPAConfiguration#OPTION_ID_DATASTORE} in the list of\r\n+ * unsupported options.</li>\r\n+ * <li>If your data store does not support queries(or if you do\r\n+ * not want to convert OpenJPA's query parse tree into a\r\n+ * datastore-specific query), you still have two options in terms\r\n+ * of query execution:\r\n+ * <ul>\r\n+ * <li><em>In-memory execution</em>: If you\r\n+ * execute a query against an extent or a class, OpenJPA will\r\n+ * automatically load the full extent of objects into memory and\r\n+ * execute the query in memory.</li>\r\n+ * <li><em>org.apache.openjpa.MethodQL</em>: MethodQL allows\r\n+ * you to use the query APIs to execute a method that finds\r\n+ * data in your back-end and returns that data as a\r\n+ * {@link org.apache.openjpa.lib.rop.ResultList}. For more details on\r\n+ * MethodQL, see the OpenJPA Reference Guide.</li>\r\n+ * </ul></li>\r\n+ * </ul>\r\n+ *\r\n+ * @since 3.1\r\n+ */\r\n+public abstract class AbstractStoreManager implements StoreManager {\r\n+\r\n+    protected StoreContext ctx;\r\n+\r\n+    public final void setContext(StoreContext ctx) {\r\n+        this.ctx = ctx;\r\n+        open();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link StoreContext} that this store manager is\r\n+     * associated with.\r\n+     */\r\n+    public StoreContext getContext() {\r\n+        return ctx;\r\n+    }\r\n+\r\n+    /**\r\n+     * No-op implementation. Ready this store manager for persistent operations.\r\n+     */\r\n+    protected void open() {\r\n+    }\r\n+\r\n+    /**\r\n+     * No-op implementation. Override this method to provide optimistic\r\n+     * locking semantics for your data store if you need notification of\r\n+     * the beginning of an optimistic transaction.\r\n+     */\r\n+    public void beginOptimistic() {\r\n+    }\r\n+\r\n+    /**\r\n+     * No-op implementation. Override this method to provide optimistic\r\n+     * locking semantics for your data store if you need notification of\r\n+     * a rollback of an optimistic transaction before {@link #begin} is invoked.\r\n+     */\r\n+    public void rollbackOptimistic() {\r\n+    }\r\n+\r\n+    /**\r\n+     * OpenJPA assumes that after this method is invoked, all data\r\n+     * accesses through this store manager will be part of a single\r\n+     * unit of work that can be rolled back.\r\n+     * This is a no-op implementation. If your data store does not\r\n+     * support any concept of locking or transactions, you need not\r\n+     * override this method.\r\n+     */\r\n+    public void begin() {\r\n+    }\r\n+\r\n+    /**\r\n+     * This is a no-op implementation. If your data store does not\r\n+     * have a concept of transactions or a unit of work, you need not\r\n+     * override this method. If it does, then override this method to\r\n+     * notify the data store that the current transaction should be committed.\r\n+     */\r\n+    public void commit() {\r\n+    }\r\n+\r\n+    /**\r\n+     * This is a no-op implementation. If your data store does not\r\n+     * have a concept of transactions or a unit of work, you need not\r\n+     * override this method. If it does, then override this method to\r\n+     * notify the data store that the current transaction should be rolled back.\r\n+     */\r\n+    public void rollback() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Since this store manager does not provide optimistic locking\r\n+     * support, this method always returns <code>true</code>.\r\n+     */\r\n+    public boolean syncVersion(OpenJPAStateManager sm, Object context) {\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * This method is invoked when OpenJPA needs to load an object whose\r\n+     * identity is known but which has not yet been loaded from the data\r\n+     * store. <code>sm</code> is a partially-set-up state manager for this\r\n+     * object. The ID and least-derived type information for the instance\r\n+     * to load can be obtained by invoking\r\n+     * <code>sm.getObjectId()</code> and <code>sm.getMetaData()</code>.\r\n+     * <p/>\r\n+     * When implementing this method, load the data for this object from\r\n+     * the data store, determine the most-derived subclass of the newly-loaded\r\n+     * data, and then use the {@link OpenJPAStateManager#initialize} method to\r\n+     * populate <code>sm</code> with a new instance of the appropriate type.\r\n+     * Once {@link OpenJPAStateManager#initialize} has been invoked, proceed to\r\n+     * load field data into <code>sm</code> as in the {@link #load} method, by\r\n+     * using {@link OpenJPAStateManager#store} (or the appropriate\r\n+     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\r\n+     * data into the object.\r\n+     */\r\n+    public abstract boolean initialize(OpenJPAStateManager sm, PCState state,\r\n+        FetchState fetchState, Object context);\r\n+\r\n+    /**\r\n+     * This method is invoked when OpenJPA needs to load additional data\r\n+     * into an object that has already been at least partially loaded by\r\n+     * a previous {@link #initialize} invocation.\r\n+     * Load data into <code>sm</code> by using {@link\r\n+     * OpenJPAStateManager#store} (or the appropriate\r\n+     * <code>OpenJPAStateManager.store<em>type</em></code> method) to put the\r\n+     * data into the object.\r\n+     */\r\n+    public abstract boolean load(OpenJPAStateManager sm, BitSet fields,\r\n+        FetchState fetchState, int lockLevel, Object context);\r\n+\r\n+    /**\r\n+     * This implementation just delegates to the proper singular\r\n+     * method({@link StoreManager#initialize} or {@link StoreManager#load})\r\n+     * depending on each state manager's state. If your data store provides\r\n+     * bulk loading APIs, overriding this method to be more clever may be\r\n+     * advantageous.\r\n+     */\r\n+    public Collection loadAll(Collection sms, PCState state, int load,\r\n+        FetchState fetchState, Object context) {\r\n+        return ImplHelper.loadAll(sms, this, state, load, fetchState, context);\r\n+    }\r\n+\r\n+    /**\r\n+     * Breaks down <code>states</code> based on the objects' current\r\n+     * states, and delegates to\r\n+     * {@link #flush(Collection,Collection,Collection,Collection,Collection)}.\r\n+     */\r\n+    public Collection flush(Collection sms) {\r\n+        // break down state managers by state; initialize as empty lists;\r\n+        // use constants for efficiency\r\n+        Collection pNew = new LinkedList();\r\n+        Collection pNewUpdated = new LinkedList();\r\n+        Collection pNewFlushedDeleted = new LinkedList();\r\n+        Collection pDirty = new LinkedList();\r\n+        Collection pDeleted = new LinkedList();\r\n+        OpenJPAStateManager sm;\r\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n+            sm = (OpenJPAStateManager) itr.next();\r\n+            if (sm.getPCState() == PCState.PNEW && !sm.isFlushed())\r\n+                pNew.add(sm);\r\n+            else if (sm.getPCState() == PCState.PNEW && sm.isFlushed())\r\n+                pNewUpdated.add(sm);\r\n+            else if (sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\r\n+                pNewFlushedDeleted.add(sm);\r\n+            else if (sm.getPCState() == PCState.PDIRTY)\r\n+                pDirty.add(sm);\r\n+            else if (sm.getPCState() == PCState.PDELETED)\r\n+                pDeleted.add(sm);\r\n+        }\r\n+        // no dirty instances to flush?\r\n+        if (pNew.isEmpty() && pNewUpdated.isEmpty()\r\n+            && pNewFlushedDeleted.isEmpty() && pDirty.isEmpty()\r\n+            && pDeleted.isEmpty())\r\n+            return Collections.EMPTY_LIST;\r\n+        return flush(pNew, pNewUpdated, pNewFlushedDeleted, pDirty, pDeleted);\r\n+    }\r\n+\r\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\r\n+        PCState toState) {\r\n+    }\r\n+\r\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush) {\r\n+        ClassMetaData meta = sm.getMetaData();\r\n+        if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)\r\n+            return ApplicationIds.assign(sm, this, preFlush);\r\n+        // datastore identity\r\n+        Object val = ImplHelper.generateIdentityValue(ctx, meta,\r\n+            JavaTypes.LONG);\r\n+        return assignDataStoreId(sm, val);\r\n+    }\r\n+\r\n+    /**\r\n+     * Assign a new datastore identity to the given instance. This given\r\n+     * value may be null.\r\n+     */\r\n+    protected boolean assignDataStoreId(OpenJPAStateManager sm, Object val) {\r\n+        ClassMetaData meta = sm.getMetaData();\r\n+        if (val == null && meta.getIdentityStrategy() != ValueStrategies.NATIVE)\r\n+            return false;\r\n+        if (val == null)\r\n+            val = getDataStoreIdSequence(meta).next(ctx, meta);\r\n+        sm.setObjectId(newDataStoreId(val, meta));\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean assignField(OpenJPAStateManager sm, int field,\r\n+        boolean preFlush) {\r\n+        FieldMetaData fmd = sm.getMetaData().getField(field);\r\n+        Object val = ImplHelper.generateFieldValue(ctx, fmd);\r\n+        if (val == null)\r\n+            return false;\r\n+        sm.store(field, val);\r\n+        return true;\r\n+    }\r\n+\r\n+    public Class getManagedType(Object oid) {\r\n+        if (oid instanceof Id)\r\n+            return ((Id) oid).getType();\r\n+        return null;\r\n+    }\r\n+\r\n+    public Class getDataStoreIdType(ClassMetaData meta) {\r\n+        return Id.class;\r\n+    }\r\n+\r\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta) {\r\n+        Id id = (Id) oid;\r\n+        return new Id(meta.getDescribedType(), id.getId(), id.hasSubclasses());\r\n+    }\r\n+\r\n+    public Object newDataStoreId(Object val, ClassMetaData meta) {\r\n+        // we use base types for all oids\r\n+        while (meta.getPCSuperclass() != null)\r\n+            meta = meta.getPCSuperclassMetaData();\r\n+        return Id.newInstance(meta.getDescribedType(), val);\r\n+    }\r\n+\r\n+    /**\r\n+     * Override to retain a dedicated connection.\r\n+     */\r\n+    public void retainConnection() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Override to release previously-retained connection.\r\n+     */\r\n+    public void releaseConnection() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns <code>null</code>. If your data store can provide a\r\n+     * distinct connection object, return it here.\r\n+     */\r\n+    public Object getClientConnection() {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a {@link ResultObjectProvider} that can return all instances\r\n+     * of <code>type</code>, optionally including subclasses as defined\r\n+     * by <code>subclasses</code>.\r\n+     * The implementation of the result provider will typically execute\r\n+     * some sort of data store query to find all the applicable objects, loop\r\n+     * through the returned data, extracting object IDs from the data, and\r\n+     * invoking {@link StoreContext#find(Object,FetchState,BitSet,Object,int)}\r\n+     * on each OID. When invoking this method, the first argument is the OID.\r\n+     * The second is the given fetch configuration. The\r\n+     * third argument is a mask of fields to exclude from loading; it will\r\n+     * typically be null. The last argument is an object that will be passed\r\n+     * through to {@link #initialize} or {@link #load}, and typically will\r\n+     * contain the actual data to load. For example, for a JDBC-based store\r\n+     * manager, this might be the result set that is being iterated over. If\r\n+     * this argument is <code>null</code>, then the {@link #initialize} or\r\n+     * {@link #load} method will have to issue another command to the data\r\n+     * store in order to fetch the data to be loaded.\r\n+     */\r\n+    public abstract ResultObjectProvider executeExtent(ClassMetaData meta,\r\n+        boolean subs, FetchConfiguration fetch);\r\n+\r\n+    public StoreQuery newQuery(String language) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public FetchConfiguration newFetchConfiguration() {\r\n+        return new FetchConfigurationImpl();\r\n+    }\r\n+\r\n+    /**\r\n+     * Casts <code>v1</code> and <code>v2</code> to {@link Comparable}, and\r\n+     * invokes <code>v1.compareTo(v2)</code>. If <code>v1</code> is less\r\n+     * than <code>v2</code>, returns {@link #VERSION_EARLIER}. If the same,\r\n+     * returns {@link #VERSION_SAME}. Otherwise, returns {@link\r\n+     * #VERSION_LATER}. If either <code>v1</code> or <code>v2</code> are\r\n+     * <code>null</code>, returns {@link #VERSION_DIFFERENT}.\r\n+     */\r\n+    public int compareVersion(OpenJPAStateManager state, Object v1, Object v2) {\r\n+        if (v1 == null || v2 == null)\r\n+            return VERSION_DIFFERENT;\r\n+        int compare = ((Comparable) v1).compareTo((Comparable) v2);\r\n+        if (compare < 0)\r\n+            return VERSION_EARLIER;\r\n+        if (compare == 0)\r\n+            return VERSION_SAME;\r\n+        return VERSION_LATER;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the system-configured sequence. To use some other sort\r\n+     * of datastore identifier(a GUID, string, or someting of that nature),\r\n+     * override {@link #getManagedType},\r\n+     * {@link #getDataStoreIdType}, {@link #copyDataStoreId},\r\n+     * {@link #newDataStoreId}.\r\n+     */\r\n+    public Seq getDataStoreIdSequence(ClassMetaData forClass) {\r\n+        return ctx.getConfiguration().getSequenceInstance();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns null.\r\n+     */\r\n+    public Seq getValueSequence(FieldMetaData forField) {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns <code>false</code>. If your data store supports\r\n+     * cancelling queries, this method should cancel any\r\n+     * currently-running queries and return <code>true</code> if any\r\n+     * were cancelled.\r\n+     */\r\n+    public boolean cancelAll() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public void close() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Responsible for writing modifications happened back to the data\r\n+     * store. If you do not remove the\r\n+     * {@link OpenJPAConfiguration#OPTION_INC_FLUSH} option in\r\n+     * {@link #getUnsupportedOptions}, this will be called only once at the\r\n+     * end of a transaction. Otherwise, it may be called periodically\r\n+     * throughout the course of a transaction.\r\n+     * If this store manager supports optimistic transactions, datastore\r\n+     * version information should be updated during flush, and the state\r\n+     * manager's version indicator should be updated through the\r\n+     * {@link OpenJPAStateManager#setNextVersion} method.\r\n+     * This method will only be invoked if there are meaningful changes\r\n+     * to store. This differs from the behavior of {@link StoreManager#flush},\r\n+     * which may be invoked with a collection of objects in states that\r\n+     * do not require any datastore action(for example, objects in the\r\n+     * transient-transactional state).\r\n+     *\r\n+     * @param pNew               Objects that should be added to the store,\r\n+     *                           and that have not previously been flushed.\r\n+     * @param pNewUpdated        New objects that have been modified since\r\n+     *                           they were initially flushed. These were\r\n+     *                           in <code>persistentNew</code> in an earlier flush invocation.\r\n+     * @param pNewFlushedDeleted New objects that have been deleted since\r\n+     *                           they were initially flushed. These were\r\n+     *                           in <code>persistentNew</code> in an earlier flush invocation.\r\n+     * @param pDirty             Objects that were loaded from the data\r\n+     *                           store and have since been modified.\r\n+     * @param pDeleted           Objects that were loaded from the data\r\n+     *                           store and have since been deleted. These\r\n+     *                           may have been in a previous flush invocation's persistentDirty list.\r\n+     * @return a collection of exceptions encountered during flushing.\r\n+     */\r\n+    protected abstract Collection flush(Collection pNew,\r\n+        Collection pNewUpdated, Collection pNewFlushedDeleted,\r\n+        Collection pDirty, Collection pDeleted);\r\n+\r\n+    /**\r\n+     * Return a new configuration instance for this runtime. Configuration\r\n+     * data is maintained at the factory level and is available to all OpenJPA\r\n+     * components; therefore it is a good place to maintain shared resources\r\n+     * such as connection pools, etc.\r\n+     */\r\n+    protected OpenJPAConfiguration newConfiguration() {\r\n+        return new OpenJPAConfigurationImpl();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a set of option names that this store manager does\r\n+     * not support. By default, returns the following:\r\n+     * <ul>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_OPTIMISTIC}</li>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_ID_DATASTORE}</li>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_INC_FLUSH}</li>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_AUTOASSIGN}</li>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_VALUE_INCREMENT}</li>\r\n+     * <li>{@link OpenJPAConfiguration#OPTION_DATASTORE_CONNECTION}</li>\r\n+     * </ul>\r\n+     */\r\n+    protected Collection getUnsupportedOptions() {\r\n+        Collection c = new HashSet();\r\n+        c.add(OpenJPAConfiguration.OPTION_OPTIMISTIC);\r\n+        c.add(OpenJPAConfiguration.OPTION_ID_DATASTORE);\r\n+        c.add(OpenJPAConfiguration.OPTION_INC_FLUSH);\r\n+        c.add(OpenJPAConfiguration.OPTION_VALUE_AUTOASSIGN);\r\n+        c.add(OpenJPAConfiguration.OPTION_VALUE_INCREMENT);\r\n+        c.add(OpenJPAConfiguration.OPTION_DATASTORE_CONNECTION);\r\n+        return c;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a string name to identify the platform of this\r\n+     * store manager. Returns the class name of this store manager by default.\r\n+     */\r\n+    protected String getPlatform() {\r\n+        return getClass().getName();\r\n+    }\r\n+}\r"},{"sha":"7b8303d4aebe38c5f01794bdf0ce88273a7e396b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,59 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Abstract StoreManager Implementation</strong></p>\n+\n+<p>\n+    This package provides some infrastructure classes to help in the creation\n+    of OpenJPA drivers for new non-relational data stores.\n+</p>\n+\n+<p>\n+    To create support for a new data store:\n+    <ul>\n+        <li>\n+            <p>\n+                Extend <code>AbstractStoreManager</code> following the rules\n+                outlined in its documentation.\n+            </p>\n+        </li>\n+        <li>\n+            <p>\n+                Configure your org.apache.openjpa.properties file (or your\n+                resource archive\n+                configuration file) to use <code>\n+                AbstractStoreBrokerFactory</code>,\n+                and specify your <code>AbstractStore</code> extension as the\n+                <code>\n+                    org.apache.openjpa.abstractstore.AbstractStoreManager</code>\n+                class:\n+            </p>\n+\n+            <p>\n+                <code>\n+                    org.apache.openjpa.BrokerFactory: abstractstore<br/>\n+                    org.apache.openjpa.abstractstore.AbstractStoreManager:\n+                    com.xyz.MyAbstractStoreManagerSubclass\n+                </code>\n+            </p>\n+        </li>\n+    </ul>\n+</p>\n+\n+<p>\n+    Additionally, you can optionally extend <code>\n+    OpenJPAConfigurationImpl</code>\n+    to define your own configuration options, using the helper classes defined\n+    in the <a href=\"../../openjpa/conf/package.html\">\n+    <code>org.apache.openjpa.lib.conf</code></a> package. To do this you must\n+    also\n+    override the <code>AbstractStoreManager.newConfiguration</code> method.\n+</p>\n+\n+<p>\n+    For a sample of how to use this package, see the\n+    <a href=\"../xml/package.html\"><code>org.apache.openjpa.xmlstore</code></a>\n+    abstract\n+    store implementation.\n+</p>\n+</body>\n+</html>"},{"sha":"1d4d75dc1ee83c7ac23def80e088ae516553173b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,82 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.ant;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+\r\n+import org.apache.tools.ant.BuildException;\r\n+import org.apache.tools.ant.types.EnumeratedAttribute;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.lib.ant.AbstractTask;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.util.Files;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.MetaDataTool;\r\n+\r\n+/**\r\n+ * Executes the metadata tool on the specified files. This task can\r\n+ * take the following arguments:\r\n+ * <ul>\r\n+ * <li><code>file</code></li>\r\n+ * </ul>\r\n+ */\r\n+public class MetaDataToolTask extends AbstractTask {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (MetaDataToolTask.class);\r\n+    protected MetaDataTool.Flags flags = new MetaDataTool.Flags();\r\n+    protected String fileName = null;\r\n+\r\n+    /**\r\n+     * Set the tool action.\r\n+     */\r\n+    public void setAction(Action act) {\r\n+        flags.action = act.getValue();\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the file to write the metadata to.\r\n+     */\r\n+    public void setFile(String fileName) {\r\n+        this.fileName = fileName;\r\n+    }\r\n+\r\n+    protected Configuration newConfiguration() {\r\n+        return new OpenJPAConfigurationImpl();\r\n+    }\r\n+\r\n+    protected void executeOn(String[] files) throws IOException {\r\n+        ClassLoader loader = getClassLoader();\r\n+        if (\"stdout\".equals(fileName))\r\n+            flags.writer = new PrintWriter(System.out);\r\n+        else if (\"stderr\".equals(fileName))\r\n+            flags.writer = new PrintWriter(System.err);\r\n+        else if (fileName != null)\r\n+            flags.file = Files.getFile(fileName, loader);\r\n+        if (!MetaDataTool.run((OpenJPAConfiguration) getConfiguration(), files,\r\n+            flags, null, loader))\r\n+            throw new BuildException(_loc.get(\"bad-conf\", \"MetaDataToolTask\"));\r\n+    }\r\n+\r\n+    public static class Action extends EnumeratedAttribute {\r\n+\r\n+        public String[] getValues() {\r\n+            return MetaDataTool.ACTIONS;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"4c5ffe539f777a0a1ed89651bc1c750beed560b6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,86 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.ant;\r\n+\r\n+import java.io.IOException;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.enhance.PCEnhancer;\r\n+import org.apache.openjpa.lib.ant.AbstractTask;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.util.Files;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+\r\n+/**\r\n+ * Executes the enhancer on the specified files. This task can take\r\n+ * the following arguments:\r\n+ * <ul>\r\n+ * <li><code>directory</code></li>\r\n+ * <li><code>addDefaultConstructor</code></li>\r\n+ * <li><code>tmpClassLoader</code></li>\r\n+ * <li><code>enforcePropertyRestrictions</code></li>\r\n+ * </ul>\r\n+ */\r\n+public class PCEnhancerTask extends AbstractTask {\r\n+\r\n+    protected PCEnhancer.Flags flags = new PCEnhancer.Flags();\r\n+    protected String dirName = null;\r\n+\r\n+    /**\r\n+     * Set the output directory we want the enhancer to write to.\r\n+     */\r\n+    public void setDirectory(String dirName) {\r\n+        this.dirName = dirName;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set whether or not the enhancer should add a no-args constructor\r\n+     * to any PC that does not have a no-args constructor.\r\n+     */\r\n+    public void setAddDefaultConstructor(boolean addDefCons) {\r\n+        flags.addDefaultConstructor = addDefCons;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set whether to fail if the persistent type uses property access and\r\n+     * bytecode analysis shows that it may be violating OpenJPA's property\r\n+     * access restrictions.\r\n+     */\r\n+    public void setEnforcePropertyRestrictions(boolean fail) {\r\n+        flags.enforcePropertyRestrictions = fail;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set whether or not to use a default class loader for loading\r\n+     * the unenhanced classes.\r\n+     */\r\n+    public void setTmpClassLoader(boolean tmpClassLoader) {\r\n+        flags.tmpClassLoader = tmpClassLoader;\r\n+    }\r\n+\r\n+    protected Configuration newConfiguration() {\r\n+        return new OpenJPAConfigurationImpl();\r\n+    }\r\n+\r\n+    protected void executeOn(String[] files) throws IOException {\r\n+        flags.directory = (dirName == null) ? null\r\n+            : Files.getFile(dirName, getClassLoader());\r\n+        OpenJPAConfiguration conf = (OpenJPAConfiguration) getConfiguration();\r\n+        MetaDataRepository repos = new MetaDataRepository(conf);\r\n+        PCEnhancer.run(conf, files, flags, repos, null, getClassLoader());\r\n+    }\r\n+}\r"},{"sha":"99aeb836be0503991fa6fbf1e7b7c17a91c679c0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Ant Tasks</strong></p>\n+\n+<p>\n+    Ant tasks for OpenJPA tools.\n+</p>\n+</body>\n+</html>"},{"sha":"f33c8dda6082b6fb3d81d4a57c3546066fd0fb3c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,82 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.kernel.AutoDetach;\r\n+import org.apache.openjpa.lib.conf.Value;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Value type used to represent auto detach flags. Separate to\r\n+ * optimize translation of Strings to bit flags.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ */\r\n+class AutoDetachValue extends Value {\r\n+\r\n+    public static final String DETACH_CLOSE = \"close\";\r\n+    public static final String DETACH_COMMIT = \"commit\";\r\n+    public static final String DETACH_NONTXREAD = \"nontx-read\";\r\n+    private static String[] ALIASES = new String[]{\r\n+        DETACH_CLOSE, String.valueOf(AutoDetach.DETACH_CLOSE),\r\n+        DETACH_COMMIT, String.valueOf(AutoDetach.DETACH_COMMIT),\r\n+        DETACH_NONTXREAD, String.valueOf(AutoDetach.DETACH_NONTXREAD),\r\n+        // for compatibility with JDO DetachAllOnCommit\r\n+        \"true\", String.valueOf(AutoDetach.DETACH_COMMIT), \"false\", \"0\", };\r\n+    private int _flags;\r\n+\r\n+    public AutoDetachValue(String prop) {\r\n+        super(prop);\r\n+        setAliases(ALIASES);\r\n+    }\r\n+\r\n+    public Class getValueType() {\r\n+        return String[].class;\r\n+    }\r\n+\r\n+    public void set(int flags) {\r\n+        _flags = flags;\r\n+    }\r\n+\r\n+    public int get() {\r\n+        return _flags;\r\n+    }\r\n+\r\n+    protected String getInternalString() {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        String[] aliases = getAliases();\r\n+        boolean start = false;\r\n+        for (int i = 0; i < aliases.length; i += 2) {\r\n+            if ((_flags & Integer.parseInt(aliases[i + 1])) != 0) {\r\n+                buf.append(aliases[i]);\r\n+                if (start)\r\n+                    buf.append(\", \");\r\n+                else start = true;\r\n+            }\r\n+        }\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    public void setInternalString(String val) {\r\n+        String[] vals = Strings.split(val, \",\", 0);\r\n+        for (int i = 0; i < vals.length; i++)\r\n+            _flags |= Integer.parseInt(unalias(vals[i]));\r\n+    }\r\n+\r\n+    public void setInternalObject(Object val) {\r\n+        String[] vals = (String[]) val;\r\n+        for (int i = 0; i < vals.length; i++)\r\n+            _flags |= Integer.parseInt(unalias(vals[i]));\r\n+    }\r\n+}\r"},{"sha":"517688bc3a2eae15ab033c4ffa3e40447d7b0e19","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,42 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+\r\n+/**\r\n+ * Value type used to represent the {@link BrokerFactory}. This type is\r\n+ * defined separately so that it can be used both in the global configuration\r\n+ * and in {@link OpenJPAHelper} with the same encapsulated configuration.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class BrokerFactoryValue extends PluginValue {\r\n+\r\n+    public static final String KEY = \"org.apache.openjpa.BrokerFactory\";\r\n+    private static final String[] ALIASES = new String[]{\r\n+        \"abstractstore\",\r\n+        \"org.apache.openjpa.abstractstore.AbstractStoreBrokerFactory\",\r\n+    };\r\n+\r\n+    public BrokerFactoryValue() {\r\n+        this(KEY);\r\n+    }\r\n+\r\n+    public BrokerFactoryValue(String prop) {\r\n+        super(prop, false);\r\n+        setAliases(ALIASES);\r\n+    }\r\n+}\r"},{"sha":"d8fca615dc8aed310cbbc1a8e7bb90f798479080","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"added","additions":136,"deletions":0,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,136 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+/**\r\n+ * Struct encompassing backwards-compatibility options.\r\n+ */\r\n+public class Compatibility {\r\n+\r\n+    private boolean _strictIdValues = false;\r\n+    private boolean _hollowLookups = true;\r\n+    private boolean _checkStore = false;\r\n+    private boolean _copyIds = false;\r\n+    private boolean _closeOnCommit = true;\r\n+    private boolean _quotedNumbers = false;\r\n+\r\n+    /**\r\n+     * Whether to require exact identity value types when creating object\r\n+     * ids from a class and value. Defaults to false.\r\n+     */\r\n+    public boolean getStrictIdentityValues() {\r\n+        return _strictIdValues;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to require exact identity value types when creating object\r\n+     * ids from a class and value. Defaults to false.\r\n+     */\r\n+    public void setStrictIdentityValues(boolean strictVals) {\r\n+        _strictIdValues = strictVals;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to interpret quoted numbers in query strings as numbers.\r\n+     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\r\n+     * versions treat them as strings.\r\n+     */\r\n+    public boolean getQuotedNumbersInQueries() {\r\n+        return _quotedNumbers;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to interpret quoted numbers in query strings as numbers.\r\n+     * OpenJPA versions 3.1 and prior treated them as numbers; more recent\r\n+     * versions treat them as strings.\r\n+     */\r\n+    public void setQuotedNumbersInQueries(boolean quotedNumbers) {\r\n+        _quotedNumbers = quotedNumbers;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to return hollow instances to broker lookups with a\r\n+     * <code>validate</code> parameter of false. OpenJPA versions prior to\r\n+     * 4.0 did not return hollow instances without special configuration\r\n+     * (the <code>ObjectLookupMode</code>). Beginning with 4.0, hollow\r\n+     * objects are the default.\r\n+     */\r\n+    public boolean getValidateFalseReturnsHollow() {\r\n+        return _hollowLookups;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to return hollow instances to broker lookups with a\r\n+     * <code>validate</code> parameter of false. OpenJPA versions prior to\r\n+     * 4.0 did not return hollow instances without special configuration\r\n+     * (the <code>ObjectLookupMode</code>). Beginning with 4.0, hollow\r\n+     * objects are the default.\r\n+     */\r\n+    public void setValidateFalseReturnsHollow(boolean hollow) {\r\n+        _hollowLookups = hollow;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to check the datastore for the existence of a nontransactional\r\n+     * cached object in broker lookups with a <code>validate</code> parameter\r\n+     * of true. OpenJPA versions prior to 4.0 checked the datastore.\r\n+     */\r\n+    public boolean getValidateTrueChecksStore() {\r\n+        return _checkStore;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to check the datastore for the existence of a nontransactional\r\n+     * cached object in broker lookups with a <code>validate</code> parameter\r\n+     * of true. OpenJPA versions prior to 4.0 checked the datastore.\r\n+     */\r\n+    public void setValidateTrueChecksStore(boolean check) {\r\n+        _checkStore = check;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to copy identity objects before returning them to client code.\r\n+     * Versions of OpenJPA prior to 3.0 always copied identity objects. Also,\r\n+     * you should configure OpenJPA to copy identity objects if you mutate them\r\n+     * after use.\r\n+     */\r\n+    public boolean getCopyObjectIds() {\r\n+        return _copyIds;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to copy identity objects before returning them to client code.\r\n+     * Versions of OpenJPA prior to 3.0 always copied identity objects. Also,\r\n+     * you should configure OpenJPA to copy identity objects if you mutate them\r\n+     * after use.\r\n+     */\r\n+    public void setCopyObjectIds(boolean copy) {\r\n+        _copyIds = copy;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to close the broker when the managed transaction commits.\r\n+     * Versions of OpenJPA prior to 3.0 did not close the broker.\r\n+     */\r\n+    public boolean getCloseOnManagedCommit() {\r\n+        return _closeOnCommit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to close the broker when the managed transaction commits.\r\n+     * Versions of OpenJPA prior to 3.0 did not close the broker.\r\n+     */\r\n+    public void setCloseOnManagedCommit(boolean close) {\r\n+        _closeOnCommit = close;\r\n+    }\r\n+}\r"},{"sha":"d6c3bd4b0b0808eb5f81ee42f3d0fa82dd392444","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,149 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.kernel.DetachState;\r\n+\r\n+/**\r\n+ * Detach options.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public abstract class DetachOptions implements DetachState {\r\n+\r\n+    private boolean _field = true;\r\n+    private boolean _transient = true;\r\n+    private boolean _manager = true;\r\n+    private boolean _access = true;\r\n+\r\n+    /**\r\n+     * The {@link DetachState} constant.\r\n+     */\r\n+    public abstract int getDetachState();\r\n+\r\n+    /**\r\n+     * Whether to add a detached state field to enhanced classes.\r\n+     */\r\n+    public boolean getDetachedStateField() {\r\n+        return _field;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to add a detached state field to enhanced classes.\r\n+     */\r\n+    public void setDetachedStateField(boolean val) {\r\n+        _field = val;\r\n+        if (!val)\r\n+            _manager = false;\r\n+    }\r\n+\r\n+    /**\r\n+     * For auto-configuration of the detached state field. Accepts values\r\n+     * \"true\", \"false\", or \"transient\".\r\n+     */\r\n+    public void setDetachedStateField(String val) {\r\n+        if (val == null)\r\n+            return;\r\n+        if (\"transient\".equals(val)) {\r\n+            setDetachedStateField(true);\r\n+            _transient = true;\r\n+        } else if (\"true\".equals(val)) {\r\n+            setDetachedStateField(true);\r\n+            _transient = false;\r\n+        } else if (\"false\".equals(val)) {\r\n+            setDetachedStateField(false);\r\n+            _transient = false;\r\n+        } else throw new IllegalArgumentException(\"DetachedStateField=\" + val);\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to use transient detached state.\r\n+     */\r\n+    public boolean isDetachedStateTransient() {\r\n+        return _transient;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to use transient detached state.\r\n+     */\r\n+    public void setDetachedStateTransient(boolean val) {\r\n+        _transient = val;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to use a detached state manager on types that allow it.\r\n+     * Types that do not use detached state or that declare a custom detached\r\n+     * state field to maintain serialization compatibility will never use\r\n+     * a detached state manager. Defaults to true.\r\n+     */\r\n+    public boolean getDetachedStateManager() {\r\n+        return _manager;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to use a detached state manager on types that allow it.\r\n+     * Types that do not use detached state or that declare a custom detached\r\n+     * state field to maintain serialization compatibility will never use\r\n+     * a detached state manager. Defaults to true.\r\n+     */\r\n+    public void setDetachedStateManager(boolean val) {\r\n+        _manager = val;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to allow access to unloaded detached fields. This setting only\r\n+     * applies to instances with detached state managers.\r\n+     */\r\n+    public boolean getAccessUnloaded() {\r\n+        return _access;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to allow access to unloaded detached fields. This setting only\r\n+     * applies to instances with detached state managers.\r\n+     */\r\n+    public void setAccessUnloaded(boolean val) {\r\n+        _access = val;\r\n+    }\r\n+\r\n+    /**\r\n+     * Detach loaded state.\r\n+     */\r\n+    public static class Loaded extends DetachOptions {\r\n+\r\n+        public int getDetachState() {\r\n+            return DETACH_LOADED;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Public to allow reflection.\r\n+     */\r\n+    public static class FetchGroups extends DetachOptions {\r\n+\r\n+        public int getDetachState() {\r\n+            return DETACH_FGS;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Public to allow reflection.\r\n+     */\r\n+    public static class All extends DetachOptions {\r\n+\r\n+        public int getDetachState() {\r\n+            return DETACH_ALL;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"edbb35bcf9ef6cbd528b6efcd525c460932cbc65","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","status":"added","additions":1324,"deletions":0,"changes":1324,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1324 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.openjpa.datacache.DataCache;\r\n+import org.apache.openjpa.datacache.DataCacheManager;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.event.OrphanedKeyAction;\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.event.RemoteCommitProvider;\r\n+import org.apache.openjpa.kernel.AutoClear;\r\n+import org.apache.openjpa.kernel.AutoDetach;\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.InverseManager;\r\n+import org.apache.openjpa.kernel.LockManager;\r\n+import org.apache.openjpa.kernel.QueryFlushModes;\r\n+import org.apache.openjpa.kernel.RestoreState;\r\n+import org.apache.openjpa.kernel.SavepointManager;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.meta.MetaDataFactory;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ClassResolver;\r\n+import org.apache.openjpa.util.ProxyManager;\r\n+\r\n+/**\r\n+ * Defines the properties necessary to configure runtime properties and\r\n+ * connect to a data source. There is a 1-1 relation between a configuration\r\n+ * and a {@link BrokerFactory}.\r\n+ * All setter methods that take primitive parameters also have wrapper\r\n+ * setter with the appropriate primitive wrapper. This is so the interface\r\n+ * can be in accordance with the J2EE Connector Architecture.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ * @author Abe White\r\n+ * @see Configuration\r\n+ */\r\n+public interface OpenJPAConfiguration extends Configuration {\r\n+\r\n+    /**\r\n+     * Name of logger for metadata-related messages:\r\n+     * <code>org.apache.openjpa.MetaData</code>.\r\n+     */\r\n+    public static final String LOG_METADATA = \"org.apache.openjpa.MetaData\";\r\n+\r\n+    /**\r\n+     * Name of logger for enhancement-related messages:\r\n+     * <code>org.apache.openjpa.Enhance</code>.\r\n+     */\r\n+    public static final String LOG_ENHANCE = \"org.apache.openjpa.Enhance\";\r\n+\r\n+    /**\r\n+     * Name of logger for messages from the runtime system:\r\n+     * <code>org.apache.openjpa.Runtime</code>.\r\n+     */\r\n+    public static final String LOG_RUNTIME = \"org.apache.openjpa.Runtime\";\r\n+\r\n+    /**\r\n+     * Name of logger for query logging:\r\n+     * <code>org.apache.openjpa.Query</code>.\r\n+     */\r\n+    public static final String LOG_QUERY = \"org.apache.openjpa.Query\";\r\n+\r\n+    /**\r\n+     * Name of logger for messages from the data cache:\r\n+     * <code>org.apache.openjpa.DataCache</code>.\r\n+     */\r\n+    public static final String LOG_DATACACHE = \"org.apache.openjpa.DataCache\";\r\n+\r\n+    /**\r\n+     * Name of logger for messages from the development tools:\r\n+     * <code>org.apache.openjpa.Tool</code>.\r\n+     */\r\n+    public static final String LOG_TOOL = \"org.apache.openjpa.Tool\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support nontransactional reads.\r\n+     */\r\n+    public static final String OPTION_NONTRANS_READ =\r\n+        \"org.apache.openjpa.option.NontransactionalRead\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support optimistic transactions.\r\n+     */\r\n+    public static final String OPTION_OPTIMISTIC =\r\n+        \"org.apache.openjpa.option.Optimistic\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support application identity.\r\n+     */\r\n+    public static final String OPTION_ID_APPLICATION =\r\n+        \"org.apache.openjpa.option.ApplicationIdentity\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support application identity.\r\n+     */\r\n+    public static final String OPTION_ID_DATASTORE =\r\n+        \"org.apache.openjpa.option.DatastoreIdentity\";\r\n+\r\n+    /**\r\n+     * Option for SQL support.\r\n+     */\r\n+    public static final String OPTION_QUERY_SQL =\r\n+        \"org.apache.openjpa.option.SQL\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support persistent collection fields.\r\n+     */\r\n+    public static final String OPTION_TYPE_COLLECTION =\r\n+        \"org.apache.openjpa.option.Collection\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support persistent map fields.\r\n+     */\r\n+    public static final String OPTION_TYPE_MAP =\r\n+        \"org.apache.openjpa.option.Map\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support persistent array fields.\r\n+     */\r\n+    public static final String OPTION_TYPE_ARRAY =\r\n+        \"org.apache.openjpa.option.Array\";\r\n+\r\n+    /**\r\n+     * Option for runtime that can differentiate between null and empty\r\n+     * container fields.\r\n+     */\r\n+    public static final String OPTION_NULL_CONTAINER =\r\n+        \"org.apache.openjpa.option.NullContainer\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support embedded relations to other\r\n+     * persistence capable objects.\r\n+     */\r\n+    public static final String OPTION_EMBEDDED_RELATION =\r\n+        \"org.apache.openjpa.option.EmbeddedRelation\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support collections of embedded\r\n+     * relations to other persistence capable objects.\r\n+     */\r\n+    public static final String OPTION_EMBEDDED_COLLECTION_RELATION =\r\n+        \"org.apache.openjpa.option.EmbeddedCollectionRelation\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support maps of embedded\r\n+     * relations to other persistence capable objects.\r\n+     */\r\n+    public static final String OPTION_EMBEDDED_MAP_RELATION =\r\n+        \"org.apache.openjpa.option.EmbeddedMapRelation\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support incremental flushing.\r\n+     */\r\n+    public static final String OPTION_INC_FLUSH =\r\n+        \"org.apache.openjpa.option.IncrementalFlush\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that the autoassign value strategy.\r\n+     */\r\n+    public static final String OPTION_VALUE_AUTOASSIGN =\r\n+        \"org.apache.openjpa.option.AutoassignValue\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that the increment value strategy.\r\n+     */\r\n+    public static final String OPTION_VALUE_INCREMENT =\r\n+        \"org.apache.openjpa.option.IncrementValue\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support returning the datastore connection.\r\n+     */\r\n+    public static final String OPTION_DATASTORE_CONNECTION =\r\n+        \"org.apache.openjpa.option.DataStoreConnection\";\r\n+\r\n+    /**\r\n+     * Option for runtimes that support returning the datastore connection\r\n+     * that is a JDBC Connection.\r\n+     */\r\n+    public static final String OPTION_JDBC_CONNECTION =\r\n+        \"org.apache.openjpa.option.JDBCConnection\";\r\n+\r\n+    /**\r\n+     * Return the set of option strings supported by this runtime. This set\r\n+     * is mutable.\r\n+     */\r\n+    public Collection supportedOptions();\r\n+\r\n+    /**\r\n+     * A configuration can be set with defaults for a specific specification.\r\n+     */\r\n+    public String getSpecification();\r\n+\r\n+    /**\r\n+     * Set the specification that this configuration should use for the\r\n+     * various properties that need to have different defaults for different\r\n+     * spec environments. This should be invoked before any configuration\r\n+     * options are set, as it will mutate various values.\r\n+     * You can only assign the specification once, though it is not fatal\r\n+     * to attempt to do so multiple times. Attempts to set to null will\r\n+     * be ignored.\r\n+     */\r\n+    public boolean setSpecification(String spec);\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ClassResolver} to use for custom\r\n+     * class loading.\r\n+     */\r\n+    public String getClassResolver();\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ClassResolver} to use for custom\r\n+     * class loading.\r\n+     */\r\n+    public void setClassResolver(String classResolver);\r\n+\r\n+    /**\r\n+     * The {@link ClassResolver} to use.\r\n+     */\r\n+    public ClassResolver getClassResolverInstance();\r\n+\r\n+    /**\r\n+     * The {@link ClassResolver} to use.\r\n+     */\r\n+    public void setClassResolver(ClassResolver classResolver);\r\n+\r\n+    /**\r\n+     * The {@link BrokerFactory} class to use.\r\n+     */\r\n+    public String getBrokerFactory();\r\n+\r\n+    /**\r\n+     * The {@link BrokerFactory} class to use.\r\n+     */\r\n+    public void setBrokerFactory(String factory);\r\n+\r\n+    /**\r\n+     * The plugin string of the {@link BrokerImpl} extension to create.\r\n+     */\r\n+    public String getBrokerImpl();\r\n+\r\n+    /**\r\n+     * The plugin string of the {@link BrokerImpl} extension to create.\r\n+     */\r\n+    public void setBrokerImpl(String broker);\r\n+\r\n+    /**\r\n+     * Create a new broker instance with the configured plugin data.\r\n+     */\r\n+    public BrokerImpl newBrokerInstance(String user, String pass);\r\n+\r\n+    /**\r\n+     * The {@link DataCache} to use for level-2 data store caching.\r\n+     */\r\n+    public String getDataCache();\r\n+\r\n+    /**\r\n+     * The {@link DataCache} to use for level-2 data store caching.\r\n+     */\r\n+    public void setDataCache(String dataCache);\r\n+\r\n+    /**\r\n+     * The data cache manager manages this configuration's cache instances.\r\n+     */\r\n+    public String getDataCacheManager();\r\n+\r\n+    /**\r\n+     * The data cache manager manages this configuration's cache instances.\r\n+     */\r\n+    public void setDataCacheManager(String mgr);\r\n+\r\n+    /**\r\n+     * The data cache manager manages this configuration's cache instances.\r\n+     * The cache manager is created if it has not been set. Once the cache\r\n+     * manager has been set/created, all changes to caching configuration\r\n+     * must proceed through the cache manager.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public DataCacheManager getDataCacheManagerInstance();\r\n+\r\n+    /**\r\n+     * The data cache manager manages this configuration's cache instances.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public void setDataCacheManager(DataCacheManager manager);\r\n+\r\n+    /**\r\n+     * Default data cache timeout.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public int getDataCacheTimeout();\r\n+\r\n+    /**\r\n+     * Default data cache timeout.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setDataCacheTimeout(int timeout);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setDataCacheTimeout(int)}.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setDataCacheTimeout(Integer timeout);\r\n+\r\n+    /**\r\n+     * The plugin to use for level-2 data store query caching.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getQueryCache();\r\n+\r\n+    /**\r\n+     * The plugin to use for level-2 data store query caching.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setQueryCache(String queryCache);\r\n+\r\n+    /**\r\n+     * Return whether to generate dynamic data structures\r\n+     * where possible for cache and runtime usage.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public boolean getDynamicDataStructs();\r\n+\r\n+    /**\r\n+     * Set whether to generate dynamic data structures\r\n+     * where possible for cache and runtime usage.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public void setDynamicDataStructs(boolean dynamic);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setDynamicDataStructs(boolean)}.\r\n+     */\r\n+    public void setDynamicDataStructs(Boolean dynamic);\r\n+\r\n+    /**\r\n+     * The plugin to use for datastore lock management.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public String getLockManager();\r\n+\r\n+    /**\r\n+     * The plugin to use for datastore lock management.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setLockManager(String lockManager);\r\n+\r\n+    /**\r\n+     * Return a new lock manager instance using the configured plugin settings.\r\n+     */\r\n+    public LockManager newLockManagerInstance();\r\n+\r\n+    /**\r\n+     * The plugin to use for managing inverse relations.\r\n+     *\r\n+     * @since 3.2\r\n+     */\r\n+    public String getInverseManager();\r\n+\r\n+    /**\r\n+     * The plugin to use for managing inverse relations.\r\n+     *\r\n+     * @since 3.2\r\n+     */\r\n+    public void setInverseManager(String inverse);\r\n+\r\n+    /**\r\n+     * Return a new inverse manager instance using the configured plugin\r\n+     * settings.\r\n+     *\r\n+     * @since 3.2\r\n+     */\r\n+    public InverseManager newInverseManagerInstance();\r\n+\r\n+    /**\r\n+     * The plugin to use for savepoint management.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public String getSavepointManager();\r\n+\r\n+    /**\r\n+     * The plugin to use for savepoint management.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public void setSavepointManager(String savepointManager);\r\n+\r\n+    /**\r\n+     * Return the configured savepoint manager instance.\r\n+     */\r\n+    public SavepointManager getSavepointManagerInstance();\r\n+\r\n+    /**\r\n+     * The action to take when an orphaned key is detected.\r\n+     *\r\n+     * @since 3.2.2\r\n+     */\r\n+    public String getOrphanedKeyAction();\r\n+\r\n+    /**\r\n+     * The action to take when an orphaned key is detected.\r\n+     *\r\n+     * @since 3.2.2\r\n+     */\r\n+    public void setOrphanedKeyAction(String action);\r\n+\r\n+    /**\r\n+     * The action to take when an orphaned key is detected.\r\n+     *\r\n+     * @since 3.2.2\r\n+     */\r\n+    public OrphanedKeyAction getOrphanedKeyActionInstance();\r\n+\r\n+    /**\r\n+     * The action to take when an orphaned key is detected.\r\n+     *\r\n+     * @since 3.2.2\r\n+     */\r\n+    public void setOrphanedKeyAction(OrphanedKeyAction action);\r\n+\r\n+    /**\r\n+     * The plugin to use for remote commit notification.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getRemoteCommitProvider();\r\n+\r\n+    /**\r\n+     * The plugin to use for remote commit notification.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setRemoteCommitProvider(String remoteCommitProvider);\r\n+\r\n+    /**\r\n+     * Create a remote commit provider from the configured plugin.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public RemoteCommitProvider newRemoteCommitProviderInstance();\r\n+\r\n+    /**\r\n+     * The remote event manager that manages this configuration's remote\r\n+     * event listeners.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public RemoteCommitEventManager getRemoteCommitEventManager();\r\n+\r\n+    /**\r\n+     * The remote event manager that manages this configuration's remote\r\n+     * event listeners.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public void setRemoteCommitEventManager(RemoteCommitEventManager manager);\r\n+\r\n+    /**\r\n+     * Specifies the behavior of the transaction featureSelection. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>local</code>: Perform transaction operations locally.</li>\r\n+     * <li><code>managed</code>: Use managed environment's global\r\n+     * transactions.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getTransactionMode();\r\n+\r\n+    /**\r\n+     * Specifies the behavior of the transaction featureSelection. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>local</code>: Perform transaction operations locally.</li>\r\n+     * <li><code>managed</code>: Use managed environment's global\r\n+     * transactions.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setTransactionMode(String mode);\r\n+\r\n+    /**\r\n+     * Return whether managed transactions are being used.\r\n+     */\r\n+    public boolean isTransactionModeManaged();\r\n+\r\n+    /**\r\n+     * Set whether managed transactions are being used.\r\n+     */\r\n+    public void setTransactionModeManaged(boolean managed);\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ManagedRuntime} to use for managed\r\n+     * environments.\r\n+     */\r\n+    public String getManagedRuntime();\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ManagedRuntime} to use for managed\r\n+     * environments.\r\n+     */\r\n+    public void setManagedRuntime(String managedRuntime);\r\n+\r\n+    /**\r\n+     * The plugin to use for integrating with a managed runtime.\r\n+     */\r\n+    public ManagedRuntime getManagedRuntimeInstance();\r\n+\r\n+    /**\r\n+     * The plugin to use for integrating with a managed runtime.\r\n+     */\r\n+    public void setManagedRuntime(ManagedRuntime runtime);\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ProxyManager} to use for second\r\n+     * class object proxies.\r\n+     */\r\n+    public String getProxyManager();\r\n+\r\n+    /**\r\n+     * The plugin string for the {@link ProxyManager} to use for second\r\n+     * class object proxies.\r\n+     */\r\n+    public void setProxyManager(String proxyManager);\r\n+\r\n+    /**\r\n+     * The {@link ProxyManager} to use.\r\n+     */\r\n+    public ProxyManager getProxyManagerInstance();\r\n+\r\n+    /**\r\n+     * The {@link ProxyManager} to use.\r\n+     */\r\n+    public void setProxyManager(ProxyManager manager);\r\n+\r\n+    /**\r\n+     * The name mapping to use for this data store.\r\n+     */\r\n+    public String getMapping();\r\n+\r\n+    /**\r\n+     * The name mapping to use for this data store.\r\n+     */\r\n+    public void setMapping(String mapping);\r\n+\r\n+    /**\r\n+     * A plugin string describing the {@link MetaDataFactory} to use.\r\n+     */\r\n+    public String getMetaDataFactory();\r\n+\r\n+    /**\r\n+     * A plugin string describing the {@link MetaDataFactory} to use.\r\n+     */\r\n+    public void setMetaDataFactory(String meta);\r\n+\r\n+    /**\r\n+     * Create a new {@link MetaDataFactory} to use with a repository.\r\n+     */\r\n+    public MetaDataFactory newMetaDataFactoryInstance();\r\n+\r\n+    /**\r\n+     * The metadata repository of managed class information. If no\r\n+     * repository has been set, creates one.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public MetaDataRepository getMetaDataRepository();\r\n+\r\n+    /**\r\n+     * The metadata repository of managed class information.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public void setMetaDataRepository(MetaDataRepository mdRepos);\r\n+\r\n+    /**\r\n+     * The user name for the data store connection.\r\n+     */\r\n+    public String getConnectionUserName();\r\n+\r\n+    /**\r\n+     * The user name for the data store connection.\r\n+     */\r\n+    public void setConnectionUserName(String connectionUserName);\r\n+\r\n+    /**\r\n+     * The password for the data store connection.\r\n+     */\r\n+    public String getConnectionPassword();\r\n+\r\n+    /**\r\n+     * The password for the data store connection.\r\n+     */\r\n+    public void setConnectionPassword(String connectionPassword);\r\n+\r\n+    /**\r\n+     * The URL for the data store connection.\r\n+     */\r\n+    public String getConnectionURL();\r\n+\r\n+    /**\r\n+     * The URL for the data store connection.\r\n+     */\r\n+    public void setConnectionURL(String connectionURL);\r\n+\r\n+    /**\r\n+     * Class name of the connection driver.\r\n+     */\r\n+    public String getConnectionDriverName();\r\n+\r\n+    /**\r\n+     * Class name of the connection driver.\r\n+     */\r\n+    public void setConnectionDriverName(String driverName);\r\n+\r\n+    /**\r\n+     * The name for the data store connection factory.\r\n+     */\r\n+    public String getConnectionFactoryName();\r\n+\r\n+    /**\r\n+     * The name for the data store connection factory.\r\n+     */\r\n+    public void setConnectionFactoryName(String cfName);\r\n+\r\n+    /**\r\n+     * The connection factory, possibly from JNDI.\r\n+     */\r\n+    public Object getConnectionFactory();\r\n+\r\n+    /**\r\n+     * The connection factory.\r\n+     */\r\n+    public void setConnectionFactory(Object factory);\r\n+\r\n+    /**\r\n+     * These properties provide any additional information needed to\r\n+     * establish connections.\r\n+     */\r\n+    public String getConnectionProperties();\r\n+\r\n+    /**\r\n+     * These properties provide any additional information needed to\r\n+     * establish connections.\r\n+     */\r\n+    public void setConnectionProperties(String props);\r\n+\r\n+    /**\r\n+     * Configuration properties for the connection factory.\r\n+     */\r\n+    public String getConnectionFactoryProperties();\r\n+\r\n+    /**\r\n+     * Configuration properties for the connection factory.\r\n+     */\r\n+    public void setConnectionFactoryProperties(String props);\r\n+\r\n+    /**\r\n+     * The mode of the connection factory in use. Available options are:\r\n+     * <ul>\r\n+     * <li>local: OpenJPA controls the connections.</li>\r\n+     * <li>managed: Connections are automatically enlisted in\r\n+     * the current global transaction by an application server.</li>\r\n+     * </ul> Defaults to local.\r\n+     */\r\n+    public String getConnectionFactoryMode();\r\n+\r\n+    /**\r\n+     * The mode of the connection factory in use. Available options are:\r\n+     * <ul>\r\n+     * <li>local: OpenJPA controls the connections.</li>\r\n+     * <li>managed: Connections are automatically enlisted in\r\n+     * the current global transaction by an application server.</li>\r\n+     * </ul> Defaults to local.\r\n+     */\r\n+    public void setConnectionFactoryMode(String mode);\r\n+\r\n+    /**\r\n+     * Whether connections are automatically enlisted in global transactions.\r\n+     */\r\n+    public boolean isConnectionFactoryModeManaged();\r\n+\r\n+    /**\r\n+     * Whether connections are automatically enlisted in global transactions.\r\n+     */\r\n+    public void setConnectionFactoryModeManaged(boolean managed);\r\n+\r\n+    /**\r\n+     * The user name for the non-XA data store connection.\r\n+     */\r\n+    public String getConnection2UserName();\r\n+\r\n+    /**\r\n+     * The user name for the non-XA data store connection.\r\n+     */\r\n+    public void setConnection2UserName(String connectionUserName);\r\n+\r\n+    /**\r\n+     * The password for the non-XA data store connection.\r\n+     */\r\n+    public String getConnection2Password();\r\n+\r\n+    /**\r\n+     * The password for the non-XA data store connection.\r\n+     */\r\n+    public void setConnection2Password(String connectionPassword);\r\n+\r\n+    /**\r\n+     * The URL for the non-XA data store connection.\r\n+     */\r\n+    public String getConnection2URL();\r\n+\r\n+    /**\r\n+     * The URL for the non-XA data store connection.\r\n+     */\r\n+    public void setConnection2URL(String connectionURL);\r\n+\r\n+    /**\r\n+     * Class name of the non-XA connection driver.\r\n+     */\r\n+    public String getConnection2DriverName();\r\n+\r\n+    /**\r\n+     * Class name of the non-XA connection driver.\r\n+     */\r\n+    public void setConnection2DriverName(String driverName);\r\n+\r\n+    /**\r\n+     * The name for the second data store connection factory.\r\n+     */\r\n+    public String getConnectionFactory2Name();\r\n+\r\n+    /**\r\n+     * The name for the second data store connection factory.\r\n+     */\r\n+    public void setConnectionFactory2Name(String cf2Name);\r\n+\r\n+    /**\r\n+     * The non-XA connection factory.\r\n+     */\r\n+    public Object getConnectionFactory2();\r\n+\r\n+    /**\r\n+     * The non-XA connection factory.\r\n+     */\r\n+    public void setConnectionFactory2(Object factory);\r\n+\r\n+    /**\r\n+     * These properties provide any additional information needed to\r\n+     * establish non-XA connections.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public String getConnection2Properties();\r\n+\r\n+    /**\r\n+     * These properties provide any additional information needed to\r\n+     * establish non-XA connections.\r\n+     *\r\n+     * @since 3.0\r\n+     */\r\n+    public void setConnection2Properties(String props);\r\n+\r\n+    /**\r\n+     * Configuration properties for the non-XA connection factory.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getConnectionFactory2Properties();\r\n+\r\n+    /**\r\n+     * Configuration properties for the non-XA connection factory.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setConnectionFactory2Properties(String props);\r\n+\r\n+    /**\r\n+     * Whether to use optimistic transactions by default.\r\n+     */\r\n+    public boolean getOptimistic();\r\n+\r\n+    /**\r\n+     * Whether to use optimistic transactions by default.\r\n+     */\r\n+    public void setOptimistic(boolean optimistic);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setOptimistic(boolean)}.\r\n+     */\r\n+    public void setOptimistic(Boolean optimistic);\r\n+\r\n+    /**\r\n+     * Whether to retain state after a transaction by default.\r\n+     */\r\n+    public boolean getRetainState();\r\n+\r\n+    /**\r\n+     * Whether to retain state after a transaction by default.\r\n+     */\r\n+    public void setRetainState(boolean retainState);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setRetainState(boolean)}.\r\n+     */\r\n+    public void setRetainState(Boolean retainState);\r\n+\r\n+    /**\r\n+     * Whether instances clear their state when entering a transaction.\r\n+     */\r\n+    public String getAutoClear();\r\n+\r\n+    /**\r\n+     * Whether instances clear their state when entering a transaction.\r\n+     */\r\n+    public void setAutoClear(String clear);\r\n+\r\n+    /**\r\n+     * Return the {@link AutoClear} constant.\r\n+     */\r\n+    public int getAutoClearConstant();\r\n+\r\n+    /**\r\n+     * Whether instances clear their state when entering a transaction.\r\n+     */\r\n+    public void setAutoClear(int clear);\r\n+\r\n+    /**\r\n+     * Whether to restore initial state on rollback by default.\r\n+     */\r\n+    public String getRestoreState();\r\n+\r\n+    /**\r\n+     * Whether to restore initial state on rollback by default.\r\n+     */\r\n+    public void setRestoreState(String restoreState);\r\n+\r\n+    /**\r\n+     * Return the {@link RestoreState} constant.\r\n+     */\r\n+    public int getRestoreStateConstant();\r\n+\r\n+    /**\r\n+     * Whether to restore initial state on rollback by default.\r\n+     */\r\n+    public void setRestoreState(int restoreState);\r\n+\r\n+    /**\r\n+     * Whether changes in the current transaction are taken into account when\r\n+     * executing queries and iterating extents.\r\n+     */\r\n+    public boolean getIgnoreChanges();\r\n+\r\n+    /**\r\n+     * Whether changes in the current transaction are taken into account when\r\n+     * executing queries and iterating extents.\r\n+     */\r\n+    public void setIgnoreChanges(boolean ignoreChanges);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setIgnoreChanges(boolean)}.\r\n+     */\r\n+    public void setIgnoreChanges(Boolean ignoreChanges);\r\n+\r\n+    /**\r\n+     * A comma-separated list of events which trigger auto-detachment\r\n+     * in place of managed states. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>commit</code>: When the current transaction commits.</li>\r\n+     * <li><code>close</code>: When the broker closes.</li>\r\n+     * <li><code>nontx-read</code>: When instances are read\r\n+     * non-transactionally.</li>\r\n+     * </ul>\r\n+     */\r\n+    public String getAutoDetach();\r\n+\r\n+    /**\r\n+     * A comma-separated list of events which trigger auto-detachment\r\n+     * in place of managed states. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>commit</code>: When the current transaction commits.</li>\r\n+     * <li><code>close</code>: When the broker closes.</li>\r\n+     * <li><code>nontx-read</code>: When instances are read\r\n+     * non-transactionally.</li>\r\n+     * </ul>\r\n+     */\r\n+    public void setAutoDetach(String detach);\r\n+\r\n+    /**\r\n+     * The {@link AutoDetach} flags.\r\n+     */\r\n+    public int getAutoDetachConstant();\r\n+\r\n+    /**\r\n+     * The {@link AutoDetach} flags.\r\n+     */\r\n+    public void setAutoDetach(int flags);\r\n+\r\n+    /**\r\n+     * Which field values to include when detaching.\r\n+     */\r\n+    public void setDetachState(String detachState);\r\n+\r\n+    /**\r\n+     * Return the instance specified by the detach state plugin.\r\n+     */\r\n+    public DetachOptions getDetachStateInstance();\r\n+\r\n+    /**\r\n+     * Return the instance specified by the detach state plugin.\r\n+     */\r\n+    public void setDetachState(DetachOptions detachState);\r\n+\r\n+    /**\r\n+     * Whether persistent state is accessible outside a transaction by default.\r\n+     */\r\n+    public boolean getNontransactionalRead();\r\n+\r\n+    /**\r\n+     * Whether persistent state is accessible outside a transaction by default.\r\n+     */\r\n+    public void setNontransactionalRead(boolean ntRead);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setNontransactionalRead(boolean)}.\r\n+     */\r\n+    public void setNontransactionalRead(Boolean ntRead);\r\n+\r\n+    /**\r\n+     * Whether persistent state can be modified outside a transaction by\r\n+     * default.\r\n+     */\r\n+    public boolean getNontransactionalWrite();\r\n+\r\n+    /**\r\n+     * Whether persistent state can be modified outside a transaction by\r\n+     * default.\r\n+     */\r\n+    public void setNontransactionalWrite(boolean ntWrite);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setNontransactionalWrite(boolean)}.\r\n+     */\r\n+    public void setNontransactionalWrite(Boolean ntWrite);\r\n+\r\n+    /**\r\n+     * Whether brokers or their managed objects will be used by multiple\r\n+     * concurrent threads.\r\n+     */\r\n+    public boolean getMultithreaded();\r\n+\r\n+    /**\r\n+     * Whether brokers or their managed objects will be used by multiple\r\n+     * concurrent threads.\r\n+     */\r\n+    public void setMultithreaded(boolean multithreaded);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setMultithreaded(boolean)}.\r\n+     */\r\n+    public void setMultithreaded(Boolean multithreaded);\r\n+\r\n+    /**\r\n+     * Get the size of the batch that will be pre-selected when accessing\r\n+     * elements in a query or relationship. Use -1 to prefetch all results.\r\n+     */\r\n+    public int getFetchBatchSize();\r\n+\r\n+    /**\r\n+     * Set the size of the batch that will be pre-selected when accessing\r\n+     * elements in a query or relationship. Use -1 to prefetch all results.\r\n+     */\r\n+    public void setFetchBatchSize(int size);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setFetchBatchSize(int)}.\r\n+     */\r\n+    public void setFetchBatchSize(Integer size);\r\n+\r\n+    /**\r\n+     * Comma-separated list of fetch group names that will be pre-set for\r\n+     * all new {@link FetchConfiguration}s.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getFetchGroups();\r\n+\r\n+    /**\r\n+     * Comma-separated list of fetch group names that will be pre-set for\r\n+     * all new {@link FetchConfiguration}s.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setFetchGroups(String groups);\r\n+\r\n+    /**\r\n+     * List of fetch group names that will be pre-set for all new\r\n+     * {@link FetchConfiguration}s.\r\n+     */\r\n+    public String[] getFetchGroupsList();\r\n+\r\n+    /**\r\n+     * List of fetch group names that will be pre-set for all new\r\n+     * {@link FetchConfiguration}s.\r\n+     */\r\n+    public void setFetchGroups(String[] names);\r\n+\r\n+    /**\r\n+     * Returns whether or not OpenJPA should automatically flush\r\n+     * modifications to the data store before executing queries.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getFlushBeforeQueries();\r\n+\r\n+    /**\r\n+     * Sets whether or not OpenJPA should automatically flush\r\n+     * modifications to the data store before executing queries.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setFlushBeforeQueries(String flush);\r\n+\r\n+    /**\r\n+     * Returns one of {@link QueryFlushModes#FLUSH_TRUE},\r\n+     * {@link QueryFlushModes#FLUSH_FALSE}, or\r\n+     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}, as determined\r\n+     * by parsing the string returned by {@link #getFlushBeforeQueries}.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public int getFlushBeforeQueriesConstant();\r\n+\r\n+    /**\r\n+     * Set to one of {@link QueryFlushModes#FLUSH_TRUE},\r\n+     * {@link QueryFlushModes#FLUSH_FALSE}, or\r\n+     * {@link QueryFlushModes#FLUSH_WITH_CONNECTION}.\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setFlushBeforeQueries(int flushBeforeQueries);\r\n+\r\n+    /**\r\n+     * The time to wait for an object lock in milliseconds, or -1 for no\r\n+     * timeout.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public int getLockTimeout();\r\n+\r\n+    /**\r\n+     * The time to wait for an object lock in milliseconds, or -1 for no\r\n+     * timeout.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setLockTimeout(int timeout);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setLockTimeout(int)}.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setLockTimeout(Integer timeout);\r\n+\r\n+    /**\r\n+     * The default read lock level to use during non-optimistic transactions.\r\n+     * Defaults to <code>read</code>.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public String getReadLockLevel();\r\n+\r\n+    /**\r\n+     * The default read lock level to use during non-optimistic transactions.\r\n+     * Defaults to <code>read</code>.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setReadLockLevel(String level);\r\n+\r\n+    /**\r\n+     * The numeric read lock level.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public int getReadLockLevelConstant();\r\n+\r\n+    /**\r\n+     * The numeric read lock level.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setReadLockLevel(int level);\r\n+\r\n+    /**\r\n+     * The default write lock level to use during non-optimistic transactions.\r\n+     * Defaults to <code>write</code>.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public String getWriteLockLevel();\r\n+\r\n+    /**\r\n+     * The default write lock level to use during non-optimistic transactions.\r\n+     * Defaults to <code>write</code>.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setWriteLockLevel(String level);\r\n+\r\n+    /**\r\n+     * The numeric write lock level.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public int getWriteLockLevelConstant();\r\n+\r\n+    /**\r\n+     * The numeric write lock level.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public void setWriteLockLevel(int level);\r\n+\r\n+    /**\r\n+     * Plugin string for the default system {@link Seq}.\r\n+     */\r\n+    public String getSequence();\r\n+\r\n+    /**\r\n+     * Plugin string for the default system {@link Seq}.\r\n+     */\r\n+    public void setSequence(String sequence);\r\n+\r\n+    /**\r\n+     * The default system sequence.\r\n+     */\r\n+    public Seq getSequenceInstance();\r\n+\r\n+    /**\r\n+     * The default system sequence.\r\n+     */\r\n+    public void setSequence(Seq sequence);\r\n+\r\n+    /**\r\n+     * Specifies the behavior of the broker with respect to data store\r\n+     * connections. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>always</code>: Each broker obtains a single connection and\r\n+     * uses it until the broker is closed.</li>\r\n+     * <li><code>transaction</code>: A connection is obtained when each\r\n+     * transaction begins(optimistic or datastore), and is released\r\n+     * when the transaction completes.</li>\r\n+     * <li><code>on-demand</code>: Connections are obtained only when needed.\r\n+     * This is the default mode. It is equivalent to the previous option\r\n+     * when datastore transactions are used. For optimistic transactions,\r\n+     * though, it means that a connection will be retained only for\r\n+     * the duration of the data store commit process.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public String getConnectionRetainMode();\r\n+\r\n+    /**\r\n+     * Specifies the behavior of the broker with respect to data store\r\n+     * connections. Possible values are:\r\n+     * <ul>\r\n+     * <li><code>always</code>: Each broker obtains a single connection and\r\n+     * uses it until the broker is closed.</li>\r\n+     * <li><code>transaction</code>: A connection is obtained when each\r\n+     * transaction begins(optimistic or datastore), and is released\r\n+     * when the transaction completes.</li>\r\n+     * <li><code>on-demand</code>: Connections are obtained only when needed.\r\n+     * This is the default mode. It is equivalent to the previous option\r\n+     * when datastore transactions are used. For optimistic transactions,\r\n+     * though, it means that a connection will be retained only for\r\n+     * the duration of the data store commit process.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @since 2.5\r\n+     */\r\n+    public void setConnectionRetainMode(String mode);\r\n+\r\n+    /**\r\n+     * Return the connection retain mode as one of the following symbolic\r\n+     * constants:\r\n+     * <ul>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\r\n+     * </ul>\r\n+     */\r\n+    public int getConnectionRetainModeConstant();\r\n+\r\n+    /**\r\n+     * Set the connection retain mode as one of the following symbolic\r\n+     * constants:\r\n+     * <ul>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_ALWAYS}</li>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_TRANS}</li>\r\n+     * <li>{@link ConnectionRetainModes#CONN_RETAIN_DEMAND}</li>\r\n+     * </ul>\r\n+     */\r\n+    public void setConnectionRetainMode(int mode);\r\n+\r\n+    /**\r\n+     * A comma-separted list of the plugin strings of the query\r\n+     * {@link FilterListener}s to use.\r\n+     */\r\n+    public String getFilterListeners();\r\n+\r\n+    /**\r\n+     * A comma-separted list of the plugin strings of the query\r\n+     * {@link FilterListener}s to use.\r\n+     */\r\n+    public void setFilterListeners(String listeners);\r\n+\r\n+    /**\r\n+     * Return the query filter listeners. If none have been set explicitly,\r\n+     * this method instantiates the listeners from the set plugin list.\r\n+     */\r\n+    public FilterListener[] getFilterListenerInstances();\r\n+\r\n+    /**\r\n+     * Set the query filter listeners. Overrides the list of listener classes.\r\n+     */\r\n+    public void setFilterListeners(FilterListener[] listeners);\r\n+\r\n+    /**\r\n+     * A comma-separted list of the plugin strings of the query\r\n+     * {@link AggregateListener}s to use.\r\n+     */\r\n+    public String getAggregateListeners();\r\n+\r\n+    /**\r\n+     * A comma-separted list of the plugin strings of the query\r\n+     * {@link AggregateListener}s to use.\r\n+     */\r\n+    public void setAggregateListeners(String listeners);\r\n+\r\n+    /**\r\n+     * Return the query function listeners. If none have been set explicitly,\r\n+     * this method instantiates the listeners from the set plugin list.\r\n+     */\r\n+    public AggregateListener[] getAggregateListenerInstances();\r\n+\r\n+    /**\r\n+     * Set the query function listeners. Overrides the list of listener classes.\r\n+     */\r\n+    public void setAggregateListeners(AggregateListener[] listeners);\r\n+\r\n+    /**\r\n+     * Whether to warn and defer registration instead of throwing an\r\n+     * exception when a registered persistent class cannot be processed.\r\n+     * Should only be set to true in complex classloader topologies.\r\n+     * Defaults to <code>false</code>.\r\n+     *\r\n+     * @since 3.2.3\r\n+     */\r\n+    public boolean getRetryClassRegistration();\r\n+\r\n+    /**\r\n+     * Whether to warn and defer registration instead of throwing an\r\n+     * exception when a registered persistent class cannot be processed.\r\n+     * Should only be set to true in complex classloader topologies.\r\n+     * Defaults to <code>false</code>.\r\n+     *\r\n+     * @since 3.2.3\r\n+     */\r\n+    public void setRetryClassRegistration(boolean warn);\r\n+\r\n+    /**\r\n+     * Wrapper for JCA usage of {@link #setRetryClassRegistration(boolean)}.\r\n+     *\r\n+     * @since 3.2.3\r\n+     */\r\n+    public void setRetryClassRegistration(Boolean warn);\r\n+\r\n+    /**\r\n+     * Backwards compatibility options.\r\n+     */\r\n+    public String getCompatibility();\r\n+\r\n+    /**\r\n+     * Backwards compatibility options.\r\n+     */\r\n+    public void setCompatibility(String compatibility);\r\n+\r\n+    /**\r\n+     * Backwards compatibility options.\r\n+     */\r\n+    public Compatibility getCompatibilityInstance();\r\n+}\r"},{"sha":"2386975ac3993399bca1f0043ab53b3b3919ec64","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"added","additions":1352,"deletions":0,"changes":1352,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1352 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+\r\n+import org.apache.openjpa.datacache.ConcurrentDataCache;\r\n+import org.apache.openjpa.datacache.ConcurrentQueryCache;\r\n+import org.apache.openjpa.datacache.DataCacheManager;\r\n+import org.apache.openjpa.datacache.DataCacheManagerImpl;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.event.OrphanedKeyAction;\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.event.RemoteCommitProvider;\r\n+import org.apache.openjpa.kernel.AutoClear;\r\n+import org.apache.openjpa.kernel.BrokerImpl;\r\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n+import org.apache.openjpa.kernel.InverseManager;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.LockManager;\r\n+import org.apache.openjpa.kernel.QueryFlushModes;\r\n+import org.apache.openjpa.kernel.RestoreState;\r\n+import org.apache.openjpa.kernel.SavepointManager;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.conf.BooleanValue;\r\n+import org.apache.openjpa.lib.conf.ConfigurationImpl;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.conf.IntValue;\r\n+import org.apache.openjpa.lib.conf.ObjectValue;\r\n+import org.apache.openjpa.lib.conf.PluginListValue;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.lib.conf.StringListValue;\r\n+import org.apache.openjpa.lib.conf.StringValue;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.MetaDataFactory;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ClassResolver;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.ProxyManager;\r\n+\r\n+/**\r\n+ * Implementation of the {@link OpenJPAConfiguration} interface.\r\n+ * On construction, the class will attempt to locate a default properties\r\n+ * file called <code>org.apache.openjpa.properties</code> located at any top level token\r\n+ * of the CLASSPATH. See the {@link ConfigurationImpl} class description\r\n+ * for details.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ * @author Abe White\r\n+ * @see ConfigurationImpl\r\n+ */\r\n+public class OpenJPAConfigurationImpl extends ConfigurationImpl\r\n+    implements OpenJPAConfiguration {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (OpenJPAConfigurationImpl.class);\r\n+    // cached state; some of this is created in getter methods, so make\r\n+    // protected in case subclasses want to access without creating\r\n+    protected MetaDataRepository metaRepos = null;\r\n+    protected RemoteCommitEventManager remoteEventManager = null;\r\n+    // openjpa properties\r\n+    public ObjectValue classResolverPlugin;\r\n+    public ObjectValue brokerPlugin;\r\n+    public ObjectValue dataCachePlugin;\r\n+    public ObjectValue dataCacheManagerPlugin;\r\n+    public IntValue dataCacheTimeout;\r\n+    public ObjectValue queryCachePlugin;\r\n+    public BooleanValue dynamicDataStructs;\r\n+    public ObjectValue managedRuntimePlugin;\r\n+    public BooleanValue transactionMode;\r\n+    public IntValue connectionRetainMode;\r\n+    public IntValue fetchBatchSize;\r\n+    public StringListValue fetchGroups;\r\n+    public IntValue flushBeforeQueries;\r\n+    public IntValue lockTimeout;\r\n+    public IntValue readLockLevel;\r\n+    public IntValue writeLockLevel;\r\n+    public ObjectValue seqPlugin;\r\n+    public PluginListValue filterListenerPlugins;\r\n+    public PluginListValue aggregateListenerPlugins;\r\n+    public BooleanValue retryClassRegistration;\r\n+    public ObjectValue proxyManagerPlugin;\r\n+    public StringValue connectionUserName;\r\n+    public StringValue connectionPassword;\r\n+    public StringValue connectionURL;\r\n+    public StringValue connectionDriverName;\r\n+    public ObjectValue connectionFactory;\r\n+    public StringValue connectionFactoryName;\r\n+    public StringValue connectionProperties;\r\n+    public StringValue connectionFactoryProperties;\r\n+    public BooleanValue connectionFactoryMode;\r\n+    public StringValue connection2UserName;\r\n+    public StringValue connection2Password;\r\n+    public StringValue connection2URL;\r\n+    public StringValue connection2DriverName;\r\n+    public StringValue connection2Properties;\r\n+    public ObjectValue connectionFactory2;\r\n+    public StringValue connectionFactory2Name;\r\n+    public StringValue connectionFactory2Properties;\r\n+    public BooleanValue optimistic;\r\n+    public IntValue autoClear;\r\n+    public BooleanValue retainState;\r\n+    public IntValue restoreState;\r\n+    public ObjectValue detachStatePlugin;\r\n+    public BooleanValue ignoreChanges;\r\n+    public BooleanValue nontransactionalRead;\r\n+    public BooleanValue nontransactionalWrite;\r\n+    public BooleanValue multithreaded;\r\n+    public StringValue mapping;\r\n+    public PluginValue metaFactoryPlugin;\r\n+    public ObjectValue lockManagerPlugin;\r\n+    public ObjectValue inverseManagerPlugin;\r\n+    public ObjectValue savepointManagerPlugin;\r\n+    public ObjectValue orphanedKeyPlugin;\r\n+    public ObjectValue compatibilityPlugin;\r\n+    // custom values\r\n+    public BrokerFactoryValue brokerFactoryPlugin;\r\n+    public RemoteCommitProviderValue remoteProviderPlugin;\r\n+    public AutoDetachValue autoDetach;\r\n+    private Collection supportedOptions = new HashSet(33);\r\n+    private String spec = null;\r\n+\r\n+    /**\r\n+     * Default constructor. Attempts to load default properties.\r\n+     */\r\n+    public OpenJPAConfigurationImpl() {\r\n+        this(true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param loadDefaults whether to attempt to load the default\r\n+     *                     <code>org.apache.openjpa.properties</code> resource\r\n+     */\r\n+    public OpenJPAConfigurationImpl(boolean loadDefaults) {\r\n+        this(true, loadDefaults);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param derivations  whether to apply product derivations\r\n+     * @param loadDefaults whether to attempt to load the default\r\n+     *                     <code>org.apache.openjpa.properties</code> resource\r\n+     */\r\n+    public OpenJPAConfigurationImpl(boolean derivations, boolean loadDefaults) {\r\n+        super(false);\r\n+        String[] aliases;\r\n+        // setup super's log factory plugin\r\n+        logFactoryPlugin.setProperty(\"org.apache.openjpa.Log\");\r\n+        logFactoryPlugin\r\n+            .setAlias(\"openjpa\", \"org.apache.openjpa.lib.log.LogFactoryImpl\");\r\n+        aliases = logFactoryPlugin.getAliases();\r\n+        logFactoryPlugin.setDefault(aliases[0]);\r\n+        logFactoryPlugin.setString(aliases[0]);\r\n+        classResolverPlugin =\r\n+            addPlugin(\"org.apache.openjpa.ClassResolver\", true);\r\n+        aliases = new String[]{\r\n+            \"default\", \"org.apache.openjpa.util.ClassResolverImpl\",\r\n+            // deprecated alias\r\n+            \"spec\", \"org.apache.openjpa.util.ClassResolverImpl\", };\r\n+        classResolverPlugin.setAliases(aliases);\r\n+        classResolverPlugin.setDefault(aliases[0]);\r\n+        classResolverPlugin.setString(aliases[0]);\r\n+        classResolverPlugin.setInstantiatingGetter(\"getClassResolverInstance\");\r\n+        brokerFactoryPlugin = new BrokerFactoryValue();\r\n+        addValue(brokerFactoryPlugin);\r\n+        brokerPlugin = addPlugin(\"org.apache.openjpa.BrokerImpl\", false);\r\n+        aliases = new String[]{ \"default\", BrokerImpl.class.getName() };\r\n+        brokerPlugin.setAliases(aliases);\r\n+        brokerPlugin.setDefault(aliases[0]);\r\n+        brokerPlugin.setString(aliases[0]);\r\n+\r\n+        dataCacheManagerPlugin =\r\n+            addPlugin(\"org.apache.openjpa.DataCacheManager\", true);\r\n+        aliases = new String[]{\r\n+            \"default\", DataCacheManagerImpl.class.getName(), };\r\n+        dataCacheManagerPlugin.setAliases(aliases);\r\n+        dataCacheManagerPlugin.setDefault(aliases[0]);\r\n+        dataCacheManagerPlugin.setString(aliases[0]);\r\n+        dataCacheManagerPlugin.setInstantiatingGetter(\"getDataCacheManager\");\r\n+        dataCachePlugin = addPlugin(\"org.apache.openjpa.DataCache\", false);\r\n+        aliases = new String[]{\r\n+            \"false\", null, \"true\", ConcurrentDataCache.class.getName(),\r\n+            \"concurrent\", ConcurrentDataCache.class.getName(), };\r\n+        dataCachePlugin.setAliases(aliases);\r\n+        dataCachePlugin.setDefault(aliases[0]);\r\n+        dataCachePlugin.setString(aliases[0]);\r\n+        dataCacheTimeout = addInt(\"org.apache.openjpa.DataCacheTimeout\");\r\n+        dataCacheTimeout.setDefault(\"-1\");\r\n+        dataCacheTimeout.set(-1);\r\n+        queryCachePlugin = addPlugin(\"org.apache.openjpa.QueryCache\", true);\r\n+        aliases = new String[]{\r\n+            \"true\", ConcurrentQueryCache.class.getName(),\r\n+            \"concurrent\", ConcurrentQueryCache.class.getName(), \"false\", null,\r\n+        };\r\n+        queryCachePlugin.setAliases(aliases);\r\n+        queryCachePlugin.setDefault(aliases[0]);\r\n+        queryCachePlugin.setString(aliases[0]);\r\n+        dynamicDataStructs =\r\n+            addBoolean(\"org.apache.openjpa.DynamicDataStructs\");\r\n+        dynamicDataStructs.setDefault(\"false\");\r\n+        dynamicDataStructs.set(false);\r\n+        lockManagerPlugin = addPlugin(\"org.apache.openjpa.LockManager\", false);\r\n+        aliases = new String[]{\r\n+            \"none\", \"org.apache.openjpa.kernel.NoneLockManager\",\r\n+            \"version\", \"org.apache.openjpa.kernel.VersionLockManager\", };\r\n+        lockManagerPlugin.setAliases(aliases);\r\n+        lockManagerPlugin.setDefault(aliases[0]);\r\n+        lockManagerPlugin.setString(aliases[0]);\r\n+        inverseManagerPlugin =\r\n+            addPlugin(\"org.apache.openjpa.InverseManager\", false);\r\n+        aliases = new String[]{\r\n+            \"false\", null, \"true\", \"org.apache.openjpa.kernel.InverseManager\",\r\n+        };\r\n+        inverseManagerPlugin.setAliases(aliases);\r\n+        inverseManagerPlugin.setDefault(aliases[0]);\r\n+        inverseManagerPlugin.setString(aliases[0]);\r\n+\r\n+        savepointManagerPlugin =\r\n+            addPlugin(\"org.apache.openjpa.SavepointManager\", true);\r\n+        aliases = new String[]{\r\n+            \"in-mem\", \"org.apache.openjpa.kernel.InMemorySavepointManager\", };\r\n+        savepointManagerPlugin.setAliases(aliases);\r\n+        savepointManagerPlugin.setDefault(aliases[0]);\r\n+        savepointManagerPlugin.setString(aliases[0]);\r\n+        savepointManagerPlugin.setInstantiatingGetter\r\n+            (\"getSavepointManagerInstance\");\r\n+        orphanedKeyPlugin =\r\n+            addPlugin(\"org.apache.openjpa.OrphanedKeyAction\", true);\r\n+        aliases = new String[]{\r\n+            \"log\", \"org.apache.openjpa.event.LogOrphanedKeyAction\",\r\n+            \"exception\", \"org.apache.openjpa.event.ExceptionOrphanedKeyAction\",\r\n+            \"none\", \"org.apache.openjpa.event.NoneOrphanedKeyAction\", };\r\n+        orphanedKeyPlugin.setAliases(aliases);\r\n+        orphanedKeyPlugin.setDefault(aliases[0]);\r\n+        orphanedKeyPlugin.setString(aliases[0]);\r\n+        orphanedKeyPlugin.setInstantiatingGetter\r\n+            (\"getOrphanedKeyActionInstance\");\r\n+        remoteProviderPlugin = new RemoteCommitProviderValue\r\n+            (\"org.apache.openjpa.RemoteCommitProvider\");\r\n+        addValue(remoteProviderPlugin);\r\n+        transactionMode = addBoolean(\"org.apache.openjpa.TransactionMode\");\r\n+        aliases = new String[]{\r\n+            \"local\", \"false\", \"managed\", \"true\", };\r\n+        transactionMode.setAliases(aliases);\r\n+        transactionMode.setDefault(aliases[0]);\r\n+        managedRuntimePlugin =\r\n+            addPlugin(\"org.apache.openjpa.ManagedRuntime\", true);\r\n+        aliases = new String[]{\r\n+            \"auto\", \"org.apache.openjpa.ee.AutomaticManagedRuntime\",\r\n+            \"jndi\", \"org.apache.openjpa.ee.JNDIManagedRuntime\",\r\n+            \"invocation\", \"org.apache.openjpa.ee.InvocationManagedRuntime\", };\r\n+        managedRuntimePlugin.setAliases(aliases);\r\n+        managedRuntimePlugin.setDefault(aliases[0]);\r\n+        managedRuntimePlugin.setString(aliases[0]);\r\n+        managedRuntimePlugin.setInstantiatingGetter\r\n+            (\"getManagedRuntimeInstance\");\r\n+        proxyManagerPlugin = addPlugin(\"org.apache.openjpa.ProxyManager\", true);\r\n+        aliases = new String[]{ \"default\",\r\n+            \"org.apache.openjpa.util.ProxyManagerImpl\" };\r\n+        proxyManagerPlugin.setAliases(aliases);\r\n+        proxyManagerPlugin.setDefault(aliases[0]);\r\n+        proxyManagerPlugin.setString(aliases[0]);\r\n+        proxyManagerPlugin.setInstantiatingGetter(\"getProxyManagerInstance\");\r\n+        mapping = addString(\"org.apache.openjpa.Mapping\");\r\n+        metaFactoryPlugin =\r\n+            addPlugin(\"org.apache.openjpa.MetaDataFactory\", false);\r\n+        connectionFactory = addObject(\"org.apache.openjpa.ConnectionFactory\");\r\n+        connectionFactory.setInstantiatingGetter(\"getConnectionFactory\");\r\n+        connectionFactory2 = addObject(\"org.apache.openjpa.ConnectionFactory2\");\r\n+        connectionFactory2.setInstantiatingGetter(\"getConnectionFactory2\");\r\n+        connectionUserName = addString(\"org.apache.openjpa.ConnectionUserName\");\r\n+        connectionPassword = addString(\"org.apache.openjpa.ConnectionPassword\");\r\n+        connectionURL = addString(\"org.apache.openjpa.ConnectionURL\");\r\n+        connectionDriverName =\r\n+            addString(\"org.apache.openjpa.ConnectionDriverName\");\r\n+        connectionFactoryName =\r\n+            addString(\"org.apache.openjpa.ConnectionFactoryName\");\r\n+        connectionProperties =\r\n+            addString(\"org.apache.openjpa.ConnectionProperties\");\r\n+        connectionFactoryProperties = addString\r\n+            (\"org.apache.openjpa.ConnectionFactoryProperties\");\r\n+        connection2UserName =\r\n+            addString(\"org.apache.openjpa.Connection2UserName\");\r\n+        connection2Password =\r\n+            addString(\"org.apache.openjpa.Connection2Password\");\r\n+        connection2URL = addString(\"org.apache.openjpa.Connection2URL\");\r\n+        connection2DriverName =\r\n+            addString(\"org.apache.openjpa.Connection2DriverName\");\r\n+        connection2Properties =\r\n+            addString(\"org.apache.openjpa.Connection2Properties\");\r\n+        connectionFactory2Properties = addString\r\n+            (\"org.apache.openjpa.ConnectionFactory2Properties\");\r\n+        connectionFactory2Name =\r\n+            addString(\"org.apache.openjpa.ConnectionFactory2Name\");\r\n+\r\n+        connectionFactoryMode =\r\n+            addBoolean(\"org.apache.openjpa.ConnectionFactoryMode\");\r\n+        aliases = new String[]{\r\n+            \"local\", \"false\", \"managed\", \"true\", };\r\n+        connectionFactoryMode.setAliases(aliases);\r\n+        connectionFactoryMode.setDefault(aliases[0]);\r\n+        optimistic = addBoolean(\"org.apache.openjpa.Optimistic\");\r\n+        optimistic.setDefault(\"true\");\r\n+        optimistic.set(true);\r\n+        autoClear = addInt(\"org.apache.openjpa.AutoClear\");\r\n+        aliases = new String[]{\r\n+            \"datastore\", String.valueOf(AutoClear.CLEAR_DATASTORE),\r\n+            \"all\", String.valueOf(AutoClear.CLEAR_ALL), };\r\n+        autoClear.setAliases(aliases);\r\n+        autoClear.setDefault(aliases[0]);\r\n+        autoClear.set(AutoClear.CLEAR_DATASTORE);\r\n+        retainState = addBoolean(\"org.apache.openjpa.RetainState\");\r\n+        retainState.setDefault(\"true\");\r\n+        retainState.set(true);\r\n+        restoreState = addInt(\"org.apache.openjpa.RestoreState\");\r\n+        aliases = new String[]{\r\n+            \"none\", String.valueOf(RestoreState.RESTORE_NONE),\r\n+            \"false\", String.valueOf(RestoreState.RESTORE_NONE),\r\n+            \"immutable\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\r\n+            // \"true\" for compat with jdo RestoreValues\r\n+            \"true\", String.valueOf(RestoreState.RESTORE_IMMUTABLE),\r\n+            \"all\", String.valueOf(RestoreState.RESTORE_ALL), };\r\n+        restoreState.setAliases(aliases);\r\n+        restoreState.setDefault(aliases[0]);\r\n+        restoreState.set(RestoreState.RESTORE_IMMUTABLE);\r\n+        autoDetach = new AutoDetachValue(\"org.apache.openjpa.AutoDetach\");\r\n+        addValue(autoDetach);\r\n+        detachStatePlugin = addPlugin(\"org.apache.openjpa.DetachState\", true);\r\n+        aliases = new String[]{\r\n+            \"loaded\", DetachOptions.Loaded.class.getName(),\r\n+            \"fgs\", DetachOptions.FetchGroups.class.getName(),\r\n+            \"all\", DetachOptions.All.class.getName(), };\r\n+        detachStatePlugin.setAliases(aliases);\r\n+        detachStatePlugin.setDefault(aliases[0]);\r\n+        detachStatePlugin.setString(aliases[0]);\r\n+        detachStatePlugin.setInstantiatingGetter(\"getDetachStateInstance\");\r\n+        ignoreChanges = addBoolean(\"org.apache.openjpa.IgnoreChanges\");\r\n+        nontransactionalRead =\r\n+            addBoolean(\"org.apache.openjpa.NontransactionalRead\");\r\n+        nontransactionalRead.setDefault(\"true\");\r\n+        nontransactionalRead.set(true);\r\n+\r\n+        nontransactionalWrite =\r\n+            addBoolean(\"org.apache.openjpa.NontransactionalWrite\");\r\n+        multithreaded = addBoolean(\"org.apache.openjpa.Multithreaded\");\r\n+        fetchBatchSize = addInt(\"org.apache.openjpa.FetchBatchSize\");\r\n+        fetchBatchSize.setDefault(\"-1\");\r\n+        fetchBatchSize.set(-1);\r\n+        fetchGroups = addStringList(\"org.apache.openjpa.FetchGroups\");\r\n+        fetchGroups.setDefault(\"default\");\r\n+        fetchGroups.set(new String[]{ \"default\" });\r\n+        flushBeforeQueries = addInt(\"org.apache.openjpa.FlushBeforeQueries\");\r\n+        aliases = new String[]{\r\n+            \"true\", String.valueOf(QueryFlushModes.FLUSH_TRUE),\r\n+            \"false\", String.valueOf(QueryFlushModes.FLUSH_FALSE),\r\n+            \"with-connection\", String.valueOf\r\n+            (QueryFlushModes.FLUSH_WITH_CONNECTION), };\r\n+        flushBeforeQueries.setAliases(aliases);\r\n+        flushBeforeQueries.setDefault(aliases[0]);\r\n+        flushBeforeQueries.set(QueryFlushModes.FLUSH_TRUE);\r\n+        lockTimeout = addInt(\"org.apache.openjpa.LockTimeout\");\r\n+        lockTimeout.setDefault(\"-1\");\r\n+        lockTimeout.set(-1);\r\n+        readLockLevel = addInt(\"org.apache.openjpa.ReadLockLevel\");\r\n+        aliases = new String[]{\r\n+            \"read\", String.valueOf(LockLevels.LOCK_READ),\r\n+            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\r\n+            \"none\", String.valueOf(LockLevels.LOCK_NONE), };\r\n+        readLockLevel.setAliases(aliases);\r\n+        readLockLevel.setDefault(aliases[0]);\r\n+        readLockLevel.set(LockLevels.LOCK_READ);\r\n+        writeLockLevel = addInt(\"org.apache.openjpa.WriteLockLevel\");\r\n+        aliases = new String[]{\r\n+            \"read\", String.valueOf(LockLevels.LOCK_READ),\r\n+            \"write\", String.valueOf(LockLevels.LOCK_WRITE),\r\n+            \"none\", String.valueOf(LockLevels.LOCK_NONE), };\r\n+        writeLockLevel.setAliases(aliases);\r\n+        writeLockLevel.setDefault(aliases[1]);\r\n+        writeLockLevel.set(LockLevels.LOCK_WRITE);\r\n+        seqPlugin = new SeqValue(\"org.apache.openjpa.Sequence\");\r\n+        seqPlugin.setInstantiatingGetter(\"getSequenceInstance\");\r\n+        addValue(seqPlugin);\r\n+        connectionRetainMode =\r\n+            addInt(\"org.apache.openjpa.ConnectionRetainMode\");\r\n+        aliases = new String[]{\r\n+            \"on-demand\",\r\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_DEMAND),\r\n+            \"transaction\",\r\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_TRANS),\r\n+            \"always\", String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS),\r\n+            // deprecated\r\n+            \"persistence-manager\",\r\n+            String.valueOf(ConnectionRetainModes.CONN_RETAIN_ALWAYS), };\r\n+        connectionRetainMode.setAliases(aliases);\r\n+        connectionRetainMode.setDefault(aliases[0]);\r\n+        connectionRetainMode.setAliasListComprehensive(true);\r\n+        connectionRetainMode.set(ConnectionRetainModes.CONN_RETAIN_DEMAND);\r\n+        filterListenerPlugins =\r\n+            addPluginList(\"org.apache.openjpa.FilterListeners\");\r\n+        filterListenerPlugins.setInstantiatingGetter\r\n+            (\"getFilterListenerInstances\");\r\n+\r\n+        aggregateListenerPlugins =\r\n+            addPluginList(\"org.apache.openjpa.AggregateListeners\");\r\n+        aggregateListenerPlugins.setInstantiatingGetter\r\n+            (\"getAggregateListenerInstances\");\r\n+\r\n+        retryClassRegistration =\r\n+            addBoolean(\"org.apache.openjpa.RetryClassRegistration\");\r\n+        compatibilityPlugin =\r\n+            addPlugin(\"org.apache.openjpa.Compatibility\", true);\r\n+        aliases = new String[]{ \"default\", Compatibility.class.getName() };\r\n+        compatibilityPlugin.setAliases(aliases);\r\n+        compatibilityPlugin.setDefault(aliases[0]);\r\n+        compatibilityPlugin.setString(aliases[0]);\r\n+        compatibilityPlugin.setInstantiatingGetter(\"getCompatibilityInstance\");\r\n+        // initialize supported options that some runtimes may not support\r\n+        supportedOptions.add(OPTION_NONTRANS_READ);\r\n+        supportedOptions.add(OPTION_OPTIMISTIC);\r\n+        supportedOptions.add(OPTION_ID_APPLICATION);\r\n+        supportedOptions.add(OPTION_ID_DATASTORE);\r\n+        supportedOptions.add(OPTION_TYPE_COLLECTION);\r\n+        supportedOptions.add(OPTION_TYPE_MAP);\r\n+        supportedOptions.add(OPTION_TYPE_ARRAY);\r\n+        supportedOptions.add(OPTION_NULL_CONTAINER);\r\n+        supportedOptions.add(OPTION_EMBEDDED_RELATION);\r\n+        supportedOptions.add(OPTION_EMBEDDED_COLLECTION_RELATION);\r\n+        supportedOptions.add(OPTION_EMBEDDED_MAP_RELATION);\r\n+        supportedOptions.add(OPTION_INC_FLUSH);\r\n+        supportedOptions.add(OPTION_VALUE_AUTOASSIGN);\r\n+        supportedOptions.add(OPTION_VALUE_INCREMENT);\r\n+        supportedOptions.add(OPTION_DATASTORE_CONNECTION);\r\n+        if (derivations)\r\n+            ProductDerivations.beforeConfigurationLoad(this);\r\n+        if (loadDefaults)\r\n+            loadDefaults();\r\n+    }\r\n+\r\n+    public String getProductName() {\r\n+        return \"openjpa\";\r\n+    }\r\n+\r\n+    public Collection supportedOptions() {\r\n+        return supportedOptions;\r\n+    }\r\n+\r\n+    public String getSpecification() {\r\n+        return spec;\r\n+    }\r\n+\r\n+    public boolean setSpecification(String spec) {\r\n+        if (spec == null)\r\n+            return false;\r\n+        if (this.spec != null) {\r\n+            if (!this.spec.equals(spec)\r\n+                && getConfigurationLog().isWarnEnabled())\r\n+                getConfigurationLog().warn(_loc.get(\"diff-specs\", this.spec,\r\n+                    spec));\r\n+            return false;\r\n+        }\r\n+        this.spec = spec;\r\n+        ProductDerivations.afterSpecificationSet(this);\r\n+        return true;\r\n+    }\r\n+\r\n+    public void setClassResolver(String classResolver) {\r\n+        assertNotReadOnly();\r\n+        classResolverPlugin.setString(classResolver);\r\n+    }\r\n+\r\n+    public String getClassResolver() {\r\n+        return classResolverPlugin.getString();\r\n+    }\r\n+\r\n+    public void setClassResolver(ClassResolver classResolver) {\r\n+        assertNotReadOnly();\r\n+        classResolverPlugin.set(classResolver);\r\n+    }\r\n+\r\n+    public ClassResolver getClassResolverInstance() {\r\n+        if (classResolverPlugin.get() == null)\r\n+            classResolverPlugin.instantiate(ClassResolver.class, this);\r\n+        return (ClassResolver) classResolverPlugin.get();\r\n+    }\r\n+\r\n+    public void setBrokerFactory(String factory) {\r\n+        assertNotReadOnly();\r\n+        brokerFactoryPlugin.setString(factory);\r\n+    }\r\n+\r\n+    public String getBrokerFactory() {\r\n+        return brokerFactoryPlugin.getString();\r\n+    }\r\n+\r\n+    public void setBrokerImpl(String broker) {\r\n+        assertNotReadOnly();\r\n+        brokerPlugin.setString(broker);\r\n+    }\r\n+\r\n+    public String getBrokerImpl() {\r\n+        return brokerPlugin.getString();\r\n+    }\r\n+\r\n+    public BrokerImpl newBrokerInstance(String user, String pass) {\r\n+        BrokerImpl broker = (BrokerImpl) brokerPlugin.instantiate\r\n+            (BrokerImpl.class, this);\r\n+        if (broker != null)\r\n+            broker.setAuthentication(user, pass);\r\n+        return broker;\r\n+    }\r\n+\r\n+    public void setDataCacheManager(String mgr) {\r\n+        assertNotReadOnly();\r\n+        dataCacheManagerPlugin.setString(mgr);\r\n+    }\r\n+\r\n+    public String getDataCacheManager() {\r\n+        return dataCacheManagerPlugin.getString();\r\n+    }\r\n+\r\n+    public void setDataCacheManager(DataCacheManager dcm) {\r\n+        assertNotReadOnly();\r\n+        if (dcm != null)\r\n+            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\r\n+        dataCacheManagerPlugin.set(dcm);\r\n+    }\r\n+\r\n+    public DataCacheManager getDataCacheManagerInstance() {\r\n+        DataCacheManager dcm = (DataCacheManager) dataCacheManagerPlugin.get();\r\n+        if (dcm == null) {\r\n+            dcm = (DataCacheManager) dataCacheManagerPlugin.instantiate\r\n+                (DataCacheManager.class, this);\r\n+            dcm.initialize(this, dataCachePlugin, queryCachePlugin);\r\n+        }\r\n+        return dcm;\r\n+    }\r\n+\r\n+    public void setDataCache(String dataCache) {\r\n+        assertNotReadOnly();\r\n+        dataCachePlugin.setString(dataCache);\r\n+    }\r\n+\r\n+    public String getDataCache() {\r\n+        return dataCachePlugin.getString();\r\n+    }\r\n+\r\n+    public void setDataCacheTimeout(int dataCacheTimeout) {\r\n+        assertNotReadOnly();\r\n+        this.dataCacheTimeout.set(dataCacheTimeout);\r\n+    }\r\n+\r\n+    public void setDataCacheTimeout(Integer dataCacheTimeout) {\r\n+        if (dataCacheTimeout != null)\r\n+            setDataCacheTimeout(dataCacheTimeout.intValue());\r\n+    }\r\n+\r\n+    public int getDataCacheTimeout() {\r\n+        return dataCacheTimeout.get();\r\n+    }\r\n+\r\n+    public void setQueryCache(String queryCache) {\r\n+        assertNotReadOnly();\r\n+        queryCachePlugin.setString(queryCache);\r\n+    }\r\n+\r\n+    public String getQueryCache() {\r\n+        return queryCachePlugin.getString();\r\n+    }\r\n+\r\n+    public boolean getDynamicDataStructs() {\r\n+        return dynamicDataStructs.get();\r\n+    }\r\n+\r\n+    public void setDynamicDataStructs(boolean dynamic) {\r\n+        dynamicDataStructs.set(dynamic);\r\n+    }\r\n+\r\n+    public void setDynamicDataStructs(Boolean dynamic) {\r\n+        setDynamicDataStructs(dynamic.booleanValue());\r\n+    }\r\n+\r\n+    public void setLockManager(String lockManager) {\r\n+        assertNotReadOnly();\r\n+        lockManagerPlugin.setString(lockManager);\r\n+    }\r\n+\r\n+    public String getLockManager() {\r\n+        return lockManagerPlugin.getString();\r\n+    }\r\n+\r\n+    public LockManager newLockManagerInstance() {\r\n+        // don't validate plugin properties on instantiation because it\r\n+        // is likely that back ends will override defaults with their\r\n+        // own subclasses with new properties\r\n+        return (LockManager) lockManagerPlugin.instantiate(LockManager.class,\r\n+            this, false);\r\n+    }\r\n+\r\n+    public void setInverseManager(String inverseManager) {\r\n+        assertNotReadOnly();\r\n+        inverseManagerPlugin.setString(inverseManager);\r\n+    }\r\n+\r\n+    public String getInverseManager() {\r\n+        return inverseManagerPlugin.getString();\r\n+    }\r\n+\r\n+    public InverseManager newInverseManagerInstance() {\r\n+        return (InverseManager) inverseManagerPlugin.instantiate\r\n+            (InverseManager.class, this);\r\n+    }\r\n+\r\n+    public void setSavepointManager(String savepointManager) {\r\n+        assertNotReadOnly();\r\n+        savepointManagerPlugin.setString(savepointManager);\r\n+    }\r\n+\r\n+    public String getSavepointManager() {\r\n+        return savepointManagerPlugin.getString();\r\n+    }\r\n+\r\n+    public SavepointManager getSavepointManagerInstance() {\r\n+        if (savepointManagerPlugin.get() == null)\r\n+            savepointManagerPlugin.instantiate(SavepointManager.class, this);\r\n+        return (SavepointManager) savepointManagerPlugin.get();\r\n+    }\r\n+\r\n+    public void setOrphanedKeyAction(String action) {\r\n+        assertNotReadOnly();\r\n+        orphanedKeyPlugin.setString(action);\r\n+    }\r\n+\r\n+    public String getOrphanedKeyAction() {\r\n+        return orphanedKeyPlugin.getString();\r\n+    }\r\n+\r\n+    public OrphanedKeyAction getOrphanedKeyActionInstance() {\r\n+        if (orphanedKeyPlugin.get() == null)\r\n+            orphanedKeyPlugin.instantiate(OrphanedKeyAction.class, this);\r\n+        return (OrphanedKeyAction) orphanedKeyPlugin.get();\r\n+    }\r\n+\r\n+    public void setOrphanedKeyAction(OrphanedKeyAction action) {\r\n+        assertNotReadOnly();\r\n+        orphanedKeyPlugin.set(action);\r\n+    }\r\n+\r\n+    public void setRemoteCommitProvider(String remoteCommitProvider) {\r\n+        assertNotReadOnly();\r\n+        remoteProviderPlugin.setString(remoteCommitProvider);\r\n+    }\r\n+\r\n+    public String getRemoteCommitProvider() {\r\n+        return remoteProviderPlugin.getString();\r\n+    }\r\n+\r\n+    public RemoteCommitProvider newRemoteCommitProviderInstance() {\r\n+        return remoteProviderPlugin.instantiateProvider(this);\r\n+    }\r\n+\r\n+    public void setRemoteCommitEventManager\r\n+        (RemoteCommitEventManager remoteEventManager) {\r\n+        assertNotReadOnly();\r\n+        this.remoteEventManager = remoteEventManager;\r\n+        remoteProviderPlugin.configureEventManager(remoteEventManager);\r\n+    }\r\n+\r\n+    public RemoteCommitEventManager getRemoteCommitEventManager() {\r\n+        if (remoteEventManager == null) {\r\n+            remoteEventManager = new RemoteCommitEventManager(this);\r\n+            remoteProviderPlugin.configureEventManager(remoteEventManager);\r\n+        }\r\n+        return remoteEventManager;\r\n+    }\r\n+\r\n+    public void setTransactionMode(String transactionMode) {\r\n+        assertNotReadOnly();\r\n+        this.transactionMode.setString(transactionMode);\r\n+    }\r\n+\r\n+    public String getTransactionMode() {\r\n+        return transactionMode.getString();\r\n+    }\r\n+\r\n+    public void setTransactionModeManaged(boolean managed) {\r\n+        assertNotReadOnly();\r\n+        transactionMode.set(managed);\r\n+    }\r\n+\r\n+    public boolean isTransactionModeManaged() {\r\n+        return transactionMode.get();\r\n+    }\r\n+\r\n+    public void setManagedRuntime(String managedRuntime) {\r\n+        assertNotReadOnly();\r\n+        managedRuntimePlugin.setString(managedRuntime);\r\n+    }\r\n+\r\n+    public String getManagedRuntime() {\r\n+        return managedRuntimePlugin.getString();\r\n+    }\r\n+\r\n+    public void setManagedRuntime(ManagedRuntime managedRuntime) {\r\n+        assertNotReadOnly();\r\n+        managedRuntimePlugin.set(managedRuntime);\r\n+    }\r\n+\r\n+    public ManagedRuntime getManagedRuntimeInstance() {\r\n+        if (managedRuntimePlugin.get() == null)\r\n+            managedRuntimePlugin.instantiate(ManagedRuntime.class, this);\r\n+        return (ManagedRuntime) managedRuntimePlugin.get();\r\n+    }\r\n+\r\n+    public void setProxyManager(String proxyManager) {\r\n+        assertNotReadOnly();\r\n+        proxyManagerPlugin.setString(proxyManager);\r\n+    }\r\n+\r\n+    public String getProxyManager() {\r\n+        return proxyManagerPlugin.getString();\r\n+    }\r\n+\r\n+    public void setProxyManager(ProxyManager proxyManager) {\r\n+        assertNotReadOnly();\r\n+        proxyManagerPlugin.set(proxyManager);\r\n+    }\r\n+\r\n+    public ProxyManager getProxyManagerInstance() {\r\n+        if (proxyManagerPlugin.get() == null)\r\n+            proxyManagerPlugin.instantiate(ProxyManager.class, this);\r\n+        return (ProxyManager) proxyManagerPlugin.get();\r\n+    }\r\n+\r\n+    public void setMapping(String mapping) {\r\n+        assertNotReadOnly();\r\n+        this.mapping.setString(mapping);\r\n+    }\r\n+\r\n+    public String getMapping() {\r\n+        return mapping.getString();\r\n+    }\r\n+\r\n+    public void setMetaDataFactory(String meta) {\r\n+        assertNotReadOnly();\r\n+        this.metaFactoryPlugin.setString(meta);\r\n+    }\r\n+\r\n+    public String getMetaDataFactory() {\r\n+        return metaFactoryPlugin.getString();\r\n+    }\r\n+\r\n+    public MetaDataFactory newMetaDataFactoryInstance() {\r\n+        return (MetaDataFactory) metaFactoryPlugin.instantiate\r\n+            (MetaDataFactory.class, this);\r\n+    }\r\n+\r\n+    public void setMetaDataRepository(MetaDataRepository meta) {\r\n+        assertNotReadOnly();\r\n+        metaRepos = meta;\r\n+    }\r\n+\r\n+    public MetaDataRepository getMetaDataRepository() {\r\n+        if (metaRepos == null)\r\n+            metaRepos = new MetaDataRepository(this);\r\n+        return metaRepos;\r\n+    }\r\n+\r\n+    public void setConnectionUserName(String connectionUserName) {\r\n+        assertNotReadOnly();\r\n+        this.connectionUserName.setString(connectionUserName);\r\n+    }\r\n+\r\n+    public String getConnectionUserName() {\r\n+        return connectionUserName.getString();\r\n+    }\r\n+\r\n+    public void setConnectionPassword(String connectionPassword) {\r\n+        assertNotReadOnly();\r\n+        this.connectionPassword.setString(connectionPassword);\r\n+    }\r\n+\r\n+    public String getConnectionPassword() {\r\n+        return connectionPassword.getString();\r\n+    }\r\n+\r\n+    public void setConnectionURL(String connectionURL) {\r\n+        assertNotReadOnly();\r\n+        this.connectionURL.setString(connectionURL);\r\n+    }\r\n+\r\n+    public String getConnectionURL() {\r\n+        return connectionURL.getString();\r\n+    }\r\n+\r\n+    public void setConnectionDriverName(String driverName) {\r\n+        assertNotReadOnly();\r\n+        this.connectionDriverName.setString(driverName);\r\n+    }\r\n+\r\n+    public String getConnectionDriverName() {\r\n+        return connectionDriverName.getString();\r\n+    }\r\n+\r\n+    public void setConnectionProperties(String connectionProperties) {\r\n+        assertNotReadOnly();\r\n+        this.connectionProperties.setString(connectionProperties);\r\n+    }\r\n+\r\n+    public String getConnectionProperties() {\r\n+        return connectionProperties.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactoryProperties\r\n+        (String connectionFactoryProperties) {\r\n+        assertNotReadOnly();\r\n+        this.connectionFactoryProperties.setString(connectionFactoryProperties);\r\n+    }\r\n+\r\n+    public String getConnectionFactoryProperties() {\r\n+        return connectionFactoryProperties.getString();\r\n+    }\r\n+\r\n+    public String getConnectionFactoryMode() {\r\n+        return connectionFactoryMode.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactoryMode(String mode) {\r\n+        assertNotReadOnly();\r\n+        connectionFactoryMode.setString(mode);\r\n+    }\r\n+\r\n+    public boolean isConnectionFactoryModeManaged() {\r\n+        return connectionFactoryMode.get();\r\n+    }\r\n+\r\n+    public void setConnectionFactoryModeManaged(boolean managed) {\r\n+        assertNotReadOnly();\r\n+        connectionFactoryMode.set(managed);\r\n+    }\r\n+\r\n+    public void setConnectionFactoryName(String connectionFactoryName) {\r\n+        assertNotReadOnly();\r\n+        this.connectionFactoryName.setString(connectionFactoryName);\r\n+    }\r\n+\r\n+    public String getConnectionFactoryName() {\r\n+        return connectionFactoryName.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactory(Object factory) {\r\n+        assertNotReadOnly();\r\n+        connectionFactory.set(factory);\r\n+    }\r\n+\r\n+    public Object getConnectionFactory() {\r\n+        if (connectionFactory.get() == null)\r\n+            connectionFactory.set(lookupConnectionFactory\r\n+                (getConnectionFactoryName()), true);\r\n+        return connectionFactory.get();\r\n+    }\r\n+\r\n+    /**\r\n+     * Lookup the connection factory at the given name.\r\n+     */\r\n+    private Object lookupConnectionFactory(String name) {\r\n+        if (name == null || name.trim().length() == 0)\r\n+            return null;\r\n+        return Configurations.lookup(name);\r\n+    }\r\n+\r\n+    public void setConnection2UserName(String connection2UserName) {\r\n+        assertNotReadOnly();\r\n+        this.connection2UserName.setString(connection2UserName);\r\n+    }\r\n+\r\n+    public String getConnection2UserName() {\r\n+        return connection2UserName.getString();\r\n+    }\r\n+\r\n+    public void setConnection2Password(String connection2Password) {\r\n+        assertNotReadOnly();\r\n+        this.connection2Password.setString(connection2Password);\r\n+    }\r\n+\r\n+    public String getConnection2Password() {\r\n+        return connection2Password.getString();\r\n+    }\r\n+\r\n+    public void setConnection2URL(String connection2URL) {\r\n+        assertNotReadOnly();\r\n+        this.connection2URL.setString(connection2URL);\r\n+    }\r\n+\r\n+    public String getConnection2URL() {\r\n+        return connection2URL.getString();\r\n+    }\r\n+\r\n+    public void setConnection2DriverName(String driverName) {\r\n+        assertNotReadOnly();\r\n+        this.connection2DriverName.setString(driverName);\r\n+    }\r\n+\r\n+    public String getConnection2DriverName() {\r\n+        return connection2DriverName.getString();\r\n+    }\r\n+\r\n+    public void setConnection2Properties(String connection2Properties) {\r\n+        assertNotReadOnly();\r\n+        this.connection2Properties.setString(connection2Properties);\r\n+    }\r\n+\r\n+    public String getConnection2Properties() {\r\n+        return connection2Properties.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactory2Properties\r\n+        (String connectionFactory2Properties) {\r\n+        assertNotReadOnly();\r\n+        this.connectionFactory2Properties.setString\r\n+            (connectionFactory2Properties);\r\n+    }\r\n+\r\n+    public String getConnectionFactory2Properties() {\r\n+        return connectionFactory2Properties.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactory2Name(String connectionFactory2Name) {\r\n+        assertNotReadOnly();\r\n+        this.connectionFactory2Name.setString(connectionFactory2Name);\r\n+    }\r\n+\r\n+    public String getConnectionFactory2Name() {\r\n+        return connectionFactory2Name.getString();\r\n+    }\r\n+\r\n+    public void setConnectionFactory2(Object factory) {\r\n+        assertNotReadOnly();\r\n+        connectionFactory2.set(factory);\r\n+    }\r\n+\r\n+    public Object getConnectionFactory2() {\r\n+        if (connectionFactory2.get() == null)\r\n+            connectionFactory2.set(lookupConnectionFactory\r\n+                (getConnectionFactory2Name()), false);\r\n+        return connectionFactory2.get();\r\n+    }\r\n+\r\n+    public void setOptimistic(boolean optimistic) {\r\n+        assertNotReadOnly();\r\n+        this.optimistic.set(optimistic);\r\n+    }\r\n+\r\n+    public void setOptimistic(Boolean optimistic) {\r\n+        if (optimistic != null)\r\n+            setOptimistic(optimistic.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getOptimistic() {\r\n+        return optimistic.get();\r\n+    }\r\n+\r\n+    public void setAutoClear(String clear) {\r\n+        assertNotReadOnly();\r\n+        autoClear.setString(clear);\r\n+    }\r\n+\r\n+    public String getAutoClear() {\r\n+        return autoClear.getString();\r\n+    }\r\n+\r\n+    public void setAutoClear(int clear) {\r\n+        assertNotReadOnly();\r\n+        autoClear.set(clear);\r\n+    }\r\n+\r\n+    public int getAutoClearConstant() {\r\n+        return autoClear.get();\r\n+    }\r\n+\r\n+    public void setRetainState(boolean retainState) {\r\n+        assertNotReadOnly();\r\n+        this.retainState.set(retainState);\r\n+    }\r\n+\r\n+    public void setRetainState(Boolean retainState) {\r\n+        if (retainState != null)\r\n+            setRetainState(retainState.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getRetainState() {\r\n+        return retainState.get();\r\n+    }\r\n+\r\n+    public void setRestoreState(String restoreState) {\r\n+        assertNotReadOnly();\r\n+        this.restoreState.setString(restoreState);\r\n+    }\r\n+\r\n+    public String getRestoreState() {\r\n+        return restoreState.getString();\r\n+    }\r\n+\r\n+    public void setRestoreState(int restoreState) {\r\n+        assertNotReadOnly();\r\n+        this.restoreState.set(restoreState);\r\n+    }\r\n+\r\n+    public int getRestoreStateConstant() {\r\n+        return restoreState.get();\r\n+    }\r\n+\r\n+    public void setAutoDetach(String autoDetach) {\r\n+        assertNotReadOnly();\r\n+        this.autoDetach.setString(autoDetach);\r\n+    }\r\n+\r\n+    public String getAutoDetach() {\r\n+        return autoDetach.getString();\r\n+    }\r\n+\r\n+    public void setAutoDetach(int autoDetachFlags) {\r\n+        autoDetach.set(autoDetachFlags);\r\n+    }\r\n+\r\n+    public int getAutoDetachConstant() {\r\n+        return autoDetach.get();\r\n+    }\r\n+\r\n+    public void setDetachState(String detachState) {\r\n+        assertNotReadOnly();\r\n+        detachStatePlugin.setString(detachState);\r\n+    }\r\n+\r\n+    public String getDetachState() {\r\n+        return detachStatePlugin.getString();\r\n+    }\r\n+\r\n+    public void setDetachState(DetachOptions detachState) {\r\n+        assertNotReadOnly();\r\n+        detachStatePlugin.set(detachState);\r\n+    }\r\n+\r\n+    public DetachOptions getDetachStateInstance() {\r\n+        if (detachStatePlugin.get() == null)\r\n+            detachStatePlugin.instantiate(DetachOptions.class, this);\r\n+        return (DetachOptions) detachStatePlugin.get();\r\n+    }\r\n+\r\n+    public void setIgnoreChanges(boolean ignoreChanges) {\r\n+        assertNotReadOnly();\r\n+        this.ignoreChanges.set(ignoreChanges);\r\n+    }\r\n+\r\n+    public void setIgnoreChanges(Boolean ignoreChanges) {\r\n+        if (ignoreChanges != null)\r\n+            setIgnoreChanges(ignoreChanges.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getIgnoreChanges() {\r\n+        return ignoreChanges.get();\r\n+    }\r\n+\r\n+    public void setNontransactionalRead(boolean nontransactionalRead) {\r\n+        assertNotReadOnly();\r\n+        this.nontransactionalRead.set(nontransactionalRead);\r\n+    }\r\n+\r\n+    public void setNontransactionalRead(Boolean nontransactionalRead) {\r\n+        if (nontransactionalRead != null)\r\n+            setNontransactionalRead(nontransactionalRead.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getNontransactionalRead() {\r\n+        return nontransactionalRead.get();\r\n+    }\r\n+\r\n+    public void setNontransactionalWrite(boolean nontransactionalWrite) {\r\n+        assertNotReadOnly();\r\n+        this.nontransactionalWrite.set(nontransactionalWrite);\r\n+    }\r\n+\r\n+    public void setNontransactionalWrite(Boolean nontransactionalWrite) {\r\n+        if (nontransactionalWrite != null)\r\n+            setNontransactionalWrite(nontransactionalWrite.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getNontransactionalWrite() {\r\n+        return nontransactionalWrite.get();\r\n+    }\r\n+\r\n+    public void setMultithreaded(boolean multithreaded) {\r\n+        assertNotReadOnly();\r\n+        this.multithreaded.set(multithreaded);\r\n+    }\r\n+\r\n+    public void setMultithreaded(Boolean multithreaded) {\r\n+        if (multithreaded != null)\r\n+            setMultithreaded(multithreaded.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getMultithreaded() {\r\n+        return multithreaded.get();\r\n+    }\r\n+\r\n+    public void setFetchBatchSize(int fetchBatchSize) {\r\n+        assertNotReadOnly();\r\n+        this.fetchBatchSize.set(fetchBatchSize);\r\n+    }\r\n+\r\n+    public void setFetchBatchSize(Integer fetchBatchSize) {\r\n+        if (fetchBatchSize != null)\r\n+            setFetchBatchSize(fetchBatchSize.intValue());\r\n+    }\r\n+\r\n+    public int getFetchBatchSize() {\r\n+        return fetchBatchSize.get();\r\n+    }\r\n+\r\n+    public void setFetchGroups(String fetchGroups) {\r\n+        assertNotReadOnly();\r\n+        this.fetchGroups.setString(fetchGroups);\r\n+    }\r\n+\r\n+    public String getFetchGroups() {\r\n+        return fetchGroups.getString();\r\n+    }\r\n+\r\n+    public String[] getFetchGroupsList() {\r\n+        return fetchGroups.get();\r\n+    }\r\n+\r\n+    public void setFetchGroups(String[] fetchGroups) {\r\n+        this.fetchGroups.set(fetchGroups);\r\n+    }\r\n+\r\n+    public void setFlushBeforeQueries(String flush) {\r\n+        assertNotReadOnly();\r\n+        flushBeforeQueries.setString(flush);\r\n+    }\r\n+\r\n+    public String getFlushBeforeQueries() {\r\n+        return flushBeforeQueries.getString();\r\n+    }\r\n+\r\n+    public void setFlushBeforeQueries(int flush) {\r\n+        assertNotReadOnly();\r\n+        flushBeforeQueries.set(flush);\r\n+    }\r\n+\r\n+    public int getFlushBeforeQueriesConstant() {\r\n+        return flushBeforeQueries.get();\r\n+    }\r\n+\r\n+    public void setLockTimeout(int timeout) {\r\n+        assertNotReadOnly();\r\n+        lockTimeout.set(timeout);\r\n+    }\r\n+\r\n+    public void setLockTimeout(Integer timeout) {\r\n+        if (timeout != null)\r\n+            setLockTimeout(timeout.intValue());\r\n+    }\r\n+\r\n+    public int getLockTimeout() {\r\n+        return lockTimeout.get();\r\n+    }\r\n+\r\n+    public void setReadLockLevel(String level) {\r\n+        assertNotReadOnly();\r\n+        readLockLevel.setString(level);\r\n+    }\r\n+\r\n+    public String getReadLockLevel() {\r\n+        return readLockLevel.getString();\r\n+    }\r\n+\r\n+    public void setReadLockLevel(int level) {\r\n+        assertNotReadOnly();\r\n+        readLockLevel.set(level);\r\n+    }\r\n+\r\n+    public int getReadLockLevelConstant() {\r\n+        return readLockLevel.get();\r\n+    }\r\n+\r\n+    public void setWriteLockLevel(String level) {\r\n+        assertNotReadOnly();\r\n+        writeLockLevel.setString(level);\r\n+    }\r\n+\r\n+    public String getWriteLockLevel() {\r\n+        return writeLockLevel.getString();\r\n+    }\r\n+\r\n+    public void setWriteLockLevel(int level) {\r\n+        assertNotReadOnly();\r\n+        writeLockLevel.set(level);\r\n+    }\r\n+\r\n+    public int getWriteLockLevelConstant() {\r\n+        return writeLockLevel.get();\r\n+    }\r\n+\r\n+    public void setSequence(String sequence) {\r\n+        assertNotReadOnly();\r\n+        seqPlugin.setString(sequence);\r\n+    }\r\n+\r\n+    public String getSequence() {\r\n+        return seqPlugin.getString();\r\n+    }\r\n+\r\n+    public void setSequence(Seq seq) {\r\n+        assertNotReadOnly();\r\n+        seqPlugin.set(seq);\r\n+    }\r\n+\r\n+    public Seq getSequenceInstance() {\r\n+        if (seqPlugin.get() == null)\r\n+            seqPlugin.instantiate(Seq.class, this);\r\n+        return (Seq) seqPlugin.get();\r\n+    }\r\n+\r\n+    public void setConnectionRetainMode(String connectionRetainMode) {\r\n+        assertNotReadOnly();\r\n+        this.connectionRetainMode.setString(connectionRetainMode);\r\n+    }\r\n+\r\n+    public String getConnectionRetainMode() {\r\n+        return connectionRetainMode.getString();\r\n+    }\r\n+\r\n+    public void setConnectionRetainMode(int connectionRetainMode) {\r\n+        assertNotReadOnly();\r\n+        this.connectionRetainMode.set(connectionRetainMode);\r\n+    }\r\n+\r\n+    public int getConnectionRetainModeConstant() {\r\n+        return connectionRetainMode.get();\r\n+    }\r\n+\r\n+    public void setFilterListeners(String filterListeners) {\r\n+        assertNotReadOnly();\r\n+        filterListenerPlugins.setString(filterListeners);\r\n+    }\r\n+\r\n+    public String getFilterListeners() {\r\n+        return filterListenerPlugins.getString();\r\n+    }\r\n+\r\n+    public void setFilterListeners(FilterListener[] listeners) {\r\n+        assertNotReadOnly();\r\n+        filterListenerPlugins.set(listeners);\r\n+    }\r\n+\r\n+    public FilterListener[] getFilterListenerInstances() {\r\n+        if (filterListenerPlugins.get() == null)\r\n+            filterListenerPlugins.instantiate(FilterListener.class, this);\r\n+        return (FilterListener[]) filterListenerPlugins.get();\r\n+    }\r\n+\r\n+    public void setAggregateListeners(String aggregateListeners) {\r\n+        assertNotReadOnly();\r\n+        aggregateListenerPlugins.setString(aggregateListeners);\r\n+    }\r\n+\r\n+    public String getAggregateListeners() {\r\n+        return aggregateListenerPlugins.getString();\r\n+    }\r\n+\r\n+    public void setAggregateListeners(AggregateListener[] listeners) {\r\n+        assertNotReadOnly();\r\n+        aggregateListenerPlugins.set(listeners);\r\n+    }\r\n+\r\n+    public AggregateListener[] getAggregateListenerInstances() {\r\n+        if (aggregateListenerPlugins.get() == null)\r\n+            aggregateListenerPlugins.instantiate(AggregateListener.class, this);\r\n+        return (AggregateListener[]) aggregateListenerPlugins.get();\r\n+    }\r\n+\r\n+    public void setRetryClassRegistration(boolean retry) {\r\n+        assertNotReadOnly();\r\n+        retryClassRegistration.set(retry);\r\n+    }\r\n+\r\n+    public void setRetryClassRegistration(Boolean retry) {\r\n+        if (retry != null)\r\n+            setRetryClassRegistration(retry.booleanValue());\r\n+    }\r\n+\r\n+    public boolean getRetryClassRegistration() {\r\n+        return retryClassRegistration.get();\r\n+    }\r\n+\r\n+    public String getCompatibility() {\r\n+        return compatibilityPlugin.getString();\r\n+    }\r\n+\r\n+    public void setCompatibility(String compatibility) {\r\n+        compatibilityPlugin.setString(compatibility);\r\n+    }\r\n+\r\n+    public Compatibility getCompatibilityInstance() {\r\n+        if (compatibilityPlugin.get() == null)\r\n+            compatibilityPlugin.instantiate(Compatibility.class, this);\r\n+        return (Compatibility) compatibilityPlugin.get();\r\n+    }\r\n+\r\n+    public void instantiateAll() {\r\n+        super.instantiateAll();\r\n+        // instantiate singletons without values\r\n+        getRemoteCommitEventManager();\r\n+        getMetaDataRepository();\r\n+    }\r\n+\r\n+    public void close() {\r\n+        ImplHelper.close(remoteEventManager);\r\n+        ImplHelper.close(metaRepos);\r\n+        super.close();\r\n+        ProductDerivations.afterClose(this);\r\n+    }\r\n+\r\n+    protected boolean isInvalidProperty(String propName) {\r\n+        // handle warnings for org.apache.openjpa.SomeString, but not for\r\n+        // org.apache.openjpa.some.subpackage.SomeString, since it might be valid for some\r\n+        // specific implementation of OpenJPA\r\n+        return propName.toLowerCase().startsWith(\"org.apache.openjpa.\")\r\n+            && propName.length() > 5 && propName.indexOf('.', 5) == -1;\r\n+    }\r\n+\r\n+    public Log getConfigurationLog() {\r\n+        return getLog(LOG_RUNTIME);\r\n+    }\r\n+}\r"},{"sha":"a20764944b4929b2ac8f13b99668f06177dbcaed","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,58 @@\n+package org.apache.openjpa.conf;\r\n+\r\n+import java.io.File;\r\n+import java.util.Date;\r\n+import java.util.StringTokenizer;\r\n+\r\n+/**\r\n+ * This class contains version information for Kodo. It uses\r\n+ * Ant's filter tokens to convert the template into a java\r\n+ * file with current information.\r\n+ *\r\n+ * @author Marc Prud'hommeaux, Patrick Linskey\r\n+ */\r\n+public class OpenJPAVersion {\r\n+\r\n+    public static final String VERSION_NUMBER = \"4.1.0EA1\";\r\n+    private static final long RELEASE_SECONDS = 1147454303;\r\n+    public static final Date RELEASE_DATE = new Date(RELEASE_SECONDS * 1000);\r\n+    public static final String VERSION_ID = \"kodo-4.1.0EA1-20060710-0004\";\r\n+    public static final String VENDOR_NAME = \"BEA\";\r\n+    public static final int MAJOR_RELEASE = 4;\r\n+    public static final int MINOR_RELEASE = 1;\r\n+    public static final int PATCH_RELEASE = 0;\r\n+    public static final String RELEASE_STATUS = \"EA1\";\r\n+\r\n+    public static void main(String [] args) {\r\n+        System.out.println(new OpenJPAVersion().toString());\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        StringBuffer buf = new StringBuffer(80 * 30);\r\n+        buf.append(\"Kodo\");\r\n+        buf.append(VERSION_NUMBER);\r\n+        buf.append(\"\\n\");\r\n+        buf.append(\"version id: \").append(VERSION_ID);\r\n+        buf.append(\"\\n\\n\");\r\n+        getProperty(\"os.name\", buf).append(\"\\n\");\r\n+        getProperty(\"os.version\", buf).append(\"\\n\");\r\n+        getProperty(\"os.arch\", buf).append(\"\\n\\n\");\r\n+        getProperty(\"java.version\", buf).append(\"\\n\");\r\n+        getProperty(\"java.vendor\", buf).append(\"\\n\\n\");\r\n+        buf.append(\"java.class.path:\\n\");\r\n+        StringTokenizer tok = new StringTokenizer\r\n+            (System.getProperty(\"java.class.path\"), File.pathSeparator);\r\n+        while (tok.hasMoreTokens()) {\r\n+            buf.append(\"\\t\").append(tok.nextToken());\r\n+            buf.append(\"\\n\");\r\n+        }\r\n+        buf.append(\"\\n\");\r\n+        getProperty(\"user.dir\", buf);\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    private StringBuffer getProperty(String prop, StringBuffer buf) {\r\n+        buf.append(prop).append(\": \").append(System.getProperty(prop));\r\n+        return buf;\r\n+    }\r\n+}\r"},{"sha":"c7174766e5b8f499667de04ea77251ab94181e5c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivation.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,65 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+\r\n+/**\r\n+ * Hooks for deriving products with additional functionality.\r\n+ * All implementations of this interface will have a chance to mutate\r\n+ * a {@link Configuration} both before and after the user-specified\r\n+ * configuration data is loaded. The order in which the\r\n+ * derivations are evaluated is determined by the specificity of the\r\n+ * derivation type.\r\n+ *\r\n+ * @since 4.1\r\n+ */\r\n+public interface ProductDerivation {\r\n+\r\n+    public static final int TYPE_SPEC = 0;\r\n+    public static final int TYPE_PRODUCT = 1;\r\n+    public static final int TYPE_STORE = 2;\r\n+    public static final int TYPE_SPEC_STORE = 3;\r\n+    public static final int TYPE_PRODUCT_STORE = 4;\r\n+    public static final int TYPE_FEATURE = 5;\r\n+\r\n+    /**\r\n+     * Return the type of derivation.\r\n+     */\r\n+    public int getType();\r\n+\r\n+    /**\r\n+     * Provides the instance with a callback to mutate the initial properties\r\n+     * of the {@link ConfigurationProvider}. This is primarily to alter or\r\n+     * add properties that determine what type of configuration is constructed,\r\n+     * and therefore is typically used at runtime only.\r\n+     */\r\n+    public void beforeConfigurationConstruct(ConfigurationProvider cp);\r\n+\r\n+    /**\r\n+     * Provides the instance with the opportunity to mutate\r\n+     * <code>conf</code> before the user configuration is applied.\r\n+     */\r\n+    public void beforeConfigurationLoad(OpenJPAConfiguration conf);\r\n+\r\n+    /**\r\n+     * Called after the specification has been set.\r\n+     */\r\n+    public void afterSpecificationSet(OpenJPAConfiguration conf);\r\n+\r\n+    /**\r\n+     * Called after the configuration has been closed.\r\n+     */\r\n+    public void afterClose(OpenJPAConfiguration conf);\r\n+}\r"},{"sha":"ccdc784fcdbfe5375508721d38eeab63a90d72e3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/ProductDerivations.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,123 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.Comparator;\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+import org.apache.openjpa.lib.util.Services;\r\n+\r\n+/**\r\n+ * Utilities for running product derivations.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class ProductDerivations {\r\n+\r\n+    private static final ProductDerivation[] _derivations;\r\n+\r\n+    static {\r\n+        Class[] pdcls = Services.getImplementorClasses(ProductDerivation.class);\r\n+        List derivations = new ArrayList(pdcls.length);\r\n+        for (int i = 0; i < pdcls.length; i++) {\r\n+            try {\r\n+                derivations.add(pdcls[i].newInstance());\r\n+            } catch (Throwable t) {\r\n+                // invalid service\r\n+            }\r\n+        }\r\n+        Collections.sort(derivations, new ProductDerivationComparator());\r\n+        _derivations = (ProductDerivation[]) derivations.toArray\r\n+            (new ProductDerivation[derivations.size()]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply {@link ProductDerivation#beforeConfigurationConstruct} callbacks\r\n+     * to the the given instance. Exceptions are swallowed.\r\n+     */\r\n+    public static void beforeConfigurationConstruct(ConfigurationProvider cp) {\r\n+        for (int i = 0; i < _derivations.length; i++) {\r\n+            try {\r\n+                _derivations[i].beforeConfigurationConstruct(cp);\r\n+            } catch (Exception e) {\r\n+                // can't log; no configuration yet\r\n+                e.printStackTrace();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply {@link ProductDerivation#beforeConfigurationLoad} callbacks\r\n+     * to the the given instance. Exceptions are swallowed.\r\n+     */\r\n+    public static void beforeConfigurationLoad(OpenJPAConfiguration conf) {\r\n+        for (int i = 0; i < _derivations.length; i++) {\r\n+            try {\r\n+                _derivations[i].beforeConfigurationLoad(conf);\r\n+            } catch (Exception e) {\r\n+                // logging not configured yet\r\n+                e.printStackTrace();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply {@link ProductDerivation#afterSpecificationSet} callbacks\r\n+     * to the the given instance. Exceptions are swallowed.\r\n+     */\r\n+    public static void afterSpecificationSet(OpenJPAConfiguration conf) {\r\n+        for (int i = 0; i < _derivations.length; i++) {\r\n+            try {\r\n+                _derivations[i].afterSpecificationSet(conf);\r\n+            } catch (Exception e) {\r\n+                // logging not configured yet\r\n+                e.printStackTrace();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply {@link ProductDerivation#afterClose} callbacks\r\n+     * to the the given instance. Exceptions are swallowed.\r\n+     */\r\n+    public static void afterClose(OpenJPAConfigurationImpl impl) {\r\n+        for (int i = 0; i < _derivations.length; i++) {\r\n+            try {\r\n+                _derivations[i].afterClose(impl);\r\n+            } catch (Exception e) {\r\n+                // logging not available\r\n+                e.printStackTrace();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Compare {@link ProductDerivation}s.\r\n+     */\r\n+    private static class ProductDerivationComparator implements Comparator {\r\n+\r\n+        public int compare(Object o1, Object o2) {\r\n+            int type1 = ((ProductDerivation) o1).getType();\r\n+            int type2 = ((ProductDerivation) o2).getType();\r\n+            if (type1 != type2)\r\n+                return type1 - type2;\r\n+            // arbitrary but consistent order\r\n+            return o1.getClass().getName().compareTo(o2.getClass(). getName());\r\n+        }\r\n+    }\r\n+}\r\n+\r"},{"sha":"29237a5f1f7d9233714e2dacc9f66abad01ad7fa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,132 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.event.RemoteCommitProvider;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+\r\n+/**\r\n+ * Value type used to represent a {@link RemoteCommitProvider}. This\r\n+ * plugin allows users to specify whether to transmit the ids of added objects\r\n+ * in the remote commit events distributed.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class RemoteCommitProviderValue extends PluginValue {\r\n+\r\n+    private static final String[] ALIASES = new String[]{\r\n+        \"sjvm\", \"org.apache.openjpa.event.SingleJVMRemoteCommitProvider\",\r\n+        \"jms\", \"org.apache.openjpa.event.JMSRemoteCommitProvider\",\r\n+        \"tcp\", \"org.apache.openjpa.event.TCPRemoteCommitProvider\", };\r\n+    private Options _opts = null;\r\n+    private Boolean _transmitPersIds = null;\r\n+\r\n+    public RemoteCommitProviderValue(String prop) {\r\n+        super(prop, true);\r\n+        setAliases(ALIASES);\r\n+    }\r\n+\r\n+    public void setProperties(String props) {\r\n+        super.setProperties(props);\r\n+        _opts = null;\r\n+        _transmitPersIds = null;\r\n+    }\r\n+\r\n+    public void setString(String str) {\r\n+        super.setString(str);\r\n+        _opts = null;\r\n+        _transmitPersIds = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * The cached provider.\r\n+     */\r\n+    public RemoteCommitProvider getProvider() {\r\n+        return (RemoteCommitProvider) get();\r\n+    }\r\n+\r\n+    /**\r\n+     * The cached provider.\r\n+     */\r\n+    public void setProvider(RemoteCommitProvider provider) {\r\n+        set(provider);\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to transmit persisted object ids in remote commit events.\r\n+     */\r\n+    public boolean getTransmitPersistedObjectIds() {\r\n+        return Boolean.TRUE.equals(_transmitPersIds);\r\n+    }\r\n+\r\n+    /**\r\n+     * The cached decorators.\r\n+     */\r\n+    public void setTransmitPersistedObjectIds(boolean transmit) {\r\n+        _transmitPersIds = (transmit) ? Boolean.TRUE : Boolean.FALSE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Instantiate the provider.\r\n+     */\r\n+    public RemoteCommitProvider instantiateProvider(Configuration conf) {\r\n+        return instantiateProvider(conf, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Instantiate the provider.\r\n+     */\r\n+    public RemoteCommitProvider instantiateProvider(Configuration conf,\r\n+        boolean fatal) {\r\n+        return (RemoteCommitProvider) instantiate(RemoteCommitProvider.class,\r\n+            conf, fatal);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the remote event manager.\r\n+     */\r\n+    public void configureEventManager(RemoteCommitEventManager mgr) {\r\n+        parseOptions();\r\n+        if (_transmitPersIds != null)\r\n+            mgr.setTransmitPersistedObjectIds(_transmitPersIds.booleanValue());\r\n+    }\r\n+\r\n+    /**\r\n+     * Override to keep decorators out of transport configuration.\r\n+     */\r\n+    public Object instantiate(Class type, Configuration conf, boolean fatal) {\r\n+        Object obj = newInstance(getClassName(), type, conf, fatal);\r\n+        parseOptions();\r\n+        Configurations.configureInstance(obj, conf, _opts, getProperty());\r\n+        set(obj, true);\r\n+        return obj;\r\n+    }\r\n+\r\n+    private void parseOptions() {\r\n+        if (_opts != null)\r\n+            return;\r\n+        _opts = Configurations.parseProperties(getProperties());\r\n+        String transmit = _opts.removeProperty(\"transmitPersistedObjectIds\",\r\n+            \"TransmitPersistedObjectIds\", null);\r\n+        if (transmit != null) {\r\n+            transmit = transmit.trim();\r\n+            if (transmit.length() > 0)\r\n+                _transmitPersIds = Boolean.valueOf(transmit);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"d9cbf12b89a567f4f9baeef1ad3629254ef79031","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,41 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.conf;\r\n+\r\n+import org.apache.openjpa.kernel.TimeSeededSeq;\r\n+import org.apache.openjpa.lib.conf.PluginValue;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+\r\n+/**\r\n+ * Value type used to represent a sequence. This type is\r\n+ * defined separately so that it can be used both in the global configuration\r\n+ * and in class metadata with the same encapsulated configuration.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class SeqValue extends PluginValue {\r\n+\r\n+    private static final String[] ALIASES = new String[]{\r\n+        SequenceMetaData.IMPL_TIME, TimeSeededSeq.class.getName(),\r\n+        SequenceMetaData.IMPL_NATIVE, TimeSeededSeq.class.getName(),\r\n+        // deprecated aliases\r\n+        \"sjvm\", TimeSeededSeq.class.getName(), };\r\n+\r\n+    public SeqValue(String prop) {\r\n+        super(prop, true);\r\n+        setAliases(ALIASES);\r\n+        setDefault(ALIASES[0]);\r\n+        setClassName(ALIASES[1]);\r\n+    }\r\n+}\r"},{"sha":"810b7c4c8edc529bd57256f2caa5ea8bb2b999b7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Configuration</strong></p>\n+\n+<p>\n+    This package provides base OpenJPA configuration interfaces.\n+</p>\n+</body>\n+</html>"},{"sha":"7733b466e51d678b0c2b616e875e7c5419a3ddad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"added","additions":403,"deletions":0,"changes":403,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,403 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.event.RemoteCommitEvent;\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+\r\n+/**\r\n+ * Abstract {@link DataCache} implementation that provides various\r\n+ * statistics, logging, and timeout functionality common across cache\r\n+ * implementations.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractDataCache extends AbstractConcurrentEventManager\r\n+    implements DataCache, Configurable {\r\n+\r\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n+    private static final Localizer s_loc =\r\n+        Localizer.forPackage(AbstractDataCache.class);\r\n+\r\n+    /**\r\n+     * The configuration set by the system.\r\n+     */\r\n+    protected OpenJPAConfiguration conf;\r\n+\r\n+    /**\r\n+     * The log to use.\r\n+     */\r\n+    protected Log log;\r\n+    private String _name = null;\r\n+    private boolean _closed = false;\r\n+    private String _schedule = null;\r\n+\r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    public void setName(String name) {\r\n+        _name = name;\r\n+    }\r\n+\r\n+    public String getEvictionSchedule() {\r\n+        return _schedule;\r\n+    }\r\n+\r\n+    public void setEvictionSchedule(String s) {\r\n+        _schedule = s;\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager manager) {\r\n+        if (_schedule != null && !\"\".equals(_schedule)) {\r\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n+            if (scheduler != null)\r\n+                scheduler.scheduleEviction(this, _schedule);\r\n+        }\r\n+    }\r\n+\r\n+    public void commit(Collection additions, Collection newUpdates,\r\n+        Collection existingUpdates, Collection deletes) {\r\n+        // remove all objects in deletes list\r\n+        removeAllInternal(deletes);\r\n+        // next, add all the new additions\r\n+        putAllInternal(additions);\r\n+        putAllInternal(newUpdates);\r\n+        // possibly add the existing updates, depending on the\r\n+        // semantics of the cache, as dictated by recacheUpdates()\r\n+        if (recacheUpdates())\r\n+            putAllInternal(existingUpdates);\r\n+        if (log.isTraceEnabled()) {\r\n+            Collection addIds = new ArrayList(additions.size());\r\n+            Collection upIds = new ArrayList(newUpdates.size());\r\n+            Collection exIds = new ArrayList(existingUpdates.size());\r\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n+                addIds.add(((DataCachePCData) iter.next()).getId());\r\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n+                upIds.add(((DataCachePCData) iter.next()).getId());\r\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n+                exIds.add(((DataCachePCData) iter.next()).getId());\r\n+            log.trace(s_loc.get(\"cache-commit\",\r\n+                new Object[]{ addIds, upIds, exIds, deletes }));\r\n+        }\r\n+    }\r\n+\r\n+    public boolean contains(Object key) {\r\n+        DataCachePCData o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+        return o != null;\r\n+    }\r\n+\r\n+    public BitSet containsAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (contains(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public DataCachePCData get(Object key) {\r\n+        DataCachePCData o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-miss\", key));\r\n+            else log.trace(s_loc.get(\"cache-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public DataCachePCData put(DataCachePCData data) {\r\n+        DataCachePCData o = putInternal(data.getId(), data);\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n+        return (o == null || o.isTimedOut()) ? null : o;\r\n+    }\r\n+\r\n+    public void update(DataCachePCData data) {\r\n+        if (recacheUpdates())\r\n+            putInternal(data.getId(), data);\r\n+    }\r\n+\r\n+    public DataCachePCData remove(Object key) {\r\n+        DataCachePCData o = removeInternal(key);\r\n+        if (o != null && o.isTimedOut())\r\n+            o = null;\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n+            else log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public BitSet removeAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (remove(iter.next()) != null)\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the objects of the given class from the cache.\r\n+     */\r\n+    public void removeAll(Class cls, boolean subClasses) {\r\n+        removeAllInternal(cls, subClasses);\r\n+    }\r\n+\r\n+    public boolean pin(Object key) {\r\n+        boolean bool = pinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n+            else log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public BitSet pinAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (pin(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public boolean unpin(Object key) {\r\n+        boolean bool = unpinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n+            else log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public BitSet unpinAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (unpin(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        clearInternal();\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n+    }\r\n+\r\n+    public void close() {\r\n+        close(true);\r\n+    }\r\n+\r\n+    protected void close(boolean clear) {\r\n+        if (!_closed) {\r\n+            if (clear)\r\n+                clearInternal();\r\n+            _closed = true;\r\n+        }\r\n+    }\r\n+\r\n+    public boolean isClosed() {\r\n+        return _closed;\r\n+    }\r\n+\r\n+    public void addExpirationListener(ExpirationListener listen) {\r\n+        addListener(listen);\r\n+    }\r\n+\r\n+    public boolean removeExpirationListener(ExpirationListener listen) {\r\n+        return removeListener(listen);\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n+    }\r\n+\r\n+    /**\r\n+     * This method is part of the {@link RemoteCommitListener} interface. If\r\n+     * your cache subclass relies on OpenJPA for clustering support, make it\r\n+     * implement <code>RemoteCommitListener</code>. This method will take\r\n+     * care of invalidating entries from remote commits.\r\n+     */\r\n+    public void afterCommit(RemoteCommitEvent event) {\r\n+        if (_closed)\r\n+            return;\r\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n+        } else {\r\n+            // drop all the committed OIDs, excepting brand\r\n+            // new OIDs. brand new OIDs either won't be in\r\n+            // the cache, or if they are, will be more up to date\r\n+            removeAllInternal(event.getUpdatedObjectIds());\r\n+            removeAllInternal(event.getDeletedObjectIds());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Invoke when a key is removed from this cache. Propagates the\r\n+     * expiration event on to all expiration listeners registered\r\n+     * with this class.\r\n+     */\r\n+    protected void keyRemoved(Object key, boolean expired) {\r\n+        // Notify any expiration listeners of the expiration.\r\n+        if (hasListeners())\r\n+            fireEvent(new ExpirationEvent(this, key, expired));\r\n+        if (expired && log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-expired\", key));\r\n+    }\r\n+\r\n+    /**\r\n+     * Return <code>true</code> if updates to data already in the\r\n+     * cache(either in {@link #commit} or the {@link #update})\r\n+     * should be put back into the cache. Returns false by default.\r\n+     */\r\n+    protected boolean recacheUpdates() {\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the object for the given oid.\r\n+     */\r\n+    protected abstract DataCachePCData getInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Add the given object to the cache, returning the old object under the\r\n+     * given oid.\r\n+     */\r\n+    protected abstract DataCachePCData putInternal(Object oid,\r\n+        DataCachePCData pc);\r\n+\r\n+    /**\r\n+     * All all of the given objects to the cache.\r\n+     */\r\n+    protected void putAllInternal(Collection pcs) {\r\n+        DataCachePCData pc;\r\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n+            pc = (DataCachePCData) iter.next();\r\n+            putInternal(pc.getId(), pc);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the object under the given oid from the cache.\r\n+     */\r\n+    protected abstract DataCachePCData removeInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Evict objects in cache by class.\r\n+     */\r\n+    protected abstract void removeAllInternal(Class cls, boolean subclasses);\r\n+\r\n+    /**\r\n+     * Remove all objects under the given oids from the cache.\r\n+     */\r\n+    protected void removeAllInternal(Collection oids) {\r\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n+            removeInternal(iter.next());\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove all objects of the given class names from the cache.\r\n+     */\r\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n+        if (classes == null)\r\n+            return;\r\n+        Class cls;\r\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n+            cls = (Class) iter.next();\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n+            removeAllInternal(cls, false);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    protected abstract void clearInternal();\r\n+\r\n+    /**\r\n+     * Pin an object to the cache.\r\n+     */\r\n+    protected abstract boolean pinInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Unpin an object from the cache.\r\n+     */\r\n+    protected abstract boolean unpinInternal(Object oid);\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+    public void setConfiguration(Configuration conf) {\r\n+        this.conf = (OpenJPAConfiguration) conf;\r\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+        if (_name == null)\r\n+            setName(NAME_DEFAULT);\r\n+    }\r\n+\r\n+    // ---------- AbstractEventManager implementation ----------\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        ExpirationListener listen = (ExpirationListener) listener;\r\n+        ExpirationEvent ev = (ExpirationEvent) event;\r\n+        try {\r\n+            listen.onExpire(ev);\r\n+        } catch (Exception e) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"7434817587a58ba767c8c82674d9285f09d57d2a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"added","additions":307,"deletions":0,"changes":307,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,307 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.event.RemoteCommitEvent;\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.AbstractEventManager;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.Id;\r\n+\r\n+/**\r\n+ * Abstract {@link QueryCache} implementation that provides various\r\n+ * statistics, logging, and timeout functionality common across cache\r\n+ * implementations.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractQueryCache\r\n+    extends AbstractEventManager //### use concurrent; need to mod OpenJPA\r\n+    implements QueryCache, Configurable {\r\n+\r\n+    private static final Localizer s_loc =\r\n+        Localizer.forPackage(AbstractQueryCache.class);\r\n+\r\n+    /**\r\n+     * The configuration set by the system.\r\n+     */\r\n+    protected OpenJPAConfiguration conf;\r\n+\r\n+    /**\r\n+     * The log to use.\r\n+     */\r\n+    protected Log log;\r\n+    private boolean _closed = false;\r\n+\r\n+    public void initialize(DataCacheManager manager) {\r\n+    }\r\n+\r\n+    public void onTypesChanged(TypesChangedEvent ev) {\r\n+        writeLock();\r\n+        Collection keys = null;\r\n+        try {\r\n+            if (hasListeners())\r\n+                fireEvent(ev);\r\n+            keys = keySet();\r\n+        }\r\n+        finally {\r\n+            writeUnlock();\r\n+        }\r\n+        QueryKey qk;\r\n+        List removes = null;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\r\n+            qk = (QueryKey) iter.next();\r\n+            if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n+                if (removes == null)\r\n+                    removes = new ArrayList();\r\n+                removes.add(qk);\r\n+            }\r\n+        }\r\n+        if (removes != null)\r\n+            removeAllInternal(removes);\r\n+    }\r\n+\r\n+    public QueryResult get(QueryKey key) {\r\n+        QueryResult o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-miss\", key));\r\n+            else log.trace(s_loc.get(\"cache-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n+        QueryResult o = putInternal(qk, oids);\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-put\", qk));\r\n+        return (o == null || o.isTimedOut()) ? null : o;\r\n+    }\r\n+\r\n+    public QueryResult remove(QueryKey key) {\r\n+        QueryResult o = removeInternal(key);\r\n+        if (o != null && o.isTimedOut())\r\n+            o = null;\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n+            else log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public boolean pin(QueryKey key) {\r\n+        boolean bool = pinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n+            else log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public boolean unpin(QueryKey key) {\r\n+        boolean bool = unpinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n+            else log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        clearInternal();\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n+    }\r\n+\r\n+    public void close() {\r\n+        close(true);\r\n+    }\r\n+\r\n+    protected void close(boolean clear) {\r\n+        if (!_closed) {\r\n+            if (clear)\r\n+                clearInternal();\r\n+            _closed = true;\r\n+        }\r\n+    }\r\n+\r\n+    public boolean isClosed() {\r\n+        return _closed;\r\n+    }\r\n+\r\n+    public void addTypesChangedListener(TypesChangedListener listen) {\r\n+        addListener(listen);\r\n+    }\r\n+\r\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n+        return removeListener(listen);\r\n+    }\r\n+\r\n+    /**\r\n+     * This method is part of the {@link RemoteCommitListener} interface. If\r\n+     * your cache subclass relies on OpenJPA for clustering support, make it\r\n+     * implement <code>RemoteCommitListener</code>. This method will take\r\n+     * care of invalidating entries from remote commits, by delegating to\r\n+     * {@link #typesChanged}.\r\n+     */\r\n+    public void afterCommit(RemoteCommitEvent event) {\r\n+        if (_closed)\r\n+            return;\r\n+        // drop all committed classes\r\n+        Set classes = Caches.addTypesByName(conf,\r\n+            event.getPersistedTypeNames(), null);\r\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n+                classes);\r\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n+                classes);\r\n+        } else {\r\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n+        }\r\n+        if (classes != null)\r\n+            onTypesChanged(new TypesChangedEvent(this, classes));\r\n+    }\r\n+\r\n+    /**\r\n+     * Build up a set of classes for the given oids.\r\n+     */\r\n+    private Set addTypes(Collection oids, Set classes) {\r\n+        if (oids.isEmpty())\r\n+            return classes;\r\n+        if (classes == null)\r\n+            classes = new HashSet();\r\n+        MetaDataRepository repos = conf.getMetaDataRepository();\r\n+        ClassMetaData meta;\r\n+        Object oid;\r\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n+            oid = itr.next();\r\n+            if (oid instanceof Id)\r\n+                classes.add(((Id) oid).getType());\r\n+            else {\r\n+                // ok if no metadata for oid; that just means the pc type\r\n+                // probably hasn't been loaded into this JVM yet, and therefore\r\n+                // there's no chance that it's in the cache anyway\r\n+                meta = repos.getMetaData(oid, null, false);\r\n+                if (meta != null)\r\n+                    classes.add(meta.getDescribedType());\r\n+            }\r\n+        }\r\n+        return classes;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a threadsafe view of the keys in this cache. This collection\r\n+     * must be iterable without risk of concurrent modification exceptions.\r\n+     * It does not have to implement contains() efficiently or use set\r\n+     * semantics.\r\n+     */\r\n+    protected abstract Collection keySet();\r\n+\r\n+    /**\r\n+     * Return the list for the given key.\r\n+     */\r\n+    protected abstract QueryResult getInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Add the given result to the cache, returning the old result under the\r\n+     * given key.\r\n+     */\r\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n+\r\n+    /**\r\n+     * Remove the result under the given key from the cache.\r\n+     */\r\n+    protected abstract QueryResult removeInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Remove all results under the given keys from the cache.\r\n+     */\r\n+    protected void removeAllInternal(Collection qks) {\r\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n+            removeInternal((QueryKey) iter.next());\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    protected abstract void clearInternal();\r\n+\r\n+    /**\r\n+     * Pin an object to the cache.\r\n+     */\r\n+    protected abstract boolean pinInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Unpin an object from the cache.\r\n+     */\r\n+    protected abstract boolean unpinInternal(QueryKey qk);\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+    public void setConfiguration(Configuration conf) {\r\n+        this.conf = (OpenJPAConfiguration) conf;\r\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+\r\n+    // ---------- AbstractEventManager implementation ----------\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        TypesChangedListener listen = (TypesChangedListener) listener;\r\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n+        try {\r\n+            listen.onTypesChanged(ev);\r\n+        } catch (Exception e) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Individual query results will be registered as types changed\r\n+     * listeners. We want such query results to be gc'd once\r\n+     * the only reference is held by the list of expiration listeners.\r\n+     */\r\n+    protected Collection newListenerCollection() {\r\n+        //### use concurrent\r\n+        return new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n+    }\r\n+}\r"},{"sha":"f1ecee228ee82e05e1e15593ae0a798af3aa17ac","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,50 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+\r\n+class Caches {\r\n+\r\n+    /**\r\n+     * Utility to build up a set of classes from their class names\r\n+     * when operating outside the context of a persistence manager.\r\n+     * The set classes can be null, in which case a new Set will be created.\r\n+     */\r\n+    static Set addTypesByName(OpenJPAConfiguration conf,\r\n+        Collection classNames, Set classes) {\r\n+        if (classNames.isEmpty())\r\n+            return classes;\r\n+        ClassLoader loader = conf.getClassResolverInstance().\r\n+            getClassLoader(null, null);\r\n+        Class cls;\r\n+        String className;\r\n+        for (Iterator iter = classNames.iterator(); iter.hasNext();) {\r\n+            className = (String) iter.next();\r\n+            try {\r\n+                cls = Class.forName(className, true, loader);\r\n+                if (classes == null)\r\n+                    classes = new HashSet();\r\n+                classes.add(cls);\r\n+            } catch (Throwable t) {\r\n+                conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\r\n+            }\r\n+        }\r\n+        return classes;\r\n+    }\r\n+}\r"},{"sha":"143c51b508c440f40664cca9adcfa44f09748b84","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","status":"added","additions":136,"deletions":0,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,136 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.util.CacheMap;\r\n+\r\n+/**\r\n+ * A {@link DataCache} implementation that is optimized for concurrent\r\n+ * access. When the cache fills up, values to remove from cache are chosen\r\n+ * randomly. Due to race conditions, it is possible that a get call might not\r\n+ * return a cached instance if that instance is being transferred between\r\n+ * internal datastructures.\r\n+ *\r\n+ * @since 4.0\r\n+ */\r\n+public class ConcurrentDataCache extends AbstractDataCache\r\n+    implements RemoteCommitListener {\r\n+\r\n+    private final CacheMap _cache = newCacheMap();\r\n+\r\n+    /**\r\n+     * Returns the underlying {@link CacheMap} that this cache is using.\r\n+     * This is not an unmodifiable view on the map, so care should be taken\r\n+     * with this reference. Implementations should probably not modify the\r\n+     * contents of the cache, but should only use this reference to\r\n+     * obtain cache metrics.\r\n+     */\r\n+    public CacheMap getCacheMap() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the maximum number of unpinned objects to keep hard\r\n+     * references to. If the map contains more unpinned objects than\r\n+     * <code>size</code>, then this method will result in the cache\r\n+     * flushing old values.\r\n+     */\r\n+    public void setCacheSize(int size) {\r\n+        _cache.setCacheSize(size);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the maximum number of unpinned objects to keep hard\r\n+     * references to.\r\n+     */\r\n+    public int getCacheSize() {\r\n+        return _cache.getCacheSize();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the maximum number of unpinned objects to keep soft\r\n+     * references to. If the map contains more soft references than\r\n+     * <code>size</code>, then this method will result in the cache\r\n+     * flushing values.\r\n+     */\r\n+    public void setSoftReferenceSize(int size) {\r\n+        _cache.setSoftReferenceSize(size);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the maximum number of unpinned objects to keep soft\r\n+     * references to. Defaults to <code>-1</code>.\r\n+     */\r\n+    public int getSoftReferenceSize() {\r\n+        return _cache.getSoftReferenceSize();\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager mgr) {\r\n+        super.initialize(mgr);\r\n+        conf.getRemoteCommitEventManager().addListener(this);\r\n+    }\r\n+\r\n+    public void writeLock() {\r\n+        _cache.writeLock();\r\n+    }\r\n+\r\n+    public void writeUnlock() {\r\n+        _cache.writeUnlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the map to use as an internal cache; entry expirations must\r\n+     * invoke {@link AbstractDataCache#keyRemoved}.\r\n+     */\r\n+    protected CacheMap newCacheMap() {\r\n+        return new CacheMap() {\r\n+            protected void entryRemoved(Object key, Object value,\r\n+                boolean expired) {\r\n+                keyRemoved(key, expired);\r\n+            }\r\n+        };\r\n+    }\r\n+\r\n+    protected DataCachePCData getInternal(Object key) {\r\n+        return (DataCachePCData) _cache.get(key);\r\n+    }\r\n+\r\n+    protected DataCachePCData putInternal(Object key, DataCachePCData pc) {\r\n+        return (DataCachePCData) _cache.put(key, pc);\r\n+    }\r\n+\r\n+    protected DataCachePCData removeInternal(Object key) {\r\n+        return (DataCachePCData) _cache.remove(key);\r\n+    }\r\n+\r\n+    protected void removeAllInternal(Class cls, boolean subs) {\r\n+        // we could keep a histogram of the counts of contained classes and\r\n+        // only clear if we have the class, but that still wouldn't support subs\r\n+        // well, would involve synching, and won't yield much benefit when we're\r\n+        // used as a primary cache\r\n+        _cache.clear();\r\n+    }\r\n+\r\n+    protected void clearInternal() {\r\n+        _cache.clear();\r\n+    }\r\n+\r\n+    protected boolean pinInternal(Object key) {\r\n+        return _cache.pin(key);\r\n+    }\r\n+\r\n+    protected boolean unpinInternal(Object key) {\r\n+        return _cache.unpin(key);\r\n+    }\r\n+}\r"},{"sha":"2af640388e76f750bb137678e9c10c91283096b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,133 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.util.CacheMap;\r\n+\r\n+/**\r\n+ * A {@link QueryCache} implementation that is optimized for concurrent\r\n+ * access. When the cache fill up, values to remove from the cache are chosen\r\n+ * randomly. Due to race conditions, it is possible that a get call might not\r\n+ * retur a cached instance if that instance is being transferred between\r\n+ * internal datastructures.\r\n+ *\r\n+ * @since 4.1\r\n+ */\r\n+public class ConcurrentQueryCache extends AbstractQueryCache\r\n+    implements RemoteCommitListener {\r\n+\r\n+    private CacheMap _cache = newCacheMap();\r\n+\r\n+    /**\r\n+     * Returns the underlying {@link CacheMap} that this cache is using.\r\n+     * This is not an unmodifiable view on the map, so care should be taken\r\n+     * with this reference. Implementations should probably not modify the\r\n+     * contents of the cache, but should only use this reference\r\n+     * to obtain cache metrics. Additionally, this map may contain\r\n+     * expired data. Removal of timed-out data is done in a lazy\r\n+     * fashion, so the actual size of the map may be greater than the\r\n+     * number of non-expired query results in cache.\r\n+     */\r\n+    public CacheMap getCacheMap() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the maximum number of unpinned objects to keep hard\r\n+     * references to.\r\n+     */\r\n+    public int getCacheSize() {\r\n+        return _cache.getCacheSize();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the maximum number of unpinned objects to keep hard\r\n+     * references to. If the map contains more unpinned objects than\r\n+     * <code>size</code>, then this method will result in the cache\r\n+     * flushing old values.\r\n+     */\r\n+    public void setCacheSize(int size) {\r\n+        _cache.setCacheSize(size);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the maximum number of unpinned objects to keep soft\r\n+     * references to. Defaults to <code>-1</code>.\r\n+     */\r\n+    public int getSoftReferenceSize() {\r\n+        return _cache.getSoftReferenceSize();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the maximum number of unpinned objects to keep soft\r\n+     * references to. If the map contains more soft references than\r\n+     * <code>size</code>, then this method will result in the cache\r\n+     * flushing values.\r\n+     */\r\n+    public synchronized void setSoftReferenceSize(int size) {\r\n+        _cache.setSoftReferenceSize(size);\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager mgr) {\r\n+        super.initialize(mgr);\r\n+        conf.getRemoteCommitEventManager().addListener(this);\r\n+    }\r\n+\r\n+    public void writeLock() {\r\n+        // delegate actually does nothing, but in case that changes...\r\n+        _cache.writeLock();\r\n+    }\r\n+\r\n+    public void writeUnlock() {\r\n+        // delegate actually does nothing, but in case that changes...\r\n+        _cache.writeUnlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the map to use as an internal cache.\r\n+     */\r\n+    protected CacheMap newCacheMap() {\r\n+        return new CacheMap();\r\n+    }\r\n+\r\n+    protected QueryResult getInternal(QueryKey qk) {\r\n+        return (QueryResult) _cache.get(qk);\r\n+    }\r\n+\r\n+    protected QueryResult putInternal(QueryKey qk, QueryResult result) {\r\n+        return (QueryResult) _cache.put(qk, result);\r\n+    }\r\n+\r\n+    protected QueryResult removeInternal(QueryKey qk) {\r\n+        return (QueryResult) _cache.remove(qk);\r\n+    }\r\n+\r\n+    protected void clearInternal() {\r\n+        _cache.clear();\r\n+    }\r\n+\r\n+    protected boolean pinInternal(QueryKey qk) {\r\n+        return _cache.pin(qk);\r\n+    }\r\n+\r\n+    protected boolean unpinInternal(QueryKey qk) {\r\n+        return _cache.unpin(qk);\r\n+    }\r\n+\r\n+    protected Collection keySet() {\r\n+        return _cache.keySet();\r\n+    }\r\n+}\r"},{"sha":"7b6fc59fb866bc46df6003d44f303f7731cbc6e3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","status":"added","additions":242,"deletions":0,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,242 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+\r\n+/**\r\n+ * Interface that must be implemented by any level 2 cache used by\r\n+ * OpenJPA. Most data caches will choose to implement the\r\n+ * {@link org.apache.openjpa.lib.conf.Configurable} interface as well so that\r\n+ * they will be given the system configuration just after construction.\r\n+ * Implementations should take care not to return timed out data.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @see AbstractDataCache\r\n+ * @see DataCachePCData#isTimedOut\r\n+ */\r\n+public interface DataCache extends Closeable {\r\n+\r\n+    /**\r\n+     * The name of the default data cache: <code>default</code>\r\n+     */\r\n+    public static final String NAME_DEFAULT = \"default\";\r\n+\r\n+    /**\r\n+     * Returns a string name that can be used by end-user-visible\r\n+     * code to identify this cache.\r\n+     *\r\n+     * @since 2.5.0\r\n+     */\r\n+    public String getName();\r\n+\r\n+    /**\r\n+     * Sets a string name to be used to identify this cache to end-user needs.\r\n+     *\r\n+     * @since 2.5.0\r\n+     */\r\n+    public void setName(String name);\r\n+\r\n+    /**\r\n+     * Initialize any resources associated with the given\r\n+     * {@link DataCacheManager}.\r\n+     */\r\n+    public void initialize(DataCacheManager manager);\r\n+\r\n+    /**\r\n+     * Perform a batch update of the cache. Add all {@link DataCachePCData}\r\n+     * objects in <code>additions</code> and in\r\n+     * <code>newUpdates</code>, make the appropriate modifications to\r\n+     * all DataCachePCDatas in <code>existingUpdates</code>, and delete all\r\n+     * OIDs in <code>deletes</code>.\r\n+     * All changes made to cached data must be made via this\r\n+     * method. It is this method that is responsible for performing\r\n+     * any side-effects that should happen on meaningful cache changes.\r\n+     * Implementations should bear in mind that the\r\n+     * <code>deletes</code> collection may contain oids that are also\r\n+     * in the <code>additions</code> map. This is possible because it\r\n+     * is valid for a user to delete an object with a particular oid\r\n+     * and then add that object in the same batch.\r\n+     *\r\n+     * @param additions       A collection of {@link DataCachePCData} objects.\r\n+     *                        These represent data that have been newly created,\r\n+     *                        and thus must be added to the cache.\r\n+     * @param newUpdates      A collection of {@link DataCachePCData} objects.\r\n+     *                        These represent data that have been modified but\r\n+     *                        were not originally in the cache, and thus must be added to the cache.\r\n+     * @param existingUpdates A collection of {@link DataCachePCData} objects.\r\n+     *                        These represent data that have been modified and\r\n+     *                        were originally loaded from the cache. It is\r\n+     *                        up to the cache implementation to decide if\r\n+     *                        these values must be re-enlisted in the cache.\r\n+     *                        Some caches may return live data from {@link #get}\r\n+     *                        invocations, in which case these values need not be re-enlisted.\r\n+     * @param deletes         A collection of object IDs that have been deleted\r\n+     *                        and must therefore be dropped from the cache.\r\n+     */\r\n+    public void commit(Collection additions, Collection newUpdates,\r\n+        Collection existingUpdates, Collection deletes);\r\n+\r\n+    /**\r\n+     * Returns <code>true</code> if this cache contains data\r\n+     * corresponding to <code>oid</code>; otherwise returns\r\n+     * <code>false</code>.\r\n+     */\r\n+    public boolean contains(Object oid);\r\n+\r\n+    /**\r\n+     * Returns the indexes of the oids in this cache.\r\n+     */\r\n+    public BitSet containsAll(Collection oids);\r\n+\r\n+    /**\r\n+     * Return the cached object for the given oid. Modifying the returned\r\n+     * object may or may not change the cached value; the {@link #update}\r\n+     * method should be used to re-cache any changed objects.\r\n+     *\r\n+     * @return the object matching the given oid, or null if none\r\n+     */\r\n+    public DataCachePCData get(Object oid);\r\n+\r\n+    /**\r\n+     * Set the cached value for the given instance. This does <em>not</em>\r\n+     * result in an update of other caches. Rather, it should only be\r\n+     * used for loading clean data into the cache. Meaningful changes\r\n+     * to the state of the cache should be made via the {@link #commit} method.\r\n+     *\r\n+     * @return The previously cached value, or <code>null</code> if\r\n+     *         the value was not previously cached. See {@link Map#put}\r\n+     *         for more information.\r\n+     */\r\n+    public DataCachePCData put(DataCachePCData value);\r\n+\r\n+    /**\r\n+     * Update the cached value for the given instance. This does\r\n+     * <em>not</em> result in an update of other caches. Rather, it should\r\n+     * only be used for loading clean data into the cache. Meaningful changes\r\n+     * to the state of the cache should be made via the {@link #commit} method.\r\n+     * A cache implementation may or may not return a live object\r\n+     * from {@link #get} invocations. If an object retrieved from a\r\n+     * {@link #get} operation needs to be updated, this method can be\r\n+     * invoked instead of invoking {@link #put}. The DataCache implementation\r\n+     * can then make optimizations based on how its {@link #get} method works.\r\n+     */\r\n+    public void update(DataCachePCData value);\r\n+\r\n+    /**\r\n+     * Remove the value stored under the given oid. This does\r\n+     * <em>not</em> result in an update of other caches. Rather, it\r\n+     * should only be used for removing data in the cache.\r\n+     * Meaningful changes to the state of the cache should be made\r\n+     * via the {@link #commit} method.\r\n+     *\r\n+     * @return The previously cached value, or <code>null</code> if\r\n+     *         the oid was not previously cached. See {@link Map#remove}\r\n+     *         for more information.\r\n+     */\r\n+    public DataCachePCData remove(Object oid);\r\n+\r\n+    /**\r\n+     * Remove the values stored under the given oids.\r\n+     *\r\n+     * @return the indexes of the removed oids\r\n+     * @see #remove\r\n+     */\r\n+    public BitSet removeAll(Collection oids);\r\n+\r\n+    /**\r\n+     * Evict all values of a specified type.\r\n+     */\r\n+    public void removeAll(Class cls, boolean subclasses);\r\n+\r\n+    /**\r\n+     * Remove all data from this cache. This does <em>not</em> result\r\n+     * in an update of other caches. Rather, it should only be used\r\n+     * for clearing the cache. Meaningful changes to the state of the\r\n+     * cache should be made via the {@link #commit} method.\r\n+     */\r\n+    public void clear();\r\n+\r\n+    /**\r\n+     * Pin the value stored under <code>oid</code> into the cache.\r\n+     * This method guarantees that <code>oid</code>'s value will not\r\n+     * be dropped by the caching algorithm. This method does not\r\n+     * affect the behavior of {@link #remove}.\r\n+     *\r\n+     * @return <code>true</code> if <code>oid</code>'s value was\r\n+     *         pinned into the cache; <code>false</code> if the oid is not in the cache.\r\n+     */\r\n+    public boolean pin(Object oid);\r\n+\r\n+    /**\r\n+     * Pin all oids to the cache.\r\n+     *\r\n+     * @return the indexes of the pinned oids\r\n+     * @see #pin\r\n+     */\r\n+    public BitSet pinAll(Collection oids);\r\n+\r\n+    /**\r\n+     * Unpin the value stored under <code>oid</code> from the cache.\r\n+     * This method reverses a previous invocation of {@link #pin}.\r\n+     * This method does not remove anything from the cache; it merely\r\n+     * makes <code>oid</code>'s value a candidate for flushing from the cache.\r\n+     *\r\n+     * @return <code>true</code> if <code>oid</code>'s value was\r\n+     *         unpinned from the cache; <code>false</code> if the\r\n+     *         oid is not in the cache.\r\n+     */\r\n+    public boolean unpin(Object oid);\r\n+\r\n+    /**\r\n+     * Unpin all oids from the cache.\r\n+     *\r\n+     * @return the indexes of the unpinned oids\r\n+     * @see #unpin\r\n+     */\r\n+    public BitSet unpinAll(Collection oids);\r\n+\r\n+    /**\r\n+     * Obtain a write lock on the cache.\r\n+     */\r\n+    public void writeLock();\r\n+\r\n+    /**\r\n+     * Release the write lock on the cache.\r\n+     */\r\n+    public void writeUnlock();\r\n+\r\n+    /**\r\n+     * Add a new expiration event listener to this cache.\r\n+     *\r\n+     * @since 2.5.0\r\n+     */\r\n+    public void addExpirationListener(ExpirationListener listen);\r\n+\r\n+    /**\r\n+     * Remove an expiration event listener from this cache.\r\n+     *\r\n+     * @since 2.5.0\r\n+     */\r\n+    public boolean removeExpirationListener(ExpirationListener listen);\r\n+\r\n+    /**\r\n+     * Free the resources used by this cache.\r\n+     */\r\n+    public void close();\r\n+}\r"},{"sha":"3d0f2ff3ff335e8291868b0e3148749c592353de","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,71 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.conf.ObjectValue;\r\n+\r\n+/**\r\n+ * Manages the system's data and query caches. You can\r\n+ * retrieve the data cache manager from the {@link OpenJPAConfiguration}.\r\n+ *\r\n+ * @author Abe White\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public interface DataCacheManager {\r\n+\r\n+    /**\r\n+     * Initialize the manager, supplying the cache configuration.\r\n+     */\r\n+    public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\r\n+        ObjectValue queryCache);\r\n+\r\n+    /**\r\n+     * Return the system-wide data cache, or null if caching is not enabled.\r\n+     */\r\n+    public DataCache getSystemDataCache();\r\n+\r\n+    /**\r\n+     * Return the named data cache, or null if it does not exist.\r\n+     */\r\n+    public DataCache getDataCache(String name);\r\n+\r\n+    /**\r\n+     * Return the named data cache. If the given name is null, the default\r\n+     * data cache is returned.\r\n+     *\r\n+     * @param create if true, the cache will be created if it does\r\n+     *               not already exist\r\n+     */\r\n+    public DataCache getDataCache(String name, boolean create);\r\n+\r\n+    /**\r\n+     * Return the system query cache, or null if not configured.\r\n+     */\r\n+    public QueryCache getSystemQueryCache();\r\n+\r\n+    /**\r\n+     * Return the PCData generator if configured.\r\n+     */\r\n+    public DataCachePCDataGenerator getPCDataGenerator();\r\n+\r\n+    /**\r\n+     * Return the runnable which schedules evictions.\r\n+     */\r\n+    public DataCacheScheduler getDataCacheScheduler();\r\n+\r\n+    /**\r\n+     * Close all caches.\r\n+     */\r\n+    public void close();\r\n+}\r"},{"sha":"c0ff82817c78f523009505f647c0746154a22a33","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,81 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.conf.ObjectValue;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * Default data cache manager.\r\n+ *\r\n+ * @author Abe White\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public class DataCacheManagerImpl implements Closeable, DataCacheManager {\r\n+\r\n+    private DataCache _cache = null;\r\n+    private QueryCache _queryCache = null;\r\n+    private DataCachePCDataGenerator _pcGenerator = null;\r\n+    private DataCacheScheduler _scheduler = null;\r\n+\r\n+    public void initialize(OpenJPAConfiguration conf, ObjectValue dataCache,\r\n+        ObjectValue queryCache) {\r\n+        _cache = (DataCache) dataCache.instantiate(DataCache.class, conf);\r\n+        if (_cache == null)\r\n+            return;\r\n+        // create helpers before initializing caches\r\n+        if (conf.getDynamicDataStructs())\r\n+            _pcGenerator = new DataCachePCDataGenerator(conf);\r\n+        _scheduler = new DataCacheScheduler(conf);\r\n+        _cache.initialize(this);\r\n+        _queryCache = (QueryCache) queryCache.instantiate(QueryCache.class,\r\n+            conf);\r\n+        if (_queryCache != null)\r\n+            _queryCache.initialize(this);\r\n+    }\r\n+\r\n+    public DataCache getSystemDataCache() {\r\n+        return getDataCache(null, false);\r\n+    }\r\n+\r\n+    public DataCache getDataCache(String name) {\r\n+        return getDataCache(name, false);\r\n+    }\r\n+\r\n+    public DataCache getDataCache(String name, boolean create) {\r\n+        if (name == null || (_cache != null && name.equals(_cache.getName())))\r\n+            return _cache;\r\n+        return null;\r\n+    }\r\n+\r\n+    public QueryCache getSystemQueryCache() {\r\n+        return _queryCache;\r\n+    }\r\n+\r\n+    public DataCachePCDataGenerator getPCDataGenerator() {\r\n+        return _pcGenerator;\r\n+    }\r\n+\r\n+    public DataCacheScheduler getDataCacheScheduler() {\r\n+        return _scheduler;\r\n+    }\r\n+\r\n+    public void close() {\r\n+        ImplHelper.close(_cache);\r\n+        ImplHelper.close(_queryCache);\r\n+        if (_scheduler != null)\r\n+            _scheduler.stop();\r\n+    }\r\n+}\r"},{"sha":"0d4213b1bddc9412e8da853cd592761d793d7c6c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,28 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import org.apache.openjpa.kernel.PCData;\r\n+\r\n+/**\r\n+ * Specialized {@link PCData} implementation for data caching.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public interface DataCachePCData extends PCData {\r\n+\r\n+    /**\r\n+     * Whether this data is timed out.\r\n+     */\r\n+    public boolean isTimedOut();\r\n+}\r"},{"sha":"91be27ee53700eb185ac3ae6a8fad05ac7d4674b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","status":"added","additions":216,"deletions":0,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,216 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.enhance.PCDataGenerator;\r\n+import org.apache.openjpa.kernel.AbstractPCData;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCField;\r\n+import serp.bytecode.BCMethod;\r\n+import serp.bytecode.Code;\r\n+import serp.bytecode.Instruction;\r\n+import serp.bytecode.JumpInstruction;\r\n+\r\n+/**\r\n+ * A {@link PCDataGenerator} instance which generates properly\r\n+ * synchronized instances suitable for use in the cache. In addition,\r\n+ * proper timed behavior is added.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @since 3.3.0\r\n+ */\r\n+public class DataCachePCDataGenerator extends PCDataGenerator {\r\n+\r\n+    public static final String POSTFIX = \"datacache\";\r\n+    private static final Set _synchs = new HashSet(Arrays.asList\r\n+        (new String []{ \"getData\", \"setData\", \"clearData\", \"getImplData\",\r\n+            \"setImplData\", \"setIntermediate\", \"getIntermediate\",\r\n+            \"isLoaded\", \"setLoaded\", \"setVersion\", \"getVersion\", \"store\" }));\r\n+\r\n+    public DataCachePCDataGenerator(OpenJPAConfiguration conf) {\r\n+        super(conf);\r\n+    }\r\n+\r\n+    protected String getUniqueName(Class type) {\r\n+        return super.getUniqueName(type) + POSTFIX;\r\n+    }\r\n+\r\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n+        int timeout = meta.getDataCacheTimeout();\r\n+        if (timeout > 0)\r\n+            ((Timed) data).setTimeout(timeout + System.currentTimeMillis());\r\n+        else ((Timed) data).setTimeout(-1);\r\n+    }\r\n+\r\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n+        enhanceToData(bc);\r\n+        enhanceToNestedData(bc);\r\n+        replaceToEmbeddedData(bc);\r\n+        addSynchronization(bc);\r\n+        addTimeout(bc);\r\n+    }\r\n+\r\n+    private void enhanceToData(BCClass bc) {\r\n+        BCMethod meth = bc.declareMethod(\"toData\", Object.class,\r\n+            new Class []{ FieldMetaData.class, Object.class });\r\n+        Code code = meth.getCode(true);\r\n+        // if (fmd.isLRS()))\r\n+        // return NULL;\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(FieldMetaData.class, \"isLRS\",\r\n+            boolean.class, null);\r\n+        JumpInstruction ifins = code.ifeq();\r\n+        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\r\n+        code.areturn();\r\n+        // super.toData(fmd, val);\r\n+        ifins.setTarget(code.aload().setThis());\r\n+        code.aload().setParam(0);\r\n+        code.aload().setParam(1);\r\n+        code.invokespecial().setMethod(AbstractPCData.class, \"toData\",\r\n+            Object.class, new Class[]{ FieldMetaData.class, Object.class });\r\n+        code.areturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void enhanceToNestedData(BCClass bc) {\r\n+        BCMethod meth = bc.declareMethod(\"toNestedData\", Object.class,\r\n+            new Class []{ ValueMetaData.class, Object.class });\r\n+        Code code = meth.getCode(true);\r\n+        // if (val == null)\r\n+        // return null;\r\n+        code.aload().setParam(1);\r\n+        JumpInstruction ifins = code.ifnonnull();\r\n+        code.constant().setNull();\r\n+        code.areturn();\r\n+        // int type = vmd.getDeclaredTypeCode();\r\n+        ifins.setTarget(code.aload().setParam(0));\r\n+        code.invokeinterface().setMethod(ValueMetaData.class,\r\n+            \"getDeclaredTypeCode\", int.class, null);\r\n+        int local = code.getNextLocalsIndex();\r\n+        code.istore().setLocal(local);\r\n+        // if (type != JavaTypes.COLLECTION &&\r\n+        //    type != JavaTypes.MAP &&\r\n+        //    type != JavaTypes.ARRAY)\r\n+        //    return super.toNestedData(type, val, embedded);\r\n+        // else\r\n+        // return NULL;\r\n+        Collection jumps = new ArrayList(3);\r\n+        code.iload().setLocal(local);\r\n+        code.constant().setValue(JavaTypes.COLLECTION);\r\n+        jumps.add(code.ificmpeq());\r\n+        code.iload().setLocal(local);\r\n+        code.constant().setValue(JavaTypes.MAP);\r\n+        jumps.add(code.ificmpeq());\r\n+        code.iload().setLocal(local);\r\n+        code.constant().setValue(JavaTypes.ARRAY);\r\n+        jumps.add(code.ificmpeq());\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.aload().setParam(1);\r\n+        code.invokespecial().setMethod(AbstractPCData.class, \"toNestedData\",\r\n+            Object.class, new Class[]{ ValueMetaData.class, Object.class });\r\n+        code.areturn();\r\n+        setTarget(code.getstatic().setField\r\n+            (AbstractPCData.class, \"NULL\", Object.class), jumps);\r\n+        code.areturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void replaceToEmbeddedData(BCClass bc) {\r\n+        BCMethod meth = bc.declareMethod(\"toEmbeddedData\", Object.class,\r\n+            new Class[]{ Object.class });\r\n+        Code code = meth.getCode(true);\r\n+        code.getstatic().setField(AbstractPCData.class, \"NULL\", Object.class);\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    private void addTimeout(BCClass bc) {\r\n+        bc.declareInterface(DataCachePCData.class);\r\n+        bc.declareInterface(Timed.class);\r\n+        // public boolean isTimedOut();\r\n+        BCField field = addBeanField(bc, \"timeout\", long.class);\r\n+        BCMethod meth = bc.declareMethod(\"isTimedOut\", boolean.class, null);\r\n+        Code code = meth.getCode(true);\r\n+        // if (timeout == -1) ...\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(field);\r\n+        code.constant().setValue(-1L);\r\n+        code.lcmp();\r\n+        JumpInstruction ifneg = code.ifeq();\r\n+        // if (timeout >= System.currentTimeMillis())\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(field);\r\n+        code.invokestatic().setMethod(System.class, \"currentTimeMillis\",\r\n+            long.class, null);\r\n+        code.lcmp();\r\n+        JumpInstruction ifnexp = code.ifge();\r\n+        // return true;\r\n+        code.constant().setValue(1);\r\n+        // ... else return false;\r\n+        JumpInstruction go2 = code.go2();\r\n+        Instruction flse = code.constant().setValue(0);\r\n+        ifneg.setTarget(flse);\r\n+        ifnexp.setTarget(flse);\r\n+        go2.setTarget(code.ireturn());\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void addSynchronization(BCClass bc) {\r\n+        BCMethod[] methods = bc.getDeclaredMethods();\r\n+        for (int i = 0; i < methods.length; i++) {\r\n+            if (methods[i].isPublic()\r\n+                && _synchs.contains(methods[i].getName()))\r\n+                methods[i].setSynchronized(true);\r\n+        }\r\n+        // add synchronized isLoaded call.\r\n+        // public synchronized boolean isLoaded(int field)\r\n+        // {\r\n+        // return super.isLoaded(field);\r\n+        // }\r\n+        BCMethod method = bc.declareMethod(\"isLoaded\", boolean.class,\r\n+            new Class[]{ int.class });\r\n+        method.setSynchronized(true);\r\n+        Code code = method.getCode(true);\r\n+        code.aload().setThis();\r\n+        code.iload().setParam(0);\r\n+        code.invokespecial().setMethod(AbstractPCData.class, \"isLoaded\",\r\n+            boolean.class, new Class[]{ int.class });\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+        code.ireturn();\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple interface to give access to expiration time.\r\n+     */\r\n+    public static interface Timed {\r\n+\r\n+        public void setTimeout(long time);\r\n+    }\r\n+}\r"},{"sha":"9cacfc66d977b7f07d3d363505f88a29ed6882a2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,137 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.BitSet;\r\n+\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCData;\r\n+import org.apache.openjpa.kernel.PCDataImpl;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+\r\n+/**\r\n+ * Specialized {@link PCData} implementation for data caching. This\r\n+ * implementation is properly synchronized.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public class DataCachePCDataImpl extends PCDataImpl implements DataCachePCData {\r\n+\r\n+    private final long _exp;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     */\r\n+    public DataCachePCDataImpl(Object oid, ClassMetaData meta) {\r\n+        super(oid, meta);\r\n+        int timeout = meta.getDataCacheTimeout();\r\n+        if (timeout > 0)\r\n+            _exp = System.currentTimeMillis() + timeout;\r\n+        else _exp = -1;\r\n+    }\r\n+\r\n+    public boolean isTimedOut() {\r\n+        return _exp != -1 && _exp < System.currentTimeMillis();\r\n+    }\r\n+\r\n+    public synchronized Object getData(int index) {\r\n+        return super.getData(index);\r\n+    }\r\n+\r\n+    public synchronized void setData(int index, Object val) {\r\n+        super.setData(index, val);\r\n+    }\r\n+\r\n+    public synchronized void clearData(int index) {\r\n+        super.clearData(index);\r\n+    }\r\n+\r\n+    public synchronized Object getImplData() {\r\n+        return super.getImplData();\r\n+    }\r\n+\r\n+    public synchronized void setImplData(Object val) {\r\n+        super.setImplData(val);\r\n+    }\r\n+\r\n+    public synchronized Object getImplData(int index) {\r\n+        return super.getImplData(index);\r\n+    }\r\n+\r\n+    public synchronized void setImplData(int index, Object val) {\r\n+        super.setImplData(index, val);\r\n+    }\r\n+\r\n+    public synchronized Object getIntermediate(int index) {\r\n+        return super.getIntermediate(index);\r\n+    }\r\n+\r\n+    public synchronized void setIntermediate(int index, Object val) {\r\n+        super.setIntermediate(index, val);\r\n+    }\r\n+\r\n+    public synchronized boolean isLoaded(int index) {\r\n+        return super.isLoaded(index);\r\n+    }\r\n+\r\n+    public synchronized void setLoaded(int index, boolean loaded) {\r\n+        super.setLoaded(index, loaded);\r\n+    }\r\n+\r\n+    public synchronized Object getVersion() {\r\n+        return super.getVersion();\r\n+    }\r\n+\r\n+    public synchronized void setVersion(Object version) {\r\n+        super.setVersion(version);\r\n+    }\r\n+\r\n+    public synchronized void store(OpenJPAStateManager sm) {\r\n+        super.store(sm);\r\n+    }\r\n+\r\n+    public synchronized void store(OpenJPAStateManager sm, BitSet fields) {\r\n+        super.store(sm, fields);\r\n+    }\r\n+\r\n+    protected Object toData(FieldMetaData fmd, Object val, StoreContext ctx) {\r\n+        // avoid caching large result set fields\r\n+        if (fmd.isLRS())\r\n+            return NULL;\r\n+        return super.toData(fmd, val, ctx);\r\n+    }\r\n+\r\n+    protected Object toNestedData(ValueMetaData vmd, Object val,\r\n+        StoreContext ctx) {\r\n+        if (val == null)\r\n+            return null;\r\n+        // don't try to cache nested containers\r\n+        switch (vmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.COLLECTION:\r\n+            case JavaTypes.MAP:\r\n+            case JavaTypes.ARRAY:\r\n+                return NULL;\r\n+            default:\r\n+                return super.toNestedData(vmd, val, ctx);\r\n+        }\r\n+    }\r\n+\r\n+    protected Object toEmbeddedData(Object val) {\r\n+        // don't try to cache embedded pcs until we do some testing\r\n+        return NULL;\r\n+    }\r\n+}\r"},{"sha":"ec8ae5806af270f243844fdbbe055deb81f18907","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,226 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.text.DateFormat;\r\n+import java.text.SimpleDateFormat;\r\n+import java.util.Calendar;\r\n+import java.util.Date;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+import org.apache.openjpa.util.UserException;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Cron-style cache eviction. Understands schedules based on cron format:\r\n+ * <code>minute hour mday month wday</code>\r\n+ * For example:\r\n+ * <code>15,30 6,19 2,10 1 2 </code>\r\n+ * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n+ * of January when its a Monday.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public class DataCacheScheduler implements Runnable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (DataCacheScheduler.class);\r\n+    private static final DateFormat _fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n+    private Map _caches = new ConcurrentHashMap();\r\n+    private boolean _stop = false;\r\n+    private int _interval = 2;\r\n+    private Log _log;\r\n+    private Thread _thread;\r\n+\r\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    /**\r\n+     * The interval time in minutes between cache checks. Defaults to 2.\r\n+     */\r\n+    public int getInterval() {\r\n+        return _interval;\r\n+    }\r\n+\r\n+    /**\r\n+     * The interval time in minutes between cache checks. Defaults to 2.\r\n+     */\r\n+    public void setInterval(int interval) {\r\n+        _interval = interval;\r\n+    }\r\n+\r\n+    /**\r\n+     * Stop the associated thread if there and stop the current runnable.\r\n+     */\r\n+    public synchronized void stop() {\r\n+        _stop = true;\r\n+    }\r\n+\r\n+    private boolean isStopped() {\r\n+        return _stop;\r\n+    }\r\n+\r\n+    /**\r\n+     * Schedule the given cache for eviction. Starts the scheduling thread\r\n+     * if not started.\r\n+     */\r\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n+        if (times == null)\r\n+            return;\r\n+        Schedule schedule = new Schedule(times);\r\n+        _caches.put(cache, schedule);\r\n+        _stop = false;\r\n+        if (_thread == null) {\r\n+            _thread = new Thread(this, _loc.get(\"scheduler-name\"));\r\n+            _thread.start();\r\n+            if (_log.isTraceEnabled())\r\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given cache from scheduling.\r\n+     */\r\n+    public synchronized void removeFromSchedule(DataCache cache) {\r\n+        _caches.remove(cache);\r\n+        if (_caches.size() == 0)\r\n+            stop();\r\n+    }\r\n+\r\n+    public void run() {\r\n+        if (_log.isTraceEnabled())\r\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n+        Date lastRun = new Date();\r\n+        while (!isStopped()) {\r\n+            try {\r\n+                Thread.sleep(_interval * 60 * 1000);\r\n+                Date now = new Date();\r\n+                DataCache cache;\r\n+                Schedule schedule;\r\n+                Map.Entry entry;\r\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n+                    entry = (Map.Entry) i.next();\r\n+                    cache = (DataCache) entry.getKey();\r\n+                    schedule = (Schedule) entry.getValue();\r\n+                    if (schedule.matches(lastRun, now)) {\r\n+                        if (_log.isTraceEnabled())\r\n+                            _log.trace(_loc.get(\"scheduler-clear\",\r\n+                                cache.getName(), _fom.format(now)));\r\n+                        evict(cache);\r\n+                    }\r\n+                }\r\n+                lastRun = now;\r\n+            } catch (Exception e) {\r\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n+                    setFatal(true);\r\n+            }\r\n+        }\r\n+        _log.info(_loc.get(\"scheduler-stop\"));\r\n+        synchronized (this) {\r\n+            if (isStopped())\r\n+                _thread = null; // be sure to deref the thread so it can restart\r\n+        }\r\n+    }\r\n+\r\n+    protected void evict(DataCache cache) {\r\n+        cache.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple class which represents the given time schedule.\r\n+     */\r\n+    private static class Schedule {\r\n+\r\n+        static final int[] WILDCARD = new int[0];\r\n+        static final int[] UNITS = {\r\n+            Calendar.MONTH, Calendar.DAY_OF_MONTH, Calendar.DAY_OF_WEEK,\r\n+            Calendar.HOUR_OF_DAY, Calendar.MINUTE };\r\n+        final int[] month;\r\n+        final int[] dayOfMonth;\r\n+        final int[] dayOfWeek;\r\n+        final int[] hour;\r\n+        final int[] min;\r\n+\r\n+        public Schedule(String date) {\r\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n+            if (token.countTokens() != 5)\r\n+                throw new UserException(_loc.get(\"bad-count\", date)).\r\n+                    setFatal(true);\r\n+            try {\r\n+                min = parse(token.nextToken(), 0, 60);\r\n+                hour = parse(token.nextToken(), 0, 24);\r\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n+                month = parse(token.nextToken(), 1, 13);\r\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n+            } catch (Throwable t) {\r\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n+                    setFatal(true);\r\n+            }\r\n+        }\r\n+\r\n+        private int[] parse(String token, int min, int max) {\r\n+            if (token.trim().equals(\"*\"))\r\n+                return WILDCARD;\r\n+            String[] tokens = Strings.split(token, \",\", 0);\r\n+            int [] times = new int[tokens.length];\r\n+            for (int i = 0; i < tokens.length; i++) {\r\n+                try {\r\n+                    times[i] = Integer.parseInt(tokens[i]);\r\n+                } catch (Throwable t) {\r\n+                    throw new UserException(_loc.get(\"not-number\", token)).\r\n+                        setFatal(true);\r\n+                }\r\n+                if (times[i] < min || times[i] >= max)\r\n+                    throw new UserException(_loc.get(\"not-range\", token,\r\n+                        String.valueOf(min), String.valueOf(max))).\r\n+                        setFatal(true);\r\n+            }\r\n+            return times;\r\n+        }\r\n+\r\n+        boolean matches(Date last, Date now) {\r\n+            Calendar time = Calendar.getInstance();\r\n+            time.setTime(now);\r\n+            time.set(Calendar.SECOND, 0);\r\n+            time.set(Calendar.MILLISECOND, 0);\r\n+            int[][] all =\r\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n+            return matches(last, now, time, all, 0);\r\n+        }\r\n+\r\n+        private boolean matches(Date last, Date now, Calendar time,\r\n+            int[][] times, int depth) {\r\n+            if (depth == UNITS.length) {\r\n+                Date compare = time.getTime();\r\n+                return compare.compareTo(last) >= 0 &&\r\n+                    compare.compareTo(now) < 0;\r\n+            }\r\n+            if (times[depth] != WILDCARD) {\r\n+                for (int i = 0; i < times[depth].length; i++) {\r\n+                    time.set(UNITS[depth], times[depth][i]);\r\n+                    if (matches(last, now, time, times, depth + 1))\r\n+                        return true;\r\n+                }\r\n+            }\r\n+            return matches(last, now, time, times, depth + 1);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"f3c6597d006fa3bf59ceac42af105b9ced025ca2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"added","additions":563,"deletions":0,"changes":563,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,563 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.ListIterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.enhance.PCDataGenerator;\r\n+import org.apache.openjpa.kernel.DelegatingStoreManager;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchState;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCState;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+\r\n+/**\r\n+ * StoreManager proxy that delegates to a data cache when possible.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @nojavadoc\r\n+ */\r\n+public class DataCacheStoreManager extends DelegatingStoreManager {\r\n+\r\n+    // all the state managers changed in this transaction\r\n+    private Collection _inserts = null; // statemanagers\r\n+    private Map _updates = null; // statemanager -> fmd set\r\n+    private Collection _deletes = null; // statemanagers\r\n+    // the owning context\r\n+    private StoreContext _ctx = null;\r\n+    // pc data generator\r\n+    private PCDataGenerator _gen = null;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param sm the store manager to delegate to\r\n+     */\r\n+    public DataCacheStoreManager(StoreManager sm) {\r\n+        super(sm);\r\n+    }\r\n+\r\n+    public void setContext(StoreContext ctx) {\r\n+        _ctx = ctx;\r\n+        _gen = ctx.getConfiguration().getDataCacheManagerInstance().\r\n+            getPCDataGenerator();\r\n+        super.setContext(ctx);\r\n+    }\r\n+\r\n+    public void begin() {\r\n+        super.begin();\r\n+    }\r\n+\r\n+    public void commit() {\r\n+        try {\r\n+            super.commit();\r\n+            updateCaches();\r\n+        }\r\n+        finally {\r\n+            _inserts = null;\r\n+            _updates = null;\r\n+            _deletes = null;\r\n+        }\r\n+    }\r\n+\r\n+    public void rollback() {\r\n+        try {\r\n+            super.rollback();\r\n+        }\r\n+        finally {\r\n+            _inserts = null;\r\n+            _updates = null;\r\n+            _deletes = null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Evict all members of the given classes.\r\n+     */\r\n+    private void evictTypes(Collection classes) {\r\n+        if (classes.isEmpty())\r\n+            return;\r\n+        MetaDataRepository mdr =\r\n+            _ctx.getConfiguration(). getMetaDataRepository();\r\n+        ClassLoader loader = _ctx.getClassLoader();\r\n+        Class cls;\r\n+        DataCache cache;\r\n+        for (Iterator itr = classes.iterator(); itr.hasNext();) {\r\n+            cls = (Class) itr.next();\r\n+            cache = mdr.getMetaData(cls, loader, false).getDataCache();\r\n+            if (cache != null)\r\n+                cache.removeAll(cls, false);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Update all caches with the committed inserts, updates, and deletes.\r\n+     */\r\n+    private void updateCaches() {\r\n+        // map each data cache to the modifications we need to perform\r\n+        Map modMap = null;\r\n+        Modifications mods;\r\n+        OpenJPAStateManager sm;\r\n+        DataCachePCData data;\r\n+        DataCache cache;\r\n+        // create pc datas for inserts\r\n+        if (_ctx.getPopulateDataCache() && _inserts != null) {\r\n+            for (Iterator itr = _inserts.iterator(); itr.hasNext();) {\r\n+                sm = (OpenJPAStateManager) itr.next();\r\n+                cache = sm.getMetaData().getDataCache();\r\n+                if (cache == null)\r\n+                    continue;\r\n+                if (modMap == null)\r\n+                    modMap = new HashMap();\r\n+                mods = getModifications(modMap, cache);\r\n+                data = newPCData(sm);\r\n+                data.store(sm);\r\n+                mods.additions.add(new PCDataHolder(data, sm));\r\n+            }\r\n+        }\r\n+        // update pcdatas for updates\r\n+        Map.Entry entry;\r\n+        if (_updates != null) {\r\n+            BitSet fields;\r\n+            for (Iterator itr = _updates.entrySet().iterator();\r\n+                itr.hasNext();) {\r\n+                entry = (Map.Entry) itr.next();\r\n+                sm = (OpenJPAStateManager) entry.getKey();\r\n+                fields = (BitSet) entry.getValue();\r\n+                cache = sm.getMetaData().getDataCache();\r\n+                if (cache == null)\r\n+                    continue;\r\n+                // it's ok not to clone the object that we get from the cache,\r\n+                // since we're inside the commit() method, so any modifications\r\n+                // to the underlying cache are valid. If the commit had not\r\n+                // already succeeded, then we'd want to clone the retrieved\r\n+                // object.\r\n+                if (modMap == null)\r\n+                    modMap = new HashMap();\r\n+                data = cache.get(sm.getObjectId());\r\n+                mods = getModifications(modMap, cache);\r\n+                // data should always be non-null, since the object is\r\n+                // dirty, but maybe it got dropped from the cache in the\r\n+                // interim\r\n+                if (data == null) {\r\n+                    data = newPCData(sm);\r\n+                    data.store(sm);\r\n+                    mods.newUpdates.add(new PCDataHolder(data, sm));\r\n+                } else {\r\n+                    data.store(sm, fields);\r\n+                    mods.existingUpdates.add(new PCDataHolder(data, sm));\r\n+                }\r\n+            }\r\n+        }\r\n+        // remove pcdatas for deletes\r\n+        if (_deletes != null) {\r\n+            for (Iterator itr = _deletes.iterator(); itr.hasNext();) {\r\n+                sm = (OpenJPAStateManager) itr.next();\r\n+                cache = sm.getMetaData().getDataCache();\r\n+                if (cache == null)\r\n+                    continue;\r\n+                if (modMap == null)\r\n+                    modMap = new HashMap();\r\n+                mods = getModifications(modMap, cache);\r\n+                mods.deletes.add(sm.getObjectId());\r\n+            }\r\n+        }\r\n+        // notify the caches of the changes\r\n+        if (modMap != null) {\r\n+            for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\r\n+                entry = (Map.Entry) itr.next();\r\n+                cache = (DataCache) entry.getKey();\r\n+                mods = (Modifications) entry.getValue();\r\n+                // make sure we're not caching old versions\r\n+                cache.writeLock();\r\n+                try {\r\n+                    transformToVersionSafePCDatas(cache, mods.additions);\r\n+                    transformToVersionSafePCDatas(cache, mods.newUpdates);\r\n+                    transformToVersionSafePCDatas(cache, mods.existingUpdates);\r\n+                    cache.commit(mods.additions, mods.newUpdates,\r\n+                        mods.existingUpdates, mods.deletes);\r\n+                }\r\n+                finally {\r\n+                    cache.writeUnlock();\r\n+                }\r\n+            }\r\n+        }\r\n+        // if we were in largeTransaction mode, then we have recorded\r\n+        // the classes of updated/deleted objects and these now need to be\r\n+        // evicted\r\n+        if (_ctx.isLargeTransaction()) {\r\n+            evictTypes(_ctx.getDeletedTypes());\r\n+            evictTypes(_ctx.getUpdatedTypes());\r\n+        }\r\n+        // and notify the query cache.  notify in one batch to reduce synch\r\n+        QueryCache queryCache = _ctx.getConfiguration().\r\n+            getDataCacheManagerInstance().getSystemQueryCache();\r\n+        if (queryCache != null) {\r\n+            Collection pers = _ctx.getPersistedTypes();\r\n+            Collection del = _ctx.getDeletedTypes();\r\n+            Collection up = _ctx.getUpdatedTypes();\r\n+            int size = pers.size() + del.size() + up.size();\r\n+            if (size > 0) {\r\n+                Collection types = new ArrayList(size);\r\n+                types.addAll(pers);\r\n+                types.addAll(del);\r\n+                types.addAll(up);\r\n+                queryCache.onTypesChanged(new TypesChangedEvent(this, types));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Transforms a collection of {@link PCDataHolder}s that might contain\r\n+     * stale instances into a collection of up-to-date {@link DataCachePCData}s.\r\n+     */\r\n+    private void transformToVersionSafePCDatas(DataCache cache, List holders) {\r\n+        PCDataHolder holder;\r\n+        DataCachePCData oldpc;\r\n+        for (ListIterator iter = holders.listIterator(); iter.hasNext();) {\r\n+            holder = (PCDataHolder) iter.next();\r\n+            oldpc = cache.get(holder.sm.getObjectId());\r\n+            if (oldpc != null && compareVersion(holder.sm,\r\n+                holder.sm.getVersion(), oldpc.getVersion()) == VERSION_EARLIER)\r\n+                iter.remove();\r\n+            else iter.set(holder.pcdata);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a {@link Modifications} instance to track modifications\r\n+     * to the given cache, creating and caching the instance if it does\r\n+     * not already exist in the given map.\r\n+     */\r\n+    private static Modifications getModifications(Map modMap, DataCache cache) {\r\n+        Modifications mods = (Modifications) modMap.get(cache);\r\n+        if (mods == null) {\r\n+            mods = new Modifications();\r\n+            modMap.put(cache, mods);\r\n+        }\r\n+        return mods;\r\n+    }\r\n+\r\n+    public boolean exists(OpenJPAStateManager sm, Object edata) {\r\n+        DataCache cache = sm.getMetaData().getDataCache();\r\n+        if (cache != null && !isLocking(null)\r\n+            && cache.contains(sm.getObjectId()))\r\n+            return true;\r\n+        return super.exists(sm, edata);\r\n+    }\r\n+\r\n+    public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\r\n+        DataCache cache = sm.getMetaData().getDataCache();\r\n+        if (cache == null || sm.isEmbedded())\r\n+            return super.syncVersion(sm, edata);\r\n+        DataCachePCData data;\r\n+        Object version = null;\r\n+        data = cache.get(sm.getObjectId());\r\n+        if (!isLocking(null) && data != null)\r\n+            version = data.getVersion();\r\n+        // if we have a cached version update from there\r\n+        if (version != null) {\r\n+            if (!version.equals(sm.getVersion())) {\r\n+                sm.setVersion(version);\r\n+                return false;\r\n+            }\r\n+            return true;\r\n+        }\r\n+        // use data store version\r\n+        return super.syncVersion(sm, edata);\r\n+    }\r\n+\r\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\r\n+        FetchState fetchState, Object edata) {\r\n+        DataCache cache = sm.getMetaData().getDataCache();\r\n+        if (cache == null || sm.isEmbedded())\r\n+            return super.initialize(sm, state, fetchState, edata);\r\n+        DataCachePCData data = cache.get(sm.getObjectId());\r\n+        FetchConfiguration fetch = (fetchState == null)\r\n+            ? _ctx.getFetchConfiguration()\r\n+            : fetchState.getFetchConfiguration();\r\n+        if (data != null && !isLocking(fetch)) {\r\n+            //### the 'data.type' access here probably needs to be\r\n+            //### addressed for bug 511\r\n+            sm.initialize(data.getType(), state);\r\n+            data.load(sm, fetchState, edata);\r\n+            return true;\r\n+        }\r\n+        // initialize from store manager\r\n+        if (!super.initialize(sm, state, fetchState, edata))\r\n+            return false;\r\n+        if (!_ctx.getPopulateDataCache())\r\n+            return true;\r\n+        // make sure that we're not trying to cache an old version\r\n+        cache.writeLock();\r\n+        try {\r\n+            data = cache.get(sm.getObjectId());\r\n+            if (data != null && compareVersion(sm, sm.getVersion(),\r\n+                data.getVersion()) == VERSION_EARLIER)\r\n+                return true;\r\n+            // cache newly loaded info. It is safe to cache data frorm\r\n+            // initialize() because this method is only called upon\r\n+            // initial load of the data.\r\n+            if (data == null)\r\n+                data = newPCData(sm);\r\n+            data.store(sm);\r\n+            cache.put(data);\r\n+        }\r\n+        finally {\r\n+            cache.writeUnlock();\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\r\n+        FetchState fetchState, int lockLevel, Object edata) {\r\n+        FetchConfiguration fetch = (fetchState == null)\r\n+            ? _ctx.getFetchConfiguration()\r\n+            : fetchState.getFetchConfiguration();\r\n+        DataCache cache = sm.getMetaData().getDataCache();\r\n+        if (cache == null || sm.isEmbedded())\r\n+            return super.load(sm, fields, fetchState, lockLevel, edata);\r\n+        DataCachePCData data = cache.get(sm.getObjectId());\r\n+        if (lockLevel == LockLevels.LOCK_NONE && !isLocking(fetch)\r\n+            && data != null)\r\n+            data.load(sm, fields, fetchState, edata);\r\n+        if (fields.length() == 0)\r\n+            return true;\r\n+        // load from store manager; clone the set of still-unloaded fields\r\n+        // so that if the store manager decides to modify it it won't affect us\r\n+        if (!super.load(sm, (BitSet) fields.clone(), fetchState,\r\n+            lockLevel, edata))\r\n+            return false;\r\n+        if (!_ctx.getPopulateDataCache())\r\n+            return true;\r\n+        // make sure that we're not trying to cache an old version\r\n+        cache.writeLock();\r\n+        try {\r\n+            data = cache.get(sm.getObjectId());\r\n+            if (data != null && compareVersion(sm, sm.getVersion(),\r\n+                data.getVersion()) == VERSION_EARLIER)\r\n+                return true;\r\n+            // cache newly loaded info\r\n+            boolean isNew = data == null;\r\n+            if (isNew)\r\n+                data = newPCData(sm);\r\n+            data.store(sm, fields);\r\n+            if (isNew)\r\n+                cache.put(data);\r\n+            else cache.update(data);\r\n+        }\r\n+        finally {\r\n+            cache.writeUnlock();\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    public Collection loadAll(Collection sms, PCState state, int load,\r\n+        FetchState fetchState, Object edata) {\r\n+        FetchConfiguration fetch = (fetchState == null)\r\n+            ? _ctx.getFetchConfiguration()\r\n+            : fetchState.getFetchConfiguration();\r\n+        if (isLocking(fetch))\r\n+            return super.loadAll(sms, state, load, fetchState, edata);\r\n+        Map unloaded = null;\r\n+        OpenJPAStateManager sm;\r\n+        DataCache cache;\r\n+        DataCachePCData data;\r\n+        BitSet fields;\r\n+        FetchConfiguration fc;\r\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n+            sm = (OpenJPAStateManager) itr.next();\r\n+            cache = sm.getMetaData().getDataCache();\r\n+            if (cache == null || sm.isEmbedded()) {\r\n+                unloaded = addUnloaded(sm, null, unloaded);\r\n+                continue;\r\n+            }\r\n+            if (sm.getManagedInstance() == null) {\r\n+                data = cache.get(sm.getObjectId());\r\n+                if (data != null) {\r\n+                    //### the 'data.type' access here probably needs\r\n+                    //### to be addressed for bug 511\r\n+                    sm.initialize(data.getType(), state);\r\n+                    data.load(sm, fetchState, edata);\r\n+                } else unloaded = addUnloaded(sm, null, unloaded);\r\n+            } else if (load != FORCE_LOAD_NONE\r\n+                || sm.getPCState() == PCState.HOLLOW) {\r\n+                data = cache.get(sm.getObjectId());\r\n+                if (data != null) {\r\n+                    // ### fc isn't ever accessed; we should check that\r\n+                    // ### getFetchConfiguration() doesn't have any side-effects\r\n+                    // ### and remove this code.\r\n+                    fc = (load == FORCE_LOAD_ALL) ? null\r\n+                        : fetchState.getFetchConfiguration();\r\n+                    // load unloaded fields\r\n+                    fields = sm.getUnloaded(fetchState);\r\n+                    data.load(sm, fields, fetchState, edata);\r\n+                    if (fields.length() > 0)\r\n+                        unloaded = addUnloaded(sm, fields, unloaded);\r\n+                } else unloaded = addUnloaded(sm, null, unloaded);\r\n+            } else if (!cache.contains(sm.getObjectId()))\r\n+                unloaded = addUnloaded(sm, null, unloaded);\r\n+        }\r\n+        if (unloaded == null)\r\n+            return Collections.EMPTY_LIST;\r\n+        // load with delegate\r\n+        Collection failed = super.loadAll(unloaded.keySet(), state, load,\r\n+            fetchState, edata);\r\n+        if (!_ctx.getPopulateDataCache())\r\n+            return failed;\r\n+        // for each loaded instance, merge loaded state into cached data\r\n+        Map.Entry entry;\r\n+        boolean isNew;\r\n+        for (Iterator itr = unloaded.entrySet().iterator(); itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            sm = (OpenJPAStateManager) entry.getKey();\r\n+            fields = (BitSet) entry.getValue();\r\n+            cache = sm.getMetaData().getDataCache();\r\n+            if (cache == null || sm.isEmbedded() || (failed != null\r\n+                && failed.contains(sm.getId())))\r\n+                continue;\r\n+            // make sure that we're not trying to cache an old version\r\n+            cache.writeLock();\r\n+            try {\r\n+                data = cache.get(sm.getObjectId());\r\n+                if (data != null && compareVersion(sm, sm.getVersion(),\r\n+                    data.getVersion()) == VERSION_EARLIER)\r\n+                    continue;\r\n+                isNew = data == null;\r\n+                if (isNew)\r\n+                    data = newPCData(sm);\r\n+                if (fields == null)\r\n+                    data.store(sm);\r\n+                else data.store(sm, fields);\r\n+                if (isNew)\r\n+                    cache.put(data);\r\n+                else cache.update(data);\r\n+            }\r\n+            finally {\r\n+                cache.writeUnlock();\r\n+            }\r\n+        }\r\n+        return failed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method to add an unloaded instance to the given map.\r\n+     */\r\n+    private static Map addUnloaded(OpenJPAStateManager sm, BitSet fields,\r\n+        Map unloaded) {\r\n+        if (unloaded == null)\r\n+            unloaded = new HashMap();\r\n+        unloaded.put(sm, fields);\r\n+        return unloaded;\r\n+    }\r\n+\r\n+    public Collection flush(Collection states) {\r\n+        Collection exceps = super.flush(states);\r\n+        if (!exceps.isEmpty() || _ctx.isLargeTransaction())\r\n+            return exceps;\r\n+        OpenJPAStateManager sm;\r\n+        for (Iterator itr = states.iterator(); itr.hasNext();) {\r\n+            sm = (OpenJPAStateManager) itr.next();\r\n+            if (sm.getPCState() == PCState.PNEW) {\r\n+                if (_inserts == null)\r\n+                    _inserts = new LinkedList();\r\n+                _inserts.add(sm);\r\n+            } else if (_inserts != null &&\r\n+                sm.getPCState() == PCState.PNEWDELETED ||\r\n+                sm.getPCState() == PCState.PNEWFLUSHEDDELETED)\r\n+                _inserts.remove(sm);\r\n+            else if (sm.getPCState() == PCState.PDIRTY) {\r\n+                if (_updates == null)\r\n+                    _updates = new HashMap();\r\n+                _updates.put(sm, sm.getDirty());\r\n+            } else if (sm.getPCState() == PCState.PDELETED) {\r\n+                if (_deletes == null)\r\n+                    _deletes = new LinkedList();\r\n+                _deletes.add(sm);\r\n+            }\r\n+        }\r\n+        return Collections.EMPTY_LIST;\r\n+    }\r\n+\r\n+    public StoreQuery newQuery(String language) {\r\n+        StoreQuery q = super.newQuery(language);\r\n+        // if the query can't be parsed or it's using a non-parsed language\r\n+        // (one for which there is no OpenJPA ExpressionParser), we can't cache it.\r\n+        if (q == null || QueryLanguages.parserForLanguage(language) == null)\r\n+            return q;\r\n+        QueryCache queryCache = _ctx.getConfiguration().\r\n+            getDataCacheManagerInstance().getSystemQueryCache();\r\n+        if (queryCache == null)\r\n+            return q;\r\n+        return new QueryCacheStoreQuery(q, queryCache);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new cacheable instance for the given state manager.\r\n+     */\r\n+    private DataCachePCData newPCData(OpenJPAStateManager sm) {\r\n+        ClassMetaData meta = sm.getMetaData();\r\n+        if (_gen != null)\r\n+            return (DataCachePCData) _gen.generatePCData\r\n+                (sm.getObjectId(), meta);\r\n+        return new DataCachePCDataImpl(sm.getObjectId(), meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether the context is locking loaded data.\r\n+     */\r\n+    private boolean isLocking(FetchConfiguration fetch) {\r\n+        if (fetch == null)\r\n+            fetch = _ctx.getFetchConfiguration();\r\n+        return fetch.getReadLockLevel() > LockLevels.LOCK_NONE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Structure used during the commit process to track cache modifications.\r\n+     */\r\n+    private static class Modifications {\r\n+\r\n+        public final List additions = new LinkedList();\r\n+        public final List newUpdates = new LinkedList();\r\n+        public final List existingUpdates = new LinkedList();\r\n+        public final List deletes = new LinkedList();\r\n+    }\r\n+\r\n+    private static class PCDataHolder {\r\n+\r\n+        public final DataCachePCData pcdata;\r\n+        public final OpenJPAStateManager sm;\r\n+\r\n+        public PCDataHolder(DataCachePCData pcdata, OpenJPAStateManager sm) {\r\n+            this.pcdata = pcdata;\r\n+            this.sm = sm;\r\n+        }\r\n+    }\r\n+}\r\n+\r"},{"sha":"ccac638a0943b9a4506c0d0c5f5840fbe364176a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","status":"added","additions":307,"deletions":0,"changes":307,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,307 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.commons.lang.ObjectUtils;\r\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n+\r\n+/**\r\n+ * Delegating data cache that can also perform exception translation for\r\n+ * use in facades. This cache allows its delegate to be null, in which\r\n+ * case it returns default values for all operations.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class DelegatingDataCache implements DataCache {\r\n+\r\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n+    private final DataCache _cache;\r\n+    private final DelegatingDataCache _del;\r\n+    private final RuntimeExceptionTranslator _trans;\r\n+\r\n+    /**\r\n+     * Constructor. Supply delegate.\r\n+     */\r\n+    public DelegatingDataCache(DataCache cache) {\r\n+        this(cache, null);\r\n+    }\r\n+\r\n+    public DelegatingDataCache(DataCache cache,\r\n+        RuntimeExceptionTranslator trans) {\r\n+        _cache = cache;\r\n+        _trans = trans;\r\n+        if (cache instanceof DelegatingDataCache)\r\n+            _del = (DelegatingDataCache) _cache;\r\n+        else _del = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the direct delegate.\r\n+     */\r\n+    public DataCache getDelegate() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the native delegate.\r\n+     */\r\n+    public DataCache getInnermostDelegate() {\r\n+        return (_del == null) ? _cache : _del.getInnermostDelegate();\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        if (_cache == null)\r\n+            return super.hashCode();\r\n+        return getInnermostDelegate().hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (other instanceof DelegatingDataCache)\r\n+            other = ((DelegatingDataCache) other).getInnermostDelegate();\r\n+        return ObjectUtils.equals(getInnermostDelegate(), other);\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the OpenJPA exception.\r\n+     */\r\n+    protected RuntimeException translate(RuntimeException re) {\r\n+        return (_trans == null) ? re : _trans.translate(re);\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.getName();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void setName(String name) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.setName(name);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager manager) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.initialize(manager);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void commit(Collection additions, Collection newUpdates,\r\n+        Collection existingUpdates, Collection deletes) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.commit(additions, newUpdates, existingUpdates, deletes);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean contains(Object oid) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.contains(oid);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public BitSet containsAll(Collection oids) {\r\n+        if (_cache == null)\r\n+            return EMPTY_BITSET;\r\n+        try {\r\n+            return _cache.containsAll(oids);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public DataCachePCData get(Object oid) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.get(oid);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public DataCachePCData put(DataCachePCData value) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.put(value);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void update(DataCachePCData value) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.update(value);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public DataCachePCData remove(Object oid) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.remove(oid);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public BitSet removeAll(Collection oids) {\r\n+        if (_cache == null)\r\n+            return EMPTY_BITSET;\r\n+        try {\r\n+            return _cache.removeAll(oids);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void removeAll(Class cls, boolean subclasses) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.removeAll(cls, subclasses);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.clear();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean pin(Object oid) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.pin(oid);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public BitSet pinAll(Collection oids) {\r\n+        if (_cache == null)\r\n+            return EMPTY_BITSET;\r\n+        try {\r\n+            return _cache.pinAll(oids);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean unpin(Object oid) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.unpin(oid);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public BitSet unpinAll(Collection oids) {\r\n+        if (_cache == null)\r\n+            return EMPTY_BITSET;\r\n+        try {\r\n+            return _cache.unpinAll(oids);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void writeLock() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.writeLock();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void writeUnlock() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.writeUnlock();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void addExpirationListener(ExpirationListener listen) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.addExpirationListener(listen);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean removeExpirationListener(ExpirationListener listen) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.removeExpirationListener(listen);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.close();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"3d710af7170c6e6c2c2590669be8f0753d340132","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","status":"added","additions":211,"deletions":0,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,211 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import org.apache.commons.lang.ObjectUtils;\r\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n+\r\n+/**\r\n+ * Delegating query cache that can also perform exception translation for\r\n+ * use in facades. This cache allows its delegate to be null, in which case\r\n+ * it returns default values or all methods.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+public class DelegatingQueryCache implements QueryCache {\r\n+\r\n+    private final QueryCache _cache;\r\n+    private final DelegatingQueryCache _del;\r\n+    private final RuntimeExceptionTranslator _trans;\r\n+\r\n+    /**\r\n+     * Constructor. Supply delegate.\r\n+     */\r\n+    public DelegatingQueryCache(QueryCache cache) {\r\n+        this(cache, null);\r\n+    }\r\n+\r\n+    public DelegatingQueryCache(QueryCache cache,\r\n+        RuntimeExceptionTranslator trans) {\r\n+        _cache = cache;\r\n+        _trans = trans;\r\n+        if (cache instanceof DelegatingQueryCache)\r\n+            _del = (DelegatingQueryCache) _cache;\r\n+        else _del = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the direct delegate.\r\n+     */\r\n+    public QueryCache getDelegate() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the native delegate.\r\n+     */\r\n+    public QueryCache getInnermostDelegate() {\r\n+        return (_del == null) ? _cache : _del.getInnermostDelegate();\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return getInnermostDelegate().hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (other instanceof DelegatingQueryCache)\r\n+            other = ((DelegatingQueryCache) other).getInnermostDelegate();\r\n+        return ObjectUtils.equals(getInnermostDelegate(), other);\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the OpenJPA exception.\r\n+     */\r\n+    protected RuntimeException translate(RuntimeException re) {\r\n+        return (_trans == null) ? re : _trans.translate(re);\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager mgr) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.initialize(mgr);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void onTypesChanged(TypesChangedEvent e) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.onTypesChanged(e);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public QueryResult get(QueryKey qk) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.get(qk);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.put(qk, oids);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public QueryResult remove(QueryKey qk) {\r\n+        if (_cache == null)\r\n+            return null;\r\n+        try {\r\n+            return _cache.remove(qk);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.clear();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean pin(QueryKey qk) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.pin(qk);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean unpin(QueryKey qk) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.unpin(qk);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void writeLock() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.writeLock();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void writeUnlock() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.writeUnlock();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void addTypesChangedListener(TypesChangedListener listen) {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.addTypesChangedListener(listen);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n+        if (_cache == null)\r\n+            return false;\r\n+        try {\r\n+            return _cache.removeTypesChangedListener(listen);\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        if (_cache == null)\r\n+            return;\r\n+        try {\r\n+            _cache.close();\r\n+        } catch (RuntimeException re) {\r\n+            throw translate(re);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"24a8b1d7b3fd834d4f0d5392a8d8d401abf744e6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,58 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.EventObject;\r\n+\r\n+/**\r\n+ * An event indicating the expiration of an object from the data cache,\r\n+ * or an expiration of a result list from the query cache.\r\n+ * The source of the event will be the cache.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public class ExpirationEvent extends EventObject {\r\n+\r\n+    private final Object _key;\r\n+    private final boolean _expired;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param source  the data or query cache\r\n+     * @param key     the expired object oid or query key\r\n+     * @param expired <code>true</code> if the object was expired\r\n+     *                naturally; else <code>false</code>.\r\n+     */\r\n+    public ExpirationEvent(Object source, Object key, boolean expired) {\r\n+        super(source);\r\n+        _key = key;\r\n+        _expired = expired;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the expired object id or query key.\r\n+     */\r\n+    public Object getKey() {\r\n+        return _key;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether the expired object was expired naturally, or if\r\n+     * the object was explicitly removed.\r\n+     */\r\n+    public boolean getExpired() {\r\n+        return _expired;\r\n+    }\r\n+}\r"},{"sha":"1218eef9713763f4aec4bfc62c515fd1b35af6c8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,27 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+/**\r\n+ * An entity that wishes to be notified when cache keys expire.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public interface ExpirationListener {\r\n+\r\n+    /**\r\n+     * Notification that an object has expired from the cache.\r\n+     */\r\n+    public void onExpire(ExpirationEvent event);\r\n+}\r"},{"sha":"591bc1097bf5d20ce9f523627a7b5716322a8675","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","status":"added","additions":130,"deletions":0,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,130 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+\r\n+/**\r\n+ * Interface that must be implemented by any level 2 query cache\r\n+ * used by OpenJPA. These methods should be threadsafe.\r\n+ * Most query cache implementations will probably implement\r\n+ * {@link org.apache.openjpa.lib.conf.Configurable} to receive a handle to the\r\n+ * system configuration on construction.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5\r\n+ */\r\n+public interface QueryCache extends TypesChangedListener, Closeable {\r\n+\r\n+    /**\r\n+     * Initialize any resources associated with the given\r\n+     * {@link DataCacheManager}.\r\n+     *\r\n+     * @since 4.1\r\n+     */\r\n+    public void initialize(DataCacheManager manager);\r\n+\r\n+    /**\r\n+     * Return a list of oids for the given query key. This is an\r\n+     * unmodifiable list.\r\n+     *\r\n+     * @return The query results matching the given key, or null if none\r\n+     */\r\n+    public QueryResult get(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Set the list of OIDs for the given query key. A reference\r\n+     * to the given list will be stored in the query cache, so the\r\n+     * list should not be modified after invoking this method.\r\n+     *\r\n+     * @return The previously cached value, or <code>null</code> if\r\n+     *         the key was not previously cached. See {@link Map#put}\r\n+     *         for more information.\r\n+     */\r\n+    public QueryResult put(QueryKey qk, QueryResult oids);\r\n+\r\n+    /**\r\n+     * Remove the value stored under the given query key.\r\n+     * This method is typically not invoked directly from outside\r\n+     * the <code>QueryCache</code> class. Instead, the cache should\r\n+     * be updated by invoking {@link #typesChanged}, which will\r\n+     * result in all queries that may be invalid being dropped.\r\n+     *\r\n+     * @return The previously cached value, or <code>null</code> if\r\n+     *         the key was not previously cached. See {@link Map#remove}\r\n+     *         for more information.\r\n+     */\r\n+    public QueryResult remove(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Remove all data from this cache.\r\n+     */\r\n+    public void clear();\r\n+\r\n+    /**\r\n+     * Pin the value stored under <code>qk</code> into the\r\n+     * cache. This method guarantees that <code>qk</code>'s value\r\n+     * will not be expired if the cache exceeds its capacity. It\r\n+     * causes this data to be ignored when determining whether or not\r\n+     * the cache is full, effectively increasing the total amount of\r\n+     * data stored in the cache. This method does not affect the\r\n+     * behavior of {@link #remove} or {@link #typesChanged}.\r\n+     *\r\n+     * @return <code>true</code> if <code>key</code>'s value was\r\n+     *         pinned into the cache; <code>false</code> if the key is not in the cache.\r\n+     */\r\n+    public boolean pin(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Unpin the value stored under <code>key</code> into the cache.\r\n+     * This method reverses a previous invocation of {@link #pin}.\r\n+     * This method does not remove anything from the cache; it merely\r\n+     * makes <code>key</code>'s value a candidate for flushing from the cache.\r\n+     *\r\n+     * @return <code>true</code> if <code>key</code>'s value was\r\n+     *         unpinned from the cache; <code>false</code> if the\r\n+     *         key is not in the cache.\r\n+     */\r\n+    public boolean unpin(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Obtain a write lock on the cache.\r\n+     */\r\n+    public void writeLock();\r\n+\r\n+    /**\r\n+     * Release the write lock on the cache.\r\n+     */\r\n+    public void writeUnlock();\r\n+\r\n+    /**\r\n+     * Add a new types event listener to this cache.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public void addTypesChangedListener(TypesChangedListener listen);\r\n+\r\n+    /**\r\n+     * Remove an types event listener from this cache.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public boolean removeTypesChangedListener(TypesChangedListener listen);\r\n+\r\n+    /**\r\n+     * Free the resources used by this cache.\r\n+     */\r\n+    public void close();\r\n+}\r"},{"sha":"9e420a3fe348cabf77faad5a65e4a78d47ee0437","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"added","additions":644,"deletions":0,"changes":644,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,644 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.io.ObjectStreamException;\r\n+import java.io.Serializable;\r\n+import java.util.AbstractList;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.BitSet;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.List;\r\n+import java.util.Locale;\r\n+import java.util.Map;\r\n+import java.util.TreeMap;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ObjectNotFoundException;\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n+ * the query, and can determine whether or not the query has been dirtied.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public class QueryCacheStoreQuery implements StoreQuery {\r\n+\r\n+    private static Object NULL = new Object();\r\n+    private final StoreQuery _query;\r\n+    private final QueryCache _cache;\r\n+    private StoreContext _sctx;\r\n+    private MetaDataRepository _repos;\r\n+\r\n+    /**\r\n+     * Create a new instance that delegates to <code>query</code> if no\r\n+     * cached results are available.\r\n+     */\r\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n+        _query = query;\r\n+        _cache = cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link QueryCache} that this object is associated with.\r\n+     */\r\n+    public QueryCache getCache() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public StoreQuery getDelegate() {\r\n+        return _query;\r\n+    }\r\n+\r\n+    /**\r\n+     * Look in the query cache for a result for the given query\r\n+     * key. Only look if this query is being executed outside a\r\n+     * transaction or in a transaction with IgnoreChanges set to true\r\n+     * or in a transaction with IgnoreChanges set to false but in which\r\n+     * none of the classes involved in this query have been touched.\r\n+     * Caching is not used when using object locking.\r\n+     * This is because we must obtain locks on the\r\n+     * data, and it is likely that making n trips to the database to\r\n+     * make the locks will be slower than running the query against\r\n+     * the database.\r\n+     * If the fetch configuration has query caching disabled,\r\n+     * then this method returns <code>null</code>.\r\n+     * Return the list if we meet the above criteria and if a list\r\n+     * is found for <code>qk</code>. Else, return\r\n+     * <code>null</code>.\r\n+     * This implementation means that queries against the cache\r\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n+     * a transaction.\r\n+     */\r\n+    private List checkCache(QueryKey qk) {\r\n+        if (qk == null)\r\n+            return null;\r\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n+        if (!fetch.getQueryCache())\r\n+            return null;\r\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n+            return null;\r\n+        // get the cached oids\r\n+        QueryResult res = _cache.get(qk);\r\n+        if (res == null)\r\n+            return null;\r\n+        if (res.isEmpty())\r\n+            return Collections.EMPTY_LIST;\r\n+        int projs = getContext().getProjectionAliases().length;\r\n+        if (projs == 0) {\r\n+            // make sure the data cache contains the oids for the query result;\r\n+            // if it doesn't, then using the result could be slower than not\r\n+            // using it becauseo of the individual by-oid lookups\r\n+            ClassMetaData meta = _repos.getMetaData(getContext().\r\n+                getCandidateType(), _sctx.getClassLoader(), true);\r\n+            BitSet idxs = meta.getDataCache().containsAll(res);\r\n+            // eventually we should optimize this to figure out how many objects\r\n+            // the cache is missing and if only a few do a bulk fetch for them\r\n+            int len = idxs.length();\r\n+            if (len < res.size())\r\n+                return null;\r\n+            for (int i = 0; i < len; i++)\r\n+                if (!idxs.get(i))\r\n+                    return null;\r\n+        }\r\n+        return new CachedList(res, projs != 0, _sctx);\r\n+    }\r\n+\r\n+    /**\r\n+     * Wrap the result object provider returned by our delegate in a\r\n+     * caching provider.\r\n+     */\r\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n+        QueryKey key) {\r\n+        if (key == null)\r\n+            return rop;\r\n+        return new CachingResultObjectProvider(rop, getContext().\r\n+            getProjectionAliases().length > 0, key);\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy a projection element for caching / returning.\r\n+     */\r\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n+        if (obj == null)\r\n+            return null;\r\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n+            case JavaTypes.STRING:\r\n+            case JavaTypes.BOOLEAN_OBJ:\r\n+            case JavaTypes.BYTE_OBJ:\r\n+            case JavaTypes.CHAR_OBJ:\r\n+            case JavaTypes.DOUBLE_OBJ:\r\n+            case JavaTypes.FLOAT_OBJ:\r\n+            case JavaTypes.INT_OBJ:\r\n+            case JavaTypes.LONG_OBJ:\r\n+            case JavaTypes.SHORT_OBJ:\r\n+            case JavaTypes.BIGDECIMAL:\r\n+            case JavaTypes.BIGINTEGER:\r\n+            case JavaTypes.OID:\r\n+                return obj;\r\n+            case JavaTypes.DATE:\r\n+                return ((Date) obj).clone();\r\n+            case JavaTypes.LOCALE:\r\n+                return ((Locale) obj).clone();\r\n+            default:\r\n+                if (obj instanceof CachedObjectId)\r\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n+                Object oid = ctx.getObjectId(obj);\r\n+                if (oid != null)\r\n+                    return new CachedObjectId(oid);\r\n+                return obj;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the result object based on its cached oid.\r\n+     */\r\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n+        if (oid == null)\r\n+            return null;\r\n+        Object obj = sctx.find(oid, null, null, null, 0);\r\n+        if (obj == null)\r\n+            throw new ObjectNotFoundException(oid);\r\n+        return obj;\r\n+    }\r\n+\r\n+    public Object writeReplace() throws ObjectStreamException {\r\n+        return _query;\r\n+    }\r\n+\r\n+    public QueryContext getContext() {\r\n+        return _query.getContext();\r\n+    }\r\n+\r\n+    public void setContext(QueryContext qctx) {\r\n+        _query.setContext(qctx);\r\n+        _sctx = qctx.getStoreContext();\r\n+        _repos = _sctx.getConfiguration().getMetaDataRepository();\r\n+    }\r\n+\r\n+    public boolean setQuery(Object query) {\r\n+        return _query.setQuery(query);\r\n+    }\r\n+\r\n+    public FilterListener getFilterListener(String tag) {\r\n+        return _query.getFilterListener(tag);\r\n+    }\r\n+\r\n+    public AggregateListener getAggregateListener(String tag) {\r\n+        return _query.getAggregateListener(tag);\r\n+    }\r\n+\r\n+    public Object newCompilationKey() {\r\n+        return _query.newCompilationKey();\r\n+    }\r\n+\r\n+    public Object newCompilation() {\r\n+        return _query.newCompilation();\r\n+    }\r\n+\r\n+    public void populateFromCompilation(Object comp) {\r\n+        _query.populateFromCompilation(comp);\r\n+    }\r\n+\r\n+    public void invalidateCompilation() {\r\n+        _query.invalidateCompilation();\r\n+    }\r\n+\r\n+    public boolean supportsDataStoreExecution() {\r\n+        return _query.supportsDataStoreExecution();\r\n+    }\r\n+\r\n+    public boolean supportsInMemoryExecution() {\r\n+        return _query.supportsInMemoryExecution();\r\n+    }\r\n+\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n+        return _query.newInMemoryExecutor(meta, subs);\r\n+    }\r\n+\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n+        return new QueryCacheExecutor(ex, meta, subs);\r\n+    }\r\n+\r\n+    public boolean supportsAbstractExecutors() {\r\n+        return _query.supportsAbstractExecutors();\r\n+    }\r\n+\r\n+    public boolean requiresCandidateType() {\r\n+        return _query.requiresCandidateType();\r\n+    }\r\n+\r\n+    public boolean requiresParameterDeclarations() {\r\n+        return _query.requiresParameterDeclarations();\r\n+    }\r\n+\r\n+    public boolean supportsParameterDeclarations() {\r\n+        return _query.supportsParameterDeclarations();\r\n+    }\r\n+\r\n+    /**\r\n+     * Caching executor.\r\n+     */\r\n+    private static class QueryCacheExecutor implements Executor {\r\n+\r\n+        private final Executor _ex;\r\n+        private final Class _candidate;\r\n+        private final boolean _subs;\r\n+\r\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n+            boolean subs) {\r\n+            _ex = ex;\r\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n+            _subs = subs;\r\n+        }\r\n+\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n+            boolean lrs, long startIdx, long endIdx) {\r\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n+                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\r\n+            List cached = cq.checkCache(key);\r\n+            if (cached != null)\r\n+                return new ListResultObjectProvider(cached);\r\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n+                params, lrs, startIdx, endIdx);\r\n+            return cq.wrapResult(rop, key);\r\n+        }\r\n+\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\r\n+            boolean lrs, long startIdx, long endIdx) {\r\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n+                _ex.isPacking(q), params, _candidate, _subs, startIdx, endIdx);\r\n+            List cached = cq.checkCache(key);\r\n+            if (cached != null)\r\n+                return new ListResultObjectProvider(cached);\r\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n+                params, lrs, startIdx, endIdx);\r\n+            return cq.wrapResult(rop, key);\r\n+        }\r\n+\r\n+        /**\r\n+         * Clear the cached queries associated with the access path\r\n+         * classes in the query. This is done when bulk operations\r\n+         * (such as deletes or updates) are performed so that the\r\n+         * cache remains up-to-date.\r\n+         */\r\n+        private void clearAccesssPath(StoreQuery q) {\r\n+            if (q == null)\r\n+                return;\r\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n+            if (cmd == null || cmd.length == 0)\r\n+                return;\r\n+            Class[] classes = new Class[cmd.length];\r\n+            for (int i = 0; i < cmd.length; i++)\r\n+                classes[i] = cmd[i].getDescribedType();\r\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n+                (q.getContext(), Arrays.asList(classes)));\r\n+        }\r\n+\r\n+        public Number executeDelete(StoreQuery q, Object[] params) {\r\n+            try {\r\n+                return _ex.executeDelete(unwrap(q), params);\r\n+            }\r\n+            finally {\r\n+                clearAccesssPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public Number executeDelete(StoreQuery q, Map params) {\r\n+            try {\r\n+                return _ex.executeDelete(unwrap(q), params);\r\n+            }\r\n+            finally {\r\n+                clearAccesssPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n+            try {\r\n+                return _ex.executeUpdate(unwrap(q), params);\r\n+            }\r\n+            finally {\r\n+                clearAccesssPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Map params) {\r\n+            try {\r\n+                return _ex.executeUpdate(unwrap(q), params);\r\n+            }\r\n+            finally {\r\n+                clearAccesssPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            long startIdx, long endIdx) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex) {\r\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n+                orderIndex);\r\n+        }\r\n+\r\n+        public boolean[] getAscending(StoreQuery q) {\r\n+            return _ex.getAscending(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean isPacking(StoreQuery q) {\r\n+            return _ex.isPacking(unwrap(q));\r\n+        }\r\n+\r\n+        public String getAlias(StoreQuery q) {\r\n+            return _ex.getAlias(unwrap(q));\r\n+        }\r\n+\r\n+        public Class getResultClass(StoreQuery q) {\r\n+            return _ex.getResultClass(unwrap(q));\r\n+        }\r\n+\r\n+        public String[] getProjectionAliases(StoreQuery q) {\r\n+            return _ex.getProjectionAliases(unwrap(q));\r\n+        }\r\n+\r\n+        public Class[] getProjectionTypes(StoreQuery q) {\r\n+            return _ex.getProjectionTypes(unwrap(q));\r\n+        }\r\n+\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n+        }\r\n+\r\n+        public int getOperation(StoreQuery q) {\r\n+            return _ex.getOperation(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean isAggregate(StoreQuery q) {\r\n+            return _ex.isAggregate(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean hasGrouping(StoreQuery q) {\r\n+            return _ex.hasGrouping(unwrap(q));\r\n+        }\r\n+\r\n+        public LinkedMap getParameterTypes(StoreQuery q) {\r\n+            return _ex.getParameterTypes(unwrap(q));\r\n+        }\r\n+\r\n+        public Map getUpdates(StoreQuery q) {\r\n+            return _ex.getUpdates(unwrap(q));\r\n+        }\r\n+\r\n+        private static StoreQuery unwrap(StoreQuery q) {\r\n+            return ((QueryCacheStoreQuery) q).getDelegate();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Result list implementation for a cached query result. Public visibility\r\n+     * for testing.\r\n+     */\r\n+    public static class CachedList extends AbstractList\r\n+        implements Serializable {\r\n+\r\n+        private final QueryResult _res;\r\n+        private final boolean _proj;\r\n+        private final StoreContext _sctx;\r\n+\r\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n+            _res = res;\r\n+            _proj = proj;\r\n+            _sctx = ctx;\r\n+        }\r\n+\r\n+        public Object get(int idx) {\r\n+            if (!_proj)\r\n+                return fromObjectId(_res.get(idx), _sctx);\r\n+            Object[] cached = (Object[]) _res.get(idx);\r\n+            if (cached == null)\r\n+                return null;\r\n+            Object[] uncached = new Object[cached.length];\r\n+            for (int i = 0; i < cached.length; i++)\r\n+                uncached[i] = copyProjection(cached[i], _sctx);\r\n+            return uncached;\r\n+        }\r\n+\r\n+        public int size() {\r\n+            return _res.size();\r\n+        }\r\n+\r\n+        public Object writeReplace() throws ObjectStreamException {\r\n+            return new ArrayList(this);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n+     * all the OIDs in this list and registers that list with the\r\n+     * query cache. Abandons monitoring and registering if one of the classes\r\n+     * in the access path is modified while the query results are being loaded.\r\n+     */\r\n+    private class CachingResultObjectProvider\r\n+        implements ResultObjectProvider, TypesChangedListener {\r\n+\r\n+        private final ResultObjectProvider _rop;\r\n+        private final boolean _proj;\r\n+        private final QueryKey _qk;\r\n+        private final TreeMap _data = new TreeMap();\r\n+        private boolean _maintainCache = true;\r\n+        private int _pos = -1;\r\n+        // used to determine list size without necessarily calling size(),\r\n+        // which may require a DB trip or return Integer.MAX_VALUE\r\n+        private int _max = -1;\r\n+        private int _size = Integer.MAX_VALUE;\r\n+\r\n+        /**\r\n+         * Constructor. Supply delegate result provider and our query key.\r\n+         */\r\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n+            boolean proj, QueryKey key) {\r\n+            _rop = rop;\r\n+            _proj = proj;\r\n+            _qk = key;\r\n+            _cache.addTypesChangedListener(this);\r\n+        }\r\n+\r\n+        /**\r\n+         * Stop caching.\r\n+         */\r\n+        private void abortCaching() {\r\n+            if (!_maintainCache)\r\n+                return;\r\n+            // this can be called via an event from another thread\r\n+            synchronized (this) {\r\n+                // it's important that we set this flag first so that any\r\n+                // subsequent calls to this object are bypassed.\r\n+                _maintainCache = false;\r\n+                _cache.removeTypesChangedListener(this);\r\n+                _data.clear();\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Check whether we've buffered all results, while optionally adding\r\n+         * the given result.\r\n+         */\r\n+        private void checkFinished(Object obj, boolean result) {\r\n+            // this can be called at the same time as abortCaching via\r\n+            // a types changed event\r\n+            boolean finished = false;\r\n+            synchronized (this) {\r\n+                if (_maintainCache) {\r\n+                    if (result) {\r\n+                        Integer index = Numbers.valueOf(_pos);\r\n+                        if (!_data.containsKey(index)) {\r\n+                            Object cached;\r\n+                            if (obj == null)\r\n+                                cached = null;\r\n+                            else if (!_proj)\r\n+                                cached = _sctx.getObjectId(obj);\r\n+                            else {\r\n+                                Object[] arr = (Object[]) obj;\r\n+                                Object[] cp = new Object[arr.length];\r\n+                                for (int i = 0; i < arr.length; i++)\r\n+                                    cp[i] = copyProjection(arr[i], _sctx);\r\n+                                cached = cp;\r\n+                            }\r\n+                            if (cached != null)\r\n+                                _data.put(index, cached);\r\n+                        }\r\n+                    }\r\n+                    finished = _size == _data.size();\r\n+                }\r\n+            }\r\n+            if (finished) {\r\n+                // an abortCaching call can sneak in here via onExpire; the\r\n+                // cache is locked during event firings, so the lock here will\r\n+                // wait for it(or will force the next firing to wait)\r\n+                _cache.writeLock();\r\n+                try {\r\n+                    // make sure we didn't abort\r\n+                    if (_maintainCache) {\r\n+                        QueryResult res = new QueryResult(_qk, _data.values());\r\n+                        _cache.put(_qk, res);\r\n+                        abortCaching();\r\n+                    }\r\n+                }\r\n+                finally {\r\n+                    _cache.writeUnlock();\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        public boolean supportsRandomAccess() {\r\n+            return _rop.supportsRandomAccess();\r\n+        }\r\n+\r\n+        public void open() throws Exception {\r\n+            _rop.open();\r\n+        }\r\n+\r\n+        public Object getResultObject() throws Exception {\r\n+            Object obj = _rop.getResultObject();\r\n+            checkFinished(obj, true);\r\n+            return obj;\r\n+        }\r\n+\r\n+        public boolean next() throws Exception {\r\n+            _pos++;\r\n+            boolean next = _rop.next();\r\n+            if (!next && _pos == _max + 1) {\r\n+                _size = _pos;\r\n+                checkFinished(null, false);\r\n+            } else if (next && _pos > _max)\r\n+                _max = _pos;\r\n+            return next;\r\n+        }\r\n+\r\n+        public boolean absolute(int pos) throws Exception {\r\n+            _pos = pos;\r\n+            boolean valid = _rop.absolute(pos);\r\n+            if (!valid && _pos == _max + 1) {\r\n+                _size = _pos;\r\n+                checkFinished(null, false);\r\n+            } else if (valid && _pos > _max)\r\n+                _max = _pos;\r\n+            return valid;\r\n+        }\r\n+\r\n+        public int size() throws Exception {\r\n+            if (_size != Integer.MAX_VALUE)\r\n+                return _size;\r\n+            int size = _rop.size();\r\n+            _size = size;\r\n+            checkFinished(null, false);\r\n+            return size;\r\n+        }\r\n+\r\n+        public void reset() throws Exception {\r\n+            _rop.reset();\r\n+            _pos = -1;\r\n+        }\r\n+\r\n+        public void close() throws Exception {\r\n+            abortCaching();\r\n+            _rop.close();\r\n+        }\r\n+\r\n+        public void handleCheckedException(Exception e) {\r\n+            _rop.handleCheckedException(e);\r\n+        }\r\n+\r\n+        public void onTypesChanged(TypesChangedEvent ev) {\r\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n+                abortCaching();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Struct to recognize cached oids.\r\n+     */\r\n+    private static class CachedObjectId {\r\n+\r\n+        public final Object oid;\r\n+\r\n+        public CachedObjectId(Object oid) {\r\n+            this.oid = oid;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"df16dcc3cc29da610055bbaba9db12b9e3df3bda","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","status":"added","additions":432,"deletions":0,"changes":432,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,432 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.io.Externalizable;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInput;\r\n+import java.io.ObjectOutput;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.SortedSet;\r\n+import java.util.TreeSet;\r\n+\r\n+import org.apache.commons.lang.ObjectUtils;\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.kernel.Query;\r\n+import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * This class stores information about a particular invocation of\r\n+ * a query. It contains a reference to the external properties of the\r\n+ * query that was executed, as well as any parameters used to execute\r\n+ * that query, with one exception: first-class objects used as\r\n+ * parameter values are converted to OIDs.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public class QueryKey implements Externalizable {\r\n+\r\n+    // initialize the set of unmodifiable classes. This allows us\r\n+    // to avoid cloning collections that are not modifiable,\r\n+    // provided that they do not contain mutable objects.\r\n+    private static Collection s_unmod = new HashSet();\r\n+\r\n+    static {\r\n+        // handle the set types; jdk uses different classes for collection,\r\n+        // set, and sorted set\r\n+        TreeSet s = new TreeSet();\r\n+        s_unmod.add(Collections.unmodifiableCollection(s).getClass());\r\n+        s_unmod.add(Collections.unmodifiableSet(s).getClass());\r\n+        s_unmod.add(Collections.unmodifiableSortedSet(s).getClass());\r\n+        // handle the list types; jdk uses different classes for standard\r\n+        // and random access lists\r\n+        List l = new LinkedList();\r\n+        s_unmod.add(Collections.unmodifiableList(l).getClass());\r\n+        l = new ArrayList(0);\r\n+        s_unmod.add(Collections.unmodifiableList(l).getClass());\r\n+        // handle the constant types\r\n+        s_unmod.add(Collections.EMPTY_SET.getClass());\r\n+        s_unmod.add(Collections.EMPTY_LIST.getClass());\r\n+    }\r\n+\r\n+    // caching state; no need to include parameter and variable declarations\r\n+    // because they are implicit in the filter\r\n+    private String _candidateClassName;\r\n+    private boolean _subclasses;\r\n+    private Set _accessPathClassNames;\r\n+    private String _query;\r\n+    private boolean _ignoreChanges;\r\n+    private Map _params;\r\n+    private long _rangeStart;\r\n+    private long _rangeEnd;\r\n+    // ### pcl: 2 May 2003: should this timeout take into account the\r\n+    // ### timeouts for classes in the access path of the query?\r\n+    // ### Currently, it only considers the candidate class and its\r\n+    // ### subclasses. Note that this value is used to decide whether\r\n+    // ### or not OIDs should be registered for expiration callbacks\r\n+    private int _timeout = -1;\r\n+\r\n+    /**\r\n+     * Return a key for the given query, or null if it is not cacheable.\r\n+     */\r\n+    public static QueryKey newInstance(Query q) {\r\n+        return newInstance(q, (Object[]) null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a key for the given query, or null if it is not cacheable.\r\n+     */\r\n+    public static QueryKey newInstance(Query q, Object[] args) {\r\n+        // compile to make sure info encoded in query string is available\r\n+        // via API calls(candidate class, result class, etc)\r\n+        q.compile();\r\n+        return newInstance(q, false, args, q.getCandidateType(),\r\n+            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a key for the given query, or null if it is not cacheable.\r\n+     */\r\n+    public static QueryKey newInstance(Query q, Map args) {\r\n+        // compile to make sure info encoded in query string is available\r\n+        // via API calls(candidate class, result class, etc)\r\n+        q.compile();\r\n+        return newInstance(q, false, args, q.getCandidateType(),\r\n+            q.hasSubclasses(), q.getStartRange(), q.getEndRange());\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a key for the given query, or null if it is not cacheable.\r\n+     */\r\n+    static QueryKey newInstance(QueryContext q, boolean packed, Object[] args,\r\n+        Class candidate, boolean subs, long startIdx, long endIdx) {\r\n+        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\r\n+        if (key != null && setParams(key, q, args))\r\n+            return key;\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a key for the given query, or null if it is not cacheable.\r\n+     */\r\n+    static QueryKey newInstance(QueryContext q, boolean packed, Map args,\r\n+        Class candidate, boolean subs, long startIdx, long endIdx) {\r\n+        QueryKey key = createKey(q, packed, candidate, subs, startIdx, endIdx);\r\n+        if (key != null && (args == null || args.isEmpty() ||\r\n+            setParams(key, q.getStoreContext(), new HashMap(args))))\r\n+            return key;\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Extract the relevant identifying information from\r\n+     * <code>q</code>. This includes information such as candidate\r\n+     * class, query filter, etc.\r\n+     */\r\n+    private static QueryKey createKey(QueryContext q, boolean packed,\r\n+        Class candidateClass, boolean subclasses, long startIdx, long endIdx) {\r\n+        if (candidateClass == null)\r\n+            return null;\r\n+        // can only cache datastore queries\r\n+        if (q.getCandidateCollection() != null)\r\n+            return null;\r\n+        // no support already-packed results\r\n+        if (q.getResultType() != null && packed)\r\n+            return null;\r\n+        // can't cache non-serializable non-managed complex types\r\n+        Class[] types = q.getProjectionTypes();\r\n+        for (int i = 0; i < types.length; i++) {\r\n+            switch (JavaTypes.getTypeCode(types[i])) {\r\n+                case JavaTypes.ARRAY:\r\n+                    return null;\r\n+                case JavaTypes.COLLECTION:\r\n+                case JavaTypes.MAP:\r\n+                case JavaTypes.OBJECT:\r\n+                    if (!ImplHelper.isManagedType(types[i]))\r\n+                        return null;\r\n+                    break;\r\n+            }\r\n+        }\r\n+        // we can't cache the query if we don't know which classes are in the\r\n+        // access path\r\n+        ClassMetaData[] metas = q.getAccessPathMetaDatas();\r\n+        if (metas.length == 0)\r\n+            return null;\r\n+        Set accessPathClassNames = new HashSet((int) (metas.length * 1.33 + 1));\r\n+        ClassMetaData meta;\r\n+        for (int i = 0; i < metas.length; i++) {\r\n+            // since the class change framework deals with least-derived types,\r\n+            // record the least-derived access path types\r\n+            meta = metas[i];\r\n+            while (meta.getPCSuperclass() != null)\r\n+                meta = meta.getPCSuperclassMetaData();\r\n+            // ensure that this metadata is cacheable\r\n+            if (meta.getDataCache() == null)\r\n+                return null;\r\n+            accessPathClassNames.add(meta.getDescribedType().getName());\r\n+        }\r\n+        // if any of the types are currently dirty, we can't cache this query\r\n+        StoreContext ctx = q.getStoreContext();\r\n+        if (intersects(accessPathClassNames, ctx.getPersistedTypes())\r\n+            || intersects(accessPathClassNames, ctx.getUpdatedTypes())\r\n+            || intersects(accessPathClassNames, ctx.getDeletedTypes()))\r\n+            return null;\r\n+        // calculate the timeout for the key\r\n+        MetaDataRepository repos = ctx.getConfiguration().\r\n+            getMetaDataRepository();\r\n+        // won't find metadata for interfaces.\r\n+        if (candidateClass.isInterface())\r\n+            return null;\r\n+        meta = repos.getMetaData(candidateClass, ctx.getClassLoader(), true);\r\n+        int timeout = meta.getDataCacheTimeout();\r\n+        if (subclasses) {\r\n+            metas = meta.getPCSubclassMetaDatas();\r\n+            int subTimeout;\r\n+            for (int i = 0; i < metas.length; i++) {\r\n+                if (metas[i].getDataCache() == null)\r\n+                    return null;\r\n+                subTimeout = metas[i].getDataCacheTimeout();\r\n+                if (subTimeout != -1 && subTimeout < timeout)\r\n+                    timeout = subTimeout;\r\n+            }\r\n+        }\r\n+        // tests all passed; cacheable\r\n+        QueryKey key = new QueryKey();\r\n+        key._candidateClassName = candidateClass.getName();\r\n+        key._subclasses = subclasses;\r\n+        key._accessPathClassNames = accessPathClassNames;\r\n+        key._timeout = timeout;\r\n+        key._query = q.getQueryString();\r\n+        key._ignoreChanges = q.getIgnoreChanges();\r\n+        key._rangeStart = startIdx;\r\n+        key._rangeEnd = endIdx;\r\n+        return key;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert an array of arguments into the corresponding parameter\r\n+     * map, and do any PC to OID conversion necessary.\r\n+     */\r\n+    private static boolean setParams(QueryKey key, QueryContext q,\r\n+        Object[] args) {\r\n+        if (args == null || args.length == 0)\r\n+            return true;\r\n+        // Create a map for the given parameters, and convert the\r\n+        // parameter list into a map, using the query's parameter\r\n+        // declaration to determine ordering etc.\r\n+        Map types = q.getParameterTypes();\r\n+        Map map = new HashMap((int) (types.size() * 1.33 + 1));\r\n+        int idx = 0;\r\n+        for (Iterator iter = types.keySet().iterator(); iter.hasNext(); idx++)\r\n+            map.put(iter.next(), args[idx]);\r\n+        return setParams(key, q.getStoreContext(), map);\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert parameters to a form that is cacheable. Mutable params\r\n+     * will be cloned.\r\n+     */\r\n+    private static boolean setParams(QueryKey key, StoreContext ctx,\r\n+        Map params) {\r\n+        if (params == null || params.isEmpty())\r\n+            return true;\r\n+        Map.Entry e;\r\n+        Object v;\r\n+        for (Iterator iter = params.entrySet().iterator(); iter.hasNext();) {\r\n+            e = (Map.Entry) iter.next();\r\n+            v = e.getValue();\r\n+            if (ImplHelper.isManageable(v)) {\r\n+                if (!ctx.isPersistent(v) || ctx.isNew(v) || ctx.isDeleted(v))\r\n+                    return false;\r\n+                e.setValue(ctx.getObjectId(v));\r\n+            }\r\n+            if (v instanceof Collection) {\r\n+                Collection c = (Collection) v;\r\n+                boolean contentsAreDates = false;\r\n+                if (c.iterator().hasNext()) {\r\n+                    // this assumes that the collection is homogeneous\r\n+                    Object o = c.iterator().next();\r\n+                    if (ImplHelper.isManageable(o))\r\n+                        return false;\r\n+                    // pcl: 27 Jun 2004: if we grow this logic to\r\n+                    // handle other mutable types that are not\r\n+                    // known to be cloneable, we will have to add\r\n+                    // logic to handle them. This is because we\r\n+                    // can't just cast to Cloneable and invoke\r\n+                    // clone(), as clone() is a protected method\r\n+                    // in Object.\r\n+                    if (o instanceof Date)\r\n+                        contentsAreDates = true;\r\n+                    // if the collection is not a known immutable\r\n+                    // type, or if it contains mutable instances,\r\n+                    // clone it for good measure.\r\n+                    if (contentsAreDates || !s_unmod.contains(c.getClass())) {\r\n+                        // copy the collection\r\n+                        Collection copy;\r\n+                        if (c instanceof SortedSet)\r\n+                            copy = new TreeSet();\r\n+                        else if (c instanceof Set)\r\n+                            copy = new HashSet();\r\n+                        else copy = new ArrayList(c.size());\r\n+                        if (contentsAreDates) {\r\n+                            // must go through by hand and do the\r\n+                            // copy, since Date is mutable.\r\n+                            for (Iterator itr2 = c.iterator(); itr2.hasNext();)\r\n+                                copy.add(((Date) itr2.next()).clone());\r\n+                        } else copy.addAll(c);\r\n+                        e.setValue(copy);\r\n+                    }\r\n+                }\r\n+            } else if (v instanceof Date)\r\n+                e.setValue(((Date) v).clone());\r\n+        }\r\n+        key._params = params;\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Public constructor for externalization only.\r\n+     */\r\n+    public QueryKey() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the candidate class name for this query.\r\n+     */\r\n+    public String getCandidateTypeName() {\r\n+        return _candidateClassName;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the amount of time this key is good for.\r\n+     */\r\n+    public int getTimeout() {\r\n+        return _timeout;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns <code>true</code> if modifications to any of the\r\n+     * classes in <code>changed</code> results in a possible\r\n+     * invalidation of this query; otherwise returns\r\n+     * <code>false</code>. Invalidation is possible if one or more of\r\n+     * the classes in this query key's access path has been changed.\r\n+     */\r\n+    public boolean changeInvalidatesQuery(Collection changed) {\r\n+        return intersects(_accessPathClassNames, changed);\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given set of least-derived class names intersects with\r\n+     * the given set of changed classes.\r\n+     */\r\n+    private static boolean intersects(Collection names, Collection changed) {\r\n+        Class cls;\r\n+        Class sup;\r\n+        for (Iterator iter = changed.iterator(); iter.hasNext();) {\r\n+            cls = (Class) iter.next();\r\n+            while ((sup = PCRegistry.getPersistentSuperclass(cls)) != null)\r\n+                cls = sup;\r\n+            if (names.contains(cls.getName()))\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Determine equality based on identifying information. Keys\r\n+     * created for queries that specify a candidate collection are\r\n+     * always not equal.\r\n+     */\r\n+    public boolean equals(Object ob) {\r\n+        if (this == ob)\r\n+            return true;\r\n+        if (ob == null || getClass() != ob.getClass())\r\n+            return false;\r\n+        QueryKey other = (QueryKey) ob;\r\n+        return StringUtils.equals(_candidateClassName,\r\n+            other._candidateClassName)\r\n+            && _subclasses == other._subclasses\r\n+            && _ignoreChanges == other._ignoreChanges\r\n+            && _rangeStart == other._rangeStart && _rangeEnd == other._rangeEnd\r\n+            && StringUtils.equals(_query, other._query)\r\n+            && ObjectUtils.equals(_params, other._params);\r\n+    }\r\n+\r\n+    /**\r\n+     * Define a hashing algorithm corresponding to the {@link #equals}\r\n+     * method defined above.\r\n+     */\r\n+    public int hashCode() {\r\n+        int code = 37 * 17 + _candidateClassName.hashCode();\r\n+        if (_query != null)\r\n+            code = 37 * code + _query.hashCode();\r\n+        if (_params != null)\r\n+            code = 37 * code + _params.hashCode();\r\n+        return code;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        StringBuffer buf = new StringBuffer(255);\r\n+        buf.append(super.toString()).\r\n+            append(\"[query:[\").append(_query).append(\"]\").\r\n+            append(\",access path:\").append(_accessPathClassNames).\r\n+            append(\",subs:\").append(_subclasses).\r\n+            append(\",ignoreChanges:\").append(_ignoreChanges).\r\n+            append(\",startRange:\").append(_rangeStart).\r\n+            append(\",endRange:\").append(_rangeEnd).\r\n+            append(\",timeout:\").append(_timeout). append(\"]\");\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    // ---------- Externalizable implementation ----------\r\n+    public void writeExternal(ObjectOutput out) throws IOException {\r\n+        out.writeObject(_candidateClassName);\r\n+        out.writeBoolean(_subclasses);\r\n+        out.writeObject(_accessPathClassNames);\r\n+        out.writeObject(_query);\r\n+        out.writeBoolean(_ignoreChanges);\r\n+        out.writeObject(_params);\r\n+        out.writeLong(_rangeStart);\r\n+        out.writeLong(_rangeEnd);\r\n+        out.writeInt(_timeout);\r\n+    }\r\n+\r\n+    public void readExternal(ObjectInput in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _candidateClassName = (String) in.readObject();\r\n+        _subclasses = in.readBoolean();\r\n+        _accessPathClassNames = (Set) in.readObject();\r\n+        _query = (String) in.readObject();\r\n+        _ignoreChanges = in.readBoolean();\r\n+        _params = (Map) in.readObject();\r\n+        _rangeStart = in.readLong();\r\n+        _rangeEnd = in.readLong();\r\n+        _timeout = in.readInt();\r\n+    }\r\n+}\r"},{"sha":"794cad2a8b38b3f3cb542a69c334071a6c45b878","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,58 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+\r\n+/**\r\n+ * A query result.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class QueryResult extends ArrayList {\r\n+\r\n+    private final long _ex;\r\n+\r\n+    /**\r\n+     * Constructor; supply corresponding query key and result data.\r\n+     */\r\n+    public QueryResult(QueryKey key, Collection data) {\r\n+        super(data);\r\n+        if (key.getTimeout() == -1)\r\n+            _ex = -1;\r\n+        else _ex = System.currentTimeMillis() + key.getTimeout();\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set internal data from a serializer.\r\n+     */\r\n+    public QueryResult(Collection data, long ex) {\r\n+        super(data);\r\n+        _ex = ex;\r\n+    }\r\n+\r\n+    /**\r\n+     * Expiration time, or -1 for no timeout.\r\n+     */\r\n+    public long getTimeoutTime() {\r\n+        return _ex;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether this data is timed out.\r\n+     */\r\n+    public boolean isTimedOut() {\r\n+        return _ex != -1 && _ex < System.currentTimeMillis();\r\n+    }\r\n+}\r"},{"sha":"becc92ca29c82102182e73c2ffee2be26e5ec005","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,45 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.EventObject;\r\n+\r\n+/**\r\n+ * An event indicating that instances of given persistent types have\r\n+ * been modified.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class TypesChangedEvent extends EventObject {\r\n+\r\n+    private final Collection _types;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param source the data or query cache\r\n+     * @param types  the changed types\r\n+     */\r\n+    public TypesChangedEvent(Object source, Collection types) {\r\n+        super(source);\r\n+        _types = types;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the expired types.\r\n+     */\r\n+    public Collection getTypes() {\r\n+        return _types;\r\n+    }\r\n+}\r"},{"sha":"84e08ab7436245d60356ddb40313475ab0ee51d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,27 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+/**\r\n+ * An entity that wishes to be notified when types change.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public interface TypesChangedListener {\r\n+\r\n+    /**\r\n+     * Notification that instances of persistent types have changed.\r\n+     */\r\n+    public void onTypesChanged(TypesChangedEvent event);\r\n+}\r"},{"sha":"30554f79238779fc5a2a2b2bb4ebe71cfbe22a49","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Data Cache</strong></p>\n+\n+<p>\n+    OpenJPA's data and query caching frameworks.\n+</p>\n+</body>\n+</html>"},{"sha":"ce5038e5e222be4187a4f32f6eb5989d80e57b4b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,160 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+\r\n+/**\r\n+ * Implementation of the {@link ManagedRuntime} interface that searches\r\n+ * through a set of known JNDI locations and method invocations to locate the\r\n+ * appropriate mechanism for obtaining a TransactionManager.\r\n+ * Built in support is provided for the following Application Servers:\r\n+ * <ul>\r\n+ * <li>Bluestone</li>\r\n+ * <li>HP Application Server</li>\r\n+ * <li>JBoss</li>\r\n+ * <li>JRun</li>\r\n+ * <li>OpenEJB</li>\r\n+ * <li>Oracle Application Server</li>\r\n+ * <li>Orion</li>\r\n+ * <li>SunONE</li>\r\n+ * <li>Weblogic</li>\r\n+ * <li>Websphere</li>\r\n+ * </ul>\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+public class AutomaticManagedRuntime implements ManagedRuntime, Configurable {\r\n+\r\n+    private static final String [] JNDI_LOCS = new String []{\r\n+        \"javax.transaction.TransactionManager\", // weblogic\r\n+        \"java:/TransactionManager\", // jboss & jrun\r\n+        \"java:/DefaultDomain/TransactionManager\", // jrun too\r\n+        \"java:comp/pm/TransactionManager\", // orion & oracle\r\n+        \"java:comp/TransactionManager\", // generic\r\n+        \"java:pm/TransactionManager\", // borland\r\n+    };\r\n+    private static final String [] METHODS = new String[]{\r\n+        \"com.arjuna.jta.JTA_TransactionManager.transactionManager\", // hp\r\n+        \"com.bluestone.jta.SaTransactionManagerFactory.SaGetTransactionManager\",\r\n+        \"com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\",\r\n+        \"com.ibm.ejs.jts.jta.TransactionManagerFactory.getTransactionManager\",\r\n+        \"com.ibm.ws.Transaction.TransactionManagerFactory.\"\r\n+            + \"getTransactionManager\", // WS 5.1\r\n+        \"org.openejb.OpenEJB.getTransactionManager\",\r\n+        \"com.sun.jts.jta.TransactionManagerImpl.getTransactionManagerImpl\",\r\n+        \"com.inprise.visitransact.jta.TransactionManagerImpl.\"\r\n+            + \"getTransactionManagerImpl\", // borland\r\n+    };\r\n+    private static final ManagedRuntime WLS;\r\n+    private static final ManagedRuntime SUNONE;\r\n+    private static Localizer _loc = Localizer.forPackage\r\n+        (AutomaticManagedRuntime.class);\r\n+\r\n+    static {\r\n+        ManagedRuntime mr = null;\r\n+        try {\r\n+            mr = new WLSManagedRuntime();\r\n+        } catch (Throwable t) {\r\n+        }\r\n+        WLS = mr;\r\n+        mr = null;\r\n+        try {\r\n+            mr = new SunOneManagedRuntime();\r\n+        } catch (Throwable t) {\r\n+        }\r\n+        SUNONE = mr;\r\n+    }\r\n+\r\n+    private Configuration _conf = null;\r\n+    private ManagedRuntime _runtime = null;\r\n+\r\n+    public TransactionManager getTransactionManager() throws Exception {\r\n+        if (_runtime != null)\r\n+            return _runtime.getTransactionManager();\r\n+        List errors = new LinkedList();\r\n+        TransactionManager tm = null;\r\n+        if (WLS != null) {\r\n+            try {\r\n+                tm = WLS.getTransactionManager();\r\n+            } catch (Throwable t) {\r\n+                errors.add(t);\r\n+            }\r\n+            if (tm != null) {\r\n+                _runtime = WLS;\r\n+                return tm;\r\n+            }\r\n+        }\r\n+        // try to find a jndi runtime\r\n+        JNDIManagedRuntime jmr = new JNDIManagedRuntime();\r\n+        for (int i = 0; i < JNDI_LOCS.length; i++) {\r\n+            jmr.setTransactionManagerName(JNDI_LOCS[i]);\r\n+            try {\r\n+                tm = jmr.getTransactionManager();\r\n+            } catch (Throwable t) {\r\n+                errors.add(t);\r\n+            }\r\n+            if (tm != null) {\r\n+                _runtime = jmr;\r\n+                return tm;\r\n+            }\r\n+        }\r\n+        // look for a method runtime\r\n+        InvocationManagedRuntime imr = new InvocationManagedRuntime();\r\n+        for (int i = 0; i < METHODS.length; i++) {\r\n+            imr.setConfiguration(_conf);\r\n+            imr.setTransactionManagerMethod(METHODS[i]);\r\n+            try {\r\n+                tm = imr.getTransactionManager();\r\n+            } catch (Throwable t) {\r\n+                errors.add(t);\r\n+            }\r\n+            if (tm != null) {\r\n+                _runtime = imr;\r\n+                return tm;\r\n+            }\r\n+        }\r\n+        if (SUNONE != null) {\r\n+            try {\r\n+                tm = SUNONE.getTransactionManager();\r\n+            } catch (Throwable t) {\r\n+                errors.add(t);\r\n+            }\r\n+            if (tm != null) {\r\n+                _runtime = SUNONE;\r\n+                return tm;\r\n+            }\r\n+        }\r\n+        Throwable[] t =\r\n+            (Throwable []) errors.toArray(new Throwable [errors.size()]);\r\n+        throw new InvalidStateException(_loc.get(\"tm-not-found\")).\r\n+            setFatal(true).setNestedThrowables(t);\r\n+    }\r\n+\r\n+    public void setConfiguration(Configuration conf) {\r\n+        _conf = conf;\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+}\r"},{"sha":"fceef07937b1a070c58f524afb59fc4eece75587","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,74 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import java.lang.reflect.Method;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+\r\n+/**\r\n+ * Implementation of the {@link ManagedRuntime} interface that uses\r\n+ * a static method call to find the TransactionManager.\r\n+ * For example, to configure it to use IBM Websphere's TransactionManager,\r\n+ * use the method:<br />\r\n+ * <code>com.ibm.ejs.jts.jta.JTSXA.getTransactionManager</code>\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+public class InvocationManagedRuntime implements ManagedRuntime, Configurable {\r\n+\r\n+    private String _methodName = null;\r\n+    private String _clazz = null;\r\n+    private transient Method _method = null;\r\n+    private OpenJPAConfiguration _conf = null;\r\n+\r\n+    /**\r\n+     * Return the method to invoke to get the {@link TransactionManager}.\r\n+     */\r\n+    public String getTransactionManagerMethod() {\r\n+        return _methodName;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the method to invoke to get the {@link TransactionManager}.\r\n+     * E.g.: com.ibm.ejs.jts.jta.JTSXA.getTransactionManager\r\n+     */\r\n+    public void setTransactionManagerMethod(String methodName) {\r\n+        _clazz = methodName.substring(0, methodName.lastIndexOf('.'));\r\n+        _methodName = methodName.substring(methodName.lastIndexOf('.') + 1);\r\n+        _method = null;\r\n+    }\r\n+\r\n+    public TransactionManager getTransactionManager() throws Exception {\r\n+        if (_method == null) {\r\n+            ClassLoader loader = _conf.getClassResolverInstance().\r\n+                getClassLoader(getClass(), null);\r\n+            _method = Class.forName(_clazz, true, loader)\r\n+                .getMethod(_methodName, null);\r\n+        }\r\n+        return (TransactionManager) _method.invoke(null, null);\r\n+    }\r\n+\r\n+    public void setConfiguration(Configuration conf) {\r\n+        _conf = (OpenJPAConfiguration) conf;\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+}\r"},{"sha":"47380b1cd8847eee562e4f0b8a796beb233aadc4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,52 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+/**\r\n+ * Implementation of the {@link ManagedRuntime} interface that uses JNDI to\r\n+ * find the TransactionManager.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class JNDIManagedRuntime implements ManagedRuntime {\r\n+\r\n+    private String _tmLoc = \"java:/TransactionManager\";\r\n+\r\n+    /**\r\n+     * Return the location of the {@link TransactionManager} in JNDI.\r\n+     */\r\n+    public String getTransactionManagerName() {\r\n+        return _tmLoc;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the location of the {@link TransactionManager} in JNDI.\r\n+     */\r\n+    public void setTransactionManagerName(String name) {\r\n+        _tmLoc = name;\r\n+    }\r\n+\r\n+    public TransactionManager getTransactionManager() throws Exception {\r\n+        Context ctx = new InitialContext();\r\n+        try {\r\n+            return (TransactionManager) ctx.lookup(_tmLoc);\r\n+        }\r\n+        finally {\r\n+            ctx.close();\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"0fbb94d84312c7f44c0e785e2d33c2eec6757c17","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+/**\r\n+ * This interface must be implemented by concrete plugins to application\r\n+ * servers in order to integrate the OpenJPA runtime in a managed environment.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public interface ManagedRuntime {\r\n+\r\n+    /**\r\n+     * Return the TransactionManager for the managed runtime. This\r\n+     * manager is used to register synchronization listeners, to\r\n+     * map transactional PersistenceManagers to the current transaction,\r\n+     * and possibly to enlist XA resources.\r\n+     */\r\n+    public TransactionManager getTransactionManager() throws Exception;\r\n+}\r"},{"sha":"951cc993ee947e28ed1d05a6b1601571fcd4a4aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,41 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import java.lang.reflect.Method;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+/**\r\n+ * {@link ManagedRuntime} implementation for SunONE.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+public class SunOneManagedRuntime implements ManagedRuntime {\r\n+\r\n+    private Method _switchMeth;\r\n+    private Method _txManagerMeth;\r\n+\r\n+    public SunOneManagedRuntime()\r\n+        throws ClassNotFoundException, NoSuchMethodException {\r\n+        Class swtch = Class.forName(\"com.sun.enterprise.Switch\");\r\n+        _switchMeth = swtch.getMethod(\"getSwitch\", (Class[]) null);\r\n+        _txManagerMeth = swtch.getMethod(\"getTransactionManager\",\r\n+            (Class[]) null);\r\n+    }\r\n+\r\n+    public TransactionManager getTransactionManager() throws Exception {\r\n+        // return Switch.getSwitch().getTransactionManager();\r\n+        Object sw = _switchMeth.invoke(null, (Object[]) null);\r\n+        return (TransactionManager) _txManagerMeth.invoke(sw, (Object[]) null);\r\n+    }\r\n+}\r"},{"sha":"d42ceb8ff695671b9ff17eae680165c0ee40821a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,43 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.ee;\r\n+\r\n+import java.lang.reflect.Method;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+/**\r\n+ * {@link ManagedRuntime} implementation that directly accesses the\r\n+ * transaction manager via WebLogic Server helper classes.\r\n+ *\r\n+ * @author Arunabh Hazarika, Patrick Linskey\r\n+ */\r\n+public class WLSManagedRuntime implements ManagedRuntime {\r\n+\r\n+    private final Method _txHelperMeth;\r\n+    private final Method _txManagerMeth;\r\n+\r\n+    public WLSManagedRuntime()\r\n+        throws ClassNotFoundException, NoSuchMethodException {\r\n+        Class txHelper = Class.forName\r\n+            (\"weblogic.transaction.TransactionHelper\");\r\n+        _txHelperMeth = txHelper.getMethod(\"getTransactionHelper\", null);\r\n+        _txManagerMeth = txHelper.getMethod(\"getTransactionManager\", null);\r\n+    }\r\n+\r\n+    public TransactionManager getTransactionManager() throws Exception {\r\n+        // return TransactionHelper.getTransactionHelper().\r\n+        // getTransactionManager();\r\n+        Object o = _txHelperMeth.invoke(null, null);\r\n+        return (TransactionManager) _txManagerMeth.invoke(o, null);\r\n+    }\r\n+}\r"},{"sha":"e028af6a85b730b465aa01a1656d1d96dc33aee7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Enterprise Extensions</strong></p>\n+\n+<p>\n+    This package provides enterprise extensions to the OpenJPA runtime.\n+</p>\n+</body>\n+</html>"},{"sha":"dbecae94643ca06d8d9fda101e3ce9b31816167d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","status":"added","additions":1336,"deletions":0,"changes":1336,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1336 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.File;\r\n+import java.io.FileWriter;\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+import java.io.Writer;\r\n+import java.lang.reflect.Modifier;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Date;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.TreeSet;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.meta.ClassArgParser;\r\n+import org.apache.openjpa.lib.util.CodeFormat;\r\n+import org.apache.openjpa.lib.util.Files;\r\n+import org.apache.openjpa.lib.util.JavaVersions;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.DelegatingMetaDataFactory;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataFactory;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+import org.apache.openjpa.util.UserException;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCClassLoader;\r\n+import serp.bytecode.Project;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Generates a class appropriate for use as an application identity class.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public class ApplicationIdTool {\r\n+\r\n+    public static final String TOKEN_DEFAULT = \"::\";\r\n+    private static final String TOKENIZER_CUSTOM = \"Tokenizer\";\r\n+    private static final String TOKENIZER_STD = \"StringTokenizer\";\r\n+    private static Localizer _loc = Localizer.forPackage\r\n+        (ApplicationIdTool.class);\r\n+    private final Log _log;\r\n+    private final Class _type;\r\n+    private final ClassMetaData _meta;\r\n+    private boolean _abstract = false;\r\n+    private FieldMetaData[] _fields = null;\r\n+    private boolean _ignore = true;\r\n+    private File _dir = null;\r\n+    private Writer _writer = null;\r\n+    private String _code = null;\r\n+    private String _token = TOKEN_DEFAULT;\r\n+    private CodeFormat _format = null;\r\n+\r\n+    /**\r\n+     * Constructs a new ApplicationIdTool capable of generating an\r\n+     * object id class for <code>type</code>.\r\n+     */\r\n+    public ApplicationIdTool(OpenJPAConfiguration conf, Class type) {\r\n+        _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+        _type = type;\r\n+        MetaDataRepository repos = new MetaDataRepository(conf);\r\n+        repos.setValidate(repos.VALIDATE_NONE);\r\n+        repos.setSourceMode(repos.MODE_MAPPING, false);\r\n+        loadObjectIds(repos, true);\r\n+        _meta = repos.getMetaData(type, null, false);\r\n+        if (_meta != null) {\r\n+            _abstract = Modifier.isAbstract(_meta.getDescribedType().\r\n+                getModifiers());\r\n+            _fields = getDeclaredPrimaryKeyFields(_meta);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructs a new tool instance capable of generating an\r\n+     * object id class for <code>meta</code>.\r\n+     */\r\n+    public ApplicationIdTool(OpenJPAConfiguration conf, Class type,\r\n+        ClassMetaData meta) {\r\n+        _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+        _type = type;\r\n+        _meta = meta;\r\n+        if (_meta != null) {\r\n+            _abstract = Modifier.isAbstract(_meta.getDescribedType().\r\n+                getModifiers());\r\n+            _fields = getDeclaredPrimaryKeyFields(_meta);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return metadata for primary key fields declared in the given class.\r\n+     */\r\n+    private static FieldMetaData[] getDeclaredPrimaryKeyFields\r\n+        (ClassMetaData meta) {\r\n+        if (meta.getPCSuperclass() == null)\r\n+            return meta.getPrimaryKeyFields();\r\n+        // remove the primary key fields that are not declared\r\n+        // in the current class\r\n+        FieldMetaData[] fields = meta.getPrimaryKeyFields();\r\n+        List decs = new ArrayList(fields.length);\r\n+        for (int i = 0; i < fields.length; i++)\r\n+            if (fields[i].getDeclaringType() == meta.getDescribedType())\r\n+                decs.add(fields[i]);\r\n+        return (FieldMetaData[]) decs.toArray(new FieldMetaData[decs.size()]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return false if this tool is configured to throw an exception on\r\n+     * an attempt to generate an id class for a type that does not use\r\n+     * application identity.\r\n+     */\r\n+    public boolean getIgnoreErrors() {\r\n+        return _ignore;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set to false if this tool should throw an exception on\r\n+     * an attempt to generate an id class for a type that does not use\r\n+     * application identity.\r\n+     */\r\n+    public void setIgnoreErrors(boolean ignore) {\r\n+        _ignore = ignore;\r\n+    }\r\n+\r\n+    /**\r\n+     * The code formatter for the generated Java code.\r\n+     */\r\n+    public CodeFormat getCodeFormat() {\r\n+        return _format;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the code formatter for the generated Java code.\r\n+     */\r\n+    public void setCodeFormat(CodeFormat format) {\r\n+        _format = format;\r\n+    }\r\n+\r\n+    /**\r\n+     * The directory to write source to. Defaults to the directory\r\n+     * of the Java file for the set type. If the given directory does not\r\n+     * match the package of the object id, the package structure will be\r\n+     * created below the directory.\r\n+     */\r\n+    public File getDirectory() {\r\n+        return _dir;\r\n+    }\r\n+\r\n+    /**\r\n+     * The directory to write source to. Defaults to the directory\r\n+     * of the Java file for the set type. If the given directory does not\r\n+     * match the package of the object id, the package structure will be\r\n+     * created below the directory.\r\n+     */\r\n+    public void setDirectory(File dir) {\r\n+        _dir = dir;\r\n+    }\r\n+\r\n+    /**\r\n+     * The token to use to separate stringified primary key field values.\r\n+     */\r\n+    public String getToken() {\r\n+        return _token;\r\n+    }\r\n+\r\n+    /**\r\n+     * The token to use to separate stringified primary key field values.\r\n+     */\r\n+    public void setToken(String token) {\r\n+        _token = token;\r\n+    }\r\n+\r\n+    /**\r\n+     * The writer to write source to, or null to write to default file.\r\n+     */\r\n+    public Writer getWriter() {\r\n+        return _writer;\r\n+    }\r\n+\r\n+    /**\r\n+     * The writer to write source to, or null to write to default file.\r\n+     */\r\n+    public void setWriter(Writer writer) {\r\n+        _writer = writer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the type we are generating an application id for.\r\n+     */\r\n+    public Class getType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return metadata for the type we are generating an application id for.\r\n+     */\r\n+    public ClassMetaData getMetaData() {\r\n+        return _meta;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the code generated for the application id, or null\r\n+     * if invalid class or the {@link #run} method has not been called.\r\n+     */\r\n+    public String getCode() {\r\n+        return _code;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the application identity class should be an inner class.\r\n+     */\r\n+    public boolean isInnerClass() {\r\n+        Class oidClass = _meta.getObjectIdType();\r\n+        return oidClass.getName().indexOf('$') != -1;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the short class name for the object id class.\r\n+     */\r\n+    private String getClassName() {\r\n+        if (_meta.isOpenJPAIdentity())\r\n+            return null;\r\n+        // convert from SomeClass$ID to ID\r\n+        String className = Strings.getClassName(_meta.getObjectIdType());\r\n+        if (isInnerClass())\r\n+            className = className.substring(className.lastIndexOf('$') + 1);\r\n+        return className;\r\n+    }\r\n+\r\n+    /**\r\n+     * Generates the sourcecode for the application id class; returns\r\n+     * false if the class is invalid.\r\n+     */\r\n+    public boolean run() {\r\n+        if (_log.isInfoEnabled())\r\n+            _log.info(_loc.get(\"appid-start\", _type));\r\n+        // ensure that this type is a candidate for application identity\r\n+        if (_meta == null\r\n+            || _meta.getIdentityType() != ClassMetaData.ID_APPLICATION\r\n+            || _meta.isOpenJPAIdentity()) {\r\n+            if (!_ignore)\r\n+                throw new UserException(_loc.get(\"appid-invalid\", _type));\r\n+            // else just warn\r\n+            if (_log.isWarnEnabled())\r\n+                _log.warn(_loc.get(\"appid-warn\", _type));\r\n+            return false;\r\n+        }\r\n+        Class oidClass = _meta.getObjectIdType();\r\n+        Class superOidClass = null;\r\n+        // allow diff oid class in subclass(horizontal)\r\n+        if (_meta.getPCSuperclass() != null) {\r\n+            superOidClass = _meta.getPCSuperclassMetaData().getObjectIdType();\r\n+            if (oidClass == null || oidClass.equals(superOidClass)) {\r\n+                // just warn\r\n+                if (_log.isWarnEnabled())\r\n+                    _log.warn(_loc.get(\"appid-warn\", _type));\r\n+                return false;\r\n+            }\r\n+        }\r\n+        // ensure that an id class is declared\r\n+        if (oidClass == null)\r\n+            throw new UserException(_loc.get(\"no-id-class\", _type)).\r\n+                setFatal(true);\r\n+        // ensure there is at least one pk field if we are\r\n+        // non-absract, and see if we have any byte[]\r\n+        boolean bytes = false;\r\n+        for (int i = 0; !bytes && i < _fields.length; i++)\r\n+            bytes = _fields[i].getDeclaredType() == byte[].class;\r\n+        // collect info on id type\r\n+        String className = getClassName();\r\n+        String packageName = Strings.getPackageName(oidClass);\r\n+        String packageDec = \"\";\r\n+        if (packageName.length() > 0)\r\n+            packageDec = \"package \" + packageName + \";\";\r\n+        String imports = getImports();\r\n+        String fieldDecs = getFieldDeclarations();\r\n+        String constructor = getConstructor(superOidClass != null);\r\n+        String properties = getProperties();\r\n+        String fromStringCode = getFromStringCode(superOidClass != null);\r\n+        String toStringCode = getToStringCode(superOidClass != null);\r\n+        String equalsCode = getEqualsCode(superOidClass != null);\r\n+        String hashCodeCode = getHashCodeCode(superOidClass != null);\r\n+        // build the java code\r\n+        CodeFormat code = newCodeFormat();\r\n+        if (!isInnerClass() && packageDec.length() > 0)\r\n+            code.append(packageDec).afterSection();\r\n+        if (!isInnerClass() && imports.length() > 0)\r\n+            code.append(imports).afterSection();\r\n+        code.append(\"/**\").endl(). append(\" * \").\r\n+            append(_loc.get(\"appid-comment-for\", _type.getName())). endl().\r\n+            append(\" *\").endl().\r\n+            append(\" * \").append(_loc.get(\"appid-comment-gen\")).endl().\r\n+            append(\" * \").append(getClass().getName()).endl().\r\n+            append(\" */\").endl();\r\n+        code.append(\"public \");\r\n+        if (isInnerClass())\r\n+            code.append(\"static \");\r\n+        code.append(\"class \").append(className);\r\n+        if (code.getBraceOnSameLine())\r\n+            code.append(\" \");\r\n+        else code.endl().tab();\r\n+        if (superOidClass != null) {\r\n+            code.append(\"extends \" + Strings.getClassName(superOidClass));\r\n+            if (code.getBraceOnSameLine())\r\n+                code.append(\" \");\r\n+            else code.endl().tab();\r\n+        }\r\n+        code.append(\"implements Serializable\").openBrace(1).endl();\r\n+        // if we use a byte array we need a static array for encoding to string\r\n+        if (bytes) {\r\n+            code.tab().append(\"private static final char[] HEX = \").\r\n+                append(\"new char[] {\").endl();\r\n+            code.tab(2).append(\"'0', '1', '2', '3', '4', '5', '6', '7',\").\r\n+                endl();\r\n+            code.tab(2).append(\"'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\").\r\n+                endl();\r\n+            code.tab().append(\"};\").endl(2);\r\n+        }\r\n+        // static block to register class\r\n+        code.tab().append(\"static\").openBrace(2).endl();\r\n+        code.tab(2).append(\"// register persistent class in JVM\").endl();\r\n+        if (JavaVersions.VERSION >= 5) {\r\n+            code.tab(2).append(\"try { Class.forName\").openParen(true).\r\n+                append(\"\\\"\").append(_type.getName()).append(\"\\\"\").\r\n+                closeParen().append(\";\").append(\" }\").endl();\r\n+            code.tab(2).append(\"catch\").openParen(true).\r\n+                append(\"Exception e\").closeParen().append(\" {}\").endl();\r\n+        } else code.tab(2).append(\"Class c = \").append(_type.getName()).\r\n+            append(\".class;\").endl();\r\n+        code.closeBrace(2);\r\n+        // field declarations\r\n+        if (fieldDecs.length() > 0)\r\n+            code.endl(2).append(fieldDecs);\r\n+        // default constructor\r\n+        code.afterSection().tab().append(\"public \").append(className).\r\n+            parens().openBrace(2).endl();\r\n+        code.closeBrace(2);\r\n+        // string constructor\r\n+        code.afterSection().append(constructor);\r\n+        // properties\r\n+        if (properties.length() > 0)\r\n+            code.afterSection().append(properties);\r\n+        // toString, equals, hashCode methods\r\n+        if (toStringCode.length() > 0)\r\n+            code.afterSection().append(toStringCode);\r\n+        if (hashCodeCode.length() > 0)\r\n+            code.afterSection().append(hashCodeCode);\r\n+        if (equalsCode.length() > 0)\r\n+            code.afterSection().append(equalsCode);\r\n+        if (fromStringCode.length() > 0)\r\n+            code.afterSection().append(fromStringCode);\r\n+        // if we have any byte array fields, we have to add the extra\r\n+        // methods for handling byte arrays\r\n+        if (bytes) {\r\n+            code.afterSection().append(getToBytesByteArrayCode());\r\n+            code.afterSection().append(getToStringByteArrayCode());\r\n+            code.afterSection().append(getEqualsByteArrayCode());\r\n+            code.afterSection().append(getHashCodeByteArrayCode());\r\n+        }\r\n+        // base classes might need to define a custom tokenizer\r\n+        if (superOidClass == null && getTokenizer(false) == TOKENIZER_CUSTOM)\r\n+            code.afterSection().append(getCustomTokenizerClass());\r\n+        code.endl();\r\n+        code.closeBrace(1);\r\n+        _code = code.toString();\r\n+        // if this is an inner class, then indent the entire\r\n+        // code unit one tab level\r\n+        if (isInnerClass()) {\r\n+            // indent the entire code block one level to make it\r\n+            // a propertly indented innder class\r\n+            _code = code.getTab() + Strings.replace(_code,\r\n+                System.getProperty(\"line.separator\"),\r\n+                System.getProperty(\"line.separator\") + code.getTab());\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes the generated code to the proper file.\r\n+     */\r\n+    public void record() throws IOException {\r\n+        if (_code == null)\r\n+            return;\r\n+        Writer writer = _writer;\r\n+        if (writer == null) {\r\n+            File file = getFile();\r\n+            Files.backup(file, false);\r\n+            writer = new FileWriter(file);\r\n+        }\r\n+        PrintWriter printer = new PrintWriter(writer);\r\n+        printer.print(_code);\r\n+        printer.flush();\r\n+        if (_writer == null)\r\n+            writer.close();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the necessary imports for the class.\r\n+     */\r\n+    private String getImports() {\r\n+        Set pkgs = getImportPackages();\r\n+        CodeFormat imports = newCodeFormat();\r\n+        String base = Strings.getPackageName(_meta.getObjectIdType());\r\n+        String pkg;\r\n+        for (Iterator itr = pkgs.iterator(); itr.hasNext();) {\r\n+            pkg = (String) itr.next();\r\n+            if (pkg.length() > 0 && !\"java.lang\".equals(pkg)\r\n+                && !base.equals(pkg)) {\r\n+                if (imports.length() > 0)\r\n+                    imports.endl();\r\n+                imports.append(\"import \").append(pkg).append(\".*;\");\r\n+            }\r\n+        }\r\n+        return imports.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the collection of packages that need to be imported.\r\n+     */\r\n+    public Set getImportPackages() {\r\n+        Set pkgs = new TreeSet();\r\n+        pkgs.add(Strings.getPackageName(_type));\r\n+        Class superOidClass = null;\r\n+        if (_meta != null && _meta.getPCSuperclassMetaData() != null)\r\n+            superOidClass = _meta.getPCSuperclassMetaData().getObjectIdType();\r\n+        if (superOidClass != null)\r\n+            pkgs.add(Strings.getPackageName(superOidClass));\r\n+        pkgs.add(\"java.io\");\r\n+        pkgs.add(\"java.util\");\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            if (_fields[i].getDeclaredType() != byte[].class\r\n+                && _fields[i].getDeclaredType() != char[].class\r\n+                && !_fields[i].getDeclaredType().getName().\r\n+                startsWith(\"java.sql.\")) {\r\n+                pkgs.add(Strings.getPackageName\r\n+                    (_fields[i].getDeclaredType()));\r\n+            }\r\n+        }\r\n+        return pkgs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the code to declare all primary key fields.\r\n+     */\r\n+    private String getFieldDeclarations() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            if (i > 0)\r\n+                code.endl();\r\n+            code.tab().append(\"public \").append(getTypeName(_fields[i])).\r\n+                append(\" \").append(_fields[i].getName()).append(\";\");\r\n+        }\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the type name to declare the given field as.\r\n+     */\r\n+    private String getTypeName(FieldMetaData fmd) {\r\n+        if (fmd.getDeclaredType() == byte[].class)\r\n+            return \"byte[]\";\r\n+        if (fmd.getDeclaredType() == char[].class)\r\n+            return \"char[]\";\r\n+        if (fmd.getDeclaredType().getName().startsWith(\"java.sql.\"))\r\n+            return fmd.getDeclaredType().getName();\r\n+        return Strings.getClassName(fmd.getDeclaredType());\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the getters and setters for all primary key fields.\r\n+     */\r\n+    private String getProperties() {\r\n+        if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\r\n+            return \"\";\r\n+        CodeFormat code = newCodeFormat();\r\n+        String propName;\r\n+        String typeName;\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            if (i > 0)\r\n+                code.afterSection();\r\n+            typeName = getTypeName(_fields[i]);\r\n+            propName = StringUtils.capitalize(_fields[i].getName());\r\n+            code.tab().append(\"public \").append(typeName).append(\" \");\r\n+            if (_fields[i].getDeclaredTypeCode() == JavaTypes.BOOLEAN\r\n+                || _fields[i].getDeclaredTypeCode() == JavaTypes.BOOLEAN_OBJ)\r\n+                code.append(\"is\");\r\n+            else code.append(\"get\");\r\n+            code.append(propName).parens().openBrace(2).endl();\r\n+            code.tab(2).append(\"return \").append(_fields[i].getName()).\r\n+                append(\";\").endl();\r\n+            code.closeBrace(2);\r\n+            code.afterSection();\r\n+            code.tab().append(\"public void set\").append(propName);\r\n+            code.openParen(true).append(typeName).append(\" \").\r\n+                append(_fields[i].getName()).closeParen();\r\n+            code.openBrace(2).endl();\r\n+            code.tab(2).append(\"this.\").append(_fields[i].getName()).\r\n+                append(\" = \").append(_fields[i].getName()).append(\";\"). endl();\r\n+            code.closeBrace(2);\r\n+        }\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the string constructor code.\r\n+     */\r\n+    private String getConstructor(boolean hasSuperclass) {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"public \");\r\n+        code.append(getClassName());\r\n+        code.openParen(true).append(\"String str\").closeParen();\r\n+        code.openBrace(2).endl();\r\n+        if (_fields.length != 0 || (hasSuperclass\r\n+            && _meta.getPrimaryKeyFields().length > 0)) {\r\n+            code.tab(2).append(\"fromString\").openParen(true).\r\n+                append(\"str\").closeParen().append(\";\").endl();\r\n+        }\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Create the fromString method that parses the result of our toString\r\n+     * method. If we have superclasses with id fields, this will call\r\n+     * super.fromString() so that the parent class can parse its own fields.\r\n+     */\r\n+    private String getFromStringCode(boolean hasSuperclass) {\r\n+        // if we are below a concrete class then we cannot declare any\r\n+        // more primary key fields; thus, just use the parent invocation\r\n+        if (hasConcreteSuperclass())\r\n+            return \"\";\r\n+        if (_fields.length == 0)\r\n+            return \"\";\r\n+        hasSuperclass = hasSuperclass && getDeclaredPrimaryKeyFields\r\n+            (_meta.getPCSuperclassMetaData()).length > 0;\r\n+        String toke = getTokenizer(hasSuperclass);\r\n+        CodeFormat code = newCodeFormat();\r\n+        if (_abstract || hasSuperclass)\r\n+            code.tab().append(\"protected \").append(toke).\r\n+                append(\" fromString\");\r\n+        else code.tab().append(\"private void fromString\");\r\n+        code.openParen(true).append(\"String str\").closeParen();\r\n+        code.openBrace(2).endl();\r\n+        if (toke != null) {\r\n+            code.tab(2).append(toke).append(\" toke = \");\r\n+            if (hasSuperclass) {\r\n+                // call super.fromString(str) to get the tokenizer that was\r\n+                // used to parse the superclass\r\n+                code.append(\"super.fromString\").openParen(true).\r\n+                    append(\"str\").closeParen();\r\n+            } else {\r\n+                // otherwise construct a new tokenizer with the string\r\n+                code.append(\"new \").append(toke).openParen(true).\r\n+                    append(\"str\");\r\n+                if (toke == TOKENIZER_STD)\r\n+                    code.append(\", \\\"\").append(_token).append(\"\\\"\");\r\n+                code.closeParen();\r\n+            }\r\n+            code.append(\";\").endl();\r\n+        }\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            if (toke != null) {\r\n+                code.tab(2).append(\"str = toke.nextToken\").parens().\r\n+                    append(\";\").endl();\r\n+            }\r\n+            code.tab(2).append(getConversionCode(_fields[i], \"str\")).endl();\r\n+        }\r\n+        if (_abstract || hasSuperclass)\r\n+            code.tab(2).append(\"return toke;\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the type of tokenizer to use, or null if none.\r\n+     */\r\n+    private String getTokenizer(boolean hasSuperclass) {\r\n+        if (!_abstract && !hasSuperclass && _fields.length == 1)\r\n+            return null;\r\n+        if (_token.length() == 1)\r\n+            return TOKENIZER_STD;\r\n+        return TOKENIZER_CUSTOM;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get parsing code for the given field.\r\n+     */\r\n+    private String getConversionCode(FieldMetaData field, String var) {\r\n+        CodeFormat parse = newCodeFormat();\r\n+        if (field.getName().equals(var))\r\n+            parse.append(\"this.\");\r\n+        parse.append(field.getName()).append(\" = \");\r\n+        Class type = field.getDeclaredType();\r\n+        if (type == Date.class) {\r\n+            parse.append(\"new Date\").openParen(true).\r\n+                append(\"Long.parseLong\").openParen(true).\r\n+                append(var).closeParen().closeParen();\r\n+        } else if (type == java.sql.Date.class\r\n+            || type == java.sql.Timestamp.class || type == java.sql.Time.class)\r\n+        {\r\n+            parse.append(type.getName()).append(\".valueOf\").openParen(true).\r\n+                append(var).closeParen();\r\n+        } else if (type == String.class)\r\n+            parse.append(var);\r\n+        else if (type == Character.class) {\r\n+            parse.append(\"new Character\").openParen(true).append(var).\r\n+                append(\".charAt\").openParen(true).append(0).\r\n+                closeParen().closeParen();\r\n+        } else if (type == byte[].class)\r\n+            parse.append(\"toBytes\").openParen(true).append(var).closeParen();\r\n+        else if (type == char[].class)\r\n+            parse.append(var).append(\".toCharArray\").parens();\r\n+        else if (!type.isPrimitive()) {\r\n+            parse.append(\"new \").append(Strings.getClassName(type)).\r\n+                openParen(true).append(var).closeParen();\r\n+        } else { // primitive\r\n+            switch (type.getName().charAt(0)) {\r\n+                case 'b':\r\n+                    if (type == boolean.class)\r\n+                        parse.append(\"\\\"true\\\".equals\").openParen(true).\r\n+                            append(var).closeParen();\r\n+                    else parse.append(\"Byte.parseByte\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+                case 'c':\r\n+                    parse.append(var).append(\".charAt\").openParen(true).\r\n+                        append(0).closeParen();\r\n+                    break;\r\n+                case 'd':\r\n+                    parse.append(\"Double.parseDouble\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+                case 'f':\r\n+                    parse.append(\"Float.parseFloat\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+                case 'i':\r\n+                    parse.append(\"Integer.parseInt\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+                case 'l':\r\n+                    parse.append(\"Long.parseLong\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+                case 's':\r\n+                    parse.append(\"Short.parseShort\").openParen(true).\r\n+                        append(var).closeParen();\r\n+                    break;\r\n+            }\r\n+        }\r\n+        if (!type.isPrimitive() && type != byte[].class) {\r\n+            CodeFormat isNull = newCodeFormat();\r\n+            isNull.append(\"if\").openParen(true).append(\"\\\"null\\\".equals\").\r\n+                openParen(true).append(var).closeParen().closeParen().\r\n+                endl().tab(3);\r\n+            if (field.getName().equals(var))\r\n+                isNull.append(\"this.\");\r\n+            isNull.append(field.getName()).append(\" = null;\").endl();\r\n+            isNull.tab(2).append(\"else\").endl();\r\n+            isNull.tab(3).append(parse);\r\n+            parse = isNull;\r\n+        }\r\n+        return parse.append(\";\").toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return an equality method that compares all pk variables.\r\n+     * Must deal correctly with both primitives and objects.\r\n+     */\r\n+    private String getEqualsCode(boolean hasSuperclass) {\r\n+        // if we are below a concrete class then we cannot declare any\r\n+        // more primary key fields; thus, just use the parent invocation\r\n+        if (hasConcreteSuperclass() || (hasSuperclass && _fields.length == 0))\r\n+            return \"\";\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"public boolean equals\").openParen(true).\r\n+            append(\"Object obj\").closeParen().openBrace(2).endl();\r\n+        code.tab(2).append(\"if\").openParen(true).\r\n+            append(\"this == obj\").closeParen().endl();\r\n+        code.tab(3).append(\"return true;\").endl();\r\n+        // call super.equals() if we have a superclass\r\n+        String className = getClassName();\r\n+        if (hasSuperclass) {\r\n+            code.tab(2).append(\"if\").openParen(true).\r\n+                append(\"!super.equals\").openParen(true).\r\n+                append(\"obj\").closeParen().closeParen().endl();\r\n+            code.tab(3).append(\"return false;\").endl();\r\n+        } else {\r\n+            code.tab(2).append(\"if\").openParen(true).\r\n+                append(\"obj == null || obj.getClass\").parens().\r\n+                append(\" != \").append(\"getClass\").parens().\r\n+                closeParen().endl();\r\n+            code.tab(3).append(\"return false;\").endl();\r\n+        }\r\n+        String name;\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            if (i == 0) {\r\n+                code.endl().tab(2).append(className).append(\" other = \").\r\n+                    openParen(false).append(className).closeParen().\r\n+                    append(\" obj;\").endl();\r\n+            }\r\n+            // if this is not the first field, add an &&\r\n+            if (i == 0)\r\n+                code.tab(2).append(\"return \");\r\n+            else code.endl().tab(3).append(\"&& \");\r\n+            name = _fields[i].getName();\r\n+            if (_fields[i].getDeclaredType().isPrimitive()) {\r\n+                code.openParen(false).append(name).append(\" == \").\r\n+                    append(\"other.\").append(name).closeParen();\r\n+            } else if (_fields[i].getDeclaredType() == byte[].class) {\r\n+                code.openParen(false).append(\"equals\").openParen(true).\r\n+                    append(name).append(\", \").append(\"other.\").\r\n+                    append(name).closeParen().closeParen();\r\n+            } else if (_fields[i].getDeclaredType() == char[].class) {\r\n+                // ((name == null && other.name == null)\r\n+                // || (name != null && String.valueOf(name).\r\n+                // equals(String.valueOf(other.name))))\r\n+                code.append(\"(\").openParen(false).append(name).\r\n+                    append(\" == null && other.\").append(name).\r\n+                    append(\" == null\").closeParen().endl();\r\n+                code.tab(3).append(\"|| \");\r\n+                code.openParen(false).append(name).append(\" != null \").\r\n+                    append(\"&& String.valueOf\").openParen(true).append(name).\r\n+                    closeParen().append(\".\").endl();\r\n+                code.tab(3).append(\"equals\").openParen(true).\r\n+                    append(\"String.valueOf\").openParen(true).\r\n+                    append(\"other.\").append(name).closeParen().closeParen().\r\n+                    closeParen().append(\")\");\r\n+            } else {\r\n+                // ((name == null && other.name == null)\r\n+                // || (name != null && name.equals(other.name)))\r\n+                code.append(\"(\").openParen(false).append(name).\r\n+                    append(\" == null && other.\").append(name).\r\n+                    append(\" == null\").closeParen().endl();\r\n+                code.tab(3).append(\"|| \");\r\n+                code.openParen(false).append(name).append(\" != null \").\r\n+                    append(\"&& \").append(name).append(\".equals\").\r\n+                    openParen(true).append(\"other.\").append(name).\r\n+                    closeParen().closeParen().append(\")\");\r\n+            }\r\n+        }\r\n+        // no _fields: just return true after checking instanceof\r\n+        if (_fields.length == 0)\r\n+            code.tab(2).append(\"return true;\").endl();\r\n+        else code.append(\";\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a hashCode method that takes into account all\r\n+     * primary key values. Must deal correctly with both primitives and objects.\r\n+     */\r\n+    private String getHashCodeCode(boolean hasSuperclass) {\r\n+        // if we are below a concrete class then we cannot declare any\r\n+        // more primary key fields; thus, just use the parent invocation\r\n+        if (hasConcreteSuperclass() || (hasSuperclass && _fields.length == 0))\r\n+            return \"\";\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"public int hashCode\").parens(). openBrace(2).endl();\r\n+        if (_fields.length == 0)\r\n+            code.tab(2).append(\"return 17;\").endl();\r\n+        else if (_fields.length == 1 && !hasSuperclass) {\r\n+            code.tab(2).append(\"return \");\r\n+            appendHashCodeCode(_fields[0], code);\r\n+            code.append(\";\").endl();\r\n+        } else {\r\n+            code.tab(2).append(\"int rs = \");\r\n+            if (hasSuperclass) {\r\n+                // call super.hashCode() if we have a superclass\r\n+                code.append(\"super.hashCode\").openParen(true).\r\n+                    closeParen().append(\";\");\r\n+            } else code.append(\"17;\");\r\n+            code.endl();\r\n+            for (int i = 0; i < _fields.length; i++) {\r\n+                code.tab(2).append(\"rs = rs * 37 + \");\r\n+                appendHashCodeCode(_fields[i], code);\r\n+                code.append(\";\").endl();\r\n+            }\r\n+            code.tab(2).append(\"return rs;\").endl();\r\n+        }\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if this class has a concrete superclass.\r\n+     */\r\n+    private boolean hasConcreteSuperclass() {\r\n+        for (ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n+            sup != null; sup = sup.getPCSuperclassMetaData()) {\r\n+            if (!Modifier.isAbstract(sup.getDescribedType().getModifiers()))\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Append code calculating the hashcode for the given field.\r\n+     */\r\n+    private void appendHashCodeCode(FieldMetaData field, CodeFormat code) {\r\n+        String name = field.getName();\r\n+        if (\"rs\".equals(name))\r\n+            name = \"this.\" + name;\r\n+        if (field.getDeclaredType().isPrimitive()) {\r\n+            if (field.getDeclaredType() == boolean.class) {\r\n+                // ((name) ? 1 : 0)\r\n+                code.append(\"(\").openParen(false).append(name).closeParen().\r\n+                    append(\" ? 1 : 0\").append(\")\");\r\n+            } else if (field.getDeclaredType() == long.class) {\r\n+                // (int) (name ^ (name >>> 32))\r\n+                code.openParen(false).append(\"int\").closeParen().\r\n+                    append(\" \").openParen(false).append(name).\r\n+                    append(\" ^ \").openParen(false).append(name).\r\n+                    append(\" >>> 32\").closeParen().closeParen();\r\n+            } else if (field.getDeclaredType() == double.class) {\r\n+                // (int) (Double.doubleToLongBits(name)\r\n+                //     ^ (Double.doubleToLongBits(name) >>> 32))\r\n+                code.openParen(false).append(\"int\").closeParen().\r\n+                    append(\" \").openParen(false).\r\n+                    append(\"Double.doubleToLongBits\").openParen(true).\r\n+                    append(name).closeParen().endl();\r\n+                code.tab(3).append(\"^ \").openParen(false).\r\n+                    append(\"Double.doubleToLongBits\").openParen(true).\r\n+                    append(name).closeParen().append(\" >>> 32\").\r\n+                    closeParen().closeParen();\r\n+            } else if (field.getDeclaredType() == float.class) {\r\n+                // Float.floatToIntBits(name)\r\n+                code.append(\"Float.floatToIntBits\").openParen(true).\r\n+                    append(name).closeParen();\r\n+            } else if (field.getDeclaredType() == int.class)\r\n+                code.append(name);\r\n+            else {\r\n+                // (int) name\r\n+                code.openParen(false).append(\"int\").closeParen().\r\n+                    append(\" \").append(name);\r\n+            }\r\n+        } else if (field.getDeclaredType() == byte[].class) {\r\n+            // hashCode(name);\r\n+            code.append(\"hashCode\").openParen(true).append(name). closeParen();\r\n+        } else if (field.getDeclaredType() == char[].class) {\r\n+            // ((name == null) ? 0 : String.valueOf(name).hashCode())\r\n+            code.append(\"(\").openParen(false).append(name).\r\n+                append(\" == null\").closeParen().append(\" ? 0 : \").\r\n+                append(\"String.valueOf\").openParen(true).append(name).\r\n+                closeParen().append(\".hashCode\").parens().append(\")\");\r\n+        } else {\r\n+            // ((name == null) ? 0 : name.hashCode())\r\n+            code.append(\"(\").openParen(false).append(name).\r\n+                append(\" == null\").closeParen().append(\" ? 0 : \").\r\n+                append(name).append(\".hashCode\").parens().append(\")\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a method to create a string containing the primary key\r\n+     * values that define the application id object.\r\n+     */\r\n+    private String getToStringCode(boolean hasSuperclass) {\r\n+        // if we are below a concrete class then we cannot declare any\r\n+        // more primary key fields; thus, just use the parent invocation\r\n+        if (hasConcreteSuperclass() || (hasSuperclass && _fields.length == 0))\r\n+            return \"\";\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"public String toString\").parens().\r\n+            openBrace(2).endl();\r\n+        String name;\r\n+        String appendDelimiter = \"+ \\\"\" + _token + \"\\\" + \";\r\n+        for (int i = 0; i < _fields.length; i++) {\r\n+            // if this is not the first field, add a +\r\n+            if (i == 0) {\r\n+                code.tab(2).append(\"return \");\r\n+                // add in the super.toString() if we have a parent\r\n+                if (hasSuperclass && getDeclaredPrimaryKeyFields\r\n+                    (_meta.getPCSuperclassMetaData()).length > 0) {\r\n+                    code.append(\"super.toString\").parens();\r\n+                    code.endl().tab(3).append(appendDelimiter);\r\n+                }\r\n+            } else code.endl().tab(3).append(appendDelimiter);\r\n+            name = _fields[i].getName();\r\n+            if (_fields[i].getDeclaredType() == String.class)\r\n+                code.append(name);\r\n+            else if (_fields[i].getDeclaredType() == byte[].class)\r\n+                code.append(\"toString\").openParen(true).\r\n+                    append(name).closeParen();\r\n+            else if (_fields[i].getDeclaredType() == char[].class)\r\n+                code.openParen(true).openParen(true).append(name).\r\n+                    append(\" == null\").closeParen().append(\" ? \\\"null\\\"\").\r\n+                    append(\": String.valueOf\").openParen(true).\r\n+                    append(name).closeParen().closeParen();\r\n+            else if (_fields[i].getDeclaredType() == Date.class)\r\n+                code.openParen(true).openParen(true).append(name).\r\n+                    append(\" == null\").closeParen().append(\" ? \\\"null\\\"\").\r\n+                    endl().tab(4).append(\": String.valueOf\").\r\n+                    openParen(true).append(name).append(\".getTime\").\r\n+                    parens().closeParen().closeParen();\r\n+            else code.append(\"String.valueOf\").openParen(true).\r\n+                append(name).closeParen();\r\n+        }\r\n+        // no fields; just use \"\"\r\n+        if (_fields.length == 0)\r\n+            code.tab(2).append(\"return \\\"\\\"\");\r\n+        code.append(\";\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Code to convert a string to a byte array.\r\n+     *\r\n+     * @see org.apache.openjpa.lib.util.Base16Encoder#decode\r\n+     */\r\n+    private String getToBytesByteArrayCode() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"private static byte[] toBytes\").openParen(true).\r\n+            append(\"String s\").closeParen().openBrace(2).endl();\r\n+        code.tab(2).append(\"if\").openParen(true).append(\"\\\"null\\\".equals\").\r\n+            openParen(true).append(\"s\").closeParen().closeParen().endl();\r\n+        code.tab(3).append(\"return null;\").endl(2);\r\n+        code.tab(2).append(\"int len = s.length\").parens(). append(\";\").endl();\r\n+        code.tab(2).append(\"byte[] r = new byte[len / 2];\").endl();\r\n+        code.tab(2).append(\"for\").openParen(true).\r\n+            append(\"int i = 0; i < r.length; i++\").closeParen().\r\n+            openBrace(3).endl();\r\n+        code.tab(3).append(\"int digit1 = s.charAt\").openParen(true).\r\n+            append(\"i * 2\").closeParen().append(\", \").\r\n+            append(\"digit2 = s.charAt\").openParen(true).\r\n+            append(\"i * 2 + 1\").closeParen().append(\";\").endl();\r\n+        code.tab(3).append(\"if\").openParen(true).\r\n+            append(\"digit1 >= '0' && digit1 <= '9'\").closeParen().endl();\r\n+        code.tab(4).append(\"digit1 -= '0';\").endl();\r\n+        code.tab(3).append(\"else if\").openParen(true).\r\n+            append(\"digit1 >= 'A' && digit1 <= 'F'\").closeParen().endl();\r\n+        code.tab(4).append(\"digit1 -= 'A' - 10;\").endl();\r\n+        code.tab(3).append(\"if\").openParen(true).\r\n+            append(\"digit2 >= '0' && digit2 <= '9'\").closeParen().endl();\r\n+        code.tab(4).append(\"digit2 -= '0';\").endl();\r\n+        code.tab(3).append(\"else if\").openParen(true).\r\n+            append(\"digit2 >= 'A' && digit2 <= 'F'\").closeParen().endl();\r\n+        code.tab(4).append(\"digit2 -= 'A' - 10;\").endl(2);\r\n+        code.tab(3).append(\"r[i] = (byte) \").openParen(false).\r\n+            openParen(false).append(\"digit1 << 4\").closeParen().\r\n+            append(\" + digit2\").closeParen().append(\";\").endl();\r\n+        code.closeBrace(3).endl();\r\n+        code.tab(2).append(\"return r;\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Code to convert a byte array to a string.\r\n+     *\r\n+     * @see org.apache.openjpa.lib.util.Base16Encoder#encode\r\n+     */\r\n+    private String getToStringByteArrayCode() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"private static String toString\").openParen(true).\r\n+            append(\"byte[] b\").closeParen().openBrace(2).endl();\r\n+        code.tab(2).append(\"if\").openParen(true).\r\n+            append(\"b == null\").closeParen().endl();\r\n+        code.tab(3).append(\"return \\\"null\\\";\").endl(2);\r\n+        code.tab(2).append(\"StringBuffer r = new StringBuffer\").\r\n+            openParen(true).append(\"b.length * 2\").closeParen().\r\n+            append(\";\").endl();\r\n+        code.tab(2).append(\"for\").openParen(true).\r\n+            append(\"int i = 0; i < b.length; i++\").closeParen().endl();\r\n+        code.tab(3).append(\"for\").openParen(true).\r\n+            append(\"int j = 1; j >= 0; j--\").closeParen().endl();\r\n+        code.tab(4).append(\"r.append\").openParen(true).\r\n+            append(\"HEX[\").openParen(false).append(\"b[i] >> \").\r\n+            openParen(false).append(\"j * 4\").closeParen().closeParen().\r\n+            append(\" & 0xF]\").closeParen().append(\";\").endl();\r\n+        code.tab(2).append(\"return r.toString\").parens(). append(\";\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Code to test if two byte arrays are equal.\r\n+     */\r\n+    private String getEqualsByteArrayCode() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"private static boolean equals\").openParen(true).\r\n+            append(\"byte[] b1, byte[] b2\").closeParen().openBrace(2).endl();\r\n+        code.tab(2).append(\"if\").openParen(true).\r\n+            append(\"b1 == null && b2 == null\").closeParen().endl();\r\n+        code.tab(3).append(\"return true;\").endl();\r\n+        code.tab(2).append(\"if\").openParen(true).\r\n+            append(\"b1 == null || b2 == null\").closeParen().endl();\r\n+        code.tab(3).append(\"return false;\").endl();\r\n+        code.tab(2).append(\"if\").openParen(true).\r\n+            append(\"b1.length != b2.length\").closeParen().endl();\r\n+        code.tab(3).append(\"return false;\").endl();\r\n+        code.tab(2).append(\"for\").openParen(true).\r\n+            append(\"int i = 0; i < b1.length; i++\").closeParen().endl();\r\n+        code.tab(3).append(\"if\").openParen(true).\r\n+            append(\"b1[i] != b2[i]\").closeParen().endl();\r\n+        code.tab(4).append(\"return false;\").endl();\r\n+        code.tab(2).append(\"return true;\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    private String getHashCodeByteArrayCode() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"private static int hashCode\").openParen(true).\r\n+            append(\"byte[] b\").closeParen().openBrace(2).endl();\r\n+        code.tab(2).append(\"if\").openParen(true).append(\"b == null\").\r\n+            closeParen().endl();\r\n+        code.tab(3).append(\"return 0;\").endl();\r\n+        code.tab(2).append(\"int sum = 0;\").endl();\r\n+        code.tab(2).append(\"for\").openParen(true).\r\n+            append(\"int i = 0; i < b.length; i++\").closeParen().endl();\r\n+        code.tab(3).append(\"sum += b[i];\").endl();\r\n+        code.tab(2).append(\"return sum;\").endl();\r\n+        code.closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Code defining a tokenizer class.\r\n+     */\r\n+    private String getCustomTokenizerClass() {\r\n+        CodeFormat code = newCodeFormat();\r\n+        code.tab().append(\"protected static class \").\r\n+            append(TOKENIZER_CUSTOM).openBrace(2).endl();\r\n+        code.tab(2).append(\"private final String str;\").endl();\r\n+        code.tab(2).append(\"private int last;\").afterSection();\r\n+        code.tab(2).append(\"public Tokenizer(String str)\"). openBrace(3).endl();\r\n+        code.tab(3).append(\"this.str = str;\").endl();\r\n+        code.closeBrace(3).afterSection();\r\n+        code.tab(2).append(\"public String nextToken()\"). openBrace(3).endl();\r\n+        code.tab(3).append(\"int next = str.indexOf\").openParen(true).\r\n+            append(\"\\\"\").append(_token).append(\"\\\", last\").closeParen().\r\n+            append(\";\").endl();\r\n+        code.tab(3).append(\"String part;\").endl();\r\n+        code.tab(3).append(\"if\").openParen(true).append(\"next == -1\").\r\n+            closeParen().openBrace(4).endl();\r\n+        code.tab(4).append(\"part = str.substring\").openParen(true).\r\n+            append(\"last\").closeParen().append(\";\").endl();\r\n+        code.tab(4).append(\"last = str.length\").parens().append(\";\").\r\n+            endl().closeBrace(4);\r\n+        if (!code.getBraceOnSameLine())\r\n+            code.endl().tab(3);\r\n+        else code.append(\" \");\r\n+        code.append(\"else\").openBrace(4).endl();\r\n+        code.tab(4).append(\"part = str.substring\").openParen(true).\r\n+            append(\"last, next\").closeParen().append(\";\").endl();\r\n+        code.tab(4).append(\"last = next + \").append(_token.length()).\r\n+            append(\";\").endl().closeBrace(4).endl();\r\n+        code.tab(3).append(\"return part;\").endl();\r\n+        code.closeBrace(3);\r\n+        code.endl().closeBrace(2);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the file that this tool should output to.\r\n+     */\r\n+    private File getFile() {\r\n+        if (_meta == null)\r\n+            return null;\r\n+        String packageName = Strings.getPackageName(_meta.getObjectIdType());\r\n+        String fileName = Strings.getClassName(_meta.getObjectIdType())\r\n+            + \".java\";\r\n+        // if pc class in same package as oid class, try to find pc .java file\r\n+        File dir = null;\r\n+        if (_dir == null && Strings.getPackageName(_type).equals(packageName)) {\r\n+            dir = Files.getSourceFile(_type);\r\n+            if (dir != null)\r\n+                dir = dir.getParentFile();\r\n+        }\r\n+        if (dir == null)\r\n+            dir = Files.getPackageFile(_dir, packageName, true);\r\n+        return new File(dir, fileName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a copy of the correct code format.\r\n+     */\r\n+    private CodeFormat newCodeFormat() {\r\n+        return (_format == null) ? new CodeFormat()\r\n+            : (CodeFormat) _format.clone();\r\n+    }\r\n+\r\n+    /**\r\n+     * Usage: java org.apache.openjpa.enhance.ApplicationIdTool [option]*\r\n+     * &lt;class name | .java file | .class file | .jdo file&gt;+\r\n+     * Where the following options are recognized.\r\n+     * <ul>\r\n+     * <li><i>-properties/-p &lt;properties file&gt;</i>: The path to a OpenJPA\r\n+     * properties file containing information such as the license key,\r\n+     * as outlined in {@link Configuration}; optional.</li>\r\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\r\n+     * properties of the standard OpenJPA {@link OpenJPAConfiguration} can be\r\n+     * set by using their names and supplying a value; for example:\r\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\r\n+     * <li><i>-directory/-d &lt;output directory&gt;</i>: Path to the base\r\n+     * source directory. The package structure will be created beneath\r\n+     * this directory if necessary. If not specified, the tool will try\r\n+     * to locate the .java file in the CLASSPATH and output to the same\r\n+     * directory; failing that, it will use the current directory as\r\n+     * the base directory.\r\n+     * <li><i>-ignoreErrors/-i &lt;true/t | false/f&gt;</i>: If false, an\r\n+     * exception will be thrown if the tool encounters any class that\r\n+     * does not use application identity or uses the identity class of\r\n+     * its superclass; defaults to true.</li>\r\n+     * <li><i>-token/-t &lt;token&gt;</i>: The token to use to separate\r\n+     * stingified primary key field values in the stringified oid.</li>\r\n+     * <li><i>-name/-n &lt;id class name&gt;</i>: The name of the identity\r\n+     * class to generate. If this option is specified, you must only\r\n+     * give a single class argument. If the class metadata names an object\r\n+     * id class, this argument is ignored.</li>\r\n+     * <li><i>-suffix/-s &lt;id class suffix&gt;</i>: A string to suffix each\r\n+     * persistent class with to create the identity class name. This is\r\n+     * overridden by <code>-name</code> or by any identity class name\r\n+     * specified in metadata.</li>\r\n+     * <li><i>-codeFormat/-cf.&lt;property name&gt; &lt; property value&gt;</i>\r\n+     * : Arguments like this will be used to configure the bean\r\n+     * properties of the internal {@link CodeFormat}.</li>\r\n+     * </ul>\r\n+     * Each additional argument can be either the full class name of the\r\n+     * type to create an id class for, the path to the .java file for the type,\r\n+     * the path to the .class file for the type, or the path to a .jdo file\r\n+     * listing one or more types. If a .java file already exists for an\r\n+     * application id, it will be backed up to a file named\r\n+     * &lt;orig file name&gt;~.\r\n+     */\r\n+    public static void main(String[] args)\r\n+        throws IOException, ClassNotFoundException {\r\n+        Options opts = new Options();\r\n+        args = opts.setFromCmdLine(args);\r\n+        OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();\r\n+        try {\r\n+            if (!run(conf, args, opts))\r\n+                System.err.println(_loc.get(\"appid-usage\"));\r\n+        }\r\n+        finally {\r\n+            conf.close();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Run the application id tool with the given command-line and\r\n+     * given configuration. Returns false if invalid options were given.\r\n+     */\r\n+    public static boolean run(OpenJPAConfiguration conf, String[] args,\r\n+        Options opts) throws IOException, ClassNotFoundException {\r\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\r\n+            return false;\r\n+        Flags flags = new Flags();\r\n+        flags.ignoreErrors = opts.removeBooleanProperty\r\n+            (\"ignoreErrors\", \"i\", flags.ignoreErrors);\r\n+        flags.directory = Files.getFile(opts.removeProperty(\"directory\", \"d\",\r\n+            null), null);\r\n+        flags.token = opts.removeProperty(\"token\", \"t\", flags.token);\r\n+        flags.name = opts.removeProperty(\"name\", \"n\", flags.name);\r\n+        flags.suffix = opts.removeProperty(\"suffix\", \"s\", flags.suffix);\r\n+        // separate the properties for the customizer and code format\r\n+        Options formatOpts = new Options();\r\n+        Map.Entry entry;\r\n+        String key;\r\n+        for (Iterator itr = opts.entrySet().iterator(); itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            key = (String) entry.getKey();\r\n+            if (key.startsWith(\"codeFormat.\")) {\r\n+                formatOpts.put(key.substring(11), entry.getValue());\r\n+                itr.remove();\r\n+            } else if (key.startsWith(\"cf.\")) {\r\n+                formatOpts.put(key.substring(3), entry.getValue());\r\n+                itr.remove();\r\n+            }\r\n+        }\r\n+        if (!formatOpts.isEmpty()) {\r\n+            flags.format = new CodeFormat();\r\n+            formatOpts.setInto(flags.format);\r\n+        }\r\n+        Configurations.populateConfiguration(conf, opts);\r\n+        ClassLoader loader = conf.getClassResolverInstance().\r\n+            getClassLoader(ApplicationIdTool.class, null);\r\n+        return run(conf, args, flags, loader);\r\n+    }\r\n+\r\n+    /**\r\n+     * Run the tool. Returns false if invalid options were given.\r\n+     */\r\n+    public static boolean run(OpenJPAConfiguration conf, String[] args,\r\n+        Flags flags, ClassLoader loader)\r\n+        throws IOException, ClassNotFoundException {\r\n+        MetaDataRepository repos = new MetaDataRepository(conf);\r\n+        repos.setValidate(repos.VALIDATE_NONE, true);\r\n+        loadObjectIds(repos, flags.name == null && flags.suffix == null);\r\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\r\n+        Collection classes;\r\n+        if (args.length == 0) {\r\n+            log.info(_loc.get(\"running-all-classes\"));\r\n+            classes = repos.loadPersistentTypes(true, loader);\r\n+        } else {\r\n+            ClassArgParser cap = conf.getMetaDataRepository().\r\n+                getMetaDataFactory().newClassArgParser();\r\n+            cap.setClassLoader(loader);\r\n+            classes = new HashSet();\r\n+            for (int i = 0; i < args.length; i++)\r\n+                classes.addAll(Arrays.asList(cap.parseTypes(args[i])));\r\n+        }\r\n+        if (flags.name != null && classes.size() > 1)\r\n+            throw new UserException(_loc.get(\"name-mult-args\", classes));\r\n+        ApplicationIdTool tool;\r\n+        Class cls;\r\n+        ClassMetaData meta;\r\n+        BCClassLoader bc = new BCClassLoader(new Project());\r\n+        for (Iterator itr = classes.iterator(); itr.hasNext();) {\r\n+            cls = (Class) itr.next();\r\n+            log.info(_loc.get(\"appid-running\", cls));\r\n+            meta = repos.getMetaData(cls, null, false);\r\n+            setObjectIdType(meta, flags, bc);\r\n+            tool = new ApplicationIdTool(conf, cls, meta);\r\n+            tool.setDirectory(flags.directory);\r\n+            tool.setIgnoreErrors(flags.ignoreErrors);\r\n+            tool.setToken(flags.token);\r\n+            tool.setCodeFormat(flags.format);\r\n+            if (tool.run()) {\r\n+                log.info(_loc.get(\"appid-output\", tool.getFile()));\r\n+                tool.record();\r\n+            } else log.info(_loc.get(\"appid-norun\"));\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the object id type of the given metadata.\r\n+     */\r\n+    private static void setObjectIdType(ClassMetaData meta, Flags flags,\r\n+        BCClassLoader bc) throws ClassNotFoundException {\r\n+        if (meta == null || (meta.getObjectIdType() != null\r\n+            && (!meta.isOpenJPAIdentity() || flags.name == null))\r\n+            || getDeclaredPrimaryKeyFields(meta).length == 0)\r\n+            return;\r\n+        Class desc = meta.getDescribedType();\r\n+        Class cls = null;\r\n+        if (flags.name != null)\r\n+            cls = loadClass(desc, flags.name, bc);\r\n+        else if (flags.suffix != null)\r\n+            cls = loadClass(desc, desc.getName() + flags.suffix, bc);\r\n+        meta.setObjectIdType(cls, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the given class name even if it does not exist.\r\n+     */\r\n+    private static Class loadClass(Class context, String name,\r\n+        BCClassLoader bc) throws ClassNotFoundException {\r\n+        if (name.indexOf('.') == -1 && context.getName().indexOf('.') != -1)\r\n+            name = Strings.getPackageName(context) + \".\" + name;\r\n+        // first try with regular class loader\r\n+        ClassLoader loader = context.getClassLoader();\r\n+        if (loader == null)\r\n+            loader = Thread.currentThread().getContextClassLoader();\r\n+        try {\r\n+            return Class.forName(name, false, loader);\r\n+        } catch (Throwable t) {\r\n+        }\r\n+        // create class\r\n+        BCClass oid = bc.getProject().loadClass(name, null);\r\n+        oid.addDefaultConstructor();\r\n+        return Class.forName(name, false, bc);\r\n+    }\r\n+\r\n+    /**\r\n+     * Tell the metadata factory to load object id classes even if they don't\r\n+     * exist.\r\n+     */\r\n+    private static void loadObjectIds(MetaDataRepository repos, boolean fatal) {\r\n+        MetaDataFactory mdf = repos.getMetaDataFactory();\r\n+        if (mdf instanceof DelegatingMetaDataFactory)\r\n+            mdf = ((DelegatingMetaDataFactory) mdf).getInnermostDelegate();\r\n+        if (mdf instanceof ObjectIdLoader)\r\n+            ((ObjectIdLoader) mdf).setLoadObjectIds();\r\n+        else if (fatal)\r\n+            throw new InvalidStateException(_loc.get(\"factory-not-oidloader\")).\r\n+                setFatal(true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Run flags.\r\n+     */\r\n+    public static class Flags {\r\n+\r\n+        public File directory = null;\r\n+        public boolean ignoreErrors = true;\r\n+        public String token = TOKEN_DEFAULT;\r\n+        public CodeFormat format = null;\r\n+        public String name = null;\r\n+        public String suffix = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Interface implemented by metadata factories that can load non-existant\r\n+     * object id classes.\r\n+     */\r\n+    public static interface ObjectIdLoader {\r\n+\r\n+        /**\r\n+         * Turn on the loading of all identity classes, even if they don't\r\n+         * exist.\r\n+         */\r\n+        public void setLoadObjectIds();\r\n+    }\r\n+}\r"},{"sha":"504269432c18813e6d63f7f2b1cbf39983e19663","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","status":"added","additions":492,"deletions":0,"changes":492,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,492 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.io.Writer;\r\n+import java.util.Iterator;\r\n+import java.util.Set;\r\n+import java.util.TreeSet;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.util.CodeFormat;\r\n+import org.apache.openjpa.lib.util.Files;\r\n+import org.apache.openjpa.lib.util.ParameterTemplate;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Generates Java class code from metadata.\r\n+ *\r\n+ * @author Abe White\r\n+ * @author Stephen Kim\r\n+ * @nojavadoc\r\n+ * @since 3.0\r\n+ */\r\n+public class CodeGenerator {\r\n+\r\n+    private OpenJPAConfiguration _conf = null;\r\n+    private File _dir = null;\r\n+    private CodeFormat _format = null;\r\n+    private ClassMetaData _meta = null;\r\n+    private Class _type = null;\r\n+    private ParameterTemplate _code = null;\r\n+\r\n+    /**\r\n+     * Constructor. Supply configuration and class to generate code for.\r\n+     */\r\n+    public CodeGenerator(OpenJPAConfiguration conf, Class type) {\r\n+        this(conf, new MetaDataRepository(conf).\r\n+            getMetaData(type, null, true));\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. Supply configuration and metadata to generate code for.\r\n+     */\r\n+    public CodeGenerator(OpenJPAConfiguration conf, ClassMetaData meta) {\r\n+        _conf = conf;\r\n+        _meta = meta;\r\n+        _type = meta.getDescribedType();\r\n+    }\r\n+\r\n+    /**\r\n+     * The directory to write source to. Defaults to the current directory.\r\n+     * If the given directory does not match the package of the metadata, the\r\n+     * package structure will be created below the directory.\r\n+     */\r\n+    public File getCodeDirectory() {\r\n+        return _dir;\r\n+    }\r\n+\r\n+    /**\r\n+     * The directory to write source to. Defaults to the current directory.\r\n+     * If the given directory does not match the package of the metadata, the\r\n+     * package structure will be created below the directory.\r\n+     */\r\n+    public void setDirectory(File dir) {\r\n+        _dir = dir;\r\n+    }\r\n+\r\n+    /**\r\n+     * The code formatter for the generated Java code.\r\n+     */\r\n+    public CodeFormat getCodeFormat() {\r\n+        return _format;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the code formatter for the generated Java code.\r\n+     */\r\n+    public void setCodeFormat(CodeFormat format) {\r\n+        _format = format;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the type being generated.\r\n+     */\r\n+    public Class getType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return metadata for the type being generated.\r\n+     */\r\n+    public ClassMetaData getMetaData() {\r\n+        return _meta;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the generated code, or null if {@link #generateCode} has not\r\n+     * been called.\r\n+     */\r\n+    public String getCode() {\r\n+        return (_code == null) ? null : _code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes the generated code to the proper directory.\r\n+     */\r\n+    public void generateCode() {\r\n+        // setup parameters\r\n+        String className = Strings.getClassName(_type);\r\n+        String packageName = Strings.getPackageName(_type);\r\n+        String packageDec = \"\";\r\n+        if (packageName.length() > 0)\r\n+            packageDec = \"package \" + packageName + \";\";\r\n+        String extendsDec = \"\";\r\n+        String extendsName = \"\";\r\n+        if (!_type.getSuperclass().getName().equals(Object.class.getName())) {\r\n+            extendsName = Strings.getClassName(_type.getSuperclass());\r\n+            extendsDec = \"extends \" + extendsName;\r\n+        }\r\n+        String imports = getImports();\r\n+        String[] fieldCode = getFieldCode();\r\n+        String constructor = getConstructor();\r\n+        // get code template\r\n+        _code = new ParameterTemplate();\r\n+        String codeStr = getClassCode();\r\n+        if (codeStr != null) {\r\n+            _code.append(codeStr);\r\n+            _code.setParameter(\"packageDec\", packageDec);\r\n+            _code.setParameter(\"imports\", imports);\r\n+            _code.setParameter(\"className\", className);\r\n+            _code.setParameter(\"extendsDec\", extendsDec);\r\n+            _code.setParameter(\"constructor\", constructor);\r\n+            _code.setParameter(\"fieldDecs\", fieldCode[0]);\r\n+            _code.setParameter(\"fieldCode\", fieldCode[1]);\r\n+        } else _code.append(getClassCode(packageDec, imports, className,\r\n+            extendsName, constructor, fieldCode[0], fieldCode[1]));\r\n+    }\r\n+\r\n+    /**\r\n+     * Write the generated code to the proper file.\r\n+     */\r\n+    public void writeCode() throws IOException {\r\n+        if (_code == null)\r\n+            return;\r\n+        File file = getFile();\r\n+        Files.backup(file, false);\r\n+        _code.write(file);\r\n+    }\r\n+\r\n+    /**\r\n+     * Write the code to the specified {@link Writer}.\r\n+     */\r\n+    public void writeCode(Writer out) throws IOException {\r\n+        if (_code == null)\r\n+            return;\r\n+        _code.write(out);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the necessary imports for the class.\r\n+     */\r\n+    private String getImports() {\r\n+        Set pkgs = getImportPackages();\r\n+        CodeFormat imports = newCodeFormat();\r\n+        String base = Strings.getPackageName(_type);\r\n+        String pkg;\r\n+        for (Iterator itr = pkgs.iterator(); itr.hasNext();) {\r\n+            pkg = (String) itr.next();\r\n+            if (pkg.length() > 0 && !\"java.lang\".equals(pkg)\r\n+                && !base.equals(pkg)) {\r\n+                if (imports.length() > 0)\r\n+                    imports.endl();\r\n+                imports.append(\"import \").append(pkg).append(\".*;\");\r\n+            }\r\n+        }\r\n+        return imports.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the set of packages that needs to be imported for this code.\r\n+     */\r\n+    public Set getImportPackages() {\r\n+        Set pkgs = new TreeSet();\r\n+        pkgs.add(Strings.getPackageName(_type.getSuperclass()));\r\n+        FieldMetaData[] fields = _meta.getDeclaredFields();\r\n+        for (int i = 0; i < fields.length; i++)\r\n+            pkgs.add(Strings.getPackageName(fields[i].getDeclaredType()));\r\n+        fields = _meta.getPrimaryKeyFields();\r\n+        for (int i = 0; i < fields.length; i++)\r\n+            pkgs.add(Strings.getPackageName(fields[i].getDeclaredType()));\r\n+        return pkgs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return code for a primary key constructor for the given class.\r\n+     */\r\n+    private String getConstructor() {\r\n+        FieldMetaData[] fields = _meta.getPrimaryKeyFields();\r\n+        if (fields.length == 0)\r\n+            return \"\";\r\n+        CodeFormat cons = newCodeFormat();\r\n+        CodeFormat body = newCodeFormat();\r\n+        // public <class> (\r\n+        cons.tab().append(\"public \").append(Strings.getClassName(_type));\r\n+        cons.openParen(true);\r\n+        // append args to constructor, and build up body at same time\r\n+        String propertyName;\r\n+        String fieldType;\r\n+        for (int i = 0; i < fields.length; i++) {\r\n+            propertyName = fields[i].getName();\r\n+            if (propertyName.startsWith(\"_\"))\r\n+                propertyName = propertyName.substring(1);\r\n+            fieldType = Strings.getClassName(fields[i].getDeclaredType());\r\n+            if (i > 0)\r\n+                cons.append(\", \");\r\n+            cons.append(fieldType).append(\" \").append(propertyName);\r\n+            if (_meta.getPCSuperclass() == null) {\r\n+                if (i > 0)\r\n+                    body.endl();\r\n+                body.tab(2);\r\n+                if (propertyName.equals(fields[i].getName()))\r\n+                    body.append(\"this.\");\r\n+                body.append(fields[i].getName());\r\n+                body.append(\" = \").append(propertyName).append(\";\");\r\n+            } else {\r\n+                // super(...);\r\n+                if (i == 0)\r\n+                    body.tab(2).append(\"super\").openParen(true);\r\n+                else body.append(\", \");\r\n+                body.append(propertyName);\r\n+                if (i == fields.length - 1)\r\n+                    body.closeParen().append(\";\");\r\n+            }\r\n+        }\r\n+        cons.closeParen();\r\n+        cons.openBrace(2).endl();\r\n+        cons.append(body.toString()).endl();\r\n+        cons.closeBrace(2);\r\n+        return cons.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the Java declaration and access method code for all declared\r\n+     * fields.\r\n+     */\r\n+    private String[] getFieldCode() {\r\n+        CodeFormat decs = newCodeFormat();\r\n+        CodeFormat code = newCodeFormat();\r\n+        FieldMetaData[] fields = _meta.getDeclaredFields();\r\n+        for (int i = 0; i < fields.length; i++)\r\n+            appendFieldCode(fields[i], decs, code);\r\n+        fields = _meta.getDeclaredUnmanagedFields();\r\n+        for (int i = 0; i < fields.length; i++)\r\n+            appendFieldCode(fields[i], decs, code);\r\n+        return new String[]{ decs.toString(), code.toString() };\r\n+    }\r\n+\r\n+    /**\r\n+     * Append the declaration and code for the given field to the given buffers.\r\n+     */\r\n+    private void appendFieldCode(FieldMetaData fmd, CodeFormat decs,\r\n+        CodeFormat code) {\r\n+        String fieldName = fmd.getName();\r\n+        String capFieldName = StringUtils.capitalise(fieldName);\r\n+        String propertyName = fieldName;\r\n+        if (propertyName.startsWith(\"_\"))\r\n+            propertyName = propertyName.substring(1);\r\n+        String fieldType = Strings.getClassName(fmd.getDeclaredType());\r\n+        String fieldValue = getInitialValue(fmd);\r\n+        if (fieldValue == null) {\r\n+            if (\"Set\".equals(fieldType))\r\n+                fieldValue = \"new HashSet\" + decs.getParens();\r\n+            else if (\"TreeSet\".equals(fieldType))\r\n+                fieldValue = \"new TreeSet\" + decs.getParens();\r\n+            else if (\"Collection\".equals(fieldType))\r\n+                fieldValue = \"new ArrayList\" + decs.getParens();\r\n+            else if (\"Map\".equals(fieldType))\r\n+                fieldValue = \"new HashMap\" + decs.getParens();\r\n+            else if (\"TreeMap\".equals(fieldType))\r\n+                fieldValue = \"new TreeMap\" + decs.getParens();\r\n+            else if (fmd.getDeclaredTypeCode() == JavaTypes.COLLECTION\r\n+                || fmd.getDeclaredTypeCode() == JavaTypes.MAP)\r\n+                fieldValue = \"new \" + fieldType + decs.getParens();\r\n+            else fieldValue = \"\";\r\n+        }\r\n+        if (fieldValue.length() > 0)\r\n+            fieldValue = \" = \" + fieldValue;\r\n+        String custom = getDeclaration(fmd);\r\n+        if (decs.length() > 0)\r\n+            decs.endl();\r\n+        ParameterTemplate templ;\r\n+        if (custom != null) {\r\n+            templ = new ParameterTemplate();\r\n+            templ.append(custom);\r\n+            templ.setParameter(\"fieldName\", fieldName);\r\n+            templ.setParameter(\"capFieldName\", capFieldName);\r\n+            templ.setParameter(\"propertyName\", propertyName);\r\n+            templ.setParameter(\"fieldType\", fieldType);\r\n+            templ.setParameter(\"fieldValue\", fieldValue);\r\n+            decs.append(templ.toString());\r\n+        } else {\r\n+            decs.tab().append(\"private \").append(fieldType).\r\n+                append(\" \").append(fieldName).append(fieldValue). append(\";\");\r\n+        }\r\n+        custom = getFieldCode(fmd);\r\n+        if (code.length() > 0)\r\n+            code.afterSection();\r\n+        if (custom != null) {\r\n+            templ = new ParameterTemplate();\r\n+            templ.append(custom);\r\n+            templ.setParameter(\"fieldName\", fieldName);\r\n+            templ.setParameter(\"capFieldName\", capFieldName);\r\n+            templ.setParameter(\"propertyName\", propertyName);\r\n+            templ.setParameter(\"fieldType\", fieldType);\r\n+            templ.setParameter(\"fieldValue\", fieldValue);\r\n+            code.append(templ.toString());\r\n+        } else {\r\n+            // getter\r\n+            code.tab().append(\"public \").append(fieldType).append(\" \");\r\n+            if (\"boolean\".equalsIgnoreCase(fieldType))\r\n+                code.append(\"is\");\r\n+            else code.append(\"get\");\r\n+            code.append(capFieldName).parens();\r\n+            code.openBrace(2).endl();\r\n+            code.tab(2).append(\"return \").append(fieldName).\r\n+                append(\";\").endl();\r\n+            code.closeBrace(2).afterSection();\r\n+            // setter\r\n+            code.tab().append(\"public void set\").append(capFieldName);\r\n+            code.openParen(true).append(fieldType).append(\" \").\r\n+                append(propertyName).closeParen();\r\n+            code.openBrace(2).endl();\r\n+            code.tab(2);\r\n+            if (propertyName.equals(fieldName))\r\n+                code.append(\"this.\");\r\n+            code.append(fieldName).append(\" = \").append(propertyName).\r\n+                append(\";\").endl();\r\n+            code.closeBrace(2);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a code template for a generated Java class.\r\n+     */\r\n+    private String getClassCode(String packageDec, String imports,\r\n+        String className, String extendsName, String constructor,\r\n+        String fieldDecs, String fieldCode) {\r\n+        CodeFormat code = newCodeFormat();\r\n+        if (packageDec.length() > 0)\r\n+            code.append(packageDec).afterSection();\r\n+        if (imports.length() > 0)\r\n+            code.append(imports).afterSection();\r\n+        code.append(\"/**\").endl(). append(\" * Auto-generated by:\").endl().\r\n+            append(\" * \").append(getClass().getName()).endl().\r\n+            append(\" */\").endl();\r\n+        code.append(\"public class \").append(className);\r\n+        if (extendsName.length() > 0)\r\n+            code.extendsDec(1).append(\" \").append(extendsName);\r\n+        openClassBrace(code);\r\n+        if (fieldDecs.length() > 0)\r\n+            code.append(fieldDecs).afterSection();\r\n+        // default constructor\r\n+        code.tab().append(\"public \").append(className).parens();\r\n+        code.openBrace(2).endl().closeBrace(2);\r\n+        if (constructor.length() > 0)\r\n+            code.afterSection().append(constructor);\r\n+        if (fieldCode.length() > 0)\r\n+            code.afterSection().append(fieldCode);\r\n+        code.endl();\r\n+        closeClassBrace(code);\r\n+        return code.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Append the opening code-level brace to the code; this can be\r\n+     * overridden to add code to the top of the class.\r\n+     */\r\n+    protected void openClassBrace(CodeFormat code) {\r\n+        code.openBrace(1).endl();\r\n+    }\r\n+\r\n+    /**\r\n+     * Append the closing code-level brace to the code; this can be\r\n+     * overridden to add code to the bottom of the class.\r\n+     */\r\n+    protected void closeClassBrace(CodeFormat code) {\r\n+        code.closeBrace(1);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return Java file to write to.\r\n+     */\r\n+    public File getFile() {\r\n+        String packageName = Strings.getPackageName(_type);\r\n+        String fileName = Strings.getClassName(_type) + \".java\";\r\n+        File dir = Files.getPackageFile(_dir, packageName, true);\r\n+        return new File(dir, fileName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a copy of the internal code format.\r\n+     */\r\n+    protected CodeFormat newCodeFormat() {\r\n+        if (_format == null)\r\n+            return new CodeFormat();\r\n+        return (CodeFormat) _format.clone();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a code template for the given class, or null to use the standard\r\n+     * system-generated Java code. To facilitate template reuse, the\r\n+     * following parameters can appear in the template; the proper values\r\n+     * will be subtituted by the system:\r\n+     * <ul>\r\n+     * <li>${packageDec}: The package declaration, in the form\r\n+     * \"package &lt;package name &gt;;\", or empty string if no package.</li>\r\n+     * <li>${imports}: Imports for the packages used by the declared\r\n+     * field types.</li>\r\n+     * <li>${className}: The name of the class, without package.</li>\r\n+     * <li>${extendsDec}: Extends declaration, in the form\r\n+     * \"extends &lt;superclass&gt;\", or empty string if no superclass.</li>\r\n+     * <li>${constructor}: A constructor that takes in all primary key fields\r\n+     * of the class, or empty string if the class uses datastore identity.</li>\r\n+     * <li>${fieldDecs}: Declarations of all the declared fields.</li>\r\n+     * <li>${fieldCode}: Get/set methods for all the declared fields.</li>\r\n+     * </ul> Returns null by default.\r\n+     */\r\n+    protected String getClassCode() {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return code for the initial value for the given field, or null to use\r\n+     * the default generated by the system. Returns null by default.\r\n+     */\r\n+    protected String getInitialValue(FieldMetaData field) {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a code template for the declaration of the given field, or null\r\n+     * to use the system-generated default Java code.\r\n+     * To facilitate template reuse, the following parameters can appear in\r\n+     * your template; the proper values will be subtituted by the system:\r\n+     * <ul>\r\n+     * <li>${fieldName}: The name of the field.</li>\r\n+     * <li>${capFieldName}: The capitalized field name.</li>\r\n+     * <li>${propertyName}: The field name without leading '_', if any.</li>\r\n+     * <li>${fieldType}: The field's type name.</li>\r\n+     * <li>${fieldValue}: The field's initial value, in the form\r\n+     * \" = &lt;value&gt;\", or empty string if none.</li>\r\n+     * </ul> Returns null by default.\r\n+     */\r\n+    protected String getDeclaration(FieldMetaData field) {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a code template for the get/set methods of the given field, or\r\n+     * null to use the system-generated default Java code.\r\n+     * To facilitate template reuse, the following parameters can appear in\r\n+     * your template; the proper values will be subtituted by the system:\r\n+     * <ul>\r\n+     * <li>${fieldName}: The name of the field.</li>\r\n+     * <li>${capFieldName}: The capitalized field name.</li>\r\n+     * <li>${propertyName}: The field name without leading '_', if any.</li>\r\n+     * <li>${fieldType}: The field's type name.</li>\r\n+     * <li>${fieldValue}: The field's initial value, in the form\r\n+     * \"= &lt;value&gt;\", or empty string if none.</li>\r\n+     * </ul>\r\n+     */\r\n+    protected String getFieldCode(FieldMetaData field) {\r\n+        return null;\r\n+    }\r\n+}\r"},{"sha":"c9aeced583821fe70ea3c960e31749afe49e8bf4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,135 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Interface for dynamically generated classes. Certain getters/setters\r\n+ * may either return null or throw an exception depending on the\r\n+ * {@link DynamicStorageGenerator}'s field policy.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ * @since 3.2.0\r\n+ */\r\n+public interface DynamicStorage {\r\n+\r\n+    /**\r\n+     * Return the number of fields, regardless of type\r\n+     */\r\n+    public int getFieldCount();\r\n+\r\n+    /**\r\n+     * Return the number of object fields\r\n+     */\r\n+    public int getObjectCount();\r\n+\r\n+    /**\r\n+     * Factory method for getting new instances of the same definition.\r\n+     */\r\n+    public DynamicStorage newInstance();\r\n+\r\n+    /**\r\n+     * Get the boolean at the given index.\r\n+     */\r\n+    public boolean getBoolean(int field);\r\n+\r\n+    /**\r\n+     * Set the boolean at the given index.\r\n+     */\r\n+    public void setBoolean(int field, boolean val);\r\n+\r\n+    /**\r\n+     * Get the byte at the given index.\r\n+     */\r\n+    public byte getByte(int field);\r\n+\r\n+    /**\r\n+     * Set the byte at the given index.\r\n+     */\r\n+    public void setByte(int field, byte val);\r\n+\r\n+    /**\r\n+     * Get the char at the given index.\r\n+     */\r\n+    public char getChar(int field);\r\n+\r\n+    /**\r\n+     * Set the char at the given index.\r\n+     */\r\n+    public void setChar(int field, char val);\r\n+\r\n+    /**\r\n+     * Get the double at the given index.\r\n+     */\r\n+    public double getDouble(int field);\r\n+\r\n+    /**\r\n+     * Set the double at the given index.\r\n+     */\r\n+    public void setDouble(int field, double val);\r\n+\r\n+    /**\r\n+     * Get the float at the given index.\r\n+     */\r\n+    public float getFloat(int field);\r\n+\r\n+    /**\r\n+     * Set the float at the given index.\r\n+     */\r\n+    public void setFloat(int field, float val);\r\n+\r\n+    /**\r\n+     * Get the int at the given index.\r\n+     */\r\n+    public int getInt(int field);\r\n+\r\n+    /**\r\n+     * Set the int at the given index.\r\n+     */\r\n+    public void setInt(int field, int val);\r\n+\r\n+    /**\r\n+     * Get the long at the given index.\r\n+     */\r\n+    public long getLong(int field);\r\n+\r\n+    /**\r\n+     * Set the long at the given index.\r\n+     */\r\n+    public void setLong(int field, long val);\r\n+\r\n+    /**\r\n+     * Get the short at the given index.\r\n+     */\r\n+    public short getShort(int field);\r\n+\r\n+    /**\r\n+     * Set the short at the given index.\r\n+     */\r\n+    public void setShort(int field, short val);\r\n+\r\n+    /**\r\n+     * Get the object at the given index.\r\n+     */\r\n+    public Object getObject(int field);\r\n+\r\n+    /**\r\n+     * Set the object at the given index.\r\n+     */\r\n+    public void setObject(int field, Object val);\r\n+\r\n+    /**\r\n+     * Ensure object capacity\r\n+     */\r\n+    public void initialize();\r\n+}\r"},{"sha":"899792efaecd21fbd4f53ce3f665f0c371a7f2f2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","status":"added","additions":498,"deletions":0,"changes":498,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,498 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.lang.reflect.Constructor;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCClassLoader;\r\n+import serp.bytecode.BCField;\r\n+import serp.bytecode.BCMethod;\r\n+import serp.bytecode.Code;\r\n+import serp.bytecode.Constants;\r\n+import serp.bytecode.Instruction;\r\n+import serp.bytecode.JumpInstruction;\r\n+import serp.bytecode.LoadInstruction;\r\n+import serp.bytecode.Project;\r\n+import serp.bytecode.TableSwitchInstruction;\r\n+\r\n+/**\r\n+ * Factory for creating new {@link DynamicStorage} classes. Can be\r\n+ * extended to decorate/modify the generated instances behavior.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ * @since 3.2.0\r\n+ */\r\n+public class DynamicStorageGenerator {\r\n+\r\n+    // prefix for generic generated classes.\r\n+    private static final String PREFIX = \"openjpastorage$\";\r\n+\r\n+    /**\r\n+     * Constant to throw an exception on invalid index passed to type set/get\r\n+     * methods\r\n+     */\r\n+    protected static final int POLICY_EXCEPTION = 0;\r\n+\r\n+    /**\r\n+     * Constant to not generate type set/get methods.\r\n+     */\r\n+    protected static final int POLICY_EMPTY = 1;\r\n+\r\n+    /**\r\n+     * Constant to be as silent as possible during invalid index passed\r\n+     * to set/get type methods. On getting an Object, for example,\r\n+     * null will be returned.\r\n+     * However, on primitive gets, an exception will be thrown.\r\n+     */\r\n+    protected static final int POLICY_SILENT = 2;\r\n+    // wrappers for primitive types\r\n+    private static final Class[][] WRAPPERS = new Class[][]{\r\n+        { boolean.class, Boolean.class }, { byte.class, Byte.class },\r\n+        { char.class, Character.class }, { int.class, Integer.class },\r\n+        { short.class, Short.class }, { long.class, Long.class },\r\n+        { float.class, Float.class }, { double.class, Double.class }, };\r\n+    // primitive types\r\n+    private static final int[] TYPES = new int[]{\r\n+        JavaTypes.BOOLEAN, JavaTypes.BYTE, JavaTypes.CHAR, JavaTypes.INT,\r\n+        JavaTypes.SHORT, JavaTypes.LONG, JavaTypes.FLOAT, JavaTypes.DOUBLE,\r\n+        JavaTypes.OBJECT };\r\n+    // the project/classloader for the classes.\r\n+    private final Project _project = new Project();\r\n+    private final BCClassLoader _loader = new BCClassLoader(_project,\r\n+        DynamicStorage.class.getClassLoader());\r\n+\r\n+    /**\r\n+     * Generate a generic {@link DynamicStorage} instance with the given\r\n+     * array of {@link JavaTypes} constants and the given object as\r\n+     * the user key for generation.\r\n+     */\r\n+    public DynamicStorage generateStorage(int[] types, Object obj) {\r\n+        if (obj == null)\r\n+            return null;\r\n+        String name = getClassName(obj);\r\n+        BCClass bc = _project.loadClass(name);\r\n+        declareClasses(bc);\r\n+        bc.addDefaultConstructor().makePublic();\r\n+        int objectCount = declareFields(types, bc);\r\n+        addFactoryMethod(bc);\r\n+        addFieldCount(bc, types, objectCount);\r\n+        addSetMethods(bc, types, objectCount);\r\n+        addGetMethods(bc, types);\r\n+        addInitialize(bc, objectCount);\r\n+        decorate(obj, bc, types);\r\n+        return createFactory(bc);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a class name to use for the given user key. By default,\r\n+     * returns the stringified key prefixed by PREFIX.\r\n+     */\r\n+    protected String getClassName(Object obj) {\r\n+        return PREFIX + obj.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the default field ACCESS constant for generated fields from\r\n+     * {@link Constants}.\r\n+     */\r\n+    protected int getFieldAccess() {\r\n+        return Constants.ACCESS_PRIVATE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the name for the generated field at the given index. Returns\r\n+     * <code>\"field\" + i</code> by default.\r\n+     */\r\n+    protected String getFieldName(int index) {\r\n+        return \"field\" + index;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the policy constant for how to create type methods.\r\n+     */\r\n+    protected int getCreateFieldMethods(int type) {\r\n+        return POLICY_EXCEPTION;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decorate the generated class.\r\n+     */\r\n+    protected void decorate(Object obj, BCClass cls, int[] types) {\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a stub factory instance for the given class.\r\n+     */\r\n+    protected DynamicStorage createFactory(BCClass bc) {\r\n+        try {\r\n+            Class cls = Class.forName(bc.getName(), false, _loader);\r\n+            Constructor cons = cls.getConstructor((Class[]) null);\r\n+            DynamicStorage data = (DynamicStorage) cons.newInstance\r\n+                ((Object[]) null);\r\n+            _project.clear(); // remove old refs\r\n+            return data;\r\n+        } catch (Throwable t) {\r\n+            throw new InternalException(\"cons-access\", t).setFatal(true);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Add interface or superclass declarations to the generated class.\r\n+     */\r\n+    protected void declareClasses(BCClass bc) {\r\n+        bc.declareInterface(DynamicStorage.class);\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement the newInstance method.\r\n+     */\r\n+    private void addFactoryMethod(BCClass bc) {\r\n+        BCMethod method = bc.declareMethod(\"newInstance\",\r\n+            DynamicStorage.class, null);\r\n+        Code code = method.getCode(true);\r\n+        code.anew().setType(bc);\r\n+        code.dup();\r\n+        code.invokespecial().setMethod(bc.getName(), \"<init>\", \"void\", null);\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement getFieldCount/getObjectCount.\r\n+     */\r\n+    private void addFieldCount(BCClass bc, int[] types, int objectCount) {\r\n+        BCMethod method = bc.declareMethod(\"getFieldCount\", int.class, null);\r\n+        Code code = method.getCode(true);\r\n+        code.constant().setValue(types.length);\r\n+        code.ireturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+        method = bc.declareMethod(\"getObjectCount\", int.class, null);\r\n+        code = method.getCode(true);\r\n+        code.constant().setValue(objectCount);\r\n+        code.ireturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement initialize.\r\n+     */\r\n+    private void addInitialize(BCClass bc, int objectCount) {\r\n+        BCMethod meth = bc.declareMethod(\"initialize\", void.class, null);\r\n+        Code code = meth.getCode(true);\r\n+        JumpInstruction ifins = null;\r\n+        if (objectCount > 0) {\r\n+            // if (objects == null)\r\n+            // objects = new Object[objectCount];\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"objects\", Object[].class);\r\n+            ifins = code.ifnonnull();\r\n+            code.aload().setThis();\r\n+            code.constant().setValue(objectCount);\r\n+            code.anewarray().setType(Object.class);\r\n+            code.putfield().setField(\"objects\", Object[].class);\r\n+        }\r\n+        Instruction ins = code.vreturn();\r\n+        if (ifins != null)\r\n+            ifins.setTarget(ins);\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Declare the primitive fields and the object field.\r\n+     */\r\n+    private int declareFields(int[] types, BCClass bc) {\r\n+        bc.declareField(\"objects\", Object[].class).makePrivate();\r\n+        int objectCount = 0;\r\n+        Class type;\r\n+        for (int i = 0; i < types.length; i++) {\r\n+            type = forType(types[i]);\r\n+            if (type == Object.class)\r\n+                objectCount++;\r\n+            else {\r\n+                BCField field = bc.declareField(getFieldName(i), type);\r\n+                field.setAccessFlags(getFieldAccess());\r\n+            }\r\n+        }\r\n+        return objectCount;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add all the typed set by index method.\r\n+     */\r\n+    private void addSetMethods(BCClass bc, int[] types, int totalObjects) {\r\n+        for (int i = 0; i < TYPES.length; i++)\r\n+            addSetMethod(TYPES[i], bc, types, totalObjects);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add the typed set by index method.\r\n+     */\r\n+    private void addSetMethod(int typeCode, BCClass bc, int[] types,\r\n+        int totalObjects) {\r\n+        int handle = getCreateFieldMethods(typeCode);\r\n+        if (handle == POLICY_EMPTY)\r\n+            return;\r\n+        Class type = forType(typeCode);\r\n+        // public void set<Type> (int field, <type> val)\r\n+        String name = Object.class.equals(type) ? \"Object\" :\r\n+            StringUtils.capitalize(type.getName());\r\n+        name = \"set\" + name;\r\n+        BCMethod method = bc.declareMethod(name, void.class,\r\n+            new Class[]{ int.class, type });\r\n+        method.makePublic();\r\n+        Code code = method.getCode(true);\r\n+        // switch (field)\r\n+        code.aload().setParam(0);\r\n+        TableSwitchInstruction tabins = code.tableswitch();\r\n+        tabins.setLow(0);\r\n+        tabins.setHigh(types.length - 1);\r\n+        Instruction defaultIns;\r\n+        if (handle == POLICY_SILENT)\r\n+            defaultIns = code.vreturn();\r\n+        else defaultIns = throwException\r\n+            (code, IllegalArgumentException.class);\r\n+        tabins.setDefaultTarget(defaultIns);\r\n+        int objectCount = 0;\r\n+        for (int i = 0; i < types.length; i++) {\r\n+            // default: throw new IllegalArgumentException\r\n+            if (!isCompatible(types[i], typeCode)) {\r\n+                tabins.addTarget(tabins.getDefaultTarget());\r\n+                continue;\r\n+            }\r\n+            tabins.addTarget(code.aload().setThis());\r\n+            if (typeCode >= JavaTypes.OBJECT) {\r\n+                // if (objects == null)\r\n+                // objects = new Object[totalObjects];\r\n+                code.aload().setThis();\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                JumpInstruction ifins = code.ifnonnull();\r\n+                code.aload().setThis();\r\n+                code.constant().setValue(totalObjects);\r\n+                code.anewarray().setType(Object.class);\r\n+                code.putfield().setField(\"objects\", Object[].class);\r\n+                // objects[objectCount] = val;\r\n+                ifins.setTarget(code.aload().setThis());\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                code.constant().setValue(objectCount);\r\n+                code.aload().setParam(1);\r\n+                code.aastore();\r\n+                objectCount++;\r\n+            } else {\r\n+                // case i: fieldi = val;\r\n+                LoadInstruction load = code.xload();\r\n+                load.setType(type);\r\n+                load.setParam(1);\r\n+                code.putfield().setField(\"field\" + i, type);\r\n+            }\r\n+            // return\r\n+            code.vreturn();\r\n+        }\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add all typed get by index method for the given fields.\r\n+     */\r\n+    private void addGetMethods(BCClass bc, int[] types) {\r\n+        for (int i = 0; i < TYPES.length; i++)\r\n+            addGetMethod(TYPES[i], bc, types);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add typed get by index method.\r\n+     */\r\n+    private void addGetMethod(int typeCode, BCClass bc, int[] types) {\r\n+        int handle = getCreateFieldMethods(typeCode);\r\n+        if (handle == POLICY_EMPTY)\r\n+            return;\r\n+        Class type = forType(typeCode);\r\n+        // public <type> get<Type>Field(int field)\r\n+        String name = Object.class.equals(type) ? \"Object\" :\r\n+            StringUtils.capitalize(type.getName());\r\n+        name = \"get\" + name;\r\n+        BCMethod method = bc.declareMethod(name, type,\r\n+            new Class[]{ int.class });\r\n+        method.makePublic();\r\n+        Code code = method.getCode(true);\r\n+        // switch (field)\r\n+        code.aload().setParam(0);\r\n+        TableSwitchInstruction tabins = code.tableswitch();\r\n+        tabins.setLow(0);\r\n+        tabins.setHigh(types.length - 1);\r\n+        Instruction defaultIns = null;\r\n+        if (typeCode == JavaTypes.OBJECT && handle == POLICY_SILENT) {\r\n+            defaultIns = code.constant().setNull();\r\n+            code.areturn();\r\n+        } else defaultIns = throwException\r\n+            (code, IllegalArgumentException.class);\r\n+        tabins.setDefaultTarget(defaultIns);\r\n+        int objectCount = 0;\r\n+        for (int i = 0; i < types.length; i++) {\r\n+            // default: throw new IllegalArgumentException\r\n+            if (!isCompatible(types[i], typeCode)) {\r\n+                tabins.addTarget(tabins.getDefaultTarget());\r\n+                continue;\r\n+            }\r\n+            tabins.addTarget(code.aload().setThis());\r\n+            if (typeCode >= JavaTypes.OBJECT) {\r\n+                // if (objects == null)\r\n+                // return null;\r\n+                // return objects[objectCount];\r\n+                code.aload().setThis();\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                JumpInstruction ifins = code.ifnonnull();\r\n+                code.constant().setNull();\r\n+                code.areturn();\r\n+                ifins.setTarget(code.aload().setThis());\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                code.constant().setValue(objectCount);\r\n+                code.aaload();\r\n+                code.areturn();\r\n+                objectCount++;\r\n+            } else {\r\n+                // case i: return fieldi;\r\n+                code.getfield().setField(\"field\" + i, type);\r\n+                code.xreturn().setType(type);\r\n+            }\r\n+        }\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+    /////////////\r\n+    // Utilities\r\n+    /////////////\r\n+\r\n+    /**\r\n+     * Clear code associated with the given method signature, and return\r\n+     * the empty code. Will return null if the method should be empty.\r\n+     */\r\n+    protected Code replaceMethod(BCClass bc, String name, Class retType,\r\n+        Class[] args, boolean remove) {\r\n+        bc.removeDeclaredMethod(name, args);\r\n+        BCMethod meth = bc.declareMethod(name, retType, args);\r\n+        Code code = meth.getCode(true);\r\n+        if (!remove)\r\n+            return code;\r\n+        code.xreturn().setType(retType);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a bean field of the given name and type.\r\n+     */\r\n+    protected BCField addBeanField(BCClass bc, String name, Class type) {\r\n+        if (name == null)\r\n+            throw new IllegalArgumentException(\"name == null\");\r\n+        // private <type> <name>\r\n+        BCField field = bc.declareField(name, type);\r\n+        field.setAccessFlags(getFieldAccess());\r\n+        name = StringUtils.capitalize(name);\r\n+        // getter\r\n+        String prefix = (type == boolean.class) ? \"is\" : \"get\";\r\n+        BCMethod method = bc.declareMethod(prefix + name, type, null);\r\n+        method.makePublic();\r\n+        Code code = method.getCode(true);\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(field);\r\n+        code.xreturn().setType(type);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+        // setter\r\n+        method = bc.declareMethod(\"set\" + name, void.class,\r\n+            new Class[]{ type });\r\n+        method.makePublic();\r\n+        code = method.getCode(true);\r\n+        code.aload().setThis();\r\n+        code.xload().setParam(0).setType(type);\r\n+        code.putfield().setField(field);\r\n+        code.vreturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+        return field;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if the given field type and storage type are compatible.\r\n+     */\r\n+    protected boolean isCompatible(int fieldType, int storageType) {\r\n+        if (storageType == JavaTypes.OBJECT)\r\n+            return fieldType >= JavaTypes.OBJECT;\r\n+        return fieldType == storageType;\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw an exception of the given type.\r\n+     */\r\n+    protected Instruction throwException(Code code, Class type) {\r\n+        Instruction ins = code.anew().setType(type);\r\n+        code.dup();\r\n+        code.invokespecial().setMethod(type, \"<init>\", void.class, null);\r\n+        code.athrow();\r\n+        return ins;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the proper type for the given {@link JavaTypes} constant.\r\n+     */\r\n+    protected Class forType(int type) {\r\n+        switch (type) {\r\n+            case JavaTypes.BOOLEAN:\r\n+                return boolean.class;\r\n+            case JavaTypes.BYTE:\r\n+                return byte.class;\r\n+            case JavaTypes.CHAR:\r\n+                return char.class;\r\n+            case JavaTypes.INT:\r\n+                return int.class;\r\n+            case JavaTypes.SHORT:\r\n+                return short.class;\r\n+            case JavaTypes.LONG:\r\n+                return long.class;\r\n+            case JavaTypes.FLOAT:\r\n+                return float.class;\r\n+            case JavaTypes.DOUBLE:\r\n+                return double.class;\r\n+        }\r\n+        return Object.class;\r\n+    }\r\n+\r\n+    /**\r\n+     * get the wrapper for the given {@link JavaTypes} constant.\r\n+     */\r\n+    protected Class getWrapper(int type) {\r\n+        return getWrapper(forType(type));\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the wrapper for the given type.\r\n+     */\r\n+    protected Class getWrapper(Class c) {\r\n+        for (int i = 0; i < WRAPPERS.length; i++) {\r\n+            if (WRAPPERS[i][0].equals(c))\r\n+                return WRAPPERS[i][1];\r\n+        }\r\n+        return c;\r\n+    }\r\n+}\r"},{"sha":"50335a0d46914d50adc349b6965eecc19e457161","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,69 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Consumes persistent field values.\r\n+ */\r\n+public interface FieldConsumer {\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeBooleanField(int fieldIndex, boolean value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeCharField(int fieldIndex, char value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeByteField(int fieldIndex, byte value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeShortField(int fieldIndex, short value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeIntField(int fieldIndex, int value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeLongField(int fieldIndex, long value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeFloatField(int fieldIndex, float value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeDoubleField(int fieldIndex, double value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeStringField(int fieldIndex, String value);\r\n+\r\n+    /**\r\n+     * Set the value of the given field.\r\n+     */\r\n+    void storeObjectField(int fieldIndex, Object value);\r\n+}\r"},{"sha":"9ab1f27ce73d26c3c928185938ce3301bf4df661","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","status":"added","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,20 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Manages persistent fields.\r\n+ */\r\n+public interface FieldManager extends FieldConsumer, FieldSupplier {\r\n+\r\n+}\r"},{"sha":"fda09b08c9d5adc6c0e1a10cb8ed5f6a82506e72","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,69 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * Supplies persistent field values.\r\n+ */\r\n+public interface FieldSupplier {\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    boolean fetchBooleanField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    char fetchCharField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    byte fetchByteField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    short fetchShortField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    int fetchIntField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    long fetchLongField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    float fetchFloatField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    double fetchDoubleField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    String fetchStringField(int fieldIndex);\r\n+\r\n+    /**\r\n+     * Return the value of the given field.\r\n+     */\r\n+    Object fetchObjectField(int fieldIndex);\r\n+}\r"},{"sha":"e2c00471bfe113fcb71374dddc554bf38c7356ec","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"added","additions":1024,"deletions":0,"changes":1024,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1024 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.AbstractPCData;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchState;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCData;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCField;\r\n+import serp.bytecode.BCMethod;\r\n+import serp.bytecode.Code;\r\n+import serp.bytecode.Constants;\r\n+import serp.bytecode.ExceptionHandler;\r\n+import serp.bytecode.Instruction;\r\n+import serp.bytecode.JumpInstruction;\r\n+import serp.bytecode.LookupSwitchInstruction;\r\n+\r\n+/**\r\n+ * Generates {@link PCData} instances which avoid primitve wrappers\r\n+ * to optimize memory use and performance at the cost of slightly higher\r\n+ * startup time.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ * @since 3.2\r\n+ */\r\n+public class PCDataGenerator extends DynamicStorageGenerator {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (PCDataGenerator.class);\r\n+    protected static final String POSTFIX = \"$openjpapcdata\";\r\n+    private final Map _generated = new ConcurrentHashMap();\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private final Log _log;\r\n+\r\n+    public PCDataGenerator(OpenJPAConfiguration conf) {\r\n+        _conf = conf;\r\n+        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the configuration.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a {@link PCData} instance for the given oid and metadata.\r\n+     */\r\n+    public PCData generatePCData(Object oid, ClassMetaData meta) {\r\n+        if (meta == null)\r\n+            return null;\r\n+        Class type = meta.getDescribedType();\r\n+        DynamicStorage storage = (DynamicStorage) _generated.get(type);\r\n+        if (storage == null) {\r\n+            storage = generateStorage(meta);\r\n+            _generated.put(type, storage);\r\n+            if (_log.isDebugEnabled())\r\n+                _log.debug(_loc.get(\"pcdata-created\", type.getName(), meta));\r\n+        }\r\n+        DynamicPCData data = (DynamicPCData) storage.newInstance();\r\n+        data.setId(oid);\r\n+        data.setStorageGenerator(this);\r\n+        finish(data, meta);\r\n+        return data;\r\n+    }\r\n+\r\n+    /**\r\n+     * Actually generate the factory instance.\r\n+     */\r\n+    private DynamicStorage generateStorage(ClassMetaData meta) {\r\n+        if (_log.isDebugEnabled())\r\n+            _log.debug(_loc.get(\"pcdata-generate\", meta));\r\n+        FieldMetaData[] fields = meta.getFields();\r\n+        int[] types = new int[fields.length];\r\n+        for (int i = 0; i < types.length; i++)\r\n+            types[i] = replaceType(fields[i]);\r\n+        return generateStorage(types, meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Perform any final actions before the pcdata is returned to client code.\r\n+     */\r\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n+    }\r\n+\r\n+    protected int getCreateFieldMethods(int typeCode) {\r\n+        if (typeCode >= JavaTypes.OBJECT)\r\n+            return POLICY_SILENT;\r\n+        // don't bother creating set/get<Primitive> methods\r\n+        return POLICY_EMPTY;\r\n+    }\r\n+\r\n+    protected void declareClasses(BCClass bc) {\r\n+        super.declareClasses(bc);\r\n+        bc.declareInterface(DynamicPCData.class);\r\n+        bc.setSuperclass(AbstractPCData.class);\r\n+    }\r\n+\r\n+    protected final String getClassName(Object obj) {\r\n+        return getUniqueName(((ClassMetaData) obj).getDescribedType());\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a unique name for the given type's pcdata implementation.\r\n+     */\r\n+    protected String getUniqueName(Class type) {\r\n+        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\r\n+    }\r\n+\r\n+    protected final void decorate(Object obj, BCClass bc, int[] types) {\r\n+        super.decorate(obj, bc, types);\r\n+        ClassMetaData meta = (ClassMetaData) obj;\r\n+        enhanceConstructor(bc);\r\n+        addBaseFields(bc);\r\n+        addImplDataMethods(bc, meta);\r\n+        addFieldImplDataMethods(bc, meta);\r\n+        addVersionMethods(bc);\r\n+        addGetType(bc, meta);\r\n+        addLoadMethod(bc, meta);\r\n+        addLoadWithFieldsMethod(bc, meta);\r\n+        addStoreMethods(bc, meta);\r\n+        addNewEmbedded(bc);\r\n+        addGetData(bc);\r\n+        decorate(bc, meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply additional decoration to generated class.\r\n+     */\r\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n+    }\r\n+\r\n+    /**\r\n+     * Enhance constructor to initialize fields\r\n+     */\r\n+    private void enhanceConstructor(BCClass bc) {\r\n+        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\r\n+        Code code = cons.getCode(false);\r\n+        code.afterLast();\r\n+        code.previous();\r\n+        // private BitSet loaded = new BitSet();\r\n+        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\r\n+        loaded.setFinal(true);\r\n+        code.aload().setThis();\r\n+        code.anew().setType(BitSet.class);\r\n+        code.dup();\r\n+        code.constant().setValue(bc.getFields().length);\r\n+        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\r\n+            new Class[]{ int.class });\r\n+        code.putfield().setField(loaded);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Have to load the type since it may not be available to the\r\n+     * same classloader(i.e. rar vs. ear). The context classloader\r\n+     * (i.e. the user app classloader) should be fine.\r\n+     */\r\n+    private void addGetType(BCClass bc, ClassMetaData meta) {\r\n+        BCField type = bc.declareField(\"type\", Class.class);\r\n+        type.setStatic(true);\r\n+        type.makePrivate();\r\n+        // public Class getType() {\r\n+        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\r\n+        getter.makePublic();\r\n+        Code code = getter.getCode(true);\r\n+        // if (type == null) {\r\n+        // try {\r\n+        // type = Class.forName\r\n+        // (meta.getDescribedType().getName(), true,\r\n+        // Thread.currentThread().getContextClassLoader());\r\n+        // } catch (ClassNotFoundException cnfe) {\r\n+        // throw new InternalException();\r\n+        // }\r\n+        // }\r\n+        code.getstatic().setField(type);\r\n+        Collection jumps = new LinkedList();\r\n+        jumps.add(code.ifnonnull());\r\n+        ExceptionHandler handler = code.addExceptionHandler();\r\n+        handler.setTryStart(code.constant().setValue\r\n+            (meta.getDescribedType().getName()));\r\n+        code.constant().setValue(true);\r\n+        code.invokestatic().setMethod(Thread.class, \"currentThread\",\r\n+            Thread.class, null);\r\n+        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\r\n+            ClassLoader.class, null);\r\n+        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\r\n+            new Class[]{ String.class, boolean.class, ClassLoader.class });\r\n+        code.putstatic().setField(type);\r\n+        Instruction go2 = code.go2();\r\n+        jumps.add(go2);\r\n+        handler.setTryEnd(go2);\r\n+        handler.setCatch(ClassNotFoundException.class);\r\n+        handler.setHandlerStart(throwException\r\n+            (code, InternalException.class));\r\n+        setTarget(code.getstatic().setField(type), jumps);\r\n+        code.areturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Declare standard dynamic pcdata fields.\r\n+     */\r\n+    private void addBaseFields(BCClass bc) {\r\n+        addBeanField(bc, \"id\", Object.class);\r\n+        BCField field = addBeanField(bc, \"storageGenerator\",\r\n+            PCDataGenerator.class);\r\n+        field.setAccessFlags(field.getAccessFlags()\r\n+            | Constants.ACCESS_TRANSIENT);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing class-level impl data.\r\n+     */\r\n+    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n+        // void storeImplData(OpenJPAStateManager);\r\n+        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+        BCField impl = null;\r\n+        if (!usesImplData(meta))\r\n+            code.vreturn();\r\n+        else {\r\n+            // if (sm.isImplDataCacheable())\r\n+            // setImplData(sm.getImplData());\r\n+            impl = addBeanField(bc, \"implData\", Object.class);\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"isImplDataCacheable\", boolean.class, null);\r\n+            JumpInstruction ifins = code.ifeq();\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, null);\r\n+            code.invokevirtual().setMethod(\"setImplData\", void.class,\r\n+                new Class[]{ Object.class });\r\n+            ifins.setTarget(code.vreturn());\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+        // void loadImplData(OpenJPAStateManager);\r\n+        meth = bc.declareMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        code = meth.getCode(true);\r\n+        if (!usesImplData(meta))\r\n+            code.vreturn();\r\n+        else {\r\n+            // if (sm.getImplData() == null && implData != null)\r\n+            // sm.setImplData(impl, true);\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, null);\r\n+            JumpInstruction ifins = code.ifnonnull();\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            JumpInstruction ifins2 = code.ifnull();\r\n+            code.aload().setParam(0);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            code.constant().setValue(true);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"setImplData\", void.class,\r\n+                new Class[]{ Object.class, boolean.class });\r\n+            Instruction ins = code.vreturn();\r\n+            ifins.setTarget(ins);\r\n+            ifins2.setTarget(ins);\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing class-level impl data.\r\n+     */\r\n+    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n+        // public void loadImplData(OpenJPAStateManager sm, int i)\r\n+        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class });\r\n+        meth.makePrivate();\r\n+        Code code = meth.getCode(true);\r\n+        int count = countImplDataFields(meta);\r\n+        BCField impl = null;\r\n+        if (count == 0)\r\n+            code.vreturn();\r\n+        else {\r\n+            // Object[] fieldImpl\r\n+            impl = bc.declareField(\"fieldImpl\", Object[].class);\r\n+            impl.makePrivate();\r\n+            // if (fieldImpl != null)\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            JumpInstruction ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+            // Object obj = null;\r\n+            int obj = code.getNextLocalsIndex();\r\n+            ifins.setTarget(code.constant().setNull());\r\n+            code.astore().setLocal(obj);\r\n+            // establish switch target, then move before it\r\n+            Instruction target = code.aload().setLocal(obj);\r\n+            code.previous();\r\n+            // switch (i)\r\n+            code.iload().setParam(1);\r\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n+            FieldMetaData[] fields = meta.getFields();\r\n+            int cacheable = 0;\r\n+            for (int i = 0; i < fields.length; i++) {\r\n+                if (!usesImplData(fields[i]))\r\n+                    continue;\r\n+                // case x: obj = fieldImpl[y]; break;\r\n+                lswitch.addCase(i, code.aload().setThis());\r\n+                code.getfield().setField(impl);\r\n+                code.constant().setValue(cacheable++);\r\n+                code.aaload();\r\n+                code.astore().setLocal(obj);\r\n+                code.go2().setTarget(target);\r\n+            }\r\n+            lswitch.setDefaultTarget(target);\r\n+            // if (obj != null)\r\n+            code.next(); // jump back over target\r\n+            ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+            // sm.setImplData(index, impl);\r\n+            ifins.setTarget(code.aload().setParam(0));\r\n+            code.iload().setParam(1);\r\n+            code.aload().setLocal(obj);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"setImplData\", void.class,\r\n+                new Class[]{ int.class, Object.class });\r\n+            code.vreturn();\r\n+        }\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\r\n+        meth = bc.declareMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n+        code = meth.getCode(true);\r\n+        if (count == 0)\r\n+            code.vreturn();\r\n+        else {\r\n+            // int arrIdx = -1;\r\n+            // switch (index)\r\n+            int arrIdx = code.getNextLocalsIndex();\r\n+            code.constant().setValue(-1);\r\n+            code.istore().setLocal(arrIdx);\r\n+            code.iload().setParam(1);\r\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n+            // establish switch target, then move before it\r\n+            Instruction switchTarget = code.iload().setLocal(arrIdx);\r\n+            code.previous();\r\n+            FieldMetaData[] fields = meta.getFields();\r\n+            int cacheable = 0;\r\n+            for (int i = 0; i < fields.length; i++) {\r\n+                if (!usesImplData(fields[i]))\r\n+                    continue;\r\n+                // case x: arrIdx = y; break;\r\n+                lswitch.addCase(i, code.constant().setValue(cacheable++));\r\n+                code.istore().setLocal(arrIdx);\r\n+                code.go2().setTarget(switchTarget);\r\n+            }\r\n+            lswitch.setDefaultTarget(switchTarget);\r\n+            code.next(); // step over switch target\r\n+            // if (arrIdx != -1)\r\n+            code.constant().setValue(-1);\r\n+            JumpInstruction ifins = code.ificmpne();\r\n+            code.vreturn();\r\n+            // create null target, then move before it\r\n+            Instruction nullTarget = code.aload().setThis();\r\n+            code.previous();\r\n+            // if (loaded)\r\n+            ifins.setTarget(code.iload().setParam(2));\r\n+            code.ifeq().setTarget(nullTarget);\r\n+            // Object obj = sm.getImplData(index)\r\n+            int obj = code.getNextLocalsIndex();\r\n+            code.aload().setParam(0);\r\n+            code.iload().setParam(1);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, new Class[]{ int.class });\r\n+            code.astore().setLocal(obj);\r\n+            // if (obj != null)\r\n+            code.aload().setLocal(obj);\r\n+            code.ifnull().setTarget(nullTarget);\r\n+            // if (fieldImpl == null)\r\n+            // fieldImpl = new Object[fields];\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            ifins = code.ifnonnull();\r\n+            code.aload().setThis();\r\n+            code.constant().setValue(count);\r\n+            code.anewarray().setType(Object.class);\r\n+            code.putfield().setField(impl);\r\n+            // fieldImpl[arrIdx] = obj;\r\n+            // return;\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(impl);\r\n+            code.iload().setLocal(arrIdx);\r\n+            code.aload().setLocal(obj);\r\n+            code.aastore();\r\n+            code.vreturn();\r\n+            // if (fieldImpl != null)\r\n+            // fieldImpl[index] = null;\r\n+            code.next(); // step over nullTarget\r\n+            code.getfield().setField(impl);\r\n+            ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(impl);\r\n+            code.iload().setLocal(arrIdx);\r\n+            code.constant().setNull();\r\n+            code.aastore();\r\n+            code.vreturn();\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing version data.\r\n+     */\r\n+    protected void addVersionMethods(BCClass bc) {\r\n+        // void storeVersion(OpenJPAStateManager sm);\r\n+        addBeanField(bc, \"version\", Object.class);\r\n+        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+        // version = sm.getVersion();\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface()\r\n+            .setMethod(OpenJPAStateManager.class, \"getVersion\",\r\n+                Object.class, null);\r\n+        code.putfield().setField(\"version\", Object.class);\r\n+        code.vreturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+        // void loadVersion(OpenJPAStateManager sm)\r\n+        meth = bc.declareMethod(\"loadVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        code = meth.getCode(true);\r\n+        // if (sm.getVersion() == null)\r\n+        // sm.setVersion(version);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getVersion\", Object.class, null);\r\n+        JumpInstruction ifins = code.ifnonnull();\r\n+        code.aload().setParam(0);\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"version\", Object.class);\r\n+        code.invokeinterface()\r\n+            .setMethod(OpenJPAStateManager.class, \"setVersion\",\r\n+                void.class, new Class[]{ Object.class });\r\n+        ifins.setTarget(code.vreturn());\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\r\n+        // public void load(OpenJPAStateManager sm, FetchState fc,\r\n+        // Object context)\r\n+        Code code = addLoadMethod(bc, false);\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        Collection jumps2;\r\n+        int local = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(local);\r\n+        int inter = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(inter);\r\n+        int objectCount = 0;\r\n+        boolean intermediate;\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            jumps2 = new LinkedList();\r\n+            intermediate = usesIntermediate(fmds[i]);\r\n+            setTarget(code.aload().setThis(), jumps);\r\n+            // if (loaded.get(i)) or(!loaded.get(i)) depending on inter resp\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            jumps.add(code.ifne());\r\n+            if (intermediate)\r\n+                addLoadIntermediate(code, i, objectCount, jumps2, inter);\r\n+            jumps2.add(code.go2());\r\n+            // if in DFG, no if statement.\r\n+            // else if (fetch.hasFetchGroup(fmds[i].getFetchGroups())\r\n+            // || fetch.hasField(fmds[i].getFullName()))\r\n+            if (!fmds[i].isInDefaultFetchGroup()) {\r\n+                setTarget(code.aload().setParam(1), jumps);\r\n+                code.constant().setValue(fmds[i]);\r\n+                code.invokevirtual().setMethod(FieldMetaData.class,\r\n+                    \"getFetchGroups\", Set.class, null);\r\n+                code.aload().setParam(0);\r\n+                code.invokeinterface().setMethod\r\n+                    (FetchConfiguration.class, \"hasFetchGroup\",\r\n+                        boolean.class, new Class[]{ Set.class });\r\n+                JumpInstruction ifins = code.ifne();\r\n+                code.aload().setParam(1);\r\n+                code.constant().setValue(fmds[i].getFullName());\r\n+                code.invokeinterface().setMethod\r\n+                    (FetchConfiguration.class, \"hasField\", boolean.class,\r\n+                        new Class[]{ String.class });\r\n+                jumps2.add(code.ifeq());\r\n+                ifins.setTarget(addLoad(bc, code, fmds[i], objectCount,\r\n+                    local, false));\r\n+            } else {\r\n+                setTarget(addLoad(bc, code, fmds[i], objectCount,\r\n+                    local, false), jumps);\r\n+            }\r\n+            jumps = jumps2;\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\r\n+        Code code = addLoadMethod(bc, true);\r\n+        // public void load(OpenJPAStateManager sm, FetchConfiguration fc,\r\n+        // BitSet fields, Object conn)\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        Collection jumps2;\r\n+        int objectCount = 0;\r\n+        boolean intermediate;\r\n+        int local = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(local);\r\n+        int inter = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(inter);\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            jumps2 = new LinkedList();\r\n+            intermediate = usesIntermediate(fmds[i]);\r\n+            // if (fields.get(i))\r\n+            // {\r\n+            // if (loaded.get(i))\r\n+            setTarget(code.aload().setParam(1), jumps);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            jumps2.add(code.ifeq());\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            if (intermediate)\r\n+                jumps.add(code.ifeq());\r\n+            else jumps2.add(code.ifeq());\r\n+            addLoad(bc, code, fmds[i], objectCount, local, true);\r\n+            if (usesImplData(fmds[i])) {\r\n+                // loadImplData(sm, i);\r\n+                code.aload().setThis();\r\n+                code.aload().setParam(0);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n+                    new Class[]{ OpenJPAStateManager.class, int.class });\r\n+            }\r\n+            jumps2.add(code.go2());\r\n+            if (intermediate)\r\n+                setTarget(addLoadIntermediate\r\n+                    (code, i, objectCount, jumps2, inter), jumps);\r\n+            jumps = jumps2;\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Declare and start the base load method.\r\n+     */\r\n+    private Code addLoadMethod(BCClass bc, boolean fields) {\r\n+        Class[] args = null;\r\n+        if (fields)\r\n+            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\r\n+                FetchState.class, Object.class };\r\n+        else args = new Class[]{ OpenJPAStateManager.class,\r\n+            FetchState.class, Object.class };\r\n+        BCMethod load = bc.declareMethod(\"load\", void.class, args);\r\n+        Code code = load.getCode(true);\r\n+        //loadVersion(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"loadVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        //loadImplData(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        return code;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add the field load.\r\n+     */\r\n+    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\r\n+        int objectCount, int local, boolean fields) {\r\n+        int index = fmd.getIndex();\r\n+        int typeCode = replaceType(fmd);\r\n+        Instruction first;\r\n+        if (typeCode < JavaTypes.OBJECT) {\r\n+            // sm.store<type> (i, field<i>)\r\n+            Class type = forType(fmd.getTypeCode());\r\n+            first = code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(getFieldName(index), type);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"store\" + StringUtils.capitalize(type.getName()),\r\n+                void.class, new Class[]{ int.class, type });\r\n+        } else {\r\n+            // fmd = sm.getMetaData().getField(i);\r\n+            int offset = fields ? 1 : 0;\r\n+            first = code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getMetaData\", ClassMetaData.class, null);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\r\n+                FieldMetaData.class, new Class[]{ int.class });\r\n+            code.astore().setLocal(local);\r\n+            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\r\n+            // fetch, context);\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.aload().setLocal(local);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"objects\", Object[].class);\r\n+            code.constant().setValue(objectCount);\r\n+            code.aaload();\r\n+            code.aload().setParam(1 + offset);\r\n+            code.aload().setParam(2 + offset);\r\n+            code.invokevirtual().setMethod(bc.getName(), \"toField\",\r\n+                Object.class.getName(), toStrings\r\n+                (new Class[]{ OpenJPAStateManager.class, FieldMetaData.class,\r\n+                    Object.class, FetchState.class, Object.class }));\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"storeField\", void.class,\r\n+                new Class[]{ int.class, Object.class });\r\n+        }\r\n+        return first;\r\n+    }\r\n+\r\n+    /**\r\n+     * Load intermediate data if possible.\r\n+     */\r\n+    private Instruction addLoadIntermediate(Code code, int index,\r\n+        int objectCount, Collection jumps2, int inter) {\r\n+        // {\r\n+        // Object inter = objects[objectCount];\r\n+        Instruction first = code.aload().setThis();\r\n+        code.getfield().setField(\"objects\", Object[].class);\r\n+        code.constant().setValue(objectCount);\r\n+        code.aaload();\r\n+        code.astore().setLocal(inter);\r\n+        // if (inter != null && !sm.getLoaded().get(index))\r\n+        code.aload().setLocal(inter);\r\n+        jumps2.add(code.ifnull());\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getLoaded\", BitSet.class, null);\r\n+        code.constant().setValue(index);\r\n+        code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+            boolean.class, new Class[]{ int.class });\r\n+        jumps2.add(code.ifne());\r\n+        // sm.setIntermediate(index, inter);\r\n+        // }  // end else\r\n+        code.aload().setParam(0);\r\n+        code.constant().setValue(index);\r\n+        code.aload().setLocal(inter);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"setIntermediate\", void.class,\r\n+            new Class[]{ int.class, Object.class });\r\n+        return first;\r\n+    }\r\n+\r\n+    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\r\n+        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\r\n+        addStoreMethod(bc, meta, true);\r\n+        // i.e. void store(OpenJPAStateManager sm);\r\n+        addStoreMethod(bc, meta, false);\r\n+    }\r\n+\r\n+    private void addStoreMethod(BCClass bc, ClassMetaData meta,\r\n+        boolean fields) {\r\n+        BCMethod store;\r\n+        if (fields)\r\n+            store = bc.declareMethod(\"store\", void.class,\r\n+                new Class[]{ OpenJPAStateManager.class, BitSet.class });\r\n+        else store = bc.declareMethod(\"store\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = store.getCode(true);\r\n+        // initialize();\r\n+        code.aload().setThis();\r\n+        code.invokevirtual().setMethod(\"initialize\", void.class, null);\r\n+        // storeVersion(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"storeVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        // storeImplData(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        int objectCount = 0;\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            if (fields) {\r\n+                //  if (fields != null && fields.get(index))\r\n+                setTarget(code.aload().setParam(1), jumps);\r\n+                jumps.add(code.ifnull());\r\n+                code.aload().setParam(1);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifeq());\r\n+            } else {\r\n+                // if (sm.getLoaded().get(index)))\r\n+                setTarget(code.aload().setParam(0), jumps);\r\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                    \"getLoaded\", BitSet.class, null);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifeq());\r\n+            }\r\n+            addStore(bc, code, fmds[i], objectCount);\r\n+            if (usesIntermediate(fmds[i])) {\r\n+                JumpInstruction elseIns = code.go2();\r\n+                // else if (!loaded.get(index))\r\n+                setTarget(code.aload().setThis(), jumps);\r\n+                jumps.add(elseIns);\r\n+                code.getfield().setField(\"loaded\", BitSet.class);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifne());\r\n+                // Object val = sm.getIntermediate(index);\r\n+                // if (val != null)\r\n+                // objects[objectCount] = val;\r\n+                code.aload().setParam(0);\r\n+                code.constant().setValue(i);\r\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                    \"getIntermediate\", Object.class, new Class[]{ int.class });\r\n+                int local = code.getNextLocalsIndex();\r\n+                code.astore().setLocal(local);\r\n+                code.aload().setLocal(local);\r\n+                jumps.add(code.ifnull());\r\n+                code.aload().setThis();\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                code.constant().setValue(objectCount);\r\n+                code.aload().setLocal(local);\r\n+                code.aastore();\r\n+            }\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\r\n+        int objectCount) {\r\n+        int typeCode = replaceType(fmd);\r\n+        int index = fmd.getIndex();\r\n+        if (typeCode < JavaTypes.OBJECT) {\r\n+            Class type = forType(typeCode);\r\n+            // field<i> = sm.fetch<Type> (index)\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"fetch\" + StringUtils.capitalize(type.getName()), type,\r\n+                new Class[]{ int.class });\r\n+            code.putfield().setField(getFieldName(index), type);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n+                new Class[]{ int.class });\r\n+        } else {\r\n+            // Object val = toData(sm.getMetaData().getField(index),\r\n+            // sm.fetchField(index, false), sm.getContext());\r\n+            int local = code.getNextLocalsIndex();\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getMetaData\", ClassMetaData.class, null);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.invokevirtual().setMethod(ClassMetaData.class,\r\n+                \"getField\", FieldMetaData.class, new Class[]{ int.class });\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.constant().setValue(false);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"fetchField\", Object.class, new Class[]\r\n+                { int.class, boolean.class });\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getContext\", StoreContext.class, null);\r\n+            code.invokevirtual().setMethod(bc.getName(), \"toData\",\r\n+                Object.class.getName(), toStrings(new Class []{\r\n+                FieldMetaData.class, Object.class, StoreContext.class }));\r\n+            code.astore().setLocal(local);\r\n+            // if (val == NULL) {\r\n+            // val = null;\r\n+            // loaded.clear(index);\r\n+            // } else\r\n+            // loaded.set(index);\r\n+            // objects[objectCount] = val;\r\n+            code.aload().setLocal(local);\r\n+            code.getstatic().setField(AbstractPCData.class, \"NULL\",\r\n+                Object.class);\r\n+            JumpInstruction ifins = code.ifacmpne();\r\n+            code.constant().setNull();\r\n+            code.astore().setLocal(local);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n+                new Class[]{ int.class });\r\n+            JumpInstruction go2 = code.go2();\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n+                new Class[]{ int.class });\r\n+            go2.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(\"objects\", Object[].class);\r\n+            code.constant().setValue(objectCount);\r\n+            code.aload().setLocal(local);\r\n+            code.aastore();\r\n+        }\r\n+        if (!usesImplData(fmd))\r\n+            return;\r\n+        // storeImplData(sm, i, loaded.get(i);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.constant().setValue(index);\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"loaded\", BitSet.class);\r\n+        code.constant().setValue(index);\r\n+        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\r\n+            new Class[]{ int.class });\r\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n+    }\r\n+\r\n+    private void addNewEmbedded(BCClass bc) {\r\n+        // void newEmbeddedPCData(OpenJPAStateManager embedded)\r\n+        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+        // return getStorageGenerator().generatePCData\r\n+        // (sm.getId(), sm.getMetaData());\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getId\", Object.class, null);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getMetaData\", ClassMetaData.class, null);\r\n+        code.invokevirtual().setMethod(PCDataGenerator.class,\r\n+            \"generatePCData\", PCData.class, new Class[]\r\n+            { Object.class, ClassMetaData.class });\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    private void addGetData(BCClass bc) {\r\n+        // return getObjectField(i);\r\n+        BCMethod method = bc.declareMethod(\"getData\", Object.class,\r\n+            new Class[]{ int.class });\r\n+        Code code = method.getCode(true);\r\n+        code.aload().setThis();\r\n+        code.iload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"getObject\", Object.class,\r\n+            new Class[]{ int.class });\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+    /////////////\r\n+    // Utilities\r\n+    /////////////\r\n+\r\n+    /**\r\n+     * Return a valid {@link JavaTypes} constant for the given field\r\n+     */\r\n+    protected int replaceType(FieldMetaData fmd) {\r\n+        if (usesIntermediate(fmd))\r\n+            return JavaTypes.OBJECT;\r\n+        return fmd.getTypeCode();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given field uses a cacheable intermediate value.\r\n+     */\r\n+    protected boolean usesIntermediate(FieldMetaData fmd) {\r\n+        return fmd.usesIntermediate();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given type might have cacheable class-level impl data.\r\n+     */\r\n+    protected boolean usesImplData(ClassMetaData meta) {\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given field might have cacheable impl data.\r\n+     */\r\n+    protected boolean usesImplData(FieldMetaData fmd) {\r\n+        return fmd.usesImplData() == null;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of fields with cacheable impl data.\r\n+     */\r\n+    private int countImplDataFields(ClassMetaData meta) {\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        int count = 0;\r\n+        for (int i = 0; i < fmds.length; i++)\r\n+            if (usesImplData(fmds[i]))\r\n+                count++;\r\n+        return count;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add method which defers to AbstractPCData.\r\n+     */\r\n+    protected void callAbstractPCData(BCClass bc, String name, Class retType,\r\n+        Class[] args) {\r\n+        BCMethod meth = bc.declareMethod(name, retType, args);\r\n+        Code code = meth.getCode(true);\r\n+        code.aload().setThis();\r\n+        for (int i = 0; i < args.length; i++)\r\n+            code.xload().setParam(i).setType(args[i]);\r\n+        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\r\n+            args);\r\n+        if (!void.class.equals(retType))\r\n+            code.xreturn().setType(retType);\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the collection of {@link JumpInstruction}s to the given instruction,\r\n+     * clearing the collection in the process.\r\n+     */\r\n+    protected void setTarget(Instruction ins, Collection jumps) {\r\n+        for (Iterator it = jumps.iterator(); it.hasNext();)\r\n+            ((JumpInstruction) it.next()).setTarget(ins);\r\n+        jumps.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given array of classes to strings.\r\n+     */\r\n+    private static String[] toStrings(Class[] cls) {\r\n+        String[] strings = new String[cls.length];\r\n+        for (int i = 0; i < strings.length; i++)\r\n+            strings[i] = cls[i].getName();\r\n+        return strings;\r\n+    }\r\n+\r\n+    /**\r\n+     * Dynamic {@link PCData}s generated will implement this interface\r\n+     * to simplify initialization.\r\n+     */\r\n+    public static interface DynamicPCData extends PCData {\r\n+\r\n+        public void setId(Object oid);\r\n+\r\n+        public PCDataGenerator getStorageGenerator();\r\n+\r\n+        public void setStorageGenerator(PCDataGenerator generator);\r\n+    }\r\n+}\r"},{"sha":"528f955cb7d32c3149ce85e0b48f6b68cec9514a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"added","additions":3202,"deletions":0,"changes":3202,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"20219ed22f91218a5c35e5cc4d40cd3291ea93de","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"added","additions":247,"deletions":0,"changes":247,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,247 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+import java.util.WeakHashMap;\r\n+\r\n+/**\r\n+ * Tracks registered persistence-capable classes.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+public class PCRegistry {\r\n+\r\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n+    // intentionally left unlocalized to minimize dependencies\r\n+    private static final String COPY_NO_ID = \"Cannot copy identity for \"\r\n+        + \"abstract class \";\r\n+    private static final String NO_META = \"No metadata found for class \";\r\n+    // map of pc classes to meta structs; weak so the VM can GC classes\r\n+    private static final Map _metas = new WeakHashMap();\r\n+    // register class listeners\r\n+    private static final Collection _listeners = new LinkedList();\r\n+\r\n+    /**\r\n+     * Register a {@link RegisterClassListener}.\r\n+     */\r\n+    public static void addRegisterClassListener(RegisterClassListener rcl) {\r\n+        if (rcl == null)\r\n+            return;\r\n+        synchronized (_listeners) {\r\n+            _listeners.add(rcl);\r\n+        }\r\n+        synchronized (_metas) {\r\n+            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\r\n+                rcl.register((Class) itr.next());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes a {@link RegisterClassListener}.\r\n+     */\r\n+    public static void removeRegisterClassListener(RegisterClassListener rcl) {\r\n+        synchronized (_listeners) {\r\n+            _listeners.remove(rcl);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the field names for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static String[] getFieldNames(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.fieldNames;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the field types for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static Class[] getFieldTypes(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.fieldTypes;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the persistent superclass for a <code>PersistenceCapable</code>\r\n+     * class, or null if none. The superclass may or may not implement\r\n+     * {@link PersistenceCapable}, depending on the access type of the class.\r\n+     */\r\n+    public static Class getPersistentSuperclass(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.pcSuper;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new instance of the class and assign its state manager.\r\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n+     */\r\n+    public static PersistenceCapable newInstance(Class pcClass,\r\n+        StateManager sm, boolean clear) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new instance of the class and assign its state manager and oid.\r\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n+     */\r\n+    public static PersistenceCapable newInstance(Class pcClass,\r\n+        StateManager sm, Object oid, boolean clear) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new identity object for the given\r\n+     * <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static Object newObjectId(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new identity object for the given\r\n+     * <code>PersistenceCapable</code> class, using the <code>String</code>\r\n+     * form of the constructor.\r\n+     */\r\n+    public static Object newObjectId(Class pcClass, String str) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the alias for the given type.\r\n+     */\r\n+    public static String getTypeAlias(Class pcClass) {\r\n+        return getMeta(pcClass).alias;\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy fields from an outside source to the key fields in the identity\r\n+     * object.\r\n+     */\r\n+    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\r\n+        Object oid) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        if (meta.pc == null)\r\n+            throw new IllegalStateException(COPY_NO_ID + pcClass.getName());\r\n+        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy fields to an outside source from the key fields in the identity\r\n+     * object.\r\n+     */\r\n+    public static void copyKeyFieldsFromObjectId(Class pcClass,\r\n+        FieldConsumer fm, Object oid) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        if (meta.pc == null)\r\n+            throw new IllegalStateException(COPY_NO_ID + pcClass.getName());\r\n+        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Register metadata by class.\r\n+     *\r\n+     * @param pcClass    the <code>PersistenceCapable</code> class\r\n+     * @param fieldNames managed field names\r\n+     * @param fieldTypes managed field types\r\n+     * @param fieldFlags managed field flags\r\n+     * @param sup        the most immediate persistent superclass\r\n+     * @param alias      the class alias\r\n+     * @param pc         an instance of the class, if not abstract\r\n+     */\r\n+    public static void register(Class pcClass, String[] fieldNames,\r\n+        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\r\n+        PersistenceCapable pc) {\r\n+        if (pcClass == null)\r\n+            throw new NullPointerException();\r\n+        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\r\n+        synchronized (_metas) {\r\n+            _metas.put(pcClass, meta);\r\n+        }\r\n+        synchronized (_listeners) {\r\n+            if (!_listeners.isEmpty())\r\n+                for (Iterator i = _listeners.iterator(); i.hasNext();)\r\n+                    ((RegisterClassListener) i.next()).register(pcClass);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a collection of class objects of the registered\r\n+     * persistence-capable classes.\r\n+     */\r\n+    public static Collection getRegisteredTypes() {\r\n+        synchronized (_metas) {\r\n+            return Collections.unmodifiableCollection(_metas.keySet());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns <code>true</code> if <code>cls</code> is already registered.\r\n+     */\r\n+    public static boolean isRegistered(Class cls) {\r\n+        synchronized (_metas) {\r\n+            return _metas.containsKey(cls);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Look up the metadata for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    private static Meta getMeta(Class pcClass) {\r\n+        Meta ret;\r\n+        synchronized (_metas) {\r\n+            ret = (Meta) _metas.get(pcClass);\r\n+        }\r\n+        if (ret == null)\r\n+            throw new IllegalStateException(NO_META + pcClass.getName());\r\n+        return ret;\r\n+    }\r\n+\r\n+    /**\r\n+     * Listener for persistent class registration events.\r\n+     */\r\n+    public static interface RegisterClassListener {\r\n+\r\n+        public void register(Class cls);\r\n+    }\r\n+\r\n+    /**\r\n+     * This is a helper class to manage metadata per persistence-capable class.\r\n+     */\r\n+    private static class Meta {\r\n+\r\n+        public final PersistenceCapable pc;\r\n+        public final String[] fieldNames;\r\n+        public final Class[] fieldTypes;\r\n+        public final Class pcSuper;\r\n+        public final String alias;\r\n+\r\n+        public Meta(PersistenceCapable pc, String[] fieldNames,\r\n+            Class[] fieldTypes, Class pcSuper, String alias) {\r\n+            this.pc = pc;\r\n+            this.fieldNames = fieldNames;\r\n+            this.fieldTypes = fieldTypes;\r\n+            this.pcSuper = pcSuper;\r\n+            this.alias = alias;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"3f49df39ea9d957f372ebd79a48c8378ac405fb2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,87 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+/**\r\n+ * The interface that persistent instances will implement.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+public interface PersistenceCapable {\r\n+\r\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n+    public static final byte READ_WRITE_OK = 0;\r\n+    public static final byte LOAD_REQUIRED = 1;\r\n+    public static final byte READ_OK = -1;\r\n+    public static final byte CHECK_READ = 1;\r\n+    public static final byte MEDIATE_READ = 2;\r\n+    public static final byte CHECK_WRITE = 4;\r\n+    public static final byte MEDIATE_WRITE = 8;\r\n+    public static final byte SERIALIZABLE = 16;\r\n+    public static final Object DESERIALIZED = new Object();\r\n+\r\n+    Object pcGetGenericContext();\r\n+\r\n+    StateManager pcGetStateManager();\r\n+\r\n+    void pcReplaceStateManager(StateManager sm);\r\n+\r\n+    void pcProvideField(int fieldIndex);\r\n+\r\n+    void pcProvideFields(int[] fieldIndices);\r\n+\r\n+    void pcReplaceField(int fieldIndex);\r\n+\r\n+    void pcReplaceFields(int[] fieldIndex);\r\n+\r\n+    void pcReplaceFlags();\r\n+\r\n+    void pcCopyFields(Object fromObject, int[] fields);\r\n+\r\n+    void pcDirty(String fieldName);\r\n+\r\n+    Object pcFetchObjectId();\r\n+\r\n+    Object pcGetVersion();\r\n+\r\n+    boolean pcIsDirty();\r\n+\r\n+    boolean pcIsTransactional();\r\n+\r\n+    boolean pcIsPersistent();\r\n+\r\n+    boolean pcIsNew();\r\n+\r\n+    boolean pcIsDeleted();\r\n+\r\n+    Boolean pcIsDetached(); // null == unknown\r\n+\r\n+    PersistenceCapable pcNewInstance(StateManager sm, boolean clear);\r\n+\r\n+    PersistenceCapable pcNewInstance(StateManager sm, Object obj,\r\n+        boolean clear);\r\n+\r\n+    Object pcNewObjectIdInstance();\r\n+\r\n+    Object pcNewObjectIdInstance(Object obj);\r\n+\r\n+    void pcCopyKeyFieldsToObjectId(Object obj);\r\n+\r\n+    void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj);\r\n+\r\n+    void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer, Object obj);\r\n+\r\n+    Object pcGetDetachedState();\r\n+\r\n+    void pcSetDetachedState(Object state);\r\n+}\r"},{"sha":"732eb9fd6a742e578dd0c3df6ef56f935c044a4c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","status":"added","additions":277,"deletions":0,"changes":277,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,277 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectOutput;\r\n+\r\n+/**\r\n+ * Internal state manager for managed instances.\r\n+ */\r\n+public interface StateManager {\r\n+\r\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n+    public static final int SET_USER = 0;\r\n+    public static final int SET_REMOTE = 1;\r\n+    public static final int SET_ATTACH = 2;\r\n+\r\n+    /**\r\n+     * Persistence context.\r\n+     */\r\n+    public Object getGenericContext();\r\n+\r\n+    /**\r\n+     * Change internal flags.\r\n+     */\r\n+    public byte replaceFlags();\r\n+\r\n+    /**\r\n+     * Change state manager.\r\n+     */\r\n+    public StateManager replaceStateManager(StateManager sm);\r\n+\r\n+    /**\r\n+     * Returns the optimistic version for this instance.\r\n+     */\r\n+    public Object getVersion();\r\n+\r\n+    /**\r\n+     * Whether the instance has been modified in this transaction.\r\n+     */\r\n+    public boolean isDirty();\r\n+\r\n+    /**\r\n+     * Whether the instance is transactional.\r\n+     */\r\n+    public boolean isTransactional();\r\n+\r\n+    /**\r\n+     * Whether the instance is persistent.\r\n+     */\r\n+    public boolean isPersistent();\r\n+\r\n+    /**\r\n+     * Whether the instance is newly-persisted in this transaction.\r\n+     */\r\n+    public boolean isNew();\r\n+\r\n+    /**\r\n+     * Whether the instance is deleted in this transaction.\r\n+     */\r\n+    public boolean isDeleted();\r\n+\r\n+    /**\r\n+     * Whether the instance is detached(i.e. this manager is a detached\r\n+     * state manager)\r\n+     */\r\n+    public boolean isDetached();\r\n+\r\n+    /**\r\n+     * Make named field dirty.\r\n+     */\r\n+    public void dirty(String field);\r\n+\r\n+    /**\r\n+     * Return the object id, assigning it if necessary.\r\n+     */\r\n+    public Object fetchObjectId();\r\n+\r\n+    /**\r\n+     * Callback to prepare instance for serialization.\r\n+     *\r\n+     * @return true to null detached state after serialize\r\n+     */\r\n+    public boolean serializing();\r\n+\r\n+    /**\r\n+     * Write detached state object and detached state manager to the\r\n+     * given stream.\r\n+     *\r\n+     * @return true if managed fields also written to stream\r\n+     */\r\n+    public boolean writeDetached(ObjectOutput out) throws IOException;\r\n+\r\n+    /**\r\n+     * Proxy the given detached field after deserialization.\r\n+     */\r\n+    public void proxyDetachedDeserialized(int idx);\r\n+\r\n+    /**\r\n+     * Field access callback.\r\n+     */\r\n+    public void accessingField(int idx);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingBooleanField(PersistenceCapable pc, int idx,\r\n+        boolean cur, boolean next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingCharField(PersistenceCapable pc, int idx, char cur,\r\n+        char next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingByteField(PersistenceCapable pc, int idx, byte cur,\r\n+        byte next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingShortField(PersistenceCapable pc, int idx, short cur,\r\n+        short next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingIntField(PersistenceCapable pc, int idx, int cur,\r\n+        int next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingLongField(PersistenceCapable pc, int idx, long cur,\r\n+        long next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingFloatField(PersistenceCapable pc, int idx, float cur,\r\n+        float next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingDoubleField(PersistenceCapable pc, int idx, double cur,\r\n+        double next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingStringField(PersistenceCapable pc, int idx, String cur,\r\n+        String next, int set);\r\n+\r\n+    /**\r\n+     * Setting state callback.\r\n+     */\r\n+    public void settingObjectField(PersistenceCapable pc, int idx, Object cur,\r\n+        Object next, int set);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedBooleanField(PersistenceCapable pc, int idx,\r\n+        boolean cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedCharField(PersistenceCapable pc, int idx, char cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedByteField(PersistenceCapable pc, int idx, byte cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedShortField(PersistenceCapable pc, int idx, short cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedIntField(PersistenceCapable pc, int idx, int cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedLongField(PersistenceCapable pc, int idx, long cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedFloatField(PersistenceCapable pc, int idx, float cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedDoubleField(PersistenceCapable pc, int idx,\r\n+        double cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedStringField(PersistenceCapable pc, int idx,\r\n+        String cur);\r\n+\r\n+    /**\r\n+     * Provide state callback.\r\n+     */\r\n+    public void providedObjectField(PersistenceCapable pc, int idx,\r\n+        Object cur);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public boolean replaceBooleanField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public char replaceCharField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public byte replaceByteField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public short replaceShortField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public int replaceIntField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public long replaceLongField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public float replaceFloatField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public double replaceDoubleField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public String replaceStringField(PersistenceCapable pc, int idx);\r\n+\r\n+    /**\r\n+     * Replace state callback.\r\n+     */\r\n+    public Object replaceObjectField(PersistenceCapable pc, int idx);\r\n+}\r"},{"sha":"6c72cdb10a2101f64a005f2ea27c58437489e414","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","status":"added","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,12 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Enhancer</strong></p>\n+\n+<p>\n+    This package provides a bytecode enhancer used to\n+    post-process classes for use in a OpenJPA runtime.\n+    A tool for generating application identity class sourcecode is also\n+    provided.\n+</p>\n+</body>\n+</html>"},{"sha":"60e3e9bb80b4cb4d8c458b7e021429ec1d480f52","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,77 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Abstract implementation of the {@link LifecycleListener} interface\r\n+ * which delegates events to a single method.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractLifecycleListener implements LifecycleListener {\r\n+\r\n+    /**\r\n+     * Should be implemented to handle the specific lifecycle event.\r\n+     */\r\n+    protected void eventOccurred(LifecycleEvent event) {\r\n+    }\r\n+\r\n+    public void afterPersist(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeClear(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterClear(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterLoad(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeDelete(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterDelete(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeStore(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterStore(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeDirty(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterDirty(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeDirtyFlushed(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterDirtyFlushed(LifecycleEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+}\r"},{"sha":"9483fca014e76f758df86d2edb16f7d72800e8f3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+\r\n+/**\r\n+ * Abstract implementation of {@link RemoteCommitProvider}. Obtains handles\r\n+ * to the event manager and log.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public abstract class AbstractRemoteCommitProvider\r\n+    implements RemoteCommitProvider, Configurable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (AbstractRemoteCommitProvider.class);\r\n+    protected RemoteCommitEventManager eventManager;\r\n+    protected Log log;\r\n+\r\n+    public void setConfiguration(Configuration config) {\r\n+        this.log = config.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+\r\n+    public void setRemoteCommitEventManager(RemoteCommitEventManager mgr) {\r\n+        eventManager = mgr;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire a remote commit event via the cached event manager.\r\n+     */\r\n+    protected void fireEvent(RemoteCommitEvent event) {\r\n+        Exception[] es = eventManager.fireEvent(event);\r\n+        if (es.length > 0 && log.isWarnEnabled())\r\n+            log.warn(_loc.get(\"remote-listener-ex\", Arrays.asList(es)));\r\n+        if (log.isTraceEnabled())\r\n+            for (int i = 0; i < es.length; i++)\r\n+                log.trace(es[i]);\r\n+    }\r\n+}\r"},{"sha":"71c2d5881ca5648e6cf286b8d6c834cb9885778f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,67 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Abstract implementation of the {@link TransactionListener} interface\r\n+ * that provides no-op implementations of all methods.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public abstract class AbstractTransactionListener\r\n+    implements TransactionListener {\r\n+\r\n+    /**\r\n+     * Catch-all for unhandled events. This method is called by all other\r\n+     * event methods if you do not override them. Does nothing by default.\r\n+     */\r\n+    protected void eventOccurred(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterBegin(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeFlush(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterFlush(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void beforeCommit(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterCommit(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterRollback(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterStateTransitions(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterCommitComplete(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+\r\n+    public void afterRollbackComplete(TransactionEvent event) {\r\n+        eventOccurred(event);\r\n+    }\r\n+}\r"},{"sha":"8b1e4a292336431d10c8da97ee8aab4da1f69ebc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when a detached instance is attached.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public interface AttachListener {\r\n+\r\n+    /**\r\n+     * Invoked before the instance is attached.\r\n+     */\r\n+    public void beforeAttach(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after the instance has been attached.\r\n+     */\r\n+    public void afterAttach(LifecycleEvent event);\r\n+}\r"},{"sha":"f30fa7a70ace010d88bca35f28fe2a9e110e6f8f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.lang.reflect.Method;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Performs a callback method on a cached bean instance.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public class BeanLifecycleCallbacks extends MethodLifecycleCallbacks {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (BeanLifecycleCallbacks.class);\r\n+    private Object _listener;\r\n+\r\n+    /**\r\n+     * Constructor. Make the callback on an instance of the given type.\r\n+     *\r\n+     * @arg whether another argunent is expected such as AfterDetach\r\n+     */\r\n+    public BeanLifecycleCallbacks(Class cls, String method, boolean arg) {\r\n+        this(cls, getMethod(cls, method, arg ? new Class[]{ Object.class,\r\n+            Object.class } : new Class[]{ Object.class }), arg);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. Make the callback on an instance of the given type.\r\n+     */\r\n+    public BeanLifecycleCallbacks(Class cls, Method method, boolean arg) {\r\n+        super(method, arg);\r\n+        try {\r\n+            _listener = cls.newInstance();\r\n+        } catch (Throwable t) {\r\n+            throw new UserException(_loc.get(\"bean-constructor\",\r\n+                cls.getName()), t);\r\n+        }\r\n+    }\r\n+\r\n+    public void makeCallback(Object obj, Object rel, int eventType)\r\n+        throws Exception {\r\n+        Method callback = getCallbackMethod();\r\n+        if (!callback.isAccessible())\r\n+            callback.setAccessible(true);\r\n+        if (requiresArgument())\r\n+            callback.invoke(_listener, new Object[]{ obj, rel });\r\n+        else callback.invoke(_listener, new Object[]{ obj });\r\n+    }\r\n+}\r"},{"sha":"3528cef7d5002c6a76568d4387cc89d5bbe0b818","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,30 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Notified when transactions begin.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface BeginTransactionListener {\r\n+\r\n+    /**\r\n+     * Notification that a transaction has begun.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_BEGIN\r\n+     */\r\n+    public void afterBegin(TransactionEvent event);\r\n+}\r"},{"sha":"c0b665b6274e5b37298f1e0c563a3bc7e27ea5fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,47 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Callback handling constants.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @since 4.0\r\n+ */\r\n+public interface CallbackModes {\r\n+\r\n+    /**\r\n+     * Flag to stop executing callbacks on exception immediately.\r\n+     */\r\n+    public static final int CALLBACK_FAIL_FAST = 2 << 0;\r\n+\r\n+    /**\r\n+     * Flag to ignore exceptions made during callback.\r\n+     */\r\n+    public static final int CALLBACK_IGNORE = 2 << 1;\r\n+\r\n+    /**\r\n+     * Flag to log exceptions made during callback.\r\n+     */\r\n+    public static final int CALLBACK_LOG = 2 << 2;\r\n+\r\n+    /**\r\n+     * Flag to re-throw exceptions made during callback.\r\n+     */\r\n+    public static final int CALLBACK_RETHROW = 2 << 3;\r\n+\r\n+    /**\r\n+     * Flag to always rollback on a callback exception.\r\n+     */\r\n+    public static final int CALLBACK_ROLLBACK = 2 << 4;\r\n+}\r"},{"sha":"2f0b218c732820c039323f93f0c7cea64199d2df","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when persistent state is cleared from an instance.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface ClearListener {\r\n+\r\n+    /**\r\n+     * Invoked before state is cleared.\r\n+     */\r\n+    public void beforeClear(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after state is cleared.\r\n+     */\r\n+    public void afterClear(LifecycleEvent event);\r\n+}\r"},{"sha":"8786ce12ca042aeddd9fd2915f84dffb44d3d7f5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when a persistent instance is deleted.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface DeleteListener {\r\n+\r\n+    /**\r\n+     * Invoked before the instance transferred to a deleted state.\r\n+     */\r\n+    public void beforeDelete(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after the instance transferred to a deleted state.\r\n+     */\r\n+    public void afterDelete(LifecycleEvent event);\r\n+}\r"},{"sha":"cf47e1f1df685b2929ca8edb2e87fffd7e36ee59","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when a persistent instance is detached.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public interface DetachListener {\r\n+\r\n+    /**\r\n+     * Invoked before the instance is detached.\r\n+     */\r\n+    public void beforeDetach(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after the instance has been detached.\r\n+     */\r\n+    public void afterDetach(LifecycleEvent event);\r\n+}\r"},{"sha":"a738ee66f2d1f90f475cdd950e149634cec287bc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,42 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when a persistent instance becomes dirty.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface DirtyListener {\r\n+\r\n+    /**\r\n+     * Invoked before the first change is applied.\r\n+     */\r\n+    public void beforeDirty(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after the first change is applied.\r\n+     */\r\n+    public void afterDirty(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked before the first change is applied to a flushed instance.\r\n+     */\r\n+    public void beforeDirtyFlushed(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after the first change is applied to a flushed instance.\r\n+     */\r\n+    public void afterDirtyFlushed(LifecycleEvent event);\r\n+}\r"},{"sha":"9df7c52cad0f5cfbef62aae097cce7a2a3ac0fa0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,67 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Notified when transactions end.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface EndTransactionListener {\r\n+\r\n+    /**\r\n+     * Notification that the next flush is for the transaction commit.\r\n+     *\r\n+     * @see TransactionEvent#BEFORE_COMMIT\r\n+     */\r\n+    public void beforeCommit(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that a transaction has successfully committed.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_COMMIT\r\n+     */\r\n+    public void afterCommit(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that a transaction has been rolled back.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_ROLLBACK\r\n+     */\r\n+    public void afterRollback(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that state transitions are complete.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_STATE_TRANSITIONS\r\n+     */\r\n+    public void afterStateTransitions(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that a transaction has successfully committed and\r\n+     * the transaction is no longer active.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_COMMIT_COMPLETE\r\n+     */\r\n+    public void afterCommitComplete(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that a transaction has been rolled back and\r\n+     * the transaction is no longer active.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_ROLLBACK_COMPLETE\r\n+     */\r\n+    public void afterRollbackComplete(TransactionEvent event);\r\n+}\r"},{"sha":"f7d2111db3d075822179a3c97a65d7f04b3afda1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,35 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.ObjectNotFoundException;\r\n+\r\n+/**\r\n+ * Throw a {@link ObjectNotFoundException} when an orphaned key is discovered.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.2.2\r\n+ */\r\n+public class ExceptionOrphanedKeyAction implements OrphanedKeyAction {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (ExceptionOrphanedKeyAction.class);\r\n+\r\n+    public Object orphan(Object oid, OpenJPAStateManager sm,\r\n+        ValueMetaData vmd) {\r\n+        throw new ObjectNotFoundException(_loc.get(\"orphaned-key\", oid, vmd));\r\n+    }\r\n+}\r"},{"sha":"71ff818e0f6feef40eda57bd845af9b19e5cb824","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,37 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Notified on transaction flush.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface FlushTransactionListener {\r\n+\r\n+    /**\r\n+     * Notification that a transaction is about to flush all object changes.\r\n+     *\r\n+     * @see TransactionEvent#BEFORE_FLUSH\r\n+     */\r\n+    public void beforeFlush(TransactionEvent event);\r\n+\r\n+    /**\r\n+     * Notification that a transaction has flushed all object changes.\r\n+     *\r\n+     * @see TransactionEvent#AFTER_FLUSH\r\n+     */\r\n+    public void afterFlush(TransactionEvent event);\r\n+}\r"},{"sha":"48edd71eb85ce2c69a65c43316d6c7a18d40cfc6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,255 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import javax.jms.ExceptionListener;\r\n+import javax.jms.JMSException;\r\n+import javax.jms.Message;\r\n+import javax.jms.MessageListener;\r\n+import javax.jms.ObjectMessage;\r\n+import javax.jms.Session;\r\n+import javax.jms.Topic;\r\n+import javax.jms.TopicConnection;\r\n+import javax.jms.TopicConnectionFactory;\r\n+import javax.jms.TopicPublisher;\r\n+import javax.jms.TopicSession;\r\n+import javax.jms.TopicSubscriber;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.GenericConfigurable;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * JMS-based implementation of {@link RemoteCommitProvider} that\r\n+ * listens for object modifications and propagates those changes to\r\n+ * other RemoteCommitProviders over a JMS topic.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public class JMSRemoteCommitProvider extends AbstractRemoteCommitProvider\r\n+    implements Configurable, GenericConfigurable, ExceptionListener {\r\n+\r\n+    private static Localizer s_loc = Localizer.forPackage\r\n+        (JMSRemoteCommitProvider.class);\r\n+    private String _topicName = \"topic/OpenJPACommitProviderTopic\";\r\n+    private String _tcfName = \"java:/ConnectionFactory\";\r\n+    private Properties _ctxProps = null;\r\n+    private int _reconnectAttempts = 0;\r\n+    private TopicConnection _connection;\r\n+    private TopicSession _session;\r\n+    private TopicPublisher _publisher;\r\n+\r\n+    /**\r\n+     * Sets the JMS Topic name. Defaults to\r\n+     * <code>topic/OpenJPACommitProviderTopic</code>.\r\n+     */\r\n+    public void setTopic(String name) {\r\n+        _topicName = name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the JMS TopicConnectionFactory name. Defaults to\r\n+     * <code>java:/ConnectionFactory</code>.\r\n+     */\r\n+    public void setTopicConnectionFactory(String name) {\r\n+        _tcfName = name;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of times to attempt to reconnect after a JMS send exception\r\n+     * is detected. Defaults to 0, meaning no attempt to reconnect is made;\r\n+     * the exception is logged and ignored.\r\n+     */\r\n+    public void setExceptionReconnectAttempts(int attempts) {\r\n+        _reconnectAttempts = attempts;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set a map of properties to pass to the {@link InitialContext}\r\n+     * constructor for JNDI lookups. Implementation of\r\n+     * {@link GenericConfigurable}.\r\n+     */\r\n+    public void setInto(Map m) {\r\n+        if (m != null && !m.isEmpty()) {\r\n+            _ctxProps = new Properties();\r\n+            _ctxProps.putAll(m);\r\n+            m.clear();\r\n+        } else _ctxProps = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new {@link Context} object for use by this provider.\r\n+     */\r\n+    protected Context newContext() throws NamingException {\r\n+        if (_ctxProps == null)\r\n+            return new InitialContext();\r\n+        return new InitialContext(_ctxProps);\r\n+    }\r\n+\r\n+    // ---------- RemoteCommitProvider implementation ----------\r\n+    public void broadcast(RemoteCommitEvent event) {\r\n+        try {\r\n+            _publisher.publish(createMessage(event));\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"jms-sent-update\", _topicName));\r\n+        } catch (JMSException jmse) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"jms-send-error\", _topicName), jmse);\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        try {\r\n+            if (_connection != null) {\r\n+                _connection.close();\r\n+                if (log.isInfoEnabled())\r\n+                    log.info(s_loc.get(\"jms-close-listener\", _topicName));\r\n+            }\r\n+        } catch (JMSException jmse) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"jms-close-error\", _topicName), jmse);\r\n+        }\r\n+        finally {\r\n+            _connection = null;\r\n+        }\r\n+    }\r\n+    // ---------- Configurable implementation ----------\r\n+\r\n+    /**\r\n+     * Subclasses that need to perform actions in\r\n+     * {@link Configurable#endConfiguration} must invoke this method.\r\n+     */\r\n+    public void endConfiguration() {\r\n+        super.endConfiguration();\r\n+        connect();\r\n+    }\r\n+\r\n+    private void connect() {\r\n+        try {\r\n+            Context ctx = newContext();\r\n+            TopicConnectionFactory tcf =\r\n+                (TopicConnectionFactory) ctx.lookup(_tcfName);\r\n+            Topic topic = (Topic) ctx.lookup(_topicName);\r\n+            ctx.close();\r\n+            _connection = tcf.createTopicConnection();\r\n+            // false == not transacted.\r\n+            _session = _connection.createTopicSession\r\n+                (false, Session.AUTO_ACKNOWLEDGE);\r\n+            // create a publisher\r\n+            _publisher = _session.createPublisher(topic);\r\n+            // create a subscriber.\r\n+            TopicSubscriber s = _session.createSubscriber(topic, null,\r\n+                /* noLocal: */ true);\r\n+            MessageListener l = getMessageListener();\r\n+            s.setMessageListener(l);\r\n+            _connection.start();\r\n+            _connection.setExceptionListener(this);\r\n+            if (log.isInfoEnabled())\r\n+                log.info(s_loc.get(\"jms-start-listener\", _topicName));\r\n+        }\r\n+        catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        }\r\n+        catch (Exception e) {\r\n+            throw new UserException(s_loc.get(\"jms-provider-config\",\r\n+                _topicName, _tcfName), e).setFatal(true);\r\n+        }\r\n+    }\r\n+\r\n+    /* *\r\n+     * Returns a {@link javax.jms.MessageListener} capable of\r\n+     * understanding and processing messages created by {@link #createMessage}.\r\n+     *  The listener returned by this method is responsible for\r\n+     * notifying the provider that a remote event has been received.\r\n+     */\r\n+    protected MessageListener getMessageListener() {\r\n+        return new MessageListener() {\r\n+            public void onMessage(Message m) {\r\n+                if (!(m instanceof ObjectMessage)) {\r\n+                    if (log.isWarnEnabled())\r\n+                        log.warn(s_loc.get(\"jms-receive-error-3\",\r\n+                            _topicName, m.getClass().getName()));\r\n+                    return;\r\n+                }\r\n+                ObjectMessage om = (ObjectMessage) m;\r\n+                Object o;\r\n+                try {\r\n+                    o = om.getObject();\r\n+                } catch (JMSException jmse) {\r\n+                    if (log.isWarnEnabled())\r\n+                        log.warn(s_loc.get(\"jms-receive-error-1\"), jmse);\r\n+                    return;\r\n+                }\r\n+                if (o instanceof RemoteCommitEvent) {\r\n+                    if (log.isTraceEnabled())\r\n+                        log.trace(s_loc.get(\"jms-received-update\",\r\n+                            _topicName));\r\n+                    RemoteCommitEvent rce = (RemoteCommitEvent) o;\r\n+                    fireEvent(rce);\r\n+                } else {\r\n+                    if (log.isWarnEnabled())\r\n+                        log.warn(s_loc.get(\"jms-receive-error-2\",\r\n+                            o.getClass().getName(), _topicName));\r\n+                }\r\n+            }\r\n+        };\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new {@link Message} to send to the topic. This\r\n+     * implementation creates an {@link ObjectMessage}.\r\n+     */\r\n+    protected Message createMessage(RemoteCommitEvent event)\r\n+        throws JMSException {\r\n+        return _session.createObjectMessage(event);\r\n+    }\r\n+\r\n+    public void onException(JMSException ex) {\r\n+        if (log.isWarnEnabled())\r\n+            log.warn(s_loc.get(\"jms-listener-error\", _topicName), ex);\r\n+        if (_reconnectAttempts <= 0)\r\n+            return;\r\n+        close();\r\n+        boolean connected = false;\r\n+        for (int i = 0; i < _reconnectAttempts; i++) {\r\n+            try {\r\n+                if (log.isInfoEnabled())\r\n+                    log.info(s_loc.get(\"jms-reconnect-attempt\", _topicName,\r\n+                        String.valueOf(i + 1)));\r\n+                connect();\r\n+                connected = true;\r\n+            } catch (Exception e) {\r\n+                if (log.isInfoEnabled())\r\n+                    log.info(s_loc.get(\"jms-reconnect-fail\", _topicName), e);\r\n+                try {\r\n+                    Thread.sleep(1000);\r\n+                } catch (InterruptedException ie) {\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+        if (!connected && log.isErrorEnabled())\r\n+            log.error(s_loc.get(\"jms-cant-reconnect\", _topicName,\r\n+                String.valueOf(_reconnectAttempts)));\r\n+        else if (connected && log.isInfoEnabled())\r\n+            log.info(s_loc.get(\"jms-reconnected\", _topicName));\r\n+    }\r\n+}\r"},{"sha":"96efab5632b177aca91da1f9c98c4b1ce015c797","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * A lifecycle listener that responds to callbacks rather than events.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public interface LifecycleCallbacks {\r\n+\r\n+    /**\r\n+     * Return whether the given instance has a callback for the given\r\n+     * event type.\r\n+     */\r\n+    public boolean hasCallback(Object obj, int eventType);\r\n+\r\n+    /**\r\n+     * Invoke the callback for the given event type on the given instance.\r\n+     */\r\n+    public void makeCallback(Object obj, Object related, int eventType)\r\n+        throws Exception;\r\n+}\r"},{"sha":"886125e4f6b22e8b64b2dfc983570dca19a678aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,164 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.EventObject;\r\n+\r\n+/**\r\n+ * Lifecycle event on a persistent instance. The event source\r\n+ * is the persistent instance whose state has changed.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ * @since 3.3\r\n+ */\r\n+public class LifecycleEvent extends EventObject {\r\n+\r\n+    /**\r\n+     * Event type before an instance is made persistent\r\n+     */\r\n+    public static final int BEFORE_PERSIST = 0;\r\n+\r\n+    /**\r\n+     * Event type when an instance is made persistent\r\n+     */\r\n+    public static final int AFTER_PERSIST = 1;\r\n+\r\n+    /**\r\n+     * Event type when an instance is loaded.\r\n+     */\r\n+    public static final int AFTER_LOAD = 2;\r\n+\r\n+    /**\r\n+     * Event type when an instance is stored.\r\n+     */\r\n+    public static final int BEFORE_STORE = 3;\r\n+\r\n+    /**\r\n+     * Event type when an instance is stored.\r\n+     */\r\n+    public static final int AFTER_STORE = 4;\r\n+\r\n+    /**\r\n+     * Event type when an instance is cleared.\r\n+     */\r\n+    public static final int BEFORE_CLEAR = 5;\r\n+\r\n+    /**\r\n+     * Event type when an instance is cleared.\r\n+     */\r\n+    public static final int AFTER_CLEAR = 6;\r\n+\r\n+    /**\r\n+     * Event type when an instance is deleted.\r\n+     */\r\n+    public static final int BEFORE_DELETE = 7;\r\n+\r\n+    /**\r\n+     * Event type when an instance is deleted.\r\n+     */\r\n+    public static final int AFTER_DELETE = 8;\r\n+\r\n+    /**\r\n+     * Event type when an instance is dirtied for the first time.\r\n+     */\r\n+    public static final int BEFORE_DIRTY = 9;\r\n+\r\n+    /**\r\n+     * Event type when an instance is dirtied for the first time.\r\n+     */\r\n+    public static final int AFTER_DIRTY = 10;\r\n+\r\n+    /**\r\n+     * Event type when an instance is dirtied for the first time after flush.\r\n+     */\r\n+    public static final int BEFORE_DIRTY_FLUSHED = 11;\r\n+\r\n+    /**\r\n+     * Event type when an instance is dirtied for the first time after flush.\r\n+     */\r\n+    public static final int AFTER_DIRTY_FLUSHED = 12;\r\n+\r\n+    /**\r\n+     * Event type when an instance is detached.\r\n+     */\r\n+    public static final int BEFORE_DETACH = 13;\r\n+\r\n+    /**\r\n+     * Event type when an instance is detached.\r\n+     */\r\n+    public static final int AFTER_DETACH = 14;\r\n+\r\n+    /**\r\n+     * Event type when an instance is attached.\r\n+     */\r\n+    public static final int BEFORE_ATTACH = 15;\r\n+\r\n+    /**\r\n+     * Event type when an instance is attached.\r\n+     */\r\n+    public static final int AFTER_ATTACH = 16;\r\n+\r\n+    /**\r\n+     * Event type when an instances is refreshed.\r\n+     */\r\n+    public static final int AFTER_REFRESH = 17;\r\n+\r\n+    /**\r\n+     * Convenience array of all event types.\r\n+     */\r\n+    public static final int[] ALL_EVENTS = new int[]{\r\n+        BEFORE_PERSIST, AFTER_PERSIST, AFTER_LOAD, BEFORE_STORE, AFTER_STORE,\r\n+        BEFORE_CLEAR, AFTER_CLEAR, BEFORE_DELETE, AFTER_DELETE, BEFORE_DIRTY,\r\n+        AFTER_DIRTY, BEFORE_DIRTY_FLUSHED, AFTER_DIRTY_FLUSHED, BEFORE_DETACH,\r\n+        AFTER_DETACH, BEFORE_ATTACH, AFTER_ATTACH, AFTER_REFRESH, };\r\n+    private final int _type;\r\n+    private final Object _related;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param pc   the persistent instance that triggered the event\r\n+     * @param type the event type\r\n+     */\r\n+    public LifecycleEvent(Object pc, int type) {\r\n+        this(pc, null, type);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param pc      the persistent instance that triggered the event\r\n+     * @param type    the event type\r\n+     * @param related the related instance such as the detached copy.\r\n+     */\r\n+    public LifecycleEvent(Object pc, Object related, int type) {\r\n+        super(pc);\r\n+        _type = type;\r\n+        _related = related;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the event type.\r\n+     */\r\n+    public int getType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the related object.\r\n+     */\r\n+    public Object getRelated() {\r\n+        return _related;\r\n+    }\r\n+}\r"},{"sha":"9a40759d766be88665d31761141d5da430b7954a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"added","additions":553,"deletions":0,"changes":553,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,553 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataDefaults;\r\n+\r\n+/**\r\n+ * Manager that can be used to track and notify listeners on lifecycle events.\r\n+ * This class is optimized for event firing rather than for adding and\r\n+ * removing listeners, which are O(n) operations. This class also does not\r\n+ * maintain perfect set semantics for listeners; it is possible to wind up\r\n+ * having the same listener invoked multiple times for a single event if it\r\n+ * is added to this manager multiple times with different classes, or with\r\n+ * a base class and its subclass.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 3.3\r\n+ */\r\n+public class LifecycleEventManager implements CallbackModes {\r\n+\r\n+    private static final Exception[] EMPTY_EXCEPTIONS = new Exception[0];\r\n+    private Map _classListeners = null; // class -> listener list\r\n+    private ListenerList _listeners = null;\r\n+    private List _addListeners = new LinkedList();\r\n+    private List _remListeners = new LinkedList();\r\n+    private List _exceps = new LinkedList();\r\n+    private boolean _firing = false;\r\n+    private boolean _fail = false;\r\n+\r\n+    /**\r\n+     * Register a lifecycle listener for the given classes. If the classes\r\n+     * array is null, register for all classes.\r\n+     */\r\n+    public synchronized void addListener(Object listener, Class[] classes) {\r\n+        if (listener == null)\r\n+            return;\r\n+        if (classes != null && classes.length == 0)\r\n+            return;\r\n+        if (_firing) {\r\n+            _addListeners.add(listener);\r\n+            _addListeners.add(classes);\r\n+            return;\r\n+        }\r\n+        if (classes == null) {\r\n+            if (_listeners == null)\r\n+                _listeners = new ListenerList(5);\r\n+            _listeners.add(listener);\r\n+            return;\r\n+        }\r\n+        if (_classListeners == null)\r\n+            _classListeners = new HashMap();\r\n+        ListenerList listeners;\r\n+        for (int i = 0; i < classes.length; i++) {\r\n+            listeners = (ListenerList) _classListeners.get(classes[i]);\r\n+            if (listeners == null) {\r\n+                listeners = new ListenerList(3);\r\n+                _classListeners.put(classes[i], listeners);\r\n+            }\r\n+            listeners.add(listener);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given listener.\r\n+     */\r\n+    public synchronized void removeListener(Object listener) {\r\n+        if (_firing) {\r\n+            _remListeners.add(listener);\r\n+            return;\r\n+        }\r\n+        if (_listeners != null && _listeners.remove(listener))\r\n+            return;\r\n+        if (_classListeners != null) {\r\n+            ListenerList listeners;\r\n+            for (Iterator itr = _classListeners.values().iterator();\r\n+                itr.hasNext();) {\r\n+                listeners = (ListenerList) itr.next();\r\n+                listeners.remove(listener);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasPersistListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_PERSIST)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_PERSIST)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_PERSIST);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasDeleteListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_DELETE)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_DELETE)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_DELETE);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasClearListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_CLEAR)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_CLEAR)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_CLEAR);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasLoadListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.AFTER_LOAD)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_LOAD);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasStoreListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_STORE)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_STORE)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_STORE);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasDirtyListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_DIRTY)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_DIRTY)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.BEFORE_DIRTY_FLUSHED)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_DIRTY_FLUSHED)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_DIRTY);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasDetachListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_DETACH)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_DETACH)\r\n+            || hasListeners(source, meta, LifecycleEvent.BEFORE_DETACH)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_DETACH);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether there are listeners or callbacks for the given source.\r\n+     */\r\n+    public boolean hasAttachListeners(Object source, ClassMetaData meta) {\r\n+        return hasCallbacks(source, meta, LifecycleEvent.BEFORE_ATTACH)\r\n+            || hasCallbacks(source, meta, LifecycleEvent.AFTER_ATTACH)\r\n+            || hasListeners(source, meta, LifecycleEvent.BEFORE_ATTACH)\r\n+            || hasListeners(source, meta, LifecycleEvent.AFTER_ATTACH);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if any callbacks are registered for the given source and\r\n+     * event type.\r\n+     */\r\n+    private boolean hasCallbacks(Object source, ClassMetaData meta, int type) {\r\n+        LifecycleCallbacks[] callbacks = meta.getLifecycleMetaData().\r\n+            getCallbacks(type);\r\n+        if (callbacks.length == 0)\r\n+            return false;\r\n+        for (int i = 0; i < callbacks.length; i++)\r\n+            if (callbacks[i].hasCallback(source, type))\r\n+                return true;\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if any listeners are registered for the given source and\r\n+     * event type.\r\n+     */\r\n+    private synchronized boolean hasListeners(Object source,\r\n+        ClassMetaData meta, int type) {\r\n+        if (meta.getLifecycleMetaData().getIgnoreSystemListeners())\r\n+            return false;\r\n+        boolean failFast = (meta.getRepository().getMetaDataFactory().\r\n+            getDefaults().getCallbackMode() & CALLBACK_FAIL_FAST) != 0;\r\n+        if (fireEvent(null, source, null, type, _listeners, true, failFast,\r\n+            null) == Boolean.TRUE)\r\n+            return true;\r\n+        ListenerList system = meta.getRepository().getSystemListeners();\r\n+        if (!system.isEmpty() && fireEvent(null, source, null, type, system,\r\n+            true, failFast, null) == Boolean.TRUE)\r\n+            return true;\r\n+        if (_classListeners != null) {\r\n+            Class c = source == null ? meta.getDescribedType() :\r\n+                source.getClass();\r\n+            do {\r\n+                if (fireEvent(null, source, null, type, (ListenerList)\r\n+                    _classListeners.get(c), true, failFast, null)\r\n+                    == Boolean.TRUE)\r\n+                    return true;\r\n+                c = c.getSuperclass();\r\n+            } while (c != null && c != Object.class);\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire lifecycle event to all registered listeners without an argument.\r\n+     */\r\n+    public Exception[] fireEvent(Object source, ClassMetaData meta, int type) {\r\n+        return fireEvent(source, null, meta, type);\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire lifecycle event to all registered listeners.\r\n+     */\r\n+    public synchronized Exception[] fireEvent(Object source, Object related,\r\n+        ClassMetaData meta, int type) {\r\n+        boolean reentrant = _firing;\r\n+        _firing = true;\r\n+        List exceptions = (reentrant) ? new LinkedList() : _exceps;\r\n+        MetaDataDefaults def = meta.getRepository().getMetaDataFactory().\r\n+            getDefaults();\r\n+        int mode = meta.getRepository().getMetaDataFactory().\r\n+            getDefaults().getCallbackMode();\r\n+        boolean callbacks = def.getCallbacksBeforeListeners(type);\r\n+        boolean failFast = (def.getCallbackMode() & CALLBACK_FAIL_FAST) != 0;\r\n+        if (callbacks)\r\n+            makeCallbacks(source, related, meta, type, failFast, exceptions);\r\n+        LifecycleEvent ev = (LifecycleEvent) fireEvent(null, source, related,\r\n+            type, _listeners, false, failFast, exceptions);\r\n+        if (_classListeners != null) {\r\n+            Class c = source == null ? meta.getDescribedType() :\r\n+                source.getClass();\r\n+            do {\r\n+                ev = (LifecycleEvent) fireEvent(ev, source, related, type,\r\n+                    (ListenerList) _classListeners.get(c), false, failFast,\r\n+                    exceptions);\r\n+                c = c.getSuperclass();\r\n+            } while (c != null && c != Object.class);\r\n+        }\r\n+        // make system listeners\r\n+        if (!meta.getLifecycleMetaData().getIgnoreSystemListeners()) {\r\n+            ListenerList system = meta.getRepository().getSystemListeners();\r\n+            fireEvent(ev, source, related, type, system, false, failFast,\r\n+                exceptions);\r\n+        }\r\n+        if (!callbacks)\r\n+            makeCallbacks(source, related, meta, type, failFast, exceptions);\r\n+        // create return array before clearing exceptions\r\n+        Exception[] ret;\r\n+        if (exceptions.isEmpty())\r\n+            ret = EMPTY_EXCEPTIONS;\r\n+        else ret = (Exception[]) exceptions.toArray\r\n+            (new Exception[exceptions.size()]);\r\n+        // if this wasn't a reentrant call, catch up with calls to add\r\n+        // and remove listeners made while firing\r\n+        if (!reentrant) {\r\n+            _firing = false;\r\n+            _fail = false;\r\n+            if (!_addListeners.isEmpty())\r\n+                for (Iterator itr = _addListeners.iterator(); itr.hasNext();)\r\n+                    addListener(itr.next(), (Class[]) itr.next());\r\n+            if (!_remListeners.isEmpty())\r\n+                for (Iterator itr = _remListeners.iterator(); itr.hasNext();)\r\n+                    removeListener(itr.next());\r\n+            _addListeners.clear();\r\n+            _remListeners.clear();\r\n+            _exceps.clear();\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    /**\r\n+     * Make callbacks, recording any exceptions in the given collection.\r\n+     */\r\n+    private void makeCallbacks(Object source, Object related,\r\n+        ClassMetaData meta, int type, boolean failFast, Collection exceptions) {\r\n+        // make lifecycle callbacks\r\n+        LifecycleCallbacks[] callbacks = meta.getLifecycleMetaData().\r\n+            getCallbacks(type);\r\n+        for (int i = 0; !_fail && i < callbacks.length; i++) {\r\n+            try {\r\n+                callbacks[i].makeCallback(source, related, type);\r\n+            } catch (Exception e) {\r\n+                exceptions.add(e);\r\n+                if (failFast)\r\n+                    _fail = true;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire an event with the given source and type to the given list of\r\n+     * listeners. The event may have already been constructed.\r\n+     */\r\n+    private Object fireEvent(LifecycleEvent ev, Object source, Object rel,\r\n+        int type, ListenerList listeners, boolean mock, boolean failFast,\r\n+        List exceptions) {\r\n+        if (listeners == null || !listeners.hasListeners(type))\r\n+            return null;\r\n+        Object listener;\r\n+        boolean responds;\r\n+        for (int i = 0, size = listeners.size(); !_fail && i < size; i++) {\r\n+            listener = listeners.get(i);\r\n+            if (size == 1)\r\n+                responds = true;\r\n+            else if (listener instanceof ListenerAdapter) {\r\n+                responds = ((ListenerAdapter) listener).respondsTo(type);\r\n+                if (!responds)\r\n+                    continue;\r\n+            } else responds = false;\r\n+            try {\r\n+                switch (type) {\r\n+                    case LifecycleEvent.BEFORE_CLEAR:\r\n+                    case LifecycleEvent.AFTER_CLEAR:\r\n+                        if (responds || listener instanceof ClearListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            if (type == LifecycleEvent.BEFORE_CLEAR)\r\n+                                ((ClearListener) listener).beforeClear(ev);\r\n+                            else ((ClearListener) listener).afterClear(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_PERSIST:\r\n+                    case LifecycleEvent.AFTER_PERSIST:\r\n+                        if (responds || listener instanceof PersistListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            if (type == LifecycleEvent.BEFORE_PERSIST)\r\n+                                ((PersistListener) listener).beforePersist(ev);\r\n+                            else ((PersistListener) listener).afterPersist(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_DELETE:\r\n+                    case LifecycleEvent.AFTER_DELETE:\r\n+                        if (responds || listener instanceof DeleteListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            if (type == LifecycleEvent.BEFORE_DELETE)\r\n+                                ((DeleteListener) listener).beforeDelete(ev);\r\n+                            else ((DeleteListener) listener).afterDelete(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_DIRTY:\r\n+                    case LifecycleEvent.AFTER_DIRTY:\r\n+                    case LifecycleEvent.BEFORE_DIRTY_FLUSHED:\r\n+                    case LifecycleEvent.AFTER_DIRTY_FLUSHED:\r\n+                        if (responds || listener instanceof DirtyListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            switch (type) {\r\n+                                case LifecycleEvent.BEFORE_DIRTY:\r\n+                                    ((DirtyListener) listener).beforeDirty(ev);\r\n+                                    break;\r\n+                                case LifecycleEvent.AFTER_DIRTY:\r\n+                                    ((DirtyListener) listener).afterDirty(ev);\r\n+                                    break;\r\n+                                case LifecycleEvent.BEFORE_DIRTY_FLUSHED:\r\n+                                    ((DirtyListener) listener)\r\n+                                        .beforeDirtyFlushed(ev);\r\n+                                    break;\r\n+                                case LifecycleEvent.AFTER_DIRTY_FLUSHED:\r\n+                                    ((DirtyListener) listener)\r\n+                                        .afterDirtyFlushed(ev);\r\n+                                    break;\r\n+                            }\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.AFTER_LOAD:\r\n+                    case LifecycleEvent.AFTER_REFRESH:\r\n+                        if (responds || listener instanceof LoadListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            if (type == LifecycleEvent.AFTER_LOAD)\r\n+                                ((LoadListener) listener).afterLoad(ev);\r\n+                            else ((LoadListener) listener).afterRefresh(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_STORE:\r\n+                    case LifecycleEvent.AFTER_STORE:\r\n+                        if (responds || listener instanceof StoreListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, type);\r\n+                            if (type == LifecycleEvent.BEFORE_STORE)\r\n+                                ((StoreListener) listener).beforeStore(ev);\r\n+                            else ((StoreListener) listener).afterStore(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_DETACH:\r\n+                    case LifecycleEvent.AFTER_DETACH:\r\n+                        if (responds || listener instanceof DetachListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, rel, type);\r\n+                            if (type == LifecycleEvent.BEFORE_DETACH)\r\n+                                ((DetachListener) listener).beforeDetach(ev);\r\n+                            else ((DetachListener) listener).afterDetach(ev);\r\n+                        }\r\n+                        break;\r\n+                    case LifecycleEvent.BEFORE_ATTACH:\r\n+                    case LifecycleEvent.AFTER_ATTACH:\r\n+                        if (responds || listener instanceof AttachListener) {\r\n+                            if (mock)\r\n+                                return Boolean.TRUE;\r\n+                            if (ev == null)\r\n+                                ev = new LifecycleEvent(source, rel, type);\r\n+                            if (type == LifecycleEvent.BEFORE_ATTACH)\r\n+                                ((AttachListener) listener).beforeAttach(ev);\r\n+                            else ((AttachListener) listener).afterAttach(ev);\r\n+                        }\r\n+                        break;\r\n+                }\r\n+            } catch (Exception e) {\r\n+                exceptions.add(e);\r\n+                if (failFast)\r\n+                    _fail = true;\r\n+            }\r\n+        }\r\n+        return ev;\r\n+    }\r\n+\r\n+    /**\r\n+     * Interface that facades to other lifecycle listener interfaces can\r\n+     * implement to choose which events to respond to based on their delegate.\r\n+     * This is more efficient than registering as a listener for all events\r\n+     * but only responding to some.\r\n+     */\r\n+    public static interface ListenerAdapter {\r\n+\r\n+        /**\r\n+         * Return whether this instance responds to the given event type from\r\n+         * {@link LifecycleEvent}.\r\n+         */\r\n+        public boolean respondsTo(int eventType);\r\n+    }\r\n+\r\n+    /**\r\n+     * Extended list that tracks what event types its elements care about.\r\n+     * Maintains set semantics as well.\r\n+     */\r\n+    public static class ListenerList extends ArrayList {\r\n+\r\n+        private int _types = 0;\r\n+\r\n+        public ListenerList(int size) {\r\n+            super(size);\r\n+        }\r\n+\r\n+        public ListenerList(ListenerList copy) {\r\n+            super(copy);\r\n+            _types = copy._types;\r\n+        }\r\n+\r\n+        public boolean hasListeners(int type) {\r\n+            return (_types & (2 << type)) > 0;\r\n+        }\r\n+\r\n+        public boolean add(Object listener) {\r\n+            if (contains(listener))\r\n+                return false;\r\n+            super.add(listener);\r\n+            _types |= getEventTypes(listener);\r\n+            return true;\r\n+        }\r\n+\r\n+        public boolean remove(Object listener) {\r\n+            if (!super.remove(listener))\r\n+                return false;\r\n+            // recompute types mask\r\n+            _types = 0;\r\n+            for (int i = 0; i < size(); i++)\r\n+                _types |= getEventTypes(get(i));\r\n+            return true;\r\n+        }\r\n+\r\n+        /**\r\n+         * Return a mask of the event types the given listener processes.\r\n+         */\r\n+        private static int getEventTypes(Object listener) {\r\n+            int types = 0;\r\n+            if (listener instanceof ListenerAdapter) {\r\n+                ListenerAdapter adapter = (ListenerAdapter) listener;\r\n+                for (int i = 0; i < LifecycleEvent.ALL_EVENTS.length; i++)\r\n+                    if (adapter.respondsTo(LifecycleEvent.ALL_EVENTS[i]))\r\n+                        types |= 2 << LifecycleEvent.ALL_EVENTS[i];\r\n+                return types;\r\n+            }\r\n+            if (listener instanceof PersistListener)\r\n+                types |= 2 << LifecycleEvent.AFTER_PERSIST;\r\n+            if (listener instanceof ClearListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_CLEAR;\r\n+                types |= 2 << LifecycleEvent.AFTER_CLEAR;\r\n+            }\r\n+            if (listener instanceof DeleteListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_DELETE;\r\n+                types |= 2 << LifecycleEvent.AFTER_DELETE;\r\n+            }\r\n+            if (listener instanceof DirtyListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_DIRTY;\r\n+                types |= 2 << LifecycleEvent.AFTER_DIRTY;\r\n+                types |= 2 << LifecycleEvent.BEFORE_DIRTY_FLUSHED;\r\n+                types |= 2 << LifecycleEvent.AFTER_DIRTY_FLUSHED;\r\n+            }\r\n+            if (listener instanceof LoadListener)\r\n+                types |= 2 << LifecycleEvent.AFTER_LOAD;\r\n+            if (listener instanceof StoreListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_STORE;\r\n+                types |= 2 << LifecycleEvent.AFTER_STORE;\r\n+            }\r\n+            if (listener instanceof DetachListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_DETACH;\r\n+                types |= 2 << LifecycleEvent.AFTER_DETACH;\r\n+            }\r\n+            if (listener instanceof AttachListener) {\r\n+                types |= 2 << LifecycleEvent.BEFORE_ATTACH;\r\n+                types |= 2 << LifecycleEvent.AFTER_ATTACH;\r\n+            }\r\n+            return types;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"1f0d449d1e4e164034155b3c0ee7922b6c90aa93","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,25 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Interface for listening to all {@link LifecycleEvent}s.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface LifecycleListener\r\n+    extends PersistListener, LoadListener, StoreListener, ClearListener,\r\n+    DeleteListener, DirtyListener, DetachListener, AttachListener {\r\n+\r\n+}\r"},{"sha":"291be4db0818867294802c422f0bcd565c39d23e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when state is loaded into a persistent instnace.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface LoadListener {\r\n+\r\n+    /**\r\n+     * Invoked after state has been loaded into the instance.\r\n+     */\r\n+    public void afterLoad(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked after state has been refreshed.\r\n+     */\r\n+    public void afterRefresh(LifecycleEvent event);\r\n+}\r"},{"sha":"8de6b7efe19573615ebb3cdbd79609c3c1dcdf6d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,103 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.log.LogFactoryImpl;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+\r\n+/**\r\n+ * Log a message when an orphaned key is discovered.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.2.2\r\n+ */\r\n+public class LogOrphanedKeyAction implements OrphanedKeyAction {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (LogOrphanedKeyAction.class);\r\n+    private String _channel = OpenJPAConfiguration.LOG_RUNTIME;\r\n+    private short _level = Log.WARN;\r\n+\r\n+    /**\r\n+     * The channel to log to. Defaults to <code>org.apache.openjpa.Runtime</code>.\r\n+     */\r\n+    public String getChannel() {\r\n+        return _channel;\r\n+    }\r\n+\r\n+    /**\r\n+     * The channel to log to. Defaults to <code>org.apache.openjpa.Runtime</code>.\r\n+     */\r\n+    public void setChannel(String channel) {\r\n+        _channel = channel;\r\n+    }\r\n+\r\n+    /**\r\n+     * The level to log at. Defaults to <code>WARN</code>.\r\n+     */\r\n+    public short getLevel() {\r\n+        return _level;\r\n+    }\r\n+\r\n+    /**\r\n+     * The level to log at. Defaults to <code>WARN</code>.\r\n+     */\r\n+    public void setLevel(short level) {\r\n+        _level = level;\r\n+    }\r\n+\r\n+    /**\r\n+     * The level to log at. Defaults to <code>WARN</code>.\r\n+     */\r\n+    public void setLevel(String level) {\r\n+        _level = LogFactoryImpl.getLevel(level);\r\n+    }\r\n+\r\n+    public Object orphan(Object oid, OpenJPAStateManager sm,\r\n+        ValueMetaData vmd) {\r\n+        Log log = vmd.getRepository().getConfiguration().getLog(_channel);\r\n+        Object owner = (sm == null) ? null : sm.getId();\r\n+        String msg = (owner == null) ? \"orphaned-key\" : \"orphaned-key-owner\";\r\n+        switch (_level) {\r\n+            case Log.TRACE:\r\n+                if (log.isTraceEnabled())\r\n+                    log.trace(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+            case Log.DEBUG:\r\n+                if (log.isDebugEnabled())\r\n+                    log.debug(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+            case Log.INFO:\r\n+                if (log.isInfoEnabled())\r\n+                    log.info(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+            case Log.WARN:\r\n+                if (log.isWarnEnabled())\r\n+                    log.warn(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+            case Log.ERROR:\r\n+                if (log.isErrorEnabled())\r\n+                    log.error(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+            case Log.FATAL:\r\n+                if (log.isFatalEnabled())\r\n+                    log.fatal(_loc.get(msg, oid, vmd, owner));\r\n+                break;\r\n+        }\r\n+        return null;\r\n+    }\r\n+}\r"},{"sha":"241c3f84f016a75e14d091300f7225ff5df2d98b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,103 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.lang.reflect.Method;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Callback adapter that invokes a callback method via reflection.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public class MethodLifecycleCallbacks implements LifecycleCallbacks {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (MethodLifecycleCallbacks.class);\r\n+    private Method _callback;\r\n+    private boolean _arg;\r\n+\r\n+    /**\r\n+     * Constructor. Supply callback class and its callback method name.\r\n+     *\r\n+     * @arg Whether we expect a further argument such as in AfterDetach\r\n+     */\r\n+    public MethodLifecycleCallbacks(Class cls, String method, boolean arg) {\r\n+        Class[] args = arg ? new Class[]{ Object.class } : null;\r\n+        _callback = getMethod(cls, method, args);\r\n+        _arg = arg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. Supply callback method.\r\n+     */\r\n+    public MethodLifecycleCallbacks(Method method, boolean arg) {\r\n+        _callback = method;\r\n+        _arg = arg;\r\n+    }\r\n+\r\n+    /**\r\n+     * The callback method.\r\n+     */\r\n+    public Method getCallbackMethod() {\r\n+        return _callback;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns if this callback expects another argument\r\n+     */\r\n+    public boolean requiresArgument() {\r\n+        return _arg;\r\n+    }\r\n+\r\n+    public boolean hasCallback(Object obj, int eventType) {\r\n+        return true;\r\n+    }\r\n+\r\n+    public void makeCallback(Object obj, Object arg, int eventType)\r\n+        throws Exception {\r\n+        if (!_callback.isAccessible())\r\n+            _callback.setAccessible(true);\r\n+        if (_arg)\r\n+            _callback.invoke(obj, new Object[]{ arg });\r\n+        else _callback.invoke(obj, (Object[]) null);\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return getClass().getName() + \":\" + _callback;\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method to return the named method of the given class, throwing\r\n+     * the proper exception on error.\r\n+     */\r\n+    protected static Method getMethod(Class cls, String method, Class[] args) {\r\n+        try {\r\n+            return cls.getMethod(method, args);\r\n+        } catch (Throwable t) {\r\n+            try {\r\n+                // try again with the declared methods, which will\r\n+                // check private and protected methods\r\n+                Method m = cls.getDeclaredMethod(method, args);\r\n+                if (!m.isAccessible())\r\n+                    m.setAccessible(true);\r\n+                return m;\r\n+            } catch (Throwable t2) {\r\n+                throw new UserException(_loc.get(\"method-notfound\",\r\n+                    cls.getName(), method), t);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"fb9faec838cce95131e8c9872335606c359d2471","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,30 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+\r\n+/**\r\n+ * Does nothing when an orphaned key is discovered.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.2.2\r\n+ */\r\n+public class NoneOrphanedKeyAction implements OrphanedKeyAction {\r\n+\r\n+    public Object orphan(Object oid, OpenJPAStateManager sm,\r\n+        ValueMetaData vmd) {\r\n+        return null;\r\n+    }\r\n+}\r"},{"sha":"236dd5b4067ec4c24d35125a3de23f57f14de9ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,37 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+\r\n+/**\r\n+ * Perform an action when OpenJPA detects an orphaned key in the database.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.2.2\r\n+ */\r\n+public interface OrphanedKeyAction {\r\n+\r\n+    /**\r\n+     * Callback received when OpenJPA discovers an orphaned key.\r\n+     *\r\n+     * @param oid the orphaned key\r\n+     * @param sm  the instance representing the record in which the\r\n+     *            key was discovered; may be null\r\n+     * @param vmd the value in which the key was discovered\r\n+     * @return the value to load into field <code>fmd</code>; typically\r\n+     *         <code>null</code>\r\n+     */\r\n+    public Object orphan(Object oid, OpenJPAStateManager sm, ValueMetaData vmd);\r\n+}\r"},{"sha":"3314abcf50c8c5254c3c90183a15518f4abaa869","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for newly-persisted instances.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public interface PersistListener {\r\n+\r\n+    /**\r\n+     * Invoked before an instance is persisted.\r\n+     */\r\n+    public void beforePersist(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked when an instance is persisted.\r\n+     */\r\n+    public void afterPersist(LifecycleEvent event);\r\n+}\r"},{"sha":"55e9eef27a569a4491310e3202e8d2f512fe8f02","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,175 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.io.Externalizable;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInput;\r\n+import java.io.ObjectOutput;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Event type to hold the IDs of additions, updates, and\r\n+ * deletes. This event type is also fully serializable for remote communication.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public class RemoteCommitEvent implements Externalizable {\r\n+\r\n+    /**\r\n+     * Names of added classes, upated and deleted Object IDs.\r\n+     */\r\n+    public static final int PAYLOAD_OIDS = 0;\r\n+\r\n+    /**\r\n+     * Names of added classes, added, upated and deleted Object IDs.\r\n+     */\r\n+    public static final int PAYLOAD_OIDS_WITH_ADDS = 1;\r\n+\r\n+    /**\r\n+     * Names of added, updated, and deleted classes only.\r\n+     */\r\n+    public static final int PAYLOAD_EXTENTS = 2;\r\n+    private static final Localizer s_loc = Localizer.forPackage\r\n+        (RemoteCommitEvent.class);\r\n+    private int _payload = PAYLOAD_OIDS;\r\n+    private Collection _addIds = null;\r\n+    private Collection _addClasses = null;\r\n+    private Collection _updates = null;\r\n+    private Collection _deletes = null;\r\n+\r\n+    /**\r\n+     * Constructor used during externalization.\r\n+     */\r\n+    public RemoteCommitEvent() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. All collections will be proxied with unmodifiable views.\r\n+     *\r\n+     * @param payloadType PAYLOAD constant for type of data in this event\r\n+     * @param addIds      set of object IDs for added instances, or null\r\n+     * @param addClasses  set of class names for added instances\r\n+     * @param updates     set of class names or object IDs for updated instances\r\n+     * @param deletes     set of class names or object IDs for deleted instances\r\n+     */\r\n+    public RemoteCommitEvent(int payloadType, Collection addIds,\r\n+        Collection addClasses, Collection updates, Collection deletes) {\r\n+        _payload = payloadType;\r\n+        if (addIds != null)\r\n+            _addIds = Collections.unmodifiableCollection(addIds);\r\n+        if (addClasses != null)\r\n+            _addClasses = Collections.unmodifiableCollection(addClasses);\r\n+        if (updates != null)\r\n+            _updates = Collections.unmodifiableCollection(updates);\r\n+        if (deletes != null)\r\n+            _deletes = Collections.unmodifiableCollection(deletes);\r\n+    }\r\n+\r\n+    /**\r\n+     * The event PAYLOAD constant.\r\n+     */\r\n+    public int getPayloadType() {\r\n+        return _payload;\r\n+    }\r\n+\r\n+    /**\r\n+     * When the event type is PAYLOAD_OIDS_WITH_ADDS, return the set of\r\n+     * object IDs for added objects. This will only be callable when the\r\n+     * backward compatability property transmitAddObjectIds is true.\r\n+     */\r\n+    public Collection getPersistedObjectIds() {\r\n+        if (_payload != PAYLOAD_OIDS_WITH_ADDS) {\r\n+            if (_payload == PAYLOAD_OIDS)\r\n+                throw new UserException(s_loc.get(\"no-added-oids\"));\r\n+            throw new UserException(s_loc.get(\"extent-only-event\"));\r\n+        }\r\n+        return (_addIds == null) ? Collections.EMPTY_LIST : _addIds;\r\n+    }\r\n+\r\n+    /**\r\n+     * When the event type is not PAYLOAD_EXTENTS, return the set of\r\n+     * object IDs for updated objects.\r\n+     */\r\n+    public Collection getUpdatedObjectIds() {\r\n+        if (_payload == PAYLOAD_EXTENTS)\r\n+            throw new UserException(s_loc.get(\"extent-only-event\"));\r\n+        return (_updates == null) ? Collections.EMPTY_LIST : _updates;\r\n+    }\r\n+\r\n+    /**\r\n+     * When the event type is not PAYLOAD_EXTENTS, return the set of\r\n+     * object IDs for deleted objects.\r\n+     */\r\n+    public Collection getDeletedObjectIds() {\r\n+        if (_payload == PAYLOAD_EXTENTS)\r\n+            throw new UserException(s_loc.get(\"extent-only-event\"));\r\n+        return (_deletes == null) ? Collections.EMPTY_LIST : _deletes;\r\n+    }\r\n+\r\n+    /**\r\n+     * For all event types, return the set of class names for\r\n+     * the classes of inserted objects.\r\n+     */\r\n+    public Collection getPersistedTypeNames() {\r\n+        return (_addClasses == null) ? Collections.EMPTY_LIST : _addClasses;\r\n+    }\r\n+\r\n+    /**\r\n+     * When the event type is PAYLOAD_EXTENTS, return the set of class\r\n+     * names for the classes of updated objects.\r\n+     */\r\n+    public Collection getUpdatedTypeNames() {\r\n+        if (_payload != PAYLOAD_EXTENTS)\r\n+            throw new UserException(s_loc.get(\"nonextent-event\"));\r\n+        return (_updates == null) ? Collections.EMPTY_LIST : _updates;\r\n+    }\r\n+\r\n+    /**\r\n+     * When the event type is PAYLOAD_EXTENTS, return the set of class\r\n+     * names for the classes of deleted objects.\r\n+     */\r\n+    public Collection getDeletedTypeNames() {\r\n+        if (_payload != PAYLOAD_EXTENTS)\r\n+            throw new UserException(s_loc.get(\"nonextent-event\"));\r\n+        return (_deletes == null) ? Collections.EMPTY_LIST : _deletes;\r\n+    }\r\n+\r\n+    public void writeExternal(ObjectOutput out) throws IOException {\r\n+        out.writeInt(_payload);\r\n+        out.writeObject(_addClasses);\r\n+        if (_payload == PAYLOAD_OIDS_WITH_ADDS)\r\n+            out.writeObject(_addIds);\r\n+        out.writeObject(_updates);\r\n+        out.writeObject(_deletes);\r\n+    }\r\n+\r\n+    public void readExternal(ObjectInput in) throws IOException {\r\n+        try {\r\n+            _payload = in.readInt();\r\n+            _addClasses = (Collection) in.readObject();\r\n+            if (_payload == PAYLOAD_OIDS_WITH_ADDS)\r\n+                _addIds = (Collection) in.readObject();\r\n+            _updates = (Collection) in.readObject();\r\n+            _deletes = (Collection) in.readObject();\r\n+        } catch (ClassNotFoundException cnfe) {\r\n+            // ### do something\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"2f4b74dfb48581896ad35ea71422453a39b671d1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"added","additions":212,"deletions":0,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,212 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Manager that can be used to track and notify\r\n+ * {@link RemoteCommitListener}s on remote commit events. If remote events\r\n+ * are enabled, this manager should be installed as a transaction listener on\r\n+ * all brokers so that it knows when commits are made.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public class RemoteCommitEventManager extends AbstractConcurrentEventManager\r\n+    implements EndTransactionListener, Closeable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (RemoteCommitEventManager.class);\r\n+    private final RemoteCommitProvider _provider;\r\n+    private final Log _log;\r\n+    private boolean _transmitPersIds = false;\r\n+\r\n+    /**\r\n+     * Constructor. Supply configuration.\r\n+     */\r\n+    public RemoteCommitEventManager(OpenJPAConfiguration conf) {\r\n+        _provider = conf.newRemoteCommitProviderInstance();\r\n+        if (_provider != null) {\r\n+            _provider.setRemoteCommitEventManager(this);\r\n+            _log = conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+        } else _log = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if remote events are enabled.\r\n+     */\r\n+    public boolean areRemoteEventsEnabled() {\r\n+        return _provider != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link RemoteCommitProvider} that this manager uses.\r\n+     *\r\n+     * @since 3.1\r\n+     */\r\n+    public RemoteCommitProvider getRemoteCommitProvider() {\r\n+        return _provider;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the oids of added instances will be transmitted.\r\n+     */\r\n+    public boolean getTransmitPersistedObjectIds() {\r\n+        return _transmitPersIds;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the oids of added instances will be transmitted.\r\n+     */\r\n+    public void setTransmitPersistedObjectIds(boolean transmit) {\r\n+        _transmitPersIds = transmit;\r\n+    }\r\n+\r\n+    public void addListener(RemoteCommitListener listen) {\r\n+        if (_provider == null)\r\n+            throw new UserException(_loc.get(\"no-provider\"));\r\n+        super.addListener(listen);\r\n+    }\r\n+\r\n+    /**\r\n+     * Close this manager and all registered listeners.\r\n+     */\r\n+    public void close() {\r\n+        if (_provider != null) {\r\n+            _provider.close();\r\n+            Collection listeners = getListeners();\r\n+            for (Iterator itr = listeners.iterator(); itr.hasNext();)\r\n+                ((RemoteCommitListener) itr.next()).close();\r\n+        }\r\n+    }\r\n+\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        RemoteCommitListener listen = (RemoteCommitListener) listener;\r\n+        RemoteCommitEvent ev = (RemoteCommitEvent) event;\r\n+        listen.afterCommit(ev);\r\n+    }\r\n+\r\n+    //////////////////////////////////////\r\n+    // TransactionListener implementation\r\n+    //////////////////////////////////////\r\n+    public void afterCommit(TransactionEvent event) {\r\n+        if (_provider != null) {\r\n+            RemoteCommitEvent rce = createRemoteCommitEvent(event);\r\n+            if (rce != null)\r\n+                _provider.broadcast(rce);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a remote commit event from the given transaction event.\r\n+     */\r\n+    private RemoteCommitEvent createRemoteCommitEvent(TransactionEvent event) {\r\n+        Broker broker = (Broker) event.getSource();\r\n+        int payload;\r\n+        Collection persIds = null;\r\n+        Collection addClassNames = null;\r\n+        Collection updates = null;\r\n+        Collection deletes = null;\r\n+        if (broker.isLargeTransaction()) {\r\n+            payload = RemoteCommitEvent.PAYLOAD_EXTENTS;\r\n+            addClassNames = toClassNames(event.getPersistedTypes());\r\n+            updates = toClassNames(event.getUpdatedTypes());\r\n+            deletes = toClassNames(event.getDeletedTypes());\r\n+            if (addClassNames == null && updates == null && deletes == null)\r\n+                return null;\r\n+        } else {\r\n+            Collection trans = event.getTransactionalObjects();\r\n+            if (trans.isEmpty())\r\n+                return null;\r\n+            payload = (_transmitPersIds)\r\n+                ? RemoteCommitEvent.PAYLOAD_OIDS_WITH_ADDS\r\n+                : RemoteCommitEvent.PAYLOAD_OIDS;\r\n+            Object oid;\r\n+            Object obj;\r\n+            OpenJPAStateManager sm;\r\n+            for (Iterator itr = trans.iterator(); itr.hasNext();) {\r\n+                obj = itr.next();\r\n+                sm = broker.getStateManager(obj);\r\n+                if (sm == null || !sm.isPersistent() || !sm.isDirty())\r\n+                    continue;\r\n+                if (sm.isNew() && sm.isDeleted())\r\n+                    continue;\r\n+                oid = sm.fetchObjectId();\r\n+                if (sm.isNew()) {\r\n+                    if (_transmitPersIds) {\r\n+                        if (persIds == null)\r\n+                            persIds = new ArrayList();\r\n+                        persIds.add(oid);\r\n+                    }\r\n+                    if (addClassNames == null)\r\n+                        addClassNames = new HashSet();\r\n+                    addClassNames.add(obj.getClass().getName());\r\n+                } else if (sm.isDeleted()) {\r\n+                    if (deletes == null)\r\n+                        deletes = new ArrayList();\r\n+                    deletes.add(oid);\r\n+                } else {\r\n+                    if (updates == null)\r\n+                        updates = new ArrayList();\r\n+                    updates.add(oid);\r\n+                }\r\n+            }\r\n+            if (addClassNames == null && updates == null && deletes == null)\r\n+                return null;\r\n+        }\r\n+        return new RemoteCommitEvent(payload, persIds, addClassNames, updates,\r\n+            deletes);\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform a collection of classes to class names.\r\n+     */\r\n+    private static Collection toClassNames(Collection clss) {\r\n+        if (clss.isEmpty())\r\n+            return null;\r\n+        List names = new ArrayList(clss);\r\n+        for (int i = 0; i < names.size(); i++)\r\n+            names.set(i, ((Class) names.get(i)).getName());\r\n+        return names;\r\n+    }\r\n+\r\n+    public void beforeCommit(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterRollback(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterCommitComplete(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterRollbackComplete(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterStateTransitions(TransactionEvent event) {\r\n+    }\r\n+}\r"},{"sha":"f43f69b40be432ddc24e67d3651e73cf752c0ad0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,52 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+\r\n+/**\r\n+ * An entity that wishes to be notified when Brokers\r\n+ * associated with remote BrokerFactories commit.\r\n+ * A RemoteCommitListener <b>is not</b> notified of commits that originated\r\n+ * with a Broker created from the BrokerFactory that it is\r\n+ * registered with. (Of course, if a listener is registered with multiple\r\n+ * factories, this situation might be complicated a bit.)\r\n+ * Usage:\r\n+ * <code><pre> import org.apache.openjpa.event.*;\r\n+ * import org.apache.openjpa.conf.*;\r\n+ * <p/>\r\n+ * {@link org.apache.openjpa.conf.OpenJPAConfiguration} conf = factory.getConfiguraiton();\r\n+ *  RemoteCommitListener l = new RemoteCommitListener() {\r\n+ * public void afterCommit({@link RemoteCommitEvent} e) {\r\n+ * // update a Swing widget when remote brokers make\r\n+ * // changes to reference data }\r\n+ *  public void close() { } };\r\n+ *  conf.getRemoteCommitEventManager().addListener(l);\r\n+ * </pre></code>\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface RemoteCommitListener extends Closeable {\r\n+\r\n+    /**\r\n+     * Notification that a transaction associated with a different\r\n+     * BrokerFactory has successfully committed.\r\n+     */\r\n+    public void afterCommit(RemoteCommitEvent event);\r\n+\r\n+    /**\r\n+     * Free the resources used by this listener.\r\n+     */\r\n+    public void close();\r\n+}\r"},{"sha":"0940bf1e852f80ff5f7a7d9eb9bb543bb97018fb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,55 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+\r\n+/**\r\n+ * An entity that is responsible for communicating commit\r\n+ * notification to other {@link RemoteCommitEventManager}s. Each\r\n+ * event manager creates a remote commit provider, based on\r\n+ * the values of the <code>org.apache.openjpa.RemoteCommitProvider</code>\r\n+ * configuration property.\r\n+ * An adapter that implements {@link TransactionListener} is\r\n+ * registered with each {@link org.apache.openjpa.kernel.Broker}. This adapter\r\n+ * invokes <code>broadcast</code>, which is responsible for\r\n+ * notifying other remote commit provider objects of the commit changes.\r\n+ * Upon receiving a notification from a different remote commit provider,\r\n+ * a provider must notify all local remote commit listeners via the\r\n+ * {@link RemoteCommitEventManager#fireEvent} method.\r\n+ * A remote commit provider <b>must not</b> fire remote events for\r\n+ * commits that originated with a local broker.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface RemoteCommitProvider extends Closeable {\r\n+\r\n+    /**\r\n+     * Set the \"owning\" remote event manager to notify when remote events\r\n+     * are received from remote sources.\r\n+     */\r\n+    public void setRemoteCommitEventManager(RemoteCommitEventManager mgr);\r\n+\r\n+    /**\r\n+     * Notifies other remote event managers in this JVM and on other machines\r\n+     * of changes to the cache. This method must not notify the\r\n+     * event manager associated with the broker that originated this commit.\r\n+     */\r\n+    public void broadcast(RemoteCommitEvent event);\r\n+\r\n+    /**\r\n+     * Free the resources used by this provider.\r\n+     */\r\n+    public void close();\r\n+}\r"},{"sha":"f4b8899cb8d6b4cec9e9e53af7ed3cce6cc7bf38","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,61 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.Set;\r\n+\r\n+/**\r\n+ * Single-JVM-only implementation of {@link RemoteCommitProvider}\r\n+ * that listens for object modifications and propagates those changes\r\n+ * to other SingleJVMRemoteCommitProviders in the same JVM. This is\r\n+ * only useful for linking together multiple factories in the same\r\n+ * JVM that are all loaded in the same classloader, which is a rare\r\n+ * circumstance.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public class SingleJVMRemoteCommitProvider\r\n+    extends AbstractRemoteCommitProvider {\r\n+\r\n+    private static Set s_providers = new HashSet();\r\n+\r\n+    public SingleJVMRemoteCommitProvider() {\r\n+        synchronized (s_providers) {\r\n+            s_providers.add(this);\r\n+        }\r\n+    }\r\n+\r\n+    public void broadcast(RemoteCommitEvent event) {\r\n+        synchronized (s_providers) {\r\n+            SingleJVMRemoteCommitProvider provider;\r\n+            for (Iterator iter = s_providers.iterator(); iter.hasNext();) {\r\n+                provider = (SingleJVMRemoteCommitProvider) iter.next();\r\n+                // don't notify this object -- this provider's factory\r\n+                // should not be notified of commits that originated\r\n+                // with one of its brokers\r\n+                if (provider == this)\r\n+                    continue;\r\n+                provider.fireEvent(event);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        synchronized (s_providers) {\r\n+            s_providers.remove(this);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"da491d9432165846c39e7111663ea243334a1651","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Listener for when persistent instances are stored to the database.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @author Abe White\r\n+ */\r\n+public interface StoreListener {\r\n+\r\n+    /**\r\n+     * Invoked just prior to store.\r\n+     */\r\n+    public void beforeStore(LifecycleEvent event);\r\n+\r\n+    /**\r\n+     * Invoked just after store.\r\n+     */\r\n+    public void afterStore(LifecycleEvent event);\r\n+}\r"},{"sha":"98e9c79cc167ed0b438b99861e391677b7ebc2a6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"added","additions":869,"deletions":0,"changes":869,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,869 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.io.BufferedInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.EOFException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.OptionalDataException;\r\n+import java.io.OutputStream;\r\n+import java.net.InetAddress;\r\n+import java.net.ServerSocket;\r\n+import java.net.Socket;\r\n+import java.net.SocketException;\r\n+import java.net.UnknownHostException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.pool.PoolableObjectFactory;\r\n+import org.apache.commons.pool.impl.GenericObjectPool;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * TCP-based implementation of {@link RemoteCommitProvider} that\r\n+ * listens for object modifications and propagates those changes to\r\n+ * other RemoteCommitProviders over TCP sockets.\r\n+ *\r\n+ * @author Brian Leair\r\n+ * @author Patrick Linskey\r\n+ * @since 2.5.0\r\n+ */\r\n+public class TCPRemoteCommitProvider extends AbstractRemoteCommitProvider\r\n+    implements Configurable {\r\n+\r\n+    private static final int DEFAULT_PORT = 5636;\r\n+    private static Localizer s_loc = Localizer.forPackage\r\n+        (TCPRemoteCommitProvider.class);\r\n+    private static long s_idSequence = System.currentTimeMillis();\r\n+    // A map of listen ports to listeners in this JVM. We might\r\n+    // want to look into allowing same port, different interface --\r\n+    // that is not currently possible in a single JVM.\r\n+    private static Map s_portListenerMap = new HashMap();\r\n+    private long _id;\r\n+    private byte[] _localhost;\r\n+    private int _port = DEFAULT_PORT;\r\n+    private int _maxActive = 2;\r\n+    private int _maxIdle = 2;\r\n+    private int _recoveryTimeMillis = 15000;\r\n+    private TCPPortListener _listener;\r\n+    private BroadcastQueue _broadcastQueue = new BroadcastQueue();\r\n+    private LinkedList _broadcastThreads = new LinkedList();\r\n+    private ArrayList _addresses = new ArrayList();\r\n+    private edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock _addressesLock;\r\n+\r\n+    public TCPRemoteCommitProvider() throws UnknownHostException {\r\n+        // obtain a unique ID.\r\n+        synchronized (TCPRemoteCommitProvider.class) {\r\n+            _id = s_idSequence++;\r\n+        }\r\n+        // cache the local IP address.\r\n+        _localhost = InetAddress.getLocalHost().getAddress();\r\n+        _addressesLock =\r\n+            new edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock();\r\n+        setNumBroadcastThreads(2);\r\n+    }\r\n+\r\n+    /**\r\n+     * The port that this provider should listen on.\r\n+     */\r\n+    public int getPort() {\r\n+        return _port;\r\n+    }\r\n+\r\n+    /**\r\n+     * The port that this provider should listen on. Set once only.\r\n+     */\r\n+    public void setPort(int port) {\r\n+        _port = port;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait before retrying\r\n+     * to reconnect to a peer after it becomes unreachable.\r\n+     */\r\n+    public void setRecoveryTimeMillis(int recoverytime) {\r\n+        _recoveryTimeMillis = recoverytime;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait before retrying\r\n+     * to reconnect to a peer after it becomes unreachable.\r\n+     */\r\n+    public int getRecoveryTimeMillis() {\r\n+        return _recoveryTimeMillis;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of sockets that this provider can\r\n+     * simetaneously open to each peer in the cluster.\r\n+     */\r\n+    public void setMaxActive(int maxActive) {\r\n+        _maxActive = maxActive;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of sockets that this provider can\r\n+     * simetaneously open to each peer in the cluster.\r\n+     */\r\n+    public int getMaxActive() {\r\n+        return _maxActive;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of idle sockets that this provider can keep open\r\n+     * to each peer in the cluster.\r\n+     */\r\n+    public void setMaxIdle(int maxIdle) {\r\n+        _maxIdle = maxIdle;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of idle sockets that this provider can keep open\r\n+     * to each peer in the cluster.\r\n+     */\r\n+    public int getMaxIdle() {\r\n+        return _maxIdle;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of worker threads that are used for\r\n+     * transmitting packets to peers in the cluster.\r\n+     */\r\n+    public void setNumBroadcastThreads(int numBroadcastThreads) {\r\n+        synchronized (_broadcastThreads) {\r\n+            int cur = _broadcastThreads.size();\r\n+            if (cur > numBroadcastThreads) {\r\n+                // Notify the extra worker threads so they stop themselves\r\n+                // Threads will not end until they send another pk.\r\n+                Iterator iter = _broadcastThreads.iterator();\r\n+                for (int i = numBroadcastThreads; i < cur; i++) {\r\n+                    BroadcastWorkerThread worker = (BroadcastWorkerThread)\r\n+                        _broadcastThreads.removeFirst();\r\n+                    worker.setRunning(false);\r\n+                }\r\n+            } else if (cur < numBroadcastThreads) {\r\n+                // Create additional worker threads\r\n+                for (int i = cur; i < numBroadcastThreads; i++) {\r\n+                    BroadcastWorkerThread wt = new BroadcastWorkerThread();\r\n+                    wt.setDaemon(true);\r\n+                    wt.start();\r\n+                    _broadcastThreads.addLast(wt);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of worker threads that are used for\r\n+     * transmitting packets to peers in the cluster.\r\n+     */\r\n+    public int getNumBroadcastThreads() {\r\n+        return _broadcastThreads.size();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the list of addresses of peers to which this provider will\r\n+     * send events to. The peers are semicolon-separated <code>names</code>\r\n+     * list in the form of \"myhost1:portA;myhost2:portB\".\r\n+     */\r\n+    public void setAddresses(String names) throws UnknownHostException {\r\n+        // NYI. Could look for equivalence of addresses and avoid\r\n+        // changing those that didn't change.\r\n+        acquireWriteLock(_addressesLock);\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();) {\r\n+                ((HostAddress) iter.next()).close();\r\n+            }\r\n+            String[] toks = Strings.split(names, \";\", 0);\r\n+            _addresses = new ArrayList(toks.length);\r\n+            InetAddress localhost = InetAddress.getLocalHost();\r\n+            String localhostName = localhost.getHostName();\r\n+            for (int i = 0; i < toks.length; i++) {\r\n+                String host = toks[i];\r\n+                String hostname;\r\n+                int tmpPort;\r\n+                int colon = host.indexOf(':');\r\n+                if (colon != -1) {\r\n+                    hostname = host.substring(0, colon);\r\n+                    tmpPort = Integer.parseInt(host.substring(colon + 1));\r\n+                } else {\r\n+                    hostname = host;\r\n+                    tmpPort = DEFAULT_PORT;\r\n+                }\r\n+                InetAddress tmpAddress = InetAddress.getByName(hostname);\r\n+                // bleair: For each address we would rather make use of\r\n+                // the jdk1.4 isLinkLocalAddress() || isLoopbackAddress().\r\n+                // (Though in practice on win32 they don't work anyways!)\r\n+                // Instead we will check hostname. Not perfect, but\r\n+                // it will match often enough(people will typically\r\n+                // use the DNS machine names and be cutting/pasting.)\r\n+                if (localhostName.equals(hostname)) {\r\n+                    // This string matches the hostname for for ourselves, we\r\n+                    // don't actually need to send ourselves messages.\r\n+                    if (log.isTraceEnabled()) {\r\n+                        log.trace(s_loc.get(\"tcp-address-asself\",\r\n+                            tmpAddress.getHostName() + \":\" + tmpPort));\r\n+                    }\r\n+                } else {\r\n+                    HostAddress newAddress = new HostAddress(host);\r\n+                    _addresses.add(newAddress);\r\n+                    if (log.isTraceEnabled()) {\r\n+                        log.trace(s_loc.get(\"tcp-address-set\",\r\n+                            newAddress._address.getHostName() + \":\"\r\n+                                + newAddress._port));\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+        finally {\r\n+            releaseWriteLock(_addressesLock);\r\n+        }\r\n+    }\r\n+\r\n+    private void acquireWriteLock(\r\n+        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\r\n+        try {\r\n+            lock.writeLock().lockInterruptibly();\r\n+        } catch (InterruptedException e) {\r\n+        }\r\n+    }\r\n+\r\n+    private void releaseWriteLock(\r\n+        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\r\n+        lock.writeLock().unlock();\r\n+    }\r\n+\r\n+    private void acquireReadLock(\r\n+        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\r\n+        try {\r\n+            lock.readLock().lockInterruptibly();\r\n+        } catch (InterruptedException e) {\r\n+        }\r\n+    }\r\n+\r\n+    private void releaseReadLock(\r\n+        edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantReadWriteLock lock) {\r\n+        lock.readLock().unlock();\r\n+    }\r\n+    // ---------- Configurable implementation ----------\r\n+\r\n+    /**\r\n+     * Subclasses that need to perform actions in\r\n+     * {@link Configurable#endConfiguration} must invoke this method.\r\n+     */\r\n+    public void endConfiguration() {\r\n+        super.endConfiguration();\r\n+        synchronized (s_portListenerMap) {\r\n+            // see if a listener exists for this port.\r\n+            _listener = (TCPPortListener) s_portListenerMap.get\r\n+                (String.valueOf(_port));\r\n+            if (_listener == null ||\r\n+                (!_listener.isRunning() && _listener._port == _port)) {\r\n+                try {\r\n+                    _listener = new TCPPortListener(_port, log);\r\n+                    _listener.listen();\r\n+                    s_portListenerMap.put(String.valueOf(_port), _listener);\r\n+                } catch (Exception e) {\r\n+                    throw new GeneralException(s_loc.get(\"tcp-init-exception\",\r\n+                        String.valueOf(_port)), e).setFatal(true);\r\n+                }\r\n+            } else if (_listener.isRunning()) {\r\n+                if (_listener._port != _port) {\r\n+                    // this really shouldn't be able to happen.\r\n+                    throw new GeneralException(s_loc.get\r\n+                        (\"tcp-not-equal\", String.valueOf(_port))).\r\n+                        setFatal(true);\r\n+                }\r\n+            } else\r\n+                throw new InternalException(s_loc.get(\"tcp-listener-broken\"));\r\n+            _listener.addProvider(this);\r\n+        }\r\n+        acquireWriteLock(_addressesLock);\r\n+        try {\r\n+            HostAddress curAddress;\r\n+            for (Iterator iter = _addresses.iterator();\r\n+                iter.hasNext();) {\r\n+                curAddress = (HostAddress) iter.next();\r\n+                curAddress.setMaxActive(_maxActive);\r\n+                curAddress.setMaxIdle(_maxIdle);\r\n+            }\r\n+        }\r\n+        finally {\r\n+            releaseWriteLock(_addressesLock);\r\n+        }\r\n+    }\r\n+\r\n+    // ---------- RemoteCommitProvider implementation ----------\r\n+    // pre 3.3.4 = <no version number transmitted>\r\n+    // 3.3 Preview = 0x1428acfd;\r\n+    // 3.4 = 0x1428acff;\r\n+    private static final long PROTOCOL_VERSION = 0x1428acff;\r\n+\r\n+    public void broadcast(RemoteCommitEvent event) {\r\n+        try {\r\n+            // build a packet notifying other JVMs of object changes.\r\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n+            oos.writeLong(PROTOCOL_VERSION);\r\n+            oos.writeLong(_id);\r\n+            oos.writeInt(_port);\r\n+            oos.writeObject(_localhost);\r\n+            oos.writeObject(event);\r\n+            oos.flush();\r\n+            byte[] bytes = baos.toByteArray();\r\n+            baos.close();\r\n+            if (_broadcastThreads.isEmpty())\r\n+                sendUpdatePacket(bytes);\r\n+            else _broadcastQueue.addPacket(bytes);\r\n+        } catch (IOException ioe) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"tcp-payload-create-error\"), ioe);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Sends a change notification packet to other machines in this\r\n+     * provider cluster.\r\n+     */\r\n+    private void sendUpdatePacket(byte[] bytes) {\r\n+        acquireReadLock(_addressesLock);\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\r\n+                ((HostAddress) iter.next()).sendUpdatePacket(bytes);\r\n+        }\r\n+        finally {\r\n+            releaseReadLock(_addressesLock);\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        if (_listener != null)\r\n+            _listener.removeProvider(this);\r\n+        acquireWriteLock(_addressesLock);\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\r\n+                ((HostAddress) iter.next()).close();\r\n+        }\r\n+        finally {\r\n+            releaseWriteLock(_addressesLock);\r\n+        }\r\n+        // We are done transmitting. Interrupt any worker threads.\r\n+        synchronized (_broadcastThreads) {\r\n+            Thread worker;\r\n+            for (Iterator iter = _broadcastThreads.iterator();\r\n+                iter.hasNext();) {\r\n+                worker = (Thread) iter.next();\r\n+                worker.interrupt();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Utility class to hold messages to be sent. This\r\n+     * allows calls to broadcast() to return without\r\n+     * waiting for the send to complete.\r\n+     */\r\n+    private static class BroadcastQueue {\r\n+\r\n+        LinkedList _packetQueue = new LinkedList();\r\n+\r\n+        public synchronized void addPacket(byte[] bytes) {\r\n+            _packetQueue.addLast(bytes);\r\n+            notify();\r\n+        }\r\n+\r\n+        public synchronized byte[] removePacket() throws InterruptedException {\r\n+            while (_packetQueue.isEmpty())\r\n+                wait();\r\n+            return (byte[]) _packetQueue.removeFirst();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Threads to broadcast packets placed in the {@link BroadcastQueueu}.\r\n+     */\r\n+    private class BroadcastWorkerThread extends Thread {\r\n+\r\n+        private boolean _keepRunning = true;\r\n+\r\n+        public void run() {\r\n+            while (_keepRunning) {\r\n+                try {\r\n+                    // This will block until there is a packet to send.\r\n+                    byte[] bytes = _broadcastQueue.removePacket();\r\n+                    sendUpdatePacket(bytes);\r\n+                } catch (InterruptedException e) {\r\n+                    // End the thread.\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        public void setRunning(boolean keepRunning) {\r\n+            _keepRunning = keepRunning;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Responsible for listening for incoming packets and processing them.\r\n+     */\r\n+    private static class TCPPortListener implements Runnable {\r\n+\r\n+        private static Localizer s_loc = Localizer.forPackage\r\n+            (TCPPortListener.class);\r\n+        private final Log _log;\r\n+        private ServerSocket _receiveSocket;\r\n+        private Thread _acceptThread;\r\n+        private Set _receiverThreads = new HashSet();\r\n+        private Set _providers = new HashSet();\r\n+\r\n+        /**\r\n+         * Cache the local IP address\r\n+         */\r\n+        private byte[] _localhost;\r\n+\r\n+        /**\r\n+         * The port that this listener should listen on. Configured\r\n+         * by TCPRemoteCommitProvider.\r\n+         */\r\n+        private int _port;\r\n+\r\n+        /**\r\n+         * Should be set to <code>true</code> once the listener is listening.\r\n+         */\r\n+        private boolean _isRunning = false;\r\n+\r\n+        /**\r\n+         * Construct a new TCPPortListener configured to use the specified port.\r\n+         */\r\n+        private TCPPortListener(int port, Log log)\r\n+            throws UnknownHostException, IOException {\r\n+            _port = port;\r\n+            _log = log;\r\n+            _receiveSocket = new ServerSocket(_port);\r\n+            _localhost = InetAddress.getLocalHost().getAddress();\r\n+            if (_log.isTraceEnabled())\r\n+                _log.info(s_loc.get(\"tcp-start-listener\",\r\n+                    String.valueOf(_port)));\r\n+        }\r\n+\r\n+        private void listen() {\r\n+            _acceptThread = new Thread(this);\r\n+            _acceptThread.setDaemon(true);\r\n+            _acceptThread.start();\r\n+        }\r\n+\r\n+        /**\r\n+         * All providers added here will be notified of any incoming\r\n+         * provider messages. There will be one of these per\r\n+         * BrokerFactory in a given JVM.\r\n+         * {@link TCPRemoteCommitProvider#endConfiguration} invokes\r\n+         * <code>addProvider</code> with <code>this</code> upon\r\n+         * completion of configuration.\r\n+         */\r\n+        private void addProvider(TCPRemoteCommitProvider provider) {\r\n+            synchronized (_providers) {\r\n+                _providers.add(provider);\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Remove a provider from the list of providers to notify of\r\n+         * commit events.\r\n+         */\r\n+        private synchronized void removeProvider\r\n+            (TCPRemoteCommitProvider provider) {\r\n+            synchronized (_providers) {\r\n+                _providers.remove(provider);\r\n+                // if the provider list is empty, shut down the thread.\r\n+                if (_providers.size() == 0) {\r\n+                    _isRunning = false;\r\n+                    try {\r\n+                        _receiveSocket.close();\r\n+                    } catch (IOException ioe) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-close-error\"), ioe);\r\n+                    }\r\n+                    _acceptThread.interrupt();\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private boolean isRunning() {\r\n+            synchronized (_providers) {\r\n+                return _isRunning;\r\n+            }\r\n+        }\r\n+\r\n+        public void run() {\r\n+            synchronized (_providers) {\r\n+                _isRunning = true;\r\n+            }\r\n+            Socket s = null;\r\n+            while (_isRunning) {\r\n+                try {\r\n+                    s = null;\r\n+                    // Block, waiting to accept new connection from a peer\r\n+                    s = _receiveSocket.accept();\r\n+                    if (_log.isTraceEnabled()) {\r\n+                        _log.trace(s_loc.get(\"tcp-received-connection\",\r\n+                            s.getInetAddress().getHostAddress()\r\n+                                + \":\" + s.getPort()));\r\n+                    }\r\n+                    ReceiveSocketHandler sh = new ReceiveSocketHandler(s);\r\n+                    Thread receiverThread = new Thread(sh);\r\n+                    receiverThread.setDaemon(true);\r\n+                    receiverThread.start();\r\n+                    _receiverThreads.add(receiverThread);\r\n+                } catch (Exception e) {\r\n+                    if (!(e instanceof SocketException) || _isRunning)\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-accept-error\"), e);\r\n+                    // Nominal case(InterruptedException) because close()\r\n+                    // calls _acceptThread.interrupt();\r\n+                    try {\r\n+                        if (s != null)\r\n+                            s.close();\r\n+                    } catch (Exception ee) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-close-error\"), e);\r\n+                    }\r\n+                }\r\n+            }\r\n+            // We are done listening. Interrupt any worker threads.\r\n+            Thread worker;\r\n+            for (Iterator iter = _receiverThreads.iterator();\r\n+                iter.hasNext();) {\r\n+                worker = (Thread) iter.next();\r\n+                // FYI, the worker threads are blocked\r\n+                // reading from the socket's InputStream. InputStreams\r\n+                // aren't interruptable, so this interrupt isn't\r\n+                // really going to be delivered until something breaks\r\n+                // the InputStream.\r\n+                worker.interrupt();\r\n+            }\r\n+            synchronized (_providers) {\r\n+                try {\r\n+                    if (_isRunning)\r\n+                        _receiveSocket.close();\r\n+                } catch (Exception e) {\r\n+                    if (_log.isWarnEnabled())\r\n+                        _log.warn(s_loc.get(\"tcp-close-error\"), e);\r\n+                }\r\n+                _isRunning = false;\r\n+                if (_log.isTraceEnabled())\r\n+                    _log.trace(s_loc.get(\"tcp-close-listener\", _port + \"\"));\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Utility class that acts as a worker thread to receive Events\r\n+         * from broadcasters.\r\n+         */\r\n+        private class ReceiveSocketHandler implements Runnable {\r\n+\r\n+            private InputStream _in;\r\n+            private Socket _s;\r\n+\r\n+            private ReceiveSocketHandler(Socket s) {\r\n+                // We are the receiving end and we don't send any messages\r\n+                // back to the broadcaster. Turn off Nagle's so that\r\n+                // we will send ack packets without waiting.\r\n+                _s = s;\r\n+                try {\r\n+                    _s.setTcpNoDelay(true);\r\n+                    _in = new BufferedInputStream(s.getInputStream());\r\n+                } catch (IOException ioe) {\r\n+                    if (_log.isInfoEnabled())\r\n+                        _log.info(s_loc.get(\"tcp-socket-option-error\"), ioe);\r\n+                    _s = null;\r\n+                } catch (Exception e) {\r\n+                    if (_log.isWarnEnabled())\r\n+                        _log.warn(s_loc.get(\"tcp-receive-error\"), e);\r\n+                    _s = null;\r\n+                }\r\n+            }\r\n+\r\n+            public void run() {\r\n+                if (_s == null)\r\n+                    return;\r\n+                while (_isRunning && _s != null) {\r\n+                    try {\r\n+                        // This will block our thread, waiting to read\r\n+                        // the next Event-object-message.\r\n+                        handle(_in);\r\n+                    } catch (EOFException eof) {\r\n+                        // EOFException raised when peer is properly\r\n+                        // closing its end.\r\n+                        if (_log.isTraceEnabled()) {\r\n+                            _log.trace(s_loc.get(\"tcp-close-socket\",\r\n+                                _s.getInetAddress().getHostAddress()\r\n+                                    + \":\" + _s.getPort()));\r\n+                        }\r\n+                        break;\r\n+                    } catch (Exception e) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-receive-error\"), e);\r\n+                        break;\r\n+                    } catch (Throwable t) {\r\n+                    }\r\n+                }\r\n+                // We are done receiving on this socket and this worker\r\n+                // thread is terminating.\r\n+                try {\r\n+                    _in.close();\r\n+                    _s.close();\r\n+                } catch (Exception e) {\r\n+                    _log.warn(s_loc.get(\"tcp-close-socket-error\",\r\n+                        _s.getInetAddress().getHostAddress() + \":\"\r\n+                            + _s.getPort()), e);\r\n+                }\r\n+            }\r\n+\r\n+            /**\r\n+             * Process an {@link InputStream} containing objects written\r\n+             * by {@link TCPRemoteCommitProvider#broadcastCommitInfo}.\r\n+             */\r\n+            private void handle(InputStream in)\r\n+                throws IOException, ClassNotFoundException,\r\n+                OptionalDataException {\r\n+                // This will block waiting for the next\r\n+                ObjectInputStream ois = new ObjectInputStream(in);\r\n+                long protocolVersion = ois.readLong();\r\n+                if (protocolVersion != PROTOCOL_VERSION) {\r\n+                    if (_log.isWarnEnabled()) {\r\n+                        _log.warn(s_loc.get(\"tcp-wrong-version-error\",\r\n+                            _s.getInetAddress().getHostAddress() + \":\"\r\n+                                + _s.getPort()));\r\n+                        return;\r\n+                    }\r\n+                }\r\n+                long senderId = ois.readLong();\r\n+                int senderPort = ois.readInt();\r\n+                byte[] senderAddress = (byte[]) ois.readObject();\r\n+                RemoteCommitEvent rce = (RemoteCommitEvent) ois.readObject();\r\n+                if (_log.isTraceEnabled()) {\r\n+                    _log.trace(s_loc.get(\"tcp-received-event\",\r\n+                        _s.getInetAddress().getHostAddress() + \":\"\r\n+                            + _s.getPort()));\r\n+                }\r\n+                boolean fromSelf = senderPort == _port &&\r\n+                    Arrays.equals(senderAddress, _localhost);\r\n+                TCPRemoteCommitProvider provider;\r\n+                synchronized (_providers) {\r\n+                    // bleair: We're iterating, but currenlty there can really\r\n+                    // only be a single provider.\r\n+                    for (Iterator iter = _providers.iterator();\r\n+                        iter.hasNext();) {\r\n+                        provider = (TCPRemoteCommitProvider) iter.next();\r\n+                        if (senderId != provider._id || !fromSelf)\r\n+                            provider.eventManager.fireEvent(rce);\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Utility class to store an InetAddress and an int. Not using\r\n+     * InetSocketAddress because it's a JDK1.4 API. This also\r\n+     * provides a wrapper around the socket(s) associated with this address.\r\n+     */\r\n+    private class HostAddress {\r\n+\r\n+        private InetAddress _address;\r\n+        private int _port;\r\n+        private long _timeLastError; // millis\r\n+        private boolean _isAvailable; // is peer thought to be up\r\n+        private int _infosIssued = 0; // limit log entries\r\n+        private GenericObjectPool _socketPool; // reusable open sockets\r\n+\r\n+        /**\r\n+         * Construct a new host address from a string of the form\r\n+         * \"host:port\" or of the form \"host\".\r\n+         */\r\n+        private HostAddress(String host) throws UnknownHostException {\r\n+            int colon = host.indexOf(':');\r\n+            if (colon != -1) {\r\n+                _address = InetAddress.getByName(host.substring(0, colon));\r\n+                _port = Integer.parseInt(host.substring(colon + 1));\r\n+            } else {\r\n+                _address = InetAddress.getByName(host);\r\n+                _port = DEFAULT_PORT;\r\n+            }\r\n+            // -1 max wait == as long as it takes\r\n+            _socketPool = new GenericObjectPool\r\n+                (new SocketPoolableObjectFactory(), _maxActive,\r\n+                    GenericObjectPool.WHEN_EXHAUSTED_BLOCK, -1);\r\n+            _isAvailable = true;\r\n+        }\r\n+\r\n+        private void setMaxActive(int maxActive) {\r\n+            _socketPool.setMaxActive(maxActive);\r\n+        }\r\n+\r\n+        private void setMaxIdle(int maxIdle) {\r\n+            _socketPool.setMaxIdle(maxIdle);\r\n+        }\r\n+\r\n+        public void close() {\r\n+            // Close the pool of sockets to this peer. This\r\n+            // will close all sockets in the pool.\r\n+            try {\r\n+                _socketPool.close();\r\n+            } catch (Exception e) {\r\n+                if (log.isWarnEnabled()) {\r\n+                    log.warn(s_loc.get(\"tcp-close-pool-error\"), e);\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private void sendUpdatePacket(byte[] bytes) {\r\n+            if (!_isAvailable) {\r\n+                long now = System.currentTimeMillis();\r\n+                if (now - _timeLastError < _recoveryTimeMillis)\r\n+                    // Not enough time has passed since the last error\r\n+                    return;\r\n+            }\r\n+            Socket s = null;\r\n+            try {\r\n+                s = getSocket();\r\n+                OutputStream os = s.getOutputStream();\r\n+                os.write(bytes);\r\n+                os.flush();\r\n+                if (log.isTraceEnabled()) {\r\n+                    log.trace(s_loc.get(\"tcp-sent-update\",\r\n+                        _address.getHostAddress() + \":\" + _port,\r\n+                        String.valueOf(s.getLocalPort())));\r\n+                }\r\n+                _isAvailable = true;\r\n+                _infosIssued = 0;\r\n+                // Return the socket to the pool; the socket is\r\n+                // still good.\r\n+                returnSocket(s);\r\n+            } catch (Exception e) {\r\n+                // There has been a problem sending to the peer.\r\n+                // The OS socket that was being used is can no longer\r\n+                // be used.\r\n+                if (s != null)\r\n+                    this.closeSocket(s);\r\n+                this.clearAllSockets();\r\n+                if (_isAvailable) {\r\n+                    // Log a warning, the peer was up and has now gone down\r\n+                    if (log.isWarnEnabled()) {\r\n+                        log.warn(s_loc.get(\"tcp-send-error\",\r\n+                            _address.getHostAddress() + \":\" + _port), e);\r\n+                    }\r\n+                    _isAvailable = false;\r\n+                    // Once enough time has passed we will log another warning\r\n+                    _timeLastError = System.currentTimeMillis();\r\n+                } else {\r\n+                    long now = System.currentTimeMillis();\r\n+                    if (now - _timeLastError > _recoveryTimeMillis) {\r\n+                        if (_infosIssued < 5) {\r\n+                            // Enough time has passed, and peer is still down\r\n+                            _timeLastError = System.currentTimeMillis();\r\n+                            // We were trying to reestablish the connection,\r\n+                            // but we failed again. Log a message, but\r\n+                            // lower severity. This log will occur periodically\r\n+                            // for 5 times until the peer comes back.\r\n+                            if (log.isInfoEnabled()) {\r\n+                                log.info(s_loc.get(\"tcp-send-still-error\",\r\n+                                    _address.getHostAddress() + \":\"\r\n+                                        + _port), e);\r\n+                            }\r\n+                            _infosIssued++;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private Socket getSocket() throws Exception {\r\n+            return (Socket) _socketPool.borrowObject();\r\n+        }\r\n+\r\n+        private void returnSocket(Socket s) throws Exception {\r\n+            _socketPool.returnObject(s);\r\n+        }\r\n+\r\n+        private void clearAllSockets() {\r\n+            _socketPool.clear();\r\n+        }\r\n+\r\n+        private void closeSocket(Socket s) {\r\n+            // All sockets come from the pool.\r\n+            // This socket is no longer usable, so delete it from the\r\n+            // pool.\r\n+            try {\r\n+                _socketPool.invalidateObject(s);\r\n+            } catch (Exception e) {\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Factory for pooled sockets.\r\n+         */\r\n+        private class SocketPoolableObjectFactory\r\n+            implements PoolableObjectFactory {\r\n+\r\n+            public Object makeObject() throws IOException {\r\n+                Socket s = new Socket(_address, _port);\r\n+                if (log.isTraceEnabled()) {\r\n+                    log.trace(s_loc.get(\"tcp-open-connection\",\r\n+                        _address + \":\" + _port, \"\" + s.getLocalPort()));\r\n+                }\r\n+                return s;\r\n+            }\r\n+\r\n+            public void destroyObject(Object obj) {\r\n+                // silentClose().\r\n+                try {\r\n+                    Socket s = (Socket) obj;\r\n+                    if (log.isTraceEnabled())\r\n+                        log.trace(s_loc.get(\"tcp-close-sending-socket\",\r\n+                            _address + \":\" + _port, \"\" + s.getLocalPort()));\r\n+                    s.close();\r\n+                } catch (Exception e) {\r\n+                    log.warn(s_loc.get(\"tcp-close-socket-error\",\r\n+                        _address.getHostAddress() + \":\" + _port), e);\r\n+                }\r\n+            }\r\n+\r\n+            public boolean validateObject(Object obj) {\r\n+                return true;\r\n+            }\r\n+\r\n+            public void activateObject(Object value) {\r\n+            }\r\n+\r\n+            public void passivateObject(Object value) {\r\n+            }\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"4180f8e1f2c40dc3a4387329e5118fb6b36f7a62","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","status":"added","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,147 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.EventObject;\r\n+\r\n+import org.apache.openjpa.kernel.Broker;\r\n+\r\n+/**\r\n+ * A transactional event. The event source is the {@link Broker} whose\r\n+ * transaction state changed.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 3.0\r\n+ */\r\n+public class TransactionEvent extends EventObject {\r\n+\r\n+    /**\r\n+     * Event type signifying that a transaction has just begun.\r\n+     */\r\n+    public static final int AFTER_BEGIN = 0;\r\n+\r\n+    /**\r\n+     * Event type signifying that changes are about to be flushed to the\r\n+     * datastore. This does not necessarily mean that a commit is taking place.\r\n+     */\r\n+    public static final int BEFORE_FLUSH = 1;\r\n+\r\n+    /**\r\n+     * Event type signifying that changes have been flushed to the datastore.\r\n+     * This event is only fired if flushing is successful.\r\n+     */\r\n+    public static final int AFTER_FLUSH = 2;\r\n+\r\n+    /**\r\n+     * Event type signifying that the transaction is about to be committed.\r\n+     * This will be fired before the {@link #BEFORE_FLUSH} event for the\r\n+     * transaction, so that you can differentiate between flushes for commits\r\n+     * and other flushes.\r\n+     */\r\n+    public static final int BEFORE_COMMIT = 3;\r\n+\r\n+    /**\r\n+     * Event type signifying that the transaction has committed.\r\n+     */\r\n+    public static final int AFTER_COMMIT = 4;\r\n+\r\n+    /**\r\n+     * Event type signifying that the transaction was rolled back.\r\n+     */\r\n+    public static final int AFTER_ROLLBACK = 5;\r\n+\r\n+    /**\r\n+     * Event type signifying that all state transitions have been made.\r\n+     */\r\n+    public static final int AFTER_STATE_TRANSITIONS = 6;\r\n+\r\n+    /**\r\n+     * Event type signifying that the commit has completey ended and the\r\n+     * transaction is no longer active.\r\n+     */\r\n+    public static final int AFTER_COMMIT_COMPLETE = 7;\r\n+\r\n+    /**\r\n+     * Event type signifying that the rollback has completey ended and the\r\n+     * transaction is no longer active.\r\n+     */\r\n+    public static final int AFTER_ROLLBACK_COMPLETE = 8;\r\n+    private final int _type;\r\n+    private transient final Collection _objs;\r\n+    private transient final Collection _addClss;\r\n+    private transient final Collection _updateClss;\r\n+    private transient final Collection _deleteClss;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param pm         the event source\r\n+     * @param type       the event type\r\n+     * @param objs       transactional objects\r\n+     * @param addClss    classes of added instances\r\n+     * @param updateClss classes of updated instances\r\n+     * @param deleteClss classes of deleted instances\r\n+     */\r\n+    public TransactionEvent(Broker broker, int type,\r\n+        Collection objs, Collection addClss, Collection updateClss,\r\n+        Collection deleteClss) {\r\n+        super(broker);\r\n+        _type = type;\r\n+        _objs = (objs == null) ? Collections.EMPTY_LIST : objs;\r\n+        _addClss = (addClss == null) ? Collections.EMPTY_SET : addClss;\r\n+        _updateClss = (updateClss == null) ? Collections.EMPTY_SET : updateClss;\r\n+        _deleteClss = (deleteClss == null) ? Collections.EMPTY_SET : deleteClss;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the type of event.\r\n+     */\r\n+    public int getType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the unmodifiable set of persistence capable objects\r\n+     * participating in the transaction. This set will contain all dirty\r\n+     * objects, but may not contain clean objects.\r\n+     */\r\n+    public Collection getTransactionalObjects() {\r\n+        return _objs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the unmodifiable the set of classes of\r\n+     * persistence capable objects that were created in the transaction.\r\n+     */\r\n+    public Collection getPersistedTypes() {\r\n+        return _addClss;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the unmodifiable the set of classes of\r\n+     * persistence capable objects that were modified in the transaction.\r\n+     */\r\n+    public Collection getUpdatedTypes() {\r\n+        return _updateClss;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the unmodifiable the set of classes of\r\n+     * persistence capable objects that were deleted in the transaction.\r\n+     */\r\n+    public Collection getDeletedTypes() {\r\n+        return _deleteClss;\r\n+    }\r\n+}\r"},{"sha":"3639583e50eb8d8f0599e28bb481e078115445d2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,121 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+\r\n+/**\r\n+ * Manager that can be used to track and notify transaction listeners\r\n+ * of transaction-related events.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 3.0\r\n+ */\r\n+public class TransactionEventManager extends AbstractConcurrentEventManager {\r\n+\r\n+    private int _begin = 0;\r\n+    private int _flush = 0;\r\n+    private int _end = 0;\r\n+\r\n+    public void addListener(Object listener) {\r\n+        super.addListener(listener);\r\n+        if (listener instanceof BeginTransactionListener)\r\n+            _begin++;\r\n+        if (listener instanceof FlushTransactionListener)\r\n+            _flush++;\r\n+        if (listener instanceof EndTransactionListener)\r\n+            _end++;\r\n+    }\r\n+\r\n+    public boolean removeListener(Object listener) {\r\n+        if (!super.removeListener(listener))\r\n+            return false;\r\n+        if (listener instanceof BeginTransactionListener)\r\n+            _begin--;\r\n+        if (listener instanceof FlushTransactionListener)\r\n+            _flush--;\r\n+        if (listener instanceof EndTransactionListener)\r\n+            _end--;\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any begin transaction listeners.\r\n+     */\r\n+    public boolean hasBeginListeners() {\r\n+        return _begin > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any flush transaction listeners.\r\n+     */\r\n+    public boolean hasFlushListeners() {\r\n+        return _flush > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any end transaction listeners.\r\n+     */\r\n+    public boolean hasEndListeners() {\r\n+        return _end > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire the given event to all registered listeners.\r\n+     */\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        TransactionEvent ev = (TransactionEvent) event;\r\n+        switch (ev.getType()) {\r\n+            case TransactionEvent.AFTER_BEGIN:\r\n+                if (listener instanceof BeginTransactionListener)\r\n+                    ((BeginTransactionListener) listener).afterBegin(ev);\r\n+                break;\r\n+            case TransactionEvent.BEFORE_FLUSH:\r\n+                if (listener instanceof FlushTransactionListener)\r\n+                    ((FlushTransactionListener) listener).beforeFlush(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_FLUSH:\r\n+                if (listener instanceof FlushTransactionListener)\r\n+                    ((FlushTransactionListener) listener).afterFlush(ev);\r\n+                break;\r\n+            case TransactionEvent.BEFORE_COMMIT:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).beforeCommit(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_COMMIT:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterCommit(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_ROLLBACK:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterRollback(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_STATE_TRANSITIONS:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener)\r\n+                        .afterStateTransitions(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_COMMIT_COMPLETE:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterCommitComplete(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_ROLLBACK_COMPLETE:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener)\r\n+                        .afterRollbackComplete(ev);\r\n+                break;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"a38408286452cb6be94c648c217510bacde4077f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,26 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+/**\r\n+ * Interface for listening to all {@link TransactionEvent}s.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 2.5.0\r\n+ */\r\n+public interface TransactionListener\r\n+    extends BeginTransactionListener, FlushTransactionListener,\r\n+    EndTransactionListener {\r\n+\r\n+}\r"},{"sha":"145a71ec76671a6020f0411b3cc0866b5b7f5281","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","status":"added","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,12 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA Events</strong></p>\n+\n+<p>\n+    This package provides some interfaces and useful implementations\n+    for OpenJPA's event notification framework. This framework\n+    allows efficient notification of object modifications and\n+    transaction changes.\n+</p>\n+</body>\n+</html>"},{"sha":"bee289c7eff13e1f66c83cd6493876eef1961368","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"added","additions":612,"deletions":0,"changes":612,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,612 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.ObjectStreamException;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import javax.transaction.Status;\r\n+import javax.transaction.Synchronization;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAVersion;\r\n+import org.apache.openjpa.datacache.DataCacheStoreManager;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\r\n+import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Abstract implementation of the {@link BrokerFactory}\r\n+ * that must be subclassed for a specific runtime.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractBrokerFactory implements BrokerFactory {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (AbstractBrokerFactory.class);\r\n+    // static mapping of configurations to pooled broker factories\r\n+    private static final Map _pool = Collections.synchronizedMap\r\n+        (new HashMap());\r\n+    // configuration\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private transient boolean _readOnly = false;\r\n+    private transient RuntimeException _closed = null;\r\n+    private Map _userObjects = null;\r\n+    // internal lock: spec forbids synchronization on this object\r\n+    private final ReentrantLock _lock = new ReentrantLock();\r\n+    // maps global transactions to associated brokers\r\n+    private transient Map _transactional = new HashMap();\r\n+    // weak-ref tracking of open brokers\r\n+    private transient Collection _brokers = new ReferenceHashSet\r\n+        (ReferenceHashSet.WEAK);\r\n+    // cache the class names loaded from the persistent classes property so\r\n+    // that we can re-load them for each new broker\r\n+    private transient Collection _pcClassNames = null;\r\n+    private transient Collection _pcClassLoaders = null;\r\n+    // lifecycle listeners to pass to each broker\r\n+    private transient Map _lifecycleListeners = null;\r\n+\r\n+    /**\r\n+     * Return the pooled factory matching the given configuration, or null\r\n+     * if none.\r\n+     */\r\n+    public static AbstractBrokerFactory getPooledFactory(\r\n+        OpenJPAConfiguration conf) {\r\n+        return (AbstractBrokerFactory) _pool.get(toPoolKey(conf));\r\n+    }\r\n+\r\n+    private static Map toPoolKey(OpenJPAConfiguration conf) {\r\n+        return conf.toProperties(false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the pooled factory matching the given configuration data, or null\r\n+     * if none.\r\n+     */\r\n+    protected static AbstractBrokerFactory getPooledFactory(Map map) {\r\n+        return (AbstractBrokerFactory) _pool.get(map);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. Configuration must be provided on construction.\r\n+     */\r\n+    protected AbstractBrokerFactory(OpenJPAConfiguration config) {\r\n+        _conf = config;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the configuration for this factory.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    public Broker newBroker() {\r\n+        return newBroker(_conf.getConnectionUserName(),\r\n+            _conf.getConnectionPassword());\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass) {\r\n+        return newBroker(user, pass, _conf.isTransactionModeManaged(),\r\n+            _conf.getConnectionRetainModeConstant());\r\n+    }\r\n+\r\n+    public Broker newBroker(boolean managed, int connRetainMode) {\r\n+        return newBroker(_conf.getConnectionUserName(),\r\n+            _conf.getConnectionPassword(), managed, connRetainMode);\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass, boolean managed,\r\n+        int connRetainMode) {\r\n+        return newBroker(user, pass, managed, connRetainMode, true);\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass, boolean managed,\r\n+        int connRetainMode, boolean findExisting) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            makeReadOnly();\r\n+            BrokerImpl broker = null;\r\n+            if (findExisting)\r\n+                broker = findBroker(user, pass, managed);\r\n+            if (broker == null) {\r\n+                // decorate the store manager for data caching and custom\r\n+                // result object providers; always make sure it's a delegating\r\n+                // store manager, because it's easier for users to deal with\r\n+                // that way\r\n+                StoreManager sm = newStoreManager();\r\n+                DelegatingStoreManager dsm = null;\r\n+                if (_conf.getDataCacheManagerInstance().getSystemDataCache()\r\n+                    != null)\r\n+                    dsm = new DataCacheStoreManager(sm);\r\n+                dsm = new ROPStoreManager((dsm == null) ? sm : dsm);\r\n+                broker = newBrokerImpl(user, pass);\r\n+                broker.initialize(this, dsm, managed, connRetainMode);\r\n+                addLifecycleListeners(broker);\r\n+                // if we're using remote events, register the event manager so\r\n+                // that it can broadcast commit notifications from the broker\r\n+                RemoteCommitEventManager remote = _conf.\r\n+                    getRemoteCommitEventManager();\r\n+                if (remote.areRemoteEventsEnabled())\r\n+                    broker.addTransactionListener(remote);\r\n+                loadPersistentTypes(broker.getClassLoader());\r\n+            }\r\n+            _brokers.add(broker);\r\n+            return broker;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (RuntimeException re) {\r\n+            throw new GeneralException(re);\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Add factory-registered lifecycle listeners to the broker.\r\n+     */\r\n+    protected void addLifecycleListeners(BrokerImpl broker) {\r\n+        if (_lifecycleListeners == null || _lifecycleListeners.isEmpty())\r\n+            return;\r\n+        Map.Entry entry;\r\n+        for (Iterator itr = _lifecycleListeners.entrySet().iterator();\r\n+            itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            broker.addLifecycleListener(entry.getKey(), (Class[])\r\n+                entry.getValue());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the configured persistent classes list. Performed automatically\r\n+     * whenever a broker is created.\r\n+     */\r\n+    private void loadPersistentTypes(ClassLoader envLoader) {\r\n+        // no listed persistent types?\r\n+        if (_pcClassNames != null && _pcClassNames.isEmpty())\r\n+            return;\r\n+        // cache persistent type names if not already\r\n+        ClassLoader loader = _conf.getClassResolverInstance().\r\n+            getClassLoader(getClass(), envLoader);\r\n+        if (_pcClassNames == null) {\r\n+            Collection clss = _conf.getMetaDataRepository().loadPersistentTypes\r\n+                (false, loader);\r\n+            if (clss.isEmpty())\r\n+                _pcClassNames = Collections.EMPTY_SET;\r\n+            else {\r\n+                _pcClassNames = new ArrayList(clss.size());\r\n+                for (Iterator itr = clss.iterator(); itr.hasNext();)\r\n+                    _pcClassNames.add(((Class) itr.next()).getName());\r\n+                _pcClassLoaders = new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n+                _pcClassLoaders.add(loader);\r\n+            }\r\n+            return;\r\n+        }\r\n+        // reload with this loader\r\n+        if (_pcClassLoaders.add(loader)) {\r\n+            for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\r\n+                try {\r\n+                    Class.forName((String) itr.next(), true, loader);\r\n+                } catch (Throwable t) {\r\n+                    _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(t, t);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void addLifecycleListener(Object listener, Class[] classes) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_lifecycleListeners == null)\r\n+                _lifecycleListeners = new HashMap(7);\r\n+            _lifecycleListeners.put(listener, classes);\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void removeLifecycleListener(Object listener) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_lifecycleListeners != null)\r\n+                _lifecycleListeners.remove(listener);\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if this broker factory is closed.\r\n+     */\r\n+    public boolean isClosed() {\r\n+        return _closed != null;\r\n+    }\r\n+\r\n+    public void close() {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            assertNoActiveTransaction();\r\n+            // remove from factory pool\r\n+            Map map = toPoolKey(_conf);\r\n+            synchronized (_pool) {\r\n+                if (_pool.get(map) == this)\r\n+                    _pool.remove(map);\r\n+            }\r\n+            // close all brokers\r\n+            Broker broker;\r\n+            for (Iterator itr = _brokers.iterator(); itr.hasNext();) {\r\n+                broker = (Broker) itr.next();\r\n+                if (!broker.isClosed())\r\n+                    broker.close();\r\n+            }\r\n+            // remove metadata repository from listener list\r\n+            PCRegistry.removeRegisterClassListener\r\n+                (_conf.getMetaDataRepository());\r\n+            _conf.close();\r\n+            _closed = new IllegalStateException();\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Subclasses should override this method to add a <code>Platform</code>\r\n+     * property listing the runtime platform, such as:\r\n+     * <code>OpenJPA JDBC Edition: Oracle Database</code>\r\n+     */\r\n+    public Properties getProperties() {\r\n+        // required props are VendorName and VersionNumber\r\n+        Properties props = new Properties();\r\n+        props.setProperty(\"VendorName\", OpenJPAVersion.VENDOR_NAME);\r\n+        props.setProperty(\"VersionNumber\", OpenJPAVersion.VERSION_NUMBER);\r\n+        props.setProperty(\"VersionId\", OpenJPAVersion.VERSION_ID);\r\n+        return props;\r\n+    }\r\n+\r\n+    public Object getUserObject(Object key) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            return (_userObjects == null) ? null : _userObjects.get(key);\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public Object putUserObject(Object key, Object val) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (val == null)\r\n+                return (_userObjects == null) ? null : _userObjects.remove(key);\r\n+            if (_userObjects == null)\r\n+                _userObjects = new HashMap();\r\n+            return _userObjects.put(key, val);\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void lock() {\r\n+        _lock.lock();\r\n+    }\r\n+\r\n+    public void unlock() {\r\n+        _lock.unlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Replaces the factory with this JVMs pooled version if it exists. Also\r\n+     * freezes the factory.\r\n+     */\r\n+    protected Object readResolve() throws ObjectStreamException {\r\n+        AbstractBrokerFactory factory = getPooledFactory(_conf);\r\n+        if (factory != null)\r\n+            return factory;\r\n+        // reset these transient fields to empty values\r\n+        _transactional = new HashMap();\r\n+        _brokers = new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n+        makeReadOnly();\r\n+        return this;\r\n+    }\r\n+    ////////////////////////\r\n+    // Methods for Override\r\n+    ////////////////////////\r\n+\r\n+    /**\r\n+     * Return a new StoreManager for this runtime. Note that the instance\r\n+     * returned here may be wrapped before being passed to the\r\n+     * {@link #newBroker} method.\r\n+     */\r\n+    protected abstract StoreManager newStoreManager();\r\n+\r\n+    /**\r\n+     * Find a pooled broker, or return null if none. If using\r\n+     * managed transactions, looks for a transactional broker;\r\n+     * otherwise returns null by default. This method will be called before\r\n+     * {@link #newStoreManager} so that factory subclasses implementing\r\n+     * pooling can return a matching manager before a new {@link StoreManager}\r\n+     * is created.\r\n+     */\r\n+    protected BrokerImpl findBroker(String user, String pass, boolean managed) {\r\n+        if (managed)\r\n+            return findTransactionalBroker(user, pass);\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a broker configured with the proper settings.\r\n+     * By default, this method constructs a new\r\n+     * BrokerImpl of the class set for this factory.\r\n+     */\r\n+    protected BrokerImpl newBrokerImpl(String user, String pass) {\r\n+        BrokerImpl broker = _conf.newBrokerInstance(user, pass);\r\n+        if (broker == null)\r\n+            throw new UserException(_loc.get(\"no-broker-class\",\r\n+                _conf.getBrokerImpl()));\r\n+        return broker;\r\n+    }\r\n+\r\n+    /**\r\n+     * Setup transient state used by this factory based on the\r\n+     * current configuration, which will subsequently be locked down. This\r\n+     * method will be called before the first broker is requested,\r\n+     * and will be re-called each time the factory is deserialized into a JVM\r\n+     * that has no configuration for this data store.\r\n+     */\r\n+    protected void setup() {\r\n+    }\r\n+    /////////////\r\n+    // Utilities\r\n+    /////////////\r\n+\r\n+    /**\r\n+     * Find a managed runtime broker associated with the\r\n+     * current transaction, or returns null if none.\r\n+     */\r\n+    protected BrokerImpl findTransactionalBroker(String user, String pass) {\r\n+        Transaction trans = null;\r\n+        try {\r\n+            trans = _conf.getManagedRuntimeInstance().getTransactionManager().\r\n+                getTransaction();\r\n+            if (trans == null ||\r\n+                trans.getStatus() == Status.STATUS_NO_TRANSACTION\r\n+                || trans.getStatus() == Status.STATUS_UNKNOWN)\r\n+                return null;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new GeneralException(e);\r\n+        }\r\n+        synchronized (_transactional) {\r\n+            Collection brokers = (Collection) _transactional.get(trans);\r\n+            if (brokers != null) {\r\n+                BrokerImpl broker;\r\n+                for (Iterator itr = brokers.iterator(); itr.hasNext();) {\r\n+                    broker = (BrokerImpl) itr.next();\r\n+                    if (StringUtils.equals(broker.getConnectionUserName(),\r\n+                        user) && StringUtils.equals\r\n+                        (broker.getConnectionPassword(), pass))\r\n+                        return broker;\r\n+                }\r\n+            }\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given broker with the current factory option settings.\r\n+     */\r\n+    protected void configureBroker(BrokerImpl broker) {\r\n+        broker.setOptimistic(_conf.getOptimistic());\r\n+        broker.setNontransactionalRead(_conf.getNontransactionalRead());\r\n+        broker.setNontransactionalWrite(_conf.getNontransactionalWrite());\r\n+        broker.setRetainState(_conf.getRetainState());\r\n+        broker.setRestoreState(_conf.getRestoreStateConstant());\r\n+        broker.setAutoClear(_conf.getAutoClearConstant());\r\n+        broker.setIgnoreChanges(_conf.getIgnoreChanges());\r\n+        broker.setMultithreaded(_conf.getMultithreaded());\r\n+        broker.setAutoDetach(_conf.getAutoDetachConstant());\r\n+        broker.setDetachState(_conf.getDetachStateInstance().\r\n+            getDetachState());\r\n+    }\r\n+\r\n+    /**\r\n+     * Add the factory to the pool.\r\n+     */\r\n+    protected void pool() {\r\n+        synchronized (_pool) {\r\n+            _pool.put(toPoolKey(_conf), this);\r\n+            makeReadOnly();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Freezes the configuration of this factory.\r\n+     */\r\n+    public void makeReadOnly() {\r\n+        if (_readOnly)\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            // check again\r\n+            if (_readOnly)\r\n+                return;\r\n+            _readOnly = true;\r\n+            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+            if (log.isInfoEnabled())\r\n+                log.info(_loc.get(\"factory-init\",\r\n+                    OpenJPAVersion.VERSION_NUMBER));\r\n+            if (log.isTraceEnabled()) {\r\n+                Map props = _conf.toProperties(true);\r\n+                String lineSep = System.getProperty(\"line.separator\");\r\n+                StringBuffer buf = new StringBuffer();\r\n+                Map.Entry entry;\r\n+                for (Iterator itr = props.entrySet().iterator();\r\n+                    itr.hasNext();) {\r\n+                    entry = (Map.Entry) itr.next();\r\n+                    buf.append(entry.getKey()).append(\": \").\r\n+                        append(entry.getValue());\r\n+                    if (itr.hasNext())\r\n+                        buf.append(lineSep);\r\n+                }\r\n+                log.trace(buf.toString());\r\n+            }\r\n+            // setup transient state\r\n+            setup();\r\n+            // register the metdata repository to auto-load persistent types\r\n+            // and make sure types are enhanced\r\n+            MetaDataRepository repos = _conf.getMetaDataRepository();\r\n+            repos.setValidate(repos.VALIDATE_RUNTIME, true);\r\n+            repos.setResolve(repos.MODE_MAPPING_INIT, true);\r\n+            PCRegistry.addRegisterClassListener(repos);\r\n+            // freeze underlying configuration and eagerly initialize to\r\n+            // avoid synchronization\r\n+            _conf.setReadOnly(true);\r\n+            _conf.instantiateAll();\r\n+        }\r\n+        finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw an exception if the factory is closed.\r\n+     */\r\n+    private void assertOpen() {\r\n+        if (_closed != null)\r\n+            throw new InvalidStateException(_loc.get(\"closed-factory\")).\r\n+                setCause(_closed);\r\n+    }\r\n+    ////////////////////\r\n+    // Broker utilities\r\n+    ////////////////////\r\n+\r\n+    /**\r\n+     * Throws a {@link UserException} if a transaction is active. The thrown\r\n+     * exception will contain all the Brokers with active transactions as\r\n+     * failed objects in the nested exceptions.\r\n+     */\r\n+    private void assertNoActiveTransaction() {\r\n+        Collection excs = null;\r\n+        synchronized (_transactional) {\r\n+            if (_transactional.isEmpty())\r\n+                return;\r\n+            excs = new ArrayList(_transactional.size());\r\n+            for (Iterator trans = _transactional.values().iterator();\r\n+                trans.hasNext();) {\r\n+                Collection brokers = (Collection) trans.next();\r\n+                for (Iterator itr = brokers.iterator(); itr.hasNext();) {\r\n+                    excs.add(new InvalidStateException(_loc.get(\"active\")).\r\n+                        setFailedObject(itr.next()));\r\n+                }\r\n+            }\r\n+        }\r\n+        if (!excs.isEmpty())\r\n+            throw new InvalidStateException(_loc.get(\"nested-exceps\")).\r\n+                setNestedThrowables((Throwable[]) excs.toArray\r\n+                    (new Throwable[excs.size()]));\r\n+    }\r\n+\r\n+    /**\r\n+     * Synchronize the given broker with a managed transaction,\r\n+     * optionally starting one if none is in progress.\r\n+     *\r\n+     * @return true if synched with transaction, false otherwise\r\n+     */\r\n+    boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\r\n+        Transaction trans = null;\r\n+        try {\r\n+            TransactionManager tm = broker.getManagedRuntime().\r\n+                getTransactionManager();\r\n+            trans = tm.getTransaction();\r\n+            if (trans != null\r\n+                && (trans.getStatus() == Status.STATUS_NO_TRANSACTION\r\n+                || trans.getStatus() == Status.STATUS_UNKNOWN))\r\n+                trans = null;\r\n+            if (trans == null && begin) {\r\n+                tm.begin();\r\n+                trans = tm.getTransaction();\r\n+            } else if (trans == null)\r\n+                return false;\r\n+            // synch broker and trans\r\n+            trans.registerSynchronization(broker);\r\n+            synchronized (_transactional) {\r\n+                Collection brokers = (Collection) _transactional.get(trans);\r\n+                if (brokers == null) {\r\n+                    brokers = new ArrayList(2);\r\n+                    _transactional.put(trans, brokers);\r\n+                    // register a callback to remove the trans from the\r\n+                    // cache when it ends\r\n+                    trans.registerSynchronization\r\n+                        (new RemoveTransactionSync(trans));\r\n+                }\r\n+                brokers.add(broker);\r\n+            }\r\n+            return true;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new GeneralException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple synchronization listener to remove completed transactions\r\n+     * from our cache.\r\n+     */\r\n+    private class RemoveTransactionSync implements Synchronization {\r\n+\r\n+        private final Transaction _trans;\r\n+\r\n+        public RemoveTransactionSync(Transaction trans) {\r\n+            _trans = trans;\r\n+        }\r\n+\r\n+        public void beforeCompletion() {\r\n+        }\r\n+\r\n+        public void afterCompletion(int status) {\r\n+            synchronized (_transactional) {\r\n+                _transactional.remove(_trans);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"38690a71d8181ae9b1d185d9979a5a87c817a764","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","status":"added","additions":105,"deletions":0,"changes":105,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,105 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.enhance.FieldManager;\r\n+import org.apache.openjpa.util.InternalException;\r\n+\r\n+/**\r\n+ * Abstract {@link FieldManager} for easy subclassing. Throws exceptions\r\n+ * for all methods.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+abstract class AbstractFieldManager implements FieldManager {\r\n+\r\n+    public boolean fetchBooleanField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public byte fetchByteField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public char fetchCharField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public double fetchDoubleField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public float fetchFloatField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public int fetchIntField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public long fetchLongField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public Object fetchObjectField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public short fetchShortField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public String fetchStringField(int field) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeBooleanField(int field, boolean curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeByteField(int field, byte curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeCharField(int field, char curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeDoubleField(int field, double curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeFloatField(int field, float curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeIntField(int field, int curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeLongField(int field, long curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeObjectField(int field, Object curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeShortField(int field, short curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public void storeStringField(int field, String curVal) {\r\n+        throw new InternalException();\r\n+    }\r\n+}\r"},{"sha":"a76ead9808402120ac9508bc1a17bb423ef2f8f5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,75 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+\r\n+/**\r\n+ * Abstract {@link LockManager} implementation.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+public abstract class AbstractLockManager implements LockManager {\r\n+\r\n+    /**\r\n+     * The context against which this LockManager is operating.\r\n+     */\r\n+    protected StoreContext ctx;\r\n+\r\n+    /**\r\n+     * Runtime log to write locking messages to.\r\n+     */\r\n+    protected Log log;\r\n+\r\n+    public void setContext(StoreContext ctx) {\r\n+        this.ctx = ctx;\r\n+        this.log = ctx.getConfiguration().getLog\r\n+            (OpenJPAConfiguration.LOG_RUNTIME);\r\n+    }\r\n+\r\n+    public StoreContext getContext() {\r\n+        return ctx;\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegates to {@link #lock} with each element of the collection.\r\n+     */\r\n+    public void lockAll(Collection sms, int level, int timeout,\r\n+        Object context) {\r\n+        for (Iterator itr = sms.iterator(); itr.hasNext();)\r\n+            lock((OpenJPAStateManager) itr.next(), level, timeout, context);\r\n+    }\r\n+\r\n+    /**\r\n+     * Does nothing by default.\r\n+     */\r\n+    public void beginTransaction() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Does nothing by default.\r\n+     */\r\n+    public void endTransaction() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Does nothing by default.\r\n+     */\r\n+    public void close() {\r\n+    }\r\n+}\r\n+\r"},{"sha":"22886c868be7c87047d7113270b1217845545ed7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","status":"added","additions":299,"deletions":0,"changes":299,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,299 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Locale;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.event.OrphanedKeyAction;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.ChangeTracker;\r\n+import org.apache.openjpa.util.Proxy;\r\n+\r\n+/**\r\n+ * Abstract base class which implements core PCData behavior.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public abstract class AbstractPCData implements PCData {\r\n+\r\n+    public static final Object NULL = new Object();\r\n+\r\n+    /**\r\n+     * Return the loaded field mask.\r\n+     */\r\n+    public abstract BitSet getLoaded();\r\n+\r\n+    /**\r\n+     * Create a new pcdata for holding the state of an embedded instance.\r\n+     */\r\n+    public abstract AbstractPCData newEmbeddedPCData(OpenJPAStateManager sm);\r\n+\r\n+    public boolean isLoaded(int field) {\r\n+        return getLoaded().get(field);\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given data value into its field value.\r\n+     */\r\n+    protected Object toField(OpenJPAStateManager sm, FieldMetaData fmd,\r\n+        Object data, FetchState fetchState, Object context) {\r\n+        if (data == null)\r\n+            return null;\r\n+        switch (fmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.COLLECTION:\r\n+                ProxyDataList c = (ProxyDataList) data;\r\n+                Collection c2 = (Collection) sm.newFieldProxy(fmd.getIndex());\r\n+                for (int i = 0; i < c.size(); i++)\r\n+                    c2.add(toNestedField(sm, fmd.getElement(), c.get(i),\r\n+                        fetchState, context));\r\n+                if (c2 instanceof Proxy) {\r\n+                    ChangeTracker ct = ((Proxy) c2).getChangeTracker();\r\n+                    if (ct != null)\r\n+                        ct.setNextSequence(c.nextSequence);\r\n+                }\r\n+                return c2;\r\n+            case JavaTypes.MAP:\r\n+                Map m = (Map) data;\r\n+                Map m2 = (Map) sm.newFieldProxy(fmd.getIndex());\r\n+                Map.Entry e;\r\n+                Object key;\r\n+                Object value;\r\n+                for (Iterator mi = m.entrySet().iterator(); mi.hasNext();) {\r\n+                    e = (Map.Entry) mi.next();\r\n+                    key = toNestedField(sm, fmd.getKey(), e.getKey(),\r\n+                        fetchState, context);\r\n+                    value = toNestedField(sm, fmd.getElement(), e.getValue(),\r\n+                        fetchState, context);\r\n+                    m2.put(key, value);\r\n+                }\r\n+                return m2;\r\n+            case JavaTypes.ARRAY:\r\n+                List l = (List) data;\r\n+                Object a = Array.newInstance(fmd.getElement().getDeclaredType(),\r\n+                    l.size());\r\n+                for (int i = 0; i < l.size(); i++) {\r\n+                    Array.set(a, i, toNestedField(sm, fmd.getElement(),\r\n+                        l.get(i), fetchState, context));\r\n+                }\r\n+                return a;\r\n+            default:\r\n+                return toNestedField(sm, fmd, data, fetchState, context);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given data value to its field value. The data value\r\n+     * may be a key, value, or element of a map or collection.\r\n+     */\r\n+    protected Object toNestedField(OpenJPAStateManager sm, ValueMetaData vmd,\r\n+        Object data, FetchState fetchState, Object context) {\r\n+        if (data == null)\r\n+            return null;\r\n+        switch (vmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.DATE:\r\n+                return ((Date) data).clone();\r\n+            case JavaTypes.LOCALE:\r\n+                return (Locale) data;\r\n+            case JavaTypes.PC:\r\n+                if (vmd.isEmbedded())\r\n+                    return toEmbeddedField(sm, vmd, data, fetchState, context);\r\n+                // no break\r\n+            case JavaTypes.PC_UNTYPED:\r\n+                Object ret =\r\n+                    toRelationField(sm, vmd, data, fetchState, context);\r\n+                if (ret != null)\r\n+                    return ret;\r\n+                OrphanedKeyAction action = sm.getContext().getConfiguration().\r\n+                    getOrphanedKeyActionInstance();\r\n+                return action.orphan(data, sm, vmd);\r\n+            default:\r\n+                return data;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given data into a relation field value. Default\r\n+     * implementation assumes the data is an oid.\r\n+     */\r\n+    protected Object toRelationField(OpenJPAStateManager sm, ValueMetaData vmd,\r\n+        Object data, FetchState fetchState, Object context) {\r\n+        return sm.getContext().find(data, fetchState, null, null, 0);\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given data into an embedded PC field value. Default\r\n+     * implementation assumes the data is an {@link AbstractPCData}.\r\n+     */\r\n+    protected Object toEmbeddedField(OpenJPAStateManager sm, ValueMetaData vmd,\r\n+        Object data, FetchState fetchState, Object context) {\r\n+        AbstractPCData pcdata = (AbstractPCData) data;\r\n+        OpenJPAStateManager embedded = sm.getContext().embed(null,\r\n+            pcdata.getId(), sm, vmd);\r\n+        pcdata.load(embedded, (BitSet) pcdata.getLoaded().clone(),\r\n+            fetchState, context);\r\n+        return embedded.getManagedInstance();\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given field value to a data value for caching. Return\r\n+     * {@link #NULL} if unable to cache.\r\n+     */\r\n+    protected Object toData(FieldMetaData fmd, Object val, StoreContext ctx) {\r\n+        if (val == null)\r\n+            return null;\r\n+        switch (fmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.COLLECTION:\r\n+                Collection c = (Collection) val;\r\n+                if (c.isEmpty())\r\n+                    return ProxyDataList.EMPTY_LIST;\r\n+                ProxyDataList c2 = null;\r\n+                int size;\r\n+                for (Iterator ci = c.iterator(); ci.hasNext();) {\r\n+                    val = toNestedData(fmd.getElement(), ci.next(), ctx);\r\n+                    if (val == NULL)\r\n+                        return NULL;\r\n+                    if (c2 == null) {\r\n+                        size = c.size();\r\n+                        c2 = new ProxyDataList(size);\r\n+                        if (c instanceof Proxy) {\r\n+                            ChangeTracker ct = ((Proxy) c).getChangeTracker();\r\n+                            if (ct != null)\r\n+                                c2.nextSequence = ct.getNextSequence();\r\n+                        } else c2.nextSequence = size;\r\n+                    }\r\n+                    c2.add(val);\r\n+                }\r\n+                return c2;\r\n+            case JavaTypes.MAP:\r\n+                Map m = (Map) val;\r\n+                if (m.isEmpty())\r\n+                    return Collections.EMPTY_MAP;\r\n+                Map m2 = null;\r\n+                Map.Entry e;\r\n+                Object val2;\r\n+                for (Iterator mi = m.entrySet().iterator(); mi.hasNext();) {\r\n+                    e = (Map.Entry) mi.next();\r\n+                    val = toNestedData(fmd.getKey(), e.getKey(), ctx);\r\n+                    if (val == NULL)\r\n+                        return NULL;\r\n+                    val2 = toNestedData(fmd.getElement(), e.getValue(), ctx);\r\n+                    if (val2 == NULL)\r\n+                        return NULL;\r\n+                    if (m2 == null)\r\n+                        m2 = new HashMap(m.size());\r\n+                    m2.put(val, val2);\r\n+                }\r\n+                return m2;\r\n+            case JavaTypes.ARRAY:\r\n+                Object a = val;\r\n+                int length = Array.getLength(a);\r\n+                if (length == 0)\r\n+                    return Collections.EMPTY_LIST;\r\n+                List l = null;\r\n+                for (int i = 0; i < length; i++) {\r\n+                    val = toNestedData(fmd.getElement(), Array.get(a, i), ctx);\r\n+                    if (val == NULL)\r\n+                        return NULL;\r\n+                    if (l == null)\r\n+                        l = new ArrayList(length);\r\n+                    l.add(val);\r\n+                }\r\n+                return l;\r\n+            default:\r\n+                return toNestedData(fmd, val, ctx);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given nested value to a cachable value. Return\r\n+     * {@link #NULL} if the value cannot be cached.\r\n+     */\r\n+    protected Object toNestedData(ValueMetaData vmd, Object val,\r\n+        StoreContext ctx) {\r\n+        if (val == null)\r\n+            return null;\r\n+        switch (vmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.PC:\r\n+                if (vmd.isEmbedded())\r\n+                    return toEmbeddedData(val, ctx);\r\n+                // no break\r\n+            case JavaTypes.PC_UNTYPED:\r\n+                return toRelationData(val, ctx);\r\n+            case JavaTypes.DATE:\r\n+                if (val instanceof Proxy)\r\n+                    return ((Proxy) val).copy(val);\r\n+                else return ((Date) val).clone();\r\n+            case JavaTypes.LOCALE:\r\n+                return (Locale) val;\r\n+            case JavaTypes.OBJECT:\r\n+                if (val instanceof Proxy)\r\n+                    return ((Proxy) val).copy(val);\r\n+                else return val;\r\n+            default:\r\n+                return val;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the value to cache for the given object. Caches its oid by\r\n+     * default.\r\n+     */\r\n+    protected Object toRelationData(Object val, StoreContext ctx) {\r\n+        return ctx.getObjectId(val);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the value to cache for the given embedded PC. Caches a\r\n+     * {@link PCData} from {@link #newEmbeddedPCData} by default.\r\n+     */\r\n+    protected Object toEmbeddedData(Object val, StoreContext ctx) {\r\n+        if (ctx == null)\r\n+            return NULL;\r\n+        OpenJPAStateManager sm = ctx.getStateManager(val);\r\n+        if (sm == null)\r\n+            return NULL;\r\n+        // have to cache all data, so make sure it's all loaded\r\n+        // ### prevent loading of things that aren't cached(lobs, lrs, etc)\r\n+        ctx.retrieve(val, false, null);\r\n+        PCData pcdata = newEmbeddedPCData(sm);\r\n+        pcdata.store(sm);\r\n+        return pcdata;\r\n+    }\r\n+\r\n+    /**\r\n+     * Tracks proxy data along with list elements.\r\n+     */\r\n+    private static class ProxyDataList extends ArrayList {\r\n+\r\n+        public static final ProxyDataList EMPTY_LIST = new ProxyDataList(0);\r\n+        public int nextSequence = 0;\r\n+\r\n+        public ProxyDataList(int size) {\r\n+            super(size);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"3b792d6db5d24fca95001b7ee2eef5e0b686c84b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","status":"added","additions":154,"deletions":0,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,154 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ObjectNotFoundException;\r\n+import org.apache.openjpa.util.StoreException;\r\n+\r\n+/**\r\n+ * Abstract implementation of {@link PCResultObjectProvider}\r\n+ * that implements {@link ResultObjectProvider#getResultObject}\r\n+ * by assembling the necessary information about the object to be loaded.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public abstract class AbstractPCResultObjectProvider\r\n+    implements PCResultObjectProvider {\r\n+\r\n+    /**\r\n+     * The {@link StoreContext} that this result object\r\n+     * provider will load objects into.\r\n+     */\r\n+    protected final StoreContext ctx;\r\n+\r\n+    /**\r\n+     * Create a new provider for loading PC objects from the input\r\n+     * into <code>ctx</code>.\r\n+     */\r\n+    public AbstractPCResultObjectProvider(StoreContext ctx) {\r\n+        this.ctx = ctx;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the context this provider was constructed with.\r\n+     */\r\n+    public StoreContext getContext() {\r\n+        return ctx;\r\n+    }\r\n+\r\n+    public void initialize(OpenJPAStateManager sm, PCState state,\r\n+        FetchState fetchState) throws Exception {\r\n+        sm.initialize(getPCType(), state);\r\n+        load(sm, fetchState);\r\n+    }\r\n+\r\n+    public Object getResultObject() throws Exception {\r\n+        Class type = getPCType();\r\n+        MetaDataRepository repos = ctx.getConfiguration().\r\n+            getMetaDataRepository();\r\n+        ClassMetaData meta = repos.getMetaData\r\n+            (type, ctx.getClassLoader(), true);\r\n+        Object oid = getObjectId(meta);\r\n+        Object res = ctx.find(oid, null, null, this, 0);\r\n+        if (res == null)\r\n+            throw new ObjectNotFoundException(oid);\r\n+        return res;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement this method to extract the object id value from the\r\n+     * current record of the input.\r\n+     */\r\n+    protected abstract Object getObjectId(ClassMetaData meta) throws Exception;\r\n+\r\n+    /**\r\n+     * Implement this method to extract the type of the pc stored\r\n+     * in the current record of the input.\r\n+     */\r\n+    protected abstract Class getPCType() throws Exception;\r\n+\r\n+    /**\r\n+     * Load data from the current input record into the given state\r\n+     * manager. Remember to call {@link OpenJPAStateManager#setVersion} to set\r\n+     * the optimistic versioning information, if it has any.\r\n+     */\r\n+    protected abstract void load(OpenJPAStateManager sm, FetchState fetch)\r\n+        throws Exception;\r\n+\r\n+    /**\r\n+     * Override if desired. Does nothing by default.\r\n+     */\r\n+    public void open() throws Exception {\r\n+    }\r\n+\r\n+    /**\r\n+     * Override if desired. Returns false by default.\r\n+     *\r\n+     * @see ResultObjectProvider#supportsRandomAccess\r\n+     */\r\n+    public boolean supportsRandomAccess() {\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement this method to advance the input.\r\n+     *\r\n+     * @see ResultObjectProvider#next\r\n+     */\r\n+    public abstract boolean next() throws Exception;\r\n+\r\n+    /**\r\n+     * Override if desired. Throws an exception by default.\r\n+     *\r\n+     * @see ResultObjectProvider#absolute\r\n+     */\r\n+    public boolean absolute(int pos) throws Exception {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    /**\r\n+     * Override if desired. Returns {@link Integer#MAX_VALUE} by default.\r\n+     *\r\n+     * @see ResultObjectProvider#size\r\n+     */\r\n+    public int size() throws Exception {\r\n+        return Integer.MAX_VALUE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Override if desired. Throws an exception by default.\r\n+     *\r\n+     * @see ResultObjectProvider#reset\r\n+     */\r\n+    public void reset() throws Exception {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    /**\r\n+     * Override if desired. Does nothing by default.\r\n+     *\r\n+     * @see ResultObjectProvider#close\r\n+     */\r\n+    public void close() throws Exception {\r\n+    }\r\n+\r\n+    /**\r\n+     * Throws a {@link StoreException} by default.\r\n+     */\r\n+    public void handleCheckedException(Exception e) {\r\n+        throw new StoreException(e);\r\n+    }\r\n+}\r"},{"sha":"aa9d54bca20822d7790192f3e0536792a371d913","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"added","additions":188,"deletions":0,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,188 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.InternalException;\r\n+\r\n+/**\r\n+ * Abstract {@link StoreQuery} that implements most methods as no-ops.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+public abstract class AbstractStoreQuery implements StoreQuery {\r\n+\r\n+    protected QueryContext ctx = null;\r\n+\r\n+    public QueryContext getContext() {\r\n+        return ctx;\r\n+    }\r\n+\r\n+    public void setContext(QueryContext ctx) {\r\n+        this.ctx = ctx;\r\n+    }\r\n+\r\n+    public boolean setQuery(Object query) {\r\n+        return false;\r\n+    }\r\n+\r\n+    public FilterListener getFilterListener(String tag) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public AggregateListener getAggregateListener(String tag) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object newCompilationKey() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object newCompilation() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public void populateFromCompilation(Object comp) {\r\n+    }\r\n+\r\n+    public void invalidateCompilation() {\r\n+    }\r\n+\r\n+    public boolean supportsDataStoreExecution() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean supportsInMemoryExecution() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public boolean supportsAbstractExecutors() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean requiresCandidateType() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean requiresParameterDeclarations() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean supportsParameterDeclarations() {\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Abstract {@link Executor} that implements most methods as no-ops.\r\n+     */\r\n+    public static abstract class AbstractExecutor implements Executor {\r\n+\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Map params,\r\n+            boolean lrs, long startIdx, long endIdx) {\r\n+            Object[] arr = q.getContext().toParameterArray\r\n+                (q.getContext().getParameterTypes(), params);\r\n+            return executeQuery(q, arr, lrs, startIdx, endIdx);\r\n+        }\r\n+\r\n+        public Number executeDelete(StoreQuery q, Object[] params) {\r\n+            return q.getContext().deleteInMemory(this, params);\r\n+        }\r\n+\r\n+        public Number executeDelete(StoreQuery q, Map params) {\r\n+            return executeDelete(q, q.getContext().toParameterArray\r\n+                (q.getContext().getParameterTypes(), params));\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n+            return q.getContext().updateInMemory(this, params);\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Map params) {\r\n+            return executeUpdate(q, q.getContext().toParameterArray\r\n+                (q.getContext().getParameterTypes(), params));\r\n+        }\r\n+\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            long startIdx, long endIdx) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public boolean[] getAscending(StoreQuery q) {\r\n+            return EMPTY_BOOLEANS;\r\n+        }\r\n+\r\n+        public boolean isPacking(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public String getAlias(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public String[] getProjectionAliases(StoreQuery q) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public Class[] getProjectionTypes(StoreQuery q) {\r\n+            return EMPTY_CLASSES;\r\n+        }\r\n+\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n+            return EMPTY_METAS;\r\n+        }\r\n+\r\n+        public int getOperation(StoreQuery q) {\r\n+            return OP_SELECT;\r\n+        }\r\n+\r\n+        public boolean isAggregate(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean hasGrouping(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public LinkedMap getParameterTypes(StoreQuery q) {\r\n+            return EMPTY_PARAMS;\r\n+        }\r\n+\r\n+        public Class getResultClass(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public Map getUpdates(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"250dc258114600d7fdd018f6cee376b3922b5da5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"added","additions":317,"deletions":0,"changes":317,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,317 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.collections.map.IdentityMap;\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.event.CallbackModes;\r\n+import org.apache.openjpa.event.LifecycleEvent;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.CallbackException;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.OptimisticException;\r\n+import org.apache.openjpa.util.ProxyManager;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Handles attaching instances.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ */\r\n+class AttachManager {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (AttachManager.class);\r\n+    private final BrokerImpl _broker;\r\n+    private final ProxyManager _proxy;\r\n+    private final OpCallbacks _call;\r\n+    private final boolean _copyNew;\r\n+    private final boolean _failFast;\r\n+    private final IdentityMap _attached = new IdentityMap();\r\n+    // reusable strategies\r\n+    private AttachStrategy _version = null;\r\n+    private AttachStrategy _detach = null;\r\n+\r\n+    /**\r\n+     * Constructor. Supply broker attaching to.\r\n+     */\r\n+    public AttachManager(BrokerImpl broker, boolean copyNew, OpCallbacks call) {\r\n+        _broker = broker;\r\n+        _proxy = broker.getConfiguration().getProxyManagerInstance();\r\n+        _call = call;\r\n+        _copyNew = copyNew;\r\n+        _failFast = (broker.getConfiguration().getMetaDataRepository().\r\n+            getMetaDataFactory().getDefaults().getCallbackMode()\r\n+            & CallbackModes.CALLBACK_FAIL_FAST) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the behavior supplied on construction.\r\n+     */\r\n+    public OpCallbacks getBehavior() {\r\n+        return _call;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether to copy new instances being persisted.\r\n+     */\r\n+    public boolean getCopyNew() {\r\n+        return _copyNew;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return an attached version of the given instance.\r\n+     */\r\n+    public Object attach(Object pc) {\r\n+        if (pc == null)\r\n+            return null;\r\n+        CallbackException excep = null;\r\n+        try {\r\n+            return attach(pc, null, null, null);\r\n+        } catch (CallbackException ce) {\r\n+            excep = ce;\r\n+            return null; // won't be reached as the exceps will be rethrown\r\n+        }\r\n+        finally {\r\n+            List exceps = null;\r\n+            if (excep == null || !_failFast)\r\n+                exceps = invokeAfterAttach(null);\r\n+            else exceps = Collections.singletonList(excep);\r\n+            _attached.clear();\r\n+            throwExceptions(exceps, null, false);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return attached versions of the given instances.\r\n+     */\r\n+    public Object[] attachAll(Collection instances) {\r\n+        Object[] attached = new Object[instances.size()];\r\n+        List exceps = null;\r\n+        List failed = null;\r\n+        boolean opt = true;\r\n+        boolean failFast = false;\r\n+        try {\r\n+            int i = 0;\r\n+            for (Iterator itr = instances.iterator(); itr.hasNext(); i++) {\r\n+                try {\r\n+                    attached[i] = attach(itr.next(), null, null, null);\r\n+                } catch (OpenJPAException ke) {\r\n+                    // track exceptions and optimistic failed objects\r\n+                    if (opt && !(ke instanceof OptimisticException))\r\n+                        opt = false;\r\n+                    if (opt && ke.getFailedObject() != null)\r\n+                        failed = add(failed, ke.getFailedObject());\r\n+                    exceps = add(exceps, ke);\r\n+                    if (ke instanceof CallbackException && _failFast) {\r\n+                        failFast = true;\r\n+                        break;\r\n+                    }\r\n+                } catch (RuntimeException re) {\r\n+                    exceps = add(exceps, re);\r\n+                }\r\n+            }\r\n+        }\r\n+        finally {\r\n+            // invoke post callbacks unless all failed\r\n+            if (!failFast && (exceps == null\r\n+                || exceps.size() < instances.size()))\r\n+                exceps = invokeAfterAttach(exceps);\r\n+            _attached.clear();\r\n+        }\r\n+        throwExceptions(exceps, failed, opt);\r\n+        return attached;\r\n+    }\r\n+\r\n+    /**\r\n+     * Invoke postAttach() on any attached instances that implement\r\n+     * PostAttachCallback. This will be done after the entire graph has\r\n+     * been attached.\r\n+     */\r\n+    private List invokeAfterAttach(List exceps) {\r\n+        Set entries = _attached.entrySet();\r\n+        for (Iterator i = entries.iterator(); i.hasNext();) {\r\n+            Map.Entry entry = (Map.Entry) i.next();\r\n+            Object attached = entry.getValue();\r\n+            StateManagerImpl sm = _broker.getStateManagerImpl(attached, true);\r\n+            if (sm.isNew())\r\n+                continue;\r\n+            try {\r\n+                _broker.fireLifecycleEvent(attached, entry.getKey(),\r\n+                    sm.getMetaData(), LifecycleEvent.AFTER_ATTACH);\r\n+            } catch (RuntimeException re) {\r\n+                exceps = add(exceps, re);\r\n+                if (_failFast && re instanceof CallbackException)\r\n+                    break;\r\n+            }\r\n+        }\r\n+        return exceps;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add an object to the list.\r\n+     */\r\n+    private List add(List list, Object obj) {\r\n+        if (list == null)\r\n+            list = new LinkedList();\r\n+        list.add(obj);\r\n+        return list;\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw exception for failures.\r\n+     */\r\n+    private void throwExceptions(List exceps, List failed, boolean opt) {\r\n+        if (exceps == null)\r\n+            return;\r\n+        if (exceps.size() == 1)\r\n+            throw(RuntimeException) exceps.get(0);\r\n+        Throwable[] t =\r\n+            (Throwable[]) exceps.toArray(new Throwable[exceps.size()]);\r\n+        if (opt && failed != null)\r\n+            throw new OptimisticException(failed, t);\r\n+        if (opt)\r\n+            throw new OptimisticException(t);\r\n+        throw new UserException(_loc.get(\"nested-exceps\")).\r\n+            setNestedThrowables(t);\r\n+    }\r\n+\r\n+    /**\r\n+     * Attach.\r\n+     *\r\n+     * @param toAttach  the detached object\r\n+     * @param into      the instance we're attaching into\r\n+     * @param owner     state manager for <code>into</code>\r\n+     * @param ownerMeta the field we traversed to find <code>toAttach</code>\r\n+     */\r\n+    Object attach(Object toAttach, PersistenceCapable into,\r\n+        OpenJPAStateManager owner, ValueMetaData ownerMeta) {\r\n+        if (toAttach == null)\r\n+            return null;\r\n+        // check if already attached\r\n+        Object attached = _attached.get(toAttach);\r\n+        if (attached != null)\r\n+            return attached;\r\n+        //### need to handle ACT_CASCADE\r\n+        int action = processArgument(toAttach);\r\n+        if ((action & OpCallbacks.ACT_RUN) == 0)\r\n+            return toAttach;\r\n+        //### need to handle ACT_RUN without also ACT_CASCADE\r\n+        ClassMetaData meta = _broker.getConfiguration().\r\n+            getMetaDataRepository().getMetaData(toAttach.getClass(),\r\n+            _broker.getClassLoader(), true);\r\n+        return getStrategy(toAttach).attach(this, toAttach, meta, into,\r\n+            owner, ownerMeta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Determine the action to take on the given argument.\r\n+     */\r\n+    private int processArgument(Object obj) {\r\n+        if (_call == null)\r\n+            return OpCallbacks.ACT_RUN;\r\n+        return _call.processArgument(OpCallbacks.OP_ATTACH, obj,\r\n+            _broker.getStateManager(obj));\r\n+    }\r\n+\r\n+    /**\r\n+     * Calculate proper attach strategy for instance.\r\n+     */\r\n+    private AttachStrategy getStrategy(Object toAttach) {\r\n+        PersistenceCapable pc = (PersistenceCapable) toAttach;\r\n+        if (pc.pcGetStateManager() instanceof AttachStrategy)\r\n+            return (AttachStrategy) pc.pcGetStateManager();\r\n+        Object obj = pc.pcGetDetachedState();\r\n+        if (obj instanceof AttachStrategy)\r\n+            return (AttachStrategy) obj;\r\n+        if (obj == null || obj == PersistenceCapable.DESERIALIZED) {\r\n+            // new or detached without state\r\n+            if (_version == null)\r\n+                _version = new VersionAttachStrategy();\r\n+            return _version;\r\n+        }\r\n+        // detached state\r\n+        if (_detach == null)\r\n+            _detach = new DetachedStateAttachStrategy();\r\n+        return _detach;\r\n+    }\r\n+\r\n+    /**\r\n+     * Owning broker.\r\n+     */\r\n+    BrokerImpl getBroker() {\r\n+        return _broker;\r\n+    }\r\n+\r\n+    /**\r\n+     * System proxy manager.\r\n+     */\r\n+    ProxyManager getProxyManager() {\r\n+        return _proxy;\r\n+    }\r\n+\r\n+    /**\r\n+     * If the passed in argument has already been attached, return\r\n+     * the(cached) attached copy.\r\n+     */\r\n+    PersistenceCapable getAttachedCopy(Object pc) {\r\n+        return (PersistenceCapable) _attached.get(pc);\r\n+    }\r\n+\r\n+    /**\r\n+     * Record the attached copy in the cache.\r\n+     */\r\n+    void setAttachedCopy(Object from, PersistenceCapable into) {\r\n+        _attached.put(from, into);\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire before-attach event.\r\n+     */\r\n+    void fireBeforeAttach(Object pc, ClassMetaData meta) {\r\n+        _broker.fireLifecycleEvent(pc, null, meta,\r\n+            LifecycleEvent.BEFORE_ATTACH);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the detached oid of the given instance.\r\n+     */\r\n+    Object getDetachedObjectId(Object pc) {\r\n+        if (pc == null)\r\n+            return null;\r\n+        return getStrategy(pc).getDetachedObjectId(this, pc);\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw an exception if the given object is not managed; otherwise\r\n+     * return its state manager.\r\n+     */\r\n+    StateManagerImpl assertManaged(Object obj) {\r\n+        StateManagerImpl sm = _broker.getStateManagerImpl(obj, true);\r\n+        if (sm == null)\r\n+            throw new UserException(_loc.get(\"not-managed\",\r\n+                Exceptions.toString(obj))).setFailedObject(obj);\r\n+        return sm;\r\n+    }\r\n+}\r"},{"sha":"7b8d0f7829fed0dd39e059c8049a5f9744393589","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"56bb0abdab87405fe505d75154e7f9f1784984df","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"dd891f8c13e5cf059e92251be092290401de68da","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"64761031bdf1cdcc82325d9817cbda60b814d517","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6a41ceb217159b53711cdc07eb1b97c1b3739233","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","status":"added","additions":652,"deletions":0,"changes":652,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9a780d74aa43e2298cb5efaf6c3a9cbc37b0033b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ab6c64616d898484b1eb9caf9e47e955bb60f7fe","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"added","additions":4565,"deletions":0,"changes":4565,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"fab3c0e06a38519ed396e3a1296bb3f5072ec804","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5b91247d909a279d4a44698411720f9bc8f93851","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"68769d607c36277dc5c9934a9c5392fdbee148bf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"added","additions":1333,"deletions":0,"changes":1333,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"1c8fdd32f65e42f31be9b83545256f2697a4fe21","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"249c493e5c085656e7addabfe4997d29ab88607b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","status":"added","additions":176,"deletions":0,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"995f7bfee9e189ee94c2c9152f362ccda8c0d2b4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"added","additions":447,"deletions":0,"changes":447,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"4a0f6a895c1b340eca992832a5e4aaec5a181d26","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","status":"added","additions":649,"deletions":0,"changes":649,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"518ce104fb64f15b6698d121ec68d0d81551ae64","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","status":"added","additions":429,"deletions":0,"changes":429,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0f4838bcb0a033f1da4ab646a77a28a4e2a42f89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"662a3dd5aedffd1a68883a20f2fed1a6268d93eb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","status":"added","additions":194,"deletions":0,"changes":194,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"946d87412f7b43a986622374ca3798c5793eedd4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"added","additions":768,"deletions":0,"changes":768,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"7f17aa9f936be2fcbfb880d787b09954ff6df0c5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"37429ad60ad10a38a67253128f6e5197e5e0b6e9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"32ad5721a90b1c35a8cfad4cd1582ebc9ce92db6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"added","additions":901,"deletions":0,"changes":901,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"164a9ac547824cdc0ffa62347cb72e27a1c1de99","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"added","additions":583,"deletions":0,"changes":583,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"792a85ffba347360d1b7c1a0cc257f870740d0c3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"22ffb72eff283e63654163f53e5af8841310a1f3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"16dce3d5f5f0279410ef33a0f7249862c7ea45c8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"84c9272bc283569ecc5ac52fd58815a2ed9def86","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"dcbc6b6331b6ca36d2efdbbbb613af8e3b0a7805","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5a69ad9f60c91da5fe27d00e685d4dc40994ec13","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","status":"added","additions":627,"deletions":0,"changes":627,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ab9eb8f60479ddbb362f9112ac20c876cacb2bae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a5eb70e024ff0b40bbc3cb9a5b3d97902fdfbb55","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"added","additions":328,"deletions":0,"changes":328,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"97dcdff25af8cde08bcce4f2aeadcb19c01cf79c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"added","additions":312,"deletions":0,"changes":312,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"229fd5646781e2de0b527b42224601f52ac75edc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"added","additions":410,"deletions":0,"changes":410,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a42375f63ea254f863998764a097fc0f59f644a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"fcbe82cb09111bbf17418815563e6cb07f1eff7a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","status":"added","additions":233,"deletions":0,"changes":233,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchStateImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f72158e8c4563216b052773f756da7c38c4c84b7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"added","additions":822,"deletions":0,"changes":822,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"87ca511df19ca81668decdec18830b892c1c4885","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"87d62613f72fc8885dc96e3e9bf15cf147928df8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a859a17a0a274e8f6a3a25dd4e6a93bc3d408af0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"27e0c9bfe631aa3139b6f9301f6b76175087f93f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","status":"added","additions":385,"deletions":0,"changes":385,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d1dc00075ac295375e3aca02bc8f1e244cf1b0bb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"964853c2d6334928d8b4ab88f960ee260a019a0a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"10c93a3e782a98a89c35a761757bd53b8de261cf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d9d801fb77d538742423e7f581872ed31b7b0feb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"58fc1d4ff6ce98710595b6748c5de2dad9d6c078","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"673da9da89c734bc872108fc3b4bc66d8f56dd43","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"added","additions":728,"deletions":0,"changes":728,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"1c390c785d7625f75fec185bc9d1f9d3fe63fac8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5d04c1c02145c6f2fef95319a846b8fb65586cc6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"58b162f7ce7d00bfcc6aad3e39424e8e30b478cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","status":"added","additions":488,"deletions":0,"changes":488,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8cd45407a373006f3b55e384bf64066b66d3fa8c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3897e4a3c6754c8f8d4345a9e65444d39fc3050a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6ab55f77ba960d0500711c0cb02b45fd28d159c2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","status":"added","additions":294,"deletions":0,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"23adfb32f93f9a5a1bd20d3ef6905568362888d3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e4704e01409548fb87c576609989b2d5ba429769","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","status":"added","additions":453,"deletions":0,"changes":453,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a2744c51dd8a063c00e5f338a3a9d8977e307520","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cea782446ac0551c6696eb416902a605118ad121","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9e9a80e11dd5276c6fbcea958f00b60937ece993","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"1e0341d661447b8e17e7b11052d69fa17fe3cff7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0fe0ae5e71e216f7d0982928925678c6bae05f61","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"72de7b6aa4e9d5cff413ee8ae54a7ed54d8137d0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"24993a740340dde48c041d7ebdc8854708e281bd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"03464c80485e7e2ac5d59f454d0599868211f731","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d43e9f69c5ac29eb1b49a835c90a4591e716dfb7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"455f92ff86a224bc77107b37ec807a32310fcd31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"13147a028367bdf3722d28520c24df3bd8eb231d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a60a793222a3d671138baf07883e73dcfa630566","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","status":"added","additions":114,"deletions":0,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"183d692d6b98bbc8376d1fb55cf40a2d4ec552ca","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cd62ac5fa7b7b3eacaf62cb999f934fd893039ff","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","status":"added","additions":282,"deletions":0,"changes":282,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3ef5d6826d1f865f8d639ef41d2f307bca9e4a3b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c76615d231714d8427e3bef0ca76b82a00fa2253","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"added","additions":2108,"deletions":0,"changes":2108,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f3440ce8e7df8dad08b742a8612172738c67739f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f090eca51efb5aeda76731ed756baba91561d642","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a7b1c51d215af60172dacc1df3026518ab0165a6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c086e6c6c9d75db994b16e4fdede1aa1e06a502b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"00d2616ca3c5d75dbc29b1dabcb067c2e605a0da","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","status":"added","additions":330,"deletions":0,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b6e995362c4c7e5ef52c98c948ebf17787544a95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"added","additions":190,"deletions":0,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0dcae8daf0675a422421db4b6eb5451b6f4d37f8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","status":"added","additions":201,"deletions":0,"changes":201,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0c8eaca4fa745b402c47635b47790a0ed5dedaf7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"90c376b829c5f5062e2b5bcacbadd398c7607da7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"7736d23b8ca90a04234f9c5f4ad36aacd5e0dc9d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"added","additions":800,"deletions":0,"changes":800,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0597bbec60d71ce7f36a07660d38fb3062eae9c4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"added","additions":2831,"deletions":0,"changes":2831,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"47842fc4896e181c347e22198563c957f1fd6c0e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"added","additions":430,"deletions":0,"changes":430,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"43d2de8c6088b07918bf3d1aa0da99e9c7632bef","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"added","additions":416,"deletions":0,"changes":416,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f377614f9b6ace2c2ba288fde15f946a517f287e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"added","additions":308,"deletions":0,"changes":308,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ecdf697b0d8e0a7dfffedbd2c1ee7de78c802636","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"4a8730117cbc78f925cda7c410556d244217a134","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"bc31f39383fa6c7483fa21d65191675545a2eb66","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c4493b3547dcd6b3cc633dc6b9354e6bd3f2f248","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ab12392fad1b230c117cc5db392200d57779f852","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"1dd327ff4f028e4cdd5fd76514a23b06ef82a863","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cd7c12e0de12da633cc57f783b9e6ba23ff883de","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0dee5bb9132001ad4a203b76c89e0c1bfacd2a76","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6a0e886b6329681705aaccc907c65c858ac1adb1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"added","additions":310,"deletions":0,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c4670b6f8bc9e1417f20366afa2f3c30ab1a2030","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"57595fb537b608edf32ccee441c7482788df1215","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"4072c6b1c588226b2b7841378632dfac5b863b77","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"added","additions":447,"deletions":0,"changes":447,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"96f33fe5a0d1c6d01350bfb607ab2c3b175f7f53","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"008a1ac3ada7aa0a63ae037372acbadc88b916c0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"84e80a4d849b9dcf77fe09ae2d52cd82ca9e2593","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"53f6592eb0c322feff6966b6de9ab9a1024fe0ac","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d5abd6db81f1556535342f8334eedfa8774657a6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5cee6073c95039095e0c975159c1f444e87c52ac","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9df6baf1afeceab8b8ee79046cee135eb53a9de7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6a7d9c238f080adbbc8f32b7d2a22c5b08a1c12c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"eec7a27df81eb1dccd0dc81a888c0734c85792ae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"adeb399a1eb472266ce2f4ce74b9b50dfd61107c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"30b0a6ae2d957e6f6ff69bd0cd7ba8aa2a0a5c28","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"32da800a935b1c1ced431681e3860a1297bcda5b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8d8a8df3dfd88d1c34ad4bbfaa9990ea5da3d7a2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ad1ccee3555621e65c5ed36cd2a5ea1b431432c7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0e77ff16781e1284c66492f05d6f5e66d18ff17b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"473731e7e1d6b1a26a2bea6097d9c36a6c0f2215","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f0cf03fe59f449c5ec16dc910e1f7c35a3fdc7b5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0a7945f5c393a4c2bac1bc18bc4dd8c05f3fd6e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9c823280b74a74438debe0ee4de19d12a94d1abd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"638a47d178d20ace5cb9a4f707c875e1ec5c5008","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9cafb6e970dfdcdb13afe041a4deed8f59c4400d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c68b3c49afb40e3af3090ec8318e6aa9d08597e5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"33dcaf0c0080c751a6e01f6ea5b15addaa0d6017","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"aba8de0e83ef8b599ac77894fb8ed4629cf09628","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2446f927bca2267b70a3a113504ba9db17a41e59","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e38ce79cb85ba4e2c2263583884c4ae1736a0618","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8440cf7c45dee70da544dc6c63dc2fc9e725a14d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5348b5baff705acb0863e25feb36d3452fa85282","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"916186d59e06b3872aed83ac944d53c87a388a5e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2dd88f27a83fd4d4a0936626532d89391c7e4400","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e645cb4f6586f5f8f7c301765cc02f11a8908a19","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"711be6534205fbdc2549ff521d6380974a775bc0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","status":"added","additions":398,"deletions":0,"changes":398,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c6b4c1258c46fa3c7fbd1441744dcd01faea789e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"440cad187e7ec5bb9a3598a91f9d9d4cb9effdae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"748e81865fff1d97b1b5739935458787e23f92e3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"403dc9157885cbf0239ee0bbbaebbc8d56ba7ac7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"7342023427c257afa70cb4a2f3749d1513b2ef46","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"adee53edcb09687c5c0c40bf4b834c1ec398c4b2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8737b9fcbd8abe9da7367eeb08b9f41ed0e7c508","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","status":"added","additions":688,"deletions":0,"changes":688,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9fd72f80cea524d54b05d6caada83345c0205dd8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"19c7b83ccb4fb8cf9cfc60e9554fc0dfdf5a7a68","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"13290a5d330c58a28b5e16ed880e73f10aebc2a9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c086efd599405e03231383de194e5b440a6e529a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"02bcf454f8fb63f5c731101d8a04aaaac28614d0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2cd71f8a4fbe60cc5faffbc76f15d3752d30e961","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b9dbdfc6792166fd58fb679f99a65af8eeb57e75","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"833ea9c73cd4af7144c50f783c8bb5579842a514","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"07adae42bd479c15fbe16d2979f9c37fbf2e03a0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"70eac4f69079ef21374aa54335cf467ba28ef728","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"faf1d388c317a6b8a1441a21c7108493c8f69b9d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"4c627308aa32895c9bc5f8c9f8c1970983a37eb1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cce61457c728bbb905829fb2ca93f1f3eb7cb949","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e69a52e0a15426c53821b0c5b75944f0b447e90d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d591d0aa4235368a664a56a06071286cf47bd66e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"4c7004014618fb2ff09c4ed7d761f4af64df2009","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"549b4c71ef3c2f1e33bc7f27937384eceffe9b48","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6ed52fc9158755a074f1eac2955587a99d8a41f9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d61d113b64b1580938838a42a509e9372e0c6607","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c27ebcffec5d191dd558e27fe3a9865d2a781ba9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"37564bfb0323f5cea1c4550f3557ba1406b46d3e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ab7b7a23c9fec7682a457dd0ce6db649c0b51467","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"aff67893345f94c688883e11b3c23856f5cc2659","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"fad72e239c46fd14e78a6739bd0faf0dd74c780d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c35a61fe707f0d240ec25de41144b70f279fd0b4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"488a66e6b75a9a3e2a5698276b551c39bb274cd5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c37cd39b13ba16e13d3c48eb56bef56f977b09c8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5cc3e8066f58bda9b22eccb635b6bc566e1d6831","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"50e99dcd32b3a10c41215d071fe0ddefbdcbe2ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cfafcbd5e46a553a0036236b671861441e2b6424","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5ce9214d9d744a9d5d97c83d5b4605b46c36910c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"935a02ca64c7ff4ca29b6dfe90f47d25dc77323e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"35abd49621f7a84141a8ec08bd180d4bf54ecc24","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e27a0ee18634213ce677703cddc9ea1b09c5afab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9afb42e1baa40e5a85988ba8ef354676ab18ae54","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"1795bf89ff27c599e2d7e01766cad3e7a4a1836e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"596e4bc6b47b59ef68a643b94b93fdea0e77c5c4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"876746f4fe0db5345c76d5ee1ca8b896536a55d7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3cc3ad24e32665338afb345df61e8b45543b5628","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e660d4629c3e7a5435d096454ad5d62676303471","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c84055e94a7d5e9e27545a3bedfcd566a02d126c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"cce3e3b0f5c891d7ba946883688eb6d45854ddd8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"670ef61f7f3c6d7e8b01dc85b28fba99e43f32b4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"47127dbde7a1411b401943a15c54eb9737a1817e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","status":"added","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d4b0ce936e164c31061867f12735062c489440da","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"added","additions":1440,"deletions":0,"changes":1440,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b7039c2b32c7e81c186e8709fdf132937aa9dbe4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d0442e4f4ada2edef98609dd01bb8f7734d45fe1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","status":"added","additions":146,"deletions":0,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"7335f50f0da57369f98ebaece1fefd66d4aa1480","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ec9bfb6631bf0baf3da09796c8cd7929580a4d70","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c5ba6cfc901e65170c22326ce3a380bc3b5aee93","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","status":"added","additions":740,"deletions":0,"changes":740,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"500db6e01ae26295ae89d44b4e3319458a9d3a2f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"added","additions":311,"deletions":0,"changes":311,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"64e52d94fb3525c9c8e2c8bfdb817cc8f4736873","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","status":"added","additions":106,"deletions":0,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"01b17b5752822cd0e6a466dcd86fbbadd9463004","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"added","additions":2084,"deletions":0,"changes":2084,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9c0c4e2920dbeff5f9fa5590ef15795e85b6f866","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"bd79904ea45cbfa35c59b6fb3af0546e50cba2f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","status":"added","additions":437,"deletions":0,"changes":437,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b53a7cf7cb96aef94adfa7990a1bd397bf9ce012","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"added","additions":189,"deletions":0,"changes":189,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2358fbdebd5942ba1662501d6e60e4100dc33e4c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"added","additions":1762,"deletions":0,"changes":1762,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"}]}

