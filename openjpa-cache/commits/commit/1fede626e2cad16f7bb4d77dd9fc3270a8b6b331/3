{"sha":"1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","node_id":"MDY6Q29tbWl0MjA2MzY0OjFmZWRlNjI2ZTJjYWQxNmY3YmI0ZDc3ZGQ5ZmMzMjcwYThiNmIzMzE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-11T00:35:10Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-11T00:35:10Z"},"message":"core OpenJPA object management code, plus a sample flat-file XML-based back-end. This submission does not include the OpenJPA JDBC back-end, and also doesn't include any additional tests yet.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@420667 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6e080044f1fb52a550e884c40416eef820cc8eb9","url":"https://api.github.com/repos/apache/openjpa/git/trees/6e080044f1fb52a550e884c40416eef820cc8eb9"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","html_url":"https://github.com/apache/openjpa/commit/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","comments_url":"https://api.github.com/repos/apache/openjpa/commits/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/comments","author":null,"committer":null,"parents":[{"sha":"00652be8fdb0007e6b0b624a370b9837c2854019","url":"https://api.github.com/repos/apache/openjpa/commits/00652be8fdb0007e6b0b624a370b9837c2854019","html_url":"https://github.com/apache/openjpa/commit/00652be8fdb0007e6b0b624a370b9837c2854019"}],"stats":{"total":109324,"additions":104070,"deletions":5254},"files":[{"sha":"7c7f0da974f005522156e7eb276bdf61ca2b9575","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","status":"added","additions":283,"deletions":0,"changes":283,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,283 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.Constructor;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.lang.reflect.Method;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import java.util.Set;\r\n+import javax.persistence.EntityManagerFactory;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.AutoDetach;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+import org.apache.openjpa.kernel.DelegatingBrokerFactory;\r\n+import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.lib.conf.Value;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Implementation of {@link EntityManagerFactory} that acts as a\r\n+ * facade to a {@link BrokerFactory}.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ * @nojavadoc\r\n+ */\r\n+public class EntityManagerFactoryImpl implements OpenJPAEntityManagerFactory {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (EntityManagerFactoryImpl.class);\r\n+    private final DelegatingBrokerFactory _factory;\r\n+    private transient Constructor<FetchPlan> _plan = null;\r\n+    private transient StoreCache _cache = null;\r\n+    private transient QueryResultCache _queryCache = null;\r\n+\r\n+    /**\r\n+     * Constructor. Delegate must be provided on construction.\r\n+     */\r\n+    protected EntityManagerFactoryImpl(BrokerFactory factory) {\r\n+        _factory = new DelegatingBrokerFactory(factory,\r\n+            PersistenceExceptions.TRANSLATOR);\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public BrokerFactory getBrokerFactory() {\r\n+        return _factory.getDelegate();\r\n+    }\r\n+\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _factory.getConfiguration();\r\n+    }\r\n+\r\n+    public Properties getProperties() {\r\n+        return _factory.getProperties();\r\n+    }\r\n+\r\n+    public Object putUserObject(Object key, Object val) {\r\n+        return _factory.putUserObject(key, val);\r\n+    }\r\n+\r\n+    public Object getUserObject(Object key) {\r\n+        return _factory.getUserObject(key);\r\n+    }\r\n+\r\n+    public StoreCache getStoreCache() {\r\n+        _factory.lock();\r\n+        try {\r\n+            if (_cache == null) {\r\n+                OpenJPAConfiguration conf = _factory.getConfiguration();\r\n+                _cache = new StoreCache(this,\r\n+                    conf.getDataCacheManagerInstance().getSystemDataCache());\r\n+            }\r\n+            return _cache;\r\n+        }\r\n+        finally {\r\n+            _factory.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public StoreCache getStoreCache(String cacheName) {\r\n+        return new StoreCache(this, _factory.getConfiguration().\r\n+            getDataCacheManagerInstance().getDataCache(cacheName));\r\n+    }\r\n+\r\n+    public QueryResultCache getQueryResultCache() {\r\n+        _factory.lock();\r\n+        try {\r\n+            if (_queryCache == null)\r\n+                _queryCache = new QueryResultCache(_factory.getConfiguration().\r\n+                    getDataCacheManagerInstance().getSystemQueryCache());\r\n+            return _queryCache;\r\n+        }\r\n+        finally {\r\n+            _factory.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAEntityManager createEntityManager() {\r\n+        return createEntityManager(null);\r\n+    }\r\n+\r\n+    public OpenJPAEntityManager createEntityManager(Map props) {\r\n+        if (props == null)\r\n+            props = Collections.EMPTY_MAP;\r\n+        else if (!props.isEmpty())\r\n+            props = new HashMap(props);\r\n+        OpenJPAConfiguration conf = getConfiguration();\r\n+        String user =\r\n+            (String) props.remove(\"org.apache.openjpa.ConnectionUserName\");\r\n+        if (user == null)\r\n+            user = conf.getConnectionUserName();\r\n+        String pass =\r\n+            (String) props.remove(\"org.apache.openjpa.ConnectionPassword\");\r\n+        if (pass == null)\r\n+            pass = conf.getConnectionPassword();\r\n+        String str =\r\n+            (String) props.remove(\"org.apache.openjpa.TransactionMode\");\r\n+        boolean managed;\r\n+        if (str == null)\r\n+            managed = conf.isTransactionModeManaged();\r\n+        else {\r\n+            Value val = conf.getValue(\"org.apache.openjpa.TransactionMode\");\r\n+            managed = Boolean.parseBoolean(val.unalias(str));\r\n+        }\r\n+        Object obj = props.remove(\"org.apache.openjpa.ConnectionRetainMode\");\r\n+        int retainMode;\r\n+        if (obj instanceof Number)\r\n+            retainMode = ((Number) obj).intValue();\r\n+        else if (obj != null) {\r\n+            Value val =\r\n+                conf.getValue(\"org.apache.openjpa.ConnectionRetainMode\");\r\n+            try {\r\n+                retainMode = Integer.parseInt(val.unalias((String) obj));\r\n+            } catch (Exception e) {\r\n+                throw new ArgumentException(_loc.get(\"bad-em-prop\",\r\n+                    \"org.apache.openjpa.ConnectionRetainMode\", obj),\r\n+                    new Throwable[]{ e },\r\n+                    obj, true);\r\n+            }\r\n+        } else retainMode = conf.getConnectionRetainModeConstant();\r\n+        Broker broker =\r\n+            _factory.newBroker(user, pass, managed, retainMode, false);\r\n+        // we should allow the user to specify these settings in conf\r\n+        // regardless of PersistenceContextType\r\n+        broker.setAutoDetach(AutoDetach.DETACH_CLOSE);\r\n+        broker.setDetachedNew(false);\r\n+        OpenJPAEntityManager em = OpenJPAPersistence.toEntityManager(broker);\r\n+        // allow setting of other bean properties of EM\r\n+        List<RuntimeException> errs = null;\r\n+        Method setter = null;\r\n+        String prop;\r\n+        Object val;\r\n+        for (Map.Entry entry : (Set<Map.Entry>) props.entrySet()) {\r\n+            prop = (String) entry.getKey();\r\n+            if (!prop.startsWith(\"org.apache.openjpa.\"))\r\n+                continue;\r\n+            prop = prop.substring(5);\r\n+            try {\r\n+                setter = ImplHelper.getSetter(em.getClass(), prop);\r\n+            } catch (OpenJPAException ke) {\r\n+                if (errs == null)\r\n+                    errs = new LinkedList<RuntimeException>();\r\n+                errs.add(PersistenceExceptions.toPersistenceException(ke));\r\n+                continue;\r\n+            }\r\n+            val = entry.getValue();\r\n+            try {\r\n+                if (val instanceof String) {\r\n+                    if (\"null\".equals(val))\r\n+                        val = null;\r\n+                    else val = Strings.parse((String) val,\r\n+                        setter.getParameterTypes()[0]);\r\n+                }\r\n+                setter.invoke(em, new Object[]{ val });\r\n+            } catch (Exception e) {\r\n+                ArgumentException err = new ArgumentException(_loc.get\r\n+                    (\"bad-em-prop\", prop, entry.getValue()),\r\n+                    new Throwable[]{ e }, null, true);\r\n+                if (errs == null)\r\n+                    errs = new LinkedList<RuntimeException>();\r\n+                errs.add(err);\r\n+            }\r\n+        }\r\n+        if (errs != null) {\r\n+            em.close();\r\n+            if (errs.size() == 1)\r\n+                throw errs.get(0);\r\n+            throw new ArgumentException(_loc.get(\"bad-em-props\"),\r\n+                (Throwable[]) errs.toArray(new Throwable[errs.size()]),\r\n+                null, true);\r\n+        }\r\n+        return em;\r\n+    }\r\n+\r\n+    public void addLifecycleListener(Object listener, Class... classes) {\r\n+        _factory.addLifecycleListener(listener, classes);\r\n+    }\r\n+\r\n+    public void removeLifecycleListener(Object listener) {\r\n+        _factory.removeLifecycleListener(listener);\r\n+    }\r\n+\r\n+    public void close() {\r\n+        _factory.close();\r\n+    }\r\n+\r\n+    public boolean isOpen() {\r\n+        return !_factory.isClosed();\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _factory.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof EntityManagerFactoryImpl))\r\n+            return false;\r\n+        return _factory.equals(((EntityManagerFactoryImpl) other)._factory);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a store-specific facade for the given fetch configuration.\r\n+     * The name of the facade class is formed by taking the top-most org.apache.openjpa.xxx\r\n+     * package and class name prefix from the fetch configuration class and\r\n+     * combining it as\r\n+     * <code>org.apache.openjpa.persistence.xxx.PrefixFetchConfiguration</code>.\r\n+     * The class must have a constructor that takes a\r\n+     * <code>FetchConfiguration</code> argument. If no facade class\r\n+     * exists, we use the default {@link FetchConfiguration}.\r\n+     */\r\n+    FetchPlan toFetchPlan(FetchConfiguration fetch) {\r\n+        if (fetch == null)\r\n+            return null;\r\n+        FetchConfiguration inner = fetch;\r\n+        if (inner instanceof DelegatingFetchConfiguration)\r\n+            inner = ((DelegatingFetchConfiguration) inner).\r\n+                getInnermostDelegate();\r\n+        _factory.lock();\r\n+        try {\r\n+            if (_plan == null) {\r\n+                Class cls = ImplHelper.getStoreFacadeType(_factory.\r\n+                    getConfiguration(), inner.getClass(), \"FetchConfiguration\",\r\n+                    \"persistence\", FetchPlan.class, null);\r\n+                if (cls == null)\r\n+                    cls = FetchPlan.class;\r\n+                _plan = cls.getConstructor(FetchConfiguration.class);\r\n+            }\r\n+            return _plan.newInstance(fetch);\r\n+        } catch (InvocationTargetException ite) {\r\n+            throw PersistenceExceptions.toPersistenceException\r\n+                (ite.getTargetException());\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+        finally {\r\n+            _factory.unlock();\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"899d736e8fd5380c9e20128f1db88f2551eedfa3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"added","additions":969,"deletions":0,"changes":969,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,969 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityTransaction;\r\n+import javax.persistence.FlushModeType;\r\n+import javax.persistence.LockModeType;\r\n+import javax.persistence.Query;\r\n+import javax.resource.ResourceException;\r\n+import javax.resource.cci.ConnectionMetaData;\r\n+import javax.resource.cci.Interaction;\r\n+import javax.resource.cci.LocalTransaction;\r\n+import javax.resource.cci.ResultSetInfo;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.DelegatingBroker;\r\n+import org.apache.openjpa.kernel.FindCallbacks;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.OpCallbacks;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.QueryFlushModes;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.jpql.JPQLParser;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.QueryMetaData;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Implementation of {@link EntityManager} interface.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class EntityManagerImpl\r\n+    implements OpenJPAEntityManager, FindCallbacks, OpCallbacks {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (EntityManagerImpl.class);\r\n+    private final DelegatingBroker _broker;\r\n+    private final EntityManagerFactoryImpl _emf;\r\n+    private FetchPlan _fetch = null;\r\n+\r\n+    /**\r\n+     * Constructor; supply factory and delegate.\r\n+     */\r\n+    public EntityManagerImpl(EntityManagerFactoryImpl factory, Broker broker) {\r\n+        _emf = factory;\r\n+        RuntimeExceptionTranslator translator =\r\n+            PersistenceExceptions.getRollbackTranslator(this);\r\n+        _broker = new DelegatingBroker(broker, translator);\r\n+        _broker.setImplicitBehavior(this, translator);\r\n+    }\r\n+\r\n+    /**\r\n+     * Broker delegate.\r\n+     */\r\n+    public Broker getBroker() {\r\n+        return _broker.getDelegate();\r\n+    }\r\n+\r\n+    public ConnectionMetaData getMetaData() throws ResourceException {\r\n+        return _broker.getMetaData();\r\n+    }\r\n+\r\n+    public Interaction createInteraction() throws ResourceException {\r\n+        return _broker.createInteraction();\r\n+    }\r\n+\r\n+    public LocalTransaction getLocalTransaction() throws ResourceException {\r\n+        return this;\r\n+    }\r\n+\r\n+    public ResultSetInfo getResultSetInfo() throws ResourceException {\r\n+        return _broker.getResultSetInfo();\r\n+    }\r\n+\r\n+    public OpenJPAEntityManagerFactory getEntityManagerFactory() {\r\n+        return _emf;\r\n+    }\r\n+\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _broker.getConfiguration();\r\n+    }\r\n+\r\n+    public FetchPlan getFetchPlan() {\r\n+        _broker.lock();\r\n+        try {\r\n+            if (_fetch == null)\r\n+                _fetch = _emf.toFetchPlan(_broker.getFetchConfiguration());\r\n+            return _fetch;\r\n+        }\r\n+        finally {\r\n+            _broker.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public int getConnectionRetainMode() {\r\n+        return _broker.getConnectionRetainMode();\r\n+    }\r\n+\r\n+    public boolean isManaged() {\r\n+        return _broker.isManaged();\r\n+    }\r\n+\r\n+    public ManagedRuntime getManagedRuntime() {\r\n+        return _broker.getManagedRuntime();\r\n+    }\r\n+\r\n+    public boolean getSyncWithManagedTransactions() {\r\n+        return _broker.getSyncWithManagedTransactions();\r\n+    }\r\n+\r\n+    public void setSyncWithManagedTransactions(boolean sync) {\r\n+        _broker.setSyncWithManagedTransactions(sync);\r\n+    }\r\n+\r\n+    public ClassLoader getClassLoader() {\r\n+        return _broker.getClassLoader();\r\n+    }\r\n+\r\n+    public String getConnectionUserName() {\r\n+        return _broker.getConnectionUserName();\r\n+    }\r\n+\r\n+    public String getConnectionPassword() {\r\n+        return _broker.getConnectionPassword();\r\n+    }\r\n+\r\n+    public boolean getMultithreaded() {\r\n+        return _broker.getMultithreaded();\r\n+    }\r\n+\r\n+    public void setMultithreaded(boolean multithreaded) {\r\n+        _broker.setMultithreaded(multithreaded);\r\n+    }\r\n+\r\n+    public boolean getIgnoreChanges() {\r\n+        return _broker.getIgnoreChanges();\r\n+    }\r\n+\r\n+    public void setIgnoreChanges(boolean val) {\r\n+        _broker.setIgnoreChanges(val);\r\n+    }\r\n+\r\n+    public boolean getNontransactionalRead() {\r\n+        return _broker.getNontransactionalRead();\r\n+    }\r\n+\r\n+    public void setNontransactionalRead(boolean val) {\r\n+        _broker.setNontransactionalRead(val);\r\n+    }\r\n+\r\n+    public boolean getNontransactionalWrite() {\r\n+        return _broker.getNontransactionalWrite();\r\n+    }\r\n+\r\n+    public void setNontransactionalWrite(boolean val) {\r\n+        _broker.setNontransactionalWrite(val);\r\n+    }\r\n+\r\n+    public boolean getOptimistic() {\r\n+        return _broker.getOptimistic();\r\n+    }\r\n+\r\n+    public void setOptimistic(boolean val) {\r\n+        _broker.setOptimistic(val);\r\n+    }\r\n+\r\n+    public int getRestoreState() {\r\n+        return _broker.getRestoreState();\r\n+    }\r\n+\r\n+    public void setRestoreState(int val) {\r\n+        _broker.setRestoreState(val);\r\n+    }\r\n+\r\n+    public boolean getRetainState() {\r\n+        return _broker.getRetainState();\r\n+    }\r\n+\r\n+    public void setRetainState(boolean val) {\r\n+        _broker.setRetainState(val);\r\n+    }\r\n+\r\n+    public int getAutoClear() {\r\n+        return _broker.getAutoClear();\r\n+    }\r\n+\r\n+    public void setAutoClear(int val) {\r\n+        _broker.setAutoClear(val);\r\n+    }\r\n+\r\n+    public int getDetachState() {\r\n+        return _broker.getDetachState();\r\n+    }\r\n+\r\n+    public void setDetachState(int mode) {\r\n+        _broker.setDetachState(mode);\r\n+    }\r\n+\r\n+    public int getAutoDetach() {\r\n+        return _broker.getAutoDetach();\r\n+    }\r\n+\r\n+    public void setAutoDetach(int flags) {\r\n+        _broker.setAutoDetach(flags);\r\n+    }\r\n+\r\n+    public void setAutoDetach(int flag, boolean on) {\r\n+        _broker.setAutoDetach(flag, on);\r\n+    }\r\n+\r\n+    public boolean getEvictFromStoreCache() {\r\n+        return _broker.getEvictFromDataCache();\r\n+    }\r\n+\r\n+    public void setEvictFromStoreCache(boolean evict) {\r\n+        _broker.setEvictFromDataCache(evict);\r\n+    }\r\n+\r\n+    public boolean getPopulateStoreCache() {\r\n+        return _broker.getPopulateDataCache();\r\n+    }\r\n+\r\n+    public void setPopulateStoreCache(boolean cache) {\r\n+        _broker.setPopulateDataCache(cache);\r\n+    }\r\n+\r\n+    public boolean isLargeTransaction() {\r\n+        return _broker.isLargeTransaction();\r\n+    }\r\n+\r\n+    public void setLargeTransaction(boolean largeTransaction) {\r\n+        _broker.setLargeTransaction(largeTransaction);\r\n+    }\r\n+\r\n+    public Object getUserObject(Object key) {\r\n+        return _broker.getUserObject(key);\r\n+    }\r\n+\r\n+    public Object putUserObject(Object key, Object val) {\r\n+        return _broker.putUserObject(key, val);\r\n+    }\r\n+\r\n+    public void addTransactionListener(Object listener) {\r\n+        _broker.addTransactionListener(listener);\r\n+    }\r\n+\r\n+    public void removeTransactionListener(Object listener) {\r\n+        _broker.removeTransactionListener(listener);\r\n+    }\r\n+\r\n+    public void addLifecycleListener(Object listener, Class... classes) {\r\n+        _broker.addLifecycleListener(listener, classes);\r\n+    }\r\n+\r\n+    public void removeLifecycleListener(Object listener) {\r\n+        _broker.removeLifecycleListener(listener);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T getReference(Class<T> cls, Object oid) {\r\n+        oid = _broker.newObjectId(cls, oid);\r\n+        return (T) _broker.find(oid, false, this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T find(Class<T> cls, Object oid) {\r\n+        oid = _broker.newObjectId(cls, oid);\r\n+        return (T) _broker.find(oid, true, this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T[] findAll(Class<T> cls, Object... oids) {\r\n+        if (oids.length == 0)\r\n+            return (T[]) Array.newInstance(cls, 0);\r\n+        Collection<T> ret = findAll(cls, Arrays.asList(oids));\r\n+        return ret.toArray((T[]) Array.newInstance(cls, ret.size()));\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> Collection<T> findAll(final Class<T> cls, Collection oids) {\r\n+        Object[] objs = _broker.findAll(oids, true, new FindCallbacks() {\r\n+            public Object processArgument(Object oid) {\r\n+                return _broker.newObjectId(cls, oid);\r\n+            }\r\n+\r\n+            public Object processReturn(Object oid, OpenJPAStateManager sm) {\r\n+                return EntityManagerImpl.this.processReturn(oid, sm);\r\n+            }\r\n+        });\r\n+        return (Collection<T>) Arrays.asList(objs);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T findCached(Class<T> cls, Object oid) {\r\n+        return (T) _broker.findCached(_broker.newObjectId(cls, oid), this);\r\n+    }\r\n+\r\n+    public Class getObjectIdClass(Class cls) {\r\n+        if (cls == null)\r\n+            return null;\r\n+        return OpenJPAPersistence\r\n+            .fromOpenJPAObjectIdClass(_broker.getObjectIdType\r\n+                (cls));\r\n+    }\r\n+\r\n+    public EntityTransaction getTransaction() {\r\n+        if (_broker.isManaged())\r\n+            throw new InvalidStateException(_loc.get(\"get-managed-trans\"),\r\n+                null, null, false);\r\n+        return this;\r\n+    }\r\n+\r\n+    public void joinTransaction() {\r\n+        if (!_broker.syncWithManagedTransaction())\r\n+            throw new TransactionRequiredException(_loc.get\r\n+                (\"no-managed-trans\"), null, null, false);\r\n+    }\r\n+\r\n+    public void begin() {\r\n+        _broker.begin();\r\n+    }\r\n+\r\n+    public void commit() {\r\n+        try {\r\n+            _broker.commit();\r\n+        } catch (RollbackException e) {\r\n+            throw e;\r\n+        } catch (IllegalStateException e) {\r\n+            throw e;\r\n+        } catch (Exception e) {\r\n+            // RollbackExceptions are special and aren't handled by the\r\n+            // normal exception translator, since the spec says they\r\n+            // should be thrown whenever the commit fails for any reason at\r\n+            // all, wheras the exception translator handles exceptions that\r\n+            // are caused for specific reasons\r\n+            throw new RollbackException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public void rollback() {\r\n+        _broker.rollback();\r\n+    }\r\n+\r\n+    public void commitAndResume() {\r\n+        _broker.commitAndResume();\r\n+    }\r\n+\r\n+    public void rollbackAndResume() {\r\n+        _broker.rollbackAndResume();\r\n+    }\r\n+\r\n+    public boolean getRollbackOnly() {\r\n+        if (!isActive())\r\n+            throw new IllegalStateException(_loc.get(\"no-transaction\"));\r\n+        return _broker.getRollbackOnly();\r\n+    }\r\n+\r\n+    public void setRollbackOnly() {\r\n+        _broker.setRollbackOnly();\r\n+    }\r\n+\r\n+    public void setSavepoint(String name) {\r\n+        _broker.setSavepoint(name);\r\n+    }\r\n+\r\n+    public void rollbackToSavepoint() {\r\n+        _broker.rollbackToSavepoint();\r\n+    }\r\n+\r\n+    public void rollbackToSavepoint(String name) {\r\n+        _broker.rollbackToSavepoint(name);\r\n+    }\r\n+\r\n+    public void releaseSavepoint() {\r\n+        _broker.releaseSavepoint();\r\n+    }\r\n+\r\n+    public void releaseSavepoint(String name) {\r\n+        _broker.releaseSavepoint(name);\r\n+    }\r\n+\r\n+    public void flush() {\r\n+        _broker.assertActiveTransaction();\r\n+        _broker.flush();\r\n+    }\r\n+\r\n+    public void preFlush() {\r\n+        _broker.preFlush();\r\n+    }\r\n+\r\n+    public void validateChanges() {\r\n+        _broker.validateChanges();\r\n+    }\r\n+\r\n+    public boolean isActive() {\r\n+        return isOpen() && _broker.isActive();\r\n+    }\r\n+\r\n+    public boolean isStoreActive() {\r\n+        return _broker.isStoreActive();\r\n+    }\r\n+\r\n+    public void beginStore() {\r\n+        _broker.beginStore();\r\n+    }\r\n+\r\n+    public boolean contains(Object entity) {\r\n+        if (entity == null)\r\n+            return false;\r\n+        OpenJPAStateManager sm = _broker.getStateManager(entity);\r\n+        if (sm == null && !ImplHelper.isManagedType(entity.getClass()))\r\n+            throw new ArgumentException(_loc.get(\"not-entity\",\r\n+                entity.getClass()), null, null, true);\r\n+        return sm != null && !sm.isDeleted();\r\n+    }\r\n+\r\n+    public boolean containsAll(Object... entities) {\r\n+        for (Object entity : entities)\r\n+            if (!contains(entity))\r\n+                return false;\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean containsAll(Collection entities) {\r\n+        for (Object entity : entities)\r\n+            if (!contains(entity))\r\n+                return false;\r\n+        return true;\r\n+    }\r\n+\r\n+    public void persist(Object entity) {\r\n+        _broker.persist(entity, this);\r\n+    }\r\n+\r\n+    public void persistAll(Object... entities) {\r\n+        persistAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void persistAll(Collection entities) {\r\n+        _broker.persistAll(entities, this);\r\n+    }\r\n+\r\n+    public void remove(Object entity) {\r\n+        _broker.delete(entity, this);\r\n+    }\r\n+\r\n+    public void removeAll(Object... entities) {\r\n+        removeAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void removeAll(Collection entities) {\r\n+        _broker.deleteAll(entities, this);\r\n+    }\r\n+\r\n+    public void release(Object entity) {\r\n+        _broker.release(entity, this);\r\n+    }\r\n+\r\n+    public void releaseAll(Collection entities) {\r\n+        _broker.releaseAll(entities, this);\r\n+    }\r\n+\r\n+    public void releaseAll(Object... entities) {\r\n+        releaseAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void refresh(Object entity) {\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refresh(entity, this);\r\n+    }\r\n+\r\n+    public void refreshAll() {\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refreshAll(_broker.getTransactionalObjects(), this);\r\n+    }\r\n+\r\n+    public void refreshAll(Collection entities) {\r\n+        _broker.assertWriteOperation();\r\n+        _broker.refreshAll(entities, this);\r\n+    }\r\n+\r\n+    public void refreshAll(Object... entities) {\r\n+        refreshAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void retrieve(Object entity) {\r\n+        _broker.retrieve(entity, true, this);\r\n+    }\r\n+\r\n+    public void retrieveAll(Collection entities) {\r\n+        _broker.retrieveAll(entities, true, this);\r\n+    }\r\n+\r\n+    public void retrieveAll(Object... entities) {\r\n+        retrieveAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void evict(Object entity) {\r\n+        _broker.evict(entity, this);\r\n+    }\r\n+\r\n+    public void evictAll(Collection entities) {\r\n+        _broker.evictAll(entities, this);\r\n+    }\r\n+\r\n+    public void evictAll(Object... entities) {\r\n+        evictAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void evictAll() {\r\n+        _broker.evictAll(this);\r\n+    }\r\n+\r\n+    public void evictAll(Class cls) {\r\n+        _broker.evictAll(_broker.newExtent(cls, true), this);\r\n+    }\r\n+\r\n+    public void evictAll(Extent extent) {\r\n+        _broker.evictAll(extent.getDelegate(), this);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T detach(T entity) {\r\n+        return (T) _broker.detach(entity, this);\r\n+    }\r\n+\r\n+    public Object[] detachAll(Object... entities) {\r\n+        return _broker.detachAll(Arrays.asList(entities), this);\r\n+    }\r\n+\r\n+    public Collection detachAll(Collection entities) {\r\n+        return Arrays.asList(_broker.detachAll(entities, this));\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public <T> T merge(T entity) {\r\n+        return (T) _broker.attach(entity, true, this);\r\n+    }\r\n+\r\n+    public Object[] mergeAll(Object... entities) {\r\n+        if (entities.length == 0)\r\n+            return new Object[0];\r\n+        return mergeAll(Arrays.asList(entities)).toArray();\r\n+    }\r\n+\r\n+    public Collection mergeAll(Collection entities) {\r\n+        return Arrays.asList(_broker.attachAll(entities, true, this));\r\n+    }\r\n+\r\n+    public void transactional(Object entity, boolean updateVersion) {\r\n+        _broker.transactional(entity, updateVersion, this);\r\n+    }\r\n+\r\n+    public void transactionalAll(Collection objs, boolean updateVersion) {\r\n+        _broker.transactionalAll(objs, updateVersion, this);\r\n+    }\r\n+\r\n+    public void transactionalAll(Object[] objs, boolean updateVersion) {\r\n+        _broker.transactionalAll(Arrays.asList(objs), updateVersion, this);\r\n+    }\r\n+\r\n+    public void nontransactional(Object entity) {\r\n+        _broker.nontransactional(entity, this);\r\n+    }\r\n+\r\n+    public void nontransactionalAll(Collection objs) {\r\n+        _broker.nontransactionalAll(objs, this);\r\n+    }\r\n+\r\n+    public void nontransactionalAll(Object[] objs) {\r\n+        _broker.nontransactionalAll(Arrays.asList(objs), this);\r\n+    }\r\n+\r\n+    public Generator getNamedGenerator(String name) {\r\n+        try {\r\n+            SequenceMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepository().getSequenceMetaData(name,\r\n+                _broker.getClassLoader(), true);\r\n+            Seq seq = meta.getInstance(_broker.getClassLoader());\r\n+            return new Generator(seq, name, _broker, null);\r\n+        } catch (RuntimeException re) {\r\n+            throw PersistenceExceptions.toPersistenceException(re);\r\n+        }\r\n+    }\r\n+\r\n+    public Generator getIdGenerator(Class forClass) {\r\n+        try {\r\n+            ClassMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepository().getMetaData(forClass,\r\n+                _broker.getClassLoader(), true);\r\n+            Seq seq = _broker.getIdentitySequence(meta);\r\n+            return (seq == null) ? null : new Generator(seq, null, _broker,\r\n+                meta);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public Generator getFieldGenerator(Class forClass, String fieldName) {\r\n+        try {\r\n+            ClassMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepository().getMetaData(forClass,\r\n+                _broker.getClassLoader(), true);\r\n+            FieldMetaData fmd = meta.getField(fieldName);\r\n+            if (fmd == null)\r\n+                throw new ArgumentException(_loc.get(\"no-named-field\",\r\n+                    forClass, fieldName), null, null, false);\r\n+            Seq seq = _broker.getValueSequence(fmd);\r\n+            return (seq == null) ? null : new Generator(seq, null, _broker,\r\n+                meta);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public <T> Extent<T> createExtent(Class<T> cls, boolean subclasses) {\r\n+        return new Extent<T>(this, _broker.newExtent(cls, subclasses));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(String query) {\r\n+        return createQuery(JPQLParser.LANG_JPQL, query);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(String language, String query) {\r\n+        return new QueryImpl(this, _broker.newQuery(language, query));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createQuery(Query query) {\r\n+        if (query == null)\r\n+            return createQuery((String) null);\r\n+        org.apache.openjpa.kernel.Query q = ((QueryImpl) query).getDelegate();\r\n+        return new QueryImpl(this, _broker.newQuery(q.getLanguage(), q));\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNamedQuery(String name) {\r\n+        try {\r\n+            QueryMetaData meta = _broker.getConfiguration().\r\n+                getMetaDataRepository().getQueryMetaData(null, name,\r\n+                _broker.getClassLoader(), true);\r\n+            org.apache.openjpa.kernel.Query del =\r\n+                _broker.newQuery(meta.getLanguage(), null);\r\n+            meta.setInto(del);\r\n+            del.compile();\r\n+            OpenJPAQuery q = new QueryImpl(this, del);\r\n+            String[] hints = meta.getHintKeys();\r\n+            Object[] values = meta.getHintValues();\r\n+            for (int i = 0; i < hints.length; i++)\r\n+                q.setHint(hints[i], values[i]);\r\n+            return q;\r\n+        } catch (RuntimeException re) {\r\n+            throw PersistenceExceptions.toPersistenceException(re);\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query) {\r\n+        validateSQL(query);\r\n+        return createQuery(QueryLanguages.LANG_SQL, query);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query, Class cls) {\r\n+        return createNativeQuery(query).setResultClass(cls);\r\n+    }\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String query, String mappingName) {\r\n+        validateSQL(query);\r\n+        org.apache.openjpa.kernel.Query kernelQuery = _broker.newQuery(\r\n+            QueryLanguages.LANG_SQL, query);\r\n+        kernelQuery.setResultMapping(null, mappingName);\r\n+        return new QueryImpl(this, kernelQuery);\r\n+    }\r\n+\r\n+    /**\r\n+     * Validate that the user provided SQL.\r\n+     */\r\n+    private static void validateSQL(String query) {\r\n+        if (query == null || query.trim().length() == 0)\r\n+            throw new ArgumentException(_loc.get(\"no-sql\"), null, null, false);\r\n+    }\r\n+\r\n+    public void setFlushMode(FlushModeType flushMode) {\r\n+        _broker.getFetchConfiguration().setFlushBeforeQueries\r\n+            (toFlushBeforeQueries(flushMode));\r\n+    }\r\n+\r\n+    public FlushModeType getFlushMode() {\r\n+        return fromFlushBeforeQueries(_broker.getFetchConfiguration().\r\n+            getFlushBeforeQueries());\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate our internal flush constant to a flush mode enum value.\r\n+     */\r\n+    static FlushModeType fromFlushBeforeQueries(int flush) {\r\n+        switch (flush) {\r\n+            case QueryFlushModes.FLUSH_TRUE:\r\n+                return FlushModeType.AUTO;\r\n+            case QueryFlushModes.FLUSH_FALSE:\r\n+                return FlushModeType.COMMIT;\r\n+            default:\r\n+                return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate a flush mode enum value to our internal flush constant.\r\n+     */\r\n+    static int toFlushBeforeQueries(FlushModeType flushMode) {\r\n+        // choose default for null\r\n+        if (flushMode == null)\r\n+            return QueryFlushModes.FLUSH_WITH_CONNECTION;\r\n+        if (flushMode == FlushModeType.AUTO)\r\n+            return QueryFlushModes.FLUSH_TRUE;\r\n+        if (flushMode == FlushModeType.COMMIT)\r\n+            return QueryFlushModes.FLUSH_FALSE;\r\n+        throw new ArgumentException(flushMode.toString(), null, null, false);\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        _broker.detachAll(this);\r\n+    }\r\n+\r\n+    public Object getDelegate() {\r\n+        return this;\r\n+    }\r\n+\r\n+    public LockModeType getLockMode(Object entity) {\r\n+        return fromLockLevel(_broker.getLockLevel(entity));\r\n+    }\r\n+\r\n+    public void lock(Object entity, LockModeType mode) {\r\n+        _broker.lock(entity, toLockLevel(mode), -1, this);\r\n+    }\r\n+\r\n+    public void lock(Object entity) {\r\n+        _broker.lock(entity, this);\r\n+    }\r\n+\r\n+    public void lock(Object entity, LockModeType mode, int timeout) {\r\n+        _broker.lock(entity, toLockLevel(mode), timeout, this);\r\n+    }\r\n+\r\n+    public void lockAll(Collection entities) {\r\n+        _broker.lockAll(entities, this);\r\n+    }\r\n+\r\n+    public void lockAll(Collection entities, LockModeType mode, int timeout) {\r\n+        _broker.lockAll(entities, toLockLevel(mode), timeout, this);\r\n+    }\r\n+\r\n+    public void lockAll(Object... entities) {\r\n+        lockAll(Arrays.asList(entities));\r\n+    }\r\n+\r\n+    public void lockAll(Object[] entities, LockModeType mode, int timeout) {\r\n+        lockAll(Arrays.asList(entities), mode, timeout);\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate our internal lock level to a javax.persistence enum value.\r\n+     */\r\n+    static LockModeType fromLockLevel(int level) {\r\n+        if (level < LockLevels.LOCK_READ)\r\n+            return null;\r\n+        if (level < LockLevels.LOCK_WRITE)\r\n+            return LockModeType.READ;\r\n+        return LockModeType.WRITE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the javax.persistence enum value to our internal lock level.\r\n+     */\r\n+    static int toLockLevel(LockModeType mode) {\r\n+        if (mode == null)\r\n+            return LockLevels.LOCK_NONE;\r\n+        if (mode == LockModeType.READ)\r\n+            return LockLevels.LOCK_READ;\r\n+        if (mode == LockModeType.WRITE)\r\n+            return LockLevels.LOCK_WRITE;\r\n+        throw new ArgumentException(mode.toString(), null, null, true);\r\n+    }\r\n+\r\n+    public boolean cancelAll() {\r\n+        return _broker.cancelAll();\r\n+    }\r\n+\r\n+    public Object getConnection() {\r\n+        return _broker.getConnection();\r\n+    }\r\n+\r\n+    public Collection getManagedObjects() {\r\n+        return _broker.getManagedObjects();\r\n+    }\r\n+\r\n+    public Collection getTransactionalObjects() {\r\n+        return _broker.getTransactionalObjects();\r\n+    }\r\n+\r\n+    public Collection getPendingTransactionalObjects() {\r\n+        return _broker.getPendingTransactionalObjects();\r\n+    }\r\n+\r\n+    public Collection getDirtyObjects() {\r\n+        return _broker.getDirtyObjects();\r\n+    }\r\n+\r\n+    public boolean getOrderDirtyObjects() {\r\n+        return _broker.getOrderDirtyObjects();\r\n+    }\r\n+\r\n+    public void setOrderDirtyObjects(boolean order) {\r\n+        _broker.setOrderDirtyObjects(order);\r\n+    }\r\n+\r\n+    public void dirtyClass(Class cls) {\r\n+        _broker.dirtyType(cls);\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getPersistedClasses() {\r\n+        return (Collection<Class>) _broker.getPersistedTypes();\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getUpdatedClasses() {\r\n+        return (Collection<Class>) _broker.getUpdatedTypes();\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    public Collection<Class> getRemovedClasses() {\r\n+        return (Collection<Class>) _broker.getDeletedTypes();\r\n+    }\r\n+\r\n+    public <T> T createInstance(Class<T> cls) {\r\n+        return (T) _broker.newInstance(cls);\r\n+    }\r\n+\r\n+    public void close() {\r\n+        _broker.close();\r\n+    }\r\n+\r\n+    public boolean isOpen() {\r\n+        return !_broker.isClosed();\r\n+    }\r\n+\r\n+    public void dirty(Object o, String field) {\r\n+        OpenJPAStateManager sm = _broker.getStateManager(o);\r\n+        try {\r\n+            if (sm != null)\r\n+                sm.dirty(field);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public Object getObjectId(Object o) {\r\n+        return OpenJPAPersistence.fromOpenJPAObjectId(_broker.getObjectId(o));\r\n+    }\r\n+\r\n+    public boolean isDirty(Object o) {\r\n+        return _broker.isDirty(o);\r\n+    }\r\n+\r\n+    public boolean isTransactional(Object o) {\r\n+        return _broker.isTransactional(o);\r\n+    }\r\n+\r\n+    public boolean isPersistent(Object o) {\r\n+        return _broker.isPersistent(o);\r\n+    }\r\n+\r\n+    public boolean isNewlyPersistent(Object o) {\r\n+        return _broker.isNew(o);\r\n+    }\r\n+\r\n+    public boolean isRemoved(Object o) {\r\n+        return _broker.isDeleted(o);\r\n+    }\r\n+\r\n+    public boolean isDetached(Object entity) {\r\n+        return _broker.isDetached(entity);\r\n+    }\r\n+\r\n+    public Object getVersion(Object o) {\r\n+        return _broker.getVersion(o);\r\n+    }\r\n+\r\n+    ////////////////////////////////\r\n+    // FindCallbacks implementation\r\n+    ////////////////////////////////\r\n+    public Object processArgument(Object arg) {\r\n+        return arg;\r\n+    }\r\n+\r\n+    public Object processReturn(Object oid, OpenJPAStateManager sm) {\r\n+        return (sm == null || sm.isDeleted()) ? null : sm.getManagedInstance();\r\n+    }\r\n+\r\n+    //////////////////////////////\r\n+    // OpCallbacks implementation\r\n+    //////////////////////////////\r\n+    public int processArgument(int op, Object obj, OpenJPAStateManager sm) {\r\n+        switch (op) {\r\n+            case OP_DELETE:\r\n+                // cascade through non-persistent non-detached instances\r\n+                if (sm == null && !_broker.isDetached(obj))\r\n+                    return ACT_CASCADE;\r\n+                if (sm != null && !sm.isDetached() && !sm.isPersistent())\r\n+                    return ACT_CASCADE;\r\n+                // ignore deleted instances\r\n+                if (sm != null && sm.isDeleted())\r\n+                    return ACT_NONE;\r\n+                break;\r\n+            case OP_ATTACH:\r\n+                // die on removed\r\n+                if (sm != null && sm.isDeleted())\r\n+                    throw new UserException(_loc.get(\"removed\",\r\n+                        Exceptions.toString(obj))).setFailedObject(obj);\r\n+                // cascade through managed instances\r\n+                if (sm != null && !sm.isDetached())\r\n+                    return ACT_CASCADE;\r\n+                break;\r\n+            case OP_REFRESH:\r\n+                // die on unmanaged instances\r\n+                if (sm == null)\r\n+                    throw new UserException(_loc.get(\"not-managed\",\r\n+                        Exceptions.toString(obj))).setFailedObject(obj);\r\n+                break;\r\n+        }\r\n+        return ACT_RUN | ACT_CASCADE;\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _broker.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof EntityManagerImpl))\r\n+            return false;\r\n+        return _broker.equals(((EntityManagerImpl) other)._broker);\r\n+    }\r\n+}\r"},{"sha":"a39c5e05b4cea73216eb2694a39bf1a0d175ad4f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityNotFoundException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,104 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.StoreException;\r\n+\r\n+/**\r\n+ * Missing entity.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class EntityNotFoundException\r\n+    extends javax.persistence.EntityNotFoundException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public EntityNotFoundException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return STORE;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return StoreException.OBJECT_NOT_FOUND;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"6c18a00b5daa50050990f20f6f607b0e4686444e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Extent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,133 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.kernel.DelegatingExtent;\r\n+\r\n+/**\r\n+ * An extent is a logical view of all instances of a class.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ */\r\n+public class Extent<T> implements Iterable {\r\n+\r\n+    private final EntityManagerImpl _em;\r\n+    private final DelegatingExtent _extent;\r\n+    private FetchPlan _fetch = null;\r\n+\r\n+    /**\r\n+     * Constructor; supply delegate.\r\n+     */\r\n+    public Extent(EntityManagerImpl em,\r\n+        org.apache.openjpa.kernel.Extent extent) {\r\n+        _em = em;\r\n+        _extent = new DelegatingExtent(extent,\r\n+            PersistenceExceptions.getRollbackTranslator(em));\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public org.apache.openjpa.kernel.Extent getDelegate() {\r\n+        return _extent.getDelegate();\r\n+    }\r\n+\r\n+    /**\r\n+     * The extent's element type.\r\n+     */\r\n+    public Class<T> getElementClass() {\r\n+        return _extent.getElementType();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the extent includes subclasses.\r\n+     */\r\n+    public boolean hasSubclasses() {\r\n+        return _extent.hasSubclasses();\r\n+    }\r\n+\r\n+    /**\r\n+     * The owning entity manager.\r\n+     */\r\n+    public OpenJPAEntityManager getEntityManager() {\r\n+        return _em;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fetch configuration for controlling how iterated objects are loaded.\r\n+     */\r\n+    public FetchPlan getFetchPlan() {\r\n+        _extent.lock();\r\n+        try {\r\n+            if (_fetch == null)\r\n+                _fetch = ((EntityManagerFactoryImpl) _em.\r\n+                    getEntityManagerFactory()).toFetchPlan(_extent.\r\n+                    getFetchConfiguration());\r\n+            return _fetch;\r\n+        }\r\n+        finally {\r\n+            _extent.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the extent sees inserts and deletes in the current transaction.\r\n+     */\r\n+    public boolean getIgnoreChanges() {\r\n+        return _extent.getIgnoreChanges();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the extent sees inserts and deletes in the current transaction.\r\n+     */\r\n+    public void setIgnoreChanges(boolean ignoreChanges) {\r\n+        _extent.setIgnoreChanges(ignoreChanges);\r\n+    }\r\n+\r\n+    /**\r\n+     * List the extent contents.\r\n+     */\r\n+    public List<T> list() {\r\n+        return _extent.list();\r\n+    }\r\n+\r\n+    /**\r\n+     * Iterator over contents.\r\n+     */\r\n+    public Iterator<T> iterator() {\r\n+        return _extent.iterator();\r\n+    }\r\n+\r\n+    /**\r\n+     * Close all open iterators that are consuming database resources.\r\n+     */\r\n+    public void closeAll() {\r\n+        _extent.closeAll();\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _extent.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof Extent))\r\n+            return false;\r\n+        return _extent.equals(((Extent) other)._extent);\r\n+    }\r\n+}\r"},{"sha":"1df4acf44789754204b360d10d9b4136fe8230d4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ExternalValues.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,34 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Maps field values to their datastore equivalents. Each element of\r\n+ * the value array should be a string in the form:\r\n+ * <code>&lt;field value&gt;=&lt;datastore value&gt;</code>\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface ExternalValues {\r\n+\r\n+    String[] value() default {};\r\n+}\r"},{"sha":"8eb36afd9c6c3305077b811b4fc61320976683e7","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Externalizer.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Declares a method that transforms the field value to its datastore\r\n+ * equivalent.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface Externalizer {\r\n+\r\n+    String value() default \"\";\r\n+}\r"},{"sha":"289bb40e9d95c4e4f302475ffe933c8552676f13","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Factory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Declares a method that transforms the datastore value to its field\r\n+ * equivalent.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface Factory {\r\n+\r\n+    String value() default \"\";\r\n+}\r"},{"sha":"6b6b62f871af21bd64ebaf6f20be505f59637838","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchAttribute.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Includes a persistent attribute in a {@link FetchGroup}.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({})\r\n+@Retention(RUNTIME)\r\n+public @interface FetchAttribute {\r\n+\r\n+    String name() default \"\";\r\n+\r\n+    int depth() default 1;\r\n+}\r"},{"sha":"37d40d0514e647c39bb3ededce776d9eb2cdf2c8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroup.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.TYPE;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Fetch group definition.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ TYPE })\r\n+@Retention(RUNTIME)\r\n+public @interface FetchGroup {\r\n+\r\n+    String name() default \"\";\r\n+\r\n+    FetchAttribute[] attributes() default {};\r\n+}\r"},{"sha":"ef79bae943a4b8f3f68befb9294784aec176ea3d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchGroups.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,31 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.TYPE;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Fetch groups holder.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ TYPE })\r\n+@Retention(RUNTIME)\r\n+public @interface FetchGroups {\r\n+\r\n+    FetchGroup[] value() default {};\r\n+}\r"},{"sha":"7f74824cf2118b44dd51745ced457fa84d183ef0","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","status":"added","additions":459,"deletions":0,"changes":459,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,459 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import javax.persistence.LockModeType;\r\n+\r\n+import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+\r\n+/**\r\n+ * The fetch plan allows you to dynamically alter eager fetching\r\n+ * configuration and other aspects of data loading.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public class FetchPlan {\r\n+\r\n+    /**\r\n+     * Fetch group representing all fields.\r\n+     */\r\n+    public static final String FETCH_GROUP_ALL =\r\n+        FetchConfiguration.FETCH_GROUP_ALL;\r\n+\r\n+    /**\r\n+     * Constant to revert any setting to its default value.\r\n+     */\r\n+    public static final int DEFAULT = FetchConfiguration.DEFAULT;\r\n+    private final DelegatingFetchConfiguration _fetch;\r\n+\r\n+    /**\r\n+     * Constructor; supply delegate.\r\n+     */\r\n+    public FetchPlan(FetchConfiguration fetch) {\r\n+        _fetch = newDelegatingFetchConfiguration(fetch);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new exception-translating delegating fetch configuration.\r\n+     */\r\n+    protected DelegatingFetchConfiguration newDelegatingFetchConfiguration\r\n+        (FetchConfiguration fetch) {\r\n+        return new DelegatingFetchConfiguration(fetch,\r\n+            PersistenceExceptions.TRANSLATOR);\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public FetchConfiguration getDelegate() {\r\n+        return _fetch.getDelegate();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the fetch batch size for large result set support.\r\n+     * Defaults to the <code>org.apache.openjpa.FetchBatchSize</code> setting. Note\r\n+     * that this property will be ignored under some data stores.\r\n+     */\r\n+    public int getFetchBatchSize() {\r\n+        return _fetch.getFetchBatchSize();\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the fetch batch size for large result set support.\r\n+     * Defaults to the <code>org.apache.openjpa.FetchBatchSize</code> setting. Note\r\n+     * that this property will be ignored under some data stores.\r\n+     */\r\n+    public FetchPlan setFetchBatchSize(int fetchBatchSize) {\r\n+        _fetch.setFetchBatchSize(fetchBatchSize);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether or not query caching is enabled. If this returns\r\n+     * <code>true</code> but the datacache plugin is not installed, caching\r\n+     * will not be enabled. If this\r\n+     * returns <code>false</code>, query caching will not be used\r\n+     * even if the datacache plugin is installed.\r\n+     */\r\n+    public boolean getQueryResultCache() {\r\n+        return _fetch.getQueryCache();\r\n+    }\r\n+\r\n+    /**\r\n+     * Control whether or not query caching is enabled. This has no effect\r\n+     * if the datacache plugin is not installed, or if the query cache size\r\n+     * is set to zero.\r\n+     */\r\n+    public FetchPlan setQueryResultCache(boolean cache) {\r\n+        _fetch.setQueryCache(cache);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the names of the fetch groups that this component will use\r\n+     * when loading objects. Defaults to the\r\n+     * <code>org.apache.openjpa.FetchGroups</code> setting.\r\n+     */\r\n+    public Collection<String> getFetchGroups() {\r\n+// return new FetchGroupSet();\r\n+        return _fetch.getFetchGroups();\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>group</code> to the set of fetch group to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFetchGroup(String group) {\r\n+        _fetch.addFetchGroup(group);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>groups</code> to the set of fetch group names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFetchGroups(String... groups) {\r\n+        return addFetchGroups(Arrays.asList(groups));\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>groups</code> to the set of fetch group names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFetchGroups(Collection groups) {\r\n+        _fetch.addFetchGroups(groups);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given fetch group.\r\n+     */\r\n+    public FetchPlan removeFetchGroup(String group) {\r\n+        _fetch.removeFetchGroup(group);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>groups</code> from the set of fetch group names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFetchGroups(String... groups) {\r\n+        return removeFetchGroups(Arrays.asList(groups));\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>groups</code> from the set of fetch group names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFetchGroups(Collection groups) {\r\n+        _fetch.removeFetchGroups(groups);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Clears the set of fetch group names to use wen loading\r\n+     * data. After this operation is invoked, only those fields in\r\n+     * the default fetch group(and any requested field) will be\r\n+     * loaded when loading an object.\r\n+     */\r\n+    public FetchPlan clearFetchGroups() {\r\n+        _fetch.clearFetchGroups();\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Resets the set of fetch groups to the list in the global configuration.\r\n+     */\r\n+    public FetchPlan resetFetchGroups() {\r\n+        _fetch.resetFetchGroups();\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the fully qualified names of the fields that this component\r\n+     * will use when loading objects. Defaults to the empty set.\r\n+     */\r\n+    public Collection<String> getFields() {\r\n+// return new FetchFieldSet();\r\n+        return (Collection<String>) _fetch.getFields();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if the given field has been added.\r\n+     */\r\n+    public boolean hasField(String field) {\r\n+        return _fetch.hasField(field);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if the given field has been added.\r\n+     */\r\n+    public boolean hasField(Class cls, String field) {\r\n+        return hasField(toFieldName(cls, field));\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>field</code> to the set of fully-qualified field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addField(String field) {\r\n+        _fetch.addField(field);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>field</code> to the set of field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addField(Class cls, String field) {\r\n+        return addField(toFieldName(cls, field));\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>fields</code> to the set of fully-qualified field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFields(String... fields) {\r\n+        return addFields(Arrays.asList(fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>fields</code> to the set of field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFields(Class cls, String... fields) {\r\n+        return addFields(cls, Arrays.asList(fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>fields</code> to the set of fully-qualified field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFields(Collection fields) {\r\n+        _fetch.addFields(fields);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds <code>fields</code> to the set of field names to\r\n+     * use when loading objects.\r\n+     */\r\n+    public FetchPlan addFields(Class cls, Collection fields) {\r\n+        return addFields(toFieldNames(cls, fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given fully-qualified field.\r\n+     */\r\n+    public FetchPlan removeField(String field) {\r\n+        _fetch.removeField(field);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given field.\r\n+     */\r\n+    public FetchPlan removeField(Class cls, String field) {\r\n+        return removeField(toFieldName(cls, field));\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>fields</code> from the set of fully-qualified field names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFields(String... fields) {\r\n+        return removeFields(Arrays.asList(fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>fields</code> from the set of field names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFields(Class cls, String... fields) {\r\n+        return removeFields(cls, Arrays.asList(fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>fields</code> from the set of fully-qualified field names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFields(Collection fields) {\r\n+        _fetch.removeFields(fields);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes <code>fields</code> from the set of field names\r\n+     * to use when loading objects.\r\n+     */\r\n+    public FetchPlan removeFields(Class cls, Collection fields) {\r\n+        return removeFields(toFieldNames(cls, fields));\r\n+    }\r\n+\r\n+    /**\r\n+     * Clears the set of field names to use wen loading\r\n+     * data. After this operation is invoked, only those fields in\r\n+     * the configured fetch groups will be loaded when loading an object.\r\n+     */\r\n+    public FetchPlan clearFields() {\r\n+        _fetch.clearFields();\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * Combine the class and field to a fully-qualified field name.\r\n+     */\r\n+    private static String toFieldName(Class cls, String field) {\r\n+        return cls.getName() + \".\" + field;\r\n+    }\r\n+\r\n+    /**\r\n+     * Combine the class and fields to fully-qualified field names.\r\n+     */\r\n+    private static Collection toFieldNames(Class cls, Collection fields) {\r\n+        if (fields.isEmpty())\r\n+            return fields;\r\n+        Collection names = new ArrayList(fields);\r\n+        for (Iterator itr = fields.iterator(); itr.hasNext();)\r\n+            names.add(toFieldName(cls, (String) itr.next()));\r\n+        return names;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait for an object lock, or -1 for no\r\n+     * limit.\r\n+     */\r\n+    public int getLockTimeout() {\r\n+        return _fetch.getLockTimeout();\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait for an object lock, or -1 for no\r\n+     * limit.\r\n+     */\r\n+    public FetchPlan setLockTimeout(int timeout) {\r\n+        _fetch.setLockTimeout(timeout);\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * The lock level to use for locking loaded objects.\r\n+     */\r\n+    public LockModeType getReadLockMode() {\r\n+        return EntityManagerImpl.fromLockLevel(_fetch.getReadLockLevel());\r\n+    }\r\n+\r\n+    /**\r\n+     * The lock level to use for locking loaded objects.\r\n+     */\r\n+    public FetchPlan setReadLockMode(LockModeType mode) {\r\n+        _fetch.setReadLockLevel(EntityManagerImpl.toLockLevel(mode));\r\n+        return this;\r\n+    }\r\n+\r\n+    /**\r\n+     * The lock level to use for locking dirtied objects.\r\n+     */\r\n+    public LockModeType getWriteLockMode() {\r\n+        return EntityManagerImpl.fromLockLevel(_fetch.getWriteLockLevel());\r\n+    }\r\n+\r\n+    /**\r\n+     * The lock level to use for locking dirtied objects.\r\n+     */\r\n+    public FetchPlan setWriteLockMode(LockModeType mode) {\r\n+        _fetch.setWriteLockLevel(EntityManagerImpl.toLockLevel(mode));\r\n+        return this;\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _fetch.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof FetchPlan))\r\n+            return false;\r\n+        return _fetch.equals(((FetchPlan) other)._fetch);\r\n+    }\r\n+\r\n+    /**\r\n+     * View of fetch groups as collection.\r\n+     */\r\n+// private class FetchGroupSet\r\n+// extends AbstractCollection<String>\r\n+// {\r\n+// private String[] _groups = null;\r\n+//\r\n+//\r\n+// public boolean contains(Object o)\r\n+// {\r\n+// return o instanceof String && _fetch.hasFetchGroup((String) o);\r\n+// }\r\n+//\r\n+//\r\n+// public Iterator iterator()\r\n+// {\r\n+// if (_groups == null)\r\n+// _groups = _fetch.getFetchGroups();\r\n+// return new ObjectArrayIterator(_groups);\r\n+// }\r\n+//\r\n+//\r\n+// public int size()\r\n+// {\r\n+// if (_groups == null)\r\n+// _groups = _fetch.getFetchGroups();\r\n+// return _groups.length;\r\n+// }\r\n+// }\r\n+\r\n+    /**\r\n+     * View of fetch fields as collection.\r\n+     */\r\n+// private class FetchFieldSet\r\n+// extends AbstractCollection<String>\r\n+// {\r\n+// private String[] _fields = null;\r\n+//\r\n+//\r\n+// public boolean contains(Object o)\r\n+// {\r\n+// return o instanceof String && _fetch.hasField((String) o);\r\n+// }\r\n+//\r\n+//\r\n+// public Iterator iterator()\r\n+// {\r\n+// if (_fields == null)\r\n+// _fields = _fetch.getFields();\r\n+// return new ObjectArrayIterator(_fields);\r\n+// }\r\n+//\r\n+//\r\n+// public int size()\r\n+// {\r\n+// if (_fields == null)\r\n+// _fields = _fetch.getFields();\r\n+// return _fields.length;\r\n+// }\r\n+// }\r\n+}\r"},{"sha":"630bcd2e17625d2fbc4c5d624c9766ec58b56d8c","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Generator.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,95 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import org.apache.openjpa.kernel.DelegatingSeq;\r\n+import org.apache.openjpa.kernel.Seq;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+\r\n+/**\r\n+ * Represents a store sequence.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public class Generator {\r\n+\r\n+    public static final String UUID_HEX = \"uuid-hex\";\r\n+    public static final String UUID_STRING = \"uuid-string\";\r\n+    private final DelegatingSeq _seq;\r\n+    private final String _name;\r\n+    private final StoreContext _ctx;\r\n+    private final ClassMetaData _meta;\r\n+\r\n+    /**\r\n+     * Constructor; supply delegate.\r\n+     */\r\n+    public Generator(Seq seq, String name, StoreContext ctx,\r\n+        ClassMetaData meta) {\r\n+        _seq = new DelegatingSeq(seq, PersistenceExceptions.TRANSLATOR);\r\n+        _name = name;\r\n+        _ctx = ctx;\r\n+        _meta = meta;\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public Seq getDelegate() {\r\n+        return _seq.getDelegate();\r\n+    }\r\n+\r\n+    /**\r\n+     * The sequence name.\r\n+     */\r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    /**\r\n+     * The next sequence value.\r\n+     */\r\n+    public Object next() {\r\n+        return _seq.next(_ctx, _meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * The current sequence value, or null if the sequence does not\r\n+     * support current values.\r\n+     */\r\n+    public Object current() {\r\n+        return _seq.current(_ctx, _meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Hint to the sequence to allocate additional values up-front for\r\n+     * efficiency.\r\n+     */\r\n+    public void allocate(int additional) {\r\n+        _seq.allocate(additional, _ctx, _meta);\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _seq.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof Generator))\r\n+            return false;\r\n+        return _seq.equals(((Generator) other)._seq);\r\n+    }\r\n+}\r"},{"sha":"977f422718d0cfdc7cb4887a033bd67ba32df768","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InvalidStateException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,103 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Extended {@link IllegalStateException}.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+public class InvalidStateException extends IllegalStateException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public InvalidStateException(String msg, Throwable[] nested, Object failed,\r\n+        boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return USER;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return UserException.INVALID_STATE;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"03cec779e0cba8163da62c302693ccbfd5a68633","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/InverseLogical.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Declares the logical inverse of a field.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface InverseLogical {\r\n+\r\n+    String value() default \"\";\r\n+}\r"},{"sha":"4677a0916e0962a566d4289ad42a570482676115","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyDependent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Dependent map key marker.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface KeyDependent {\r\n+\r\n+    boolean value() default true;\r\n+}\r"},{"sha":"385d02948c439b5fe7d6d577cec3f5625a6324d3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/KeyType.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Indicates the persistent key type of a map field, if different than the\r\n+ * declared type.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface KeyType {\r\n+\r\n+    Class value();\r\n+}\r"},{"sha":"9263e6c826fcd6af7df9e33e776816edc0a3ea75","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/LRS.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Large result set field marker.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface LRS {\r\n+\r\n+    boolean value() default true;\r\n+}\r"},{"sha":"f27290a59682234c2f74dbba3623221e54fde76b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataTag.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,72 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+/////////////////////////////////////////////////////////\r\n+// NOTE: when adding a new type, make sure to update the\r\n+// table in PersistenceMetaDataParser\r\n+/////////////////////////////////////////////////////////\r\n+\r\n+/**\r\n+ * Set of metadata tags used in JPA.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public enum MetaDataTag {\r\n+    // sorted by XML order\r\n+    MAPPED_SUPERCLASS,\r\n+    ENTITY,\r\n+    EMBEDDABLE,\r\n+    ENTITY_LISTENERS,\r\n+    FLUSH_MODE,\r\n+    GENERATED_VALUE,\r\n+    ID,\r\n+    EMBEDDED_ID,\r\n+    EXCLUDE_DEFAULT_LISTENERS,\r\n+    EXCLUDE_SUPERCLASS_LISTENERS,\r\n+    ID_CLASS,\r\n+    LOB,\r\n+    MAP_KEY,\r\n+    NATIVE_QUERIES,\r\n+    NATIVE_QUERY,\r\n+    ORDER_BY,\r\n+    QUERIES,\r\n+    QUERY,\r\n+    QUERY_HINT,\r\n+    POST_LOAD,\r\n+    POST_PERSIST,\r\n+    POST_REMOVE,\r\n+    POST_UPDATE,\r\n+    PRE_PERSIST,\r\n+    PRE_REMOVE,\r\n+    PRE_UPDATE,\r\n+    SEQ_GENERATOR,\r\n+    VERSION,\r\n+    // openjpa extensions\r\n+    AUDITABLE,\r\n+    DATA_CACHE,\r\n+    DATASTORE_ID,\r\n+    DEPENDENT,\r\n+    DETACHED_STATE,\r\n+    ELEM_DEPENDENT,\r\n+    ELEM_TYPE,\r\n+    EXTERNAL_VALS,\r\n+    EXTERNALIZER,\r\n+    FACTORY,\r\n+    FETCH_GROUP,\r\n+    FETCH_GROUPS,\r\n+    INVERSE_LOGICAL,\r\n+    KEY_DEPENDENT,\r\n+    KEY_TYPE,\r\n+    LRS,\r\n+    READ_ONLY,\r\n+    TYPE, }\r"},{"sha":"5691ae4b059a069778ac2f108cc9d1a7840975db","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NoResultException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,103 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Unique query returned no results.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class NoResultException extends javax.persistence.NoResultException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public NoResultException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return USER;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return UserException.INVALID_STATE;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"f614d1316d2e280c8cc20f1a79b7c3bf2ebbcf9f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/NonUniqueResultException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,104 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Unique query returned multipl results.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class NonUniqueResultException\r\n+    extends javax.persistence.NonUniqueResultException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public NonUniqueResultException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return USER;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return UserException.INVALID_STATE;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"a9bdf49b8f4f7abfcf5ef33f8f3211d8a531c553","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","status":"added","additions":891,"deletions":0,"changes":891,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,891 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.Collection;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityTransaction;\r\n+import javax.persistence.LockModeType;\r\n+import javax.persistence.Query;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.kernel.AutoClear;\r\n+import org.apache.openjpa.kernel.AutoDetach;\r\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n+import org.apache.openjpa.kernel.DetachState;\r\n+import org.apache.openjpa.kernel.RestoreState;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+\r\n+/**\r\n+ * Interface implemented by OpenJPA entity managers.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public interface OpenJPAEntityManager\r\n+    extends EntityManager, EntityTransaction, javax.resource.cci.Connection,\r\n+    javax.resource.cci.LocalTransaction, javax.resource.spi.LocalTransaction,\r\n+    Closeable, ConnectionRetainModes, DetachState, RestoreState, AutoDetach,\r\n+    AutoClear {\r\n+\r\n+    /**\r\n+     * Return the factory that produced this entity manager.\r\n+     */\r\n+    public OpenJPAEntityManagerFactory getEntityManagerFactory();\r\n+\r\n+    /**\r\n+     * Return the configuration associated with this entity manager.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration();\r\n+\r\n+    /**\r\n+     * Return the(mutable) fetch plan for loading objects from this\r\n+     * entity manager.\r\n+     */\r\n+    public FetchPlan getFetchPlan();\r\n+\r\n+    /**\r\n+     * Return the connection retain mode for this entity manager.\r\n+     *\r\n+     * @see ConnectionRetainModes\r\n+     */\r\n+    public int getConnectionRetainMode();\r\n+\r\n+    /**\r\n+     * Whether this entity manager is using managed transactions.\r\n+     */\r\n+    public boolean isManaged();\r\n+\r\n+    /**\r\n+     * Return the managed runtime in use.\r\n+     */\r\n+    public ManagedRuntime getManagedRuntime();\r\n+\r\n+    /**\r\n+     * Whether to check for a global transaction upon every managed,\r\n+     * non-transactional operation. Defaults to false.\r\n+     */\r\n+    public boolean getSyncWithManagedTransactions();\r\n+\r\n+    /**\r\n+     * Whether to check for a global transaction upon every managed,\r\n+     * non-transactional operation. Defaults to false.\r\n+     */\r\n+    public void setSyncWithManagedTransactions(boolean resync);\r\n+\r\n+    /**\r\n+     * Return the current thread's class loader at the time this entity\r\n+     * manager was obtained from the factory.\r\n+     */\r\n+    public ClassLoader getClassLoader();\r\n+\r\n+    /**\r\n+     * Return the connection user name.\r\n+     */\r\n+    public String getConnectionUserName();\r\n+\r\n+    /**\r\n+     * Return the connection password.\r\n+     */\r\n+    public String getConnectionPassword();\r\n+\r\n+    /**\r\n+     * Whether the entity manager or its managed instances are used in a\r\n+     * multithreaded environment.\r\n+     */\r\n+    public boolean getMultithreaded();\r\n+\r\n+    /**\r\n+     * Whether the entity manager or its managed instances are used in a\r\n+     * multithreaded environment.\r\n+     */\r\n+    public void setMultithreaded(boolean multi);\r\n+\r\n+    /**\r\n+     * Whether to take into account changes in the transaction when executing\r\n+     * a query or iterating an extent.\r\n+     */\r\n+    public boolean getIgnoreChanges();\r\n+\r\n+    /**\r\n+     * Whether to take into account changes in the transaction when executing\r\n+     * a query or iterating an extent.\r\n+     */\r\n+    public void setIgnoreChanges(boolean ignore);\r\n+\r\n+    /**\r\n+     * Whether to allow nontransactional access to persistent state.\r\n+     */\r\n+    public boolean getNontransactionalRead();\r\n+\r\n+    /**\r\n+     * Whether to allow nontransactional access to persistent state.\r\n+     */\r\n+    public void setNontransactionalRead(boolean read);\r\n+\r\n+    /**\r\n+     * Whether to allow nontransactional changes to persistent state.\r\n+     */\r\n+    public boolean getNontransactionalWrite();\r\n+\r\n+    /**\r\n+     * Whether to allow nontransactional changes to persistent state.\r\n+     */\r\n+    public void setNontransactionalWrite(boolean write);\r\n+\r\n+    /**\r\n+     * Whether to use optimistic transactional semantics.\r\n+     */\r\n+    public boolean getOptimistic();\r\n+\r\n+    /**\r\n+     * Whether to use optimistic transactional semantics.\r\n+     */\r\n+    public void setOptimistic(boolean opt);\r\n+\r\n+    /**\r\n+     * Whether to restore an object's original state on rollback.\r\n+     *\r\n+     * @see RestoreState\r\n+     */\r\n+    public int getRestoreState();\r\n+\r\n+    /**\r\n+     * Whether to restore an object's original state on rollback.\r\n+     *\r\n+     * @see RestoreState\r\n+     */\r\n+    public void setRestoreState(int restore);\r\n+\r\n+    /**\r\n+     * Whether objects retain their persistent state on transaction commit.\r\n+     */\r\n+    public boolean getRetainState();\r\n+\r\n+    /**\r\n+     * Whether objects retain their persistent state on transaction commit.\r\n+     */\r\n+    public void setRetainState(boolean retain);\r\n+\r\n+    /**\r\n+     * Detach mode constant to determine which fields are part of the\r\n+     * detached graph.\r\n+     *\r\n+     * @see DetachState\r\n+     */\r\n+    public int getDetachState();\r\n+\r\n+    /**\r\n+     * Detach mode constant to determine which fields are part of the\r\n+     * detached graph.\r\n+     *\r\n+     * @see DetachState\r\n+     */\r\n+    public void setDetachState(int mode);\r\n+\r\n+    /**\r\n+     * Whether to clear state when entering a transaction.\r\n+     *\r\n+     * @see AutoClear\r\n+     */\r\n+    public int getAutoClear();\r\n+\r\n+    /**\r\n+     * Whether to clear state when entering a transaction.\r\n+     *\r\n+     * @see AutoClear\r\n+     */\r\n+    public void setAutoClear(int clear);\r\n+\r\n+    /**\r\n+     * Bit flags marked in {@link AutoDetach} which indicate when persistent\r\n+     * managed objects should be automatically detached in-place.\r\n+     */\r\n+    public int getAutoDetach();\r\n+\r\n+    /**\r\n+     * Bit flags marked in {@link AutoDetach} which indicate when persistent\r\n+     * managed objects should be automatically detached in-place.\r\n+     */\r\n+    public void setAutoDetach(int flags);\r\n+\r\n+    /**\r\n+     * Bit flags marked in {@link AutoDetach} which indicate when persistent\r\n+     * managed objects should be automatically detached in-place.\r\n+     */\r\n+    public void setAutoDetach(int flag, boolean on);\r\n+\r\n+    /**\r\n+     * Whether to also evict an object from the store cache when it is\r\n+     * evicted through this entity manager.\r\n+     */\r\n+    public boolean getEvictFromStoreCache();\r\n+\r\n+    /**\r\n+     * Whether to also evict an object from the store cache when it is\r\n+     * evicted through this entity manager.\r\n+     */\r\n+    public void setEvictFromStoreCache(boolean evict);\r\n+\r\n+    /**\r\n+     * Whether objects accessed during this transaction will be added to the\r\n+     * store cache. Defaults to true.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public boolean getPopulateStoreCache();\r\n+\r\n+    /**\r\n+     * Whether to populate the store cache with objects used by this\r\n+     * transaction. Defaults to true.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public void setPopulateStoreCache(boolean cache);\r\n+\r\n+    /**\r\n+     * Whether memory usage is reduced during this transaction at the expense\r\n+     * of possibly more aggressive data cache evictions.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public boolean isLargeTransaction();\r\n+\r\n+    /**\r\n+     * If a large number of objects will be created, modified, or deleted\r\n+     * during this transaction setting this option to true will reduce memory\r\n+     * usage if you perform periodic flushes.\r\n+     *\r\n+     * @since 3.4\r\n+     */\r\n+    public void setLargeTransaction(boolean largeTransaction);\r\n+\r\n+    /**\r\n+     * Put the specified key-value pair into the map of user objects. Use\r\n+     * a value of null to remove the key.\r\n+     */\r\n+    public Object putUserObject(Object key, Object val);\r\n+\r\n+    /**\r\n+     * Get the value for the specified key from the map of user objects.\r\n+     */\r\n+    public Object getUserObject(Object key);\r\n+    //////////\r\n+    // Events\r\n+    //////////\r\n+\r\n+    /**\r\n+     * Register a listener for transaction-related events.\r\n+     */\r\n+    public void addTransactionListener(Object listener);\r\n+\r\n+    /**\r\n+     * Remove a listener for transaction-related events.\r\n+     */\r\n+    public void removeTransactionListener(Object listener);\r\n+\r\n+    /**\r\n+     * Register a listener for lifecycle-related events on the specified\r\n+     * classes. If the classes are null, all events will be propagated to\r\n+     * the listener.\r\n+     */\r\n+    public void addLifecycleListener(Object listener, Class... classes);\r\n+\r\n+    /**\r\n+     * Remove a listener for lifecycle-related events.\r\n+     */\r\n+    public void removeLifecycleListener(Object listener);\r\n+    ///////////\r\n+    // Lookups\r\n+    ///////////\r\n+\r\n+    /**\r\n+     * Return the objects with the given oids.\r\n+     *\r\n+     * @param oids the oids of the objects to return\r\n+     * @return the objects that were looked up, in the\r\n+     *         same order as the oids parameter.\r\n+     * @see #find(Class,Object)\r\n+     */\r\n+    public <T> T[] findAll(Class<T> cls, Object... oids);\r\n+\r\n+    /**\r\n+     * Return the objects with the given oids.\r\n+     *\r\n+     * @param oids the oids of the objects to return\r\n+     * @return the objects that were looked up, in the\r\n+     *         same order as the oids parameter.\r\n+     * @see #find(Class,Object)\r\n+     */\r\n+    public <T> Collection<T> findAll(Class<T> cls, Collection oids);\r\n+\r\n+    /**\r\n+     * Return the cached instance for the given oid/object, or null if not\r\n+     * cached.\r\n+     *\r\n+     * @param oid the object's id\r\n+     * @return the cached object, or null if not cached\r\n+     */\r\n+    public <T> T findCached(Class<T> cls, Object oid);\r\n+\r\n+    /**\r\n+     * Return the application identity class the given persistent class uses\r\n+     * for object ids, or null if not a type that uses application identity.\r\n+     */\r\n+    public Class getObjectIdClass(Class pcClass);\r\n+    ////////////////\r\n+    // Transactions\r\n+    ////////////////\r\n+\r\n+    /**\r\n+     * Issue a commit and then start a new transaction. This is identical to:\r\n+     * <pre> manager.commit(); manager.begin();\r\n+     * </pre> except that the entity manager's internal atomic lock is utilized,\r\n+     * so this method can be safely executed from multiple threads.\r\n+     *\r\n+     * @see #commit()\r\n+     * @see #begin()\r\n+     */\r\n+    public void commitAndResume();\r\n+\r\n+    /**\r\n+     * Issue a rollback and then start a new transaction. This is identical to:\r\n+     * <pre> manager.rollback(); manager.begin();\r\n+     * </pre> except that the entity manager's internal atomic lock is utilized,\r\n+     * so this method can be safely executed from multiple threads.\r\n+     *\r\n+     * @see #rollback()\r\n+     * @see #begin()\r\n+     */\r\n+    public void rollbackAndResume();\r\n+\r\n+    /**\r\n+     * Mark the current transaction for rollback.\r\n+     */\r\n+    public void setRollbackOnly();\r\n+\r\n+    /**\r\n+     * Return whether the current transaction has been marked for rollback.\r\n+     */\r\n+    public boolean getRollbackOnly();\r\n+\r\n+    /**\r\n+     * Set a transactional savepoint where operations after this savepoint\r\n+     * will be rolled back.\r\n+     */\r\n+    public void setSavepoint(String name);\r\n+\r\n+    /**\r\n+     * Rollback the current transaction to the last savepoint.\r\n+     * Savepoints set after this one will become invalid.\r\n+     */\r\n+    public void rollbackToSavepoint();\r\n+\r\n+    /**\r\n+     * Rollback the current transaction to the given savepoint name.\r\n+     * Savepoints set after this one will become invalid.\r\n+     */\r\n+    public void rollbackToSavepoint(String name);\r\n+\r\n+    /**\r\n+     * Release the last set savepoint and any resources associated with it.\r\n+     * The given savepoint and any set after it will become invalid.\r\n+     */\r\n+    public void releaseSavepoint();\r\n+\r\n+    /**\r\n+     * Release the savepoint and any resources associated with it.\r\n+     * The given savepoint and any set after it will become invalid.\r\n+     */\r\n+    public void releaseSavepoint(String name);\r\n+\r\n+    /**\r\n+     * Run pre-flush actions on transactional objects, including\r\n+     * persistence-by-reachability, inverse relationship management,\r\n+     * deletion of dependent instances, and instance callbacks.\r\n+     * Transaction listeners are not invoked.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public void preFlush();\r\n+\r\n+    /**\r\n+     * Validate the changes made in this transaction, reporting any optimistic\r\n+     * violations, constraint violations, etc. In a datastore transaction or\r\n+     * a flushed optimistic transaction, this method will act just like\r\n+     * {@link #flush}. In an optimistic transaction that has not yet begun a\r\n+     * datastore-level transaction, however, it will only report exceptions\r\n+     * that would occur on flush, without retaining any datastore resources.\r\n+     */\r\n+    public void validateChanges();\r\n+\r\n+    /**\r\n+     * Whether a store transaction is active.\r\n+     */\r\n+    public boolean isStoreActive();\r\n+\r\n+    /**\r\n+     * Begins a store transaction if one isn't already started. The\r\n+     * entity manager must already be in a logical transaction.\r\n+     */\r\n+    public void beginStore();\r\n+    ////////////////////\r\n+    // Object Lifecycle\r\n+    ////////////////////\r\n+\r\n+    /**\r\n+     * Whether the given objects are managed.\r\n+     */\r\n+    public boolean containsAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Whether the given objects are managed.\r\n+     */\r\n+    public boolean containsAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Persist the given objects.\r\n+     */\r\n+    public void persistAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Persist the given objects.\r\n+     */\r\n+    public void persistAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Delete the given persistent objects.\r\n+     */\r\n+    public void removeAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Delete the given persistent objects.\r\n+     */\r\n+    public void removeAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Release the given object from management. This operation is not\r\n+     * recursive.\r\n+     */\r\n+    public void release(Object pc);\r\n+\r\n+    /**\r\n+     * Release the given object from management. This operation is not\r\n+     * recursive.\r\n+     */\r\n+    public void releaseAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Release the given objects from management. This operation is not\r\n+     * recursive.\r\n+     */\r\n+    public void releaseAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Immediately load the given object's persistent fields. One might\r\n+     * use this action to make sure that an instance's fields are loaded\r\n+     * before transitioning it to transient. Note that this action is not\r\n+     * recursive. Any related objects that are loaded will not necessarily\r\n+     * have their fields loaded.\r\n+     */\r\n+    public void retrieve(Object pc);\r\n+\r\n+    /**\r\n+     * Retrieve the persistent state of the given objects.\r\n+     *\r\n+     * @see #retrieve\r\n+     */\r\n+    public void retrieveAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Retrieve the persistent state of the given objects.\r\n+     *\r\n+     * @see #retrieve\r\n+     */\r\n+    public void retrieveAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Refresh the state of the given objects.\r\n+     */\r\n+    public void refreshAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Refresh the state of the given objects.\r\n+     */\r\n+    public void refreshAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Refresh all transactional objects.\r\n+     */\r\n+    public void refreshAll();\r\n+\r\n+    /**\r\n+     * Evict the given object.\r\n+     */\r\n+    public void evict(Object pc);\r\n+\r\n+    /**\r\n+     * Evict the given objects.\r\n+     */\r\n+    public void evictAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Evict the given objects.\r\n+     */\r\n+    public void evictAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Evict all clean objects.\r\n+     */\r\n+    public void evictAll();\r\n+\r\n+    /**\r\n+     * Evict all persistent-clean and persistent-nontransactional\r\n+     * instances in the extent of the given class(including subclasses).\r\n+     */\r\n+    public void evictAll(Class cls);\r\n+\r\n+    /**\r\n+     * Evict all persistent-clean and persistent-nontransactional\r\n+     * instances in the given {@link Extent}.\r\n+     */\r\n+    public void evictAll(Extent extent);\r\n+\r\n+    /**\r\n+     * Detach the specified object from the entity manager.\r\n+     *\r\n+     * @param pc the instance to detach\r\n+     * @return the detached instance\r\n+     */\r\n+    public <T> T detach(T pc);\r\n+\r\n+    /**\r\n+     * Detach the specified objects from the entity manager.\r\n+     *\r\n+     * @param pcs the instances to detach\r\n+     * @return the detached instances\r\n+     */\r\n+    public Collection detachAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Detach the specified objects from the entity manager.\r\n+     *\r\n+     * @param pcs the instances to detach\r\n+     * @return the detached instances\r\n+     */\r\n+    public Object[] detachAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Merge the specified objects into the entity manager.\r\n+     *\r\n+     * @param pcs instances to import\r\n+     * @return the re-attached instances\r\n+     */\r\n+    public Object[] mergeAll(Object... pcs);\r\n+\r\n+    /**\r\n+     * Merge the specified detached objects into the entity manager.\r\n+     *\r\n+     * @param pcs Collection of instances to import\r\n+     * @return the re-attached instances\r\n+     */\r\n+    public Collection mergeAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Make the given object transactional.\r\n+     *\r\n+     * @param pc            instance to make transactional\r\n+     * @param updateVersion if true, the instance's version will be\r\n+     *                      incremented at the next flush\r\n+     */\r\n+    public void transactional(Object pc, boolean updateVersion);\r\n+\r\n+    /**\r\n+     * Make the given objects transactional.\r\n+     *\r\n+     * @param objs          instances to make transactional\r\n+     * @param updateVersion if true, the instance's version will be\r\n+     *                      incremented at the next flush\r\n+     */\r\n+    public void transactionalAll(Collection objs, boolean updateVersion);\r\n+\r\n+    /**\r\n+     * Make the given objects transactional.\r\n+     *\r\n+     * @param objs          instances to make transactional\r\n+     * @param updateVersion if true, the instance's version will be\r\n+     *                      incremented at the next flush\r\n+     */\r\n+    public void transactionalAll(Object[] objs, boolean updateVersion);\r\n+\r\n+    /**\r\n+     * Make the given object nontransactional.\r\n+     */\r\n+    public void nontransactional(Object pc);\r\n+\r\n+    /**\r\n+     * Make the given objects nontransactional.\r\n+     */\r\n+    public void nontransactionalAll(Collection objs);\r\n+\r\n+    /**\r\n+     * Make the given objects nontransactional.\r\n+     */\r\n+    public void nontransactionalAll(Object[] objs);\r\n+    ////////////////////////////\r\n+    // Extent, Query, Generator\r\n+    ////////////////////////////\r\n+\r\n+    /**\r\n+     * Return the named generator defined in the metadata.\r\n+     */\r\n+    public Generator getNamedGenerator(String name);\r\n+\r\n+    /**\r\n+     * Returns a {@link Generator} for the datastore identity values of the\r\n+     * specified type, or null if the type is unmanaged or its identity\r\n+     * cannot be represented by a sequence.\r\n+     */\r\n+    public Generator getIdGenerator(Class forClass);\r\n+\r\n+    /**\r\n+     * Returns a {@link Generator} for the generated values of the specified\r\n+     * type, or null if the field is not generated.\r\n+     */\r\n+    public Generator getFieldGenerator(Class forClass, String fieldName);\r\n+\r\n+    /**\r\n+     * Return an extent of the given class, optionally including subclasses.\r\n+     */\r\n+    public <T> Extent<T> createExtent(Class<T> cls, boolean subs);\r\n+\r\n+    public OpenJPAQuery createQuery(String query);\r\n+\r\n+    public OpenJPAQuery createNamedQuery(String name);\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String sql);\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String sql, Class resultClass);\r\n+\r\n+    public OpenJPAQuery createNativeQuery(String sql, String resultMapping);\r\n+\r\n+    /**\r\n+     * Create a new query from the given one.\r\n+     */\r\n+    public OpenJPAQuery createQuery(Query query);\r\n+\r\n+    /**\r\n+     * Create a new query in the given language.\r\n+     */\r\n+    public OpenJPAQuery createQuery(String language, String query);\r\n+    ///////////\r\n+    // Locking\r\n+    ///////////\r\n+\r\n+    /**\r\n+     * Return the lock mode of the given instance, or null if not locked.\r\n+     */\r\n+    public LockModeType getLockMode(Object pc);\r\n+\r\n+    /**\r\n+     * Ensure that the given instance is locked at the given lock level.\r\n+     *\r\n+     * @param pc      the object to lock\r\n+     * @param mode    the lock level to use\r\n+     * @param timeout the number of milliseconds to wait for the lock before\r\n+     *                giving up, or -1 for no limit\r\n+     */\r\n+    public void lock(Object pc, LockModeType mode, int timeout);\r\n+\r\n+    /**\r\n+     * Ensure that the given instance is locked at the current lock level, as\r\n+     * set in the {@link FetchPlan} for the entity manager.\r\n+     */\r\n+    public void lock(Object pc);\r\n+\r\n+    /**\r\n+     * Ensure that the given instances are locked at the given lock level.\r\n+     *\r\n+     * @param pcs     the objects to lock\r\n+     * @param mode    the lock level to use\r\n+     * @param timeout the number of milliseconds to wait for the lock before\r\n+     *                giving up, or -1 for no limit\r\n+     */\r\n+    public void lockAll(Collection pcs, LockModeType mode, int timeout);\r\n+\r\n+    /**\r\n+     * Ensure that the given instances are locked at the current lock level,\r\n+     * as set in the {@link FetchPlan} for the entity manager.\r\n+     */\r\n+    public void lockAll(Collection pcs);\r\n+\r\n+    /**\r\n+     * Ensure that the given instances are locked at the given lock level.\r\n+     *\r\n+     * @param pcs     the objects to lock\r\n+     * @param mode    the lock level to use\r\n+     * @param timeout the number of milliseconds to wait for the lock before\r\n+     *                giving up, or -1 for no limit\r\n+     */\r\n+    public void lockAll(Object[] pcs, LockModeType mode, int timeout);\r\n+\r\n+    /**\r\n+     * Ensure that the given instances are locked at the current lock level,\r\n+     * as set in the {@link FetchPlan} for the entity manager.\r\n+     */\r\n+    public void lockAll(Object... pcs);\r\n+    //////////////\r\n+    // Connection\r\n+    //////////////\r\n+\r\n+    /**\r\n+     * Cancel all pending data store statements. If statements are cancelled\r\n+     * while a flush is in progress, the transaction rollback only flag will\r\n+     * be set.\r\n+     *\r\n+     * @return true if any statements were cancelled, false otherwise\r\n+     */\r\n+    public boolean cancelAll();\r\n+\r\n+    /**\r\n+     * Return the connection in use by the entity manager, or a new\r\n+     * connection if none.\r\n+     */\r\n+    public Object getConnection();\r\n+    /////////\r\n+    // Cache\r\n+    /////////\r\n+\r\n+    /**\r\n+     * Return a set of all managed instances.\r\n+     */\r\n+    public Collection getManagedObjects();\r\n+\r\n+    /**\r\n+     * Return a set of current transaction instances.\r\n+     */\r\n+    public Collection getTransactionalObjects();\r\n+\r\n+    /**\r\n+     * Return a set of instances which will become transactional upon\r\n+     * the next transaction.\r\n+     */\r\n+    public Collection getPendingTransactionalObjects();\r\n+\r\n+    /**\r\n+     * Return a set of current dirty instances.\r\n+     */\r\n+    public Collection getDirtyObjects();\r\n+\r\n+    /**\r\n+     * Whether dirty objects will be returned in the order they were dirtied.\r\n+     * Default is determined by the store manager.\r\n+     */\r\n+    public boolean getOrderDirtyObjects();\r\n+\r\n+    /**\r\n+     * Whether dirty objects will be returned in the order they were dirtied.\r\n+     * Default is determined by the store manager.\r\n+     */\r\n+    public void setOrderDirtyObjects(boolean order);\r\n+\r\n+    /**\r\n+     * Mark the given class as dirty within the current transaction.\r\n+     */\r\n+    public void dirtyClass(Class cls);\r\n+\r\n+    /**\r\n+     * Return the set of classes that have been made persistent in the current\r\n+     * transaction.\r\n+     */\r\n+    public Collection<Class> getPersistedClasses();\r\n+\r\n+    /**\r\n+     * Return the set of classes that have been deleted in the current\r\n+     * transaction.\r\n+     */\r\n+    public Collection<Class> getRemovedClasses();\r\n+\r\n+    /**\r\n+     * Return the set of classes for objects that have been modified\r\n+     * in the current transaction.\r\n+     */\r\n+    public Collection<Class> getUpdatedClasses();\r\n+\r\n+    /**\r\n+     * Create a new instance of type <code>cls</code>. If <code>cls</code> is\r\n+     * an interface or an abstract class whose abstract methods follow the\r\n+     * JavaBeans convention, this method will create a concrete implementation\r\n+     * according to the metadata that defines the class. If <code>cls</code>\r\n+     * is a non-final concrete type that has metadata but does not implement\r\n+     * {@link org.apache.openjpa.enhance.PersistenceCapable}, this method will create a\r\n+     * subclass of the type that does implement\r\n+     * {@link org.apache.openjpa.enhance.PersistenceCapable},\r\n+     * following the property-based persistent attribute access rules, or\r\n+     * will raise an exception if the class does not meet the requirements\r\n+     * for subclassing. Otherwise, this will return an instance of the\r\n+     * specified class.\r\n+     */\r\n+    public <T> T createInstance(Class<T> cls);\r\n+\r\n+    /**\r\n+     * Make the named field of the given object dirty.\r\n+     */\r\n+    public void dirty(Object o, String field);\r\n+\r\n+    /**\r\n+     * Return the oid of the given instance.\r\n+     */\r\n+    public Object getObjectId(Object o);\r\n+\r\n+    /**\r\n+     * Return whether the given object is dirty.\r\n+     */\r\n+    public boolean isDirty(Object o);\r\n+\r\n+    /**\r\n+     * Return whether the given object is transactional.\r\n+     */\r\n+    public boolean isTransactional(Object o);\r\n+\r\n+    /**\r\n+     * Return whether the given object is persistent.\r\n+     */\r\n+    public boolean isPersistent(Object o);\r\n+\r\n+    /**\r\n+     * Return whether the given object was made persistent in the current\r\n+     * transaction.\r\n+     */\r\n+    public boolean isNewlyPersistent(Object o);\r\n+\r\n+    /**\r\n+     * Return whether the given object is deleted.\r\n+     */\r\n+    public boolean isRemoved(Object o);\r\n+\r\n+    /**\r\n+     * Returns <code>true</code> if <code>pc</code> is a detached object\r\n+     * (one that can be reattached to a {@link EntityManager} via a call\r\n+     * to {@link EntityManager#merge}); otherwise returns\r\n+     * <code>false</code>.\r\n+     */\r\n+    public boolean isDetached(Object o);\r\n+\r\n+    /**\r\n+     * Returns the current version indicator for <code>o</code>.\r\n+     */\r\n+    public Object getVersion(Object o);\r\n+}\r"},{"sha":"786e934c60e80b1c45ec29c9bffff2cdae08777f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,102 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import javax.persistence.EntityManagerFactory;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.ConnectionRetainModes;\r\n+import org.apache.openjpa.lib.util.Closeable; // also in java.io\r\n+\r\n+/**\r\n+ * Interface implemented by OpenJPA entity manager factories.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public interface OpenJPAEntityManagerFactory\r\n+    extends EntityManagerFactory, ConnectionRetainModes, Closeable,\r\n+    Serializable {\r\n+\r\n+    /**\r\n+     * Return the configuration for this factory.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration();\r\n+\r\n+    /**\r\n+     * Return properties describing this runtime.\r\n+     */\r\n+    public Properties getProperties();\r\n+\r\n+    /**\r\n+     * Put the specified key-value pair into the map of user objects.\r\n+     */\r\n+    public Object putUserObject(Object key, Object val);\r\n+\r\n+    /**\r\n+     * Get the value for the specified key from the map of user objects.\r\n+     */\r\n+    public Object getUserObject(Object key);\r\n+\r\n+    /**\r\n+     * Access the level 2 store cache. This cache acts as a proxy to all\r\n+     * named caches.\r\n+     */\r\n+    public StoreCache getStoreCache();\r\n+\r\n+    /**\r\n+     * Access a named level 2 store cache.\r\n+     */\r\n+    public StoreCache getStoreCache(String name);\r\n+\r\n+    /**\r\n+     * Access query result cache.\r\n+     */\r\n+    public QueryResultCache getQueryResultCache();\r\n+\r\n+    public OpenJPAEntityManager createEntityManager();\r\n+\r\n+    /**\r\n+     * Return an entity manager with the provided additional configuration\r\n+     * settings. OpenJPA recognizes the following configuration settings in this\r\n+     * method:\r\n+     * <ul>\r\n+     * <li>org.apache.openjpa.ConnectionUsername</li>\r\n+     * <li>org.apache.openjpa.ConnectionPassword</li>\r\n+     * <li>org.apache.openjpa.ConnectionRetainMode</li>\r\n+     * <li>org.apache.openjpa.TransactionMode</li>\r\n+     * </ul>\r\n+     */\r\n+    public OpenJPAEntityManager createEntityManager(Map props);\r\n+\r\n+    /**\r\n+     * Register a listener for lifecycle-related events on the specified\r\n+     * classes. If the classes are null, all events will be propagated to\r\n+     * the listener. The listener will be passed on to all new entity\r\n+     * managers. See the <code>org.apache.openjpa.event</code> package for listener types.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public void addLifecycleListener(Object listener, Class... classes);\r\n+\r\n+    /**\r\n+     * Remove a listener for lifecycle-related events.\r\n+     *\r\n+     * @since 3.3\r\n+     */\r\n+    public void removeLifecycleListener(Object listener);\r\n+}\r"},{"sha":"f6f96454f8752a5b2c12a3ed7daa774126f22f3e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","status":"added","additions":424,"deletions":0,"changes":424,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAPersistence.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,424 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityManagerFactory;\r\n+import javax.persistence.Persistence;\r\n+import javax.persistence.Query;\r\n+import javax.rmi.PortableRemoteObject;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.kernel.Bootstrap;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.ByteId;\r\n+import org.apache.openjpa.util.CharId;\r\n+import org.apache.openjpa.util.Id;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.IntId;\r\n+import org.apache.openjpa.util.LongId;\r\n+import org.apache.openjpa.util.ObjectId;\r\n+import org.apache.openjpa.util.OpenJPAId;\r\n+import org.apache.openjpa.util.ShortId;\r\n+import org.apache.openjpa.util.StringId;\r\n+\r\n+/**\r\n+ * Static helper method for JPA users, including switching\r\n+ * between OpenJPA native and Java Persistence APIs.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public class OpenJPAPersistence extends Persistence {\r\n+\r\n+    public static final String EM_KEY =\r\n+        \"org.apache.openjpa.persistence.EntityManager\";\r\n+    public static final String EMF_KEY =\r\n+        \"org.apache.openjpa.persistence.EntityManagerFactory\";\r\n+\r\n+    private static Localizer _loc =\r\n+        Localizer.forPackage(OpenJPAPersistence.class);\r\n+\r\n+    /**\r\n+     * Return an entity manager factory facade to the given broker factory.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory toEntityManagerFactory\r\n+        (BrokerFactory factory) {\r\n+        if (factory == null)\r\n+            return null;\r\n+        factory.lock();\r\n+        try {\r\n+            OpenJPAEntityManagerFactory emf = (OpenJPAEntityManagerFactory)\r\n+                factory.getUserObject(EMF_KEY);\r\n+            if (emf == null) {\r\n+                emf = new EntityManagerFactoryImpl(factory);\r\n+                factory.putUserObject(EMF_KEY, emf);\r\n+            }\r\n+            return emf;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+        finally {\r\n+            factory.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the underlying broker factory for the given persistence manager\r\n+     * factory facade.\r\n+     */\r\n+    public static BrokerFactory toBrokerFactory(EntityManagerFactory emf) {\r\n+        return (emf == null) ? null\r\n+            : ((EntityManagerFactoryImpl) emf).getBrokerFactory();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a persistence manager facade to the given broker retaining\r\n+     * previously associated persistence context type.\r\n+     */\r\n+    public static OpenJPAEntityManager toEntityManager(Broker broker) {\r\n+        if (broker == null)\r\n+            return null;\r\n+        broker.lock();\r\n+        try {\r\n+            OpenJPAEntityManager em = (OpenJPAEntityManager)\r\n+                broker.getUserObject(EM_KEY);\r\n+            if (em == null) {\r\n+                EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl)\r\n+                    toEntityManagerFactory(broker.getBrokerFactory());\r\n+                em = new EntityManagerImpl(emf, broker);\r\n+                broker.putUserObject(EM_KEY, em);\r\n+            }\r\n+            return em;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+        finally {\r\n+            broker.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the underlying broker for the given entity manager facade.\r\n+     */\r\n+    public static Broker toBroker(EntityManager em) {\r\n+        return (em == null) ? null : ((EntityManagerImpl) em).getBroker();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the OpenJPA facade to the given entity manager factory.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory cast(EntityManagerFactory emf) {\r\n+        return (OpenJPAEntityManagerFactory) emf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the OpenJPA facade to the given entity manager.\r\n+     */\r\n+    public static OpenJPAEntityManager cast(EntityManager em) {\r\n+        return (OpenJPAEntityManager) em;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the OpenJPA facade to the given query.\r\n+     */\r\n+    public static OpenJPAQuery cast(Query q) {\r\n+        return (OpenJPAQuery) q;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link OpenJPAEntityManagerFactory} specified by\r\n+     * your OpenJPA defaults. This method will return the same logical factory\r\n+     * for each invocation.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory getEntityManagerFactory() {\r\n+        return getEntityManagerFactory(null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link OpenJPAEntityManagerFactory} specified by\r\n+     * your OpenJPA defaults, using <code>map</code> as overrides. This method\r\n+     * will return the same logical factory for invocations with the same\r\n+     * overrides.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory getEntityManagerFactory(Map map) {\r\n+        ConfigurationProvider cp = new MapConfigurationProvider(map);\r\n+        try {\r\n+            return toEntityManagerFactory(Bootstrap.getBrokerFactory\r\n+                (cp, null));\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new {@link OpenJPAEntityManagerFactory} specified by\r\n+     * <code>name</code> in an XML configuration file at the resource location\r\n+     * <code>resource</code>. If <code>name</code> is <code>null</code>, uses\r\n+     * the first resource found in the specified location, regardless of the\r\n+     * name specified in the XML resource or the name of the jar that the\r\n+     * resource is contained in. If <code>resource</code> is <code>null</code>,\r\n+     * uses the spec-defined <code>META-INF/persistence.xml</code> resource.\r\n+     * This method only resolves {@link OpenJPAEntityManagerFactory} instances.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory createEntityManagerFactory\r\n+        (String name, String resource) {\r\n+        return createEntityManagerFactory(name, resource, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a new {@link OpenJPAEntityManagerFactory} specified by\r\n+     * <code>name</code> in an XML configuration file at the resource location\r\n+     * <code>resource</code>, applying the properties specified in\r\n+     * <code>map</code> as overrides. If <code>name</code> is\r\n+     * <code>null</code>, uses the first resource found in the specified\r\n+     * location, regardless of the name specified in the XML resource or the\r\n+     * name of the jar that the resource is contained in.\r\n+     * If <code>resource</code> is <code>null</code>, uses the spec-defined\r\n+     * <code>META-INF/persistence.xml</code> resource.\r\n+     * This method only resolves {@link OpenJPAEntityManagerFactory} instances.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory createEntityManagerFactory\r\n+        (String name, String resource, Map map) {\r\n+        return (OpenJPAEntityManagerFactory) new PersistenceProviderImpl().\r\n+            createEntityManagerFactory(name, resource, map);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link EntityManagerFactory} at the JNDI location specified\r\n+     * by <code>jndiLocation</code> in the context <code>context</code>. If\r\n+     * <code>context</code> is <code>null</code>,\r\n+     * <code>new InitialContext()</code> will be used.\r\n+     */\r\n+    public static OpenJPAEntityManagerFactory createEntityManagerFactory\r\n+        (String jndiLocation, Context context) {\r\n+        if (jndiLocation == null)\r\n+            throw new NullPointerException(\"jndiLocation == null\");\r\n+        try {\r\n+            if (context == null)\r\n+                context = new InitialContext();\r\n+            Object o = context.lookup(jndiLocation);\r\n+            return (OpenJPAEntityManagerFactory) PortableRemoteObject.narrow(o,\r\n+                OpenJPAEntityManagerFactory.class);\r\n+        } catch (NamingException ne) {\r\n+            throw new ArgumentException(_loc.get(\"naming-exception\",\r\n+                jndiLocation), new Throwable[]{ ne }, null, true);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the entity manager for the given object, if one can be determined\r\n+     * from just the object alone. This method will succeed for instances that\r\n+     * are enhanced, that were loaded from the database(rather than\r\n+     * being constructed with <code>new</code>), or that were created through\r\n+     * {@link OpenJPAEntityManager#createInstance}.\r\n+     */\r\n+    public static OpenJPAEntityManager getEntityManager(Object o) {\r\n+        try {\r\n+            if (o instanceof PersistenceCapable)\r\n+                return toEntityManager((Broker) ((PersistenceCapable) o).\r\n+                    pcGetGenericContext());\r\n+            else return null;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link ClassMetaData} associated with the\r\n+     * persistent object <code>o</code>.\r\n+     */\r\n+    public static ClassMetaData getMetaData(Object o) {\r\n+        if (o == null)\r\n+            return null;\r\n+        EntityManager em = getEntityManager(o);\r\n+        return (em == null) ? null : getMetaData(em, o.getClass());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link ClassMetaData} associated with the\r\n+     * persistent type <code>cls</code>.\r\n+     */\r\n+    public static ClassMetaData getMetaData(EntityManager em, Class cls) {\r\n+        if (em == null)\r\n+            throw new NullPointerException(\"em == null\");\r\n+        OpenJPAEntityManager kem = cast(em);\r\n+        try {\r\n+            return kem.getConfiguration().getMetaDataRepository().\r\n+                getMetaData(cls, kem.getClassLoader(), false);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the {@link ClassMetaData} associated with the\r\n+     * persistent type <code>cls</code>.\r\n+     */\r\n+    public static ClassMetaData getMetaData(EntityManagerFactory emf,\r\n+        Class cls) {\r\n+        if (emf == null)\r\n+            throw new NullPointerException(\"emf == null\");\r\n+        OpenJPAEntityManagerFactory kemf = cast(emf);\r\n+        try {\r\n+            return kemf.getConfiguration().getMetaDataRepository().\r\n+                getMetaData(cls, null, false);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Close the given resource. The resource can be an extent iterator,\r\n+     * query result, large result set relation, or any closeable OpenJPA\r\n+     * component.\r\n+     */\r\n+    public static void close(Object o) {\r\n+        try {\r\n+            ImplHelper.close(o);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the specified class is an entity or embeddable type.\r\n+     */\r\n+    public static boolean isManagedType(EntityManager em, Class cls) {\r\n+        try {\r\n+            return ImplHelper.isManagedType(cls);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the specified class is an entity or embeddable type.\r\n+     */\r\n+    public static boolean isManagedType(EntityManagerFactory emf, Class cls) {\r\n+        try {\r\n+            return ImplHelper.isManagedType(cls);\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate from a OpenJPA identity object to a Persistence one.\r\n+     */\r\n+    public static Object fromOpenJPAObjectId(Object oid) {\r\n+        if (oid instanceof OpenJPAId)\r\n+            return ((OpenJPAId) oid).getIdObject();\r\n+        return oid;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate from a Persistence identity object to a OpenJPA one.\r\n+     */\r\n+    public static Object toOpenJPAObjectId(ClassMetaData meta, Object oid) {\r\n+        if (oid == null || meta == null)\r\n+            return null;\r\n+        Class cls = meta.getDescribedType();\r\n+        if (meta.getIdentityType() == ClassMetaData.ID_DATASTORE)\r\n+            return new Id(cls, ((Number) oid).longValue());\r\n+        if (oid instanceof Byte)\r\n+            return new ByteId(cls, (Byte) oid);\r\n+        if (oid instanceof Character)\r\n+            return new CharId(cls, (Character) oid);\r\n+        if (oid instanceof Integer)\r\n+            return new IntId(cls, (Integer) oid);\r\n+        if (oid instanceof Long)\r\n+            return new LongId(cls, (Long) oid);\r\n+        if (oid instanceof Short)\r\n+            return new ShortId(cls, (Short) oid);\r\n+        if (oid instanceof String)\r\n+            return new StringId(cls, (String) oid);\r\n+        return new ObjectId(cls, oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return an array of OpenJPA oids for the given native oid array.\r\n+     */\r\n+    public static Object[] toOpenJPAObjectIds(ClassMetaData meta,\r\n+        Object... oids) {\r\n+        if (oids == null || oids.length == 0)\r\n+            return oids;\r\n+        // since the class if fixed for all oids, we can tell if we have to\r\n+        // translate the array based on whether the first oid needs translating\r\n+        Object oid = toOpenJPAObjectId(meta, oids[0]);\r\n+        if (oid == oids[0])\r\n+            return oids;\r\n+        Object[] copy = new Object[oids.length];\r\n+        copy[0] = oid;\r\n+        for (int i = 1; i < oids.length; i++)\r\n+            copy[i] = toOpenJPAObjectId(meta, oids[i]);\r\n+        return copy;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a collection of OpenJPA oids for the given native oid collection.\r\n+     */\r\n+    public static Collection toOpenJPAObjectIds(ClassMetaData meta,\r\n+        Collection oids) {\r\n+        if (oids == null || oids.isEmpty())\r\n+            return oids;\r\n+        // since the class if fixed for all oids, we can tell if we have to\r\n+        // translate the array based on whether the first oid needs translating\r\n+        Iterator itr = oids.iterator();\r\n+        Object orig = itr.next();\r\n+        Object oid = toOpenJPAObjectId(meta, orig);\r\n+        if (oid == orig)\r\n+            return oids;\r\n+        Collection copy = new ArrayList(oids.size());\r\n+        copy.add(oid);\r\n+        while (itr.hasNext())\r\n+            copy.add(toOpenJPAObjectId(meta, itr.next()));\r\n+        return copy;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate from a OpenJPA identity class to a native one.\r\n+     */\r\n+    public static Class fromOpenJPAObjectIdClass(Class oidClass) {\r\n+        if (oidClass == null)\r\n+            return null;\r\n+        if (oidClass == Id.class)\r\n+            return Long.class;\r\n+        if (oidClass == ByteId.class)\r\n+            return Byte.class;\r\n+        if (oidClass == CharId.class)\r\n+            return Character.class;\r\n+        if (oidClass == IntId.class)\r\n+            return Integer.class;\r\n+        if (oidClass == LongId.class)\r\n+            return Long.class;\r\n+        if (oidClass == ShortId.class)\r\n+            return Short.class;\r\n+        if (oidClass == StringId.class)\r\n+            return String.class;\r\n+        return oidClass;\r\n+    }\r\n+}\r"},{"sha":"8965515b463d98e37f00f770ccf7d80606089085","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","status":"added","additions":208,"deletions":0,"changes":208,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuery.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,208 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.Calendar;\r\n+import java.util.Collection;\r\n+import java.util.Date;\r\n+import java.util.Map;\r\n+import javax.persistence.FlushModeType;\r\n+import javax.persistence.Query;\r\n+import javax.persistence.TemporalType;\r\n+\r\n+import org.apache.openjpa.kernel.QueryFlushModes;\r\n+import org.apache.openjpa.kernel.QueryOperations;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+\r\n+/**\r\n+ * Interface implemented by OpenJPA queries.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public interface OpenJPAQuery extends Query, QueryOperations, QueryFlushModes {\r\n+\r\n+    /**\r\n+     * The owning entity manage.\r\n+     */\r\n+    public OpenJPAEntityManager getEntityManager();\r\n+\r\n+    /**\r\n+     * Query language.\r\n+     */\r\n+    public String getLanguage();\r\n+\r\n+    /**\r\n+     * Query operation type.\r\n+     */\r\n+    public int getOperation();\r\n+\r\n+    /**\r\n+     * Fetch plan for controlling the loading of results.\r\n+     */\r\n+    public FetchPlan getFetchPlan();\r\n+\r\n+    /**\r\n+     * Query string.\r\n+     */\r\n+    public String getQueryString();\r\n+\r\n+    /**\r\n+     * Whether to ignore changes in the current transaction.\r\n+     */\r\n+    public boolean getIgnoreChanges();\r\n+\r\n+    /**\r\n+     * Whether to ignore changes in the current transaction.\r\n+     */\r\n+    public OpenJPAQuery setIgnoreChanges(boolean ignore);\r\n+\r\n+    /**\r\n+     * Register a filter listener for the query.\r\n+     */\r\n+    public OpenJPAQuery addFilterListener(FilterListener listener);\r\n+\r\n+    /**\r\n+     * Remove a filter listener from the query.\r\n+     */\r\n+    public OpenJPAQuery removeFilterListener(FilterListener listener);\r\n+\r\n+    /**\r\n+     * Register an aggregate listener for the query.\r\n+     */\r\n+    public OpenJPAQuery addAggregateListener(AggregateListener listener);\r\n+\r\n+    /**\r\n+     * Remove an aggregate listener from the query.\r\n+     */\r\n+    public OpenJPAQuery removeAggregateListener(AggregateListener listener);\r\n+\r\n+    /**\r\n+     * Return the candidate collection, or <code>null</code> if an\r\n+     * extent was specified instead of a collection.\r\n+     */\r\n+    public Collection getCandidateCollection();\r\n+\r\n+    /**\r\n+     * Set a collection of candidates.\r\n+     */\r\n+    public OpenJPAQuery setCandidateCollection(Collection coll);\r\n+\r\n+    /**\r\n+     * Query result element type.\r\n+     */\r\n+    public Class getResultClass();\r\n+\r\n+    /**\r\n+     * Query result element type.\r\n+     */\r\n+    public OpenJPAQuery setResultClass(Class type);\r\n+\r\n+    /**\r\n+     * Whether subclasses are included in the query results.\r\n+     */\r\n+    public boolean hasSubclasses();\r\n+\r\n+    /**\r\n+     * Whether subclasses are included in the query results.\r\n+     */\r\n+    public OpenJPAQuery setSubclasses(boolean subs);\r\n+\r\n+    /**\r\n+     * Return the 0-based start index for the returned results.\r\n+     */\r\n+    public int getFirstResult();\r\n+\r\n+    /**\r\n+     * Return the maximum number of results to retrieve.\r\n+     * or {@link Integer#MAX_VALUE} for no limit.\r\n+     */\r\n+    public int getMaxResults();\r\n+\r\n+    /**\r\n+     * Compile the query.\r\n+     */\r\n+    public OpenJPAQuery compile();\r\n+\r\n+    /**\r\n+     * Whether this query has positional parameters.\r\n+     */\r\n+    public boolean hasPositionalParameters();\r\n+\r\n+    /**\r\n+     * The positional parameters for the query; empty array if none or\r\n+     * if query uses named parameters.\r\n+     */\r\n+    public Object[] getPositionalParameters();\r\n+\r\n+    /**\r\n+     * The named parameters for the query; empty map if none or\r\n+     * if query uses named parameters.\r\n+     */\r\n+    public Map getNamedParameters();\r\n+\r\n+    /**\r\n+     * Set parameters.\r\n+     */\r\n+    public OpenJPAQuery setParameters(Map params);\r\n+\r\n+    /**\r\n+     * Set parameters.\r\n+     */\r\n+    public OpenJPAQuery setParameters(Object... params);\r\n+\r\n+    /**\r\n+     * Close all open query results.\r\n+     */\r\n+    public OpenJPAQuery closeAll();\r\n+\r\n+    /**\r\n+     * Returns a description of the commands that will be sent to\r\n+     * the datastore in order to execute this query. This will\r\n+     * typically be in the native query language of the database (e.g., SQL).\r\n+     *\r\n+     * @param params the named parameter map for the query invocation\r\n+     */\r\n+    public String[] getDataStoreActions(Map params);\r\n+\r\n+    public OpenJPAQuery setMaxResults(int maxResult);\r\n+\r\n+    public OpenJPAQuery setFirstResult(int startPosition);\r\n+\r\n+    public OpenJPAQuery setHint(String hintName, Object value);\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Object value);\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Date value,\r\n+        TemporalType temporalType);\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Calendar value,\r\n+        TemporalType temporalType);\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Object value);\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Date value,\r\n+        TemporalType temporalType);\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Calendar value,\r\n+        TemporalType temporalType);\r\n+\r\n+    public OpenJPAQuery setFlushMode(FlushModeType flushMode);\r\n+\r\n+    /**\r\n+     * Return the current flush mode.\r\n+     */\r\n+    public FlushModeType getFlushMode();\r\n+}\r"},{"sha":"54b79d2fc9541e515600621398b0ff68a48b9553","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OptimisticLockException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,104 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.StoreException;\r\n+\r\n+/**\r\n+ * Optimistic concurrency violation.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class OptimisticLockException\r\n+    extends javax.persistence.OptimisticLockException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public OptimisticLockException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return STORE;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return StoreException.OPTIMISTIC;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"03343bc589782170291880a77c0375e05cdf465e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,103 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+\r\n+/**\r\n+ * General persistence exception.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class PersistenceException\r\n+    extends javax.persistence.PersistenceException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public PersistenceException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return GENERAL;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return 0;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"6ce960f442f69f354f32456ffe18c95dfbf2b337","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","status":"added","additions":235,"deletions":0,"changes":235,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceExceptions.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,235 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.InvocationTargetException;\r\n+\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.RuntimeExceptionTranslator;\r\n+import org.apache.openjpa.util.StoreException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Converts from OpenJPA to persistence exception types.\r\n+ *\r\n+ * @author Abe White\r\n+ * @author Marc Prud'hommeaux\r\n+ * @nojavadoc\r\n+ */\r\n+public class PersistenceExceptions extends Exceptions {\r\n+\r\n+    public static final RuntimeExceptionTranslator TRANSLATOR =\r\n+        new RuntimeExceptionTranslator() {\r\n+            public RuntimeException translate(RuntimeException re) {\r\n+                return PersistenceExceptions.toPersistenceException(re);\r\n+            }\r\n+        };\r\n+\r\n+    /**\r\n+     * Returns a {@link RuntimeExceptionTranslator} that will perform\r\n+     * the correct exception translation as well as roll back the\r\n+     * current transaction when for all but {@link NoResultException}\r\n+     * and {@link NonUniqueResultException} in accordance with\r\n+     * section 3.7 of the EJB 3.0 specification.\r\n+     */\r\n+    static RuntimeExceptionTranslator getRollbackTranslator\r\n+        (final OpenJPAEntityManager em) {\r\n+        return new RuntimeExceptionTranslator() {\r\n+            private boolean throwing = false;\r\n+\r\n+            public RuntimeException translate(RuntimeException re) {\r\n+                RuntimeException ex = toPersistenceException(re);\r\n+                if (!(ex instanceof NonUniqueResultException)\r\n+                    && !(ex instanceof NoResultException)\r\n+                    && !throwing) {\r\n+                    try {\r\n+                        throwing = true;\r\n+                        if (em.isOpen() && em.isActive())\r\n+                            em.setRollbackOnly();\r\n+                    }\r\n+                    finally {\r\n+                        // handle re-entrancy\r\n+                        throwing = false;\r\n+                    }\r\n+                }\r\n+                return ex;\r\n+            }\r\n+        };\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert the given throwable to the proper persistence exception.\r\n+     */\r\n+    public static RuntimeException toPersistenceException(Throwable t) {\r\n+        return (RuntimeException) translateException(t, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the given exception.\r\n+     *\r\n+     * @param checked whether to translate checked exceptions\r\n+     */\r\n+    private static Throwable translateException(Throwable t, boolean checked) {\r\n+        if (isPersistenceException(t))\r\n+            return t;\r\n+        // immediately throw errors\r\n+        if (t instanceof Error)\r\n+            throw(Error) t;\r\n+        OpenJPAException ke;\r\n+        if (!(t instanceof OpenJPAException)) {\r\n+            if (!checked || t instanceof RuntimeException)\r\n+                return t;\r\n+            ke = new org.apache.openjpa.util.GeneralException(t.getMessage());\r\n+            ke.setStackTrace(t.getStackTrace());\r\n+            return ke;\r\n+        }\r\n+        // if only nested exception is a persistence one, return it directly\r\n+        ke = (OpenJPAException) t;\r\n+        if (ke.getNestedThrowables().length == 1\r\n+            && isPersistenceException(ke.getCause()))\r\n+            return ke.getCause();\r\n+        // RuntimeExceptions thrown from callbacks should be thrown directly\r\n+        if (ke.getType() == OpenJPAException.USER\r\n+            && ke.getSubtype() == UserException.CALLBACK\r\n+            && ke.getNestedThrowables().length == 1) {\r\n+            Throwable e = ke.getCause();\r\n+            if (e instanceof InvocationTargetException)\r\n+                e = e.getCause();\r\n+            if (e instanceof RuntimeException)\r\n+                return e;\r\n+        }\r\n+        // perform intelligent translation of openjpa exceptions\r\n+        switch (ke.getType()) {\r\n+            case OpenJPAException.STORE:\r\n+                return translateStoreException(ke);\r\n+            case OpenJPAException.USER:\r\n+                return translateUserException(ke);\r\n+            default:\r\n+                return translateGeneralException(ke);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the given store exception.\r\n+     */\r\n+    private static Throwable translateStoreException(OpenJPAException ke) {\r\n+        Exception e;\r\n+        switch (ke.getSubtype()) {\r\n+            case StoreException.OBJECT_NOT_FOUND:\r\n+                e = new org.apache.openjpa.persistence.EntityNotFoundException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+                break;\r\n+            case StoreException.OPTIMISTIC:\r\n+                e = new org.apache.openjpa.persistence.OptimisticLockException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+                break;\r\n+            case StoreException.OBJECT_EXISTS:\r\n+                e = new org.apache.openjpa.persistence.EntityExistsException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+                break;\r\n+            default:\r\n+                e = new org.apache.openjpa.persistence.PersistenceException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+        }\r\n+        e.setStackTrace(ke.getStackTrace());\r\n+        return e;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the given user exception.\r\n+     */\r\n+    private static Exception translateUserException(OpenJPAException ke) {\r\n+        Exception e;\r\n+        switch (ke.getSubtype()) {\r\n+            case UserException.NO_TRANSACTION:\r\n+                e =\r\n+                    new org.apache.openjpa.persistence.TransactionRequiredException\r\n+                        (ke.getMessage(), getNestedThrowables(ke),\r\n+                            getFailedObject(ke), ke.isFatal());\r\n+                break;\r\n+            case UserException.INVALID_STATE:\r\n+                e = new org.apache.openjpa.persistence.InvalidStateException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+                break;\r\n+            default:\r\n+                e = new org.apache.openjpa.persistence.ArgumentException\r\n+                    (ke.getMessage(), getNestedThrowables(ke),\r\n+                        getFailedObject(ke), ke.isFatal());\r\n+        }\r\n+        e.setStackTrace(ke.getStackTrace());\r\n+        return e;\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the given general exception.\r\n+     */\r\n+    private static Throwable translateGeneralException(OpenJPAException ke) {\r\n+        Exception e = new org.apache.openjpa.persistence.PersistenceException\r\n+            (ke.getMessage(), getNestedThrowables(ke),\r\n+                getFailedObject(ke), ke.isFatal());\r\n+        e.setStackTrace(ke.getStackTrace());\r\n+        return e;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if the given exception is a persistence exception.\r\n+     */\r\n+    private static boolean isPersistenceException(Throwable t) {\r\n+        return t.getClass().getName()\r\n+            .startsWith(\"org.apache.openjpa.persistence.\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Translate the nested throwables of the given openjpa exception into\r\n+     * nested throwables for a persistence exception.\r\n+     */\r\n+    private static Throwable[] getNestedThrowables(OpenJPAException ke) {\r\n+        Throwable[] nested = ke.getNestedThrowables();\r\n+        if (nested.length == 0)\r\n+            return nested;\r\n+        Throwable[] trans = new Throwable[nested.length];\r\n+        for (int i = 0; i < nested.length; i++)\r\n+            trans[i] = translateException(nested[i], false);\r\n+        return trans;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the failed object for the given exception, performing any\r\n+     * necessary conversions.\r\n+     */\r\n+    private static Object getFailedObject(OpenJPAException ke) {\r\n+        Object o = ke.getFailedObject();\r\n+        if (o == null)\r\n+            return null;\r\n+        if (o instanceof Broker)\r\n+            return OpenJPAPersistence.toEntityManager((Broker) o);\r\n+        return OpenJPAPersistence.fromOpenJPAObjectId(o);\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method to extract a nested exception from an internal nested\r\n+     * array in a safe way.\r\n+     */\r\n+    static Throwable getCause(Throwable[] nested) {\r\n+        if (nested == null || nested.length == 0)\r\n+            return null;\r\n+        return nested[0];\r\n+    }\r\n+}\r"},{"sha":"17f429ee001f53f8b2ff3da44354e6411dd33d89","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceListenerAdapter.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,104 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.openjpa.event.DeleteListener;\r\n+import org.apache.openjpa.event.LifecycleCallbacks;\r\n+import org.apache.openjpa.event.LifecycleEvent;\r\n+import org.apache.openjpa.event.LifecycleEventManager;\r\n+import org.apache.openjpa.event.LoadListener;\r\n+import org.apache.openjpa.event.PersistListener;\r\n+import org.apache.openjpa.event.StoreListener;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.CallbackException;\r\n+\r\n+class PersistenceListenerAdapter\r\n+    implements LifecycleEventManager.ListenerAdapter, PersistListener,\r\n+    LoadListener, StoreListener, DeleteListener {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (PersistenceListenerAdapter.class);\r\n+    private final LifecycleCallbacks[][] _callbacks;\r\n+\r\n+    public PersistenceListenerAdapter(LifecycleCallbacks[][] callbacks) {\r\n+        _callbacks = callbacks;\r\n+    }\r\n+\r\n+    public PersistenceListenerAdapter(Collection<LifecycleCallbacks>[] calls) {\r\n+        _callbacks = new LifecycleCallbacks[LifecycleEvent.ALL_EVENTS.length][];\r\n+        for (int i = 0; i < LifecycleEvent.ALL_EVENTS.length; i++) {\r\n+            if (calls[i] == null)\r\n+                continue;\r\n+            _callbacks[i] = calls[i].toArray\r\n+                (new LifecycleCallbacks[calls[i].size()]);\r\n+        }\r\n+    }\r\n+\r\n+    public boolean respondsTo(int eventType) {\r\n+        return _callbacks[eventType] != null;\r\n+    }\r\n+\r\n+    private void makeCallback(LifecycleEvent ev) {\r\n+        int eventType = ev.getType();\r\n+        if (_callbacks[eventType] == null)\r\n+            return;\r\n+        Object src = ev.getSource();\r\n+        for (LifecycleCallbacks callback : _callbacks[eventType]) {\r\n+            try {\r\n+                callback.makeCallback(src, ev.getRelated(), eventType);\r\n+            } catch (Throwable t) {\r\n+                if (t instanceof InvocationTargetException)\r\n+                    t = t.getCause();\r\n+                if (t instanceof RuntimeException)\r\n+                    throw(RuntimeException) t;\r\n+                throw new CallbackException(_loc.get(\"system-listener-err\",\r\n+                    src)).setCause(t).setFatal(true);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void beforePersist(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void afterPersist(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void afterLoad(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void afterRefresh(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void beforeStore(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void afterStore(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void beforeDelete(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+\r\n+    public void afterDelete(LifecycleEvent event) {\r\n+        makeCallback(event);\r\n+    }\r\n+}\r"},{"sha":"ba186b10f4ad94956924839d1ed670db5d30932a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","status":"added","additions":240,"deletions":0,"changes":240,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,240 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.Serializable;\r\n+import java.lang.annotation.Annotation;\r\n+import java.lang.reflect.AnnotatedElement;\r\n+import java.lang.reflect.Field;\r\n+import java.lang.reflect.Member;\r\n+import java.lang.reflect.Method;\r\n+import java.lang.reflect.Modifier;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import javax.persistence.Basic;\r\n+import javax.persistence.Embeddable;\r\n+import javax.persistence.Embedded;\r\n+import javax.persistence.EmbeddedId;\r\n+import javax.persistence.ManyToMany;\r\n+import javax.persistence.ManyToOne;\r\n+import javax.persistence.OneToMany;\r\n+import javax.persistence.OneToOne;\r\n+import javax.persistence.PostLoad;\r\n+import javax.persistence.PostPersist;\r\n+import javax.persistence.PostRemove;\r\n+import javax.persistence.PostUpdate;\r\n+import javax.persistence.PrePersist;\r\n+import javax.persistence.PreRemove;\r\n+import javax.persistence.PreUpdate;\r\n+import javax.persistence.Transient;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.AbstractMetaDataDefaults;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import static org.apache.openjpa.persistence.PersistenceStrategy.*;\r\n+import org.apache.openjpa.util.MetaDataException;\r\n+\r\n+/**\r\n+ * Javax persistence-based metadata defaults.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+class PersistenceMetaDataDefaults extends AbstractMetaDataDefaults {\r\n+\r\n+    private static Localizer _loc = Localizer.forPackage\r\n+        (PersistenceMetaDataDefaults.class);\r\n+    private static final Map<Class, PersistenceStrategy> _strats =\r\n+        new HashMap<Class, PersistenceStrategy>();\r\n+    private static final Set<String> _ignoredAnnos = new HashSet<String>();\r\n+\r\n+    static {\r\n+        _strats.put(Basic.class, BASIC);\r\n+        _strats.put(ManyToOne.class, MANY_ONE);\r\n+        _strats.put(OneToOne.class, ONE_ONE);\r\n+        _strats.put(Embedded.class, EMBEDDED);\r\n+        _strats.put(EmbeddedId.class, EMBEDDED);\r\n+        _strats.put(OneToMany.class, ONE_MANY);\r\n+        _strats.put(ManyToMany.class, MANY_MANY);\r\n+        _strats.put(Persistent.class, PERS);\r\n+        _strats.put(PersistentCollection.class, PERS_COLL);\r\n+        _strats.put(PersistentMap.class, PERS_MAP);\r\n+        _ignoredAnnos.add(DetachedState.class.getName());\r\n+        _ignoredAnnos.add(PostLoad.class.getName());\r\n+        _ignoredAnnos.add(PostPersist.class.getName());\r\n+        _ignoredAnnos.add(PostRemove.class.getName());\r\n+        _ignoredAnnos.add(PostUpdate.class.getName());\r\n+        _ignoredAnnos.add(PrePersist.class.getName());\r\n+        _ignoredAnnos.add(PreRemove.class.getName());\r\n+        _ignoredAnnos.add(PreUpdate.class.getName());\r\n+    }\r\n+\r\n+    public PersistenceMetaDataDefaults() {\r\n+        setCallbackMode(CALLBACK_RETHROW | CALLBACK_ROLLBACK |\r\n+            CALLBACK_FAIL_FAST);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the code for the strategy of the given member. Return null if\r\n+     * no strategy.\r\n+     */\r\n+    public static PersistenceStrategy getPersistenceStrategy\r\n+        (FieldMetaData fmd, Member member) {\r\n+        if (member == null)\r\n+            return null;\r\n+        AnnotatedElement el = (AnnotatedElement) member;\r\n+        if (el.isAnnotationPresent(Transient.class))\r\n+            return TRANSIENT;\r\n+        if (fmd != null\r\n+            && fmd.getManagement() != FieldMetaData.MANAGE_PERSISTENT)\r\n+            return null;\r\n+        // look for persistence strategy in annotation table\r\n+        PersistenceStrategy pstrat = null;\r\n+        for (Annotation anno : el.getDeclaredAnnotations()) {\r\n+            if (pstrat != null && _strats.containsKey(anno.annotationType()))\r\n+                throw new MetaDataException(_loc.get(\"already-pers\", member));\r\n+            if (pstrat == null)\r\n+                pstrat = _strats.get(anno.annotationType());\r\n+        }\r\n+        if (pstrat != null)\r\n+            return pstrat;\r\n+        Class type;\r\n+        int code;\r\n+        if (fmd != null) {\r\n+            type = fmd.getType();\r\n+            code = fmd.getTypeCode();\r\n+        } else if (member instanceof Field) {\r\n+            type = ((Field) member).getType();\r\n+            code = JavaTypes.getTypeCode(type);\r\n+        } else {\r\n+            type = ((Method) member).getReturnType();\r\n+            code = JavaTypes.getTypeCode(type);\r\n+        }\r\n+        switch (code) {\r\n+            case JavaTypes.ARRAY:\r\n+                if (type == byte[].class || type == char[].class\r\n+                    || type == Byte[].class || type == Character[].class)\r\n+                    return BASIC;\r\n+                break;\r\n+            case JavaTypes.BOOLEAN:\r\n+            case JavaTypes.BOOLEAN_OBJ:\r\n+            case JavaTypes.BYTE:\r\n+            case JavaTypes.BYTE_OBJ:\r\n+            case JavaTypes.CHAR:\r\n+            case JavaTypes.CHAR_OBJ:\r\n+            case JavaTypes.DOUBLE:\r\n+            case JavaTypes.DOUBLE_OBJ:\r\n+            case JavaTypes.FLOAT:\r\n+            case JavaTypes.FLOAT_OBJ:\r\n+            case JavaTypes.INT:\r\n+            case JavaTypes.INT_OBJ:\r\n+            case JavaTypes.LONG:\r\n+            case JavaTypes.LONG_OBJ:\r\n+            case JavaTypes.SHORT:\r\n+            case JavaTypes.SHORT_OBJ:\r\n+            case JavaTypes.STRING:\r\n+            case JavaTypes.BIGDECIMAL:\r\n+            case JavaTypes.BIGINTEGER:\r\n+            case JavaTypes.DATE:\r\n+                return BASIC;\r\n+            case JavaTypes.OBJECT:\r\n+                if (Enum.class.isAssignableFrom(type))\r\n+                    return BASIC;\r\n+                break;\r\n+        }\r\n+        //### EJB3: what if defined in XML?\r\n+        if (type.isAnnotationPresent(Embeddable.class))\r\n+            return EMBEDDED;\r\n+        if (Serializable.class.isAssignableFrom(type))\r\n+            return BASIC;\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void populate(ClassMetaData meta, int access) {\r\n+        super.populate(meta, access);\r\n+        meta.setDetachable(true);\r\n+        // do not call get*Fields as it will lock down the fields.\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void populate(FieldMetaData fmd) {\r\n+        setCascadeNone(fmd);\r\n+        setCascadeNone(fmd.getKey());\r\n+        setCascadeNone(fmd.getElement());\r\n+    }\r\n+\r\n+    /**\r\n+     * Turns off auto cascading of persist, refresh, attach.\r\n+     */\r\n+    static void setCascadeNone(ValueMetaData vmd) {\r\n+        vmd.setCascadePersist(ValueMetaData.CASCADE_NONE);\r\n+        vmd.setCascadeRefresh(ValueMetaData.CASCADE_NONE);\r\n+        vmd.setCascadeAttach(ValueMetaData.CASCADE_NONE);\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int getAccessType(ClassMetaData meta) {\r\n+        return getAccessType(meta.getDescribedType());\r\n+    }\r\n+\r\n+    /**\r\n+     * Recursive helper to determine access type based on annotation placement.\r\n+     */\r\n+    private int getAccessType(Class cls) {\r\n+        // traversed entire hierarchy without finding annotations\r\n+        if (cls == null || cls == Object.class)\r\n+            return ClassMetaData.ACCESS_UNKNOWN;\r\n+        int access = 0;\r\n+        if (usesAccess(cls.getDeclaredFields()))\r\n+            access |= ClassMetaData.ACCESS_FIELD;\r\n+        if (usesAccess(cls.getDeclaredMethods()))\r\n+            access |= ClassMetaData.ACCESS_PROPERTY;\r\n+        return (access == 0) ? getAccessType(cls.getSuperclass()) : access;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether the given members have persistence annotations.\r\n+     */\r\n+    private static boolean usesAccess(AnnotatedElement[] members) {\r\n+        Annotation[] annos;\r\n+        String name;\r\n+        for (int i = 0; i < members.length; i++) {\r\n+            annos = members[i].getAnnotations();\r\n+            for (int j = 0; j < annos.length; j++) {\r\n+                name = annos[j].annotationType().getName();\r\n+                if ((name.startsWith(\"javax.persistence.\")\r\n+                    || name.startsWith(\"org.apache.openjpa.persistence.\"))\r\n+                    && !_ignoredAnnos.contains(name))\r\n+                    return true;\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    protected boolean isDefaultPersistent(ClassMetaData meta, Member member,\r\n+        String name) {\r\n+        int mods = member.getModifiers();\r\n+        if (Modifier.isTransient(mods))\r\n+            return false;\r\n+        PersistenceStrategy strat = getPersistenceStrategy(null, member);\r\n+        if (strat == null || strat == PersistenceStrategy.TRANSIENT)\r\n+            return false;\r\n+        return true;\r\n+    }\r\n+}\r"},{"sha":"091b644d86797ad3600e111e355694f09f8c7031","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","status":"added","additions":383,"deletions":0,"changes":383,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataFactory.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,383 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.net.URL;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import javax.persistence.Embeddable;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.MappedSuperclass;\r\n+import javax.persistence.NamedQueries;\r\n+import javax.persistence.NamedQuery;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.meta.ClassAnnotationMetaDataFilter;\r\n+import org.apache.openjpa.lib.meta.ClassArgParser;\r\n+import org.apache.openjpa.lib.meta.MetaDataFilter;\r\n+import org.apache.openjpa.lib.meta.MetaDataParser;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.AbstractCFMetaDataFactory;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.MetaDataDefaults;\r\n+import org.apache.openjpa.meta.MetaDataFactory;\r\n+import org.apache.openjpa.meta.QueryMetaData;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.MetaDataException;\r\n+\r\n+/**\r\n+ * {@link MetaDataFactory} for JPA metadata.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @since 4.0\r\n+ */\r\n+public class PersistenceMetaDataFactory extends AbstractCFMetaDataFactory\r\n+    implements Configurable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (PersistenceMetaDataFactory.class);\r\n+    private AnnotationPersistenceMetaDataParser _annoParser = null;\r\n+    private XMLPersistenceMetaDataParser _xmlParser = null;\r\n+    private PersistenceMetaDataDefaults _def = null;\r\n+    private Map<URL, Set> _xml = null; // xml rsrc -> class names\r\n+    private Set<URL> _unparsed = null; // xml rsrc\r\n+    private boolean _fieldOverride = true;\r\n+    private int _access = ClassMetaData.ACCESS_FIELD;\r\n+\r\n+    /**\r\n+     * Whether to use field-level override or class-level override.\r\n+     * Defaults to true.\r\n+     */\r\n+    public void setFieldOverride(boolean field) {\r\n+        _fieldOverride = field;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to use field-level override or class-level override.\r\n+     * Defaults to true.\r\n+     */\r\n+    public boolean getFieldOverride() {\r\n+        return _fieldOverride;\r\n+    }\r\n+\r\n+    /**\r\n+     * The default access type for base classes with ACCESS_UNKNOWN\r\n+     */\r\n+    public void setDefaultAccessType(String type) {\r\n+        if (type == null)\r\n+            return;\r\n+        if (\"PROPERTY\".equals(type.toUpperCase()))\r\n+            _access = ClassMetaData.ACCESS_PROPERTY;\r\n+        else _access = ClassMetaData.ACCESS_FIELD;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return metadata parser, creating it if it does not already exist.\r\n+     */\r\n+    public AnnotationPersistenceMetaDataParser getAnnotationParser() {\r\n+        if (_annoParser == null) {\r\n+            _annoParser = newAnnotationParser();\r\n+            _annoParser.setRepository(repos);\r\n+        }\r\n+        return _annoParser;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the metadata parser.\r\n+     */\r\n+    public void setAnnotationParser(\r\n+        AnnotationPersistenceMetaDataParser parser) {\r\n+        if (_annoParser != null)\r\n+            _annoParser.setRepository(null);\r\n+        if (parser != null)\r\n+            parser.setRepository(repos);\r\n+        _annoParser = parser;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new metadata parser.\r\n+     */\r\n+    protected AnnotationPersistenceMetaDataParser newAnnotationParser() {\r\n+        return new AnnotationPersistenceMetaDataParser\r\n+            (repos.getConfiguration());\r\n+    }\r\n+\r\n+    /**\r\n+     * Return XML metadata parser, creating it if it does not already exist.\r\n+     */\r\n+    public XMLPersistenceMetaDataParser getXMLParser() {\r\n+        if (_xmlParser == null) {\r\n+            _xmlParser = newXMLParser(true);\r\n+            _xmlParser.setRepository(repos);\r\n+            if (_fieldOverride)\r\n+                _xmlParser.setAnnotationParser(getAnnotationParser());\r\n+        }\r\n+        return _xmlParser;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the metadata parser.\r\n+     */\r\n+    public void setXMLParser(XMLPersistenceMetaDataParser parser) {\r\n+        if (_xmlParser != null)\r\n+            _xmlParser.setRepository(null);\r\n+        if (parser != null)\r\n+            parser.setRepository(repos);\r\n+        _xmlParser = parser;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new metadata parser.\r\n+     */\r\n+    protected XMLPersistenceMetaDataParser newXMLParser(boolean loading) {\r\n+        return new XMLPersistenceMetaDataParser(repos.getConfiguration());\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new serializer\r\n+     */\r\n+    protected XMLPersistenceMetaDataSerializer newXMLSerializer() {\r\n+        return new XMLPersistenceMetaDataSerializer(repos.getConfiguration());\r\n+    }\r\n+\r\n+    public void load(Class cls, int mode, ClassLoader envLoader) {\r\n+        if (mode == MODE_NONE)\r\n+            return;\r\n+        if (!strict && (mode & MODE_META) != 0)\r\n+            mode |= MODE_MAPPING;\r\n+        // getting the list of persistent types runs callbacks to\r\n+        // mapPersistentTypeNames if it hasn't been called already, which\r\n+        // caches XML resources\r\n+        getPersistentTypeNames(false, envLoader);\r\n+        URL xml = findXML(cls);\r\n+        // we have to parse metadata up-front to register persistence unit\r\n+        // defaults and system callbacks\r\n+        ClassMetaData meta;\r\n+        boolean parsedXML = false;\r\n+        if (_unparsed != null && !_unparsed.isEmpty()\r\n+            && (mode & MODE_META) != 0) {\r\n+            for (URL url : _unparsed)\r\n+                parseXML(url, cls, mode, envLoader);\r\n+            parsedXML = _unparsed.contains(xml);\r\n+            _unparsed.clear();\r\n+            // XML process check\r\n+            meta = repos.getCachedMetaData(cls);\r\n+            if (meta != null && (meta.getSourceMode() & mode) == mode) {\r\n+                validateStrategies(meta);\r\n+                return;\r\n+            }\r\n+        }\r\n+        // might have been looking for system-level query\r\n+        if (cls == null)\r\n+            return;\r\n+        // we may still need to parse XML if this is a redeploy of a class, or\r\n+        // if we're in strict query-only mode\r\n+        if (!parsedXML && xml != null) {\r\n+            parseXML(xml, cls, mode, envLoader);\r\n+            // XML process check\r\n+            meta = repos.getCachedMetaData(cls);\r\n+            if (meta != null && (meta.getSourceMode() & mode) == mode) {\r\n+                validateStrategies(meta);\r\n+                return;\r\n+            }\r\n+        }\r\n+        AnnotationPersistenceMetaDataParser parser = getAnnotationParser();\r\n+        parser.setEnvClassLoader(envLoader);\r\n+        parser.setMode(mode);\r\n+        parser.parse(cls);\r\n+        meta = repos.getCachedMetaData(cls);\r\n+        if (meta != null && (meta.getSourceMode() & mode) == mode)\r\n+            validateStrategies(meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse the given XML resource.\r\n+     */\r\n+    private void parseXML(URL xml, Class cls, int mode, ClassLoader envLoader) {\r\n+        ClassLoader loader = repos.getConfiguration().\r\n+            getClassResolverInstance().getClassLoader(cls, envLoader);\r\n+        XMLPersistenceMetaDataParser xmlParser = getXMLParser();\r\n+        xmlParser.setClassLoader(loader);\r\n+        xmlParser.setEnvClassLoader(envLoader);\r\n+        xmlParser.setMode(mode);\r\n+        try {\r\n+            xmlParser.parse(xml);\r\n+        } catch (IOException ioe) {\r\n+            throw new GeneralException(ioe);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Locate the XML resource for the given class.\r\n+     */\r\n+    private URL findXML(Class cls) {\r\n+        if (_xml != null && cls != null)\r\n+            for (Map.Entry<URL, Set> entry : _xml.entrySet())\r\n+                if (entry.getValue().contains(cls.getName()))\r\n+                    return entry.getKey();\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void mapPersistentTypeNames(Object rsrc, String[] names) {\r\n+        if (!(rsrc instanceof URL) || rsrc.toString().endsWith(\".class\"))\r\n+            return;\r\n+        if (_xml == null)\r\n+            _xml = new HashMap<URL, Set>();\r\n+        _xml.put((URL) rsrc, new HashSet(Arrays.asList(names)));\r\n+        if (_unparsed == null)\r\n+            _unparsed = new HashSet<URL>();\r\n+        _unparsed.add((URL) rsrc);\r\n+    }\r\n+\r\n+    @Override\r\n+    public Class getQueryScope(String queryName, ClassLoader loader) {\r\n+        if (queryName == null)\r\n+            return null;\r\n+        Collection classes = repos.loadPersistentTypes(false, loader);\r\n+        for (Class cls : (Collection<Class>) classes) {\r\n+            if (cls.isAnnotationPresent(NamedQuery.class) && hasNamedQuery\r\n+                (queryName, (NamedQuery) cls.getAnnotation(NamedQuery.class)))\r\n+                return cls;\r\n+            if (cls.isAnnotationPresent(NamedQueries.class) &&\r\n+                hasNamedQuery(queryName, ((NamedQueries) cls.getAnnotation\r\n+                    (NamedQueries.class)).value()))\r\n+                return cls;\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    private boolean hasNamedQuery(String query, NamedQuery... queries) {\r\n+        for (NamedQuery q : queries) {\r\n+            if (query.equals(q.name()))\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected MetaDataFilter newMetaDataFilter() {\r\n+        return new ClassAnnotationMetaDataFilter(new Class[]{\r\n+            Entity.class, Embeddable.class, MappedSuperclass.class });\r\n+    }\r\n+\r\n+    /**\r\n+     * Ensure all fields have declared a strategy.\r\n+     */\r\n+    private void validateStrategies(ClassMetaData meta) {\r\n+        StringBuffer buf = null;\r\n+        for (FieldMetaData fmd : meta.getDeclaredFields()) {\r\n+            if (!fmd.isExplicit()) {\r\n+                if (buf == null)\r\n+                    buf = new StringBuffer();\r\n+                else buf.append(\", \");\r\n+                buf.append(fmd);\r\n+            }\r\n+        }\r\n+        if (buf != null)\r\n+            throw new MetaDataException(_loc.get(\"no-pers-strat\", buf));\r\n+    }\r\n+\r\n+    public MetaDataDefaults getDefaults() {\r\n+        if (_def == null) {\r\n+            _def = new PersistenceMetaDataDefaults();\r\n+            _def.setDefaultAccessType(_access);\r\n+        }\r\n+        return _def;\r\n+    }\r\n+\r\n+    @Override\r\n+    public ClassArgParser newClassArgParser() {\r\n+        ClassArgParser parser = new ClassArgParser();\r\n+        parser.setMetaDataStructure(\"package\", null, new String[]{\r\n+            \"entity\", \"embeddable\", \"mapped-superclass\" }, \"class\");\r\n+        return parser;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void clear() {\r\n+        super.clear();\r\n+        if (_annoParser != null)\r\n+            _annoParser.clear();\r\n+        if (_xmlParser != null)\r\n+            _xmlParser.clear();\r\n+        if (_xml != null)\r\n+            _xml.clear();\r\n+    }\r\n+\r\n+    protected Parser newParser(boolean loading) {\r\n+        return newXMLParser(loading);\r\n+    }\r\n+\r\n+    protected Serializer newSerializer() {\r\n+        return newXMLSerializer();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void parse(MetaDataParser parser, Class[] cls) {\r\n+        parse(parser, Collections.singleton(defaultXMLFile()));\r\n+    }\r\n+\r\n+    protected File defaultSourceFile(ClassMetaData meta) {\r\n+        return defaultXMLFile();\r\n+    }\r\n+\r\n+    protected File defaultSourceFile(QueryMetaData query, Map clsNames) {\r\n+        ClassMetaData meta = getDefiningMetaData(query, clsNames);\r\n+        File file = (meta == null) ? null : meta.getSourceFile();\r\n+        if (file != null)\r\n+            return file;\r\n+        return defaultXMLFile();\r\n+    }\r\n+\r\n+    protected File defaultSourceFile(SequenceMetaData seq, Map clsNames) {\r\n+        return defaultXMLFile();\r\n+    }\r\n+\r\n+    /**\r\n+     * Look for META-INF/orm.xml, and if it doesn't exist, choose a default.\r\n+     */\r\n+    private File defaultXMLFile() {\r\n+        ClassLoader loader = repos.getConfiguration().\r\n+            getClassResolverInstance().getClassLoader(getClass(), null);\r\n+        URL rsrc = loader.getResource(\"META-INF/orm.xml\");\r\n+        if (rsrc != null) {\r\n+            File file = new File(rsrc.getFile());\r\n+            if (file.exists())\r\n+                return file;\r\n+        }\r\n+        return new File(\"orm.xml\");\r\n+    }\r\n+\r\n+    public void setConfiguration(Configuration conf) {\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+        if (rsrcs == null)\r\n+            rsrcs = Collections.singleton(\"META-INF/orm.xml\");\r\n+        else rsrcs.add(\"META-INF/orm.xml\");\r\n+    }\r\n+}\r"},{"sha":"8bb2d3fa2442f483737925b9c446c97eacee4e81","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.conf.ProductDerivation;\r\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n+\r\n+/**\r\n+ * Sets JPA specification defaults.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class PersistenceProductDerivation implements ProductDerivation {\r\n+\r\n+    public static final String SPEC_JPA = \"jpa\";\r\n+    public static final String ALIAS_EJB = \"ejb\";\r\n+\r\n+    public int getType() {\r\n+        return TYPE_SPEC;\r\n+    }\r\n+\r\n+    public void beforeConfigurationConstruct(ConfigurationProvider cp) {\r\n+    }\r\n+\r\n+    public void beforeConfigurationLoad(OpenJPAConfiguration c) {\r\n+        if (!(c instanceof OpenJPAConfigurationImpl))\r\n+            return;\r\n+        OpenJPAConfigurationImpl conf = (OpenJPAConfigurationImpl) c;\r\n+        conf.metaFactoryPlugin.setAlias(SPEC_JPA,\r\n+            PersistenceMetaDataFactory.class.getName());\r\n+        conf.metaFactoryPlugin.setAlias(ALIAS_EJB,\r\n+            PersistenceMetaDataFactory.class.getName());\r\n+    }\r\n+\r\n+    public void afterSpecificationSet(OpenJPAConfiguration c) {\r\n+        if (!(c instanceof OpenJPAConfigurationImpl)\r\n+            || !SPEC_JPA.equals(c.getSpecification()))\r\n+            return;\r\n+        OpenJPAConfigurationImpl conf = (OpenJPAConfigurationImpl) c;\r\n+        conf.metaFactoryPlugin.setDefault(SPEC_JPA);\r\n+        conf.metaFactoryPlugin.setString(SPEC_JPA);\r\n+        conf.lockManagerPlugin.setDefault(\"version\");\r\n+        conf.lockManagerPlugin.setString(\"version\");\r\n+        conf.nontransactionalWrite.setDefault(\"true\");\r\n+        conf.nontransactionalWrite.set(true);\r\n+    }\r\n+\r\n+    public void afterClose(OpenJPAConfiguration c) {\r\n+    }\r\n+}\r"},{"sha":"e6d51b2e9800566cd2b44c2cf724b47fe1b5bde8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,112 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.instrument.ClassFileTransformer;\r\n+import java.lang.instrument.IllegalClassFormatException;\r\n+import java.security.ProtectionDomain;\r\n+import java.util.Map;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityManagerFactory;\r\n+import javax.persistence.Persistence;\r\n+import javax.persistence.spi.ClassTransformer;\r\n+import javax.persistence.spi.PersistenceProvider;\r\n+import javax.persistence.spi.PersistenceUnitInfo;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.enhance.PCClassFileTransformer;\r\n+import org.apache.openjpa.kernel.Bootstrap;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.meta.MetaDataModes;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+\r\n+/**\r\n+ * Bootstrapping class that allows the creation of a stand-alone\r\n+ * {@link EntityManager}.\r\n+ *\r\n+ * @see Persistence#createEntityManagerFactory(String,Map)\r\n+ */\r\n+public class PersistenceProviderImpl implements PersistenceProvider {\r\n+\r\n+    static final String CLASS_TRANSFORMER_OPTIONS =\r\n+        \"org.apache.openjpa.ClassTransformerOptions\";\r\n+\r\n+    /**\r\n+     * Loads the entity manager specified by <code>name</code>, applying\r\n+     * the properties in <code>m</code> as overrides to the properties defined\r\n+     * in the XML configuration file for <code>name</code>. If <code>name</code>\r\n+     * is <code>null</code>, this method loads the XML in the resource\r\n+     * identified by <code>resource</code>, and uses the first resource found\r\n+     * when doing this lookup, regardless of the name specified in the XML\r\n+     * resource or the name of the jar that the resource is contained in.\r\n+     * This does no pooling of EntityManagersFactories.\r\n+     */\r\n+    public EntityManagerFactory createEntityManagerFactory(String name,\r\n+        String resource, Map m) {\r\n+        ConfigurationProviderImpl cp = new ConfigurationProviderImpl();\r\n+        try {\r\n+            if (cp.load(name, resource, m))\r\n+                return OpenJPAPersistence.toEntityManagerFactory(\r\n+                    Bootstrap.newBrokerFactory(cp, cp.getClassLoader()));\r\n+            else return null;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public EntityManagerFactory createEntityManagerFactory(String name, Map m) {\r\n+        return createEntityManagerFactory(name, null, m);\r\n+    }\r\n+\r\n+    public EntityManagerFactory createContainerEntityManagerFactory(\r\n+        PersistenceUnitInfo pui, Map map) {\r\n+        ConfigurationProviderImpl cp = new ConfigurationProviderImpl();\r\n+        try {\r\n+            if (cp.load(pui, map)) {\r\n+                OpenJPAEntityManagerFactory emf =\r\n+                    OpenJPAPersistence.toEntityManagerFactory(\r\n+                        Bootstrap.newBrokerFactory(cp, cp.getClassLoader()));\r\n+                pui.addTransformer(new ClassTransformerImpl(\r\n+                    emf.getConfiguration(), pui.getProperties().getProperty\r\n+                    (CLASS_TRANSFORMER_OPTIONS),\r\n+                    pui.getNewTempClassLoader()));\r\n+                return emf;\r\n+            } else return null;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * JEE 5 class transformer.\r\n+     */\r\n+    private static class ClassTransformerImpl implements ClassTransformer {\r\n+\r\n+        private final ClassFileTransformer _trans;\r\n+\r\n+        private ClassTransformerImpl(OpenJPAConfiguration conf, String options,\r\n+            ClassLoader tempClassLoader) {\r\n+            MetaDataRepository repos = conf.getMetaDataRepository().\r\n+                newInstance();\r\n+            repos.setResolve(MetaDataModes.MODE_MAPPING, false);\r\n+            _trans = new PCClassFileTransformer(repos,\r\n+                Configurations.parseProperties(options), tempClassLoader);\r\n+        }\r\n+\r\n+        public byte[] transform(ClassLoader cl, String name,\r\n+            Class<?> previousVersion, ProtectionDomain pd, byte[] bytes)\r\n+            throws IllegalClassFormatException {\r\n+            return _trans.transform(cl, name, previousVersion, pd, bytes);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"1438006c356afc044815c85beb867cf1eae1dd14","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceStrategy.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,36 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+///////////////////////////////////////////////////////////////////\r\n+// NOTE: when adding a new classification, make sure to update the\r\n+// table in PersistenceMetaDataDefaults\r\n+///////////////////////////////////////////////////////////////////\r\n+\r\n+/**\r\n+ * Set of field persistence strategies used in JPA.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public enum PersistenceStrategy {\r\n+    // order matters to match XML spec\r\n+    BASIC,\r\n+    MANY_ONE,\r\n+    ONE_MANY,\r\n+    ONE_ONE,\r\n+    MANY_MANY,\r\n+    EMBEDDED,\r\n+    TRANSIENT,\r\n+    // openjpa extensions\r\n+    PERS,\r\n+    PERS_COLL,\r\n+    PERS_MAP, }\r"},{"sha":"3cea33276136acd6647098cd7f283ca0bad0883e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","status":"added","additions":433,"deletions":0,"changes":433,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceUnitInfoImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,433 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.File;\r\n+import java.net.MalformedURLException;\r\n+import java.net.URISyntaxException;\r\n+import java.net.URL;\r\n+import java.net.URLDecoder;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import javax.persistence.spi.ClassTransformer;\r\n+import javax.persistence.spi.PersistenceUnitInfo;\r\n+import javax.persistence.spi.PersistenceUnitTransactionType;\r\n+import javax.sql.DataSource;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.meta.SourceTracker;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.MultiClassLoader;\r\n+import org.apache.openjpa.lib.util.TemporaryClassLoader;\r\n+import org.apache.openjpa.util.ClassResolver;\r\n+\r\n+/**\r\n+ * Implementation of the {@link PersistenceUnitInfo} interface used by OpenJPA when\r\n+ * parsing persistence configuration information.\r\n+ *\r\n+ * @nojavadoc\r\n+ */\r\n+public class PersistenceUnitInfoImpl\r\n+    implements PersistenceUnitInfo, SourceTracker {\r\n+\r\n+    private static final Localizer s_loc = Localizer.forPackage\r\n+        (PersistenceUnitInfoImpl.class);\r\n+    private String _name;\r\n+    private final Properties _props = new Properties();\r\n+    private PersistenceUnitTransactionType _transType =\r\n+        PersistenceUnitTransactionType.RESOURCE_LOCAL;\r\n+    private String _providerClassName;\r\n+    private List<String> _mappingFileNames;\r\n+    private List<String> _entityClassNames;\r\n+    private List<URL> _jarFiles;\r\n+    private String _jtaDataSourceName;\r\n+    private DataSource _jtaDataSource;\r\n+    private String _nonJtaDataSourceName;\r\n+    private DataSource _nonJtaDataSource;\r\n+    private boolean _excludeUnlisted;\r\n+    private URL _persistenceXmlFile;\r\n+    // A persistence unit is defined by a persistence.xml file. The jar\r\n+    // file or directory whose META-INF directory contains the\r\n+    // persistence.xml file is termed the root of the persistence unit.\r\n+    //\r\n+    // In Java EE, the root of a persistence unit may be one of the following:\r\n+    // - an EJB-JAR file\r\n+    // - the WEB-INF/classes directory of a WAR file[38]\r\n+    // - a jar file in the WEB-INF/lib directory of a WAR file\r\n+    // - a jar file in the root of the EAR\r\n+    // - a jar file in the EAR library directory\r\n+    // - an application client jar file\r\n+    private URL _root;\r\n+\r\n+    public ClassLoader getClassLoader() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public ClassLoader getNewTempClassLoader() {\r\n+        return new TemporaryClassLoader(Thread.currentThread().\r\n+            getContextClassLoader());\r\n+    }\r\n+\r\n+    public String getPersistenceUnitName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    public void setPersistenceUnitName(String emName) {\r\n+        _name = emName;\r\n+    }\r\n+\r\n+    public String getPersistenceProviderClassName() {\r\n+        return _providerClassName;\r\n+    }\r\n+\r\n+    public void setPersistenceProviderClassName(String providerClassName) {\r\n+        _providerClassName = providerClassName;\r\n+    }\r\n+\r\n+    public PersistenceUnitTransactionType getTransactionType() {\r\n+        return _transType;\r\n+    }\r\n+\r\n+    public void setTransactionType(PersistenceUnitTransactionType transType) {\r\n+        _transType = transType;\r\n+    }\r\n+\r\n+    public String getJtaDataSourceName() {\r\n+        return _jtaDataSourceName;\r\n+    }\r\n+\r\n+    public void setJtaDataSourceName(String jta) {\r\n+        _jtaDataSourceName = jta;\r\n+        if (jta != null)\r\n+            _jtaDataSource = null;\r\n+    }\r\n+\r\n+    public DataSource getJtaDataSource() {\r\n+        return _jtaDataSource;\r\n+    }\r\n+\r\n+    public void setJtaDataSource(DataSource ds) {\r\n+        _jtaDataSource = ds;\r\n+        if (ds != null)\r\n+            _jtaDataSourceName = null;\r\n+    }\r\n+\r\n+    public String getNonJtaDataSourceName() {\r\n+        return _nonJtaDataSourceName;\r\n+    }\r\n+\r\n+    public void setNonJtaDataSourceName(String nonJta) {\r\n+        _nonJtaDataSourceName = nonJta;\r\n+        if (nonJta != null)\r\n+            _nonJtaDataSource = null;\r\n+    }\r\n+\r\n+    public DataSource getNonJtaDataSource() {\r\n+        return _nonJtaDataSource;\r\n+    }\r\n+\r\n+    public void setNonJtaDataSource(DataSource ds) {\r\n+        _nonJtaDataSource = ds;\r\n+        if (ds != null)\r\n+            _nonJtaDataSourceName = null;\r\n+    }\r\n+\r\n+    public URL getPersistenceUnitRootUrl() {\r\n+        return _root;\r\n+    }\r\n+\r\n+    public void setPersistenceUnitRootUrl(URL root) {\r\n+        _root = root;\r\n+    }\r\n+\r\n+    public boolean excludeUnlistedClasses() {\r\n+        return _excludeUnlisted;\r\n+    }\r\n+\r\n+    public void setExcludeUnlistedClasses(boolean excludeUnlisted) {\r\n+        _excludeUnlisted = excludeUnlisted;\r\n+    }\r\n+\r\n+    public List<String> getMappingFileNames() {\r\n+        return (_mappingFileNames == null)\r\n+            ? (List<String>) Collections.EMPTY_LIST : _mappingFileNames;\r\n+    }\r\n+\r\n+    public void addMappingFileName(String name) {\r\n+        if (_mappingFileNames == null)\r\n+            _mappingFileNames = new ArrayList<String>();\r\n+        _mappingFileNames.add(name);\r\n+    }\r\n+\r\n+    public List<URL> getJarFileUrls() {\r\n+        return (_jarFiles == null)\r\n+            ? (List<URL>) Collections.EMPTY_LIST : _jarFiles;\r\n+    }\r\n+\r\n+    public void addJarFile(URL jar) {\r\n+        if (_jarFiles == null)\r\n+            _jarFiles = new ArrayList<URL>();\r\n+        _jarFiles.add(jar);\r\n+    }\r\n+\r\n+    public void addJarFileName(String name) {\r\n+        MultiClassLoader loader = new MultiClassLoader();\r\n+        loader.addClassLoader(getClass().getClassLoader());\r\n+        loader.addClassLoader(MultiClassLoader.THREAD_LOADER);\r\n+        URL url = loader.getResource(name);\r\n+        if (url != null) {\r\n+            addJarFile(url);\r\n+            return;\r\n+        }\r\n+        // jar file is not a resource; check classpath\r\n+        String[] cp = System.getProperty(\"java.class.path\").\r\n+            split(System.getProperty(\"path.separator\"));\r\n+        for (int i = 0; i < cp.length; i++) {\r\n+            if (cp[i].equals(name)\r\n+                || cp[i].endsWith(File.separatorChar + name)) {\r\n+                try {\r\n+                    addJarFile(new File(cp[i]).toURL());\r\n+                    return;\r\n+                } catch (MalformedURLException mue) {\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+        throw new IllegalArgumentException(s_loc.get(\"bad-jar-name\", name));\r\n+    }\r\n+\r\n+    public List<String> getManagedClassNames() {\r\n+        return (_entityClassNames == null)\r\n+            ? (List<String>) Collections.EMPTY_LIST : _entityClassNames;\r\n+    }\r\n+\r\n+    public void addManagedClassName(String name) {\r\n+        if (_entityClassNames == null)\r\n+            _entityClassNames = new ArrayList<String>();\r\n+        _entityClassNames.add(name);\r\n+    }\r\n+\r\n+    public Properties getProperties() {\r\n+        return _props;\r\n+    }\r\n+\r\n+    public void setProperty(String key, String value) {\r\n+        _props.setProperty(key, value);\r\n+    }\r\n+\r\n+    public void addTransformer(ClassTransformer transformer) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    /**\r\n+     * The location of the persistence.xml resource. May be null.\r\n+     */\r\n+    public URL getPersistenceXmlFileUrl() {\r\n+        return _persistenceXmlFile;\r\n+    }\r\n+\r\n+    /**\r\n+     * The location of the persistence.xml resource. May be null.\r\n+     */\r\n+    public void setPersistenceXmlFileUrl(URL url) {\r\n+        _persistenceXmlFile = url;\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the given user-supplied map of properties into this persistence\r\n+     * unit.\r\n+     */\r\n+    public void fromUserProperties(Map map) {\r\n+        if (map == null)\r\n+            return;\r\n+        Object key;\r\n+        Object val;\r\n+        for (Object o : map.entrySet()) {\r\n+            key = ((Map.Entry) o).getKey();\r\n+            val = ((Map.Entry) o).getValue();\r\n+            if (\"javax.persistence.provider\".equals(key))\r\n+                setPersistenceProviderClassName((String) val);\r\n+            else if (\"javax.persistence.transactionType\".equals(key)) {\r\n+                PersistenceUnitTransactionType ttype;\r\n+                if (val instanceof String)\r\n+                    ttype = Enum.valueOf\r\n+                        (PersistenceUnitTransactionType.class, (String) val);\r\n+                else ttype = (PersistenceUnitTransactionType) val;\r\n+                setTransactionType(ttype);\r\n+            } else if (\"javax.persistence.jtaDataSource\".equals(key)) {\r\n+                if (val instanceof String)\r\n+                    setJtaDataSourceName((String) val);\r\n+                else setJtaDataSource((DataSource) val);\r\n+            } else if (\"javax.persistence.nonJtaDataSource\".equals(key)) {\r\n+                if (val instanceof String)\r\n+                    setNonJtaDataSourceName((String) val);\r\n+                else setNonJtaDataSource((DataSource) val);\r\n+            } else if (key instanceof String && val instanceof String)\r\n+                setProperty((String) key, (String) val);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a {@link Map} containing the properties necessary to create\r\n+     * a {@link Configuration} that reflects the information in the given\r\n+     * persistence unit info.\r\n+     */\r\n+    public static Map toOpenJPAProperties(PersistenceUnitInfo info) {\r\n+        Map map = new HashMap();\r\n+        if (info.getTransactionType() == PersistenceUnitTransactionType.JTA)\r\n+            map.put(\"org.apache.openjpa.TransactionMode\", \"managed\");\r\n+        boolean hasJta = false;\r\n+        DataSource ds = info.getJtaDataSource();\r\n+        if (ds != null) {\r\n+            map.put(\"org.apache.openjpa.ConnectionFactory\", ds);\r\n+            map.put(\"org.apache.openjpa.ConnectionFactoryMode\", \"managed\");\r\n+            hasJta = true;\r\n+        } else if (info instanceof PersistenceUnitInfoImpl\r\n+            && ((PersistenceUnitInfoImpl) info).getJtaDataSourceName() != null)\r\n+        {\r\n+            map.put(\"org.apache.openjpa.ConnectionFactoryName\",\r\n+                ((PersistenceUnitInfoImpl)\r\n+                    info).getJtaDataSourceName());\r\n+            map.put(\"org.apache.openjpa.ConnectionFactoryMode\", \"managed\");\r\n+            hasJta = true;\r\n+        }\r\n+        ds = info.getNonJtaDataSource();\r\n+        if (ds != null) {\r\n+            if (!hasJta)\r\n+                map.put(\"org.apache.openjpa.ConnectionFactory\", ds);\r\n+            else map.put(\"org.apache.openjpa.ConnectionFactory2\", ds);\r\n+        } else if (info instanceof PersistenceUnitInfoImpl\r\n+            && ((PersistenceUnitInfoImpl) info).getNonJtaDataSourceName()\r\n+            != null) {\r\n+            String nonJtaName = ((PersistenceUnitInfoImpl) info).\r\n+                getNonJtaDataSourceName();\r\n+            if (!hasJta)\r\n+                map.put(\"org.apache.openjpa.ConnectionFactoryName\", nonJtaName);\r\n+            else\r\n+                map.put(\"org.apache.openjpa.ConnectionFactory2Name\",\r\n+                    nonJtaName);\r\n+        }\r\n+        if (info.getClassLoader() != null)\r\n+            map.put(\"org.apache.openjpa.ClassResolver\", new ClassResolverImpl\r\n+                (info.getClassLoader()));\r\n+        Properties props = info.getProperties();\r\n+        if (props != null) {\r\n+            map.putAll(props);\r\n+            // this isn't a real config property; remove it.\r\n+            map.remove(PersistenceProviderImpl.CLASS_TRANSFORMER_OPTIONS);\r\n+        }\r\n+        Properties metaFactoryProps = new Properties();\r\n+        if (info.getManagedClassNames() != null &&\r\n+            !info.getManagedClassNames().isEmpty()) {\r\n+            StringBuffer types = new StringBuffer();\r\n+            for (String type : info.getManagedClassNames()) {\r\n+                if (types.length() > 0)\r\n+                    types.append(';');\r\n+                types.append(type);\r\n+            }\r\n+            metaFactoryProps.put(\"Types\", types.toString());\r\n+        }\r\n+        if (info.getJarFileUrls() != null && !info.getJarFileUrls().isEmpty()\r\n+            || (!info.excludeUnlistedClasses()\r\n+            && info.getPersistenceUnitRootUrl() != null)) {\r\n+            StringBuffer jars = new StringBuffer();\r\n+            String file = null;\r\n+            if (!info.excludeUnlistedClasses()\r\n+                && info.getPersistenceUnitRootUrl() != null) {\r\n+                URL url = info.getPersistenceUnitRootUrl();\r\n+                if (\"file\".equals(url.getProtocol())) // exploded jar?\r\n+                    file = URLDecoder.decode(url.getPath());\r\n+                else jars.append(url);\r\n+            }\r\n+            for (URL jar : info.getJarFileUrls()) {\r\n+                if (jars.length() > 0)\r\n+                    jars.append(';');\r\n+                jars.append(jar);\r\n+            }\r\n+            if (file != null)\r\n+                metaFactoryProps.put(\"Files\", file);\r\n+            if (jars.length() != 0)\r\n+                metaFactoryProps.put(\"URLs\", jars.toString());\r\n+        }\r\n+        if (info.getMappingFileNames() != null\r\n+            && !info.getMappingFileNames().isEmpty()) {\r\n+            StringBuffer rsrcs = new StringBuffer();\r\n+            for (String rsrc : info.getMappingFileNames()) {\r\n+                if (rsrcs.length() > 0)\r\n+                    rsrcs.append(';');\r\n+                rsrcs.append(rsrc);\r\n+            }\r\n+            metaFactoryProps.put(\"Resources\", rsrcs.toString());\r\n+        }\r\n+        if (!metaFactoryProps.isEmpty()) {\r\n+            // set persistent class locations as properties of metadata factory\r\n+            String factory =\r\n+                (String) map.get(\"org.apache.openjpa.MetaDataFactory\");\r\n+            if (factory == null)\r\n+                factory = Configurations.serializeProperties(metaFactoryProps);\r\n+            else {\r\n+                String clsName = Configurations.getClassName(factory);\r\n+                metaFactoryProps.putAll(Configurations.parseProperties\r\n+                    (Configurations.getProperties(factory)));\r\n+                factory = Configurations.getPlugin(clsName,\r\n+                    Configurations.serializeProperties(metaFactoryProps));\r\n+            }\r\n+            map.put(\"org.apache.openjpa.MetaDataFactory\", factory);\r\n+        }\r\n+        return map;\r\n+    }\r\n+\r\n+    // --------------------\r\n+    public File getSourceFile() {\r\n+        if (_persistenceXmlFile == null)\r\n+            return null;\r\n+        try {\r\n+            return new File(_persistenceXmlFile.toURI());\r\n+        } catch (URISyntaxException e) {\r\n+            throw new IllegalStateException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public Object getSourceScope() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public int getSourceType() {\r\n+        return SRC_XML;\r\n+    }\r\n+\r\n+    public String getResourceName() {\r\n+        return \"PersistenceUnitInfo:\" + _name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple class resolver built around the persistence unit loader.\r\n+     */\r\n+    private static class ClassResolverImpl implements ClassResolver {\r\n+\r\n+        private final ClassLoader _loader;\r\n+\r\n+        public ClassResolverImpl(ClassLoader loader) {\r\n+            _loader = loader;\r\n+        }\r\n+\r\n+        public ClassLoader getClassLoader(Class ctx, ClassLoader env) {\r\n+            return _loader;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"c9e3ed76780def4063d69614e31180bb95c9c56f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Persistent.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,42 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+import javax.persistence.CascadeType;\r\n+import javax.persistence.FetchType;\r\n+\r\n+/**\r\n+ * Metadata annotation for a persistent field.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface Persistent {\r\n+\r\n+    String mappedBy() default \"\";\r\n+\r\n+    CascadeType[] cascade() default {};\r\n+\r\n+    boolean optional() default true;\r\n+\r\n+    boolean embedded() default false;\r\n+\r\n+    FetchType fetch() default FetchType.EAGER;\r\n+}\r"},{"sha":"a9c96a4328b897ece97eb4127c4180d175e84b77","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentCollection.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,42 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+import javax.persistence.CascadeType;\r\n+import javax.persistence.FetchType;\r\n+\r\n+/**\r\n+ * Metadata annotation for a persistent collection field.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface PersistentCollection {\r\n+\r\n+    String mappedBy() default \"\";\r\n+\r\n+    Class elementType() default void.class;\r\n+\r\n+    CascadeType[] elementCascade() default {};\r\n+\r\n+    boolean elementEmbedded() default false;\r\n+\r\n+    FetchType fetch() default FetchType.LAZY;\r\n+}\r"},{"sha":"2a0910a6e6564eb586374981c219920c88293bb9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistentMap.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,46 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+import javax.persistence.CascadeType;\r\n+import javax.persistence.FetchType;\r\n+\r\n+/**\r\n+ * Metadata annotation for a persistent map field.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface PersistentMap {\r\n+\r\n+    Class keyType() default void.class;\r\n+\r\n+    Class elementType() default void.class;\r\n+\r\n+    CascadeType[] keyCascade() default {};\r\n+\r\n+    CascadeType[] elementCascade() default {};\r\n+\r\n+    boolean keyEmbedded() default false;\r\n+\r\n+    boolean elementEmbedded() default false;\r\n+\r\n+    FetchType fetch() default FetchType.LAZY;\r\n+}\r"},{"sha":"6d526a10ef791507426cff52a7ac4f17d6646c39","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"added","additions":497,"deletions":0,"changes":497,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,497 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.ArrayList;\r\n+import java.util.Calendar;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import javax.persistence.FlushModeType;\r\n+import javax.persistence.Query;\r\n+import javax.persistence.TemporalType;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.DelegatingQuery;\r\n+import org.apache.openjpa.kernel.DelegatingResultList;\r\n+import org.apache.openjpa.kernel.Filters;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ResultList;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+\r\n+/**\r\n+ * Implementation of {@link Query} interface.\r\n+ *\r\n+ * @author Marc Prud'hommeaux\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class QueryImpl implements OpenJPAQuery, Serializable {\r\n+\r\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\r\n+    private static final Localizer _loc = Localizer.forPackage(QueryImpl.class);\r\n+    private final DelegatingQuery _query;\r\n+    private transient Broker _broker; // for profiling\r\n+    private transient EntityManagerImpl _em;\r\n+    private transient FetchPlan _fetch;\r\n+    private Map _named;\r\n+    private List _positional;\r\n+\r\n+    /**\r\n+     * Constructor; supply factory and delegate.\r\n+     */\r\n+    public QueryImpl(EntityManagerImpl em,\r\n+        org.apache.openjpa.kernel.Query query) {\r\n+        _em = em;\r\n+        _broker = em.getBroker();\r\n+        _query = new DelegatingQuery(query,\r\n+            PersistenceExceptions.getRollbackTranslator(em));\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public org.apache.openjpa.kernel.Query getDelegate() {\r\n+        return _query.getDelegate();\r\n+    }\r\n+\r\n+    public OpenJPAEntityManager getEntityManager() {\r\n+        return _em;\r\n+    }\r\n+\r\n+    public String getLanguage() {\r\n+        return _query.getLanguage();\r\n+    }\r\n+\r\n+    public int getOperation() {\r\n+        return _query.getOperation();\r\n+    }\r\n+\r\n+    public FetchPlan getFetchPlan() {\r\n+        _query.assertNotSerialized();\r\n+        _query.lock();\r\n+        try {\r\n+            if (_fetch == null)\r\n+                _fetch = ((EntityManagerFactoryImpl) _em.\r\n+                    getEntityManagerFactory()).toFetchPlan(_query.\r\n+                    getFetchConfiguration());\r\n+            return _fetch;\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public String getQueryString() {\r\n+        return _query.getQueryString();\r\n+    }\r\n+\r\n+    public boolean getIgnoreChanges() {\r\n+        return _query.getIgnoreChanges();\r\n+    }\r\n+\r\n+    public OpenJPAQuery setIgnoreChanges(boolean ignore) {\r\n+        _query.setIgnoreChanges(ignore);\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery addFilterListener(FilterListener listener) {\r\n+        _query.addFilterListener(listener);\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery removeFilterListener(FilterListener listener) {\r\n+        _query.removeFilterListener(listener);\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery addAggregateListener(AggregateListener listener) {\r\n+        _query.addAggregateListener(listener);\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery removeAggregateListener(AggregateListener listener) {\r\n+        _query.removeAggregateListener(listener);\r\n+        return this;\r\n+    }\r\n+\r\n+    public Collection getCandidateCollection() {\r\n+        return _query.getCandidateCollection();\r\n+    }\r\n+\r\n+    public OpenJPAQuery setCandidateCollection(Collection coll) {\r\n+        _query.setCandidateCollection(coll);\r\n+        return this;\r\n+    }\r\n+\r\n+    public Class getResultClass() {\r\n+        Class res = _query.getResultType();\r\n+        if (res != null)\r\n+            return res;\r\n+        return _query.getCandidateType();\r\n+    }\r\n+\r\n+    public OpenJPAQuery setResultClass(Class cls) {\r\n+        if (OpenJPAPersistence.isManagedType(_em, cls))\r\n+            _query.setCandidateType(cls, true);\r\n+        else _query.setResultType(cls);\r\n+        return this;\r\n+    }\r\n+\r\n+    public boolean hasSubclasses() {\r\n+        return _query.hasSubclasses();\r\n+    }\r\n+\r\n+    public OpenJPAQuery setSubclasses(boolean subs) {\r\n+        Class cls = _query.getCandidateType();\r\n+        _query.setCandidateExtent(_query.getBroker().newExtent(cls, subs));\r\n+        return this;\r\n+    }\r\n+\r\n+    public int getFirstResult() {\r\n+        return asInt(_query.getStartRange());\r\n+    }\r\n+\r\n+    public OpenJPAQuery setFirstResult(int startPosition) {\r\n+        _query.setRange(startPosition, _query.getEndRange());\r\n+        return this;\r\n+    }\r\n+\r\n+    public int getMaxResults() {\r\n+        return asInt(_query.getEndRange() - _query.getStartRange());\r\n+    }\r\n+\r\n+    public OpenJPAQuery setMaxResults(int max) {\r\n+        long start = _query.getStartRange();\r\n+        if (max == Integer.MAX_VALUE)\r\n+            _query.setRange(start, Long.MAX_VALUE);\r\n+        else _query.setRange(start, start + max);\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery compile() {\r\n+        _query.compile();\r\n+        return this;\r\n+    }\r\n+\r\n+    private Object execute() {\r\n+        if (_query.getOperation() != OP_SELECT)\r\n+            throw new InvalidStateException(_loc.get(\"not-select-query\",\r\n+                _query.getQueryString()), null, null, false);\r\n+        validateParameters();\r\n+        // handle which types of parameters we are using, if any\r\n+        if (_positional != null)\r\n+            return _query.execute(_positional.toArray());\r\n+        if (_named != null)\r\n+            return _query.execute(_named);\r\n+        return _query.execute();\r\n+    }\r\n+\r\n+    /**\r\n+     * Validate that the types of the parameters are correct.\r\n+     */\r\n+    private void validateParameters() {\r\n+        if (_positional != null) {\r\n+            LinkedMap types = _query.getParameterTypes();\r\n+            for (int i = 0, size = Math.min(_positional.size(), types.size());\r\n+                i < size; i++)\r\n+                validateParameter(String.valueOf(i),\r\n+                    (Class) types.getValue(i), _positional.get(i));\r\n+        } else if (_named != null) {\r\n+            Map types = _query.getParameterTypes();\r\n+            for (Iterator i = _named.entrySet().iterator(); i.hasNext();) {\r\n+                Map.Entry entry = (Map.Entry) i.next();\r\n+                String name = (String) entry.getKey();\r\n+                validateParameter(name, (Class) types.get(name),\r\n+                    entry.getValue());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void validateParameter(String paramDesc, Class type, Object param) {\r\n+        // null parameters are allowed, so are not validated\r\n+        if (param == null || type == null)\r\n+            return;\r\n+        // check the parameter against the wrapped type\r\n+        if (!Filters.wrap(type).isInstance(param))\r\n+            throw new ArgumentException(_loc.get(\"bad-param-type\",\r\n+                paramDesc, param.getClass().getName(), type.getName()),\r\n+                null, null, false);\r\n+    }\r\n+\r\n+    public List getResultList() {\r\n+        Object ob = execute();\r\n+        if (ob instanceof List) {\r\n+            List ret = (List) ob;\r\n+            if (ret instanceof ResultList)\r\n+                return new DelegatingResultList((ResultList) ret,\r\n+                    PersistenceExceptions.getRollbackTranslator(_em));\r\n+            else return ret;\r\n+        }\r\n+        return Collections.singletonList(ob);\r\n+    }\r\n+\r\n+    /**\r\n+     * Execute a query that returns a single result.\r\n+     */\r\n+    public Object getSingleResult() {\r\n+        Object ob = execute();\r\n+        if (!(ob instanceof List))\r\n+            return ob;\r\n+        List res = (List) ob;\r\n+        try {\r\n+            // don't use size() b/c can be inefficient under some LRS settings\r\n+            Iterator itr = res.iterator();\r\n+            if (!itr.hasNext())\r\n+                throw new NoResultException(_loc.get(\"no-results\",\r\n+                    _query.getQueryString()), null, null, false);\r\n+            Object ret = itr.next();\r\n+            if (itr.hasNext())\r\n+                throw new NonUniqueResultException(_loc.get(\"mult-results\",\r\n+                    _query.getQueryString()), null, null, false);\r\n+            return ret;\r\n+        }\r\n+        finally {\r\n+            OpenJPAPersistence.close(res);\r\n+        }\r\n+    }\r\n+\r\n+    public int executeUpdate() {\r\n+        if (_query.getOperation() == OP_DELETE) {\r\n+            // handle which types of parameters we are using, if any\r\n+            if (_positional != null)\r\n+                return asInt(_query.deleteAll(_positional.toArray()));\r\n+            if (_named != null)\r\n+                return asInt(_query.deleteAll(_named));\r\n+            return asInt(_query.deleteAll());\r\n+        }\r\n+        if (_query.getOperation() == OP_UPDATE) {\r\n+            // handle which types of parameters we are using, if any\r\n+            if (_positional != null)\r\n+                return asInt(_query.updateAll(_positional.toArray()));\r\n+            if (_named != null)\r\n+                return asInt(_query.updateAll(_named));\r\n+            return asInt(_query.updateAll());\r\n+        }\r\n+        throw new InvalidStateException(_loc.get(\"not-update-delete-query\",\r\n+            _query.getQueryString()), null, null, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Cast the specified long down to an int, first checking for overflow.\r\n+     */\r\n+    private static int asInt(long l) {\r\n+        if (l > Integer.MAX_VALUE)\r\n+            return Integer.MAX_VALUE;\r\n+        if (l < Integer.MIN_VALUE) // unlikely, but we might as well check\r\n+            return Integer.MIN_VALUE;\r\n+        return (int) l;\r\n+    }\r\n+\r\n+    public FlushModeType getFlushMode() {\r\n+        return EntityManagerImpl.fromFlushBeforeQueries(_query.\r\n+            getFetchConfiguration().getFlushBeforeQueries());\r\n+    }\r\n+\r\n+    public OpenJPAQuery setFlushMode(FlushModeType flushMode) {\r\n+        _query.getFetchConfiguration().setFlushBeforeQueries\r\n+            (EntityManagerImpl.toFlushBeforeQueries(flushMode));\r\n+        return this;\r\n+    }\r\n+\r\n+    public OpenJPAQuery setHint(String key, Object value) {\r\n+        if (key == null || !key.startsWith(\"org.apache.openjpa.\"))\r\n+            return this;\r\n+        String k = key.substring(\"org.apache.openjpa.\".length());\r\n+        try {\r\n+            if (\"Subclasses\".equals(k)) {\r\n+                if (value instanceof String)\r\n+                    value = Boolean.valueOf((String) value);\r\n+                setSubclasses(((Boolean) value).booleanValue());\r\n+            } else if (\"FilterListener\".equals(k))\r\n+                addFilterListener(Filters.hintToFilterListener(value,\r\n+                    _query.getBroker().getClassLoader()));\r\n+            else if (\"FilterListeners\".equals(k)) {\r\n+                FilterListener[] arr = Filters.hintToFilterListeners(value,\r\n+                    _query.getBroker().getClassLoader());\r\n+                for (int i = 0; i < arr.length; i++)\r\n+                    addFilterListener(arr[i]);\r\n+            } else if (\"AggregateListener\".equals(k))\r\n+                addAggregateListener(Filters.hintToAggregateListener(value,\r\n+                    _query.getBroker().getClassLoader()));\r\n+            else if (\"FilterListeners\".equals(k)) {\r\n+                AggregateListener[] arr = Filters.hintToAggregateListeners\r\n+                    (value, _query.getBroker().getClassLoader());\r\n+                for (int i = 0; i < arr.length; i++)\r\n+                    addAggregateListener(arr[i]);\r\n+            } else if (k.startsWith(\"FetchPlan.\")) {\r\n+                k = k.substring(\"FetchPlan.\".length());\r\n+                Filters.hintToSetter(getFetchPlan(), k, value);\r\n+            } else if (k.startsWith(\"hint.\"))\r\n+                _query.getFetchConfiguration().setHint(key, value);\r\n+            else throw new ArgumentException(_loc.get(\"bad-query-hint\", key),\r\n+                null, null, false);\r\n+            return this;\r\n+        } catch (Exception e) {\r\n+            throw PersistenceExceptions.toPersistenceException(e);\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Calendar value,\r\n+        TemporalType t) {\r\n+        return setParameter(position, (Object) value);\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Date value,\r\n+        TemporalType type) {\r\n+        return setParameter(position, (Object) value);\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(int position, Object value) {\r\n+        _query.lock();\r\n+        try {\r\n+            // not allowed to mix positional and named parameters(EDR2 3.6.4)\r\n+            if (_named != null)\r\n+                throw new InvalidStateException(_loc.get\r\n+                    (\"no-pos-named-params-mix\", _query.getQueryString()),\r\n+                    null, null, false);\r\n+            if (position < 1)\r\n+                throw new InvalidStateException(_loc.get\r\n+                    (\"illegal-index\", position), null, null, false);\r\n+            if (_positional == null)\r\n+                _positional = new ArrayList();\r\n+            // make sure it is at least the requested size\r\n+            while (_positional.size() < position)\r\n+                _positional.add(null);\r\n+            // note that we add it to position - 1, since setPosition\r\n+            // starts at 1, while List starts at 0\r\n+            _positional.set(position - 1, value);\r\n+            return this;\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Calendar value,\r\n+        TemporalType t) {\r\n+        return setParameter(name, (Object) value);\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Date value,\r\n+        TemporalType type) {\r\n+        return setParameter(name, (Object) value);\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameter(String name, Object value) {\r\n+        _query.lock();\r\n+        try {\r\n+            // not allowed to mix positional and named parameters(EDR2 3.6.4)\r\n+            if (_positional != null)\r\n+                throw new InvalidStateException(_loc.get\r\n+                    (\"no-pos-named-params-mix\", _query.getQueryString()),\r\n+                    null, null, false);\r\n+            if (_named == null)\r\n+                _named = new HashMap();\r\n+            _named.put(name, value);\r\n+            return this;\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public boolean hasPositionalParameters() {\r\n+        return _positional != null;\r\n+    }\r\n+\r\n+    public Object[] getPositionalParameters() {\r\n+        _query.lock();\r\n+        try {\r\n+            return (_positional == null) ? EMPTY_ARRAY : _positional.toArray();\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameters(Object... params) {\r\n+        _query.lock();\r\n+        try {\r\n+            _positional = null;\r\n+            _named = null;\r\n+            if (params != null)\r\n+                for (int i = 0; i < params.length; i++)\r\n+                    setParameter(i + 1, params[i]);\r\n+            return this;\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public Map getNamedParameters() {\r\n+        _query.lock();\r\n+        try {\r\n+            return (_named == null) ? Collections.EMPTY_MAP\r\n+                : Collections.unmodifiableMap(_named);\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery setParameters(Map params) {\r\n+        _query.lock();\r\n+        try {\r\n+            _positional = null;\r\n+            _named = null;\r\n+            if (params != null)\r\n+                for (Map.Entry e : (Set<Map.Entry>) params.entrySet())\r\n+                    setParameter((String) e.getKey(), e.getValue());\r\n+            return this;\r\n+        }\r\n+        finally {\r\n+            _query.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public OpenJPAQuery closeAll() {\r\n+        _query.closeAll();\r\n+        return this;\r\n+    }\r\n+\r\n+    public String[] getDataStoreActions(Map params) {\r\n+        return _query.getDataStoreActions(params);\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _query.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof QueryImpl))\r\n+            return false;\r\n+        return _query.equals(((QueryImpl) other)._query);\r\n+    }\r\n+}\r"},{"sha":"fb863a8c15d5d356c9597d5bc43b6604f964c3c7","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryResultCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,111 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.Collections;\r\n+import javax.persistence.Query;\r\n+\r\n+import org.apache.openjpa.datacache.DelegatingQueryCache;\r\n+import org.apache.openjpa.datacache.QueryCache;\r\n+import org.apache.openjpa.datacache.QueryKey;\r\n+import org.apache.openjpa.datacache.TypesChangedEvent;\r\n+\r\n+/**\r\n+ * Query result cache.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public class QueryResultCache {\r\n+\r\n+    private final DelegatingQueryCache _cache;\r\n+\r\n+    /**\r\n+     * Constructor; supply delegate.\r\n+     */\r\n+    public QueryResultCache(QueryCache cache) {\r\n+        _cache = new DelegatingQueryCache(cache,\r\n+            PersistenceExceptions.TRANSLATOR);\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public QueryCache getDelegate() {\r\n+        return _cache.getDelegate();\r\n+    }\r\n+\r\n+    /**\r\n+     * Pin the given query's result to the cache.\r\n+     */\r\n+    public void pin(Query q) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.pin(toQueryKey(q));\r\n+    }\r\n+\r\n+    /**\r\n+     * Unpin a previously-pinned query result.\r\n+     */\r\n+    public void unpin(Query q) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.unpin(toQueryKey(q));\r\n+    }\r\n+\r\n+    /**\r\n+     * Evict a query result from the cache.\r\n+     */\r\n+    public void evict(Query q) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.remove(toQueryKey(q));\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    public void evictAll() {\r\n+        _cache.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Evict all result for queries involving the given class.\r\n+     */\r\n+    public void evictAll(Class cls) {\r\n+        _cache.onTypesChanged(new TypesChangedEvent(this,\r\n+            Collections.singleton(cls)));\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a cache key for the given query.\r\n+     */\r\n+    private QueryKey toQueryKey(Query q) {\r\n+        QueryImpl impl = (QueryImpl) q;\r\n+        if (impl.hasPositionalParameters())\r\n+            return QueryKey.newInstance(impl.getDelegate(),\r\n+                impl.getPositionalParameters());\r\n+        return QueryKey.newInstance(impl.getDelegate(),\r\n+            impl.getNamedParameters());\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _cache.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof QueryResultCache))\r\n+            return false;\r\n+        return _cache.equals(((QueryResultCache) other)._cache);\r\n+    }\r\n+}\r"},{"sha":"d2f7691eb198dd3d4eac144b88de8a19b764719f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ReadOnly.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,32 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Marks a field read-only.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface ReadOnly {\r\n+\r\n+    UpdateAction value() default UpdateAction.RESTRICT;\r\n+}\r"},{"sha":"ee99a121986ccc92c1c3de36393e83e03cf595b4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RollbackException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,93 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+\r\n+/**\r\n+ * Rollback occurred on attempt to commit.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class RollbackException extends javax.persistence.RollbackException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient Throwable[] _nested;\r\n+\r\n+    public RollbackException(Exception e) {\r\n+        super(e.getMessage());\r\n+        _nested = new Throwable[]{ e };\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return STORE;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return GENERAL;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"59a162e0829613fd5b25ef7a82506f75a37c6a88","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","status":"added","additions":191,"deletions":0,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/StoreCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,191 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+\r\n+import org.apache.openjpa.datacache.DataCache;\r\n+import org.apache.openjpa.datacache.DelegatingDataCache;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+\r\n+/**\r\n+ * Represents the L2 cache over the data store.\r\n+ *\r\n+ * @author Abe White\r\n+ * @published\r\n+ * @since 4.0\r\n+ */\r\n+public class StoreCache {\r\n+\r\n+    public static final String NAME_DEFAULT = DataCache.NAME_DEFAULT;\r\n+    private final MetaDataRepository _repos;\r\n+    private final DelegatingDataCache _cache;\r\n+\r\n+    /**\r\n+     * Constructor; supply delegate.\r\n+     */\r\n+    public StoreCache(EntityManagerFactoryImpl emf, DataCache cache) {\r\n+        _repos = emf.getConfiguration().getMetaDataRepository();\r\n+        _cache = new DelegatingDataCache(cache,\r\n+            PersistenceExceptions.TRANSLATOR);\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public DataCache getDelegate() {\r\n+        return _cache.getDelegate();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the cache contains data for the given oid.\r\n+     */\r\n+    public boolean contains(Class cls, Object oid) {\r\n+        return _cache.getDelegate() != null\r\n+            && _cache.contains(OpenJPAPersistence.toOpenJPAObjectId\r\n+            (getMetaData(cls), oid));\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the cache contains data for the given oids.\r\n+     */\r\n+    public boolean containsAll(Class cls, Object... oids) {\r\n+        return containsAll(cls, Arrays.asList(oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the cache contains data for the given oids.\r\n+     */\r\n+    public boolean containsAll(Class cls, Collection oids) {\r\n+        if (_cache.getDelegate() == null)\r\n+            return oids.isEmpty();\r\n+        BitSet set = _cache.containsAll(OpenJPAPersistence.toOpenJPAObjectIds\r\n+            (getMetaData(cls), oids));\r\n+        for (int i = 0; i < oids.size(); i++)\r\n+            if (!set.get(i))\r\n+                return false;\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Pin the data for the given oid to the cache.\r\n+     */\r\n+    public void pin(Class cls, Object oid) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.pin(\r\n+                OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls), oid));\r\n+    }\r\n+\r\n+    /**\r\n+     * Pin the data for the given oids to the cache.\r\n+     */\r\n+    public void pinAll(Class cls, Object... oids) {\r\n+        pinAll(cls, Arrays.asList(oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Pin the data for the given oids to the cache.\r\n+     */\r\n+    public void pinAll(Class cls, Collection oids) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache\r\n+                .pinAll(OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\r\n+                    oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Unpin the data for the given oid from the cache.\r\n+     */\r\n+    public void unpin(Class cls, Object oid) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.unpin(OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls),\r\n+                oid));\r\n+    }\r\n+\r\n+    /**\r\n+     * Unpin the data for the given oids from the cache.\r\n+     */\r\n+    public void unpinAll(Class cls, Object... oids) {\r\n+        unpinAll(cls, Arrays.asList(oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Unpin the data for the given oids from the cache.\r\n+     */\r\n+    public void unpinAll(Class cls, Collection oids) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.unpinAll(\r\n+                OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\r\n+                    oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove data for the given oid from the cache.\r\n+     */\r\n+    public void evict(Class cls, Object oid) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.remove(OpenJPAPersistence.toOpenJPAObjectId(getMetaData(cls),\r\n+                oid));\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove data for the given oids from the cache.\r\n+     */\r\n+    public void evictAll(Class cls, Object... oids) {\r\n+        evictAll(cls, Arrays.asList(oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove data for the given oids from the cache.\r\n+     */\r\n+    public void evictAll(Class cls, Collection oids) {\r\n+        if (_cache.getDelegate() != null)\r\n+            _cache.removeAll(\r\n+                OpenJPAPersistence.toOpenJPAObjectIds(getMetaData(cls),\r\n+                    oids));\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    public void evictAll() {\r\n+        _cache.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return metadata for the given class, throwing the proper exception\r\n+     * if not persistent.\r\n+     */\r\n+    private ClassMetaData getMetaData(Class cls) {\r\n+        try {\r\n+            return _repos.getMetaData(cls, null, true);\r\n+        } catch (RuntimeException re) {\r\n+            throw PersistenceExceptions.toPersistenceException(re);\r\n+        }\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _cache.hashCode();\r\n+    }\r\n+\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof StoreCache))\r\n+            return false;\r\n+        return _cache.equals(((StoreCache) other)._cache);\r\n+    }\r\n+}\r"},{"sha":"a751c7907049528aa918d8b6f5fb9b5f3deff7d8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/TransactionRequiredException.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,104 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.util.ExceptionInfo;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Transaction required.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+class TransactionRequiredException\r\n+    extends javax.persistence.TransactionRequiredException\r\n+    implements Serializable, ExceptionInfo {\r\n+\r\n+    private transient boolean _fatal = false;\r\n+    private transient Object _failed = null;\r\n+    private transient Throwable[] _nested = null;\r\n+\r\n+    public TransactionRequiredException(String msg, Throwable[] nested,\r\n+        Object failed, boolean fatal) {\r\n+        super(msg);\r\n+        _nested = nested;\r\n+        _failed = failed;\r\n+        _fatal = fatal;\r\n+    }\r\n+\r\n+    public int getType() {\r\n+        return USER;\r\n+    }\r\n+\r\n+    public int getSubtype() {\r\n+        return UserException.NO_TRANSACTION;\r\n+    }\r\n+\r\n+    public boolean isFatal() {\r\n+        return _fatal;\r\n+    }\r\n+\r\n+    public Throwable getCause() {\r\n+        return PersistenceExceptions.getCause(_nested);\r\n+    }\r\n+\r\n+    public Throwable[] getNestedThrowables() {\r\n+        return (_nested == null) ? Exceptions.EMPTY_THROWABLES : _nested;\r\n+    }\r\n+\r\n+    public Object getFailedObject() {\r\n+        return _failed;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return Exceptions.toString(this);\r\n+    }\r\n+\r\n+    public void printStackTrace() {\r\n+        printStackTrace(System.err);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintStream out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    public void printStackTrace(PrintWriter out) {\r\n+        super.printStackTrace(out);\r\n+        Exceptions.printNestedThrowables(this, out);\r\n+    }\r\n+\r\n+    private void writeObject(ObjectOutputStream out) throws IOException {\r\n+        out.writeBoolean(_fatal);\r\n+        out.writeObject(Exceptions.replaceFailedObject(_failed));\r\n+        out.writeObject(Exceptions.replaceNestedThrowables(_nested));\r\n+    }\r\n+\r\n+    private void readObject(ObjectInputStream in)\r\n+        throws IOException, ClassNotFoundException {\r\n+        _fatal = in.readBoolean();\r\n+        _failed = in.readObject();\r\n+        _nested = (Throwable[]) in.readObject();\r\n+    }\r\n+}\r\n+\r"},{"sha":"93184fc58c232fc6f9c3498c8a6b54a783dfd492","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/Type.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,33 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import static java.lang.annotation.ElementType.FIELD;\r\n+import static java.lang.annotation.ElementType.METHOD;\r\n+import java.lang.annotation.Retention;\r\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\r\n+import java.lang.annotation.Target;\r\n+\r\n+/**\r\n+ * Indicates the persistent type of a field, if different than the\r\n+ * declared type.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+@Target({ METHOD, FIELD })\r\n+@Retention(RUNTIME)\r\n+public @interface Type {\r\n+\r\n+    Class value();\r\n+}\r"},{"sha":"1693ddbb912e8848c405325c7888e3d6ca2cedba","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","status":"added","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/UpdateAction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,24 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+/**\r\n+ * Action to take when a field's value is changed.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 4.0\r\n+ */\r\n+public enum UpdateAction {\r\n+\r\n+    IGNORE,\r\n+    RESTRICT };\r"},{"sha":"cc929bc4a8cfe013e340df0fe6952ed578d38192","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"added","additions":1524,"deletions":0,"changes":1524,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1524 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.lang.reflect.Field;\r\n+import java.lang.reflect.Member;\r\n+import java.lang.reflect.Method;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.EnumSet;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.Stack;\r\n+import javax.persistence.CascadeType;\r\n+import static javax.persistence.CascadeType.*;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.xml.sax.Attributes;\r\n+import org.xml.sax.SAXException;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.event.BeanLifecycleCallbacks;\r\n+import org.apache.openjpa.event.LifecycleCallbacks;\r\n+import org.apache.openjpa.event.LifecycleEvent;\r\n+import org.apache.openjpa.event.MethodLifecycleCallbacks;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.kernel.jpql.JPQLParser;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.meta.CFMetaDataParser;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.DelegatingMetaDataFactory;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.LifecycleMetaData;\r\n+import org.apache.openjpa.meta.MetaDataFactory;\r\n+import static org.apache.openjpa.meta.MetaDataModes.*;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.meta.Order;\r\n+import org.apache.openjpa.meta.QueryMetaData;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.meta.ValueStrategies;\r\n+import static org.apache.openjpa.persistence.MetaDataTag.*;\r\n+import static org.apache.openjpa.persistence.PersistenceStrategy.*;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+\r\n+/**\r\n+ * Custom SAX parser used by the system to quickly parse persistence i\r\n+ * metadata files.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ */\r\n+public class XMLPersistenceMetaDataParser extends CFMetaDataParser\r\n+    implements PersistenceMetaDataFactory.Parser {\r\n+\r\n+    // parse constants\r\n+    protected static final String ELEM_PKG = \"package\";\r\n+    protected static final String ELEM_ACCESS = \"access\";\r\n+    protected static final String ELEM_ATTRS = \"attributes\";\r\n+    protected static final String ELEM_LISTENER = \"entity-listener\";\r\n+    protected static final String ELEM_CASCADE = \"cascade\";\r\n+    protected static final String ELEM_CASCADE_ALL = \"cascade-all\";\r\n+    protected static final String ELEM_CASCADE_PER = \"cascade-persist\";\r\n+    protected static final String ELEM_CASCADE_MER = \"cascade-merge\";\r\n+    protected static final String ELEM_CASCADE_REM = \"cascade-remove\";\r\n+    protected static final String ELEM_CASCADE_REF = \"cascade-refresh\";\r\n+    protected static final String ELEM_PU_META = \"persistence-unit-metadata\";\r\n+    protected static final String ELEM_PU_DEF = \"persistence-unit-defaults\";\r\n+    private static final Map<String, Object> _elems =\r\n+        new HashMap<String, Object>();\r\n+\r\n+    static {\r\n+        _elems.put(ELEM_PKG, ELEM_PKG);\r\n+        _elems.put(ELEM_ACCESS, ELEM_ACCESS);\r\n+        _elems.put(ELEM_ATTRS, ELEM_ATTRS);\r\n+        _elems.put(ELEM_LISTENER, ELEM_LISTENER);\r\n+        _elems.put(ELEM_CASCADE, ELEM_CASCADE);\r\n+        _elems.put(ELEM_CASCADE_ALL, ELEM_CASCADE_ALL);\r\n+        _elems.put(ELEM_CASCADE_PER, ELEM_CASCADE_PER);\r\n+        _elems.put(ELEM_CASCADE_REM, ELEM_CASCADE_REM);\r\n+        _elems.put(ELEM_CASCADE_MER, ELEM_CASCADE_MER);\r\n+        _elems.put(ELEM_CASCADE_REF, ELEM_CASCADE_REF);\r\n+        _elems.put(ELEM_PU_META, ELEM_PU_META);\r\n+        _elems.put(ELEM_PU_DEF, ELEM_PU_DEF);\r\n+        _elems.put(\"entity-listeners\", ENTITY_LISTENERS);\r\n+        _elems.put(\"pre-persist\", PRE_PERSIST);\r\n+        _elems.put(\"post-persist\", POST_PERSIST);\r\n+        _elems.put(\"pre-remove\", PRE_REMOVE);\r\n+        _elems.put(\"post-remove\", POST_REMOVE);\r\n+        _elems.put(\"pre-update\", PRE_UPDATE);\r\n+        _elems.put(\"post-update\", POST_UPDATE);\r\n+        _elems.put(\"post-load\", POST_LOAD);\r\n+        _elems.put(\"exclude-default-listeners\", EXCLUDE_DEFAULT_LISTENERS);\r\n+        _elems.put(\"exclude-superclass-listeners\",\r\n+            EXCLUDE_SUPERCLASS_LISTENERS);\r\n+        _elems.put(\"named-query\", QUERY);\r\n+        _elems.put(\"named-native-query\", NATIVE_QUERY);\r\n+        _elems.put(\"query-hint\", QUERY_HINT);\r\n+        _elems.put(\"flush-mode\", FLUSH_MODE);\r\n+        _elems.put(\"sequence-generator\", SEQ_GENERATOR);\r\n+        _elems.put(\"id\", ID);\r\n+        _elems.put(\"id-class\", ID_CLASS);\r\n+        _elems.put(\"embedded-id\", EMBEDDED_ID);\r\n+        _elems.put(\"version\", VERSION);\r\n+        _elems.put(\"generated-value\", GENERATED_VALUE);\r\n+        _elems.put(\"map-key\", MAP_KEY);\r\n+        _elems.put(\"order-by\", ORDER_BY);\r\n+        _elems.put(\"lob\", LOB);\r\n+        _elems.put(\"basic\", BASIC);\r\n+        _elems.put(\"many-to-one\", MANY_ONE);\r\n+        _elems.put(\"one-to-one\", ONE_ONE);\r\n+        _elems.put(\"embedded\", EMBEDDED);\r\n+        _elems.put(\"one-to-many\", ONE_MANY);\r\n+        _elems.put(\"many-to-many\", MANY_MANY);\r\n+        _elems.put(\"transient\", TRANSIENT);\r\n+    }\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (XMLPersistenceMetaDataParser.class);\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private MetaDataRepository _repos = null;\r\n+    private AnnotationPersistenceMetaDataParser _parser = null;\r\n+    private ClassLoader _envLoader = null;\r\n+    private int _mode = MODE_NONE;\r\n+    private boolean _override = false;\r\n+    private final Stack _elements = new Stack();\r\n+    private final Stack _parents = new Stack();\r\n+    private Class _cls = null;\r\n+    private int _fieldPos = 0;\r\n+    private int _clsPos = 0;\r\n+    private int _access = ClassMetaData.ACCESS_UNKNOWN;\r\n+    private PersistenceStrategy _strategy = null;\r\n+    private Set<CascadeType> _cascades = null;\r\n+    private Set<CascadeType> _pkgCascades = null;\r\n+    private Class _listener = null;\r\n+    private Collection<LifecycleCallbacks>[] _callbacks = null;\r\n+    private int[] _highs = null;\r\n+\r\n+    /**\r\n+     * Constructor; supply configuration.\r\n+     */\r\n+    public XMLPersistenceMetaDataParser(OpenJPAConfiguration conf) {\r\n+        _conf = conf;\r\n+        setValidating(true);\r\n+        setLog(conf.getLog(OpenJPAConfiguration.LOG_METADATA));\r\n+        setParseComments(true);\r\n+        setMode(MODE_META | MODE_MAPPING | MODE_QUERY);\r\n+        setParseText(true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configuration supplied on construction.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * The annotation parser. When class is discovered in an XML file,\r\n+     * we first parse any annotations present, then override with the XML.\r\n+     */\r\n+    public AnnotationPersistenceMetaDataParser getAnnotationParser() {\r\n+        return _parser;\r\n+    }\r\n+\r\n+    /**\r\n+     * The annotation parser. When class is discovered in an XML file,\r\n+     * we first parse any annotations present, then override with the XML.\r\n+     */\r\n+    public void setAnnotationParser(\r\n+        AnnotationPersistenceMetaDataParser parser) {\r\n+        _parser = parser;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the repository for this parser. If none has been set, creates\r\n+     * a new repository and sets it.\r\n+     */\r\n+    public MetaDataRepository getRepository() {\r\n+        if (_repos == null) {\r\n+            MetaDataRepository repos = newRepository();\r\n+            MetaDataFactory mdf = repos.getMetaDataFactory();\r\n+            if (mdf instanceof DelegatingMetaDataFactory)\r\n+                mdf = ((DelegatingMetaDataFactory) mdf).getInnermostDelegate();\r\n+            if (mdf instanceof PersistenceMetaDataFactory)\r\n+                ((PersistenceMetaDataFactory) mdf).setXMLParser(this);\r\n+            _repos = repos;\r\n+        }\r\n+        return _repos;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new metadata repository.\r\n+     */\r\n+    protected MetaDataRepository newRepository() {\r\n+        return new MetaDataRepository(_conf);\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the metadata repository for this parser.\r\n+     */\r\n+    public void setRepository(MetaDataRepository repos) {\r\n+        _repos = repos;\r\n+        if (repos != null\r\n+            && (repos.getValidate() & repos.VALIDATE_RUNTIME) != 0)\r\n+            setParseComments(false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the environmental class loader to pass on to parsed\r\n+     * metadata instances.\r\n+     */\r\n+    public ClassLoader getEnvClassLoader() {\r\n+        return _envLoader;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the environmental class loader to pass on to parsed\r\n+     * metadata instances.\r\n+     */\r\n+    public void setEnvClassLoader(ClassLoader loader) {\r\n+        _envLoader = loader;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to allow later parses of mapping information to override\r\n+     * earlier information for the same class. Defaults to false. Useful\r\n+     * when a tool is mapping a class, so that .jdo file partial mapping\r\n+     * information can be used even when mappings are stored in .orm files\r\n+     * or other locations.\r\n+     */\r\n+    public boolean getMappingOverride() {\r\n+        return _override;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to allow later parses of mapping information to override\r\n+     * earlier information for the same class. Defaults to false. Useful\r\n+     * when a tool is mapping a class, so that .jdo file partial mapping\r\n+     * information can be used even when mappings are stored in .orm files\r\n+     * or other locations.\r\n+     */\r\n+    public void setMappingOverride(boolean override) {\r\n+        _override = override;\r\n+    }\r\n+\r\n+    /**\r\n+     * The parse mode according to the expected document type. The\r\n+     * mode constants act as bit flags, and therefore can be combined.\r\n+     */\r\n+    public int getMode() {\r\n+        return _mode;\r\n+    }\r\n+\r\n+    /**\r\n+     * The parse mode according to the expected document type.\r\n+     */\r\n+    public void setMode(int mode, boolean on) {\r\n+        if (mode == MODE_NONE)\r\n+            setMode(MODE_NONE);\r\n+        else if (on)\r\n+            setMode(_mode | mode);\r\n+        else setMode(_mode & ~mode);\r\n+    }\r\n+\r\n+    /**\r\n+     * The parse mode according to the expected document type.\r\n+     */\r\n+    public void setMode(int mode) {\r\n+        _mode = mode;\r\n+        if (_parser != null)\r\n+            _parser.setMode(mode);\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isMetaDataMode() {\r\n+        return (_mode & MODE_META) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isQueryMode() {\r\n+        return (_mode & MODE_QUERY) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isMappingMode() {\r\n+        return (_mode & MODE_MAPPING) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if we're in mapping mode or in metadata mode with\r\n+     * mapping override enabled.\r\n+     */\r\n+    protected boolean isMappingOverrideMode() {\r\n+        return isMappingMode() || (_override && isMetaDataMode());\r\n+    }\r\n+    ///////////////\r\n+    // XML parsing\r\n+    ///////////////\r\n+\r\n+    /**\r\n+     * Push a parse element onto the stack.\r\n+     */\r\n+    protected void pushElement(Object elem) {\r\n+        _elements.push(elem);\r\n+    }\r\n+\r\n+    /**\r\n+     * Pop a parse element from the stack.\r\n+     */\r\n+    protected Object popElement() {\r\n+        return _elements.pop();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the current element being parsed. May be a class metadata,\r\n+     * field metadata, query metadata, etc.\r\n+     */\r\n+    protected Object currentElement() {\r\n+        if (_elements.isEmpty())\r\n+            return null;\r\n+        return _elements.peek();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the current {@link PersistenceStrategy} if any.\r\n+     */\r\n+    protected PersistenceStrategy currentStrategy() {\r\n+        return _strategy;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the tag of the current parent element.\r\n+     */\r\n+    protected Object currentParent() {\r\n+        if (_parents.isEmpty())\r\n+            return null;\r\n+        return _parents.peek();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return whether we're running the parser at runtime.\r\n+     */\r\n+    protected boolean isRuntime() {\r\n+        return (getRepository().getValidate()\r\n+            & MetaDataRepository.VALIDATE_RUNTIME) != 0;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected Object getSchemaSource() {\r\n+        return XMLPersistenceMetaDataParser.class.getResourceAsStream\r\n+            (\"orm-xsd.rsrc\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getPackageAttributeName() {\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getClassAttributeName() {\r\n+        return \"class\";\r\n+    }\r\n+\r\n+    @Override\r\n+    protected int getClassElementDepth() {\r\n+        return 1;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected boolean isClassElementName(String name) {\r\n+        return \"entity\".equals(name)\r\n+            || \"embeddable\".equals(name)\r\n+            || \"mapped-superclass\".equals(name);\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void reset() {\r\n+        super.reset();\r\n+        _elements.clear();\r\n+        _parents.clear();\r\n+        _cls = null;\r\n+        _fieldPos = 0;\r\n+        _clsPos = 0;\r\n+        _access = ClassMetaData.ACCESS_UNKNOWN;\r\n+        _strategy = null;\r\n+        _listener = null;\r\n+        _callbacks = null;\r\n+        _highs = null;\r\n+        _cascades = null;\r\n+        _pkgCascades = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected boolean startSystemElement(String name, Attributes attrs)\r\n+        throws SAXException {\r\n+        Object tag = (Object) _elems.get(name);\r\n+        boolean ret = false;\r\n+        if (tag == null) {\r\n+            if (isMappingOverrideMode())\r\n+                tag = startSystemMappingElement(name, attrs);\r\n+            ret = tag != null;\r\n+        } else if (tag instanceof MetaDataTag) {\r\n+            switch ((MetaDataTag) tag) {\r\n+                case QUERY:\r\n+                    ret = startNamedQuery(attrs);\r\n+                    break;\r\n+                case QUERY_HINT:\r\n+                    ret = startQueryHint(attrs);\r\n+                    break;\r\n+                case NATIVE_QUERY:\r\n+                    ret = startNamedNativeQuery(attrs);\r\n+                    break;\r\n+                case SEQ_GENERATOR:\r\n+                    ret = startSequenceGenerator(attrs);\r\n+                    break;\r\n+                case FLUSH_MODE:\r\n+                    ret = startFlushMode(attrs);\r\n+                    break;\r\n+                case ENTITY_LISTENERS:\r\n+                    ret = startEntityListeners(attrs);\r\n+                    break;\r\n+                default:\r\n+                    warnUnsupportedTag(name);\r\n+            }\r\n+        } else if (tag == ELEM_PU_META || tag == ELEM_PU_DEF)\r\n+            ret = isMetaDataMode();\r\n+        else if (tag == ELEM_ACCESS)\r\n+            ret = _mode != MODE_QUERY;\r\n+        else if (tag == ELEM_LISTENER)\r\n+            ret = startEntityListener(attrs);\r\n+        else if (tag == ELEM_CASCADE)\r\n+            ret = isMetaDataMode();\r\n+        else if (tag == ELEM_CASCADE_ALL || tag == ELEM_CASCADE_PER\r\n+            || tag == ELEM_CASCADE_MER || tag == ELEM_CASCADE_REM\r\n+            || tag == ELEM_CASCADE_REF)\r\n+            ret = startCascade(tag, attrs);\r\n+        if (ret)\r\n+            _parents.push(tag);\r\n+        return ret;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void endSystemElement(String name) throws SAXException {\r\n+        Object tag = _elems.get(name);\r\n+        if (tag == null && isMappingOverrideMode())\r\n+            endSystemMappingElement(name);\r\n+        else if (tag instanceof MetaDataTag) {\r\n+            switch ((MetaDataTag) tag) {\r\n+                case QUERY:\r\n+                    endNamedQuery();\r\n+                    break;\r\n+                case QUERY_HINT:\r\n+                    endQueryHint();\r\n+                    break;\r\n+                case NATIVE_QUERY:\r\n+                    endNamedNativeQuery();\r\n+                    break;\r\n+                case SEQ_GENERATOR:\r\n+                    endSequenceGenerator();\r\n+                    break;\r\n+            }\r\n+        } else if (tag == ELEM_ACCESS)\r\n+            endAccess();\r\n+        else if (tag == ELEM_LISTENER)\r\n+            endEntityListener();\r\n+        _parents.pop();\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to parse a mapping element outside of any class.\r\n+     *\r\n+     * @return the tag for the given element, or null to skip the element\r\n+     */\r\n+    protected Object startSystemMappingElement(String name, Attributes attrs)\r\n+        throws SAXException {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to parse a mapping element outside of any class.\r\n+     */\r\n+    protected void endSystemMappingElement(String name) throws SAXException {\r\n+    }\r\n+\r\n+    @Override\r\n+    protected boolean startClassElement(String name, Attributes attrs)\r\n+        throws SAXException {\r\n+        Object tag = (Object) _elems.get(name);\r\n+        boolean ret = false;\r\n+        if (tag == null) {\r\n+            if (isMappingOverrideMode())\r\n+                tag = startClassMappingElement(name, attrs);\r\n+            ret = tag != null;\r\n+        } else if (tag instanceof MetaDataTag) {\r\n+            switch ((MetaDataTag) tag) {\r\n+                case GENERATED_VALUE:\r\n+                    ret = startGeneratedValue(attrs);\r\n+                    break;\r\n+                case ID:\r\n+                    ret = startId(attrs);\r\n+                    break;\r\n+                case EMBEDDED_ID:\r\n+                    ret = startEmbeddedId(attrs);\r\n+                    break;\r\n+                case ID_CLASS:\r\n+                    ret = startIdClass(attrs);\r\n+                    break;\r\n+                case LOB:\r\n+                    ret = startLob(attrs);\r\n+                    break;\r\n+                case QUERY:\r\n+                    ret = startNamedQuery(attrs);\r\n+                    break;\r\n+                case QUERY_HINT:\r\n+                    ret = startQueryHint(attrs);\r\n+                    break;\r\n+                case NATIVE_QUERY:\r\n+                    ret = startNamedNativeQuery(attrs);\r\n+                    break;\r\n+                case SEQ_GENERATOR:\r\n+                    ret = startSequenceGenerator(attrs);\r\n+                    break;\r\n+                case VERSION:\r\n+                    ret = startVersion(attrs);\r\n+                    break;\r\n+                case MAP_KEY:\r\n+                    ret = startMapKey(attrs);\r\n+                    break;\r\n+                case FLUSH_MODE:\r\n+                    ret = startFlushMode(attrs);\r\n+                    break;\r\n+                case ORDER_BY:\r\n+                case ENTITY_LISTENERS:\r\n+                    ret = isMetaDataMode();\r\n+                    break;\r\n+                case EXCLUDE_DEFAULT_LISTENERS:\r\n+                    ret = startExcludeDefaultListeners(attrs);\r\n+                    break;\r\n+                case EXCLUDE_SUPERCLASS_LISTENERS:\r\n+                    ret = startExcludeSuperclassListeners(attrs);\r\n+                    break;\r\n+                case PRE_PERSIST:\r\n+                case POST_PERSIST:\r\n+                case PRE_REMOVE:\r\n+                case POST_REMOVE:\r\n+                case PRE_UPDATE:\r\n+                case POST_UPDATE:\r\n+                case POST_LOAD:\r\n+                    ret = startCallback((MetaDataTag) tag, attrs);\r\n+                    break;\r\n+                default:\r\n+                    warnUnsupportedTag(name);\r\n+            }\r\n+        } else if (tag instanceof PersistenceStrategy) {\r\n+            ret = startStrategy((PersistenceStrategy) tag, attrs);\r\n+            if (ret)\r\n+                _strategy = (PersistenceStrategy) tag;\r\n+        } else if (tag == ELEM_LISTENER)\r\n+            ret = startEntityListener(attrs);\r\n+        else if (tag == ELEM_ATTRS)\r\n+            ret = _mode != MODE_QUERY;\r\n+        else if (tag == ELEM_CASCADE)\r\n+            ret = isMetaDataMode();\r\n+        else if (tag == ELEM_CASCADE_ALL || tag == ELEM_CASCADE_PER\r\n+            || tag == ELEM_CASCADE_MER || tag == ELEM_CASCADE_REM\r\n+            || tag == ELEM_CASCADE_REF)\r\n+            ret = startCascade(tag, attrs);\r\n+        if (ret)\r\n+            _parents.push(tag);\r\n+        return ret;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void endClassElement(String name) throws SAXException {\r\n+        Object tag = _elems.get(name);\r\n+        if (tag == null && isMappingOverrideMode())\r\n+            endClassMappingElement(name);\r\n+        else if (tag instanceof MetaDataTag) {\r\n+            switch ((MetaDataTag) tag) {\r\n+                case GENERATED_VALUE:\r\n+                    endGeneratedValue();\r\n+                    break;\r\n+                case ID:\r\n+                    endId();\r\n+                    break;\r\n+                case EMBEDDED_ID:\r\n+                    endEmbeddedId();\r\n+                    break;\r\n+                case ID_CLASS:\r\n+                    endIdClass();\r\n+                    break;\r\n+                case LOB:\r\n+                    endLob();\r\n+                    break;\r\n+                case QUERY:\r\n+                    endNamedQuery();\r\n+                    break;\r\n+                case QUERY_HINT:\r\n+                    endQueryHint();\r\n+                    break;\r\n+                case NATIVE_QUERY:\r\n+                    endNamedNativeQuery();\r\n+                    break;\r\n+                case SEQ_GENERATOR:\r\n+                    endSequenceGenerator();\r\n+                    break;\r\n+                case VERSION:\r\n+                    endVersion();\r\n+                    break;\r\n+                case ORDER_BY:\r\n+                    endOrderBy();\r\n+                    break;\r\n+            }\r\n+        } else if (tag instanceof PersistenceStrategy)\r\n+            endStrategy((PersistenceStrategy) tag);\r\n+        else if (tag == ELEM_ACCESS)\r\n+            endAccess();\r\n+        else if (tag == ELEM_LISTENER)\r\n+            endEntityListener();\r\n+        _parents.pop();\r\n+    }\r\n+\r\n+    /**\r\n+     * Log warning about an unsupported tag.\r\n+     */\r\n+    private void warnUnsupportedTag(String name) {\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.trace(_loc.get(\"unsupported-tag\", name));\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to parse a mapping element within a class.\r\n+     *\r\n+     * @return the tag for the given element, or null to skip element\r\n+     */\r\n+    protected Object startClassMappingElement(String name, Attributes attrs)\r\n+        throws SAXException {\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to parse a mapping element within a class.\r\n+     */\r\n+    protected void endClassMappingElement(String name) throws SAXException {\r\n+    }\r\n+\r\n+    @Override\r\n+    protected boolean startClass(String elem, Attributes attrs)\r\n+        throws SAXException {\r\n+        super.startClass(elem, attrs);\r\n+        // query mode only?\r\n+        _cls = classForName(currentClassName());\r\n+        if (_mode == MODE_QUERY) {\r\n+            if (_parser != null)\r\n+                _parser.parse(_cls);\r\n+            return true;\r\n+        }\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"parse-class\", _cls.getName()));\r\n+        MetaDataRepository repos = getRepository();\r\n+        ClassMetaData meta = repos.getCachedMetaData(_cls);\r\n+        if (meta != null\r\n+            && ((isMetaDataMode() && (meta.getSourceMode() & MODE_META) != 0)\r\n+            || (isMappingMode() && (meta.getSourceMode() & MODE_MAPPING) != 0)))\r\n+        {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(_loc.get(\"dup-metadata\", _cls, getSourceName()));\r\n+            _cls = null;\r\n+            return false;\r\n+        }\r\n+        if (meta == null) {\r\n+            // add metadata for this type\r\n+            int access = toAccessType(attrs.getValue(\"access\"), _access);\r\n+            meta = repos.addMetaData(_cls, access);\r\n+            meta.setEnvClassLoader(_envLoader);\r\n+            meta.setSourceMode(MODE_NONE);\r\n+            // parse annotations first so XML overrides them\r\n+            if (_parser != null)\r\n+                _parser.parse(_cls);\r\n+        }\r\n+        boolean mappedSuper = \"mapped-superclass\".equals(elem);\r\n+        if (isMetaDataMode()) {\r\n+            meta.setSource(getSourceFile(), meta.SRC_XML);\r\n+            meta.setSourceMode(MODE_META, true);\r\n+            meta.setListingIndex(_clsPos);\r\n+            meta.setEmbeddedOnly(mappedSuper || \"embeddable\".equals(elem));\r\n+            if (mappedSuper)\r\n+                meta.setIdentityType(meta.ID_UNKNOWN);\r\n+        }\r\n+        if (isMappingMode())\r\n+            meta.setSourceMode(MODE_MAPPING, true);\r\n+        if (isMappingOverrideMode())\r\n+            startClassMapping(meta, mappedSuper, attrs);\r\n+        if (isQueryMode())\r\n+            meta.setSourceMode(MODE_QUERY, true);\r\n+        _clsPos++;\r\n+        _fieldPos = 0;\r\n+        addComments(meta);\r\n+        pushElement(meta);\r\n+        return true;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void endClass(String elem) throws SAXException {\r\n+        if (_mode != MODE_QUERY) {\r\n+            ClassMetaData meta = (ClassMetaData) popElement();\r\n+            storeCallbacks(meta);\r\n+            if (isMappingOverrideMode())\r\n+                endClassMapping(meta);\r\n+        }\r\n+        _cls = null;\r\n+        super.endClass(elem);\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to add mapping attributes to class.\r\n+     */\r\n+    protected void startClassMapping(ClassMetaData mapping,\r\n+        boolean mappedSuper, Attributes attrs) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to finalize class mapping.\r\n+     */\r\n+    protected void endClassMapping(ClassMetaData mapping) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Default access element.\r\n+     */\r\n+    private void endAccess() {\r\n+        _access = toAccessType(currentText(), ClassMetaData.ACCESS_UNKNOWN);\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse the given string as an entity access type, defaulting to given\r\n+     * default if string is empty.\r\n+     */\r\n+    private int toAccessType(String str, int def) {\r\n+        if (StringUtils.isEmpty(str))\r\n+            return def;\r\n+        if (\"PROPERTY\".equals(str))\r\n+            return ClassMetaData.ACCESS_PROPERTY;\r\n+        return ClassMetaData.ACCESS_FIELD;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse flush-mode element.\r\n+     */\r\n+    private boolean startFlushMode(Attributes attrs) throws SAXException {\r\n+        Log log = getLog();\r\n+        if (log.isWarnEnabled())\r\n+            log.warn(_loc.get(\"unsupported\", \"flush-mode\", getSourceName()));\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse sequence-generator.\r\n+     */\r\n+    protected boolean startSequenceGenerator(Attributes attrs) {\r\n+        if (!isMappingOverrideMode())\r\n+            return false;\r\n+        String name = attrs.getValue(\"name\");\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"parse-sequence\", name));\r\n+        SequenceMetaData meta = getRepository().getCachedSequenceMetaData(name);\r\n+        if (meta != null && log.isWarnEnabled())\r\n+            log.warn(_loc.get(\"override-sequence\", name));\r\n+        meta = getRepository().addSequenceMetaData(name);\r\n+        String seq = attrs.getValue(\"sequence-name\");\r\n+        String val = attrs.getValue(\"initial-value\");\r\n+        int initial = val == null ? 1 : Integer.parseInt(val);\r\n+        val = attrs.getValue(\"allocation-size\");\r\n+        int allocate = val == null ? 50 : Integer.parseInt(val);\r\n+        String clsName, props;\r\n+        if (seq == null || seq.indexOf('(') == -1) {\r\n+            clsName = SequenceMetaData.IMPL_NATIVE;\r\n+            props = null;\r\n+        } else { // plugin\r\n+            seq = null;\r\n+            clsName = Configurations.getClassName(seq);\r\n+            props = Configurations.getProperties(seq);\r\n+        }\r\n+        meta.setSequencePlugin(Configurations.getPlugin(clsName, props));\r\n+        meta.setSequence(seq);\r\n+        meta.setInitialValue(initial);\r\n+        meta.setAllocate(allocate);\r\n+        Object cur = currentElement();\r\n+        Object scope = (cur instanceof ClassMetaData)\r\n+            ? ((ClassMetaData) cur).getDescribedType() : null;\r\n+        meta.setSource(getSourceFile(), scope, meta.SRC_XML);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endSequenceGenerator() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse id.\r\n+     */\r\n+    protected boolean startId(Attributes attrs) throws SAXException {\r\n+        FieldMetaData fmd = parseField(attrs);\r\n+        fmd.setExplicit(true);\r\n+        fmd.setPrimaryKey(true);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endId() throws SAXException {\r\n+        finishField();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse embedded-id.\r\n+     */\r\n+    protected boolean startEmbeddedId(Attributes attrs) throws SAXException {\r\n+        FieldMetaData fmd = parseField(attrs);\r\n+        fmd.setExplicit(true);\r\n+        fmd.setPrimaryKey(true);\r\n+        fmd.setEmbedded(true);\r\n+        if (fmd.getEmbeddedMetaData() == null)\r\n+            fmd.addEmbeddedMetaData();\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endEmbeddedId() throws SAXException {\r\n+        finishField();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse id-class.\r\n+     */\r\n+    protected boolean startIdClass(Attributes attrs) throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        ClassMetaData meta = (ClassMetaData) currentElement();\r\n+        String cls = attrs.getValue(\"class\");\r\n+        Class idCls = null;\r\n+        try {\r\n+            idCls = classForName(cls);\r\n+        } catch (Throwable t) {\r\n+            throw getException(_loc.get(\"invalid-id-class\", meta, cls), t);\r\n+        }\r\n+        meta.setObjectIdType(idCls, true);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endIdClass() throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse lob.\r\n+     */\r\n+    protected boolean startLob(Attributes attrs) throws SAXException {\r\n+        FieldMetaData fmd = (FieldMetaData) currentElement();\r\n+        if (fmd.getDeclaredTypeCode() != JavaTypes.STRING\r\n+            && fmd.getDeclaredType() != char[].class\r\n+            && fmd.getDeclaredType() != Character[].class\r\n+            && fmd.getDeclaredType() != byte[].class\r\n+            && fmd.getDeclaredType() != Byte[].class)\r\n+            fmd.setSerialized(true);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endLob() throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse generated-value.\r\n+     */\r\n+    protected boolean startGeneratedValue(Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isMappingOverrideMode())\r\n+            return false;\r\n+        String strategy = attrs.getValue(\"strategy\");\r\n+        String generator = attrs.getValue(\"generator\");\r\n+        // TODO UUID_HEX / UUID_STRING\r\n+        FieldMetaData fmd = (FieldMetaData) currentElement();\r\n+        if (StringUtils.isEmpty(strategy) || \"AUTO\".equals(strategy))\r\n+            fmd.setValueSequenceName(SequenceMetaData.NAME_SYSTEM);\r\n+        else if (\"TABLE\".equals(strategy) || \"SEQUENCE\".equals(strategy)) {\r\n+            if (StringUtils.isEmpty(generator))\r\n+                fmd.setValueSequenceName(SequenceMetaData.NAME_SYSTEM);\r\n+            else fmd.setValueSequenceName(generator);\r\n+        } else if (\"IDENTITY\".equals(strategy))\r\n+            fmd.setValueStrategy(ValueStrategies.AUTOASSIGN);\r\n+        else throw new UnsupportedException(strategy);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endGeneratedValue() throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Lazily parse cascades.\r\n+     */\r\n+    protected boolean startCascade(Object tag, Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        Set<CascadeType> cascades = null;\r\n+        if (currentElement() instanceof FieldMetaData) {\r\n+            if (_cascades == null)\r\n+                _cascades = EnumSet.noneOf(CascadeType.class);\r\n+            cascades = _cascades;\r\n+        } else {\r\n+            if (_pkgCascades == null)\r\n+                _pkgCascades = EnumSet.noneOf(CascadeType.class);\r\n+            cascades = _pkgCascades;\r\n+        }\r\n+        boolean all = ELEM_CASCADE_ALL == tag;\r\n+        if (all || ELEM_CASCADE_PER == tag)\r\n+            cascades.add(PERSIST);\r\n+        if (all || ELEM_CASCADE_REM == tag)\r\n+            cascades.add(REMOVE);\r\n+        if (all || ELEM_CASCADE_MER == tag)\r\n+            cascades.add(MERGE);\r\n+        if (all || ELEM_CASCADE_REF == tag)\r\n+            cascades.add(REFRESH);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the cached cascades into the field.\r\n+     */\r\n+    protected void setCascades(FieldMetaData fmd) {\r\n+        Set<CascadeType> cascades = _cascades;\r\n+        if (_cascades == null)\r\n+            cascades = _pkgCascades;\r\n+        if (cascades == null)\r\n+            return;\r\n+        ValueMetaData vmd = fmd;\r\n+        switch (_strategy) {\r\n+            case ONE_MANY:\r\n+            case MANY_MANY:\r\n+                vmd = fmd.getElement();\r\n+        }\r\n+        for (CascadeType cascade : cascades) {\r\n+            switch (cascade) {\r\n+                case PERSIST:\r\n+                    vmd.setCascadePersist(ValueMetaData.CASCADE_IMMEDIATE);\r\n+                    break;\r\n+                case MERGE:\r\n+                    vmd.setCascadeAttach(ValueMetaData.CASCADE_IMMEDIATE);\r\n+                    break;\r\n+                case REMOVE:\r\n+                    vmd.setCascadeDelete(ValueMetaData.CASCADE_IMMEDIATE);\r\n+                    break;\r\n+                case REFRESH:\r\n+                    vmd.setCascadeRefresh(ValueMetaData.CASCADE_IMMEDIATE);\r\n+                    break;\r\n+            }\r\n+        }\r\n+        _cascades = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse common field attributes.\r\n+     */\r\n+    private FieldMetaData parseField(Attributes attrs) throws SAXException {\r\n+        ClassMetaData meta = (ClassMetaData) currentElement();\r\n+        String name = attrs.getValue(\"name\");\r\n+        FieldMetaData field = meta.getDeclaredField(name);\r\n+        if ((field == null || field.getDeclaredType() == Object.class)\r\n+            && meta.getDescribedType() != Object.class) {\r\n+            Member member = null;\r\n+            Class type = null;\r\n+            int def = _repos.getMetaDataFactory().getDefaults().\r\n+                getDefaultAccessType();\r\n+            try {\r\n+                if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY\r\n+                    || (meta.getAccessType() == ClassMetaData.ACCESS_UNKNOWN\r\n+                    && def == ClassMetaData.ACCESS_PROPERTY)) {\r\n+                    String cap = StringUtils.capitalize(name);\r\n+                    type = meta.getDescribedType();\r\n+                    try {\r\n+                        member = type.getDeclaredMethod(\"get\" + cap,\r\n+                            (Class[]) null); // varargs disambiguate\r\n+                    } catch (Exception excep) {\r\n+                        try {\r\n+                            member = type.getDeclaredMethod(\"is\" + cap,\r\n+                                (Class[]) null);\r\n+                        } catch (Exception excep2) {\r\n+                            throw excep;\r\n+                        }\r\n+                    }\r\n+                    type = ((Method) member).getReturnType();\r\n+                } else {\r\n+                    member = meta.getDescribedType().getDeclaredField(name);\r\n+                    type = ((Field) member).getType();\r\n+                }\r\n+            } catch (Exception e) {\r\n+                throw getException(_loc.get(\"invalid-attr\", name, meta), e);\r\n+            }\r\n+            if (field == null) {\r\n+                field = meta.addDeclaredField(name, type);\r\n+                PersistenceMetaDataDefaults.setCascadeNone(field);\r\n+                PersistenceMetaDataDefaults.setCascadeNone(field.getKey());\r\n+                PersistenceMetaDataDefaults.setCascadeNone\r\n+                    (field.getElement());\r\n+            }\r\n+            field.backingMember(member);\r\n+        } else if (field == null) {\r\n+            field = meta.addDeclaredField(name, Object.class);\r\n+            PersistenceMetaDataDefaults.setCascadeNone(field);\r\n+            PersistenceMetaDataDefaults.setCascadeNone(field.getKey());\r\n+            PersistenceMetaDataDefaults.setCascadeNone(field.getElement());\r\n+        }\r\n+        if (isMetaDataMode())\r\n+            field.setListingIndex(_fieldPos);\r\n+        _fieldPos++;\r\n+        pushElement(field);\r\n+        addComments(field);\r\n+        if (isMappingOverrideMode())\r\n+            startFieldMapping(field, attrs);\r\n+        return field;\r\n+    }\r\n+\r\n+    /**\r\n+     * Pops field element.\r\n+     */\r\n+    private void finishField() throws SAXException {\r\n+        FieldMetaData field = (FieldMetaData) popElement();\r\n+        setCascades(field);\r\n+        if (isMappingOverrideMode())\r\n+            endFieldMapping(field);\r\n+        _strategy = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to add field mapping data. Does nothing by default.\r\n+     */\r\n+    protected void startFieldMapping(FieldMetaData field, Attributes attrs)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement to finalize field mapping. Does nothing by default.\r\n+     */\r\n+    protected void endFieldMapping(FieldMetaData field) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse version.\r\n+     */\r\n+    protected boolean startVersion(Attributes attrs) throws SAXException {\r\n+        FieldMetaData fmd = parseField(attrs);\r\n+        fmd.setExplicit(true);\r\n+        fmd.setVersion(true);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endVersion() throws SAXException {\r\n+        finishField();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse strategy element.\r\n+     */\r\n+    private boolean startStrategy(PersistenceStrategy strategy,\r\n+        Attributes attrs) throws SAXException {\r\n+        FieldMetaData fmd = parseField(attrs);\r\n+        fmd.setExplicit(true);\r\n+        fmd.setManagement(FieldMetaData.MANAGE_PERSISTENT);\r\n+        String val = attrs.getValue(\"fetch\");\r\n+        if (val != null)\r\n+            fmd.setInDefaultFetchGroup(\"EAGER\".equals(val));\r\n+        val = attrs.getValue(\"optional\");\r\n+        if (\"false\".equals(val))\r\n+            fmd.setNullValue(FieldMetaData.NULL_EXCEPTION);\r\n+        if (isMappingOverrideMode()) {\r\n+            val = attrs.getValue(\"mapped-by\");\r\n+            if (val != null)\r\n+                fmd.setMappedBy(val);\r\n+        }\r\n+        parseStrategy(fmd, strategy, attrs);\r\n+        return true;\r\n+    }\r\n+\r\n+    private void endStrategy(PersistenceStrategy strategy) throws SAXException {\r\n+        finishField();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse strategy specific attributes.\r\n+     */\r\n+    private void parseStrategy(FieldMetaData fmd,\r\n+        PersistenceStrategy strategy, Attributes attrs) throws SAXException {\r\n+        switch (strategy) {\r\n+            case BASIC:\r\n+                parseBasic(fmd, attrs);\r\n+                break;\r\n+            case EMBEDDED:\r\n+                parseEmbedded(fmd, attrs);\r\n+                break;\r\n+            case ONE_ONE:\r\n+                parseOneToOne(fmd, attrs);\r\n+                break;\r\n+            case MANY_ONE:\r\n+                parseManyToOne(fmd, attrs);\r\n+                break;\r\n+            case MANY_MANY:\r\n+                parseManyToMany(fmd, attrs);\r\n+                break;\r\n+            case ONE_MANY:\r\n+                parseOneToMany(fmd, attrs);\r\n+                break;\r\n+            case TRANSIENT:\r\n+                fmd.setManagement(FieldMetaData.MANAGE_NONE);\r\n+                break;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse basic.\r\n+     */\r\n+    protected void parseBasic(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse embedded.\r\n+     */\r\n+    protected void parseEmbedded(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+        assertPC(fmd, \"Embedded\");\r\n+        fmd.setEmbedded(true);\r\n+        fmd.setSerialized(false); // override any Lob annotation\r\n+        if (fmd.getEmbeddedMetaData() == null)\r\n+            fmd.addEmbeddedMetaData();\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw proper exception if given value is not possibly persistence\r\n+     * capable.\r\n+     */\r\n+    private void assertPC(FieldMetaData fmd, String attr) throws SAXException {\r\n+        if (!JavaTypes.maybePC(fmd))\r\n+            throw getException(_loc.get(\"bad-meta-anno\", fmd, attr));\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse one-to-one.\r\n+     */\r\n+    protected void parseOneToOne(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+        String val = attrs.getValue(\"target-entity\");\r\n+        if (val != null)\r\n+            fmd.setDeclaredType(classForName(val));\r\n+        assertPC(fmd, \"OneToOne\");\r\n+        fmd.setSerialized(false); // override any Lob annotation\r\n+        if (!fmd.isDefaultFetchGroupExplicit())\r\n+            fmd.setInDefaultFetchGroup(true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse many-to-one.\r\n+     */\r\n+    protected void parseManyToOne(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+        String val = attrs.getValue(\"target-entity\");\r\n+        if (val != null)\r\n+            fmd.setDeclaredType(classForName(val));\r\n+        assertPC(fmd, \"ManyToOne\");\r\n+        fmd.setSerialized(false); // override any Lob annotation\r\n+        if (!fmd.isDefaultFetchGroupExplicit())\r\n+            fmd.setInDefaultFetchGroup(true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse many-to-many.\r\n+     */\r\n+    protected void parseManyToMany(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+        String val = attrs.getValue(\"target-entity\");\r\n+        if (val != null)\r\n+            fmd.getElement().setDeclaredType(classForName(val));\r\n+        assertPCCollection(fmd, \"ManyToMany\");\r\n+        fmd.setSerialized(false); // override Lob in annotation\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw exception if given field not a collection of possible persistence\r\n+     * capables.\r\n+     */\r\n+    private void assertPCCollection(FieldMetaData fmd, String attr)\r\n+        throws SAXException {\r\n+        switch (fmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.ARRAY:\r\n+            case JavaTypes.COLLECTION:\r\n+            case JavaTypes.MAP:\r\n+                if (JavaTypes.maybePC(fmd.getElement()))\r\n+                    break;\r\n+                // no break\r\n+            default:\r\n+                throw getException(_loc.get(\"bad-meta-anno\", fmd, attr));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse one-to-many.\r\n+     */\r\n+    protected void parseOneToMany(FieldMetaData fmd, Attributes attrs)\r\n+        throws SAXException {\r\n+        String val = attrs.getValue(\"target-entity\");\r\n+        if (val != null)\r\n+            fmd.getElement().setDeclaredType(classForName(val));\r\n+        assertPCCollection(fmd, \"OneToMany\");\r\n+        fmd.setSerialized(false); // override any Lob annotation\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse map-key.\r\n+     */\r\n+    private boolean startMapKey(Attributes attrs) throws SAXException {\r\n+        if (!isMappingOverrideMode())\r\n+            return false;\r\n+        FieldMetaData fmd = (FieldMetaData) currentElement();\r\n+        String mapKey = attrs.getValue(\"name\");\r\n+        if (mapKey == null)\r\n+            fmd.getKey().setValueMappedBy(ValueMetaData.MAPPED_BY_PK);\r\n+        else fmd.getKey().setValueMappedBy(mapKey);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse order-by.\r\n+     */\r\n+    private void endOrderBy() throws SAXException {\r\n+        FieldMetaData fmd = (FieldMetaData) currentElement();\r\n+        String dec = currentText();\r\n+        if (StringUtils.isEmpty(dec))\r\n+            dec = Order.ELEMENT + \" asc\";\r\n+        fmd.setOrderDeclaration(dec);\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse named-query.\r\n+     */\r\n+    protected boolean startNamedQuery(Attributes attrs) throws SAXException {\r\n+        if (!isQueryMode())\r\n+            return false;\r\n+        String name = attrs.getValue(\"name\");\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"parse-query\", name));\r\n+        QueryMetaData meta = getRepository().getCachedQueryMetaData(null, name);\r\n+        if (meta != null && log.isWarnEnabled())\r\n+            log.warn(_loc.get(\"override-query\", name, currentLocation()));\r\n+        meta = getRepository().addQueryMetaData(null, name);\r\n+        meta.setDefiningType(_cls);\r\n+        meta.setQueryString(attrs.getValue(\"query\"));\r\n+        meta.setLanguage(JPQLParser.LANG_JPQL);\r\n+        Object cur = currentElement();\r\n+        Object scope = (cur instanceof ClassMetaData)\r\n+            ? ((ClassMetaData) cur).getDescribedType() : null;\r\n+        meta.setSource(getSourceFile(), scope, meta.SRC_XML);\r\n+        if (isMetaDataMode())\r\n+            meta.setSourceMode(MODE_META);\r\n+        else if (isMappingMode())\r\n+            meta.setSourceMode(MODE_MAPPING);\r\n+        else meta.setSourceMode(MODE_QUERY);\r\n+        pushElement(meta);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endNamedQuery() throws SAXException {\r\n+        popElement();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse query-hint.\r\n+     */\r\n+    protected boolean startQueryHint(Attributes attrs) throws SAXException {\r\n+        QueryMetaData meta = (QueryMetaData) currentElement();\r\n+        meta.addHint(attrs.getValue(\"name\"), attrs.getValue(\"value\"));\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endQueryHint() throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse native-named-query.\r\n+     */\r\n+    protected boolean startNamedNativeQuery(Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isQueryMode())\r\n+            return false;\r\n+        String name = attrs.getValue(\"name\");\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"parse-native-query\", name));\r\n+        QueryMetaData meta = getRepository().getCachedQueryMetaData(null, name);\r\n+        if (meta != null && log.isWarnEnabled())\r\n+            log.warn(_loc.get(\"override-query\", name, currentLocation()));\r\n+        meta = getRepository().addQueryMetaData(null, name);\r\n+        meta.setDefiningType(_cls);\r\n+        meta.setQueryString(attrs.getValue(\"query\"));\r\n+        meta.setLanguage(QueryLanguages.LANG_SQL);\r\n+        String val = attrs.getValue(\"result-class\");\r\n+        if (val != null) {\r\n+            Class type = classForName(val);\r\n+            if (ImplHelper.isManagedType(type))\r\n+                meta.setCandidateType(type);\r\n+            else meta.setResultType(type);\r\n+        }\r\n+        Object cur = currentElement();\r\n+        Object scope = (cur instanceof ClassMetaData)\r\n+            ? ((ClassMetaData) cur).getDescribedType() : null;\r\n+        meta.setSource(getSourceFile(), scope, meta.SRC_XML);\r\n+        if (isMetaDataMode())\r\n+            meta.setSourceMode(MODE_META);\r\n+        else if (isMappingMode())\r\n+            meta.setSourceMode(MODE_MAPPING);\r\n+        else meta.setSourceMode(MODE_QUERY);\r\n+        pushElement(meta);\r\n+        return true;\r\n+    }\r\n+\r\n+    protected void endNamedNativeQuery() throws SAXException {\r\n+        popElement();\r\n+    }\r\n+\r\n+    /**\r\n+     * Start entity-listeners\r\n+     */\r\n+    private boolean startEntityListeners(Attributes attrs) throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        if (currentElement() == null)\r\n+            return true;\r\n+        // reset listeners declared in annotations.\r\n+        LifecycleMetaData meta = ((ClassMetaData) currentElement()).\r\n+            getLifecycleMetaData();\r\n+        for (int i = 0; i < LifecycleEvent.ALL_EVENTS.length; i++)\r\n+            meta.setDeclaredCallbacks(i, null, 0);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse exclude-default-listeners.\r\n+     */\r\n+    private boolean startExcludeDefaultListeners(Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        ClassMetaData meta = (ClassMetaData) currentElement();\r\n+        meta.getLifecycleMetaData().setIgnoreSystemListeners(true);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse exclude-superclass-listeners.\r\n+     */\r\n+    private boolean startExcludeSuperclassListeners(Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        ClassMetaData meta = (ClassMetaData) currentElement();\r\n+        meta.getLifecycleMetaData().setIgnoreSuperclassCallbacks\r\n+            (LifecycleMetaData.IGNORE_HIGH);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse entity-listener.\r\n+     */\r\n+    private boolean startEntityListener(Attributes attrs) throws SAXException {\r\n+        _listener = classForName(attrs.getValue(\"class\"));\r\n+        boolean system = currentElement() == null;\r\n+        Collection<LifecycleCallbacks>[] parsed =\r\n+            AnnotationPersistenceMetaDataParser.parseCallbackMethods(_listener,\r\n+                null, true, true);\r\n+        if (parsed == null)\r\n+            return true;\r\n+        if (_callbacks == null) {\r\n+            _callbacks = (Collection<LifecycleCallbacks>[])\r\n+                new Collection[LifecycleEvent.ALL_EVENTS.length];\r\n+            if (!system)\r\n+                _highs = new int[LifecycleEvent.ALL_EVENTS.length];\r\n+        }\r\n+        for (int i = 0; i < parsed.length; i++) {\r\n+            if (parsed[i] == null)\r\n+                continue;\r\n+            if (_callbacks[i] == null)\r\n+                _callbacks[i] = parsed[i];\r\n+            else _callbacks[i].addAll(parsed[i]);\r\n+            if (!system)\r\n+                _highs[i] += parsed[i].size();\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    private void endEntityListener() throws SAXException {\r\n+        // should be in endEntityListeners I think to merge callbacks\r\n+        // into a single listener.  But then the user cannot remove.\r\n+        if (currentElement() == null && _callbacks != null) {\r\n+            _repos.addSystemListener(new PersistenceListenerAdapter\r\n+                (_callbacks));\r\n+            _callbacks = null;\r\n+        }\r\n+        _listener = null;\r\n+    }\r\n+\r\n+    private boolean startCallback(MetaDataTag callback, Attributes attrs)\r\n+        throws SAXException {\r\n+        if (!isMetaDataMode())\r\n+            return false;\r\n+        boolean system = currentElement() == null;\r\n+        if (_callbacks == null) {\r\n+            _callbacks = (Collection<LifecycleCallbacks>[])\r\n+                new Collection[LifecycleEvent.ALL_EVENTS.length];\r\n+            if (!system)\r\n+                _highs = new int[LifecycleEvent.ALL_EVENTS.length];\r\n+        }\r\n+        LifecycleCallbacks adapter;\r\n+        if (_listener != null)\r\n+            adapter = new BeanLifecycleCallbacks(_listener,\r\n+                attrs.getValue(\"method-name\"), false);\r\n+        else adapter = new MethodLifecycleCallbacks(_cls,\r\n+            attrs.getValue(\"method-name\"), false);\r\n+        int[] events = getEventTypes(callback);\r\n+        if (events == null)\r\n+            return true;\r\n+        for (int i = 0; i < events.length; i++) {\r\n+            int event = events[i];\r\n+            if (_callbacks[event] == null)\r\n+                _callbacks[event] = new ArrayList<LifecycleCallbacks>(3);\r\n+            _callbacks[event].add(adapter);\r\n+            if (!system && _listener != null)\r\n+                _highs[event]++;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    static int[] getEventTypes(MetaDataTag tag) {\r\n+        switch (tag) {\r\n+            case PRE_PERSIST:\r\n+                return new int[]{ LifecycleEvent.BEFORE_PERSIST };\r\n+            case POST_PERSIST:\r\n+                return new int[]{ LifecycleEvent.AFTER_PERSIST };\r\n+            case PRE_REMOVE:\r\n+                return new int[]{ LifecycleEvent.BEFORE_DELETE };\r\n+            case POST_REMOVE:\r\n+                return new int[]{ LifecycleEvent.AFTER_DELETE };\r\n+            case PRE_UPDATE:\r\n+                return new int[]{ LifecycleEvent.BEFORE_STORE };\r\n+            case POST_UPDATE:\r\n+                return new int[]{ LifecycleEvent.AFTER_STORE };\r\n+            case POST_LOAD:\r\n+                return new int[]{ LifecycleEvent.AFTER_LOAD,\r\n+                    LifecycleEvent.AFTER_REFRESH };\r\n+            default:\r\n+                return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Store lifecycle metadata.\r\n+     */\r\n+    private void storeCallbacks(ClassMetaData cls) {\r\n+        LifecycleMetaData meta = cls.getLifecycleMetaData();\r\n+        Class supCls = cls.getDescribedType().getSuperclass();\r\n+        Collection<LifecycleCallbacks>[] supCalls = null;\r\n+        if (!Object.class.equals(supCls)) {\r\n+            supCalls = AnnotationPersistenceMetaDataParser.parseCallbackMethods\r\n+                (supCls, null, true, false);\r\n+        }\r\n+        if (supCalls != null) {\r\n+            for (int event : LifecycleEvent.ALL_EVENTS) {\r\n+                if (supCalls[event] == null)\r\n+                    continue;\r\n+                meta.setNonPCSuperclassCallbacks(event, supCalls[event].toArray\r\n+                    (new LifecycleCallbacks[supCalls[event].size()]), 0);\r\n+            }\r\n+        }\r\n+        if (_callbacks == null)\r\n+            return;\r\n+        for (int event : LifecycleEvent.ALL_EVENTS) {\r\n+            if (_callbacks[event] == null)\r\n+                continue;\r\n+            meta.setDeclaredCallbacks(event, (LifecycleCallbacks[])\r\n+                _callbacks[event].toArray\r\n+                    (new LifecycleCallbacks[_callbacks[event].size()]),\r\n+                _highs[event]);\r\n+        }\r\n+        _callbacks = null;\r\n+        _highs = null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Instantiate the given class, taking into account the default package.\r\n+     */\r\n+    protected Class classForName(String name) throws SAXException {\r\n+        if (\"Entity\".equals(name))\r\n+            return PersistenceCapable.class;\r\n+        return super.classForName(name, isRuntime());\r\n+    }\r\n+}\r"},{"sha":"4804ac87662d81ee7084f09d8b5fc182994d438f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","status":"added","additions":1341,"deletions":0,"changes":1341,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataSerializer.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1341 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence;\r\n+\r\n+import java.io.File;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Comparator;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.xml.sax.SAXException;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.QueryLanguages;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.meta.CFMetaDataSerializer;\r\n+import org.apache.openjpa.lib.meta.SourceTracker;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataInheritanceComparator;\r\n+import static org.apache.openjpa.meta.MetaDataModes.*;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.meta.Order;\r\n+import org.apache.openjpa.meta.QueryMetaData;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Serializes persistence metadata back to XML.\r\n+ * This class processes all object level tags that are store-agnostic.\r\n+ * However, it provides hooks for the subclasses to include store-specific\r\n+ * tags to be serialized both at &lt;entity-mappings&gt; and\r\n+ * &lt;entity&gt; level.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ * @since 4.0\r\n+ */\r\n+public class XMLPersistenceMetaDataSerializer extends CFMetaDataSerializer\r\n+    implements PersistenceMetaDataFactory.Serializer {\r\n+\r\n+    // NOTE: order is important! these constants must be maintained in\r\n+    // serialization order. constants are spaced so that subclasses can\r\n+    // slip tags in-between\r\n+    protected static final int TYPE_SEQ = 10;\r\n+    protected static final int TYPE_QUERY = 20;\r\n+    protected static final int TYPE_META = 30;\r\n+    protected static final int TYPE_CLASS_SEQS = 40;\r\n+    protected static final int TYPE_CLASS_QUERIES = 50;\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (XMLPersistenceMetaDataSerializer.class);\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private Map<String, ClassMetaData> _metas = null;\r\n+    private Map<String, List> _queries = null;\r\n+    private Map<String, List> _seqs = null;\r\n+    private int _mode = MODE_NONE;\r\n+    private boolean _annos = true;\r\n+    private SerializationComparator _comp = null;\r\n+\r\n+    /**\r\n+     * Constructor. Supply configuration.\r\n+     */\r\n+    public XMLPersistenceMetaDataSerializer(OpenJPAConfiguration conf) {\r\n+        _conf = conf;\r\n+        setLog(conf.getLog(OpenJPAConfiguration.LOG_METADATA));\r\n+        setMode(MODE_META | MODE_MAPPING | MODE_QUERY);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configuration.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to serialize content originally specified in annotations.\r\n+     * Defaults to true.\r\n+     */\r\n+    public boolean getSerializeAnnotations() {\r\n+        return _annos;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether to serialize content originally specified in annotations.\r\n+     * Defaults to true.\r\n+     */\r\n+    public void setSerializeAnnotations(boolean annos) {\r\n+        _annos = annos;\r\n+    }\r\n+\r\n+    /**\r\n+     * The serialization mode according to the expected document type. The\r\n+     * mode constants act as bit flags, and therefore can be combined.\r\n+     */\r\n+    public int getMode() {\r\n+        return _mode;\r\n+    }\r\n+\r\n+    /**\r\n+     * The serialization mode according to the expected document type. The\r\n+     * mode constants act as bit flags, and therefore can be combined.\r\n+     */\r\n+    public void setMode(int mode) {\r\n+        _mode = mode;\r\n+    }\r\n+\r\n+    /**\r\n+     * The serialization mode according to the expected document type.\r\n+     */\r\n+    public void setMode(int mode, boolean on) {\r\n+        if (mode == MODE_NONE)\r\n+            setMode(MODE_NONE);\r\n+        else if (on)\r\n+            setMode(_mode | mode);\r\n+        else setMode(_mode & ~mode);\r\n+    }\r\n+\r\n+    /**\r\n+     * Override to not overwrite annotations.\r\n+     */\r\n+    @Override\r\n+    protected File getSourceFile(Object obj) {\r\n+        File file = super.getSourceFile(obj);\r\n+        if (file == null || file.getName().endsWith(\".java\")\r\n+            || file.getName().endsWith(\".class\"))\r\n+            return null;\r\n+        return file;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isMetaDataMode() {\r\n+        return (_mode & MODE_META) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isQueryMode() {\r\n+        return (_mode & MODE_QUERY) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}.\r\n+     */\r\n+    protected boolean isMappingMode() {\r\n+        return (_mode & MODE_MAPPING) != 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}. Takes into\r\n+     * account whether mapping information is loaded for the given instance.\r\n+     */\r\n+    protected boolean isMappingMode(ClassMetaData meta) {\r\n+        return isMappingMode() && (meta.getSourceMode() & MODE_MAPPING) != 0\r\n+            && (meta.getEmbeddingMetaData() != null || !meta.isEmbeddedOnly())\r\n+            && (meta.getEmbeddingMetaData() == null\r\n+            || isMappingMode(meta.getEmbeddingMetaData()));\r\n+    }\r\n+\r\n+    /**\r\n+     * Convenience method for interpreting {@link #getMode}. Takes into\r\n+     * account whether mapping information is loaded for the given instance.\r\n+     */\r\n+    protected boolean isMappingMode(ValueMetaData vmd) {\r\n+        return isMappingMode(vmd.getFieldMetaData().getDefiningMetaData());\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a class meta data to the set to be serialized.\r\n+     */\r\n+    public void addMetaData(ClassMetaData meta) {\r\n+        if (meta == null)\r\n+            return;\r\n+        if (_metas == null)\r\n+            _metas = new HashMap<String, ClassMetaData>();\r\n+        _metas.put(meta.getDescribedType().getName(), meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a sequence meta data to the set to be serialized.\r\n+     */\r\n+    public void addSequenceMetaData(SequenceMetaData meta) {\r\n+        if (meta == null)\r\n+            return;\r\n+        List seqs = null;\r\n+        String defName = null;\r\n+        if (meta.getSourceScope() instanceof Class)\r\n+            defName = ((Class) meta.getSourceScope()).getName();\r\n+        if (_seqs == null)\r\n+            _seqs = new HashMap<String, List>();\r\n+        else seqs = _seqs.get(defName);\r\n+        if (seqs == null) {\r\n+            seqs = new ArrayList(3); // don't expect many seqs / class\r\n+            seqs.add(meta);\r\n+            _seqs.put(defName, seqs);\r\n+        } else if (!seqs.contains(meta))\r\n+            seqs.add(meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a query meta data to the set to be serialized.\r\n+     */\r\n+    public void addQueryMetaData(QueryMetaData meta) {\r\n+        if (meta == null)\r\n+            return;\r\n+        List queries = null;\r\n+        String defName = null;\r\n+        if (meta.getSourceScope() instanceof Class)\r\n+            defName = ((Class) meta.getSourceScope()).getName();\r\n+        if (_queries == null)\r\n+            _queries = new HashMap<String, List>();\r\n+        else queries = _queries.get(defName);\r\n+        if (queries == null) {\r\n+            queries = new ArrayList(3); // don't expect many queries / class\r\n+            queries.add(meta);\r\n+            _queries.put(defName, queries);\r\n+        } else if (!queries.contains(meta))\r\n+            queries.add(meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add all components in the given repository to the set to be serialized.\r\n+     */\r\n+    public void addAll(MetaDataRepository repos) {\r\n+        if (repos == null)\r\n+            return;\r\n+        for (ClassMetaData meta : repos.getMetaDatas())\r\n+            addMetaData(meta);\r\n+        for (SequenceMetaData seq : repos.getSequenceMetaDatas())\r\n+            addSequenceMetaData(seq);\r\n+        for (QueryMetaData query : repos.getQueryMetaDatas())\r\n+            addQueryMetaData(query);\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a metadata from the set to be serialized.\r\n+     *\r\n+     * @return true if removed, false if not in set\r\n+     */\r\n+    public boolean removeMetaData(ClassMetaData meta) {\r\n+        return _metas != null && meta != null\r\n+            && _metas.remove(meta.getDescribedType().getName()) != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a sequence metadata from the set to be serialized.\r\n+     *\r\n+     * @return true if removed, false if not in set\r\n+     */\r\n+    public boolean removeSequenceMetaData(SequenceMetaData meta) {\r\n+        if (_seqs == null || meta == null)\r\n+            return false;\r\n+        String defName = null;\r\n+        if (meta.getSourceScope() instanceof Class)\r\n+            defName = ((Class) meta.getSourceScope()).getName();\r\n+        List seqs = _seqs.get(defName);\r\n+        if (seqs == null)\r\n+            return false;\r\n+        if (!seqs.remove(meta))\r\n+            return false;\r\n+        if (seqs.isEmpty())\r\n+            _seqs.remove(defName);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a query metadata from the set to be serialized.\r\n+     *\r\n+     * @return true if removed, false if not in set\r\n+     */\r\n+    public boolean removeQueryMetaData(QueryMetaData meta) {\r\n+        if (_queries == null || meta == null)\r\n+            return false;\r\n+        String defName = null;\r\n+        if (meta.getSourceScope() instanceof Class)\r\n+            defName = ((Class) meta.getSourceScope()).getName();\r\n+        List queries = _queries.get(defName);\r\n+        if (queries == null)\r\n+            return false;\r\n+        if (!queries.remove(meta))\r\n+            return false;\r\n+        if (queries.isEmpty())\r\n+            _queries.remove(defName);\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove all the components in the given repository from the set to be\r\n+     * serialized.\r\n+     *\r\n+     * @return true if any components removed, false if none in set\r\n+     */\r\n+    public boolean removeAll(MetaDataRepository repos) {\r\n+        if (repos == null)\r\n+            return false;\r\n+        boolean removed = false;\r\n+        ClassMetaData[] metas = repos.getMetaDatas();\r\n+        for (int i = 0; i < metas.length; i++)\r\n+            removed |= removeMetaData(metas[i]);\r\n+        SequenceMetaData[] seqs = repos.getSequenceMetaDatas();\r\n+        for (int i = 0; i < seqs.length; i++)\r\n+            removed |= removeSequenceMetaData(seqs[i]);\r\n+        QueryMetaData[] queries = repos.getQueryMetaDatas();\r\n+        for (int i = 0; i < queries.length; i++)\r\n+            removed |= removeQueryMetaData(queries[i]);\r\n+        return removed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the set of metadatas to be serialized.\r\n+     */\r\n+    public void clear() {\r\n+        if (_metas != null)\r\n+            _metas.clear();\r\n+        if (_seqs != null)\r\n+            _seqs.clear();\r\n+        if (_queries != null)\r\n+            _queries.clear();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected Collection getObjects() {\r\n+        List all = new ArrayList();\r\n+        if (isQueryMode())\r\n+            addQueryMetaDatas(all);\r\n+        if (isMappingMode())\r\n+            addSequenceMetaDatas(all);\r\n+        if ((isMetaDataMode() || isMappingMode()) && _metas != null)\r\n+            all.addAll(_metas.values());\r\n+        if (isMappingMode())\r\n+            addSystemMappingElements(all);\r\n+        serializationSort(all);\r\n+        return all;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add system-level mapping elements to be serialized. Does nothing\r\n+     * by default.\r\n+     */\r\n+    protected void addSystemMappingElements(Collection toSerialize) {\r\n+    }\r\n+\r\n+    /**\r\n+     * Sort the given collection of objects to be serialized.\r\n+     */\r\n+    private void serializationSort(List objs) {\r\n+        if (objs == null || objs.isEmpty())\r\n+            return;\r\n+        if (_comp == null)\r\n+            _comp = newSerializationComparator();\r\n+        Collections.sort(objs, _comp);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new comparator for ordering objects that are to be serialized.\r\n+     */\r\n+    protected SerializationComparator newSerializationComparator() {\r\n+        return _comp;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add sequence metadata to the given metadatas collection.\r\n+     */\r\n+    private void addSequenceMetaDatas(Collection all) {\r\n+        if (_seqs == null)\r\n+            return;\r\n+        for (Map.Entry entry : _seqs.entrySet()) {\r\n+            if (entry.getKey() == null)\r\n+                all.addAll((List) entry.getValue());\r\n+            else if (_metas == null || !_metas.containsKey(entry.getKey()))\r\n+                all.add(new ClassSeqs((List<SequenceMetaData>)\r\n+                    entry.getValue()));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Add query metadata to the given metadatas collection.\r\n+     */\r\n+    private void addQueryMetaDatas(Collection all) {\r\n+        if (_queries == null)\r\n+            return;\r\n+        for (Map.Entry entry : _queries.entrySet()) {\r\n+            if (entry.getKey() == null)\r\n+                all.addAll((List) entry.getValue());\r\n+            else if (_mode == MODE_QUERY || _metas == null\r\n+                || !_metas.containsKey(entry.getKey()))\r\n+                all.add(new ClassQueries((List<QueryMetaData>)\r\n+                    entry.getValue()));\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void serialize(Collection objects) throws SAXException {\r\n+        // copy collection to avoid mutation\r\n+        Object meta;\r\n+        boolean unique = true;\r\n+        boolean fieldAccess = false;\r\n+        boolean propertyAccess = false;\r\n+        for (Iterator it = objects.iterator(); it.hasNext();) {\r\n+            meta = it.next();\r\n+            switch (type(meta)) {\r\n+                case TYPE_META:\r\n+                    ClassMetaData cls = (ClassMetaData) meta;\r\n+                    if (cls.getAccessType() == ClassMetaData.ACCESS_FIELD)\r\n+                        fieldAccess = true;\r\n+                    else propertyAccess = true;\r\n+                    // no break\r\n+                default:\r\n+                    if (unique && getPackage() == null)\r\n+                        setPackage(getPackage(meta));\r\n+                    else if (unique) {\r\n+                        unique = getPackage().equals(getPackage(meta));\r\n+                        if (!unique)\r\n+                            setPackage(null);\r\n+                    }\r\n+            }\r\n+        }\r\n+        serializeNamespaceAttributes();\r\n+        startElement(\"entity-mappings\");\r\n+        if (getPackage() != null) {\r\n+            startElement(\"package\");\r\n+            addText(getPackage());\r\n+            endElement(\"package\");\r\n+        }\r\n+        if (fieldAccess != propertyAccess) { // i.e. only one\r\n+            int def = getConfiguration().getMetaDataRepository().\r\n+                getMetaDataFactory().getDefaults().getDefaultAccessType();\r\n+            String access = null;\r\n+            if (fieldAccess && def == ClassMetaData.ACCESS_PROPERTY)\r\n+                access = \"FIELD\";\r\n+            else if (propertyAccess && def == ClassMetaData.ACCESS_FIELD)\r\n+                access = \"PROPERTY\";\r\n+            if (access != null) {\r\n+                startElement(\"access\");\r\n+                addText(access);\r\n+                endElement(\"access\");\r\n+            }\r\n+        }\r\n+        for (Object obj : objects) {\r\n+            int type = type(obj);\r\n+            switch (type) {\r\n+                case TYPE_META:\r\n+                    serializeClass((ClassMetaData) obj, fieldAccess\r\n+                        && propertyAccess);\r\n+                    break;\r\n+                case TYPE_SEQ:\r\n+                    if (isMappingMode())\r\n+                        serializeSequence((SequenceMetaData) obj);\r\n+                case TYPE_QUERY:\r\n+                    serializeQuery((QueryMetaData) obj);\r\n+                    break;\r\n+                case TYPE_CLASS_QUERIES:\r\n+                    for (QueryMetaData query : ((ClassQueries) obj)\r\n+                        .getQueries())\r\n+                        serializeQuery(query);\r\n+                    break;\r\n+                case TYPE_CLASS_SEQS:\r\n+                    if (isMappingMode())\r\n+                        for (SequenceMetaData seq : ((ClassSeqs) obj)\r\n+                            .getSequences())\r\n+                            serializeSequence(seq);\r\n+                    break;\r\n+                default:\r\n+                    if (isMappingMode())\r\n+                        serializeSystemMappingElement(obj);\r\n+                    break;\r\n+            }\r\n+        }\r\n+        endElement(\"entity-mappings\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getPackage(Object obj) {\r\n+        int type = type(obj);\r\n+        switch (type) {\r\n+            case TYPE_META:\r\n+                return Strings.getPackageName(((ClassMetaData) obj).\r\n+                    getDescribedType());\r\n+            case TYPE_QUERY:\r\n+            case TYPE_SEQ:\r\n+            case TYPE_CLASS_QUERIES:\r\n+            case TYPE_CLASS_SEQS:\r\n+                SourceTracker st = (SourceTracker) obj;\r\n+                if (st.getSourceScope() instanceof Class)\r\n+                    return Strings.getPackageName((Class) st.getSourceScope());\r\n+                return null;\r\n+            default:\r\n+                return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the type constant for the given object based on its runtime\r\n+     * class. If the runtime class does not correspond to any of the known\r\n+     * types then returns -1. This can happen for tags\r\n+     * that are not handled at this store-agnostic level.\r\n+     */\r\n+    protected int type(Object o) {\r\n+        if (o instanceof ClassMetaData)\r\n+            return TYPE_META;\r\n+        if (o instanceof QueryMetaData)\r\n+            return TYPE_QUERY;\r\n+        if (o instanceof SequenceMetaData)\r\n+            return TYPE_SEQ;\r\n+        if (o instanceof ClassQueries)\r\n+            return TYPE_CLASS_QUERIES;\r\n+        if (o instanceof ClassSeqs)\r\n+            return TYPE_CLASS_SEQS;\r\n+        return -1;\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize namespace attributes\r\n+     */\r\n+    private void serializeNamespaceAttributes() throws SAXException {\r\n+        addAttribute(\"xmlns\", \"http://java.sun.com/xml/ns/persistence/orm\");\r\n+        addAttribute(\"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\r\n+        addAttribute(\"xsi:schemaLocation\",\r\n+            \"http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd\");\r\n+        addAttribute(\"version\", \"1.0\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize unknown mapping element at system level.\r\n+     */\r\n+    protected void serializeSystemMappingElement(Object obj)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize query metadata.\r\n+     */\r\n+    private void serializeQuery(QueryMetaData meta) throws SAXException {\r\n+        if (!_annos && meta.getSourceType() == meta.SRC_ANNOTATIONS)\r\n+            return;\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled()) {\r\n+            if (meta.getSourceScope() instanceof Class)\r\n+                log.info(_loc.get(\"ser-cls-query\",\r\n+                    meta.getSourceScope(), meta.getName()));\r\n+            else log.info(_loc.get(\"ser-query\", meta.getName()));\r\n+        }\r\n+        addComments(meta);\r\n+        addAttribute(\"name\", meta.getName());\r\n+        addAttribute(\"query\", meta.getQueryString());\r\n+        if (QueryLanguages.LANG_SQL.equals(meta.getLanguage())) {\r\n+            if (meta.getResultType() != null)\r\n+                addAttribute(\"result-class\", meta.getResultType().getName());\r\n+            startElement(\"named-native-query\");\r\n+            serializeQueryHints(meta);\r\n+            endElement(\"named-native-query\");\r\n+        } else {\r\n+            startElement(\"named-query\");\r\n+            serializeQueryHints(meta);\r\n+            endElement(\"named-query\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize query hints.\r\n+     */\r\n+    private void serializeQueryHints(QueryMetaData meta) throws SAXException {\r\n+        String[] hints = meta.getHintKeys();\r\n+        Object[] values = meta.getHintValues();\r\n+        for (int i = 0; i < hints.length; i++) {\r\n+            addAttribute(\"name\", hints[i]);\r\n+            addAttribute(\"value\", String.valueOf(values[i]));\r\n+            startElement(\"query-hint\");\r\n+            endElement(\"query-hint\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize sequence metadata.\r\n+     */\r\n+    protected void serializeSequence(SequenceMetaData meta)\r\n+        throws SAXException {\r\n+        if (!_annos && meta.getSourceType() == meta.SRC_ANNOTATIONS)\r\n+            return;\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"ser-sequence\", meta.getName()));\r\n+        addComments(meta);\r\n+        addAttribute(\"name\", meta.getName());\r\n+        // parse out the datastore sequence name, if any\r\n+        String plugin = meta.getSequencePlugin();\r\n+        String clsName = Configurations.getClassName(plugin);\r\n+        String props = Configurations.getProperties(plugin);\r\n+        String ds = null;\r\n+        if (props != null) {\r\n+            Properties map = Configurations.parseProperties(props);\r\n+            ds = (String) map.remove(\"Sequence\");\r\n+            if (ds != null) {\r\n+                props = Configurations.serializeProperties(map);\r\n+                plugin = Configurations.getPlugin(clsName, props);\r\n+            }\r\n+        }\r\n+        if (ds != null)\r\n+            addAttribute(\"sequence-name\", ds);\r\n+        else if (plugin != null && !SequenceMetaData.IMPL_NATIVE.equals\r\n+            (plugin))\r\n+            addAttribute(\"sequence-name\", plugin);\r\n+        if (meta.getInitialValue() != 0 && meta.getInitialValue() != -1)\r\n+            addAttribute(\"initial-value\",\r\n+                String.valueOf(meta.getInitialValue()));\r\n+        if (meta.getAllocate() != 50 && meta.getAllocate() != -1)\r\n+            addAttribute(\"allocation-size\",\r\n+                String.valueOf(meta.getAllocate()));\r\n+        startElement(\"sequence-generator\");\r\n+        endElement(\"sequence-generator\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize class metadata.\r\n+     */\r\n+    protected void serializeClass(ClassMetaData meta, boolean access)\r\n+        throws SAXException {\r\n+        if (!_annos && meta.getSourceType() == meta.SRC_ANNOTATIONS)\r\n+            return;\r\n+        Log log = getLog();\r\n+        if (log.isInfoEnabled())\r\n+            log.info(_loc.get(\"ser-class\", meta));\r\n+        addComments(meta);\r\n+        addAttribute(\"class\", getClassName(meta.getDescribedType().\r\n+            getName()));\r\n+        if (isMetaDataMode()\r\n+            && !meta.getTypeAlias().equals(Strings.getClassName(meta.\r\n+            getDescribedType())))\r\n+            addAttribute(\"name\", meta.getTypeAlias());\r\n+        String name = getEntityElementName(meta);\r\n+        if (isMetaDataMode())\r\n+            addClassAttributes(meta, access);\r\n+        if (isMappingMode())\r\n+            addClassMappingAttributes(meta);\r\n+        startElement(name);\r\n+        if (isMappingMode())\r\n+            serializeClassMappingContent(meta);\r\n+        if (isMetaDataMode())\r\n+            serializeIdClass(meta);\r\n+        if (isMappingMode())\r\n+            serializeInheritanceContent(meta);\r\n+        if (isMappingMode()) {\r\n+            List seqs = (_seqs == null) ? null : _seqs.get\r\n+                (meta.getDescribedType().getName());\r\n+            if (seqs != null) {\r\n+                serializationSort(seqs);\r\n+                for (int i = 0; i < seqs.size(); i++)\r\n+                    serializeSequence((SequenceMetaData) seqs.get(i));\r\n+            }\r\n+        }\r\n+        if (isQueryMode()) {\r\n+            List queries = (_queries == null) ? null : _queries.get\r\n+                (meta.getDescribedType().getName());\r\n+            if (queries != null) {\r\n+                serializationSort(queries);\r\n+                for (int i = 0; i < queries.size(); i++)\r\n+                    serializeQuery((QueryMetaData) queries.get(i));\r\n+            }\r\n+            if (isMappingMode())\r\n+                serializeQueryMappings(meta);\r\n+        }\r\n+        List<FieldMetaData> fields = new ArrayList(Arrays.asList\r\n+            (meta.getDefinedFieldsInListingOrder()));\r\n+        Collections.sort(fields, new FieldComparator());\r\n+        // serialize attr-override\r\n+        if (isMappingMode()) {\r\n+            FieldMetaData fmd;\r\n+            FieldMetaData orig;\r\n+            for (Iterator<FieldMetaData> it = fields.iterator(); it.hasNext();)\r\n+            {\r\n+                fmd = it.next();\r\n+                if (meta.getDefinedSuperclassField(fmd.getName()) == null)\r\n+                    continue;\r\n+                orig = meta.getPCSuperclassMetaData().getField(fmd.getName());\r\n+                if (serializeAttributeOverride(fmd, orig))\r\n+                    serializeAttributeOverrideContent(fmd, orig);\r\n+                it.remove();\r\n+            }\r\n+        }\r\n+        if (fields.size() > 0 && (isMetaDataMode() || isMappingMode())) {\r\n+            startElement(\"attributes\");\r\n+            FieldMetaData orig;\r\n+            for (FieldMetaData fmd : fields) {\r\n+                if (fmd.getDeclaringType() != fmd.getDefiningMetaData().\r\n+                    getDescribedType()) {\r\n+                    orig = fmd.getDeclaringMetaData().getDeclaredField\r\n+                        (fmd.getName());\r\n+                } else orig = null;\r\n+                serializeField(fmd, orig);\r\n+            }\r\n+            endElement(\"attributes\");\r\n+        }\r\n+        endElement(name);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the entity element name.\r\n+     */\r\n+    private static String getEntityElementName(ClassMetaData meta) {\r\n+        switch (getEntityTag(meta)) {\r\n+            case ENTITY:\r\n+                return \"entity\";\r\n+            case EMBEDDABLE:\r\n+                return \"embeddable\";\r\n+            case MAPPED_SUPERCLASS:\r\n+                return \"mapped-superclass\";\r\n+            default:\r\n+                throw new IllegalStateException();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the MetaDataTag for the given class meta data.\r\n+     */\r\n+    private static MetaDataTag getEntityTag(ClassMetaData meta) {\r\n+        // @Embeddable classes can't declare Id fields\r\n+        if (meta.isEmbeddedOnly() && meta.getPrimaryKeyFields().length == 0)\r\n+            return MetaDataTag.EMBEDDABLE;\r\n+        if (meta.isMapped())\r\n+            return MetaDataTag.ENTITY;\r\n+        return MetaDataTag.MAPPED_SUPERCLASS;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set class attributes.\r\n+     *\r\n+     * @param access whether to write access\r\n+     */\r\n+    private void addClassAttributes(ClassMetaData meta, boolean access) {\r\n+        if (!access)\r\n+            return;\r\n+        int def = getConfiguration().getMetaDataRepository().\r\n+            getMetaDataFactory().getDefaults().getDefaultAccessType();\r\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD\r\n+            && def == ClassMetaData.ACCESS_PROPERTY)\r\n+            addAttribute(\"access\", \"FIELD\");\r\n+        else if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY\r\n+            && def == ClassMetaData.ACCESS_FIELD)\r\n+            addAttribute(\"access\", \"PROPERTY\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Add mapping attributes for the given class. Does nothing by default\r\n+     */\r\n+    protected void addClassMappingAttributes(ClassMetaData mapping)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize id-class.\r\n+     */\r\n+    private void serializeIdClass(ClassMetaData meta) throws SAXException {\r\n+        if (meta.getIdentityType() != ClassMetaData.ID_APPLICATION\r\n+            || meta.isOpenJPAIdentity())\r\n+            return;\r\n+        ClassMetaData sup = meta.getPCSuperclassMetaData();\r\n+        Class oid = meta.getObjectIdType();\r\n+        if (oid != null && (sup == null || oid != sup.getObjectIdType())) {\r\n+            addAttribute(\"class\", getClassName(oid.getName()));\r\n+            startElement(\"id-class\");\r\n+            endElement(\"id-class\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize class mapping content. Does nothing by default.\r\n+     */\r\n+    protected void serializeClassMappingContent(ClassMetaData mapping)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize inheritance content. Does nothing by default.\r\n+     */\r\n+    protected void serializeInheritanceContent(ClassMetaData mapping)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize query mappings. Does nothing by default.\r\n+     */\r\n+    protected void serializeQueryMappings(ClassMetaData meta)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize the given field.\r\n+     */\r\n+    private void serializeField(FieldMetaData fmd, FieldMetaData orig)\r\n+        throws SAXException {\r\n+        if (fmd.getManagement() != FieldMetaData.MANAGE_PERSISTENT\r\n+            && !fmd.isExplicit())\r\n+            return;\r\n+        addComments(fmd);\r\n+        addAttribute(\"name\", fmd.getName());\r\n+        String strategy = null;\r\n+        PersistenceStrategy strat = getStrategy(fmd);\r\n+        ValueMetaData cascades = null;\r\n+        if (fmd.isPrimaryKey() && strat == PersistenceStrategy.EMBEDDED)\r\n+            strategy = \"embedded-id\";\r\n+        else if (fmd.isPrimaryKey())\r\n+            strategy = \"id\";\r\n+        else if (fmd.isVersion())\r\n+            strategy = \"version\";\r\n+        else {\r\n+            switch (strat) {\r\n+                case TRANSIENT:\r\n+                    strategy = \"transient\";\r\n+                    break;\r\n+                case BASIC:\r\n+                    if (isMetaDataMode())\r\n+                        addBasicAttributes(fmd);\r\n+                    strategy = \"basic\";\r\n+                    break;\r\n+                case EMBEDDED:\r\n+                    strategy = \"embedded\";\r\n+                    break;\r\n+                case MANY_ONE:\r\n+                    if (isMetaDataMode())\r\n+                        addManyToOneAttributes(fmd);\r\n+                    strategy = \"many-to-one\";\r\n+                    cascades = fmd;\r\n+                    break;\r\n+                case ONE_ONE:\r\n+                    if (isMetaDataMode())\r\n+                        addOneToOneAttributes(fmd);\r\n+                    strategy = \"one-to-one\";\r\n+                    cascades = fmd;\r\n+                    break;\r\n+                case ONE_MANY:\r\n+                    if (isMetaDataMode())\r\n+                        addOneToManyAttributes(fmd);\r\n+                    strategy = \"one-to-many\";\r\n+                    cascades = fmd.getElement();\r\n+                    break;\r\n+                case MANY_MANY:\r\n+                    if (isMetaDataMode())\r\n+                        addManyToManyAttributes(fmd);\r\n+                    strategy = \"many-to-many\";\r\n+                    cascades = fmd.getElement();\r\n+                    break;\r\n+            }\r\n+            if (isMappingMode())\r\n+                addStrategyMappingAttributes(fmd);\r\n+        }\r\n+        if (isMappingMode(fmd))\r\n+            addFieldMappingAttributes(fmd, orig);\r\n+        startElement(strategy);\r\n+        if (fmd.getOrderDeclaration() != null) {\r\n+            startElement(\"order-by\");\r\n+            if (!(Order.ELEMENT + \" asc\").equals(fmd.getOrderDeclaration()))\r\n+                addText(fmd.getOrderDeclaration());\r\n+            endElement(\"order-by\");\r\n+        }\r\n+        if (isMappingMode() && fmd.getKey().getValueMappedBy() != null) {\r\n+            FieldMetaData mapBy = fmd.getKey().getValueMappedByMetaData();\r\n+            if (!mapBy.isPrimaryKey() ||\r\n+                mapBy.getDefiningMetaData().getPrimaryKeyFields().length != 1) {\r\n+                addAttribute(\"name\", fmd.getKey().getValueMappedBy());\r\n+            }\r\n+            startElement(\"map-key\");\r\n+            endElement(\"map-key\");\r\n+        }\r\n+        if (isMappingMode(fmd))\r\n+            serializeFieldMappingContent(fmd, strat);\r\n+        if (cascades != null && isMetaDataMode())\r\n+            serializeCascades(cascades);\r\n+        if (isMappingMode() && strat == PersistenceStrategy.EMBEDDED) {\r\n+            ClassMetaData meta = fmd.getEmbeddedMetaData();\r\n+            ClassMetaData owner = getConfiguration().getMetaDataRepository().\r\n+                getMetaData(meta.getDescribedType(),\r\n+                    meta.getEnvClassLoader(), true);\r\n+            FieldMetaData eorig;\r\n+            for (FieldMetaData efmd : meta.getFields()) {\r\n+                eorig = owner.getField(efmd.getName());\r\n+                if (serializeAttributeOverride(efmd, eorig))\r\n+                    serializeAttributeOverrideContent(efmd, eorig);\r\n+            }\r\n+        }\r\n+        endElement(strategy);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add mapping attributes for the given field. Does nothing by default.\r\n+     */\r\n+    protected void addFieldMappingAttributes(FieldMetaData fmd,\r\n+        FieldMetaData orig) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Always returns false by default.\r\n+     */\r\n+    protected boolean serializeAttributeOverride(FieldMetaData fmd,\r\n+        FieldMetaData orig) {\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize attribute override content.\r\n+     */\r\n+    private void serializeAttributeOverrideContent(FieldMetaData fmd,\r\n+        FieldMetaData orig) throws SAXException {\r\n+        addAttribute(\"name\", fmd.getName());\r\n+        startElement(\"attribute-override\");\r\n+        serializeAttributeOverrideMappingContent(fmd, orig);\r\n+        endElement(\"attribute-override\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize attribute override mapping content. Does nothing by default,\r\n+     */\r\n+    protected void serializeAttributeOverrideMappingContent\r\n+        (FieldMetaData fmd, FieldMetaData orig) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize cascades.\r\n+     */\r\n+    private void serializeCascades(ValueMetaData vmd) throws SAXException {\r\n+        Collection<String> cascades = null;\r\n+        if (vmd.getCascadePersist() == ValueMetaData.CASCADE_IMMEDIATE) {\r\n+            if (cascades == null)\r\n+                cascades = new ArrayList<String>();\r\n+            cascades.add(\"cascade-persist\");\r\n+        }\r\n+        if (vmd.getCascadeAttach() == ValueMetaData.CASCADE_IMMEDIATE) {\r\n+            if (cascades == null)\r\n+                cascades = new ArrayList<String>();\r\n+            cascades.add(\"cascade-merge\");\r\n+        }\r\n+        if (vmd.getCascadeDelete() == ValueMetaData.CASCADE_IMMEDIATE) {\r\n+            if (cascades == null)\r\n+                cascades = new ArrayList<String>();\r\n+            cascades.add(\"cascade-remove\");\r\n+        }\r\n+        if (vmd.getCascadeRefresh() == ValueMetaData.CASCADE_IMMEDIATE) {\r\n+            if (cascades == null)\r\n+                cascades = new ArrayList<String>();\r\n+            cascades.add(\"cascade-refresh\");\r\n+        }\r\n+        if (cascades != null && cascades.size() == 4) { // ALL\r\n+            cascades.clear();\r\n+            cascades.add(\"cascade-all\");\r\n+        }\r\n+        if (cascades != null) {\r\n+            startElement(\"cascade\");\r\n+            for (String cascade : cascades) {\r\n+                startElement(cascade);\r\n+                endElement(\"cascade\");\r\n+            }\r\n+            endElement(\"cascade\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the serialized strategy name.\r\n+     */\r\n+    protected PersistenceStrategy getStrategy(FieldMetaData fmd) {\r\n+        if (fmd.getManagement() == fmd.MANAGE_NONE)\r\n+            return PersistenceStrategy.TRANSIENT;\r\n+        if (fmd.isSerialized()\r\n+            || fmd.getDeclaredType() == byte[].class\r\n+            || fmd.getDeclaredType() == Byte[].class\r\n+            || fmd.getDeclaredType() == char[].class\r\n+            || fmd.getDeclaredType() == Character[].class)\r\n+            return PersistenceStrategy.BASIC;\r\n+        FieldMetaData mappedBy;\r\n+        switch (fmd.getDeclaredTypeCode()) {\r\n+            case JavaTypes.PC:\r\n+                if (fmd.isEmbedded())\r\n+                    return PersistenceStrategy.EMBEDDED;\r\n+                if (fmd.getMappedBy() != null)\r\n+                    return PersistenceStrategy.ONE_ONE;\r\n+                FieldMetaData[] inverses = fmd.getInverseMetaDatas();\r\n+                if (inverses.length == 1 &&\r\n+                    inverses[0].getTypeCode() == JavaTypes.PC &&\r\n+                    inverses[0].getMappedByMetaData() == fmd) {\r\n+                    return PersistenceStrategy.ONE_ONE;\r\n+                }\r\n+                return PersistenceStrategy.MANY_ONE;\r\n+            case JavaTypes.ARRAY:\r\n+            case JavaTypes.COLLECTION:\r\n+            case JavaTypes.MAP:\r\n+                mappedBy = fmd.getMappedByMetaData();\r\n+                if (mappedBy == null || mappedBy.getTypeCode() != JavaTypes.PC)\r\n+                    return PersistenceStrategy.MANY_MANY;\r\n+                return PersistenceStrategy.ONE_MANY;\r\n+            case JavaTypes.OID:\r\n+                return PersistenceStrategy.EMBEDDED;\r\n+            default:\r\n+                return PersistenceStrategy.BASIC;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Add basic attributes.\r\n+     */\r\n+    private void addBasicAttributes(FieldMetaData fmd) throws SAXException {\r\n+        if (!fmd.isInDefaultFetchGroup())\r\n+            addAttribute(\"fetch\", \"LAZY\");\r\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\r\n+            addAttribute(\"optional\", \"false\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Add many-to-one attributes.\r\n+     */\r\n+    private void addManyToOneAttributes(FieldMetaData fmd) throws SAXException {\r\n+        if (!fmd.isInDefaultFetchGroup())\r\n+            addAttribute(\"fetch\", \"LAZY\");\r\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\r\n+            addAttribute(\"optional\", \"false\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Add one-to-one attributes.\r\n+     */\r\n+    private void addOneToOneAttributes(FieldMetaData fmd) throws SAXException {\r\n+        if (!fmd.isInDefaultFetchGroup())\r\n+            addAttribute(\"fetch\", \"LAZY\");\r\n+        if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION)\r\n+            addAttribute(\"optional\", \"false\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Add one-to-many attributes.\r\n+     */\r\n+    private void addOneToManyAttributes(FieldMetaData fmd) throws SAXException {\r\n+        if (fmd.isInDefaultFetchGroup())\r\n+            addAttribute(\"fetch\", \"EAGER\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Add many-to-many attributes.\r\n+     */\r\n+    private void addManyToManyAttributes(FieldMetaData fmd)\r\n+        throws SAXException {\r\n+        if (fmd.isInDefaultFetchGroup())\r\n+            addAttribute(\"fetch\", \"EAGER\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize field mapping content; this will be called before\r\n+     * {@link #serializeValueMappingContent}. Does nothing by default.\r\n+     */\r\n+    protected void serializeFieldMappingContent(FieldMetaData fmd,\r\n+        PersistenceStrategy strategy) throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Set mapping attributes for strategy. Sets mapped-by by default.\r\n+     */\r\n+    protected void addStrategyMappingAttributes(FieldMetaData fmd)\r\n+        throws SAXException {\r\n+        if (fmd.getMappedBy() != null)\r\n+            addAttribute(\"mapped-by\", fmd.getMappedBy());\r\n+    }\r\n+\r\n+    /**\r\n+     * Serialize the content of the given value. Does nothing by default.\r\n+     */\r\n+    private void serializeStrategyMappingContent(FieldMetaData vmd)\r\n+        throws SAXException {\r\n+    }\r\n+\r\n+    /**\r\n+     * Represents ordered set of {@link SequenceMetaData}s with a\r\n+     * common class scope.\r\n+     *\r\n+     * @author Stephen Kim\r\n+     * @author Pinaki Poddar\r\n+     */\r\n+    private static class ClassSeqs\r\n+        implements SourceTracker, Comparable<ClassSeqs>,\r\n+        Comparator<SequenceMetaData> {\r\n+\r\n+        private final SequenceMetaData[] _seqs;\r\n+\r\n+        public ClassSeqs(List<SequenceMetaData> seqs) {\r\n+            if (seqs == null || seqs.isEmpty())\r\n+                throw new InternalException();\r\n+            _seqs = (SequenceMetaData[]) seqs\r\n+                .toArray(new SequenceMetaData[seqs.size()]);\r\n+            Arrays.sort(_seqs, this);\r\n+        }\r\n+\r\n+        public SequenceMetaData[] getSequences() {\r\n+            return _seqs;\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare sequence metadata on name.\r\n+         */\r\n+        public int compare(SequenceMetaData o1, SequenceMetaData o2) {\r\n+            return o1.getName().compareTo(o2.getName());\r\n+        }\r\n+\r\n+        public File getSourceFile() {\r\n+            return _seqs[0].getSourceFile();\r\n+        }\r\n+\r\n+        public Object getSourceScope() {\r\n+            return _seqs[0].getSourceScope();\r\n+        }\r\n+\r\n+        public int getSourceType() {\r\n+            return _seqs[0].getSourceType();\r\n+        }\r\n+\r\n+        public String getResourceName() {\r\n+            return _seqs[0].getResourceName();\r\n+        }\r\n+\r\n+        public int compareTo(ClassSeqs other) {\r\n+            if (other == this)\r\n+                return 0;\r\n+            if (other == null)\r\n+                return -1;\r\n+            Class scope = (Class) getSourceScope();\r\n+            Class oscope = (Class) other.getSourceScope();\r\n+            return scope.getName().compareTo(oscope.getName());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Represents ordered set of {@link QueryMetaData}s with a\r\n+     * common class scope.\r\n+     *\r\n+     * @author Stephen Kim\r\n+     * @author Pinaki Poddar\r\n+     */\r\n+    private static class ClassQueries\r\n+        implements SourceTracker, Comparable<ClassQueries>,\r\n+        Comparator<QueryMetaData> {\r\n+\r\n+        private final QueryMetaData[] _queries;\r\n+\r\n+        public ClassQueries(List<QueryMetaData> queries) {\r\n+            if (queries == null || queries.isEmpty())\r\n+                throw new InternalException();\r\n+            _queries = (QueryMetaData[]) queries.toArray\r\n+                (new QueryMetaData[queries.size()]);\r\n+            Arrays.sort(_queries, this);\r\n+        }\r\n+\r\n+        public QueryMetaData[] getQueries() {\r\n+            return _queries;\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare query metadata. Normal queries appear before native queries.\r\n+         * If the given queries use same language, then their names are\r\n+         * compared.\r\n+         */\r\n+        public int compare(QueryMetaData o1, QueryMetaData o2) {\r\n+            // normal queries before native\r\n+            if (!StringUtils.equals(o1.getLanguage(), o2.getLanguage())) {\r\n+                if (QueryLanguages.LANG_SQL.equals(o1.getLanguage()))\r\n+                    return 1;\r\n+                else return -1;\r\n+            }\r\n+            return o1.getName().compareTo(o2.getName());\r\n+        }\r\n+\r\n+        public File getSourceFile() {\r\n+            return _queries[0].getSourceFile();\r\n+        }\r\n+\r\n+        public Object getSourceScope() {\r\n+            return _queries[0].getSourceScope();\r\n+        }\r\n+\r\n+        public int getSourceType() {\r\n+            return _queries[0].getSourceType();\r\n+        }\r\n+\r\n+        public String getResourceName() {\r\n+            return _queries[0].getResourceName();\r\n+        }\r\n+\r\n+        public int compareTo(ClassQueries other) {\r\n+            if (other == this)\r\n+                return 0;\r\n+            if (other == null)\r\n+                return -1;\r\n+            Class scope = (Class) getSourceScope();\r\n+            Class oscope = (Class) other.getSourceScope();\r\n+            return scope.getName().compareTo(oscope.getName());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Compares clases, sequences, and queries to order them for serialization.\r\n+     * Places sequences first, then classes, then queries. Sequences and\r\n+     * queries are ordered alphabetically by name. Classes are placed in\r\n+     * listing order, in inheritance order within that, and in alphabetical\r\n+     * order within that.\r\n+     *\r\n+     * @author Stephen Kim\r\n+     */\r\n+    protected class SerializationComparator\r\n+        extends MetaDataInheritanceComparator {\r\n+\r\n+        public int compare(Object o1, Object o2) {\r\n+            if (o1 == o2)\r\n+                return 0;\r\n+            if (o1 == null)\r\n+                return 1;\r\n+            if (o2 == null)\r\n+                return -1;\r\n+            int t1 = type(o1);\r\n+            int t2 = type(o2);\r\n+            if (t1 != t2)\r\n+                return t1 - t2;\r\n+            switch (t1) {\r\n+                case TYPE_META:\r\n+                    return compare((ClassMetaData) o1, (ClassMetaData) o2);\r\n+                case TYPE_QUERY:\r\n+                    return compare((QueryMetaData) o1, (QueryMetaData) o2);\r\n+                case TYPE_SEQ:\r\n+                    return compare((SequenceMetaData) o1,\r\n+                        (SequenceMetaData) o2);\r\n+                case TYPE_CLASS_QUERIES:\r\n+                    return ((Comparable) o1).compareTo(o2);\r\n+                case TYPE_CLASS_SEQS:\r\n+                    return ((Comparable) o1).compareTo(o2);\r\n+                default:\r\n+                    return compareUnknown(o1, o2);\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare two unrecognized elements of the same type. Throws\r\n+         * exception by default.\r\n+         */\r\n+        protected int compareUnknown(Object o1, Object o2) {\r\n+            throw new InternalException();\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare between two class metadata.\r\n+         */\r\n+        private int compare(ClassMetaData o1, ClassMetaData o2) {\r\n+            int li1 = o1.getListingIndex();\r\n+            int li2 = o2.getListingIndex();\r\n+            if (li1 == -1 && li2 == -1) {\r\n+                MetaDataTag t1 = getEntityTag(o1);\r\n+                MetaDataTag t2 = getEntityTag(o2);\r\n+                if (t1.compareTo(t2) != 0)\r\n+                    return t1.compareTo(t2);\r\n+                int inher = super.compare(o1, o2);\r\n+                if (inher != 0)\r\n+                    return inher;\r\n+                return o1.getDescribedType().getName().compareTo\r\n+                    (o2.getDescribedType().getName());\r\n+            }\r\n+            if (li1 == -1)\r\n+                return 1;\r\n+            if (li2 == -1)\r\n+                return -1;\r\n+            return li1 - li2;\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare query metadata.\r\n+         */\r\n+        private int compare(QueryMetaData o1, QueryMetaData o2) {\r\n+            // normal queries before native\r\n+            if (!StringUtils.equals(o1.getLanguage(), o2.getLanguage())) {\r\n+                if (QueryLanguages.LANG_SQL.equals(o1.getLanguage()))\r\n+                    return 1;\r\n+                else return -1;\r\n+            }\r\n+            return o1.getName().compareTo(o2.getName());\r\n+        }\r\n+\r\n+        /**\r\n+         * Compare sequence metadata.\r\n+         */\r\n+        private int compare(SequenceMetaData o1, SequenceMetaData o2) {\r\n+            return o1.getName().compareTo(o2.getName());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Sorts fields according to listing order, then XSD strategy order,\r\n+     * then name order.\r\n+     */\r\n+    private class FieldComparator implements Comparator {\r\n+\r\n+        public int compare(Object o1, Object o2) {\r\n+            FieldMetaData fmd1 = (FieldMetaData) o1;\r\n+            FieldMetaData fmd2 = (FieldMetaData) o2;\r\n+            if (fmd1.getListingIndex() != fmd2.getListingIndex())\r\n+                return fmd1.getListingIndex() - fmd2.getListingIndex();\r\n+            if (fmd1.isPrimaryKey()) {\r\n+                if (fmd2.isPrimaryKey())\r\n+                    return fmd1.compareTo(fmd2);\r\n+                return -1;\r\n+            }\r\n+            if (fmd2.isPrimaryKey())\r\n+                return 1;\r\n+            PersistenceStrategy st1 = fmd1.isVersion() ? null :\r\n+                getStrategy(fmd1);\r\n+            PersistenceStrategy st2 = fmd2.isVersion() ? null :\r\n+                getStrategy(fmd2);\r\n+            if (fmd1.isVersion()) {\r\n+                if (fmd2.isVersion())\r\n+                    return fmd1.compareTo(fmd2);\r\n+                return st2 == PersistenceStrategy.BASIC ? 1 : -1;\r\n+            }\r\n+            if (fmd2.isVersion())\r\n+                return st1 == PersistenceStrategy.BASIC ? -1 : 1;\r\n+            return st1.compareTo(st2);\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"43b4bca9847d3526131b60e8bed8cb32fc9c35de","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/package.html","status":"added","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,10 @@\n+<html>\n+<body>\n+<p><strong>OpenJPA JPA</strong></p>\n+\n+<p>\n+    This package provides an JPA facade to OpenJPA. All major OpenJPA\n+    runtime components have JPA-flavored facades in this package.\n+</p>\n+</body>\n+</html>"},{"sha":"fe738af6a0903e2a7cbd50d085d0aa602ed64e2f","filename":"openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.conf.ProductDerivation?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1 @@\n+org.apache.openjpa.persistence.PersistenceProductDerivation"},{"sha":"78705f7ba52f4738b198a365c0530cd568710f2e","filename":"openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ConfigurationProvider?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1 @@\n+org.apache.openjpa.persistence.ConfigurationProviderImpl"},{"sha":"d03ac818b7934f6623da3a164ee17ea3fccaa5c6","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,94 @@\n+no-managed-trans: There is no managed transaction in progress to sync this \\\n+\tEntityManager with.\n+get-managed-trans: You cannot access the EntityTransaction when using managed \\\n+\ttransactions.\n+trans-ctx-notactive: When using a persistence context type of TRANSACTION, you \\\n+\tcan only perform this operation during an active transaction. \n+not-entity: The class \"{0}\" is not an entity.\n+not-managed: Object \"{0}\" is not managed by this context.\n+parse-class: Parsing class \"{0}\".\n+parse-package: Parsing package \"{0}\".\n+parse-sequence: Parsing sequence \"{0}\".\n+parse-query: Parsing query \"{0}\".\n+parse-native-query: Parsing native query \"{0}\".\n+dup-metadata: Found duplicate metadata or mapping for \"{0}\".  Ignoring.\n+dup-sequence: Found duplicate generator \"{0}\" in \"{1}\".  Ignoring.\n+override-sequence: Found duplicate generator \"{0}\" in \"{1}\".  Overriding \\\n+\tprevious definition.\n+dup-query: Found duplicate query \"{0}\" in \"{1}\".  Ignoring.\n+override-query: Found duplicate query \"{0}\" in \"{1}\".  Overriding previous \\\n+\tdefinition.\n+no-seq-name: The sequence generator in \"{0}\" must declare a name.\n+no-query-name: The named query in \"{0}\" must declare a name.\n+no-native-query-name: The named native query in \"{0}\" must declare a name.\n+no-query-string: The named query \"{0}\" in \"{1}\" must declare a query string.\n+no-native-query-string: The named native query \"{0}\" in \"{1}\" must declare a \\\n+\tquery string.\n+already-pers: Field \"{0}\" cannot be annotated by two persistence strategy \\\n+\tannotations.\n+unsupported: OpenJPA does not yet support \"{1}\" as used in \"{0}\".\n+bad-meta-anno: The type of field \"{0}\" isn''t supported by declared \\\n+\tpersistence strategy \"{1}\".  Please choose a different strategy.\n+no-pers-strat: Fields \"{0}\" are not a default persistent type, and do not \\\n+\thave any annotations indicating their persistence strategy.  If you do \\\n+\tnot want these fields to be persisted, annotate them with @Transient.\n+generator-bad-strategy: \"{0}\" declares generator name \"{1}\", but uses the AUTO \\\n+\tgeneration type.  The only valid generator names under AUTO are \"uuid-hex\" \\\n+\tand \"uuid-string\". \n+unnamed-fg: \"{0}\" declares an unnamed fetch group.  All fetch groups \\\n+\tmust have names.\n+bad-fg-field: Fetch group \"{0}\" in type \"{1}\" includes field \"{2}\", but \\\n+\tthis field is not declared in \"{1}\", or is not persistent.  Currently, \\\n+\tOpenJPA only supports declared fields in fetch groups.\n+mult-fgs: Field \"{0}\" is included in fetch group \"{1}\", but is already in \\\n+\tfetch group \"{2}\".  OpenJPA currently limits fields to one fetch group.\n+mult-fgs-default: Field \"{0}\" is included in fetch group \"{1}\", but is also in \\\n+\tthe default fetch group. OpenJPA currently limits fields to one fetch group. \\\n+\tSet the field''s \"fetch\" attribute to \"FetchType.LAZY\" to exclude it \\\n+\tfrom the default fetch group.\n+nonzero-fetch-depth: Fetch group \"{0}\" in type \"{1}\" sets a non-zero \\\n+\tfetch-depth for field \"{2}\".  OpenJPA currently only supports a fetch depth \\\n+\tof zero.  Resetting depth to 0.\n+not-update-delete-query: Cannot perform an update or delete operation \\\n+\ton select query: \"{0}\".\n+not-select-query: Cannot perform a select on update or delete query: \"{0}\".\n+no-results: Query did not return any results: \"{0}\".\n+mult-results: Query returned multiple results: \"{0}\".\n+no-pos-named-params-mix: Cannot mix named and positional parameters in query \\\n+\t\"{0}\".\n+bad-query-hint: \"{0}\" is not a recognized query hint.\n+detached: Cannot perform this operation on detached entity \"{0}\".\n+removed: Cannot perform this operation on removed entity \"{0}\".\n+bad-alias: There is no known entity class for entity name \"{0}\".  It is \\\n+\tpossible that the corresponding class has not yet been registered in the \\\n+\tJVM.\n+naming-exception: A NamingException was thrown while obtaining the \\\n+\tfactory at \"{0}\" from JNDI.\n+bad-jar-name: The jar resource \"{0}\" cannot be loaded.\n+missing-xml-config: The specified XML resource \"{0}\" for persistence unit \\\n+\t\"{1}\" can''t be found in your class path.\n+cantload-xml-config: The specified XML resource \"{0}\" for persistence unit \\\n+\t\"{1}\" can''t be parsed.\n+illegal-index: The parameter index {0} is invalid. Parameters must be \\\n+\tintegers starting at 1.\n+conf-load: Setting the following properties from \"{0}\" into configuration: {1}\n+no-named-field: Type \"{0}\" does not have a managed field named \"{1}\".\n+unsupported-tag: OpenJPA does not currently support XML element \"{0}\".  Ignoring.\n+no-class: No class attribute was specified.\n+invalid-id-class: Could not load id class \"{1}\" for type \"{0}\".\n+invalid-attr: Could not find property/field with the name \"{0}\" in type \"{1}\".\n+ser-class: Writing class \"{0}\".\n+ser-cls-query: Writing query \"{1}\" in class \"{0}\".\n+ser-query: Writing query \"{1}\".\n+ser-sequence: Writing sequence \"{0}\".\n+no-sql: You must provide a SQL string when creating a native query.\n+bad-param-type: The parameter \"{0}\" is of type \"{1}\", but the \\\n+\tdeclaration in the query is for type \"{2}\". \n+bad-em-prop: Invalid EntityManager property passed to createEntityManager. \\\n+\tKey: \"{0}\", Value: \"{1}\".\n+bad-em-props: Invalid EntityManager properties passed to createEntityManager. \\\n+\tSee nested exceptions for details.\n+system-listener-err: An error occurred invoking system entity listener \\\n+\tcallback on instance \"{0}\".\n+no-transaction: Cannot perform operation with no transaction.\n+"},{"sha":"9a0d1ddafef2c43d0824d41f33232d7664fec42d","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/orm-xsd.rsrc","status":"added","additions":1516,"deletions":0,"changes":1516,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/orm-xsd.rsrc","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/orm-xsd.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/orm-xsd.rsrc?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,1516 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Java Persistence API object-relational mapping file schema -->\n+<xsd:schema targetNamespace=\"http://java.sun.com/xml/ns/persistence/orm\" \n+  xmlns:orm=\"http://java.sun.com/xml/ns/persistence/orm\" \n+  xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n+  elementFormDefault=\"qualified\" \n+  attributeFormDefault=\"unqualified\" \n+  version=\"1.0\">\n+\n+  <xsd:annotation>\n+    <xsd:documentation>\n+      @(#)orm_1_0.xsd 1.0  Feb 14 2006\n+    </xsd:documentation>\n+  </xsd:annotation>\n+  <xsd:annotation>\n+     <xsd:documentation><![CDATA[\n+\n+       This is the XML Schema for the persistence object-relational \n+       mapping file.\n+       The file may be named \"META-INF/orm.xml\" in the persistence \n+       archive or it may be named some other name which would be \n+       used to locate the file as resource on the classpath.\n+\n+     ]]></xsd:documentation>\n+  </xsd:annotation>\n+\n+  <xsd:complexType name=\"emptyType\"/>\n+\n+  <xsd:simpleType name=\"versionType\">\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:pattern value=\"[0-9]+(\\.[0-9]+)*\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:element name=\"entity-mappings\">\n+    <xsd:complexType>\n+      <xsd:annotation>\n+        <xsd:documentation>\n+\n+        The entity-mappings element is the root element of an mapping\n+        file. It contains the following four types of elements:\n+\n+        1. The persistence-unit-metadata element contains metadata\n+        for the entire persistence unit. It is undefined if this element\n+        occurs in multiple mapping files within the same persistence unit.\n+        \n+        2. The package, schema, catalog and access elements apply to all of\n+        the entity, mapped-superclass and embeddable elements defined in\n+        the same file in which they occur.\n+\n+        3. The sequence-generator, table-generator, named-query,\n+        named-native-query and sql-result-set-mapping elements are global\n+        to the persistence unit. It is undefined to have more than one\n+        sequence-generator or table-generator of the same name in the same\n+        or different mapping files in a persistence unit. It is also \n+        undefined to have more than one named-query or named-native-query\n+        of the same name in the same or different mapping files in a \n+        persistence unit.\n+\n+        4. The entity, mapped-superclass and embeddable elements each define\n+        the mapping information for a managed persistent class. The mapping\n+        information contained in these elements may be complete or it may\n+        be partial.\n+\n+        </xsd:documentation>\n+      </xsd:annotation>\n+      <xsd:sequence>\n+        <xsd:element name=\"description\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"persistence-unit-metadata\" \n+                     type=\"orm:persistence-unit-metadata\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"package\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"schema\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"catalog\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"access\" type=\"orm:access-type\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\"\n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"table-generator\" type=\"orm:table-generator\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"named-query\" type=\"orm:named-query\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"named-native-query\" type=\"orm:named-native-query\"\n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"sql-result-set-mapping\" \n+                     type=\"orm:sql-result-set-mapping\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"mapped-superclass\" type=\"orm:mapped-superclass\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"entity\" type=\"orm:entity\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"embeddable\" type=\"orm:embeddable\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      </xsd:sequence>\n+      <xsd:attribute name=\"version\" type=\"orm:versionType\" \n+                     fixed=\"1.0\" use=\"required\"/>\n+    </xsd:complexType>\n+  </xsd:element>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"persistence-unit-metadata\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        Metadata that applies to the persistence unit and not just to \n+        the mapping file in which it is contained. \n+\n+        If the xml-mapping-metadata-complete element is specified then \n+        the complete set of mapping metadata for the persistence unit \n+        is contained in the XML mapping files for the persistence unit.\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"xml-mapping-metadata-complete\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"persistence-unit-defaults\" \n+                   type=\"orm:persistence-unit-defaults\"\n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"persistence-unit-defaults\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        These defaults are applied to the persistence unit as a whole \n+        unless they are overridden by local annotation or XML \n+        element settings. \n+        \n+        schema - Used as the schema for all tables or secondary tables\n+            that apply to the persistence unit\n+        catalog - Used as the catalog for all tables or secondary tables\n+            that apply to the persistence unit\n+        access - Used as the access type for all managed classes in\n+            the persistence unit\n+        cascade-persist - Adds cascade-persist to the set of cascade options\n+            in entity relationships of the persistence unit\n+        entity-listeners - List of default entity listeners to be invoked \n+            on each entity in the persistence unit. \n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+        <xsd:element name=\"schema\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"catalog\" type=\"xsd:string\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"access\" type=\"orm:access-type\"\n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"cascade-persist\" type=\"orm:emptyType\" \n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\"\n+                     minOccurs=\"0\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"entity\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        Defines the settings and mappings for an entity. Is allowed to be\n+        sparsely populated and used in conjunction with the annotations.\n+        Alternatively, the metadata-complete attribute can be used to \n+        indicate that no annotations on the entity class (and its fields\n+        or properties) are to be processed. If this is the case then \n+        the defaulting rules for the entity and its subelements will \n+        be recursively applied.\n+\n+        @Target(TYPE) @Retention(RUNTIME)\n+          public @interface Entity {\n+          String name() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/>\n+      <xsd:element name=\"table\" type=\"orm:table\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"secondary-table\" type=\"orm:secondary-table\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"primary-key-join-column\" \n+                   type=\"orm:primary-key-join-column\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"id-class\" type=\"orm:id-class\" minOccurs=\"0\"/>\n+      <xsd:element name=\"inheritance\" type=\"orm:inheritance\" minOccurs=\"0\"/>\n+      <xsd:element name=\"discriminator-value\" type=\"orm:discriminator-value\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"discriminator-column\" \n+                   type=\"orm:discriminator-column\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"table-generator\" type=\"orm:table-generator\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"named-query\" type=\"orm:named-query\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"named-native-query\" type=\"orm:named-native-query\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"sql-result-set-mapping\" \n+                   type=\"orm:sql-result-set-mapping\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"exclude-default-listeners\" type=\"orm:emptyType\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"exclude-superclass-listeners\" type=\"orm:emptyType\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-persist\" type=\"orm:post-persist\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/>\n+      <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"association-override\" \n+                   type=\"orm:association-override\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"attributes\" type=\"orm:attributes\" minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"access\" type=\"orm:access-type\"/>\n+    <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"attributes\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        This element contains the entity field or property mappings.\n+        It may be sparsely populated to include only a subset of the\n+        fields or properties. If metadata-complete for the entity is true\n+        then the remainder of the attributes will be defaulted according\n+        to the default rules.\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:choice>\n+        <xsd:element name=\"id\" type=\"orm:id\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"embedded-id\" type=\"orm:embedded-id\" \n+                     minOccurs=\"0\"/>\n+      </xsd:choice>\n+      <xsd:element name=\"basic\" type=\"orm:basic\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"version\" type=\"orm:version\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"many-to-one\" type=\"orm:many-to-one\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"one-to-many\" type=\"orm:one-to-many\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"one-to-one\" type=\"orm:one-to-one\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"many-to-many\" type=\"orm:many-to-many\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"embedded\" type=\"orm:embedded\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"transient\" type=\"orm:transient\"\n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"access-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        This element determines how the persistence provider accesses the\n+        state of an entity or embedded object.\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"PROPERTY\"/>\n+      <xsd:enumeration value=\"FIELD\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"entity-listeners\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface EntityListeners {\n+          Class[] value();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"entity-listener\" type=\"orm:entity-listener\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"entity-listener\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        Defines an entity listener to be invoked at lifecycle events\n+        for the entities that list this listener.\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-persist\" type=\"orm:post-persist\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"pre-persist\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PrePersist {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"post-persist\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PostPersist {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"pre-remove\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PreRemove {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"post-remove\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PostRemove {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"pre-update\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PreUpdate {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"post-update\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PostUpdate {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"post-load\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD}) @Retention(RUNTIME)\n+        public @interface PostLoad {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"query-hint\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({}) @Retention(RUNTIME) \n+        public @interface QueryHint {\n+          String name();\n+          String value();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"value\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"named-query\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface NamedQuery {\n+          String name();\n+          String query();\n+          QueryHint[] hints() default {};\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"query\" type=\"xsd:string\"/>\n+      <xsd:element name=\"hint\" type=\"orm:query-hint\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"named-native-query\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface NamedNativeQuery {\n+          String name();\n+          String query();\n+          QueryHint[] hints() default {};\n+          Class resultClass() default void.class;\n+          String resultSetMapping() default \"\"; //named SqlResultSetMapping\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"query\" type=\"xsd:string\"/>\n+      <xsd:element name=\"hint\" type=\"orm:query-hint\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"result-class\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"result-set-mapping\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"sql-result-set-mapping\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface SqlResultSetMapping {\n+          String name();\n+          EntityResult[] entities() default {};\n+          ColumnResult[] columns() default {};\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"entity-result\" type=\"orm:entity-result\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"column-result\" type=\"orm:column-result\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"entity-result\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({}) @Retention(RUNTIME)\n+        public @interface EntityResult {\n+          Class entityClass();\n+          FieldResult[] fields() default {};\n+          String discriminatorColumn() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"field-result\" type=\"orm:field-result\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"entity-class\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"discriminator-column\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"field-result\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({}) @Retention(RUNTIME)\n+        public @interface FieldResult {\n+          String name();\n+          String column();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"column\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"column-result\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({}) @Retention(RUNTIME)\n+        public @interface ColumnResult {\n+          String name();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"table\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface Table {\n+          String name() default \"\";\n+          String catalog() default \"\";\n+          String schema() default \"\";\n+          UniqueConstraint[] uniqueConstraints() default {};\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"catalog\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"schema\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"secondary-table\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface SecondaryTable {\n+          String name();\n+          String catalog() default \"\";\n+          String schema() default \"\";\n+          PrimaryKeyJoinColumn[] pkJoinColumns() default {};\n+          UniqueConstraint[] uniqueConstraints() default {};\n+         }\n+\n+       </xsd:documentation>\n+     </xsd:annotation>\n+     <xsd:sequence>\n+       <xsd:element name=\"primary-key-join-column\" \n+                    type=\"orm:primary-key-join-column\" \n+                    minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+       <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" \n+                    minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"catalog\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"schema\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"unique-constraint\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({}) @Retention(RUNTIME)\n+        public @interface UniqueConstraint {\n+          String[] columnNames();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"column-name\" type=\"xsd:string\" \n+                   maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"column\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Column {\n+          String name() default \"\";\n+          boolean unique() default false;\n+          boolean nullable() default true;\n+          boolean insertable() default true;\n+          boolean updatable() default true;\n+          String columnDefinition() default \"\";\n+          String table() default \"\";\n+          int length() default 255;\n+          int precision() default 0; // decimal precision\n+          int scale() default 0; // decimal scale\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"unique\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"nullable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"insertable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"updatable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"table\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"length\" type=\"xsd:int\"/>\n+    <xsd:attribute name=\"precision\" type=\"xsd:int\"/>\n+    <xsd:attribute name=\"scale\" type=\"xsd:int\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"join-column\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface JoinColumn {\n+          String name() default \"\";\n+          String referencedColumnName() default \"\";\n+          boolean unique() default false;\n+          boolean nullable() default true;\n+          boolean insertable() default true;\n+          boolean updatable() default true;\n+          String columnDefinition() default \"\";\n+          String table() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"referenced-column-name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"unique\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"nullable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"insertable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"updatable\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"table\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"generation-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum GenerationType { TABLE, SEQUENCE, IDENTITY, AUTO };\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"TABLE\"/>\n+      <xsd:enumeration value=\"SEQUENCE\"/>\n+      <xsd:enumeration value=\"IDENTITY\"/>\n+      <xsd:enumeration value=\"AUTO\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"attribute-override\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface AttributeOverride {\n+          String name();\n+          Column column();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"column\" type=\"orm:column\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"association-override\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface AssociationOverride {\n+          String name();\n+          JoinColumn[] joinColumns();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"join-column\" type=\"orm:join-column\"\n+                   maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"id-class\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface IdClass {\n+          Class value();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"id\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Id {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"column\" type=\"orm:column\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"generated-value\" type=\"orm:generated-value\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"temporal\" type=\"orm:temporal\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"table-generator\" type=\"orm:table-generator\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\"\n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"embedded-id\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface EmbeddedId {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"transient\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Transient {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"version\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Version {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"column\" type=\"orm:column\" minOccurs=\"0\"/>\n+      <xsd:element name=\"temporal\" type=\"orm:temporal\" minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"basic\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Basic {\n+          FetchType fetch() default EAGER;\n+          boolean optional() default true;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"column\" type=\"orm:column\" minOccurs=\"0\"/>\n+      <xsd:choice>\n+        <xsd:element name=\"lob\" type=\"orm:lob\" minOccurs=\"0\"/>\n+        <xsd:element name=\"temporal\" type=\"orm:temporal\" minOccurs=\"0\"/>\n+        <xsd:element name=\"enumerated\" type=\"orm:enumerated\" minOccurs=\"0\"/>\n+      </xsd:choice>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/>\n+    <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"fetch-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum FetchType { LAZY, EAGER };\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"LAZY\"/>\n+      <xsd:enumeration value=\"EAGER\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"lob\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Lob {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"temporal\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Temporal {\n+          TemporalType value();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"orm:temporal-type\"/>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"temporal-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum TemporalType {\n+          DATE, // java.sql.Date\n+          TIME, // java.sql.Time\n+          TIMESTAMP // java.sql.Timestamp\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+      <xsd:restriction base=\"xsd:token\">\n+        <xsd:enumeration value=\"DATE\"/>\n+        <xsd:enumeration value=\"TIME\"/>\n+        <xsd:enumeration value=\"TIMESTAMP\"/>\n+     </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"enumerated\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Enumerated {\n+          EnumType value() default ORDINAL;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"orm:enum-type\"/>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"enum-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum EnumType {\n+          ORDINAL,\n+          STRING\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"ORDINAL\"/>\n+      <xsd:enumeration value=\"STRING\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"many-to-one\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface ManyToOne {\n+          Class targetEntity() default void.class;\n+          CascadeType[] cascade() default {};\n+          FetchType fetch() default EAGER;\n+          boolean optional() default true;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:choice>       \n+        <xsd:element name=\"join-column\" type=\"orm:join-column\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"join-table\" type=\"orm:join-table\" \n+                     minOccurs=\"0\"/>\n+      </xsd:choice>       \n+      <xsd:element name=\"cascade\" type=\"orm:cascade-type\" \n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/>\n+    <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"cascade-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum CascadeType { ALL, PERSIST, MERGE, REMOVE, REFRESH};\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"cascade-all\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"cascade-persist\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"cascade-merge\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"cascade-remove\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"cascade-refresh\" type=\"orm:emptyType\"\n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"one-to-one\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface OneToOne {\n+          Class targetEntity() default void.class;\n+          CascadeType[] cascade() default {};\n+          FetchType fetch() default EAGER;\n+          boolean optional() default true;\n+          String mappedBy() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:choice>\n+        <xsd:element name=\"primary-key-join-column\" \n+                     type=\"orm:primary-key-join-column\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"join-column\" type=\"orm:join-column\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+        <xsd:element name=\"join-table\" type=\"orm:join-table\" \n+                     minOccurs=\"0\"/>\n+      </xsd:choice>\n+      <xsd:element name=\"cascade\" type=\"orm:cascade-type\" \n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/>\n+    <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/>\n+    <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"one-to-many\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface OneToMany {\n+          Class targetEntity() default void.class;\n+          CascadeType[] cascade() default {};\n+          FetchType fetch() default LAZY;\n+          String mappedBy() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"order-by\" type=\"orm:order-by\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"map-key\" type=\"orm:map-key\" \n+                   minOccurs=\"0\"/>\n+      <xsd:choice>       \n+        <xsd:element name=\"join-table\" type=\"orm:join-table\" \n+                     minOccurs=\"0\"/>\n+        <xsd:element name=\"join-column\" type=\"orm:join-column\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      </xsd:choice>       \n+      <xsd:element name=\"cascade\" type=\"orm:cascade-type\" \n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/>\n+    <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"join-table\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface JoinTable {\n+          String name() default \"\";\n+          String catalog() default \"\";\n+          String schema() default \"\";\n+          JoinColumn[] joinColumns() default {};\n+          JoinColumn[] inverseJoinColumns() default {};\n+          UniqueConstraint[] uniqueConstraints() default {};\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"join-column\" type=\"orm:join-column\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"inverse-join-column\" type=\"orm:join-column\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"catalog\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"schema\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"many-to-many\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface ManyToMany {\n+          Class targetEntity() default void.class;\n+          CascadeType[] cascade() default {};\n+          FetchType fetch() default LAZY;\n+          String mappedBy() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"order-by\" type=\"orm:order-by\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"map-key\" type=\"orm:map-key\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"join-table\" type=\"orm:join-table\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"cascade\" type=\"orm:cascade-type\" \n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/>\n+    <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"generated-value\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface GeneratedValue {\n+          GenerationType strategy() default AUTO;\n+          String generator() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"strategy\" type=\"orm:generation-type\"/>\n+    <xsd:attribute name=\"generator\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"map-key\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface MapKey {\n+          String name() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"order-by\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface OrderBy {\n+          String value() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:string\"/>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"inheritance\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface Inheritance {\n+          InheritanceType strategy() default SINGLE_TABLE;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"strategy\" type=\"orm:inheritance-type\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"inheritance-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum InheritanceType\n+          { SINGLE_TABLE, JOINED, TABLE_PER_CLASS};\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"SINGLE_TABLE\"/>\n+      <xsd:enumeration value=\"JOINED\"/>\n+      <xsd:enumeration value=\"TABLE_PER_CLASS\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"discriminator-value\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface DiscriminatorValue {\n+          String value();\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:string\"/>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"discriminator-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum DiscriminatorType { STRING, CHAR, INTEGER };\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"STRING\"/>\n+      <xsd:enumeration value=\"CHAR\"/>\n+      <xsd:enumeration value=\"INTEGER\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"primary-key-join-column\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface PrimaryKeyJoinColumn {\n+          String name() default \"\";\n+          String referencedColumnName() default \"\";\n+          String columnDefinition() default \"\";\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"referenced-column-name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"discriminator-column\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface DiscriminatorColumn {\n+          String name() default \"DTYPE\";\n+          DiscriminatorType discriminatorType() default STRING;\n+          String columnDefinition() default \"\";\n+          int length() default 31;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"discriminator-type\" type=\"orm:discriminator-type\"/>\n+    <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"length\" type=\"xsd:int\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"embeddable\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        Defines the settings and mappings for embeddable objects. Is \n+        allowed to be sparsely populated and used in conjunction with \n+        the annotations. Alternatively, the metadata-complete attribute \n+        can be used to indicate that no annotations are to be processed \n+        in the class. If this is the case then the defaulting rules will \n+        be recursively applied.\n+\n+        @Target({TYPE}) @Retention(RUNTIME)\n+        public @interface Embeddable {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/>\n+      <xsd:element name=\"attributes\" type=\"orm:embeddable-attributes\" \n+                   minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"access\" type=\"orm:access-type\"/>\n+    <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"embeddable-attributes\">\n+    <xsd:sequence>\n+      <xsd:element name=\"basic\" type=\"orm:basic\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+      <xsd:element name=\"transient\" type=\"orm:transient\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"embedded\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface Embedded {}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"mapped-superclass\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        Defines the settings and mappings for a mapped superclass. Is \n+        allowed to be sparsely populated and used in conjunction with \n+        the annotations. Alternatively, the metadata-complete attribute \n+        can be used to indicate that no annotations are to be processed \n+        If this is the case then the defaulting rules will be recursively \n+        applied.\n+\n+        @Target(TYPE) @Retention(RUNTIME)\n+        public @interface MappedSuperclass{}\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/>\n+      <xsd:element name=\"id-class\" type=\"orm:id-class\" minOccurs=\"0\"/>\n+      <xsd:element name=\"exclude-default-listeners\" type=\"orm:emptyType\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"exclude-superclass-listeners\" type=\"orm:emptyType\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-persist\" type=\"orm:post-persist\" \n+                   minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/>\n+      <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/>\n+      <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/>\n+      <xsd:element name=\"attributes\" type=\"orm:attributes\" minOccurs=\"0\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"access\" type=\"orm:access-type\"/>\n+    <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"sequence-generator\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface SequenceGenerator {\n+          String name();\n+          String sequenceName() default \"\";\n+          int initialValue() default 1;\n+          int allocationSize() default 50;\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"sequence-name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"initial-value\" type=\"xsd:int\"/>\n+    <xsd:attribute name=\"allocation-size\" type=\"xsd:int\"/>\n+  </xsd:complexType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:complexType name=\"table-generator\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME)\n+        public @interface TableGenerator {\n+          String name();\n+          String table() default \"\";\n+          String catalog() default \"\";\n+          String schema() default \"\";\n+          String pkColumnName() default \"\";\n+          String valueColumnName() default \"\";\n+          String pkColumnValue() default \"\";\n+          int initialValue() default 0;\n+          int allocationSize() default 50;\n+          UniqueConstraint[] uniqueConstraints() default {};\n+        }\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:sequence>\n+      <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" \n+                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n+    </xsd:sequence>\n+    <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/>\n+    <xsd:attribute name=\"table\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"catalog\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"schema\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"pk-column-name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"value-column-name\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"pk-column-value\" type=\"xsd:string\"/>\n+    <xsd:attribute name=\"initial-value\" type=\"xsd:int\"/>\n+    <xsd:attribute name=\"allocation-size\" type=\"xsd:int\"/>\n+  </xsd:complexType>\n+\n+</xsd:schema>\n+\n+"},{"sha":"88a61a90ee3f63b8e62e5ae34b8d038aac58f9aa","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/persistence-xsd.rsrc","status":"added","additions":260,"deletions":0,"changes":260,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/persistence-xsd.rsrc","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/persistence-xsd.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/persistence-xsd.rsrc?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- persistence.xml schema -->\n+<xsd:schema targetNamespace=\"http://java.sun.com/xml/ns/persistence\" \n+  xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n+  xmlns:persistence=\"http://java.sun.com/xml/ns/persistence\"\n+  elementFormDefault=\"qualified\" \n+  attributeFormDefault=\"unqualified\" \n+  version=\"1.0\">\n+\n+  <xsd:annotation>\n+    <xsd:documentation>\n+      @(#)persistence_1_0.xsd  1.0  Feb 9 2006\n+    </xsd:documentation>\n+  </xsd:annotation>\n+   <xsd:annotation>\n+     <xsd:documentation><![CDATA[\n+\n+     This is the XML Schema for the persistence configuration file.\n+     The file must be named \"META-INF/persistence.xml\" in the \n+     persistence archive.\n+     Persistence configuration files must indicate\n+     the persistence schema by using the persistence namespace:\n+\n+     http://java.sun.com/xml/ns/persistence\n+\n+     and indicate the version of the schema by\n+     using the version element as shown below:\n+\n+      <persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"\n+        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+        xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence\n+          http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd\"\n+        version=\"1.0\">\n+          ...\n+      </persistence>\n+\n+    ]]></xsd:documentation>\n+  </xsd:annotation>\n+\n+  <xsd:simpleType name=\"versionType\">\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:pattern value=\"[0-9]+(\\.[0-9]+)*\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:element name=\"persistence\">\n+    <xsd:complexType>\n+      <xsd:sequence>\n+\n+        <!-- **************************************************** -->\n+\n+        <xsd:element name=\"persistence-unit\" \n+                     minOccurs=\"0\" maxOccurs=\"unbounded\">\n+          <xsd:complexType>\n+            <xsd:annotation>\n+              <xsd:documentation>\n+\n+                Configuration of a persistence unit.\n+\n+              </xsd:documentation>\n+            </xsd:annotation>\n+            <xsd:sequence>\n+\n+            <!-- **************************************************** -->\n+\n+              <xsd:element name=\"description\" type=\"xsd:string\" \n+                           minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    Textual description of this persistence unit.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"provider\" type=\"xsd:string\" \n+                           minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    Provider class that supplies EntityManagers for this \n+                    persistence unit.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"jta-data-source\" type=\"xsd:string\" \n+                           minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    The container-specific name of the JTA datasource to use.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"non-jta-data-source\" type=\"xsd:string\" \n+                           minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    The container-specific name of a non-JTA datasource to use.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"mapping-file\" type=\"xsd:string\" \n+                           minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    File containing mapping information. Loaded as a resource \n+                    by the persistence provider.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"jar-file\" type=\"xsd:string\" \n+                           minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    Jar file that should be scanned for entities. \n+                    Not applicable to Java SE persistence units.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"class\" type=\"xsd:string\" \n+                           minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    Class to scan for annotations.  It should be annotated \n+                    with either @Entity, @Embeddable or @MappedSuperclass.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"exclude-unlisted-classes\" type=\"xsd:boolean\" \n+                           default=\"false\" minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    When set to true then only listed classes and jars will \n+                    be scanned for persistent classes, otherwise the enclosing \n+                    jar or directory will also be scanned. Not applicable to \n+                    Java SE persistence units.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+              </xsd:element>\n+\n+              <!-- **************************************************** -->\n+\n+              <xsd:element name=\"properties\" minOccurs=\"0\">\n+                <xsd:annotation>\n+                  <xsd:documentation>\n+\n+                    A list of vendor-specific properties.\n+\n+                  </xsd:documentation>\n+                </xsd:annotation>\n+                <xsd:complexType>\n+                  <xsd:sequence>\n+                    <xsd:element name=\"property\" \n+                                 minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                      <xsd:annotation>\n+                        <xsd:documentation>\n+                          A name-value pair.\n+                        </xsd:documentation>\n+                      </xsd:annotation>\n+                      <xsd:complexType>\n+                        <xsd:attribute name=\"name\" type=\"xsd:string\" \n+                                       use=\"required\"/>\n+                        <xsd:attribute name=\"value\" type=\"xsd:string\" \n+                                       use=\"required\"/>\n+                      </xsd:complexType>\n+                    </xsd:element>\n+                  </xsd:sequence>\n+                </xsd:complexType>\n+              </xsd:element>\n+\n+            </xsd:sequence>\n+\n+            <!-- **************************************************** -->\n+\n+            <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\">\n+              <xsd:annotation>\n+                <xsd:documentation>\n+\n+                  Name used in code to reference this persistence unit.\n+\n+                </xsd:documentation>\n+              </xsd:annotation>\n+            </xsd:attribute>\n+\n+            <!-- **************************************************** -->\n+\n+            <xsd:attribute name=\"transaction-type\" \n+                           type=\"persistence:persistence-unit-transaction-type\">\n+              <xsd:annotation>\n+                <xsd:documentation>\n+\n+                  Type of transactions used by EntityManagers from this \n+                  persistence unit.\n+\n+                </xsd:documentation>\n+              </xsd:annotation>\n+            </xsd:attribute>\n+\n+          </xsd:complexType>\n+        </xsd:element>\n+      </xsd:sequence>\n+      <xsd:attribute name=\"version\" type=\"persistence:versionType\" \n+                     fixed=\"1.0\" use=\"required\"/>\n+    </xsd:complexType>\n+  </xsd:element>\n+\n+  <!-- **************************************************** -->\n+\n+  <xsd:simpleType name=\"persistence-unit-transaction-type\">\n+    <xsd:annotation>\n+      <xsd:documentation>\n+\n+        public enum TransactionType { JTA, RESOURCE_LOCAL };\n+\n+      </xsd:documentation>\n+    </xsd:annotation>\n+    <xsd:restriction base=\"xsd:token\">\n+      <xsd:enumeration value=\"JTA\"/>\n+      <xsd:enumeration value=\"RESOURCE_LOCAL\"/>\n+    </xsd:restriction>\n+  </xsd:simpleType>\n+\n+</xsd:schema>\n+"},{"sha":"5bb046e7f58c191615aff1b7e188f9ee05baf8ae","filename":"openjpa-xmlstore/pom.xml","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/pom.xml?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,51 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa-xmlstore</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>JPA</name>\n+    <description>JPA</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>org.apache.openjpa</groupId>\n+            <artifactId>openjpa-kernel</artifactId>\n+            <version>0.0.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.3</source>\n+                    <target>1.3</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+\n+</project>"},{"sha":"aedd02f0922b97e3fc561d0eac2f9cbac8c0685b","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","status":"added","additions":358,"deletions":0,"changes":358,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/ObjectData.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,358 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.xmlstore;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.event.OrphanedKeyAction;\r\n+import org.apache.openjpa.kernel.FetchState;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.Proxy;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * In-memory form of data in datastore backing a single persistent object.\r\n+ */\r\n+public final class ObjectData implements Cloneable {\r\n+\r\n+    private Object _oid;\r\n+    private Object[] _data;\r\n+    private Long _version;\r\n+    private ClassMetaData _meta;\r\n+\r\n+    /**\r\n+     * Create the object without underlying data. Just pass in type specific\r\n+     * metadata and the oid.\r\n+     */\r\n+    public ObjectData(Object oid, ClassMetaData meta) {\r\n+        _oid = oid;\r\n+        _meta = meta;\r\n+        _data = new Object[meta.getFields().length];\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for oid.\r\n+     */\r\n+    public Object getId() {\r\n+        return _oid;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the data for the field with the given index.\r\n+     */\r\n+    public Object getField(int num) {\r\n+        return _data[num];\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the data for the field with the given index.\r\n+     */\r\n+    public void setField(int num, Object val) {\r\n+        _data[num] = val;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the version number of the object.\r\n+     */\r\n+    public void setVersion(Long version) {\r\n+        _version = version;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the version number of the object.\r\n+     */\r\n+    public Long getVersion() {\r\n+        return _version;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the metadata associated with the type of persistent object for\r\n+     * which this data applies.\r\n+     */\r\n+    public ClassMetaData getMetaData() {\r\n+        return _meta;\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the data and version information for this object into the\r\n+     * given state manager. Only fields in the given fetch configuration are\r\n+     * loaded.\r\n+     */\r\n+    public void load(OpenJPAStateManager sm, FetchState fetchState) {\r\n+        if (sm.getVersion() == null)\r\n+            sm.setVersion(_version);\r\n+        FieldMetaData[] fmds = _meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            if (fmds[i].getManagement() == fmds[i].MANAGE_PERSISTENT\r\n+                && (fetchState.requiresLoad(sm, fmds[i]))) {\r\n+                sm.store(i, toLoadable(sm, fmds[i], _data[i], fetchState));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the data and version information for this object into the\r\n+     * given state manager. Only fields in the given bit set will be loaded.\r\n+     */\r\n+    public void load(OpenJPAStateManager sm, BitSet fields,\r\n+        FetchState fetchState) {\r\n+        if (sm.getVersion() == null)\r\n+            sm.setVersion(_version);\r\n+        FieldMetaData[] fmds = _meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++)\r\n+            if (fields.get(i))\r\n+                sm.store(i, toLoadable(sm, fmds[i], _data[i], fetchState));\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert the stored value <code>val</code> into a value for loading\r\n+     * into a state manager.\r\n+     */\r\n+    private static Object toLoadable(OpenJPAStateManager sm,\r\n+        FieldMetaData fmd, Object val, FetchState fetchState) {\r\n+        if (val == null)\r\n+            return null;\r\n+        Collection c;\r\n+        switch (fmd.getTypeCode()) {\r\n+            case JavaTypes.COLLECTION:\r\n+                // the stored value must be a collection\r\n+                c = (Collection) val;\r\n+                // the state manager will create a proxy collection of the needed\r\n+                // type depending on the declared type of the user's field; the\r\n+                // proxy will perform dirty tracking, etc\r\n+                Collection c2 = (Collection) sm.newFieldProxy(fmd.getIndex());\r\n+                // populate the proxy collection with our stored data, converting\r\n+                // it to the right type from its stored form\r\n+                for (Iterator itr = c.iterator(); itr.hasNext();)\r\n+                    c2.add(toNestedLoadable(sm, fmd.getElement(), itr.next(),\r\n+                        fetchState));\r\n+                return c2;\r\n+            case JavaTypes.ARRAY:\r\n+                // the stored value must be a collection; we put arrays into\r\n+                // collections for storage\r\n+                c = (Collection) val;\r\n+                // create a new array of the right type; unlike collections in\r\n+                // the case above, arrays cannot be proxied\r\n+                Object a =\r\n+                    Array.newInstance(fmd.getElement().getType(), c.size());\r\n+                // populate the array with our stored data, converting it to the\r\n+                // right type from its stored form\r\n+                int idx = 0;\r\n+                for (Iterator itr = c.iterator(); itr.hasNext(); idx++)\r\n+                    Array.set(a, idx, toNestedLoadable(sm, fmd.getElement(),\r\n+                        itr.next(), fetchState));\r\n+                return a;\r\n+            case JavaTypes.MAP:\r\n+                // the stored value must be a map\r\n+                Map m = (Map) val;\r\n+                // the state manager will create a proxy map of the needed\r\n+                // type depending on the declared type of the user's field; the\r\n+                // proxy will perform dirty tracking, etc\r\n+                Map m2 = (Map) sm.newFieldProxy(fmd.getIndex());\r\n+                // populate the proxy map with our stored data, converting\r\n+                // it to the right type from its stored form\r\n+                for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n+                    Map.Entry e = (Map.Entry) itr.next();\r\n+                    m2.put(toNestedLoadable(sm, fmd.getKey(), e.getKey(),\r\n+                        fetchState),\r\n+                        toNestedLoadable(sm, fmd.getElement(), e.getValue(),\r\n+                            fetchState));\r\n+                }\r\n+                return m2;\r\n+            default:\r\n+                // just convert the stored value into its loadable equivalent.\r\n+                return toNestedLoadable(sm, fmd, val, fetchState);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert the given stored value <code>val</code> to a value for loading\r\n+     * into a state manager. The value <code>val</code> must be a singular\r\n+     * value; it cannot be a container.\r\n+     */\r\n+    private static Object toNestedLoadable(OpenJPAStateManager sm,\r\n+        ValueMetaData vmd, Object val, FetchState fetchState) {\r\n+        if (val == null)\r\n+            return null;\r\n+        switch (vmd.getTypeCode()) {\r\n+            // clone the date to prevent direct modification of our stored value\r\n+            case JavaTypes.DATE:\r\n+                return ((Date) val).clone();\r\n+            case JavaTypes.PC:\r\n+            case JavaTypes.PC_UNTYPED:\r\n+                // for relations to other persistent objects, we store the related\r\n+                // object's oid -- convert it back into a persistent instance\r\n+                StoreContext ctx = sm.getContext();\r\n+                Object pc = ctx.find(val, fetchState, null, null, 0);\r\n+                if (pc != null)\r\n+                    return pc;\r\n+                OrphanedKeyAction action = ctx.getConfiguration().\r\n+                    getOrphanedKeyActionInstance();\r\n+                return action.orphan(val, sm, vmd);\r\n+            default:\r\n+                return val;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Store the data and version information for this object from the\r\n+     * given state manager. Only dirty fields will be stored.\r\n+     */\r\n+    public void store(OpenJPAStateManager sm) {\r\n+        _version = (Long) sm.getVersion();\r\n+        // if the version has not been set in the state manager(only true\r\n+        // when the object is new), set the version number to 0\r\n+        if (_version == null)\r\n+            _version = Numbers.valueOf(0L);\r\n+        // run through each persistent field in the state manager and store it\r\n+        FieldMetaData[] fmds = _meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            if (sm.getDirty().get(i)\r\n+                && fmds[i].getManagement() == fmds[i].MANAGE_PERSISTENT)\r\n+                _data[i] = toStorable(fmds[i], sm.fetch(i), sm.getContext());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert the given field value <code>val</code> to a form we can store.\r\n+     */\r\n+    private static Object toStorable(FieldMetaData fmd, Object val,\r\n+        StoreContext ctx) {\r\n+        if (val == null)\r\n+            return null;\r\n+        Collection c;\r\n+        switch (fmd.getTypeCode()) {\r\n+            case JavaTypes.COLLECTION:\r\n+                c = (Collection) val;\r\n+                // create a collection to copy the elements into for storage, and\r\n+                // populate it with converted element values\r\n+                Collection c2 = new ArrayList();\r\n+                for (Iterator itr = c.iterator(); itr.hasNext();)\r\n+                    c2.add(toNestedStorable(fmd.getElement(), itr.next(), ctx));\r\n+                return c2;\r\n+            case JavaTypes.ARRAY:\r\n+                // create a collection to copy the elements into for storage, and\r\n+                // populate it with converted element values\r\n+                c = new ArrayList();\r\n+                for (int i = 0, len = Array.getLength(val); i < len; i++)\r\n+                    c.add(toNestedStorable(fmd.getElement(), Array.get(val, i),\r\n+                        ctx));\r\n+                return c;\r\n+            case JavaTypes.MAP:\r\n+                Map m = (Map) val;\r\n+                // create a map to copy the entries into for storage, and\r\n+                // populate it with converted entry values\r\n+                Map m2 = new HashMap();\r\n+                for (Iterator itr = m.entrySet().iterator(); itr.hasNext();) {\r\n+                    Map.Entry e = (Map.Entry) itr.next();\r\n+                    m2.put(toNestedStorable(fmd.getKey(), e.getKey(), ctx),\r\n+                        toNestedStorable(fmd.getElement(), e.getValue(), ctx));\r\n+                }\r\n+                return m2;\r\n+            default:\r\n+                // just convert the loaded value into its storable equivalent\r\n+                return toNestedStorable(fmd, val, ctx);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Convert the given loaded value <code>val</code> to a value for storing.\r\n+     * The value <code>val</code> must be a singular value; it cannot be a\r\n+     * container.\r\n+     */\r\n+    private static Object toNestedStorable(ValueMetaData vmd, Object val,\r\n+        StoreContext ctx) {\r\n+        if (val == null)\r\n+            return null;\r\n+        switch (vmd.getTypeCode()) {\r\n+            case JavaTypes.DATE:\r\n+                // if the date is a proxy(since Dates are second class\r\n+                // objects(SCOs) they can be proxied for dirty tracking,\r\n+                // etc) then copy the value out of it for storage\r\n+                if (val instanceof Proxy)\r\n+                    return ((Proxy) val).copy(val);\r\n+                return ((Date) val).clone();\r\n+            case JavaTypes.PC:\r\n+            case JavaTypes.PC_UNTYPED:\r\n+                return ctx.getObjectId(val);\r\n+            case JavaTypes.COLLECTION:\r\n+            case JavaTypes.ARRAY:\r\n+            case JavaTypes.MAP:\r\n+                // nested relation types(e.g. collections of collections)\r\n+                // are not currently supported\r\n+                throw new UnsupportedException(\"This store does not support \"\r\n+                    + \"nested containers(e.g. collections of collections).\");\r\n+            default:\r\n+                return val;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Clone this data.\r\n+     */\r\n+    public Object clone() {\r\n+        ObjectData data = new ObjectData(_oid, _meta);\r\n+        data.setVersion(_version);\r\n+        // copy each field\r\n+        FieldMetaData[] fmds = _meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            Object val = _data[i];\r\n+            if (val == null) {\r\n+                data.setField(i, null);\r\n+                continue;\r\n+            }\r\n+            switch (fmds[i].getTypeCode()) {\r\n+                case JavaTypes.COLLECTION:\r\n+                case JavaTypes.ARRAY:\r\n+                    data.setField(i, new ArrayList((Collection) val));\r\n+                    break;\r\n+                case JavaTypes.MAP:\r\n+                    data.setField(i, new HashMap((Map) val));\r\n+                    break;\r\n+                default:\r\n+                    data.setField(i, val);\r\n+            }\r\n+        }\r\n+        return data;\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(\"Class: (\" + _meta.getDescribedType().getName() + \")\\n\");\r\n+        buf.append(\"Object Id: (\" + _oid + \")\\n\");\r\n+        buf.append(\"Version: (\" + _version + \")\\n\");\r\n+        FieldMetaData[] fmds = _meta.getFields();\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            buf.append(\"  Field: (\" + i + \")\\n\");\r\n+            buf.append(\"  Name: (\" + fmds[i].getName() + \")\\n\");\r\n+            buf.append(\"  Value: (\" + _data[i] + \")\\n\");\r\n+        }\r\n+        return buf.toString();\r\n+    }\r\n+}\r"},{"sha":"9d69f8edccede6e82a5d7e0e4fd9edf0b93175c3","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLConfiguration.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,67 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.xmlstore;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\r\n+import org.apache.openjpa.conf.ProductDerivations;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.BrokerFactory;\r\n+\r\n+/**\r\n+ * Configuration implementation for the XML file store. Each unique\r\n+ * {@link BrokerFactory} has a distinct configuration instance.\r\n+ * Thus this configuration is shared by all {@link Broker}s\r\n+ * associated with the owning factory, and is a good place to provide access\r\n+ * to shared resources. Note that each broker has its own\r\n+ * {@link org.apache.openjpa.abstractstore.AbstractStoreManager}.\r\n+ */\r\n+public class XMLConfiguration extends OpenJPAConfigurationImpl {\r\n+\r\n+    // shared resources\r\n+    private XMLStore _store;\r\n+    private XMLFileHandler _handler;\r\n+\r\n+    /**\r\n+     * Default constructor.\r\n+     */\r\n+    public XMLConfiguration() {\r\n+        super(false, false);\r\n+        // override the default and the current value of lock manager plugin\r\n+        // from our superclass to use the single-jvm lock manager\r\n+        lockManagerPlugin.setDefault(\"version\");\r\n+        lockManagerPlugin.setString(\"version\");\r\n+        ProductDerivations.beforeConfigurationLoad(this);\r\n+        loadDefaults();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link XMLFileHandler} associated with this configuration.\r\n+     */\r\n+    public synchronized XMLFileHandler getFileHandler() {\r\n+        if (_handler == null)\r\n+            _handler = new XMLFileHandler(this);\r\n+        return _handler;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link XMLStore} associated with this configuration.\r\n+     */\r\n+    public synchronized XMLStore getStore() {\r\n+        if (_store == null)\r\n+            _store = new XMLStore(this);\r\n+        return _store;\r\n+    }\r\n+}\r"},{"sha":"9706a7ae9c1f45c25102cf9f623884403a1889b0","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","status":"added","additions":599,"deletions":0,"changes":599,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLFileHandler.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,599 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.xmlstore;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.File;\r\n+import java.io.FileWriter;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.Serializable;\r\n+import java.io.Writer;\r\n+import java.lang.reflect.Constructor;\r\n+import java.math.BigDecimal;\r\n+import java.math.BigInteger;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Locale;\r\n+import java.util.Map;\r\n+import javax.xml.parsers.SAXParser;\r\n+\r\n+import org.xml.sax.Attributes;\r\n+import org.xml.sax.SAXException;\r\n+import org.xml.sax.helpers.DefaultHandler;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.lib.util.Base16Encoder;\r\n+import org.apache.openjpa.lib.xml.XMLFactory;\r\n+import org.apache.openjpa.lib.xml.XMLWriter;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.util.Id;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.StoreException;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+\r\n+/**\r\n+ * Stores {@link ObjectData} objects by serializing a collection\r\n+ * of them into and out of an XML file.\r\n+ */\r\n+public class XMLFileHandler {\r\n+\r\n+    private final XMLConfiguration _conf;\r\n+\r\n+    /**\r\n+     * Constructor; supply configuration.\r\n+     */\r\n+    public XMLFileHandler(XMLConfiguration conf) {\r\n+        _conf = conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Loads all instances of <code>meta</code> into a list of objects.\r\n+     * The given <code>meta</code> must represent a least-derived\r\n+     * persistence-capable type.\r\n+     */\r\n+    public Collection load(ClassMetaData meta) {\r\n+        File f = getFile(meta);\r\n+        if (!f.exists() || f.length() == 0)\r\n+            return Collections.EMPTY_SET;\r\n+        try {\r\n+            return read(f);\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new StoreException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a collection of {@link ObjectData}s from the contents of the\r\n+     * given file.\r\n+     */\r\n+    private Collection read(File f) throws Exception {\r\n+        // parse the file and return the objects it contains\r\n+        SAXParser parser = XMLFactory.getSAXParser(false, false);\r\n+        ObjectDataHandler handler = new ObjectDataHandler(_conf);\r\n+        parser.parse(f, handler);\r\n+        return handler.getExtent();\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a {@link File} object that <code>meta</code> lives\r\n+     * in. This implementation creates a filename from the full class\r\n+     * name of the type identified by <code>meta</code>, and returns\r\n+     * a {@link File} object that has this filename and whose base\r\n+     * directory is the URL identified by the <code>ConnectionURL</code>\r\n+     * configuration property.\r\n+     */\r\n+    private File getFile(ClassMetaData meta) {\r\n+        File baseDir = new File(_conf.getConnectionURL());\r\n+        return new File(baseDir, meta.getDescribedType().getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Stores all instances in <code>datas</code> into the appropriate file,\r\n+     * as dictated by <code>meta</code>.\r\n+     *\r\n+     * @param meta  the least-derived type of the instances being stored\r\n+     * @param datas a collection of {@link ObjectData} instances, each\r\n+     *              of which represents an object of type <code>meta</code>\r\n+     */\r\n+    public void store(ClassMetaData meta, Collection datas) {\r\n+        if (meta.getPCSuperclass() != null)\r\n+            throw new InternalException();\r\n+        File f = getFile(meta);\r\n+        if (!f.getParentFile().exists())\r\n+            f.getParentFile().mkdirs();\r\n+        FileWriter fw = null;\r\n+        try {\r\n+            fw = new FileWriter(f);\r\n+            write(datas, fw);\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new StoreException(e);\r\n+        }\r\n+        finally {\r\n+            if (fw != null)\r\n+                try {\r\n+                    fw.close();\r\n+                } catch (IOException ioe) {\r\n+                }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Write the given collection of {@link ObjectData}s to the given file.\r\n+     */\r\n+    private void write(Collection datas, FileWriter fw) throws Exception {\r\n+        // create an XML pretty printer to write out the objects\r\n+        Writer out = new XMLWriter(fw);\r\n+        // start the file; the root node is an \"extent\"\r\n+        out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n+        out.write(\"<extent>\");\r\n+        // run through each object in the collection\r\n+        for (Iterator itr = datas.iterator(); itr.hasNext();) {\r\n+            ObjectData obj = (ObjectData) itr.next();\r\n+            ClassMetaData meta = obj.getMetaData();\r\n+            // write out the \"object\" element start\r\n+            out.write(\"<object class=\\\"\");\r\n+            out.write(meta.getDescribedType().getName());\r\n+            out.write(\"\\\" oid=\\\"\");\r\n+            out.write(obj.getId().toString());\r\n+            out.write(\"\\\" version=\\\"\");\r\n+            out.write(obj.getVersion().toString());\r\n+            out.write(\"\\\">\");\r\n+            // run through each field writing out the value\r\n+            FieldMetaData[] fmds = meta.getFields();\r\n+            for (int i = 0; i < fmds.length; i++) {\r\n+                if (fmds[i].getManagement() != fmds[i].MANAGE_PERSISTENT)\r\n+                    continue;\r\n+                out.write(\"<field name=\\\"\");\r\n+                out.write(fmds[i].getName());\r\n+                out.write(\"\\\">\");\r\n+                // write out the field data depending upon type\r\n+                switch (fmds[i].getTypeCode()) {\r\n+                    case JavaTypes.COLLECTION:\r\n+                    case JavaTypes.ARRAY:\r\n+                        Collection c = (Collection) obj.getField(i);\r\n+                        if (c == null)\r\n+                            break;\r\n+                        // write out each of the elements\r\n+                        int elemType = fmds[i].getElement().getTypeCode();\r\n+                        for (Iterator ci = c.iterator(); ci.hasNext();) {\r\n+                            out.write(\"<element>\");\r\n+                            writeDataValue(out, elemType, ci.next());\r\n+                            out.write(\"</element>\");\r\n+                        }\r\n+                        break;\r\n+                    case JavaTypes.MAP:\r\n+                        Map m = (Map) obj.getField(i);\r\n+                        if (m == null)\r\n+                            break;\r\n+                        // write out each of the map entries\r\n+                        Collection entries = m.entrySet();\r\n+                        int keyType = fmds[i].getKey().getTypeCode();\r\n+                        int valueType = fmds[i].getElement().getTypeCode();\r\n+                        for (Iterator ei = entries.iterator(); ei.hasNext();) {\r\n+                            Map.Entry e = (Map.Entry) ei.next();\r\n+                            out.write(\"<key>\");\r\n+                            writeDataValue(out, keyType, e.getKey());\r\n+                            out.write(\"</key>\");\r\n+                            out.write(\"<value>\");\r\n+                            writeDataValue(out, valueType, e.getValue());\r\n+                            out.write(\"</value>\");\r\n+                        }\r\n+                        break;\r\n+                    default:\r\n+                        writeDataValue(out, fmds[i].getTypeCode(),\r\n+                            obj.getField(i));\r\n+                }\r\n+                out.write(\"</field>\");\r\n+            }\r\n+            out.write(\"</object>\");\r\n+        }\r\n+        out.write(\"</extent>\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Write out the data value. This method writes nulls as \"null\",\r\n+     * serializes(using Java serialization and base16 encoding) out non-\r\n+     * primitives/boxed primitives and non-persistent types, and writes\r\n+     * primitives/boxed primitives and oids using their toString.\r\n+     */\r\n+    public void writeDataValue(Writer out, int type, Object val)\r\n+        throws IOException {\r\n+        // write nulls as \"null\"\r\n+        if (val == null) {\r\n+            out.write(\"null\");\r\n+            return;\r\n+        }\r\n+        switch (type) {\r\n+            case JavaTypes.OBJECT:\r\n+            case JavaTypes.OID:\r\n+                if (!(val instanceof Serializable))\r\n+                    throw new UnsupportedException(\r\n+                        \"Cannot store non-serializable,\"\r\n+                            + \" non-persistence-capable value: \" + val);\r\n+                // serialize out the object and encode the result with base16\r\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);\r\n+                ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n+                oos.writeObject(val);\r\n+                oos.close();\r\n+                out.write(Base16Encoder.encode(baos.toByteArray()));\r\n+                break;\r\n+            case JavaTypes.CHAR:\r\n+            case JavaTypes.CHAR_OBJ:\r\n+                // quote chars so we can distinguish whitespace chars; special\r\n+                // case for \\0\r\n+                char c = ((Character) val).charValue();\r\n+                out.write(\"'\");\r\n+                if (c == '\\0')\r\n+                    out.write(\"0x0\");\r\n+                else out.write(XMLEncoder.encode(val.toString()));\r\n+                out.write(\"'\");\r\n+                break;\r\n+            case JavaTypes.STRING:\r\n+                // quote strings so we can distinguish leading and trailing\r\n+                // whitespace\r\n+                out.write(\"\\\"\");\r\n+                out.write(XMLEncoder.encode(val.toString()));\r\n+                out.write(\"\\\"\");\r\n+                break;\r\n+            case JavaTypes.PC:\r\n+            case JavaTypes.PC_UNTYPED:\r\n+                // write the type of oid object + ':' + oid string\r\n+                out.write(val.getClass().getName());\r\n+                out.write(':');\r\n+                out.write(XMLEncoder.encode(val.toString()));\r\n+                break;\r\n+            default:\r\n+                // must be a number of simple type; no need to encode\r\n+                out.write(val.toString());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Used to reconstruct {@link ObjectData} instances from SAX events.\r\n+     */\r\n+    private static class ObjectDataHandler extends DefaultHandler {\r\n+\r\n+        private static final Class[] ARGS = new Class[]{ String.class };\r\n+        private final XMLConfiguration _conf;\r\n+        private final Collection _extent = new ArrayList();\r\n+        // parse state\r\n+        private ObjectData _object;\r\n+        private FieldMetaData _fmd;\r\n+        private Object _fieldVal;\r\n+        private Object _keyVal;\r\n+        private StringBuffer _buf;\r\n+\r\n+        /**\r\n+         * Constructor; supply configuration.\r\n+         */\r\n+        public ObjectDataHandler(XMLConfiguration conf) {\r\n+            _conf = conf;\r\n+        }\r\n+\r\n+        /**\r\n+         * Return the results of the parsing.\r\n+         */\r\n+        public Collection getExtent() {\r\n+            return _extent;\r\n+        }\r\n+\r\n+        public void startElement(String uri, String localName, String qName,\r\n+            Attributes attrs) throws SAXException {\r\n+            try {\r\n+                startElement(qName, attrs);\r\n+            } catch (RuntimeException re) {\r\n+                throw re;\r\n+            } catch (SAXException se) {\r\n+                throw se;\r\n+            } catch (Exception e) {\r\n+                throw new SAXException(e);\r\n+            }\r\n+        }\r\n+\r\n+        private void startElement(String qName, Attributes attrs)\r\n+            throws Exception {\r\n+            switch (qName.charAt(0)) {\r\n+                case 'o': // object\r\n+                    // get the metadata for the type we're reading\r\n+                    String type = attrs.getValue(\"class\");\r\n+                    ClassMetaData meta = _conf.getMetaDataRepository().\r\n+                        getMetaData(classForName(type), null, true);\r\n+                    // construct the oid object\r\n+                    Object oid;\r\n+                    if (meta.getIdentityType() == meta.ID_DATASTORE)\r\n+                        oid = new Id(attrs.getValue(\"oid\"), _conf, null);\r\n+                    else oid = PCRegistry.newObjectId(meta.getDescribedType(),\r\n+                        attrs.getValue(\"oid\"));\r\n+                    // create an ObjectData that will contain the information\r\n+                    // for this instance, and set the version\r\n+                    _object = new ObjectData(oid, meta);\r\n+                    _object.setVersion(new Long(attrs.getValue(\"version\")));\r\n+                    break;\r\n+                case 'f': // field\r\n+                    // start parsing a field element: for container types,\r\n+                    // initialize the container; for other types, initialize a\r\n+                    // buffer\r\n+                    _fmd =\r\n+                        _object.getMetaData().getField(attrs.getValue(\"name\"));\r\n+                    switch (_fmd.getTypeCode()) {\r\n+                        case JavaTypes.COLLECTION:\r\n+                        case JavaTypes.ARRAY:\r\n+                            _fieldVal = new ArrayList();\r\n+                            break;\r\n+                        case JavaTypes.MAP:\r\n+                            _fieldVal = new HashMap();\r\n+                            break;\r\n+                        default:\r\n+                            _buf = new StringBuffer();\r\n+                    }\r\n+                    break;\r\n+                case 'e': // element\r\n+                case 'k': // key\r\n+                case 'v': // value\r\n+                    // initialize a buffer for the element value\r\n+                    _buf = new StringBuffer();\r\n+                    break;\r\n+            }\r\n+        }\r\n+\r\n+        public void endElement(String uri, String localName, String qName)\r\n+            throws SAXException {\r\n+            try {\r\n+                endElement(qName);\r\n+            } catch (RuntimeException re) {\r\n+                throw re;\r\n+            } catch (SAXException se) {\r\n+                throw se;\r\n+            } catch (Exception e) {\r\n+                throw new SAXException(e);\r\n+            }\r\n+        }\r\n+\r\n+        private void endElement(String qName) throws Exception {\r\n+            Object val;\r\n+            switch (qName.charAt(0)) {\r\n+                case 'o': // object\r\n+                    // add the object to our results\r\n+                    _extent.add(_object);\r\n+                case 'f': // field\r\n+                    switch (_fmd.getTypeCode()) {\r\n+                        case JavaTypes.COLLECTION:\r\n+                        case JavaTypes.ARRAY:\r\n+                        case JavaTypes.MAP:\r\n+                            // field value already constructed\r\n+                            break;\r\n+                        default:\r\n+                            // construct the field value from text within the element\r\n+                            _fieldVal = fromXMLString(_fmd.getTypeCode(),\r\n+                                _fmd.getTypeMetaData(), _buf.toString());\r\n+                    }\r\n+                    // set the field value into the object being parsed\r\n+                    _object.setField(_fmd.getIndex(), _fieldVal);\r\n+                    break;\r\n+                case 'e': // element\r\n+                    // cache element value\r\n+                    val = fromXMLString(_fmd.getElement().getTypeCode(),\r\n+                        _fmd.getElement().getTypeMetaData(), _buf.toString());\r\n+                    ((Collection) _fieldVal).add(val);\r\n+                    break;\r\n+                case 'k': // key\r\n+                    // cache key value\r\n+                    _keyVal = fromXMLString(_fmd.getKey().getTypeCode(),\r\n+                        _fmd.getKey().getTypeMetaData(), _buf.toString());\r\n+                    break;\r\n+                case 'v': // value\r\n+                    // create value and put cached key and value into map\r\n+                    val = fromXMLString(_fmd.getElement().getTypeCode(),\r\n+                        _fmd.getElement().getTypeMetaData(), _buf.toString());\r\n+                    Map map = (Map) _fieldVal;\r\n+                    map.put(_keyVal, val);\r\n+                    break;\r\n+            }\r\n+            // don't cache text between elements\r\n+            _buf = null;\r\n+        }\r\n+\r\n+        public void characters(char[] ch, int start, int length) {\r\n+            if (_buf != null)\r\n+                _buf.append(ch, start, length);\r\n+        }\r\n+\r\n+        /**\r\n+         * Recreate a field value from its XML string.\r\n+         */\r\n+        public Object fromXMLString(int type, ClassMetaData rel, String str)\r\n+            throws Exception {\r\n+            str = str.trim();\r\n+            if (str.equals(\"null\"))\r\n+                return null;\r\n+            switch (type) {\r\n+                case JavaTypes.BOOLEAN:\r\n+                case JavaTypes.BOOLEAN_OBJ:\r\n+                    return Boolean.valueOf(str);\r\n+                case JavaTypes.BYTE:\r\n+                case JavaTypes.BYTE_OBJ:\r\n+                    return new Byte(str);\r\n+                case JavaTypes.CHAR:\r\n+                case JavaTypes.CHAR_OBJ:\r\n+                    // strip quotes; special case for 0x0\r\n+                    str = str.substring(1, str.length() - 1);\r\n+                    if (str.equals(\"0x0\"))\r\n+                        return new Character('\\0');\r\n+                    return new Character(XMLEncoder.decode(str).charAt(0));\r\n+                case JavaTypes.DOUBLE:\r\n+                case JavaTypes.DOUBLE_OBJ:\r\n+                    return new Double(str);\r\n+                case JavaTypes.FLOAT:\r\n+                case JavaTypes.FLOAT_OBJ:\r\n+                    return new Float(str);\r\n+                case JavaTypes.INT:\r\n+                case JavaTypes.INT_OBJ:\r\n+                    return new Integer(str);\r\n+                case JavaTypes.LONG:\r\n+                case JavaTypes.LONG_OBJ:\r\n+                    return new Long(str);\r\n+                case JavaTypes.SHORT:\r\n+                case JavaTypes.SHORT_OBJ:\r\n+                    return new Short(str);\r\n+                case JavaTypes.NUMBER:\r\n+                case JavaTypes.BIGDECIMAL:\r\n+                    return new BigDecimal(str);\r\n+                case JavaTypes.BIGINTEGER:\r\n+                    return new BigInteger(str);\r\n+                case JavaTypes.STRING:\r\n+                    // strip quotes\r\n+                    str = str.substring(1, str.length() - 1);\r\n+                    return XMLEncoder.decode(str);\r\n+                case JavaTypes.OBJECT:\r\n+                case JavaTypes.OID:\r\n+                    // convert the characters into bytes, and run them through an\r\n+                    // ObjectInputStream in order to get the serialized object\r\n+                    byte[] bytes = Base16Encoder.decode(str);\r\n+                    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n+                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n+                    Object data = ois.readObject();\r\n+                    ois.close();\r\n+                    return data;\r\n+                case JavaTypes.DATE:\r\n+                    return new Date(str);\r\n+                case JavaTypes.PC:\r\n+                case JavaTypes.PC_UNTYPED:\r\n+                    // parse out oid class name and value\r\n+                    int idx = str.indexOf(':');\r\n+                    Class idClass = classForName(str.substring(0, idx));\r\n+                    String idStr = XMLEncoder.decode(str.substring(idx + 1));\r\n+                    Constructor cons = idClass.getConstructor(ARGS);\r\n+                    return cons.newInstance(new Object[]{ idStr });\r\n+                case JavaTypes.LOCALE:\r\n+                    int under1 = str.indexOf('_');\r\n+                    if (under1 == -1)\r\n+                        return (new Locale(str, \"\"));\r\n+                    int under2 = str.indexOf('_', under1 + 1);\r\n+                    if (under2 == -1)\r\n+                        return new Locale(str.substring(0, under1),\r\n+                            str.substring(under1 + 1));\r\n+                    String lang = str.substring(0, under1);\r\n+                    String country = str.substring(under1 + 1, under2);\r\n+                    String variant = str.substring(under2 + 1);\r\n+                    return new Locale(lang, country, variant);\r\n+                default:\r\n+                    throw new InternalException();\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Return the class for the specified name.\r\n+         */\r\n+        private Class classForName(String name) throws Exception {\r\n+            ClassLoader loader = _conf.getClassResolverInstance().\r\n+                getClassLoader(getClass(), null);\r\n+            return Class.forName(name, true, loader);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Utility methods for encoding and decoding XML strings.\r\n+     */\r\n+    private static class XMLEncoder {\r\n+\r\n+        /**\r\n+         * Encode the given string as XML text.\r\n+         */\r\n+        public static String encode(String s) {\r\n+            StringBuffer buf = null;\r\n+            for (int i = 0; i < s.length(); i++) {\r\n+                switch (s.charAt(i)) {\r\n+                    case '<':\r\n+                        buf = initializeBuffer(buf, s, i);\r\n+                        buf.append(\"&lt;\");\r\n+                        break;\r\n+                    case '>':\r\n+                        buf = initializeBuffer(buf, s, i);\r\n+                        buf.append(\"&gt;\");\r\n+                        break;\r\n+                    case '&':\r\n+                        buf = initializeBuffer(buf, s, i);\r\n+                        buf.append(\"&amp;\");\r\n+                        break;\r\n+                    default:\r\n+                        if (buf != null)\r\n+                            buf.append(s.charAt(i));\r\n+                }\r\n+            }\r\n+            if (buf != null)\r\n+                return buf.toString();\r\n+            return s;\r\n+        }\r\n+\r\n+        /**\r\n+         * Decode the given XML string.\r\n+         */\r\n+        public static String decode(String s) {\r\n+            StringBuffer buf = null;\r\n+            for (int i = 0; i < s.length(); i++) {\r\n+                char c = s.charAt(i);\r\n+                if (c == '&' && s.length() > i + 3) {\r\n+                    if ((s.charAt(i + 1) == 'l' || s.charAt(i + 1) == 'g')\r\n+                        && s.charAt(i + 2) == 't' && s.charAt(i + 3) == ';') {\r\n+                        // &lt; or &gt;\r\n+                        buf = initializeBuffer(buf, s, i);\r\n+                        c = (s.charAt(i) == 'l') ? '<' : '>';\r\n+                        i += 3;\r\n+                    } else if (s.length() > i + 4 && s.charAt(i + 1) == 'a'\r\n+                        && s.charAt(i + 2) == 'm' && s.charAt(i + 3) == 'p'\r\n+                        && s.charAt(i + 4) == ';') {\r\n+                        // &amp;\r\n+                        buf = initializeBuffer(buf, s, i);\r\n+                        c = '&';\r\n+                        i += 4;\r\n+                    }\r\n+                }\r\n+                if (buf != null)\r\n+                    buf.append(c);\r\n+            }\r\n+            if (buf != null)\r\n+                return buf.toString();\r\n+            return s;\r\n+        }\r\n+\r\n+        /**\r\n+         * Create and initialize a buffer for the encoded/decoded string if\r\n+         * needed.\r\n+         */\r\n+        private static StringBuffer initializeBuffer(StringBuffer buf,\r\n+            String s, int i) {\r\n+            if (buf == null) {\r\n+                buf = new StringBuffer();\r\n+                if (i > 0)\r\n+                    buf.append(s.substring(0, i));\r\n+            }\r\n+            return buf;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"c45d3e4abf4b4ec8e06ab34ad2764543dc051025","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStore.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,151 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.xmlstore;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+\r\n+/**\r\n+ * Represents a store of object data encoded in XML. This store only allows\r\n+ * one datastore transaction to proceed at a time. File I/O errors can put\r\n+ * this store into an invalid state.\r\n+ */\r\n+public class XMLStore {\r\n+\r\n+    private final XMLConfiguration _conf;\r\n+    // each key in the map is a least-derived class metadata object, and each\r\n+    // value is a map of oids to object datas representing the instances of\r\n+    // that class, including subclasses\r\n+    private final Map _metaOidMaps = new HashMap();\r\n+    // store gets locked during transactions\r\n+    private boolean _locked;\r\n+\r\n+    /**\r\n+     * Constructor; supply configuration.\r\n+     */\r\n+    public XMLStore(XMLConfiguration conf) {\r\n+        _conf = conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the data for the given oid, or null if it does not exist.\r\n+     */\r\n+    public synchronized ObjectData getData(ClassMetaData meta, Object oid) {\r\n+        meta = getLeastDerived(meta);\r\n+        return (ObjectData) getMap(meta).get(oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return all datas for the base class of the given type.\r\n+     */\r\n+    public synchronized ObjectData[] getData(ClassMetaData meta) {\r\n+        meta = getLeastDerived(meta);\r\n+        Collection vals = getMap(meta).values();\r\n+        return (ObjectData[]) vals.toArray(new ObjectData[vals.size()]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the map of oids to object datas for the given least-derived type.\r\n+     */\r\n+    private Map getMap(ClassMetaData meta) {\r\n+        Map m = (Map) _metaOidMaps.get(meta);\r\n+        if (m != null)\r\n+            return m;\r\n+        // load datas from file and cache them\r\n+        Collection datas = _conf.getFileHandler().load(meta);\r\n+        m = new HashMap(datas.size());\r\n+        for (Iterator itr = datas.iterator(); itr.hasNext();) {\r\n+            ObjectData data = (ObjectData) itr.next();\r\n+            m.put(data.getId(), data);\r\n+        }\r\n+        _metaOidMaps.put(meta, m);\r\n+        return m;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the least-derived metadata in the inheritance chain\r\n+     * above <code>meta</code>, or <code>meta</code> if it is a\r\n+     * least-derived metadata.\r\n+     */\r\n+    private static ClassMetaData getLeastDerived(ClassMetaData meta) {\r\n+        while (meta.getPCSuperclass() != null)\r\n+            meta = meta.getPCSuperclassMetaData();\r\n+        return meta;\r\n+    }\r\n+\r\n+    /**\r\n+     * Begin a datastore transaction. Obtains an exclusive write lock on the\r\n+     * store.\r\n+     */\r\n+    public synchronized void beginTransaction() {\r\n+        // lock store\r\n+        while (_locked)\r\n+            try {\r\n+                wait();\r\n+            } catch (InterruptedException ie) {\r\n+            }\r\n+        _locked = true;\r\n+    }\r\n+\r\n+    /**\r\n+     * End the datastore transaction.\r\n+     *\r\n+     * @param updates {@link ObjectData} instances to insert or update\r\n+     * @param deletes {@link ObjectData} instances to delete\r\n+     */\r\n+    public synchronized void endTransaction(Collection updates,\r\n+        Collection deletes) {\r\n+        // track dirty types\r\n+        Set dirty = new HashSet();\r\n+        try {\r\n+            // commit updates\r\n+            if (updates != null) {\r\n+                for (Iterator itr = updates.iterator(); itr.hasNext();) {\r\n+                    ObjectData data = (ObjectData) itr.next();\r\n+                    ClassMetaData meta = getLeastDerived(data.getMetaData());\r\n+                    getMap(meta).put(data.getId(), data);\r\n+                    dirty.add(meta);\r\n+                }\r\n+            }\r\n+            // commit deletes\r\n+            if (deletes != null) {\r\n+                for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n+                    ObjectData data = (ObjectData) itr.next();\r\n+                    ClassMetaData meta = getLeastDerived(data.getMetaData());\r\n+                    getMap(meta).remove(data.getId());\r\n+                    dirty.add(meta);\r\n+                }\r\n+            }\r\n+            // write changes to dirty extents back to file\r\n+            XMLFileHandler fh = _conf.getFileHandler();\r\n+            for (Iterator itr = dirty.iterator(); itr.hasNext();) {\r\n+                ClassMetaData meta = (ClassMetaData) itr.next();\r\n+                fh.store(meta, getMap(meta).values());\r\n+            }\r\n+        }\r\n+        finally {\r\n+            // unlock store\r\n+            notify();\r\n+            _locked = false;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"454ab961b7d4c15e1dfff13e7d24310ef04548e4","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/XMLStoreManager.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,261 @@\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+/*********************************************************************\r\n+\r\n+ **********************************************************************/\r\n+package org.apache.openjpa.xmlstore;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+\r\n+import org.apache.openjpa.abstractstore.AbstractStoreManager;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.FetchState;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCState;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.OptimisticException;\r\n+import org.apache.openjpa.util.StoreException;\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * Store manager to a back-end consisting of XML files. This\r\n+ * implementation accesses data through the {@link XMLStore} associated with\r\n+ * its {@link XMLConfiguration}. Configuration instances are shared by all\r\n+ * store managers owned by all brokers created with the same factory.\r\n+ *\r\n+ * @see AbstractStoreManager\r\n+ */\r\n+public class XMLStoreManager extends AbstractStoreManager {\r\n+\r\n+    private XMLConfiguration _conf;\r\n+    private XMLStore _store;\r\n+    private Log _log;\r\n+    // changed data within the current transaction\r\n+    private Collection _updates;\r\n+    private Collection _deletes;\r\n+\r\n+    protected Collection getUnsupportedOptions() {\r\n+        Collection c = super.getUnsupportedOptions();\r\n+        // remove options we do support but the abstract store doesn't\r\n+        c.remove(OpenJPAConfiguration.OPTION_ID_DATASTORE);\r\n+        c.remove(OpenJPAConfiguration.OPTION_OPTIMISTIC);\r\n+        // and add some that we don't support but the abstract store does\r\n+        c.add(OpenJPAConfiguration.OPTION_EMBEDDED_RELATION);\r\n+        c.add(OpenJPAConfiguration.OPTION_EMBEDDED_COLLECTION_RELATION);\r\n+        c.add(OpenJPAConfiguration.OPTION_EMBEDDED_MAP_RELATION);\r\n+        return c;\r\n+    }\r\n+\r\n+    protected OpenJPAConfiguration newConfiguration() {\r\n+        // override to use our configuration type\r\n+        return new XMLConfiguration();\r\n+    }\r\n+\r\n+    protected void open() {\r\n+        // cache operational state\r\n+        _conf = (XMLConfiguration) ctx.getConfiguration();\r\n+        _store = _conf.getStore();\r\n+        _log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+    }\r\n+\r\n+    public boolean exists(OpenJPAStateManager sm, Object context) {\r\n+        // see if the given object exists in the store\r\n+        return _store.getData(sm.getMetaData(), sm.getObjectId()) != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Increment the version indicator in the given state manager.\r\n+     */\r\n+    private static void incrementVersion(OpenJPAStateManager sm) {\r\n+        long version = 0;\r\n+        if (sm.getVersion() != null)\r\n+            version = ((Long) sm.getVersion()).longValue() + 1;\r\n+        sm.setNextVersion(Numbers.valueOf(version));\r\n+    }\r\n+\r\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\r\n+        FetchState fetchState, Object context) {\r\n+        // we may already have looked up the backing ObjectData(see our extent\r\n+        // implementation below), and passed it through as the context; if\r\n+        // not, then look it up in the store\r\n+        ObjectData data;\r\n+        if (context != null)\r\n+            data = (ObjectData) context;\r\n+        else data = _store.getData(sm.getMetaData(), sm.getObjectId());\r\n+        // no matching record?\r\n+        if (data == null)\r\n+            return false;\r\n+        // initialize the state manager with a new instance of the right\r\n+        // type and lifecycle state\r\n+        sm.initialize(data.getMetaData().getDescribedType(), state);\r\n+        // load the data from the ObjectData into the state mgr; note that\r\n+        // this store manager doesn't do any locking -- it relies on the\r\n+        // system's lock manager to lock after the load is complete\r\n+        data.load(sm, fetchState);\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\r\n+        FetchState fetchState, int lockLevel, Object context) {\r\n+        // we may already have looked up the backing ObjectData(see our extent\r\n+        // implementation below), and passed it through as the context; if\r\n+        // not, then look it up in the store\r\n+        ObjectData data;\r\n+        if (context != null)\r\n+            data = (ObjectData) context;\r\n+        else data = _store.getData(sm.getMetaData(), sm.getObjectId());\r\n+        // no matching record?\r\n+        if (data == null)\r\n+            return false;\r\n+        // load the data from the ObjectData into the state mgr; note that\r\n+        // this store manager doesn't do any locking -- it relies on the\r\n+        // system's lock manager to lock after the load is complete\r\n+        data.load(sm, fields, fetchState);\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean syncVersion(OpenJPAStateManager sm, Object context) {\r\n+        if (sm.getVersion() == null)\r\n+            return false;\r\n+        // we may already have looked up the backing ObjectData(see our extent\r\n+        // implementation below), and passed it through as the context; if\r\n+        // not, then look it up in the store\r\n+        ObjectData data;\r\n+        if (context != null)\r\n+            data = (ObjectData) context;\r\n+        else data = _store.getData(sm.getMetaData(), sm.getObjectId());\r\n+        // no record?\r\n+        if (data == null)\r\n+            return false;\r\n+        // if the version of data held by the state mgr is the same as the\r\n+        // version in the datastore, return true, letting the broker know that\r\n+        // it doesn't need to load any more data\r\n+        if (sm.getVersion().equals(data.getVersion()))\r\n+            return true;\r\n+        // set the version to be up-to-date, and return false letting\r\n+        // the broker know that it needs to load up-to-date data\r\n+        sm.setVersion(data.getVersion());\r\n+        return false;\r\n+    }\r\n+\r\n+    public void begin() {\r\n+        _store.beginTransaction();\r\n+    }\r\n+\r\n+    public void commit() {\r\n+        try {\r\n+            _store.endTransaction(_updates, _deletes);\r\n+        }\r\n+        finally {\r\n+            _updates = null;\r\n+            _deletes = null;\r\n+        }\r\n+    }\r\n+\r\n+    public void rollback() {\r\n+        _updates = null;\r\n+        _deletes = null;\r\n+        _store.endTransaction(null, null);\r\n+    }\r\n+\r\n+    protected Collection flush(Collection pNew, Collection pNewUpdated,\r\n+        Collection pNewFlushedDeleted, Collection pDirty, Collection pDeleted) {\r\n+        // we don't support incremental flushing, so pNewUpdated and\r\n+        // pNewFlushedDeleted should be empty; we ignore them here\r\n+        // track optimistic violations\r\n+        Collection exceps = new LinkedList();\r\n+        // convert instances to ObjectDatas\r\n+        _updates = new ArrayList(pNew.size() + pDirty.size());\r\n+        _deletes = new ArrayList(pDeleted.size());\r\n+        // convert additions\r\n+        for (Iterator itr = pNew.iterator(); itr.hasNext();) {\r\n+            // create new object data for instance\r\n+            OpenJPAStateManager sm = (OpenJPAStateManager) itr.next();\r\n+            Object oid = sm.getObjectId();\r\n+            ObjectData data = _store.getData(sm.getMetaData(), oid);\r\n+            if (data != null)\r\n+                throw new StoreException(\"Attempt to insert \"\r\n+                    + \"new object \" + sm.getManagedInstance()\r\n+                    + \"with the same oid as an existing instance: \" + oid).\r\n+                    setFatal(true);\r\n+            data = new ObjectData(oid, sm.getMetaData());\r\n+            incrementVersion(sm);\r\n+            data.store(sm);\r\n+            _updates.add(data);\r\n+        }\r\n+        // convert updates\r\n+        for (Iterator itr = pDirty.iterator(); itr.hasNext();) {\r\n+            OpenJPAStateManager sm = (OpenJPAStateManager) itr.next();\r\n+            ObjectData data = _store.getData(sm.getMetaData(),\r\n+                sm.getObjectId());\r\n+            // if data has been deleted or has the wrong version, record\r\n+            // opt lock violation\r\n+            if (data == null || !data.getVersion().equals(sm.getVersion())) {\r\n+                exceps.add(new OptimisticException(sm.getManagedInstance()));\r\n+                continue;\r\n+            }\r\n+            // store changes\r\n+            incrementVersion(sm);\r\n+            data = (ObjectData) data.clone();\r\n+            data.store(sm);\r\n+            _updates.add(data);\r\n+        }\r\n+        // convert deletes\r\n+        for (Iterator itr = pDeleted.iterator(); itr.hasNext();) {\r\n+            OpenJPAStateManager sm = (OpenJPAStateManager) itr.next();\r\n+            ObjectData data = _store.getData(sm.getMetaData(),\r\n+                sm.getObjectId());\r\n+            // record delete\r\n+            if (data != null)\r\n+                _deletes.add(data);\r\n+        }\r\n+        return exceps;\r\n+    }\r\n+\r\n+    public ResultObjectProvider executeExtent(ClassMetaData meta,\r\n+        boolean subclasses, FetchConfiguration fetch) {\r\n+        // ask the store for all ObjectDatas for the given type; this\r\n+        // actually gives us all instances of the base class of the type\r\n+        ObjectData[] datas = _store.getData(meta);\r\n+        Class candidate = meta.getDescribedType();\r\n+        // create a list of the corresponding persistent objects that\r\n+        // match the type and subclasses criteria\r\n+        List pcs = new ArrayList(datas.length);\r\n+        for (int i = 0; i < datas.length; i++) {\r\n+            // does this instance belong in the extent?\r\n+            Class c = datas[i].getMetaData().getDescribedType();\r\n+            if (c != candidate && (!subclasses\r\n+                || !candidate.isAssignableFrom(c)))\r\n+                continue;\r\n+            // look up the pc instance for the data, passing in the data\r\n+            // as well so that we can take advantage of the fact that we've\r\n+            // already looked it up.  note that in the store manager's\r\n+            // initialize(), load(), etc methods we check for this data\r\n+            // being passed through and save ourselves a trip to the store\r\n+            // if it is present; this is particularly important in systems\r\n+            // where a trip to the store can be expensive.\r\n+            pcs.add(ctx.find(datas[i].getId(), fetch.newFetchState(),\r\n+                null, datas[i], 0));\r\n+        }\r\n+        return new ListResultObjectProvider(pcs);\r\n+    }\r\n+}\r"},{"sha":"9f415dbb07f8b6aa5d660e91a560a0d201e2a842","filename":"openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/package.html","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/src/main/java/org/apache/openjpa/xmlstore/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -0,0 +1,9 @@\n+<html>\n+<body>\n+<p><strong>XML Store</strong></p>\n+\n+<p>\n+    Simple XML store using the common OpenJPA runtime system as a front end.\n+</p>\n+</body>\n+</html>"},{"sha":"7252bbf584c09d540d378f9ce3a8d97d5c6a62e6","filename":"pom.xml","status":"modified","additions":192,"deletions":177,"changes":369,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -1,179 +1,194 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\t\t<modelVersion>4.0.0</modelVersion>\n-\t<groupId>org.apache.openjpa</groupId>\n-\t<artifactId>openjpa</artifactId>\n-\t<packaging>pom</packaging>\n-\n-\t<name>OpenJPA</name>\n-\t<description>OpenJPA</description>\n-\t<version>0.0.1</version>\n-\t<url>http://incubator.apache.org/projects/openjpa</url>\n-\t<issueManagement>\n-\t\t<system>jira</system>\n-\t\t<url>http://issues.apache.org/jira/browse/OPENJPA</url>\n-\t</issueManagement>\n-\t<inceptionYear>2006</inceptionYear>\n-\t<mailingLists>\n-\t\t<mailingList>\n-\t\t\t<name>OpenJPA Developer List</name>\n-\t\t\t<subscribe>open-jpa-dev-subscribe@incubator.apache.org</subscribe>\n-\t\t\t<unsubscribe>open-jpa-dev-unsubscribe@incubator.apache.org</unsubscribe>\n-\t\t\t<post>open-jpa-dev@incubator.apache.org</post>\n-\t\t\t<archive>http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-dev/</archive>\n-\t\t</mailingList>\n-\t\t<mailingList>\n-\t\t\t<name>OpenJPA Commits List</name>\n-\t\t\t<subscribe>open-jpa-commits-subscribe@incubator.apache.org</subscribe>\n-\t\t\t<unsubscribe>open-jpa-commits-unsubscribe@incubator.apache.org</unsubscribe>\n-\t\t\t<post>open-jpa-commits@incubator.apache.org</post>\n-\t\t\t<archive>http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-commits/</archive>\n-\t\t</mailingList>\n-\t</mailingLists>\n-\t<developers>\n-\t\t<developer>\n-\t\t\t<name>Patrick Linskey</name>\n-\t\t\t<id>plinskey</id>\n-\t\t\t<organization>BEA Systems, Inc.</organization>\n-\t\t\t<email>plinskey@bea.com</email>\n-\t\t</developer>\n-\t\t<developer>\n-\t\t\t<name>Abe White</name>\n-\t\t\t<id>awhite</id>\n-\t\t\t<organization>BEA Systems, Inc.</organization>\n-\t\t\t<email>awhite@bea.com</email>\n-\t\t</developer>\n-\t\t<developer>\n-\t\t\t<name>Steve Kim</name>\n-\t\t\t<id>stkim</id>\n-\t\t\t<organization>BEA Systems, Inc.</organization>\n-\t\t\t<email>stkim@bea.com</email>\n-\t\t</developer>\n-\t\t<developer>\n-\t\t\t<name>Marc Prud'hommeaux</name>\n-\t\t\t<id>mprudhom</id>\n-\t\t\t<organization>BEA Systems, Inc.</organization>\n-\t\t\t<email>mprudhom@bea.com</email>\n-\t\t</developer>\n-\t</developers>\n-\t<licenses>\n-\t\t<license>\n-\t\t\t<name>Apache Software License 2.0</name>\n-\t\t\t<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n-\t\t\t<distribution>repo</distribution>\n-\t\t</license>\n-\t</licenses>\n-\t<organization>\n-\t\t<name>Apache Software Foundation</name>\n-\t\t<url>http://www.apache.org</url>\n-\t</organization>\n-\t<scm>\n-\t\t<connection>scm:svn:http://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</connection>\n-\t\t<developerConnection>scm:svn:https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</developerConnection>\n-\t\t<url>https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</url>\n-\t</scm>\n-<modules>\n-\t\n-\t\t<module>openjpa-lib</module>\n-\t\t<module>serp</module>\n-\t\t\n-\t</modules>\n-\t<repositories>\n-\t\n-\t\t<repository>\n-\t\t<id>central</id>\n-\t\t<name>Maven Repository Switchboard</name>\n-\t\t<url>http://www.ibiblio.org/maven2</url>\n-\t\t</repository>\n-\t\t\n-\t\n-\t\t<repository>\n-\t\t<id>swami</id>\n-\t\t<name>Swami repository</name>\n-\t\t<url>http://m2.ngbw.org</url>\n-\t\t</repository>\n-\t\t\n-\t\n-\t\t<repository>\n-\t\t<id>java-net</id>\n-\t\t<name>dev.java.net repository</name>\n-\t\t<url>https://maven-repository.dev.java.net/nonav/repository</url>\n-\t\t<layout>legacy</layout>\n-\t\t</repository>\n-\t\t\n-\t</repositories>\n-\t<dependencies>\n-\t\n-\t\t<dependency>\n-\t\t\n-\t\t\t<groupId>junit</groupId>\n-\t\t\t<artifactId>junit</artifactId>\n-\t\t\t<version>3.8.1</version>\n-\t\t\t<scope>compile</scope>\n-\t\t\t\n-\t\t</dependency>\n-\t\t\n-\t</dependencies>\n-\t<build>\n-\t\n-\t\t<plugins>\n-\t\t\n-\t\t\t<plugin>\n-\t\t\t\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t<source>1.5</source>\n-\t\t\t\t<target>1.5</target>\n-\t\t\t\t</configuration>\n-\t\t\t\t\n-\t\t\t</plugin>\n-\t\t\t\n-\t\t</plugins>\n-\t\t\n-\t</build>\n-\t\n-\t<reporting>\n-\t\t<plugins>\n-\t\t\t<plugin>\n-\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n-\t\t\t\t<artifactId>taglist-maven-plugin</artifactId>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n-\t\t\t\t<artifactId>jxr-maven-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<aggregate>true</aggregate>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\t\t\t<plugin>\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-javadoc-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t\t<aggregate>true</aggregate>\n-\t\t\t\t\t<linksource>true</linksource>\n-\t\t\t\t\t<links>\n-\t\t\t\t\t\t<link>http://java.sun.com/j2se/1.5.0/docs/api</link>\n-\t\t\t\t\t\t<link>http://java.sun.com/javaee/5/docs/api</link>\n-\t\t\t\t\t\t<link>http://jakarta.apache.org/commons/collections/api-release</link>\n-\t\t\t\t\t</links>\n-\t\t\t\t</configuration>\n-\t\t\t</plugin>\n-\t\t</plugins>\n-\t</reporting>\n-\t<distributionManagement>\n-\t\t<repository>\n-\t\t\t<id>bea-internal</id>\n-\t\t\t<name>Internal BEA OpenJPA test site</name>\n-\t\t\t<url>file:///${user.home}/web/devel/openjpa/dist</url>\n-\t\t</repository>\n-\t\t<site>\n-\t\t\t<id>bea-internal</id>\n-\t\t\t<name>Internal BEA OpenJPA test sit</name>\n-\t\t\t<url>file:///${user.home}/web/devel/openjpa/site</url>\n-\t\t</site>\n-\t</distributionManagement>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>openjpa</artifactId>\n+    <packaging>pom</packaging>\n+\n+    <name>OpenJPA</name>\n+    <description>OpenJPA</description>\n+    <version>0.0.1</version>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <issueManagement>\n+        <system>jira</system>\n+        <url>http://issues.apache.org/jira/browse/OPENJPA</url>\n+    </issueManagement>\n+    <inceptionYear>2006</inceptionYear>\n+    <mailingLists>\n+        <mailingList>\n+            <name>OpenJPA Developer List</name>\n+            <subscribe>open-jpa-dev-subscribe@incubator.apache.org</subscribe>\n+            <unsubscribe>\n+                open-jpa-dev-unsubscribe@incubator.apache.org</unsubscribe>\n+            <post>open-jpa-dev@incubator.apache.org</post>\n+            <archive>\n+                http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-dev/</archive>\n+        </mailingList>\n+        <mailingList>\n+            <name>OpenJPA Commits List</name>\n+            <subscribe>\n+                open-jpa-commits-subscribe@incubator.apache.org</subscribe>\n+            <unsubscribe>\n+                open-jpa-commits-unsubscribe@incubator.apache.org</unsubscribe>\n+            <post>open-jpa-commits@incubator.apache.org</post>\n+            <archive>\n+                http://mail-archives.apache.org/mod_mbox/incubator-open-jpa-commits/</archive>\n+        </mailingList>\n+    </mailingLists>\n+    <developers>\n+        <developer>\n+            <name>Patrick Linskey</name>\n+            <id>plinskey</id>\n+            <organization>BEA Systems, Inc.</organization>\n+            <email>plinskey@bea.com</email>\n+        </developer>\n+        <developer>\n+            <name>Abe White</name>\n+            <id>awhite</id>\n+            <organization>BEA Systems, Inc.</organization>\n+            <email>awhite@bea.com</email>\n+        </developer>\n+        <developer>\n+            <name>Steve Kim</name>\n+            <id>stkim</id>\n+            <organization>BEA Systems, Inc.</organization>\n+            <email>stkim@bea.com</email>\n+        </developer>\n+        <developer>\n+            <name>Marc Prud'hommeaux</name>\n+            <id>mprudhom</id>\n+            <organization>BEA Systems, Inc.</organization>\n+            <email>mprudhom@bea.com</email>\n+        </developer>\n+    </developers>\n+    <licenses>\n+        <license>\n+            <name>Apache Software License 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+            <distribution>repo</distribution>\n+        </license>\n+    </licenses>\n+    <organization>\n+        <name>Apache Software Foundation</name>\n+        <url>http://www.apache.org</url>\n+    </organization>\n+    <scm>\n+        <connection>\n+            scm:svn:http://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</connection>\n+        <developerConnection>\n+            scm:svn:https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</developerConnection>\n+        <url>\n+            https://svn.apache.org/repos/asf/incubator/openjpa/${pom.artifactId}</url>\n+    </scm>\n+    <modules>\n+\n+        <module>openjpa-lib</module>\n+        <module>serp</module>\n+        <module>openjpa-kernel</module>\n+        <module>openjpa-kernel-5</module>\n+        <module>openjpa-persistence</module>\n+        <module>openjpa-xmlstore</module>\n+\n+    </modules>\n+    <repositories>\n+\n+        <repository>\n+            <id>central</id>\n+            <name>Maven Repository Switchboard</name>\n+            <url>http://www.ibiblio.org/maven2</url>\n+        </repository>\n+\n+\n+        <repository>\n+            <id>swami</id>\n+            <name>Swami repository</name>\n+            <url>http://m2.ngbw.org</url>\n+        </repository>\n+\n+\n+        <repository>\n+            <id>java-net</id>\n+            <name>dev.java.net repository</name>\n+            <url>https://maven-repository.dev.java.net/nonav/repository</url>\n+            <layout>legacy</layout>\n+        </repository>\n+\n+    </repositories>\n+    <dependencies>\n+\n+        <dependency>\n+\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>3.8.1</version>\n+            <scope>compile</scope>\n+\n+        </dependency>\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n+    <reporting>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>taglist-maven-plugin</artifactId>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>jxr-maven-plugin</artifactId>\n+                <configuration>\n+                    <aggregate>true</aggregate>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <configuration>\n+                    <aggregate>true</aggregate>\n+                    <linksource>true</linksource>\n+                    <links>\n+                        <link>http://java.sun.com/j2se/1.5.0/docs/api</link>\n+                        <link>http://java.sun.com/javaee/5/docs/api</link>\n+                        <link>\n+                            http://jakarta.apache.org/commons/collections/api-release</link>\n+                    </links>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </reporting>\n+    <distributionManagement>\n+        <repository>\n+            <id>bea-internal</id>\n+            <name>Internal BEA OpenJPA test site</name>\n+            <url>file:///${user.home}/web/devel/openjpa/dist</url>\n+        </repository>\n+        <site>\n+            <id>bea-internal</id>\n+            <name>Internal BEA OpenJPA test sit</name>\n+            <url>file:///${user.home}/web/devel/openjpa/site</url>\n+        </site>\n+    </distributionManagement>\n \n </project>"},{"sha":"10d6085e2340419f87e11f202440142d9683a13b","filename":"serp/pom.xml","status":"modified","additions":41,"deletions":39,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/pom.xml?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -1,41 +1,43 @@\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-\t\t<modelVersion>4.0.0</modelVersion>\n-\t<groupId>org.apache.openjpa</groupId>\n-\t<artifactId>serp</artifactId>\n-\t<packaging>jar</packaging>\n-\n-\t<name>Serp</name>\n-\t<description>Serp</description>\n-\t<url>http://incubator.apache.org/projects/openjpa</url>\n-<parent>\n-\t\n-\t\t<groupId>org.apache.openjpa</groupId>\n-\t\t<artifactId>openjpa</artifactId>\n-\t\t<version>0.0.1</version>\n-\t\t\n-\t</parent>\n-\t<dependencies>\n-\t\n-\t\t\n-\t</dependencies>\n-\t<build>\n-\t\n-\t\t<plugins>\n-\t\t\n-\t\t\t<plugin>\n-\t\t\t\n-\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n-\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n-\t\t\t\t<configuration>\n-\t\t\t\t<source>1.3</source>\n-\t\t\t\t<target>1.3</target>\n-\t\t\t\t</configuration>\n-\t\t\t\t\n-\t\t\t</plugin>\n-\t\t\t\n-\t\t</plugins>\n-\t\t\n-\t</build>\n-\t\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.openjpa</groupId>\n+    <artifactId>serp</artifactId>\n+    <packaging>jar</packaging>\n+\n+    <name>Serp</name>\n+    <description>Serp</description>\n+    <url>http://incubator.apache.org/projects/openjpa</url>\n+    <parent>\n+\n+        <groupId>org.apache.openjpa</groupId>\n+        <artifactId>openjpa</artifactId>\n+        <version>0.0.1</version>\n+\n+    </parent>\n+    <dependencies>\n+\n+\n+    </dependencies>\n+    <build>\n+\n+        <plugins>\n+\n+            <plugin>\n+\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>1.3</source>\n+                    <target>1.3</target>\n+                </configuration>\n+\n+            </plugin>\n+\n+        </plugins>\n+\n+    </build>\n+\n \n </project>"},{"sha":"933dc6d09c908bf749fc3afa39d12c4c4c8b0b52","filename":"serp/src/main/java/serp/bytecode/ArrayInstruction.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,16 +12,15 @@\n  */\n package serp.bytecode;\n \n-import java.util.*;\n-\n /**\n  * Any array load or store instruction. This class has\n  * no functionality beyond the {@link TypedInstruction} but is provided\n  * so that users can easily identify array instructions in code if need be.\n- * \n+ *\n  * @author Abe White\n  */\n public abstract class ArrayInstruction extends TypedInstruction {\n+\n     ArrayInstruction(Code owner) {\n         super(owner);\n     }"},{"sha":"c8427fbb13a056027154f3d0c3883b6de1df035e","filename":"serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","status":"modified","additions":49,"deletions":48,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayLoadInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,16 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Loads a value from an array onto the stack.\n- * \n+ *\n  * @author Abe White\n  */\n public class ArrayLoadInstruction extends ArrayInstruction {\n-    private static final Class[][] _mappings = new Class[][] {\n+\n+    private static final Class[][] _mappings = new Class[][]{\n         { boolean.class, int.class }, { void.class, int.class }, };\n \n     ArrayLoadInstruction(Code owner) {\n@@ -33,70 +34,70 @@\n \n     public int getLogicalStackChange() {\n         switch (getOpcode()) {\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -1;\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -1;\n         }\n     }\n \n     public int getStackChange() {\n         switch (getOpcode()) {\n-        case Constants.DALOAD:\n-        case Constants.LALOAD:\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -1;\n+            case Constants.DALOAD:\n+            case Constants.LALOAD:\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -1;\n         }\n     }\n \n     public String getTypeName() {\n         switch (getOpcode()) {\n-        case Constants.IALOAD:\n-            return int.class.getName();\n-        case Constants.LALOAD:\n-            return long.class.getName();\n-        case Constants.FALOAD:\n-            return float.class.getName();\n-        case Constants.DALOAD:\n-            return double.class.getName();\n-        case Constants.AALOAD:\n-            return Object.class.getName();\n-        case Constants.BALOAD:\n-            return byte.class.getName();\n-        case Constants.CALOAD:\n-            return char.class.getName();\n-        case Constants.SALOAD:\n-            return short.class.getName();\n-        default:\n-            return null;\n+            case Constants.IALOAD:\n+                return int.class.getName();\n+            case Constants.LALOAD:\n+                return long.class.getName();\n+            case Constants.FALOAD:\n+                return float.class.getName();\n+            case Constants.DALOAD:\n+                return double.class.getName();\n+            case Constants.AALOAD:\n+                return Object.class.getName();\n+            case Constants.BALOAD:\n+                return byte.class.getName();\n+            case Constants.CALOAD:\n+                return char.class.getName();\n+            case Constants.SALOAD:\n+                return short.class.getName();\n+            default:\n+                return null;\n         }\n     }\n \n     public TypedInstruction setType(String type) {\n         type = mapType(type, _mappings, true);\n \n         if (type == null)\n-            return(TypedInstruction) setOpcode(Constants.NOP);\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n \n         switch (type.charAt(0)) {\n-        case 'i':\n-            return(TypedInstruction) setOpcode(Constants.IALOAD);\n-        case 'l':\n-            return(TypedInstruction) setOpcode(Constants.LALOAD);\n-        case 'f':\n-            return(TypedInstruction) setOpcode(Constants.FALOAD);\n-        case 'd':\n-            return(TypedInstruction) setOpcode(Constants.DALOAD);\n-        case 'b':\n-            return(TypedInstruction) setOpcode(Constants.BALOAD);\n-        case 'c':\n-            return(TypedInstruction) setOpcode(Constants.CALOAD);\n-        case 's':\n-            return(TypedInstruction) setOpcode(Constants.SALOAD);\n-        default:\n-            return(TypedInstruction) setOpcode(Constants.AALOAD);\n+            case 'i':\n+                return (TypedInstruction) setOpcode(Constants.IALOAD);\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.LALOAD);\n+            case 'f':\n+                return (TypedInstruction) setOpcode(Constants.FALOAD);\n+            case 'd':\n+                return (TypedInstruction) setOpcode(Constants.DALOAD);\n+            case 'b':\n+                return (TypedInstruction) setOpcode(Constants.BALOAD);\n+            case 'c':\n+                return (TypedInstruction) setOpcode(Constants.CALOAD);\n+            case 's':\n+                return (TypedInstruction) setOpcode(Constants.SALOAD);\n+            default:\n+                return (TypedInstruction) setOpcode(Constants.AALOAD);\n         }\n     }\n "},{"sha":"af9202077e4f57ec5eddb80b28ad96564874e2de","filename":"serp/src/main/java/serp/bytecode/ArrayState.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,14 +12,16 @@\n  */\n package serp.bytecode;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.Collections;\n \n /**\n  * State implementing the behavior of an array class.\n- * \n+ *\n  * @author Abe White\n  */\n class ArrayState extends State {\n+\n     private String _name = null;\n     private String _componentName = null;\n "},{"sha":"0ace3f0a876dc91ff951ec02494aa69c8c33896e","filename":"serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","status":"modified","additions":50,"deletions":49,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ArrayStoreInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,16 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Store a value from the stack into an array.\n- * \n+ *\n  * @author Abe White\n  */\n public class ArrayStoreInstruction extends ArrayInstruction {\n-    private static final Class[][] _mappings = new Class[][] {\n+\n+    private static final Class[][] _mappings = new Class[][]{\n         { boolean.class, int.class }, { void.class, int.class }, };\n \n     ArrayStoreInstruction(Code owner) {\n@@ -33,70 +34,70 @@\n \n     public int getLogicalStackChange() {\n         switch (getOpcode()) {\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -3;\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -3;\n         }\n     }\n \n     public int getStackChange() {\n         switch (getOpcode()) {\n-        case Constants.DASTORE:\n-        case Constants.LASTORE:\n-            return -4;\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -3;\n+            case Constants.DASTORE:\n+            case Constants.LASTORE:\n+                return -4;\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -3;\n         }\n     }\n \n     public String getTypeName() {\n         switch (getOpcode()) {\n-        case Constants.IASTORE:\n-            return int.class.getName();\n-        case Constants.LASTORE:\n-            return long.class.getName();\n-        case Constants.FASTORE:\n-            return float.class.getName();\n-        case Constants.DASTORE:\n-            return double.class.getName();\n-        case Constants.AASTORE:\n-            return Object.class.getName();\n-        case Constants.BASTORE:\n-            return byte.class.getName();\n-        case Constants.CASTORE:\n-            return char.class.getName();\n-        case Constants.SASTORE:\n-            return short.class.getName();\n-        default:\n-            return null;\n+            case Constants.IASTORE:\n+                return int.class.getName();\n+            case Constants.LASTORE:\n+                return long.class.getName();\n+            case Constants.FASTORE:\n+                return float.class.getName();\n+            case Constants.DASTORE:\n+                return double.class.getName();\n+            case Constants.AASTORE:\n+                return Object.class.getName();\n+            case Constants.BASTORE:\n+                return byte.class.getName();\n+            case Constants.CASTORE:\n+                return char.class.getName();\n+            case Constants.SASTORE:\n+                return short.class.getName();\n+            default:\n+                return null;\n         }\n     }\n \n     public TypedInstruction setType(String type) {\n         type = mapType(type, _mappings, true);\n         if (type == null)\n-            return(TypedInstruction) setOpcode(Constants.NOP);\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n \n         switch (type.charAt(0)) {\n-        case 'i':\n-            return(TypedInstruction) setOpcode(Constants.IASTORE);\n-        case 'l':\n-            return(TypedInstruction) setOpcode(Constants.LASTORE);\n-        case 'f':\n-            return(TypedInstruction) setOpcode(Constants.FASTORE);\n-        case 'd':\n-            return(TypedInstruction) setOpcode(Constants.DASTORE);\n-        case 'b':\n-            return(TypedInstruction) setOpcode(Constants.BASTORE);\n-        case 'c':\n-            return(TypedInstruction) setOpcode(Constants.CASTORE);\n-        case 's':\n-            return(TypedInstruction) setOpcode(Constants.SASTORE);\n-        default:\n-            return(TypedInstruction) setOpcode(Constants.AASTORE);\n+            case 'i':\n+                return (TypedInstruction) setOpcode(Constants.IASTORE);\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.LASTORE);\n+            case 'f':\n+                return (TypedInstruction) setOpcode(Constants.FASTORE);\n+            case 'd':\n+                return (TypedInstruction) setOpcode(Constants.DASTORE);\n+            case 'b':\n+                return (TypedInstruction) setOpcode(Constants.BASTORE);\n+            case 'c':\n+                return (TypedInstruction) setOpcode(Constants.CASTORE);\n+            case 's':\n+                return (TypedInstruction) setOpcode(Constants.SASTORE);\n+            default:\n+                return (TypedInstruction) setOpcode(Constants.AASTORE);\n         }\n     }\n "},{"sha":"1c2cb74bae6a4110317f708f1c01b80353c57890","filename":"serp/src/main/java/serp/bytecode/Attribute.java","status":"modified","additions":15,"deletions":9,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Attribute.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Attribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attribute.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,22 +12,28 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.lowlevel.UTF8Entry;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Numbers;\n \n /**\n  * In bytecode attributes are used to represent anything that is not\n  * part of the class structure. This includes the source file name, code of\n  * methods, the line number table, etc. All attributes contain at a minimum\n  * an immutable name that also determines the attribute's type.\n- * \n+ *\n  * @author Abe White\n  */\n public abstract class Attribute extends Attributes implements VisitAcceptor {\n+\n     private int _nameIndex = 0;\n     private Attributes _owner = null;\n \n@@ -42,7 +48,7 @@ static Attribute create(String name, Attributes owner) {\n             Constructor cons = type.getDeclaredConstructor(new Class[]\n                 { int.class, Attributes.class });\n \n-            return(Attribute) cons.newInstance(new Object[]\n+            return (Attribute) cons.newInstance(new Object[]\n                 { Numbers.valueOf(nameIndex), owner });\n         } catch (Throwable t) {\n             return new UnknownAttribute(nameIndex, owner);\n@@ -75,7 +81,7 @@ public int getNameIndex() {\n      * Return the name of this attribute.\n      */\n     public String getName() {\n-        return((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n+        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n     }\n \n     public Project getProject() {"},{"sha":"b5e091ce10de2b73a55695ddcb558cb1bd08c893","filename":"serp/src/main/java/serp/bytecode/Attributes.java","status":"modified","additions":18,"deletions":11,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Attributes.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Attributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Attributes.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,25 +12,32 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import serp.bytecode.lowlevel.UTF8Entry;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Abstract superclass for all bytecode entities that hold attributes.\n- * \n+ *\n  * @author Abe White\n  */\n public abstract class Attributes implements BCEntity {\n+\n     /**\n      * Return all the attributes owned by this entity.\n-     * \n+     *\n      * @return all owned attributes, or empty array if none\n      */\n     public Attribute[] getAttributes() {\n         Collection attrs = getAttributesHolder();\n-        return(Attribute[]) attrs.toArray(new Attribute[attrs.size()]);\n+        return (Attribute[]) attrs.toArray(new Attribute[attrs.size()]);\n     }\n \n     /**\n@@ -51,7 +58,7 @@ public Attribute getAttribute(String name) {\n \n     /**\n      * Return all attributes with the given name.\n-     * \n+     *\n      * @return the matching attributes, or empty array if none\n      */\n     public Attribute[] getAttributes(String name) {\n@@ -64,7 +71,7 @@ public Attribute getAttribute(String name) {\n             if (attr.getName().equals(name))\n                 matches.add(attr);\n         }\n-        return(Attribute[]) matches.toArray(new Attribute[matches.size()]);\n+        return (Attribute[]) matches.toArray(new Attribute[matches.size()]);\n     }\n \n     /**\n@@ -112,7 +119,7 @@ public void clearAttributes() {\n \n     /**\n      * Remove all attributes with the given name from this entity.\n-     * \n+     *\n      * @return true if an attribute was removed, false otherwise\n      */\n     public boolean removeAttribute(String name) {\n@@ -122,7 +129,7 @@ public boolean removeAttribute(String name) {\n     /**\n      * Remove the given attribute. After being removed, the attribute\n      * is invalid, and the result of any operations on it are undefined.\n-     * \n+     *\n      * @return true if the attribute was removed, false otherwise\n      */\n     public boolean removeAttribute(Attribute attribute) {"},{"sha":"69a382d4abb5505eb7a1d7af79a492f6abb4b3e5","filename":"serp/src/main/java/serp/bytecode/BCClass.java","status":"modified","additions":97,"deletions":59,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCClass.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClass.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,12 +12,30 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.net.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URLDecoder;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n \n /**\n  * The BCClass represents a class object in the bytecode framework, in many\n@@ -27,16 +45,17 @@\n  * contains methods to manipulate the low-level state of the class(constant\n  * pool indexes, etc), but these can and should be ignored in\n  * favor of the available high-level methods.\n- *  A BCClass instance is loaded from a {@link Project} and remains\n+ * A BCClass instance is loaded from a {@link Project} and remains\n  * attached to that project for its lifetime. If a BCClass is removed from\n  * its project, the result of any further operations on the class are undefined.\n- *  Note that if a BCClass represents a primitive or array type, all of the\n+ * Note that if a BCClass represents a primitive or array type, all of the\n  * available mutator methods and any methods that access the constant pool\n  * will throw {@link UnsupportedOperationException}s.\n- * \n+ *\n  * @author Abe White\n  */\n public class BCClass extends Attributes implements VisitAcceptor {\n+\n     private Project _project = null;\n     private State _state = null;\n     private ClassLoader _loader = null;\n@@ -73,7 +92,11 @@ void invalidate() {\n      */\n     void read(File classFile, ClassLoader loader) throws IOException {\n         InputStream in = new FileInputStream(classFile);\n-        try { read(in, loader); } finally { in.close(); }\n+        try {\n+            read(in, loader);\n+        } finally {\n+            in.close();\n+        }\n     }\n \n     /**\n@@ -143,7 +166,11 @@ void read(Class type) throws IOException {\n \n         // attempt to get the class file for the class as a stream\n         InputStream in = type.getResourceAsStream(className + \".class\");\n-        try { read(in, type.getClassLoader()); } finally { in.close(); }\n+        try {\n+            read(in, type.getClassLoader());\n+        } finally {\n+            in.close();\n+        }\n     }\n \n     /**\n@@ -178,15 +205,23 @@ public void write() throws IOException {\n         // has spaces in it\n         OutputStream out = new FileOutputStream(URLDecoder.decode\n             (type.getResource(name + \".class\").getFile()));\n-        try { write(out); } finally { out.close(); }\n+        try {\n+            write(out);\n+        } finally {\n+            out.close();\n+        }\n     }\n \n     /**\n      * Write the class bytecode to the specified file.\n      */\n     public void write(File classFile) throws IOException {\n         OutputStream out = new FileOutputStream(classFile);\n-        try { write(out); } finally { out.close(); }\n+        try {\n+            write(out);\n+        } finally {\n+            out.close();\n+        }\n     }\n \n     /**\n@@ -246,7 +281,10 @@ public void write(OutputStream outstream) throws IOException {\n             throw new RuntimeException(ioe.toString());\n         }\n         finally {\n-            try { out.close(); } catch (IOException ioe) {}\n+            try {\n+                out.close();\n+            } catch (IOException ioe) {\n+            }\n         }\n     }\n \n@@ -330,7 +368,7 @@ public void setAccessFlags(int access) {\n      * Manipulate the class access flags.\n      */\n     public boolean isPublic() {\n-        return(getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n     }\n \n     /**\n@@ -358,7 +396,7 @@ public void makePackage() {\n      * Manipulate the class access flags.\n      */\n     public boolean isFinal() {\n-        return(getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n     }\n \n     /**\n@@ -375,7 +413,7 @@ public void setFinal(boolean on) {\n      * Manipulate the class access flags.\n      */\n     public boolean isInterface() {\n-        return(getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n     }\n \n     /**\n@@ -393,7 +431,7 @@ public void setInterface(boolean on) {\n      * Manipulate the class access flags.\n      */\n     public boolean isAbstract() {\n-        return(getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n     }\n \n     /**\n@@ -626,7 +664,7 @@ public void setSuperclass(BCClass type) {\n      * Return the list of {@link ConstantPool} indexes of the\n      * {@link ClassEntry}s describing all the interfaces this class declares\n      * that it implements/extends.\n-     * \n+     *\n      * @return the implmented interfaces, or an empty array if none\n      */\n     public int[] getDeclaredInterfaceIndexes() {\n@@ -748,7 +786,7 @@ public void setDeclaredInterfaces(BCClass[] interfaces) {\n             for (int i = 0; i < names.length; i++)\n                 allNames.add(names[i]);\n         }\n-        return(String[]) allNames.toArray(new String[allNames.size()]);\n+        return (String[]) allNames.toArray(new String[allNames.size()]);\n     }\n \n     /**\n@@ -764,7 +802,7 @@ public void setDeclaredInterfaces(BCClass[] interfaces) {\n             for (int i = 0; i < types.length; i++)\n                 allTypes.add(types[i]);\n         }\n-        return(Class[]) allTypes.toArray(new Class[allTypes.size()]);\n+        return (Class[]) allTypes.toArray(new Class[allTypes.size()]);\n     }\n \n     /**\n@@ -780,7 +818,7 @@ public void setDeclaredInterfaces(BCClass[] interfaces) {\n             for (int i = 0; i < types.length; i++)\n                 allTypes.add(types[i]);\n         }\n-        return(BCClass[]) allTypes.toArray(new BCClass[allTypes.size()]);\n+        return (BCClass[]) allTypes.toArray(new BCClass[allTypes.size()]);\n     }\n \n     /**\n@@ -792,7 +830,7 @@ public void clearDeclaredInterfaces() {\n \n     /**\n      * Remove an interface declared by this class.\n-     * \n+     *\n      * @return true if the class had the interface, false otherwise\n      */\n     public boolean removeDeclaredInterface(String name) {\n@@ -810,7 +848,7 @@ public boolean removeDeclaredInterface(String name) {\n \n     /**\n      * Remove an interface declared by this class.\n-     * \n+     *\n      * @return true if the class had the interface, false otherwise\n      */\n     public boolean removeDeclaredInterface(Class type) {\n@@ -821,7 +859,7 @@ public boolean removeDeclaredInterface(Class type) {\n \n     /**\n      * Remove an interface declared by this class.\n-     * \n+     *\n      * @return true if the class had the interface, false otherwise\n      */\n     public boolean removeDeclaredInterface(BCClass type) {\n@@ -901,7 +939,7 @@ public boolean isInstanceOf(BCClass type) {\n      */\n     public BCField[] getDeclaredFields() {\n         Collection fields = _state.getFieldsHolder();\n-        return(BCField[]) fields.toArray(new BCField[fields.size()]);\n+        return (BCField[]) fields.toArray(new BCField[fields.size()]);\n     }\n \n     /**\n@@ -927,7 +965,7 @@ public BCField getDeclaredField(String name) {\n             for (int i = 0; i < fields.length; i++)\n                 allFields.add(fields[i]);\n         }\n-        return(BCField[]) allFields.toArray(new BCField[allFields.size()]);\n+        return (BCField[]) allFields.toArray(new BCField[allFields.size()]);\n     }\n \n     /**\n@@ -940,7 +978,7 @@ public BCField getDeclaredField(String name) {\n         for (int i = 0; i < fields.length; i++)\n             if (fields[i].getName().equals(name))\n                 matches.add(fields[i]);\n-        return(BCField[]) matches.toArray(new BCField[matches.size()]);\n+        return (BCField[]) matches.toArray(new BCField[matches.size()]);\n     }\n \n     /**\n@@ -956,7 +994,7 @@ public void setDeclaredFields(BCField[] fields) {\n \n     /**\n      * Import the information from given field as a new field in this class.\n-     * \n+     *\n      * @return the added field\n      */\n     public BCField declareField(BCField field) {\n@@ -968,7 +1006,7 @@ public BCField declareField(BCField field) {\n \n     /**\n      * Add a field to this class.\n-     * \n+     *\n      * @return the added field\n      */\n     public BCField declareField(String name, String type) {\n@@ -981,7 +1019,7 @@ public BCField declareField(String name, String type) {\n \n     /**\n      * Add a field to this class.\n-     * \n+     *\n      * @return the added field\n      */\n     public BCField declareField(String name, Class type) {\n@@ -991,7 +1029,7 @@ public BCField declareField(String name, Class type) {\n \n     /**\n      * Add a field to this class.\n-     * \n+     *\n      * @return the added field\n      */\n     public BCField declareField(String name, BCClass type) {\n@@ -1015,7 +1053,7 @@ public void clearDeclaredFields() {\n     /**\n      * Remove a field from this class. After this method, the removed field\n      * will be invalid, and the result of any operations on it is undefined.\n-     * \n+     *\n      * @return true if this class contained the field, false otherwise\n      */\n     public boolean removeDeclaredField(String name) {\n@@ -1035,7 +1073,7 @@ public boolean removeDeclaredField(String name) {\n     /**\n      * Remove a field from this class. After this method, the removed field\n      * will be invalid, and the result of any operations on it is undefined.\n-     * \n+     *\n      * @return true if this class contained the field, false otherwise\n      */\n     public boolean removeDeclaredField(BCField field) {\n@@ -1054,7 +1092,7 @@ public boolean removeDeclaredField(BCField field) {\n      */\n     public BCMethod[] getDeclaredMethods() {\n         Collection methods = _state.getMethodsHolder();\n-        return(BCMethod[]) methods.toArray(new BCMethod[methods.size()]);\n+        return (BCMethod[]) methods.toArray(new BCMethod[methods.size()]);\n     }\n \n     /**\n@@ -1084,7 +1122,7 @@ public BCMethod getDeclaredMethod(String name) {\n         for (int i = 0; i < methods.length; i++)\n             if (methods[i].getName().equals(name))\n                 matches.add(methods[i]);\n-        return(BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n     }\n \n     /**\n@@ -1170,7 +1208,7 @@ public BCMethod getDeclaredMethod(String name, BCClass[] paramTypes) {\n             for (int i = 0; i < methods.length; i++)\n                 allMethods.add(methods[i]);\n         }\n-        return(BCMethod[]) allMethods.toArray (new BCMethod[allMethods.size()]);\n+        return (BCMethod[]) allMethods.toArray(new BCMethod[allMethods.size()]);\n     }\n \n     /**\n@@ -1185,7 +1223,7 @@ public BCMethod getDeclaredMethod(String name, BCClass[] paramTypes) {\n         for (int i = 0; i < methods.length; i++)\n             if (methods[i].getName().equals(name))\n                 matches.add(methods[i]);\n-        return(BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n     }\n \n     /**\n@@ -1221,7 +1259,7 @@ public BCMethod getDeclaredMethod(String name, BCClass[] paramTypes) {\n                     matches.add(methods[i]);\n             }\n         }\n-        return(BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n+        return (BCMethod[]) matches.toArray(new BCMethod[matches.size()]);\n     }\n \n     /**\n@@ -1269,7 +1307,7 @@ public void setDeclaredMethods(BCMethod[] methods) {\n \n     /**\n      * Import the information in the given method as a new method of this class.\n-     * \n+     *\n      * @return the added method\n      */\n     public BCMethod declareMethod(BCMethod method) {\n@@ -1284,7 +1322,7 @@ public BCMethod declareMethod(BCMethod method) {\n      * Add a method to this class.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return the added method\n      */\n     public BCMethod declareMethod(String name, String returnType,\n@@ -1300,7 +1338,7 @@ public BCMethod declareMethod(String name, String returnType,\n      * Add a method to this class.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return the added method\n      */\n     public BCMethod declareMethod(String name, Class returnType,\n@@ -1319,7 +1357,7 @@ public BCMethod declareMethod(String name, Class returnType,\n      * Add a method to this class.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return the added method\n      */\n     public BCMethod declareMethod(String name, BCClass returnType,\n@@ -1353,7 +1391,7 @@ public void clearDeclaredMethods() {\n      * If multiple methods match the given name, which is removed is undefined.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return true if this class contained the method, false otherwise\n      */\n     public boolean removeDeclaredMethod(String name) {\n@@ -1373,7 +1411,7 @@ public boolean removeDeclaredMethod(String name) {\n     /**\n      * Removes a method from this class. After this method, the removed method\n      * will be invalid, and the result of any operations on it is undefined.\n-     * \n+     *\n      * @return true if this class contained the method, false otherwise\n      */\n     public boolean removeDeclaredMethod(BCMethod method) {\n@@ -1387,7 +1425,7 @@ public boolean removeDeclaredMethod(BCMethod method) {\n      * will be invalid, and the result of any operations on it is undefined.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return true if this class contained the method, false otherwise\n      */\n     public boolean removeDeclaredMethod(String name, String[] paramTypes) {\n@@ -1429,7 +1467,7 @@ public boolean removeDeclaredMethod(String name, String[] paramTypes) {\n      * will be invalid, and the result of any operations on it is undefined.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return true if this class contained the method, false otherwise\n      */\n     public boolean removeDeclaredMethod(String name, Class[] paramTypes) {\n@@ -1447,7 +1485,7 @@ public boolean removeDeclaredMethod(String name, Class[] paramTypes) {\n      * will be invalid, and the result of any operations on it is undefined.\n      * Note that in bytecode, constructors are named <code>&lt;init&gt;</code>\n      * and static initializers are named <code>&lt;clinit&gt;</code>.\n-     * \n+     *\n      * @return true if this class contained the method, false otherwise\n      */\n     public boolean removeDeclaredMethod(String name, BCClass[] paramTypes) {\n@@ -1469,7 +1507,7 @@ public boolean removeDeclaredMethod(String name, BCClass[] paramTypes) {\n      * If a default constructor already exists, this method will return it\n      * without modification.\n      * This method can only be called if the superclass has been set.\n-     * \n+     *\n      * @return the default constructor\n      */\n     public BCMethod addDefaultConstructor() {\n@@ -1492,23 +1530,23 @@ public BCMethod addDefaultConstructor() {\n     /**\n      * Return source file information for the class.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new source file attribute will be added\n-     * if not already present\n+     *            if not already present\n      * @return the source file information, or null if none and the\n-     * <code>add</code> param is set to false\n+     *         <code>add</code> param is set to false\n      */\n     public SourceFile getSourceFile(boolean add) {\n         SourceFile source = (SourceFile) getAttribute(Constants.ATTR_SOURCE);\n         if (!add || source != null)\n             return source;\n-        return(SourceFile) addAttribute(Constants.ATTR_SOURCE);\n+        return (SourceFile) addAttribute(Constants.ATTR_SOURCE);\n     }\n \n     /**\n      * Remove the source file attribute for the class.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a file to remove\n      */\n     public boolean removeSourceFile() {\n@@ -1518,24 +1556,24 @@ public boolean removeSourceFile() {\n     /**\n      * Return inner classes information for the class.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new inner classes attribute will be added\n-     * if not already present\n+     *            if not already present\n      * @return the inner classes information, or null if none and the\n-     * <code>add</code> param is set to false\n+     *         <code>add</code> param is set to false\n      */\n     public InnerClasses getInnerClasses(boolean add) {\n         InnerClasses inner = (InnerClasses) getAttribute\n             (Constants.ATTR_INNERCLASS);\n         if (!add || inner != null)\n             return inner;\n-        return(InnerClasses) addAttribute(Constants.ATTR_INNERCLASS);\n+        return (InnerClasses) addAttribute(Constants.ATTR_INNERCLASS);\n     }\n \n     /**\n      * Remove the inner classes attribute for the class.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was an attribute to remove\n      */\n     public boolean removeInnerClasses() {"},{"sha":"491793cc2af5dc6b3abed6b4b1d46e0fbafb6d7d","filename":"serp/src/main/java/serp/bytecode/BCClassLoader.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCClassLoader.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -15,10 +15,11 @@\n /**\n  * Class loader that will attempt to find requested classes in a given\n  * {@link Project}.\n- * \n+ *\n  * @author Abe White\n  */\n public class BCClassLoader extends ClassLoader {\n+\n     private Project _project = null;\n \n     /**\n@@ -30,7 +31,7 @@ public BCClassLoader(Project project) {\n \n     /**\n      * Constructor. Supply the project to use when looking for classes.\n-     * \n+     *\n      * @param parent the parent classoader\n      */\n     public BCClassLoader(Project project, ClassLoader loader) {"},{"sha":"ff5e6da90985b53426368220e2e5ab04ca0f5f64","filename":"serp/src/main/java/serp/bytecode/BCEntity.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCEntity.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCEntity.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,16 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.lowlevel.*;\n+import serp.bytecode.lowlevel.ConstantPool;\n \n /**\n  * Interface implemented by all bytecode entities. Entities must be able\n  * to access the project, constant pool, and class loader of the current class.\n- * \n+ *\n  * @author Abe White\n  */\n public interface BCEntity {\n+\n     /**\n      * Return the project of the current class.\n      */"},{"sha":"e8f5fa483c6fefbbb5931eeb147a17e9f5443803","filename":"serp/src/main/java/serp/bytecode/BCField.java","status":"modified","additions":15,"deletions":14,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCField.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCField.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,16 +12,17 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Strings;\n \n /**\n  * A field of a class.\n- * \n+ *\n  * @author Abe White\n  */\n public class BCField extends BCMember implements VisitAcceptor {\n+\n     BCField(BCClass owner) {\n         super(owner);\n     }\n@@ -30,7 +31,7 @@\n      * Manipulate the field access flags.\n      */\n     public boolean isVolatile() {\n-        return(getAccessFlags() & Constants.ACCESS_VOLATILE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_VOLATILE) > 0;\n     }\n \n     /**\n@@ -47,7 +48,7 @@ public void setVolatile(boolean on) {\n      * Manipulate the field access flags.\n      */\n     public boolean isTransient() {\n-        return(getAccessFlags() & Constants.ACCESS_TRANSIENT) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_TRANSIENT) > 0;\n     }\n \n     /**\n@@ -63,7 +64,7 @@ public void setTransient(boolean on) {\n     /**\n      * Return the name of the type of this field. The name will be given in\n      * a form suitable for a {@link Class#forName} call.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public String getTypeName() {\n@@ -87,7 +88,7 @@ public BCClass getTypeBC() {\n \n     /**\n      * Set the name of the type of this field.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setType(String type) {\n@@ -96,7 +97,7 @@ public void setType(String type) {\n \n     /**\n      * Set the type of this field.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setType(Class type) {\n@@ -105,7 +106,7 @@ public void setType(Class type) {\n \n     /**\n      * Set the type of this field.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setType(BCClass type) {\n@@ -115,11 +116,11 @@ public void setType(BCClass type) {\n     /**\n      * Return the constant value information for the field.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new constant value attribute will be added\n-     * if not already present\n+     *            if not already present\n      * @return the constant value information, or null if none and the\n-     * <code>add</code> param is set to false\n+     *         <code>add</code> param is set to false\n      */\n     public ConstantValue getConstantValue(boolean add) {\n         ConstantValue constant = (ConstantValue) getAttribute\n@@ -135,7 +136,7 @@ public ConstantValue getConstantValue(boolean add) {\n     /**\n      * Remove the constant value attribute for the field.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a value to remove\n      */\n     public boolean removeConstantValue() {"},{"sha":"d8719da8f13102772c7bf3c59725e7a3b8972cb7","filename":"serp/src/main/java/serp/bytecode/BCMember.java","status":"modified","additions":18,"deletions":11,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCMember.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCMember.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMember.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,16 +12,23 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+import serp.bytecode.lowlevel.ComplexEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.lowlevel.UTF8Entry;\n \n /**\n  * A member field or method of a class.\n- * \n+ *\n  * @author Abe White\n  */\n public abstract class BCMember extends Attributes {\n+\n     private BCClass _owner = null;\n     private int _access = Constants.ACCESS_PRIVATE;\n     private int _nameIndex = 0;\n@@ -67,7 +74,7 @@ public void setAccessFlags(int access) {\n      * Manipulate the member access flags.\n      */\n     public boolean isPublic() {\n-        return(getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n     }\n \n     /**\n@@ -83,7 +90,7 @@ public void makePublic() {\n      * Manipulate the member access flags.\n      */\n     public boolean isProtected() {\n-        return(getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n     }\n \n     /**\n@@ -99,7 +106,7 @@ public void makeProtected() {\n      * Manipulate the member access flags.\n      */\n     public boolean isPrivate() {\n-        return(getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n     }\n \n     /**\n@@ -138,7 +145,7 @@ public void makePackage() {\n      * Manipulate the member access flags.\n      */\n     public boolean isFinal() {\n-        return(getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n     }\n \n     /**\n@@ -155,7 +162,7 @@ public void setFinal(boolean on) {\n      * Manipulate the member access flags.\n      */\n     public boolean isStatic() {\n-        return(getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n     }\n \n     /**\n@@ -216,7 +223,7 @@ public void setDescriptorIndex(int index) {\n      * Return the name of this member.\n      */\n     public String getName() {\n-        return((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n+        return ((UTF8Entry) getPool().getEntry(_nameIndex)).getValue();\n     }\n \n     /**\n@@ -236,7 +243,7 @@ public void setName(String name) {\n      * Return the descriptor of this member, in internal form.\n      */\n     public String getDescriptor() {\n-        return((UTF8Entry) getPool().getEntry(_descriptorIndex)).getValue();\n+        return ((UTF8Entry) getPool().getEntry(_descriptorIndex)).getValue();\n     }\n \n     /**"},{"sha":"954577f0e05574769f90144901de5571fccb325a","filename":"serp/src/main/java/serp/bytecode/BCMethod.java","status":"modified","additions":33,"deletions":31,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCMethod.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/BCMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/BCMethod.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,17 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Strings;\n \n /**\n  * A method of a class.\n- * \n+ *\n  * @author Abe White\n  */\n public class BCMethod extends BCMember implements VisitAcceptor {\n+\n     BCMethod(BCClass owner) {\n         super(owner);\n     }\n@@ -33,7 +35,7 @@\n      * Manipulate the method access flags.\n      */\n     public boolean isSynchronized() {\n-        return(getAccessFlags() & Constants.ACCESS_SYNCHRONIZED) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_SYNCHRONIZED) > 0;\n     }\n \n     /**\n@@ -50,7 +52,7 @@ public void setSynchronized(boolean on) {\n      * Manipulate the method access flags.\n      */\n     public boolean isNative() {\n-        return(getAccessFlags() & Constants.ACCESS_NATIVE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_NATIVE) > 0;\n     }\n \n     /**\n@@ -67,7 +69,7 @@ public void setNative(boolean on) {\n      * Manipulate the method access flags.\n      */\n     public boolean isAbstract() {\n-        return(getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n     }\n \n     /**\n@@ -84,7 +86,7 @@ public void setAbstract(boolean on) {\n      * Manipulate the method access flags.\n      */\n     public boolean isStrict() {\n-        return(getAccessFlags() & Constants.ACCESS_STRICT) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_STRICT) > 0;\n     }\n \n     /**\n@@ -104,7 +106,7 @@ public void setStrict(boolean on) {\n     /**\n      * Return the name of the type returned by this method. The name\n      * will be given in a form suitable for a {@link Class#forName} call.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public String getReturnName() {\n@@ -114,7 +116,7 @@ public String getReturnName() {\n \n     /**\n      * Return the {@link Class} object for the return type of this method.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public Class getReturnType() {\n@@ -123,7 +125,7 @@ public Class getReturnType() {\n \n     /**\n      * Return the bytecode for the return type of this method.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public BCClass getReturnBC() {\n@@ -159,7 +161,7 @@ public void setReturn(BCClass type) {\n     /**\n      * Return the names of all the parameter types for this method. The names\n      * will be returned in a form suitable for a {@link Class#forName} call.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public String[] getParamNames() {\n@@ -177,7 +179,7 @@ public void setReturn(BCClass type) {\n     /**\n      * Return the {@link Class} objects for all the parameter types for this\n      * method.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public Class[] getParamTypes() {\n@@ -190,7 +192,7 @@ public void setReturn(BCClass type) {\n \n     /**\n      * Return the bytecode for all the parameter types for this method.\n-     * \n+     *\n      * @see BCMember#getDescriptor\n      */\n     public BCClass[] getParamBCs() {\n@@ -203,7 +205,7 @@ public void setReturn(BCClass type) {\n \n     /**\n      * Set the parameter types of this method.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setParams(String[] names) {\n@@ -215,7 +217,7 @@ public void setParams(String[] names) {\n \n     /**\n      * Set the parameter type of this method.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setParams(Class[] types) {\n@@ -231,7 +233,7 @@ public void setParams(Class[] types) {\n \n     /**\n      * Set the parameter type of this method.\n-     * \n+     *\n      * @see BCMember#setDescriptor\n      */\n     public void setParams(BCClass[] types) {\n@@ -274,7 +276,7 @@ public void addParam(BCClass type) {\n \n     /**\n      * Add a parameter type to this method.\n-     * \n+     *\n      * @see java.util.List#add(int,Object)\n      */\n     public void addParam(int pos, String type) {\n@@ -294,7 +296,7 @@ public void addParam(int pos, String type) {\n \n     /**\n      * Add a parameter type to this method.\n-     * \n+     *\n      * @see java.util.List#add(int,Object)\n      */\n     public void addParam(int pos, Class type) {\n@@ -303,7 +305,7 @@ public void addParam(int pos, Class type) {\n \n     /**\n      * Add a parameter type to this method.\n-     * \n+     *\n      * @see java.util.List#add(int,Object)\n      */\n     public void addParam(int pos, BCClass type) {\n@@ -312,7 +314,7 @@ public void addParam(int pos, BCClass type) {\n \n     /**\n      * Change a parameter type of this method.\n-     * \n+     *\n      * @see java.util.List#set(int,Object)\n      */\n     public void setParam(int pos, String type) {\n@@ -332,7 +334,7 @@ public void setParam(int pos, String type) {\n \n     /**\n      * Change a parameter type of this method.\n-     * \n+     *\n      * @see java.util.List#set(int,Object)\n      */\n     public void setParam(int pos, Class type) {\n@@ -341,7 +343,7 @@ public void setParam(int pos, Class type) {\n \n     /**\n      * Change a parameter type of this method.\n-     * \n+     *\n      * @see java.util.List#set(int,Object)\n      */\n     public void setParam(int pos, BCClass type) {\n@@ -377,11 +379,11 @@ public void removeParam(int pos) {\n     /**\n      * Return the checked exceptions information for the method.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new exceptions attribute will be added\n-     * if not already present\n+     *            if not already present\n      * @return the exceptions information, or null if none and the\n-     * <code>add</code> param is set to false\n+     *         <code>add</code> param is set to false\n      */\n     public Exceptions getExceptions(boolean add) {\n         Exceptions exceptions = (Exceptions) getAttribute\n@@ -397,7 +399,7 @@ public Exceptions getExceptions(boolean add) {\n     /**\n      * Remove the exceptions attribute for the method.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a value to remove\n      */\n     public boolean removeExceptions() {\n@@ -408,11 +410,11 @@ public boolean removeExceptions() {\n      * Return the code for the method. If the code already exists, its\n      * iterator will be reset to the first instruction.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new code attribute will be added\n-     * if not already present\n+     *            if not already present\n      * @return the code for the metohd, or null if none and the\n-     * <code>add</code> param is set to false\n+     *         <code>add</code> param is set to false\n      */\n     public Code getCode(boolean add) {\n         Code code = (Code) getAttribute(Constants.ATTR_CODE);\n@@ -423,13 +425,13 @@ public Code getCode(boolean add) {\n         if (!add)\n             return null;\n \n-        return(Code) addAttribute(Constants.ATTR_CODE);\n+        return (Code) addAttribute(Constants.ATTR_CODE);\n     }\n \n     /**\n      * Remove the code attribute from the method.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a value to remove\n      */\n     public boolean removeCode() {"},{"sha":"1251050bc87a380aa5751eebfb60e82c5551b97e","filename":"serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","status":"modified","additions":10,"deletions":8,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassConstantInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,8 +12,8 @@\n  */\n package serp.bytecode;\n \n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Pseudo-instruction used to place {@link Class} objects onto the stack.\n@@ -22,12 +22,14 @@\n  * Therefore, once the type of class being loaded is set, it cannot\n  * be changed. Also, this instruction is invalid as the target of\n  * any jump instruction or exception handler.\n- * \n+ *\n  * @author Abe White\n  */\n public class ClassConstantInstruction {\n-    private static final Class[] _params = new Class[] { String.class };\n+\n+    private static final Class[] _params = new Class[]{ String.class };\n     private static final Map _wrappers = new HashMap();\n+\n     static {\n         _wrappers.put(byte.class.getName(), Byte.class);\n         _wrappers.put(boolean.class.getName(), Boolean.class);\n@@ -52,7 +54,7 @@\n \n     /**\n      * Set the type of class being loaded.\n-     * \n+     *\n      * @return the first Instruction of the block added by setting the type\n      * @throws IllegalStateException if type has already been set\n      */\n@@ -64,7 +66,7 @@ public Instruction setClass(String name) {\n \n     /**\n      * Set the type of class being loaded.\n-     * \n+     *\n      * @return the first Instruction of the block added by setting the type\n      * @throws IllegalStateException if type has already been set\n      */\n@@ -74,7 +76,7 @@ public Instruction setClass(Class type) {\n \n     /**\n      * Set the type of class being loaded.\n-     * \n+     *\n      * @return the first Instruction of the block added by setting the type\n      * @throws IllegalStateException if type has already been set\n      */\n@@ -195,6 +197,6 @@ private BCMethod addClassLoadMethod() {\n     private static Class getWrapperClass(String name) {\n         if (name == null)\n             return null;\n-        return(Class) _wrappers.get(name);\n+        return (Class) _wrappers.get(name);\n     }\n }"},{"sha":"e2b0aea5e5ee14218b8c807870bc8d76595f9086","filename":"serp/src/main/java/serp/bytecode/ClassInstruction.java","status":"modified","additions":10,"deletions":5,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ClassInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ClassInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ClassInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,17 +12,22 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * An instruction that takes as an argument a class to operate\n  * on. Examples include <code>anewarray, checkcast, instance, anew</code>, etc.\n- * \n+ *\n  * @author Abe White\n  */\n public class ClassInstruction extends TypedInstruction {\n+\n     private int _index = 0;\n \n     ClassInstruction(Code owner, int opcode) {\n@@ -54,7 +59,7 @@ public int getTypeIndex() {\n     /**\n      * Set the {@link ConstantPool} index of the\n      * {@link ClassEntry} describing the class for this instruction.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ClassInstruction setTypeIndex(int index) {"},{"sha":"936a8c00789dcdb92068f03580e6ec71e6c8e89b","filename":"serp/src/main/java/serp/bytecode/CmpInstruction.java","status":"modified","additions":67,"deletions":66,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/CmpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/CmpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CmpInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,16 +12,17 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * An instruction comparing two stack values. Examples include\n  * <code>lcmp, fcmpl</code>, etc.\n- * \n+ *\n  * @author Abe White\n  */\n public class CmpInstruction extends TypedInstruction {\n-    private static Class[][] _mappings = new Class[][] {\n+\n+    private static Class[][] _mappings = new Class[][]{\n         { int.class, long.class }, { byte.class, long.class },\n         { char.class, long.class }, { short.class, long.class },\n         { boolean.class, long.class }, { void.class, long.class },\n@@ -37,61 +38,61 @@\n \n     public int getLogicalStackChange() {\n         switch (getOpcode()) {\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -1;\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -1;\n         }\n     }\n \n     public int getStackChange() {\n         switch (getOpcode()) {\n-        case Constants.LCMP:\n-        case Constants.DCMPL:\n-        case Constants.DCMPG:\n-            return -3;\n-        case Constants.NOP:\n-            return 0;\n-        default:\n-            return -1;\n+            case Constants.LCMP:\n+            case Constants.DCMPL:\n+            case Constants.DCMPG:\n+                return -3;\n+            case Constants.NOP:\n+                return 0;\n+            default:\n+                return -1;\n         }\n     }\n \n     public String getTypeName() {\n         switch (getOpcode()) {\n-        case Constants.LCMP:\n-            return long.class.getName();\n-        case Constants.FCMPL:\n-        case Constants.FCMPG:\n-            return float.class.getName();\n-        case Constants.DCMPL:\n-        case Constants.DCMPG:\n-            return double.class.getName();\n-        default:\n-            return null;\n+            case Constants.LCMP:\n+                return long.class.getName();\n+            case Constants.FCMPL:\n+            case Constants.FCMPG:\n+                return float.class.getName();\n+            case Constants.DCMPL:\n+            case Constants.DCMPG:\n+                return double.class.getName();\n+            default:\n+                return null;\n         }\n     }\n \n     public TypedInstruction setType(String type) {\n         type = mapType(type, _mappings, true);\n \n         if (type == null)\n-            return(TypedInstruction) setOpcode(Constants.NOP);\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n \n         int opcode = getOpcode();\n         switch (type.charAt(0)) {\n-        case 'l':\n-            return(TypedInstruction) setOpcode(Constants.LCMP);\n-        case 'f':\n-            if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n-                return(TypedInstruction) setOpcode(Constants.FCMPL);\n-            return(TypedInstruction) setOpcode(Constants.FCMPG);\n-        case 'd':\n-            if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n-                return(TypedInstruction) setOpcode(Constants.DCMPL);\n-            return(TypedInstruction) setOpcode(Constants.DCMPG);\n-        default:\n-            throw new IllegalStateException();\n+            case 'l':\n+                return (TypedInstruction) setOpcode(Constants.LCMP);\n+            case 'f':\n+                if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n+                    return (TypedInstruction) setOpcode(Constants.FCMPL);\n+                return (TypedInstruction) setOpcode(Constants.FCMPG);\n+            case 'd':\n+                if (opcode == Constants.FCMPL || opcode == Constants.DCMPL)\n+                    return (TypedInstruction) setOpcode(Constants.DCMPL);\n+                return (TypedInstruction) setOpcode(Constants.DCMPG);\n+            default:\n+                throw new IllegalStateException();\n         }\n     }\n \n@@ -103,14 +104,14 @@ public TypedInstruction setType(String type) {\n      */\n     public int getNaNValue() {\n         switch (getOpcode()) {\n-        case Constants.FCMPL:\n-        case Constants.DCMPL:\n-            return -1;\n-        case Constants.FCMPG:\n-        case Constants.DCMPG:\n-            return 1;\n-        default:\n-            return 0;\n+            case Constants.FCMPL:\n+            case Constants.DCMPL:\n+                return -1;\n+            case Constants.FCMPG:\n+            case Constants.DCMPG:\n+                return 1;\n+            default:\n+                return 0;\n         }\n     }\n \n@@ -119,30 +120,30 @@ public int getNaNValue() {\n      * is of type float or double and one of the operands is NaN. For\n      * FCMPG or DCMPG, this value should be 1; for FCMPL or DCMPL this value\n      * should be -1. For LCMP, this value should be 0.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public CmpInstruction setNaNValue(int nan) {\n         switch (getOpcode()) {\n-        case Constants.FCMPL:\n-        case Constants.FCMPG:\n-            if (nan == 1)\n-                setOpcode(Constants.FCMPG);\n-            else if (nan == -1)\n-                setOpcode(Constants.FCMPL);\n-            else\n-                throw new IllegalArgumentException(\"Invalid nan for type\");\n-        case Constants.DCMPL:\n-        case Constants.DCMPG:\n-            if (nan == 1)\n-                setOpcode(Constants.DCMPG);\n-            else if (nan == -1)\n-                setOpcode(Constants.DCMPL);\n-            else\n-                throw new IllegalArgumentException(\"Invalid nan for type\");\n-        default:\n-            if (nan != 0)\n-                throw new IllegalArgumentException(\"Invalid nan for type\");\n+            case Constants.FCMPL:\n+            case Constants.FCMPG:\n+                if (nan == 1)\n+                    setOpcode(Constants.FCMPG);\n+                else if (nan == -1)\n+                    setOpcode(Constants.FCMPL);\n+                else\n+                    throw new IllegalArgumentException(\"Invalid nan for type\");\n+            case Constants.DCMPL:\n+            case Constants.DCMPG:\n+                if (nan == 1)\n+                    setOpcode(Constants.DCMPG);\n+                else if (nan == -1)\n+                    setOpcode(Constants.DCMPL);\n+                else\n+                    throw new IllegalArgumentException(\"Invalid nan for type\");\n+            default:\n+                if (nan != 0)\n+                    throw new IllegalArgumentException(\"Invalid nan for type\");\n         }\n         return this;\n     }"},{"sha":"a90029e2017fcaefb9d415f005609d799ad3e77a","filename":"serp/src/main/java/serp/bytecode/Code.java","status":"modified","additions":435,"deletions":417,"changes":852,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Code.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Code.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Code.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,21 +12,32 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Representation of a code block of a class.\n  * The methods of this class mimic those of the same name in the\n  * {@link java.util.ListIterator} class. Note that the size and index\n  * information of the code block will change as opcodes are added.\n- *  Code blocks are usually obtained from a {@link BCMethod}, but can also\n+ * Code blocks are usually obtained from a {@link BCMethod}, but can also\n  * be constructed via the default constructor. Blocks created this way can\n  * be used to provide template instructions to the various search/replace\n  * methods in this class.\n- *  The code class contains methods named after most JVM instructions, each\n+ * The code class contains methods named after most JVM instructions, each\n  * of which adds the matching opcode to the code block at the\n  * current iterator position. It also contains generic versions of various\n  * JVM instructions whose opcodes are not set until their properties are set\n@@ -35,10 +46,11 @@\n  * Thus the developer can initially call, for example, the <code>aload</code>\n  * opcode, but later change the type to load to <code>int</code> and the\n  * opcode will automatically morph to the <code>iload</code> opcode.\n- * \n+ *\n  * @author Abe White\n  */\n public class Code extends Attribute {\n+\n     private final CodeEntry _head;\n     private final CodeEntry _tail;\n     private CodeIterator _ci;\n@@ -74,7 +86,7 @@ public Code() {\n      * The owning method.\n      */\n     public BCMethod getMethod() {\n-        return(BCMethod) getOwner();\n+        return (BCMethod) getOwner();\n     }\n \n     Collection getAttributesHolder() {\n@@ -145,7 +157,7 @@ public int getLocalsIndex(int paramIndex) {\n     /**\n      * Return the parameter index for the given local index, or -1 if\n      * the given local does not reference a param.\n-     * \n+     *\n      * @see #getLocalsIndex\n      */\n     public int getParamsIndex(int localIndex) {\n@@ -177,7 +189,7 @@ public int getNextLocalsIndex() {\n      * Calculate and set the number of locals needed based on\n      * the instructions used and the parameters of the method this code\n      * block is a part of.\n-     * \n+     *\n      * @see #setMaxLocals\n      */\n     public void calculateMaxLocals() {\n@@ -218,7 +230,7 @@ else if (params.length > 0) {\n     /**\n      * Calculate and set the maximum stack depth needed for\n      * the instructions used.\n-     * \n+     *\n      * @see #setMaxStack\n      */\n     public void calculateMaxStack() {\n@@ -253,7 +265,7 @@ public void calculateMaxStack() {\n      * empty array if none.\n      */\n     public ExceptionHandler[] getExceptionHandlers() {\n-        return(ExceptionHandler[]) _handlers.toArray\n+        return (ExceptionHandler[]) _handlers.toArray\n             (new ExceptionHandler[_handlers.size()]);\n     }\n \n@@ -320,7 +332,7 @@ public ExceptionHandler getExceptionHandler(BCClass catchType) {\n                 matches.add(handlers[i]);\n         }\n \n-        return(ExceptionHandler[]) matches.toArray\n+        return (ExceptionHandler[]) matches.toArray\n             (new ExceptionHandler[matches.size()]);\n     }\n \n@@ -376,11 +388,11 @@ public ExceptionHandler addExceptionHandler() {\n \n     /**\n      * Add an exception handler to this code block.\n-     * \n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n+     *\n+     * @param tryStart     the first instruction of the try {} block\n+     * @param tryEnd       the last instruction of the try {} block\n      * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n+     * @param catchType    the type of exception being caught\n      */\n     public ExceptionHandler addExceptionHandler(Instruction tryStart,\n         Instruction tryEnd, Instruction handlerStart, String catchType) {\n@@ -394,11 +406,11 @@ public ExceptionHandler addExceptionHandler(Instruction tryStart,\n \n     /**\n      * Add an exception handler to this code block.\n-     * \n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n+     *\n+     * @param tryStart     the first instruction of the try {} block\n+     * @param tryEnd       the last instruction of the try {} block\n      * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n+     * @param catchType    the type of exception being caught\n      */\n     public ExceptionHandler addExceptionHandler(Instruction tryStart,\n         Instruction tryEnd, Instruction handlerStart, Class catchType) {\n@@ -410,11 +422,11 @@ public ExceptionHandler addExceptionHandler(Instruction tryStart,\n \n     /**\n      * Add an exception handler to this code block.\n-     * \n-     * @param tryStart the first instruction of the try {} block\n-     * @param tryEnd the last instruction of the try {} block\n+     *\n+     * @param tryStart     the first instruction of the try {} block\n+     * @param tryEnd       the last instruction of the try {} block\n      * @param handlerStart the first instruction of the catch {} block\n-     * @param catchType the type of exception being caught\n+     * @param catchType    the type of exception being caught\n      */\n     public ExceptionHandler addExceptionHandler(Instruction tryStart,\n         Instruction tryEnd, Instruction handlerStart, BCClass catchType) {\n@@ -445,7 +457,7 @@ public boolean removeExceptionHandler(String catchType) {\n \n     /**\n      * Remove the exception handler that catches the given type.\n-     * \n+     *\n      * @return true if the handler was removed, false otherwise\n      */\n     public boolean removeExceptionHandler(Class catchType) {\n@@ -456,7 +468,7 @@ public boolean removeExceptionHandler(Class catchType) {\n \n     /**\n      * Remove the exception handler that catches the given type.\n-     * \n+     *\n      * @return true if the handler was removed, false otherwise\n      */\n     public boolean removeExceptionHandler(BCClass catchType) {\n@@ -544,7 +556,7 @@ public boolean hasPrevious() {\n      * Return the next instruction.\n      */\n     public Instruction next() {\n-        return(Instruction) _ci.next();\n+        return (Instruction) _ci.next();\n     }\n \n     /**\n@@ -558,7 +570,7 @@ public int nextIndex() {\n      * Return the previous instruction.\n      */\n     public Instruction previous() {\n-        return(Instruction) _ci.previous();\n+        return (Instruction) _ci.previous();\n     }\n \n     /**\n@@ -576,7 +588,7 @@ public void before(int index) {\n             throw new IndexOutOfBoundsException(String.valueOf(index));\n \n         CodeEntry entry = _head;\n-        for (int i = 0; i < index; entry = entry.next, i++);\n+        for (int i = 0; i < index; entry = entry.next, i++) ;\n         _ci = new CodeIterator(entry, index - 1);\n     }\n \n@@ -597,7 +609,7 @@ public void after(int index) {\n      * in. If a match is found, the iterator is placed after the matching\n      * Instruction. If no match is found, moves the iterator to\n      * {@link #afterLast}.\n-     * \n+     *\n      * @return true if match found\n      */\n     public boolean searchForward(Instruction template) {\n@@ -618,7 +630,7 @@ public boolean searchForward(Instruction template) {\n      * instruction has not been filled in. If a match is found, the iterator\n      * is placed before the matching Instruction. If no match is found,\n      * moves the iterator to {@link #beforeFirst}.\n-     * \n+     *\n      * @return true if match found\n      */\n     public boolean searchBackward(Instruction template) {\n@@ -632,7 +644,7 @@ public boolean searchBackward(Instruction template) {\n \n     /**\n      * Adds a copy of the given instruction.\n-     * \n+     *\n      * @return the newly added instruction\n      */\n     public Instruction add(Instruction ins) {\n@@ -646,9 +658,8 @@ public Instruction add(Instruction ins) {\n      * Replaces the last iterated instruction with a copy of the given one.\n      * This method will also make sure that all jump points\n      * that referenced the old opcode are updated correctly.\n-     * \n+     *\n      * @return the newly added instruction\n-     * \n      * @see ListIterator#set\n      */\n     public Instruction set(Instruction ins) {\n@@ -662,7 +673,7 @@ public Instruction set(Instruction ins) {\n      * Replaces all the instructions in this code block that match the\n      * given template with the given instruction. After this method,\n      * the iterator will be {@link #afterLast}.\n-     * \n+     *\n      * @return the number of substitutions made\n      */\n     public int replace(Instruction template, Instruction with) {\n@@ -693,7 +704,7 @@ public int replace(Instruction[] templates, Instruction[] with) {\n \n     /**\n      * Remove the last iterated instruction.\n-     * \n+     *\n      * @see ListIterator#remove\n      */\n     public void remove() {\n@@ -733,7 +744,7 @@ public Instruction nop() {\n      * <code>lconst0</code>.\n      */\n     public ConstantInstruction constant() {\n-        return(ConstantInstruction) addInstruction\n+        return (ConstantInstruction) addInstruction\n             (new ConstantInstruction(this));\n     }\n \n@@ -742,15 +753,15 @@ public ConstantInstruction constant() {\n      * in a <code>nop</code> until its type and local index are set.\n      */\n     public LoadInstruction xload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this));\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this));\n     }\n \n     /**\n      * Load an int local variable onto the stack. This instruction will\n      * result in a <code>nop</code> until its local index is set.\n      */\n     public LoadInstruction iload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this).\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n             setType(int.class));\n     }\n \n@@ -759,7 +770,7 @@ public LoadInstruction iload() {\n      * result in a <code>nop</code> until its local index is set.\n      */\n     public LoadInstruction lload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this).\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n             setType(long.class));\n     }\n \n@@ -768,7 +779,7 @@ public LoadInstruction lload() {\n      * result in a <code>nop</code> until its local index is set.\n      */\n     public LoadInstruction fload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this).\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n             setType(float.class));\n     }\n \n@@ -777,7 +788,7 @@ public LoadInstruction fload() {\n      * result in a <code>nop</code> until its local index is set.\n      */\n     public LoadInstruction dload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this).\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n             setType(double.class));\n     }\n \n@@ -786,7 +797,7 @@ public LoadInstruction dload() {\n      * result in a <code>nop</code> until its local index is set.\n      */\n     public LoadInstruction aload() {\n-        return(LoadInstruction) addInstruction(new LoadInstruction(this).\n+        return (LoadInstruction) addInstruction(new LoadInstruction(this).\n             setType(Object.class));\n     }\n \n@@ -795,7 +806,7 @@ public LoadInstruction aload() {\n      * will result in a <code>nop</code> until its type and local index are set.\n      */\n     public StoreInstruction xstore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this));\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this));\n     }\n \n     /**\n@@ -804,7 +815,7 @@ public StoreInstruction xstore() {\n      * set.\n      */\n     public StoreInstruction istore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this).\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n             setType(int.class));\n     }\n \n@@ -814,7 +825,7 @@ public StoreInstruction istore() {\n      * set.\n      */\n     public StoreInstruction lstore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this).\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n             setType(long.class));\n     }\n \n@@ -824,7 +835,7 @@ public StoreInstruction lstore() {\n      * set.\n      */\n     public StoreInstruction fstore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this).\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n             setType(float.class));\n     }\n \n@@ -834,7 +845,7 @@ public StoreInstruction fstore() {\n      * set.\n      */\n     public StoreInstruction dstore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this).\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n             setType(double.class));\n     }\n \n@@ -844,7 +855,7 @@ public StoreInstruction dstore() {\n      * set.\n      */\n     public StoreInstruction astore() {\n-        return(StoreInstruction) addInstruction(new StoreInstruction(this).\n+        return (StoreInstruction) addInstruction(new StoreInstruction(this).\n             setType(Object.class));\n     }\n \n@@ -853,95 +864,95 @@ public StoreInstruction astore() {\n      * <code>finally</code> clauses.\n      */\n     public RetInstruction ret() {\n-        return(RetInstruction) addInstruction(Constants.RET);\n+        return (RetInstruction) addInstruction(Constants.RET);\n     }\n \n     /**\n      * Add the <code>iinc</code> opcode.\n      */\n     public IIncInstruction iinc() {\n-        return(IIncInstruction) addInstruction(Constants.IINC);\n+        return (IIncInstruction) addInstruction(Constants.IINC);\n     }\n \n     /**\n      * Add the <code>wide</code> opcode.\n      */\n     public WideInstruction wide() {\n-        return(WideInstruction) addInstruction(Constants.WIDE);\n+        return (WideInstruction) addInstruction(Constants.WIDE);\n     }\n \n     /**\n      * Load an array value onto the stack. This instruction will result\n      * in a <code>nop</code> until its type is set.\n      */\n     public ArrayLoadInstruction xaload() {\n-        return(ArrayLoadInstruction) addInstruction\n+        return (ArrayLoadInstruction) addInstruction\n             (new ArrayLoadInstruction(this));\n     }\n \n     /**\n      * Load an int array value onto the stack; the <code>iaload</code> opcode.\n      */\n     public ArrayLoadInstruction iaload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.IALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.IALOAD);\n     }\n \n     /**\n      * Load a long array value onto the stack; the <code>laload</code> opcode.\n      */\n     public ArrayLoadInstruction laload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.LALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.LALOAD);\n     }\n \n     /**\n      * Load a float array value onto the stack; the <code>faload</code> opcode.\n      */\n     public ArrayLoadInstruction faload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.FALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.FALOAD);\n     }\n \n     /**\n      * Load a double array value onto the stack; the <code>daload</code> opcode.\n      */\n     public ArrayLoadInstruction daload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.DALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.DALOAD);\n     }\n \n     /**\n      * Load an object array value onto the stack; the <code>aaload</code>\n      * opcode.\n      */\n     public ArrayLoadInstruction aaload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.AALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.AALOAD);\n     }\n \n     /**\n      * Load a byte array value onto the stack; the <code>baload</code> opcode.\n      */\n     public ArrayLoadInstruction baload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.BALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.BALOAD);\n     }\n \n     /**\n      * Load a char array value onto the stack; the <code>caload</code> opcode.\n      */\n     public ArrayLoadInstruction caload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.CALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.CALOAD);\n     }\n \n     /**\n      * Load a short array value onto the stack; the <code>saload</code> opcode.\n      */\n     public ArrayLoadInstruction saload() {\n-        return(ArrayLoadInstruction) addInstruction(Constants.SALOAD);\n+        return (ArrayLoadInstruction) addInstruction(Constants.SALOAD);\n     }\n \n     /**\n      * Store a value from the stack into an array. This instruction\n      * will result in a <code>nop</code> until its type is set.\n      */\n     public ArrayStoreInstruction xastore() {\n-        return(ArrayStoreInstruction) addInstruction\n+        return (ArrayStoreInstruction) addInstruction\n             (new ArrayStoreInstruction(this));\n     }\n \n@@ -950,134 +961,134 @@ public ArrayStoreInstruction xastore() {\n      * <code>iastore</code> opcode.\n      */\n     public ArrayStoreInstruction iastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.IASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.IASTORE);\n     }\n \n     /**\n      * Store a long value from the stack into an array; the\n      * <code>lastore</code> opcode.\n      */\n     public ArrayStoreInstruction lastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.LASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.LASTORE);\n     }\n \n     /**\n      * Store a float value from the stack into an array; the\n      * <code>fastore</code> opcode.\n      */\n     public ArrayStoreInstruction fastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.FASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.FASTORE);\n     }\n \n     /**\n      * Store a double value from the stack into an array; the\n      * <code>dastore</code> opcode.\n      */\n     public ArrayStoreInstruction dastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.DASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.DASTORE);\n     }\n \n     /**\n      * Store an object value from the stack into an array; the\n      * <code>aastore</code> opcode.\n      */\n     public ArrayStoreInstruction aastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.AASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.AASTORE);\n     }\n \n     /**\n      * Store a byte value from the stack into an array; the\n      * <code>bastore</code> opcode.\n      */\n     public ArrayStoreInstruction bastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.BASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.BASTORE);\n     }\n \n     /**\n      * Store a char value from the stack into an array; the\n      * <code>castore</code> opcode.\n      */\n     public ArrayStoreInstruction castore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.CASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.CASTORE);\n     }\n \n     /**\n      * Store a short value from the stack into an array; the\n      * <code>sastore</code> opcode.\n      */\n     public ArrayStoreInstruction sastore() {\n-        return(ArrayStoreInstruction) addInstruction(Constants.SASTORE);\n+        return (ArrayStoreInstruction) addInstruction(Constants.SASTORE);\n     }\n \n     /**\n      * The <code>pop</code> opcode.\n      */\n     public StackInstruction pop() {\n-        return(StackInstruction) addInstruction(Constants.POP);\n+        return (StackInstruction) addInstruction(Constants.POP);\n     }\n \n     /**\n      * The <code>pop2</code> opcode.\n      */\n     public StackInstruction pop2() {\n-        return(StackInstruction) addInstruction(Constants.POP2);\n+        return (StackInstruction) addInstruction(Constants.POP2);\n     }\n \n     /**\n      * The <code>dup</code> opcode.\n      */\n     public StackInstruction dup() {\n-        return(StackInstruction) addInstruction(Constants.DUP);\n+        return (StackInstruction) addInstruction(Constants.DUP);\n     }\n \n     /**\n      * The <code>dupx1</code> opcode.\n      */\n     public StackInstruction dupx1() {\n-        return(StackInstruction) addInstruction(Constants.DUPX1);\n+        return (StackInstruction) addInstruction(Constants.DUPX1);\n     }\n \n     /**\n      * The <code>dupx2</code> opcode.\n      */\n     public StackInstruction dupx2() {\n-        return(StackInstruction) addInstruction(Constants.DUPX2);\n+        return (StackInstruction) addInstruction(Constants.DUPX2);\n     }\n \n     /**\n      * The <code>dup2</code> opcode.\n      */\n     public StackInstruction dup2() {\n-        return(StackInstruction) addInstruction(Constants.DUP2);\n+        return (StackInstruction) addInstruction(Constants.DUP2);\n     }\n \n     /**\n      * The <code>dup2x1</code> opcode.\n      */\n     public StackInstruction dup2x1() {\n-        return(StackInstruction) addInstruction(Constants.DUP2X1);\n+        return (StackInstruction) addInstruction(Constants.DUP2X1);\n     }\n \n     /**\n      * The <code>dup2x2</code> opcode.\n      */\n     public StackInstruction dup2x2() {\n-        return(StackInstruction) addInstruction(Constants.DUP2X2);\n+        return (StackInstruction) addInstruction(Constants.DUP2X2);\n     }\n \n     /**\n      * The <code>swap</code> opcode.\n      */\n     public StackInstruction swap() {\n-        return(StackInstruction) addInstruction(Constants.SWAP);\n+        return (StackInstruction) addInstruction(Constants.SWAP);\n     }\n \n     /**\n      * Perform some math operation on the stack items. This instruction will\n      * result in a <code>nop</code> until its operation and type are set.\n      */\n     public MathInstruction math() {\n-        return(MathInstruction) addInstruction(new MathInstruction(this));\n+        return (MathInstruction) addInstruction(new MathInstruction(this));\n     }\n \n     /**\n@@ -1093,28 +1104,28 @@ public MathInstruction xadd() {\n      * Add the top two stack int values; the <code>iadd</code> opcode.\n      */\n     public MathInstruction iadd() {\n-        return(MathInstruction) addInstruction(Constants.IADD);\n+        return (MathInstruction) addInstruction(Constants.IADD);\n     }\n \n     /**\n      * Add the top two stack long values; the <code>ladd</code> opcode.\n      */\n     public MathInstruction ladd() {\n-        return(MathInstruction) addInstruction(Constants.LADD);\n+        return (MathInstruction) addInstruction(Constants.LADD);\n     }\n \n     /**\n      * Add the top two stack float values; the <code>fadd</code> opcode.\n      */\n     public MathInstruction fadd() {\n-        return(MathInstruction) addInstruction(Constants.FADD);\n+        return (MathInstruction) addInstruction(Constants.FADD);\n     }\n \n     /**\n      * Add the top two stack double values; the <code>dadd</code> opcode.\n      */\n     public MathInstruction dadd() {\n-        return(MathInstruction) addInstruction(Constants.DADD);\n+        return (MathInstruction) addInstruction(Constants.DADD);\n     }\n \n     /**\n@@ -1130,28 +1141,28 @@ public MathInstruction xsub() {\n      * Subtract the top two stack int values; the <code>isub</code> opcode.\n      */\n     public MathInstruction isub() {\n-        return(MathInstruction) addInstruction(Constants.ISUB);\n+        return (MathInstruction) addInstruction(Constants.ISUB);\n     }\n \n     /**\n      * Subtract the top two stack long values; the <code>lsub</code> opcode.\n      */\n     public MathInstruction lsub() {\n-        return(MathInstruction) addInstruction(Constants.LSUB);\n+        return (MathInstruction) addInstruction(Constants.LSUB);\n     }\n \n     /**\n      * Subtract the top two stack float values; the <code>fsub</code> opcode.\n      */\n     public MathInstruction fsub() {\n-        return(MathInstruction) addInstruction(Constants.FSUB);\n+        return (MathInstruction) addInstruction(Constants.FSUB);\n     }\n \n     /**\n      * Subtract the top two stack double values; the <code>dsub</code> opcode.\n      */\n     public MathInstruction dsub() {\n-        return(MathInstruction) addInstruction(Constants.DSUB);\n+        return (MathInstruction) addInstruction(Constants.DSUB);\n     }\n \n     /**\n@@ -1167,28 +1178,28 @@ public MathInstruction xmul() {\n      * Multiply the top two stack int values; the <code>imul</code> opcode.\n      */\n     public MathInstruction imul() {\n-        return(MathInstruction) addInstruction(Constants.IMUL);\n+        return (MathInstruction) addInstruction(Constants.IMUL);\n     }\n \n     /**\n      * Multiply the top two stack long values; the <code>lmul</code> opcode.\n      */\n     public MathInstruction lmul() {\n-        return(MathInstruction) addInstruction(Constants.LMUL);\n+        return (MathInstruction) addInstruction(Constants.LMUL);\n     }\n \n     /**\n      * Multiply the top two stack float values; the <code>fmul</code> opcode.\n      */\n     public MathInstruction fmul() {\n-        return(MathInstruction) addInstruction(Constants.FMUL);\n+        return (MathInstruction) addInstruction(Constants.FMUL);\n     }\n \n     /**\n      * Multiply the top two stack double values; the <code>dmul</code> opcode.\n      */\n     public MathInstruction dmul() {\n-        return(MathInstruction) addInstruction(Constants.DMUL);\n+        return (MathInstruction) addInstruction(Constants.DMUL);\n     }\n \n     /**\n@@ -1204,28 +1215,28 @@ public MathInstruction xdiv() {\n      * Divide the top two stack int values; the <code>idiv</code> opcode.\n      */\n     public MathInstruction idiv() {\n-        return(MathInstruction) addInstruction(Constants.IDIV);\n+        return (MathInstruction) addInstruction(Constants.IDIV);\n     }\n \n     /**\n      * Divide the top two stack long values; the <code>ldiv</code> opcode.\n      */\n     public MathInstruction ldiv() {\n-        return(MathInstruction) addInstruction(Constants.LDIV);\n+        return (MathInstruction) addInstruction(Constants.LDIV);\n     }\n \n     /**\n      * Divide the top two stack float values; the <code>fdiv</code> opcode.\n      */\n     public MathInstruction fdiv() {\n-        return(MathInstruction) addInstruction(Constants.FDIV);\n+        return (MathInstruction) addInstruction(Constants.FDIV);\n     }\n \n     /**\n      * Divide the top two stack double values; the <code>ddiv</code> opcode.\n      */\n     public MathInstruction ddiv() {\n-        return(MathInstruction) addInstruction(Constants.DDIV);\n+        return (MathInstruction) addInstruction(Constants.DDIV);\n     }\n \n     /**\n@@ -1242,31 +1253,31 @@ public MathInstruction xrem() {\n      * <code>irem</code> opcode.\n      */\n     public MathInstruction irem() {\n-        return(MathInstruction) addInstruction(Constants.IREM);\n+        return (MathInstruction) addInstruction(Constants.IREM);\n     }\n \n     /**\n      * Take the remainder of the top two long stack values; the\n      * <code>lrem</code> opcode.\n      */\n     public MathInstruction lrem() {\n-        return(MathInstruction) addInstruction(Constants.LREM);\n+        return (MathInstruction) addInstruction(Constants.LREM);\n     }\n \n     /**\n      * Take the remainder of the top two float stack values; the\n      * <code>frem</code> opcode.\n      */\n     public MathInstruction frem() {\n-        return(MathInstruction) addInstruction(Constants.FREM);\n+        return (MathInstruction) addInstruction(Constants.FREM);\n     }\n \n     /**\n      * Take the remainder of the top two double stack values; the\n      * <code>drem</code> opcode.\n      */\n     public MathInstruction drem() {\n-        return(MathInstruction) addInstruction(Constants.DREM);\n+        return (MathInstruction) addInstruction(Constants.DREM);\n     }\n \n     /**\n@@ -1282,28 +1293,28 @@ public MathInstruction xneg() {\n      * Negate the top stack int value; the <code>ineg</code> opcode.\n      */\n     public MathInstruction ineg() {\n-        return(MathInstruction) addInstruction(Constants.INEG);\n+        return (MathInstruction) addInstruction(Constants.INEG);\n     }\n \n     /**\n      * Negate the top stack long value; the <code>lneg</code> opcode.\n      */\n     public MathInstruction lneg() {\n-        return(MathInstruction) addInstruction(Constants.LNEG);\n+        return (MathInstruction) addInstruction(Constants.LNEG);\n     }\n \n     /**\n      * Negate the top stack float value; the <code>fneg</code> opcode.\n      */\n     public MathInstruction fneg() {\n-        return(MathInstruction) addInstruction(Constants.FNEG);\n+        return (MathInstruction) addInstruction(Constants.FNEG);\n     }\n \n     /**\n      * Negate the top stack double value; the <code>dneg</code> opcode.\n      */\n     public MathInstruction dneg() {\n-        return(MathInstruction) addInstruction(Constants.DNEG);\n+        return (MathInstruction) addInstruction(Constants.DNEG);\n     }\n \n     /**\n@@ -1319,14 +1330,14 @@ public MathInstruction xshl() {\n      * Shift the top stack int values; the <code>ishl</code> opcode.\n      */\n     public MathInstruction ishl() {\n-        return(MathInstruction) addInstruction(Constants.ISHL);\n+        return (MathInstruction) addInstruction(Constants.ISHL);\n     }\n \n     /**\n      * Shift the top stack long values; the <code>lshl</code> opcode.\n      */\n     public MathInstruction lshl() {\n-        return(MathInstruction) addInstruction(Constants.LSHL);\n+        return (MathInstruction) addInstruction(Constants.LSHL);\n     }\n \n     /**\n@@ -1342,14 +1353,14 @@ public MathInstruction xshr() {\n      * Shift the top stack int values; the <code>ishr</code> opcode.\n      */\n     public MathInstruction ishr() {\n-        return(MathInstruction) addInstruction(Constants.ISHR);\n+        return (MathInstruction) addInstruction(Constants.ISHR);\n     }\n \n     /**\n      * Shift the top stack long values; the <code>lshr</code> opcode.\n      */\n     public MathInstruction lshr() {\n-        return(MathInstruction) addInstruction(Constants.LSHR);\n+        return (MathInstruction) addInstruction(Constants.LSHR);\n     }\n \n     /**\n@@ -1365,14 +1376,14 @@ public MathInstruction xushr() {\n      * Shift the top stack int values; the <code>iushr</code> opcode.\n      */\n     public MathInstruction iushr() {\n-        return(MathInstruction) addInstruction(Constants.IUSHR);\n+        return (MathInstruction) addInstruction(Constants.IUSHR);\n     }\n \n     /**\n      * Shift the top stack long values; the <code>lushr</code> opcode.\n      */\n     public MathInstruction lushr() {\n-        return(MathInstruction) addInstruction(Constants.LUSHR);\n+        return (MathInstruction) addInstruction(Constants.LUSHR);\n     }\n \n     /**\n@@ -1389,15 +1400,15 @@ public MathInstruction xand() {\n      * <code>iand</code> opcode.\n      */\n     public MathInstruction iand() {\n-        return(MathInstruction) addInstruction(Constants.IAND);\n+        return (MathInstruction) addInstruction(Constants.IAND);\n     }\n \n     /**\n      * Take the mathematical and of the top two stack long values; the\n      * <code>land</code> opcode.\n      */\n     public MathInstruction land() {\n-        return(MathInstruction) addInstruction(Constants.LAND);\n+        return (MathInstruction) addInstruction(Constants.LAND);\n     }\n \n     /**\n@@ -1414,15 +1425,15 @@ public MathInstruction xor() {\n      * <code>ior</code> opcode.\n      */\n     public MathInstruction ior() {\n-        return(MathInstruction) addInstruction(Constants.IOR);\n+        return (MathInstruction) addInstruction(Constants.IOR);\n     }\n \n     /**\n      * Take the mathematical or of the top two stack long values; the\n      * <code>lor</code> opcode.\n      */\n     public MathInstruction lor() {\n-        return(MathInstruction) addInstruction(Constants.LOR);\n+        return (MathInstruction) addInstruction(Constants.LOR);\n     }\n \n     /**\n@@ -1439,15 +1450,15 @@ public MathInstruction xxor() {\n      * <code>ixor</code> opcode.\n      */\n     public MathInstruction ixor() {\n-        return(MathInstruction) addInstruction(Constants.IXOR);\n+        return (MathInstruction) addInstruction(Constants.IXOR);\n     }\n \n     /**\n      * Take the mathematical xor of the top two stack long values; the\n      * <code>lxor</code> opcode.\n      */\n     public MathInstruction lxor() {\n-        return(MathInstruction) addInstruction(Constants.LXOR);\n+        return (MathInstruction) addInstruction(Constants.LXOR);\n     }\n \n     /**\n@@ -1456,7 +1467,7 @@ public MathInstruction lxor() {\n      * between are set.\n      */\n     public ConvertInstruction convert() {\n-        return(ConvertInstruction) addInstruction\n+        return (ConvertInstruction) addInstruction\n             (new ConvertInstruction(this));\n     }\n \n@@ -1465,340 +1476,340 @@ public ConvertInstruction convert() {\n      * <code>nop</code> until its type is set.\n      */\n     public CmpInstruction xcmp() {\n-        return(CmpInstruction) addInstruction(new CmpInstruction(this));\n+        return (CmpInstruction) addInstruction(new CmpInstruction(this));\n     }\n \n     /**\n      * Compare the top two stack values; the <code>lcmp</code> opcode.\n      */\n     public CmpInstruction lcmp() {\n-        return(CmpInstruction) addInstruction(Constants.LCMP);\n+        return (CmpInstruction) addInstruction(Constants.LCMP);\n     }\n \n     /**\n      * Compare the top two stack values; the <code>fcmpl</code> opcode.\n      */\n     public CmpInstruction fcmpl() {\n-        return(CmpInstruction) addInstruction(Constants.FCMPL);\n+        return (CmpInstruction) addInstruction(Constants.FCMPL);\n     }\n \n     /**\n      * Compare the top two stack values; the <code>fcmpg</code> opcode.\n      */\n     public CmpInstruction fcmpg() {\n-        return(CmpInstruction) addInstruction(Constants.FCMPG);\n+        return (CmpInstruction) addInstruction(Constants.FCMPG);\n     }\n \n     /**\n      * Compare the top two stack values; the <code>dcmpl</code> opcode.\n      */\n     public CmpInstruction dcmpl() {\n-        return(CmpInstruction) addInstruction(Constants.DCMPL);\n+        return (CmpInstruction) addInstruction(Constants.DCMPL);\n     }\n \n     /**\n      * Compare the top two stack values; the <code>dcmpg</code> opcode.\n      */\n     public CmpInstruction dcmpg() {\n-        return(CmpInstruction) addInstruction(Constants.DCMPG);\n+        return (CmpInstruction) addInstruction(Constants.DCMPG);\n     }\n \n     /**\n      * The <code>ifeq</code> opcode.\n      */\n     public IfInstruction ifeq() {\n-        return(IfInstruction) addInstruction(Constants.IFEQ);\n+        return (IfInstruction) addInstruction(Constants.IFEQ);\n     }\n \n     /**\n      * The <code>ifne</code> opcode.\n      */\n     public IfInstruction ifne() {\n-        return(IfInstruction) addInstruction(Constants.IFNE);\n+        return (IfInstruction) addInstruction(Constants.IFNE);\n     }\n \n     /**\n      * The <code>iflt</code> opcode.\n      */\n     public IfInstruction iflt() {\n-        return(IfInstruction) addInstruction(Constants.IFLT);\n+        return (IfInstruction) addInstruction(Constants.IFLT);\n     }\n \n     /**\n      * The <code>ifge</code> opcode.\n      */\n     public IfInstruction ifge() {\n-        return(IfInstruction) addInstruction(Constants.IFGE);\n+        return (IfInstruction) addInstruction(Constants.IFGE);\n     }\n \n     /**\n      * The <code>ifgt</code> opcode.\n      */\n     public IfInstruction ifgt() {\n-        return(IfInstruction) addInstruction(Constants.IFGT);\n+        return (IfInstruction) addInstruction(Constants.IFGT);\n     }\n \n     /**\n      * The <code>ifle</code> opcode.\n      */\n     public IfInstruction ifle() {\n-        return(IfInstruction) addInstruction(Constants.IFLE);\n+        return (IfInstruction) addInstruction(Constants.IFLE);\n     }\n \n     /**\n      * The <code>ificmpeq</code> opcode.\n      */\n     public IfInstruction ificmpeq() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPEQ);\n+        return (IfInstruction) addInstruction(Constants.IFICMPEQ);\n     }\n \n     /**\n      * The <code>ificmpne</code> opcode.\n      */\n     public IfInstruction ificmpne() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPNE);\n+        return (IfInstruction) addInstruction(Constants.IFICMPNE);\n     }\n \n     /**\n      * The <code>ificmplt</code> opcode.\n      */\n     public IfInstruction ificmplt() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPLT);\n+        return (IfInstruction) addInstruction(Constants.IFICMPLT);\n     }\n \n     /**\n      * The <code>ificmpge</code> opcode.\n      */\n     public IfInstruction ificmpge() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPGE);\n+        return (IfInstruction) addInstruction(Constants.IFICMPGE);\n     }\n \n     /**\n      * The <code>ificmpgt</code> opcode.\n      */\n     public IfInstruction ificmpgt() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPGT);\n+        return (IfInstruction) addInstruction(Constants.IFICMPGT);\n     }\n \n     /**\n      * The <code>ificmple</code> opcode.\n      */\n     public IfInstruction ificmple() {\n-        return(IfInstruction) addInstruction(Constants.IFICMPLE);\n+        return (IfInstruction) addInstruction(Constants.IFICMPLE);\n     }\n \n     /**\n      * The <code>ifacmpeq</code> opcode.\n      */\n     public IfInstruction ifacmpeq() {\n-        return(IfInstruction) addInstruction(Constants.IFACMPEQ);\n+        return (IfInstruction) addInstruction(Constants.IFACMPEQ);\n     }\n \n     /**\n      * The <code>ifacmpne</code> opcode.\n      */\n     public IfInstruction ifacmpne() {\n-        return(IfInstruction) addInstruction(Constants.IFACMPNE);\n+        return (IfInstruction) addInstruction(Constants.IFACMPNE);\n     }\n \n     /**\n      * The <code>ifnull</code> opcode.\n      */\n     public IfInstruction ifnull() {\n-        return(IfInstruction) addInstruction(Constants.IFNULL);\n+        return (IfInstruction) addInstruction(Constants.IFNULL);\n     }\n \n     /**\n      * The <code>ifnonnull</code> opcode.\n      */\n     public IfInstruction ifnonnull() {\n-        return(IfInstruction) addInstruction(Constants.IFNONNULL);\n+        return (IfInstruction) addInstruction(Constants.IFNONNULL);\n     }\n \n     /**\n      * The <code>go2</code> opcode.\n      */\n     public JumpInstruction go2() {\n-        return(JumpInstruction) addInstruction(Constants.GOTO);\n+        return (JumpInstruction) addInstruction(Constants.GOTO);\n     }\n \n     /**\n      * The <code>jsr</code> opcode used in implementing <code>finally</code>\n      * clauses.\n      */\n     public JumpInstruction jsr() {\n-        return(JumpInstruction) addInstruction(Constants.JSR);\n+        return (JumpInstruction) addInstruction(Constants.JSR);\n     }\n \n     /**\n      * The <code>tableswitch</code> opcode.\n      */\n     public TableSwitchInstruction tableswitch() {\n-        return(TableSwitchInstruction) addInstruction(Constants.TABLESWITCH);\n+        return (TableSwitchInstruction) addInstruction(Constants.TABLESWITCH);\n     }\n \n     /**\n      * The <code>lookupswitch</code> opcode.\n      */\n     public LookupSwitchInstruction lookupswitch() {\n-        return(LookupSwitchInstruction) addInstruction(Constants.LOOKUPSWITCH);\n+        return (LookupSwitchInstruction) addInstruction(Constants.LOOKUPSWITCH);\n     }\n \n     /**\n      * Return from a method. This method will result in a\n      * <code>nop</code> until its type is set.\n      */\n     public ReturnInstruction xreturn() {\n-        return(ReturnInstruction) addInstruction (new ReturnInstruction(this));\n+        return (ReturnInstruction) addInstruction(new ReturnInstruction(this));\n     }\n \n     /**\n      * Return void from a method; the <code>return</code> opcode.\n      */\n     public ReturnInstruction vreturn() {\n-        return(ReturnInstruction) addInstruction(Constants.RETURN);\n+        return (ReturnInstruction) addInstruction(Constants.RETURN);\n     }\n \n     /**\n      * Return an int from a method; the <code>ireturn</code> opcode.\n      */\n     public ReturnInstruction ireturn() {\n-        return(ReturnInstruction) addInstruction(Constants.IRETURN);\n+        return (ReturnInstruction) addInstruction(Constants.IRETURN);\n     }\n \n     /**\n      * Return a long from a method; the <code>lreturn</code> opcode.\n      */\n     public ReturnInstruction lreturn() {\n-        return(ReturnInstruction) addInstruction(Constants.LRETURN);\n+        return (ReturnInstruction) addInstruction(Constants.LRETURN);\n     }\n \n     /**\n      * Return a float from a method; the <code>freturn</code> opcode.\n      */\n     public ReturnInstruction freturn() {\n-        return(ReturnInstruction) addInstruction(Constants.FRETURN);\n+        return (ReturnInstruction) addInstruction(Constants.FRETURN);\n     }\n \n     /**\n      * Return a double from a method; the <code>dreturn</code> opcode.\n      */\n     public ReturnInstruction dreturn() {\n-        return(ReturnInstruction) addInstruction(Constants.DRETURN);\n+        return (ReturnInstruction) addInstruction(Constants.DRETURN);\n     }\n \n     /**\n      * Return an object from a method; the <code>areturn</code> opcode.\n      */\n     public ReturnInstruction areturn() {\n-        return(ReturnInstruction) addInstruction(Constants.ARETURN);\n+        return (ReturnInstruction) addInstruction(Constants.ARETURN);\n     }\n \n     /**\n      * Load the value from a field onto the stack; the <code>getfield</code>\n      * opcode.\n      */\n     public GetFieldInstruction getfield() {\n-        return(GetFieldInstruction) addInstruction(Constants.GETFIELD);\n+        return (GetFieldInstruction) addInstruction(Constants.GETFIELD);\n     }\n \n     /**\n      * Load the value from a static field onto the stack; the\n      * <code>getstatic</code> opcode.\n      */\n     public GetFieldInstruction getstatic() {\n-        return(GetFieldInstruction) addInstruction(Constants.GETSTATIC);\n+        return (GetFieldInstruction) addInstruction(Constants.GETSTATIC);\n     }\n \n     /**\n      * Place the value of a field onto the stack; the <code>putfield</code>\n      * opcode.\n      */\n     public PutFieldInstruction putfield() {\n-        return(PutFieldInstruction) addInstruction(Constants.PUTFIELD);\n+        return (PutFieldInstruction) addInstruction(Constants.PUTFIELD);\n     }\n \n     /**\n      * Place the value of a static field onto the stack; the\n      * <code>putstatic</code> opcode.\n      */\n     public PutFieldInstruction putstatic() {\n-        return(PutFieldInstruction) addInstruction(Constants.PUTSTATIC);\n+        return (PutFieldInstruction) addInstruction(Constants.PUTSTATIC);\n     }\n \n     /**\n      * Invoke a virtual method; the <code>invokevirtual</code> opcode.\n      */\n     public MethodInstruction invokevirtual() {\n-        return(MethodInstruction) addInstruction(Constants.INVOKEVIRTUAL);\n+        return (MethodInstruction) addInstruction(Constants.INVOKEVIRTUAL);\n     }\n \n     /**\n      * Invoke a method non-virtually, as for constructors and superclass\n      * methods; the <code>invokespecial</code> opcode.\n      */\n     public MethodInstruction invokespecial() {\n-        return(MethodInstruction) addInstruction(Constants.INVOKESPECIAL);\n+        return (MethodInstruction) addInstruction(Constants.INVOKESPECIAL);\n     }\n \n     /**\n      * Invoke a method on an interface; the <code>invokeinterface</code> opcode.\n      */\n     public MethodInstruction invokeinterface() {\n-        return(MethodInstruction) addInstruction(Constants.INVOKEINTERFACE);\n+        return (MethodInstruction) addInstruction(Constants.INVOKEINTERFACE);\n     }\n \n     /**\n      * Invoke a static method; the <code>invokestatic</code> opcode.\n      */\n     public MethodInstruction invokestatic() {\n-        return(MethodInstruction) addInstruction(Constants.INVOKESTATIC);\n+        return (MethodInstruction) addInstruction(Constants.INVOKESTATIC);\n     }\n \n     /**\n      * Create a new instance of an object; the <code>new</code> opcode.\n      */\n     public ClassInstruction anew() {\n-        return(ClassInstruction) addInstruction(Constants.NEW);\n+        return (ClassInstruction) addInstruction(Constants.NEW);\n     }\n \n     /**\n      * Create a new instance of an object array; the <code>anew</code> opcode.\n      */\n     public ClassInstruction anewarray() {\n-        return(ClassInstruction) addInstruction(Constants.ANEWARRAY);\n+        return (ClassInstruction) addInstruction(Constants.ANEWARRAY);\n     }\n \n     /**\n      * Cast an object on the stack to another type; the <code>checkcast</code>\n      * opcode.\n      */\n     public ClassInstruction checkcast() {\n-        return(ClassInstruction) addInstruction(Constants.CHECKCAST);\n+        return (ClassInstruction) addInstruction(Constants.CHECKCAST);\n     }\n \n     /**\n      * Test if a stack object is an instance of a class; the\n      * <code>instanceof</code> opcode.\n      */\n     public ClassInstruction isinstance() {\n-        return(ClassInstruction) addInstruction(Constants.INSTANCEOF);\n+        return (ClassInstruction) addInstruction(Constants.INSTANCEOF);\n     }\n \n     /**\n      * Create a new multidimensional array; the <code>multianewarray</code>\n      * opcode.\n      */\n     public MultiANewArrayInstruction multianewarray() {\n-        return(MultiANewArrayInstruction) addInstruction\n+        return (MultiANewArrayInstruction) addInstruction\n             (Constants.MULTIANEWARRAY);\n     }\n \n     /**\n      * Create a new array of a primitive type; the <code>newarray</code> opcode.\n      */\n     public NewArrayInstruction newarray() {\n-        return(NewArrayInstruction) addInstruction(Constants.NEWARRAY);\n+        return (NewArrayInstruction) addInstruction(Constants.NEWARRAY);\n     }\n \n     /**\n@@ -1820,14 +1831,14 @@ public Instruction athrow() {\n      * The <code>monitorenter</code> opcode.\n      */\n     public MonitorEnterInstruction monitorenter() {\n-        return(MonitorEnterInstruction) addInstruction(Constants.MONITORENTER);\n+        return (MonitorEnterInstruction) addInstruction(Constants.MONITORENTER);\n     }\n \n     /**\n      * The <code>monitorexit</code> opcode.\n      */\n     public MonitorExitInstruction monitorexit() {\n-        return(MonitorExitInstruction) addInstruction(Constants.MONITOREXIT);\n+        return (MonitorExitInstruction) addInstruction(Constants.MONITOREXIT);\n     }\n \n     /////////////////////////\n@@ -1891,25 +1902,25 @@ public void acceptVisit(BCVisitor visit) {\n     /**\n      * Return line number information for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new line number table will be added\n-     * if not already present\n+     *            if not already present\n      * @return the line number information, or null if none\n-     * and the <code>add</code> param is set to false\n+     *         and the <code>add</code> param is set to false\n      */\n     public LineNumberTable getLineNumberTable(boolean add) {\n         LineNumberTable attr = (LineNumberTable) getAttribute\n             (Constants.ATTR_LINENUMBERS);\n         if (!add || attr != null)\n             return attr;\n \n-        return(LineNumberTable) addAttribute(Constants.ATTR_LINENUMBERS);\n+        return (LineNumberTable) addAttribute(Constants.ATTR_LINENUMBERS);\n     }\n \n     /**\n      * Remove the line number table for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a table to remove\n      */\n     public boolean removeLineNumberTable() {\n@@ -1919,25 +1930,25 @@ public boolean removeLineNumberTable() {\n     /**\n      * Return local variable information for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new local variable table will be\n-     * added if not already present\n+     *            added if not already present\n      * @return the local variable information, or null if none\n-     * and the <code>add</code> param is set to false\n+     *         and the <code>add</code> param is set to false\n      */\n     public LocalVariableTable getLocalVariableTable(boolean add) {\n         LocalVariableTable attr = (LocalVariableTable) getAttribute\n             (Constants.ATTR_LOCALS);\n         if (!add || attr != null)\n             return attr;\n \n-        return(LocalVariableTable) addAttribute(Constants.ATTR_LOCALS);\n+        return (LocalVariableTable) addAttribute(Constants.ATTR_LOCALS);\n     }\n \n     /**\n      * Remove the local variable table for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a table to remove\n      */\n     public boolean removeLocalVariableTables() {\n@@ -1947,26 +1958,26 @@ public boolean removeLocalVariableTables() {\n     /**\n      * Return local variable generics information for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @param add if true, a new local variable type table will be\n-     * added if not already present\n+     *            added if not already present\n      * @return the local variable type information, or null if none\n-     * and the <code>add</code> param is set to false\n+     *         and the <code>add</code> param is set to false\n      */\n     public LocalVariableTypeTable getLocalVariableTypeTable(boolean add) {\n         LocalVariableTypeTable attr = (LocalVariableTypeTable) getAttribute\n             (Constants.ATTR_LOCAL_TYPES);\n         if (!add || attr != null)\n             return attr;\n \n-        return(LocalVariableTypeTable) addAttribute\n+        return (LocalVariableTypeTable) addAttribute\n             (Constants.ATTR_LOCAL_TYPES);\n     }\n \n     /**\n      * Remove the local variable type table for the code.\n      * Acts internally through the {@link Attributes} interface.\n-     * \n+     *\n      * @return true if there was a table to remove\n      */\n     public boolean removeLocalVariableTypeTables() {\n@@ -2138,7 +2149,7 @@ Instruction getInstruction(int byteIndex) {\n         int curIndex = 0;\n         for (CodeEntry entry = _head.next; entry != _tail; entry = entry.next) {\n             if (byteIndex == curIndex)\n-                return(Instruction) entry;\n+                return (Instruction) entry;\n             curIndex += ((Instruction) entry).getLength();\n         }\n         throw new IllegalArgumentException(String.valueOf(byteIndex));\n@@ -2147,9 +2158,9 @@ Instruction getInstruction(int byteIndex) {\n     /**\n      * Returns the number of instructions that occur before 'ins'\n      * in this code block that 'ins' is a part of.\n-     * \n+     *\n      * @throws IllegalArgumentException if this code block is not the owner\n-     * of ins\n+     *                                  of ins\n      */\n     private int indexOf(Instruction ins) {\n         int i = 0;\n@@ -2177,7 +2188,10 @@ private void writeCode(DataOutput out) throws IOException {\n             return byteStream.toByteArray();\n         }\n         finally {\n-            try { stream.close(); } catch (Exception e) {}\n+            try {\n+                stream.close();\n+            } catch (Exception e) {\n+            }\n         }\n     }\n \n@@ -2193,7 +2207,10 @@ private void fromByteArray(byte[] code) throws IOException {\n                 readCode(stream, code.length);\n             }\n             finally {\n-                try { stream.close(); } catch (Exception e) {}\n+                try {\n+                    stream.close();\n+                } catch (Exception e) {\n+                }\n             }\n         }\n     }\n@@ -2213,235 +2230,235 @@ private Instruction addInstruction(int opcode) {\n      */\n     private Instruction createInstruction(int opcode) {\n         switch (opcode) {\n-        case Constants.NOP:\n-        case Constants.ARRAYLENGTH:\n-        case Constants.ATHROW:\n-            return new Instruction(this, opcode);\n-        case Constants.ACONSTNULL:\n-        case Constants.ICONSTM1:\n-        case Constants.ICONST0:\n-        case Constants.ICONST1:\n-        case Constants.ICONST2:\n-        case Constants.ICONST3:\n-        case Constants.ICONST4:\n-        case Constants.ICONST5:\n-        case Constants.LCONST0:\n-        case Constants.LCONST1:\n-        case Constants.FCONST0:\n-        case Constants.FCONST1:\n-        case Constants.FCONST2:\n-        case Constants.DCONST0:\n-        case Constants.DCONST1:\n-        case Constants.BIPUSH:\n-        case Constants.SIPUSH:\n-        case Constants.LDC:\n-        case Constants.LDCW:\n-        case Constants.LDC2W:\n-            return new ConstantInstruction(this, opcode);\n-        case Constants.ILOAD:\n-        case Constants.LLOAD:\n-        case Constants.FLOAD:\n-        case Constants.DLOAD:\n-        case Constants.ALOAD:\n-        case Constants.ILOAD0:\n-        case Constants.ILOAD1:\n-        case Constants.ILOAD2:\n-        case Constants.ILOAD3:\n-        case Constants.LLOAD0:\n-        case Constants.LLOAD1:\n-        case Constants.LLOAD2:\n-        case Constants.LLOAD3:\n-        case Constants.FLOAD0:\n-        case Constants.FLOAD1:\n-        case Constants.FLOAD2:\n-        case Constants.FLOAD3:\n-        case Constants.DLOAD0:\n-        case Constants.DLOAD1:\n-        case Constants.DLOAD2:\n-        case Constants.DLOAD3:\n-        case Constants.ALOAD0:\n-        case Constants.ALOAD1:\n-        case Constants.ALOAD2:\n-        case Constants.ALOAD3:\n-            return new LoadInstruction(this, opcode);\n-        case Constants.IALOAD:\n-        case Constants.LALOAD:\n-        case Constants.FALOAD:\n-        case Constants.DALOAD:\n-        case Constants.AALOAD:\n-        case Constants.BALOAD:\n-        case Constants.CALOAD:\n-        case Constants.SALOAD:\n-            return new ArrayLoadInstruction(this, opcode);\n-        case Constants.ISTORE:\n-        case Constants.LSTORE:\n-        case Constants.FSTORE:\n-        case Constants.DSTORE:\n-        case Constants.ASTORE:\n-        case Constants.ISTORE0:\n-        case Constants.ISTORE1:\n-        case Constants.ISTORE2:\n-        case Constants.ISTORE3:\n-        case Constants.LSTORE0:\n-        case Constants.LSTORE1:\n-        case Constants.LSTORE2:\n-        case Constants.LSTORE3:\n-        case Constants.FSTORE0:\n-        case Constants.FSTORE1:\n-        case Constants.FSTORE2:\n-        case Constants.FSTORE3:\n-        case Constants.DSTORE0:\n-        case Constants.DSTORE1:\n-        case Constants.DSTORE2:\n-        case Constants.DSTORE3:\n-        case Constants.ASTORE0:\n-        case Constants.ASTORE1:\n-        case Constants.ASTORE2:\n-        case Constants.ASTORE3:\n-            return new StoreInstruction(this, opcode);\n-        case Constants.IASTORE:\n-        case Constants.LASTORE:\n-        case Constants.FASTORE:\n-        case Constants.DASTORE:\n-        case Constants.AASTORE:\n-        case Constants.BASTORE:\n-        case Constants.CASTORE:\n-        case Constants.SASTORE:\n-            return new ArrayStoreInstruction(this, opcode);\n-        case Constants.POP:\n-        case Constants.POP2:\n-        case Constants.DUP:\n-        case Constants.DUPX1:\n-        case Constants.DUPX2:\n-        case Constants.DUP2:\n-        case Constants.DUP2X1:\n-        case Constants.DUP2X2:\n-        case Constants.SWAP:\n-            return new StackInstruction(this, opcode);\n-        case Constants.IADD:\n-        case Constants.LADD:\n-        case Constants.FADD:\n-        case Constants.DADD:\n-        case Constants.ISUB:\n-        case Constants.LSUB:\n-        case Constants.FSUB:\n-        case Constants.DSUB:\n-        case Constants.IMUL:\n-        case Constants.LMUL:\n-        case Constants.FMUL:\n-        case Constants.DMUL:\n-        case Constants.IDIV:\n-        case Constants.LDIV:\n-        case Constants.FDIV:\n-        case Constants.DDIV:\n-        case Constants.IREM:\n-        case Constants.LREM:\n-        case Constants.FREM:\n-        case Constants.DREM:\n-        case Constants.INEG:\n-        case Constants.LNEG:\n-        case Constants.FNEG:\n-        case Constants.DNEG:\n-        case Constants.ISHL:\n-        case Constants.LSHL:\n-        case Constants.ISHR:\n-        case Constants.LSHR:\n-        case Constants.IUSHR:\n-        case Constants.LUSHR:\n-        case Constants.IAND:\n-        case Constants.LAND:\n-        case Constants.IOR:\n-        case Constants.LOR:\n-        case Constants.IXOR:\n-        case Constants.LXOR:\n-            return new MathInstruction(this, opcode);\n-        case Constants.IINC:\n-            return new IIncInstruction(this);\n-        case Constants.I2L:\n-        case Constants.I2F:\n-        case Constants.I2D:\n-        case Constants.L2I:\n-        case Constants.L2F:\n-        case Constants.L2D:\n-        case Constants.F2I:\n-        case Constants.F2L:\n-        case Constants.F2D:\n-        case Constants.D2I:\n-        case Constants.D2L:\n-        case Constants.D2F:\n-        case Constants.I2B:\n-        case Constants.I2C:\n-        case Constants.I2S:\n-            return new ConvertInstruction(this, opcode);\n-        case Constants.LCMP:\n-        case Constants.FCMPL:\n-        case Constants.FCMPG:\n-        case Constants.DCMPL:\n-        case Constants.DCMPG:\n-            return new CmpInstruction(this, opcode);\n-        case Constants.IFEQ:\n-        case Constants.IFNE:\n-        case Constants.IFLT:\n-        case Constants.IFGE:\n-        case Constants.IFGT:\n-        case Constants.IFLE:\n-        case Constants.IFICMPEQ:\n-        case Constants.IFICMPNE:\n-        case Constants.IFICMPLT:\n-        case Constants.IFICMPGE:\n-        case Constants.IFICMPGT:\n-        case Constants.IFICMPLE:\n-        case Constants.IFACMPEQ:\n-        case Constants.IFACMPNE:\n-        case Constants.IFNULL:\n-        case Constants.IFNONNULL:\n-            return new IfInstruction(this, opcode);\n-        case Constants.GOTO:\n-        case Constants.JSR:\n-        case Constants.GOTOW:\n-        case Constants.JSRW:\n-            return new JumpInstruction(this, opcode);\n-        case Constants.RET:\n-            return new RetInstruction(this);\n-        case Constants.TABLESWITCH:\n-            return new TableSwitchInstruction(this);\n-        case Constants.LOOKUPSWITCH:\n-            return new LookupSwitchInstruction(this);\n-        case Constants.IRETURN:\n-        case Constants.LRETURN:\n-        case Constants.FRETURN:\n-        case Constants.DRETURN:\n-        case Constants.ARETURN:\n-        case Constants.RETURN:\n-            return new ReturnInstruction(this, opcode);\n-        case Constants.GETSTATIC:\n-        case Constants.GETFIELD:\n-            return new GetFieldInstruction(this, opcode);\n-        case Constants.PUTSTATIC:\n-        case Constants.PUTFIELD:\n-            return new PutFieldInstruction(this, opcode);\n-        case Constants.INVOKEVIRTUAL:\n-        case Constants.INVOKESPECIAL:\n-        case Constants.INVOKESTATIC:\n-        case Constants.INVOKEINTERFACE:\n-            return new MethodInstruction(this, opcode);\n-        case Constants.NEW:\n-        case Constants.ANEWARRAY:\n-        case Constants.CHECKCAST:\n-        case Constants.INSTANCEOF:\n-            return new ClassInstruction(this, opcode);\n-        case Constants.NEWARRAY:\n-            return new NewArrayInstruction(this);\n-        case Constants.MONITORENTER:\n-            return new MonitorEnterInstruction(this);\n-        case Constants.MONITOREXIT:\n-            return new MonitorExitInstruction(this);\n-        case Constants.WIDE:\n-            return new WideInstruction(this);\n-        case Constants.MULTIANEWARRAY:\n-            return new MultiANewArrayInstruction(this);\n-        default:\n-            throw new IllegalArgumentException(\"Illegal opcode: \" + opcode);\n+            case Constants.NOP:\n+            case Constants.ARRAYLENGTH:\n+            case Constants.ATHROW:\n+                return new Instruction(this, opcode);\n+            case Constants.ACONSTNULL:\n+            case Constants.ICONSTM1:\n+            case Constants.ICONST0:\n+            case Constants.ICONST1:\n+            case Constants.ICONST2:\n+            case Constants.ICONST3:\n+            case Constants.ICONST4:\n+            case Constants.ICONST5:\n+            case Constants.LCONST0:\n+            case Constants.LCONST1:\n+            case Constants.FCONST0:\n+            case Constants.FCONST1:\n+            case Constants.FCONST2:\n+            case Constants.DCONST0:\n+            case Constants.DCONST1:\n+            case Constants.BIPUSH:\n+            case Constants.SIPUSH:\n+            case Constants.LDC:\n+            case Constants.LDCW:\n+            case Constants.LDC2W:\n+                return new ConstantInstruction(this, opcode);\n+            case Constants.ILOAD:\n+            case Constants.LLOAD:\n+            case Constants.FLOAD:\n+            case Constants.DLOAD:\n+            case Constants.ALOAD:\n+            case Constants.ILOAD0:\n+            case Constants.ILOAD1:\n+            case Constants.ILOAD2:\n+            case Constants.ILOAD3:\n+            case Constants.LLOAD0:\n+            case Constants.LLOAD1:\n+            case Constants.LLOAD2:\n+            case Constants.LLOAD3:\n+            case Constants.FLOAD0:\n+            case Constants.FLOAD1:\n+            case Constants.FLOAD2:\n+            case Constants.FLOAD3:\n+            case Constants.DLOAD0:\n+            case Constants.DLOAD1:\n+            case Constants.DLOAD2:\n+            case Constants.DLOAD3:\n+            case Constants.ALOAD0:\n+            case Constants.ALOAD1:\n+            case Constants.ALOAD2:\n+            case Constants.ALOAD3:\n+                return new LoadInstruction(this, opcode);\n+            case Constants.IALOAD:\n+            case Constants.LALOAD:\n+            case Constants.FALOAD:\n+            case Constants.DALOAD:\n+            case Constants.AALOAD:\n+            case Constants.BALOAD:\n+            case Constants.CALOAD:\n+            case Constants.SALOAD:\n+                return new ArrayLoadInstruction(this, opcode);\n+            case Constants.ISTORE:\n+            case Constants.LSTORE:\n+            case Constants.FSTORE:\n+            case Constants.DSTORE:\n+            case Constants.ASTORE:\n+            case Constants.ISTORE0:\n+            case Constants.ISTORE1:\n+            case Constants.ISTORE2:\n+            case Constants.ISTORE3:\n+            case Constants.LSTORE0:\n+            case Constants.LSTORE1:\n+            case Constants.LSTORE2:\n+            case Constants.LSTORE3:\n+            case Constants.FSTORE0:\n+            case Constants.FSTORE1:\n+            case Constants.FSTORE2:\n+            case Constants.FSTORE3:\n+            case Constants.DSTORE0:\n+            case Constants.DSTORE1:\n+            case Constants.DSTORE2:\n+            case Constants.DSTORE3:\n+            case Constants.ASTORE0:\n+            case Constants.ASTORE1:\n+            case Constants.ASTORE2:\n+            case Constants.ASTORE3:\n+                return new StoreInstruction(this, opcode);\n+            case Constants.IASTORE:\n+            case Constants.LASTORE:\n+            case Constants.FASTORE:\n+            case Constants.DASTORE:\n+            case Constants.AASTORE:\n+            case Constants.BASTORE:\n+            case Constants.CASTORE:\n+            case Constants.SASTORE:\n+                return new ArrayStoreInstruction(this, opcode);\n+            case Constants.POP:\n+            case Constants.POP2:\n+            case Constants.DUP:\n+            case Constants.DUPX1:\n+            case Constants.DUPX2:\n+            case Constants.DUP2:\n+            case Constants.DUP2X1:\n+            case Constants.DUP2X2:\n+            case Constants.SWAP:\n+                return new StackInstruction(this, opcode);\n+            case Constants.IADD:\n+            case Constants.LADD:\n+            case Constants.FADD:\n+            case Constants.DADD:\n+            case Constants.ISUB:\n+            case Constants.LSUB:\n+            case Constants.FSUB:\n+            case Constants.DSUB:\n+            case Constants.IMUL:\n+            case Constants.LMUL:\n+            case Constants.FMUL:\n+            case Constants.DMUL:\n+            case Constants.IDIV:\n+            case Constants.LDIV:\n+            case Constants.FDIV:\n+            case Constants.DDIV:\n+            case Constants.IREM:\n+            case Constants.LREM:\n+            case Constants.FREM:\n+            case Constants.DREM:\n+            case Constants.INEG:\n+            case Constants.LNEG:\n+            case Constants.FNEG:\n+            case Constants.DNEG:\n+            case Constants.ISHL:\n+            case Constants.LSHL:\n+            case Constants.ISHR:\n+            case Constants.LSHR:\n+            case Constants.IUSHR:\n+            case Constants.LUSHR:\n+            case Constants.IAND:\n+            case Constants.LAND:\n+            case Constants.IOR:\n+            case Constants.LOR:\n+            case Constants.IXOR:\n+            case Constants.LXOR:\n+                return new MathInstruction(this, opcode);\n+            case Constants.IINC:\n+                return new IIncInstruction(this);\n+            case Constants.I2L:\n+            case Constants.I2F:\n+            case Constants.I2D:\n+            case Constants.L2I:\n+            case Constants.L2F:\n+            case Constants.L2D:\n+            case Constants.F2I:\n+            case Constants.F2L:\n+            case Constants.F2D:\n+            case Constants.D2I:\n+            case Constants.D2L:\n+            case Constants.D2F:\n+            case Constants.I2B:\n+            case Constants.I2C:\n+            case Constants.I2S:\n+                return new ConvertInstruction(this, opcode);\n+            case Constants.LCMP:\n+            case Constants.FCMPL:\n+            case Constants.FCMPG:\n+            case Constants.DCMPL:\n+            case Constants.DCMPG:\n+                return new CmpInstruction(this, opcode);\n+            case Constants.IFEQ:\n+            case Constants.IFNE:\n+            case Constants.IFLT:\n+            case Constants.IFGE:\n+            case Constants.IFGT:\n+            case Constants.IFLE:\n+            case Constants.IFICMPEQ:\n+            case Constants.IFICMPNE:\n+            case Constants.IFICMPLT:\n+            case Constants.IFICMPGE:\n+            case Constants.IFICMPGT:\n+            case Constants.IFICMPLE:\n+            case Constants.IFACMPEQ:\n+            case Constants.IFACMPNE:\n+            case Constants.IFNULL:\n+            case Constants.IFNONNULL:\n+                return new IfInstruction(this, opcode);\n+            case Constants.GOTO:\n+            case Constants.JSR:\n+            case Constants.GOTOW:\n+            case Constants.JSRW:\n+                return new JumpInstruction(this, opcode);\n+            case Constants.RET:\n+                return new RetInstruction(this);\n+            case Constants.TABLESWITCH:\n+                return new TableSwitchInstruction(this);\n+            case Constants.LOOKUPSWITCH:\n+                return new LookupSwitchInstruction(this);\n+            case Constants.IRETURN:\n+            case Constants.LRETURN:\n+            case Constants.FRETURN:\n+            case Constants.DRETURN:\n+            case Constants.ARETURN:\n+            case Constants.RETURN:\n+                return new ReturnInstruction(this, opcode);\n+            case Constants.GETSTATIC:\n+            case Constants.GETFIELD:\n+                return new GetFieldInstruction(this, opcode);\n+            case Constants.PUTSTATIC:\n+            case Constants.PUTFIELD:\n+                return new PutFieldInstruction(this, opcode);\n+            case Constants.INVOKEVIRTUAL:\n+            case Constants.INVOKESPECIAL:\n+            case Constants.INVOKESTATIC:\n+            case Constants.INVOKEINTERFACE:\n+                return new MethodInstruction(this, opcode);\n+            case Constants.NEW:\n+            case Constants.ANEWARRAY:\n+            case Constants.CHECKCAST:\n+            case Constants.INSTANCEOF:\n+                return new ClassInstruction(this, opcode);\n+            case Constants.NEWARRAY:\n+                return new NewArrayInstruction(this);\n+            case Constants.MONITORENTER:\n+                return new MonitorEnterInstruction(this);\n+            case Constants.MONITOREXIT:\n+                return new MonitorExitInstruction(this);\n+            case Constants.WIDE:\n+                return new WideInstruction(this);\n+            case Constants.MULTIANEWARRAY:\n+                return new MultiANewArrayInstruction(this);\n+            default:\n+                throw new IllegalArgumentException(\"Illegal opcode: \" + opcode);\n         }\n     }\n \n@@ -2460,6 +2477,7 @@ public ListIterator listIterator() {\n      * and notification of modification on addition.\n      */\n     private class CodeIterator implements ListIterator {\n+\n         public static final int UNSET = -99;\n \n         private CodeEntry _bn = null; // \"before next\" entry\n@@ -2596,7 +2614,7 @@ private void replaceTarget(Instruction orig, Instruction replace) {\n             // update the ExceptionHandler pointers\n             ExceptionHandler[] handlers = getExceptionHandlers();\n             for (int i = 0; i < handlers.length; i++)\n-                handlers [i].replaceTarget(orig, replace);\n+                handlers[i].replaceTarget(orig, replace);\n \n             // update LineNumber pointers\n             LineNumberTable lineNumbers = getLineNumberTable(false);"},{"sha":"94bd16aa5bbbfa7887affd497464ea10270cdc3a","filename":"serp/src/main/java/serp/bytecode/CodeEntry.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/CodeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/CodeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/CodeEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -14,10 +14,11 @@\n \n /**\n  * An entry in a code block.\n- * \n+ *\n  * @author Abe White\n  */\n class CodeEntry {\n+\n     CodeEntry next = null;\n     CodeEntry prev = null;\n }"},{"sha":"c733e84602d34080876c3370cd3dcdbb6c1c5d32","filename":"serp/src/main/java/serp/bytecode/ConstantInstruction.java","status":"modified","additions":125,"deletions":119,"changes":244,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,21 +12,27 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantEntry;\n+import serp.bytecode.lowlevel.Entry;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.util.Numbers;\n \n /**\n  * An instruction that that loads a constant onto the stack.\n  * The opcode represented by this instruction may change depending on the\n  * type and value of the constant set. For example, if the constant value\n  * is initially set to 5, the opcode will be <code>iconst5</code>; if later\n  * incremented to 6, the opcode will be changed to <code>bipush(6)</code>.\n- * \n+ *\n  * @author Abe White\n  */\n public class ConstantInstruction extends TypedInstruction {\n+\n     private int _arg = -1;\n \n     ConstantInstruction(Code owner) {\n@@ -39,15 +45,15 @@\n \n     int getLength() {\n         switch (getOpcode()) {\n-        case Constants.BIPUSH:\n-        case Constants.LDC:\n-            return super.getLength() + 1;\n-        case Constants.SIPUSH:\n-        case Constants.LDCW:\n-        case Constants.LDC2W:\n-            return super.getLength() + 2;\n-        default:\n-            return super.getLength();\n+            case Constants.BIPUSH:\n+            case Constants.LDC:\n+                return super.getLength() + 1;\n+            case Constants.SIPUSH:\n+            case Constants.LDCW:\n+            case Constants.LDC2W:\n+                return super.getLength() + 2;\n+            default:\n+                return super.getLength();\n         }\n     }\n \n@@ -66,49 +72,49 @@ public int getLogicalStackChange() {\n     public String getTypeName() {\n         int opcode = getOpcode();\n         switch (opcode) {\n-        case Constants.NOP:\n-            return null;\n-        case Constants.ACONSTNULL:\n-            return Object.class.getName();\n-        case Constants.ICONSTM1:\n-        case Constants.ICONST0:\n-        case Constants.ICONST1:\n-        case Constants.ICONST2:\n-        case Constants.ICONST3:\n-        case Constants.ICONST4:\n-        case Constants.ICONST5:\n-        case Constants.BIPUSH:\n-        case Constants.SIPUSH:\n-            return int.class.getName();\n-        case Constants.LCONST0:\n-        case Constants.LCONST1:\n-            return long.class.getName();\n-        case Constants.FCONST0:\n-        case Constants.FCONST1:\n-        case Constants.FCONST2:\n-            return float.class.getName();\n-        case Constants.DCONST0:\n-        case Constants.DCONST1:\n-            return double.class.getName();\n+            case Constants.NOP:\n+                return null;\n+            case Constants.ACONSTNULL:\n+                return Object.class.getName();\n+            case Constants.ICONSTM1:\n+            case Constants.ICONST0:\n+            case Constants.ICONST1:\n+            case Constants.ICONST2:\n+            case Constants.ICONST3:\n+            case Constants.ICONST4:\n+            case Constants.ICONST5:\n+            case Constants.BIPUSH:\n+            case Constants.SIPUSH:\n+                return int.class.getName();\n+            case Constants.LCONST0:\n+            case Constants.LCONST1:\n+                return long.class.getName();\n+            case Constants.FCONST0:\n+            case Constants.FCONST1:\n+            case Constants.FCONST2:\n+                return float.class.getName();\n+            case Constants.DCONST0:\n+            case Constants.DCONST1:\n+                return double.class.getName();\n         }\n \n         Entry entry = getPool().getEntry(_arg);\n         switch (entry.getType()) {\n-        case Entry.UTF8:\n-        case Entry.STRING:\n-            return String.class.getName();\n-        case Entry.INT:\n-            return int.class.getName();\n-        case Entry.FLOAT:\n-            return float.class.getName();\n-        case Entry.LONG:\n-            return long.class.getName();\n-        case Entry.DOUBLE:\n-            return double.class.getName();\n-        case Entry.CLASS:\n-            return Class.class.getName();\n-        default:\n-            return null;\n+            case Entry.UTF8:\n+            case Entry.STRING:\n+                return String.class.getName();\n+            case Entry.INT:\n+                return int.class.getName();\n+            case Entry.FLOAT:\n+                return float.class.getName();\n+            case Entry.LONG:\n+                return long.class.getName();\n+            case Entry.DOUBLE:\n+                return double.class.getName();\n+            case Entry.CLASS:\n+                return Class.class.getName();\n+            default:\n+                return null;\n         }\n     }\n \n@@ -123,37 +129,37 @@ public TypedInstruction setType(String type) {\n     public Object getValue() {\n         int opcode = getOpcode();\n         switch (opcode) {\n-        case Constants.NOP:\n-        case Constants.ACONSTNULL:\n-            return null;\n-        case Constants.ICONSTM1:\n-        case Constants.ICONST0:\n-        case Constants.ICONST1:\n-        case Constants.ICONST2:\n-        case Constants.ICONST3:\n-        case Constants.ICONST4:\n-        case Constants.ICONST5:\n-            return Numbers.valueOf(opcode - Constants.ICONST0);\n-        case Constants.LCONST0:\n-        case Constants.LCONST1:\n-            return Numbers.valueOf((long) (opcode - Constants.LCONST0));\n-        case Constants.FCONST0:\n-        case Constants.FCONST1:\n-        case Constants.FCONST2:\n-            return new Float(opcode - Constants.FCONST0);\n-        case Constants.DCONST0:\n-        case Constants.DCONST1:\n-            return new Double(opcode - Constants.DCONST0);\n-        case Constants.BIPUSH:\n-        case Constants.SIPUSH:\n-            return Numbers.valueOf(_arg);\n-        default:\n-            Entry entry = getPool().getEntry(_arg);\n-            Object val = ((ConstantEntry) entry).getConstant();\n-            if (entry.getType() == Entry.CLASS)\n-                return getProject().getNameCache().getExternalForm\n-                    ((String) val, false);\n-            return val;\n+            case Constants.NOP:\n+            case Constants.ACONSTNULL:\n+                return null;\n+            case Constants.ICONSTM1:\n+            case Constants.ICONST0:\n+            case Constants.ICONST1:\n+            case Constants.ICONST2:\n+            case Constants.ICONST3:\n+            case Constants.ICONST4:\n+            case Constants.ICONST5:\n+                return Numbers.valueOf(opcode - Constants.ICONST0);\n+            case Constants.LCONST0:\n+            case Constants.LCONST1:\n+                return Numbers.valueOf((long) (opcode - Constants.LCONST0));\n+            case Constants.FCONST0:\n+            case Constants.FCONST1:\n+            case Constants.FCONST2:\n+                return new Float(opcode - Constants.FCONST0);\n+            case Constants.DCONST0:\n+            case Constants.DCONST1:\n+                return new Double(opcode - Constants.DCONST0);\n+            case Constants.BIPUSH:\n+            case Constants.SIPUSH:\n+                return Numbers.valueOf(_arg);\n+            default:\n+                Entry entry = getPool().getEntry(_arg);\n+                Object val = ((ConstantEntry) entry).getConstant();\n+                if (entry.getType() == Entry.CLASS)\n+                    return getProject().getNameCache().getExternalForm\n+                        ((String) val, false);\n+                return val;\n         }\n     }\n \n@@ -162,7 +168,7 @@ public Object getValue() {\n      * an instance of String, Integer, Long, Double, Float, Class, BCClass, or\n      * null depending on the constant type. If the given value is not\n      * supported directly, it will be converted accordingly.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(Object value) {\n@@ -189,51 +195,51 @@ else if (value != null && !(value instanceof Number)\n      * Return the string value of this constant, or null if not set.\n      */\n     public String getStringValue() {\n-        return(String) getValue();\n+        return (String) getValue();\n     }\n \n     /**\n      * Return the int value of this constant, or 0 if not set.\n      */\n     public int getIntValue() {\n         Object value = getValue();\n-        return(value == null) ? 0 : ((Number) value).intValue();\n+        return (value == null) ? 0 : ((Number) value).intValue();\n     }\n \n     /**\n      * Return the long value of this constant, or 0 if not set.\n      */\n     public long getLongValue() {\n         Object value = getValue();\n-        return(value == null) ? 0L : ((Number) value).longValue();\n+        return (value == null) ? 0L : ((Number) value).longValue();\n     }\n \n     /**\n      * Return the float value of this constant, or 0 if not set.\n      */\n     public float getFloatValue() {\n         Object value = getValue();\n-        return(value == null) ? 0F : ((Number) value).floatValue();\n+        return (value == null) ? 0F : ((Number) value).floatValue();\n     }\n \n     /**\n      * Return the double value of this constant, or 0 if not set.\n      */\n     public double getDoubleValue() {\n         Object value = getValue();\n-        return(value == null) ? 0D : ((Number) value).doubleValue();\n+        return (value == null) ? 0D : ((Number) value).doubleValue();\n     }\n \n     /**\n      * Return the class value of this constant, or null if not set.\n      */\n     public String getClassNameValue() {\n-        return(String) getValue();\n+        return (String) getValue();\n     }\n \n     /**\n      * Set this constant to null.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setNull() {\n@@ -243,7 +249,7 @@ public ConstantInstruction setNull() {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(String value) {\n@@ -253,7 +259,7 @@ public ConstantInstruction setValue(String value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(Class value) {\n@@ -263,7 +269,7 @@ public ConstantInstruction setValue(Class value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(BCClass value) {\n@@ -273,7 +279,7 @@ public ConstantInstruction setValue(BCClass value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(int value) {\n@@ -283,7 +289,7 @@ public ConstantInstruction setValue(int value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(long value) {\n@@ -293,7 +299,7 @@ public ConstantInstruction setValue(long value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(float value) {\n@@ -303,7 +309,7 @@ public ConstantInstruction setValue(float value) {\n \n     /**\n      * Set the value of this constant.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(double value) {\n@@ -313,7 +319,7 @@ public ConstantInstruction setValue(double value) {\n \n     /**\n      * Set the value of this constant; note that this type is converted to int.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(boolean value) {\n@@ -322,7 +328,7 @@ public ConstantInstruction setValue(boolean value) {\n \n     /**\n      * Set the value of this constant; note that this type is converted to int.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(short value) {\n@@ -331,7 +337,7 @@ public ConstantInstruction setValue(short value) {\n \n     /**\n      * Set the value of this constant; note that this type is converted to int.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConstantInstruction setValue(char value) {\n@@ -369,30 +375,30 @@ void read(DataInput in) throws IOException {\n         super.read(in);\n \n         switch (getOpcode()) {\n-        case Constants.BIPUSH:\n-        case Constants.LDC:\n-            _arg = in.readUnsignedByte();\n-            break;\n-        case Constants.SIPUSH:\n-        case Constants.LDCW:\n-        case Constants.LDC2W:\n-            _arg = in.readUnsignedShort();\n+            case Constants.BIPUSH:\n+            case Constants.LDC:\n+                _arg = in.readUnsignedByte();\n+                break;\n+            case Constants.SIPUSH:\n+            case Constants.LDCW:\n+            case Constants.LDC2W:\n+                _arg = in.readUnsignedShort();\n         }\n     }\n \n     void write(DataOutput out) throws IOException {\n         super.write(out);\n \n         switch (getOpcode()) {\n-        case Constants.BIPUSH:\n-        case Constants.LDC:\n-            out.writeByte(_arg);\n-            break;\n-        case Constants.SIPUSH:\n-        case Constants.LDCW:\n-        case Constants.LDC2W:\n-            out.writeShort(_arg);\n-            break;\n+            case Constants.BIPUSH:\n+            case Constants.LDC:\n+                out.writeByte(_arg);\n+                break;\n+            case Constants.SIPUSH:\n+            case Constants.LDCW:\n+            case Constants.LDC2W:\n+                out.writeShort(_arg);\n+                break;\n         }\n     }\n "},{"sha":"44b508b40ed7ee8e74db3823540be999c08f30b2","filename":"serp/src/main/java/serp/bytecode/ConstantValue.java","status":"modified","additions":21,"deletions":11,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConstantValue.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConstantValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConstantValue.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,16 +12,26 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ConstantEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.lowlevel.DoubleEntry;\n+import serp.bytecode.lowlevel.FloatEntry;\n+import serp.bytecode.lowlevel.IntEntry;\n+import serp.bytecode.lowlevel.LongEntry;\n+import serp.bytecode.lowlevel.StringEntry;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * A constant value for a member field.\n- * \n+ *\n  * @author Abe White\n  */\n public class ConstantValue extends Attribute {\n+\n     int _valueIndex = 0;\n \n     ConstantValue(int nameIndex, Attributes owner) {\n@@ -36,7 +46,7 @@ int getLength() {\n      * Return the owning field.\n      */\n     public BCField getField() {\n-        return(BCField) getOwner();\n+        return (BCField) getOwner();\n     }\n \n     /**\n@@ -101,7 +111,7 @@ public BCClass getTypeBC() {\n     public Object getValue() {\n         if (_valueIndex <= 0)\n             return null;\n-        return((ConstantEntry) getPool().getEntry(_valueIndex)). getConstant();\n+        return ((ConstantEntry) getPool().getEntry(_valueIndex)). getConstant();\n     }\n \n     /**\n@@ -135,7 +145,7 @@ else if (type == Long.class)\n     public int getIntValue() {\n         if (getValueIndex() <= 0)\n             return 0;\n-        return((IntEntry) getPool().getEntry(getValueIndex())).getValue();\n+        return ((IntEntry) getPool().getEntry(getValueIndex())).getValue();\n     }\n \n     /**\n@@ -151,7 +161,7 @@ public void setIntValue(int value) {\n     public float getFloatValue() {\n         if (getValueIndex() <= 0)\n             return 0F;\n-        return((FloatEntry) getPool().getEntry(getValueIndex())).getValue();\n+        return ((FloatEntry) getPool().getEntry(getValueIndex())).getValue();\n     }\n \n     /**\n@@ -167,7 +177,7 @@ public void setFloatValue(float value) {\n     public double getDoubleValue() {\n         if (getValueIndex() <= 0)\n             return 0D;\n-        return((DoubleEntry) getPool().getEntry(getValueIndex())). getValue();\n+        return ((DoubleEntry) getPool().getEntry(getValueIndex())). getValue();\n     }\n \n     /**\n@@ -183,7 +193,7 @@ public void setDoubleValue(double value) {\n     public long getLongValue() {\n         if (getValueIndex() <= 0)\n             return 0L;\n-        return((LongEntry) getPool().getEntry(getValueIndex())).getValue();\n+        return ((LongEntry) getPool().getEntry(getValueIndex())).getValue();\n     }\n \n     /**\n@@ -199,7 +209,7 @@ public void setLongValue(long value) {\n     public String getStringValue() {\n         if (getValueIndex() <= 0)\n             return null;\n-        return((StringEntry) getPool().getEntry(getValueIndex())).\n+        return ((StringEntry) getPool().getEntry(getValueIndex())).\n             getStringEntry().getValue();\n     }\n "},{"sha":"874eb35ffaf7245cc12b72e3fec0a6b5b5dbd7b5","filename":"serp/src/main/java/serp/bytecode/Constants.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Constants.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Constants.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Constants.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -17,10 +17,11 @@\n  * constants using the static <code>Constants.</code> field prefix,\n  * or implement this interface themselves to conveniently import the\n  * constants into their own namespace.\n- * \n+ *\n  * @author Abe White\n  */\n public interface Constants {\n+\n     // class magic number\n     public static final int VALID_MAGIC = 0xcafebabe;\n \n@@ -284,7 +285,7 @@\n     public static final int MATH_XOR = IXOR;\n \n     // human-readable opcode names\n-    public static final String[] OPCODE_NAMES = new String[] {\n+    public static final String[] OPCODE_NAMES = new String[]{\n         \"nop\", \"aconstnull\", \"iconstm1\", \"iconst0\", \"iconst1\", \"iconst2\",\n         \"iconst3\", \"iconst4\", \"iconst5\", \"lconst0\", \"lconst1\", \"fconst0\",\n         \"fconst1\", \"fconst2\", \"dconst0\", \"dconst1\", \"bipush\", \"sipush\", \"ldc\","},{"sha":"a4e241b77c894161a07d961c11f95e8bfd569e2c","filename":"serp/src/main/java/serp/bytecode/ConvertInstruction.java","status":"modified","additions":153,"deletions":153,"changes":306,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ConvertInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,23 +12,23 @@\n  */\n package serp.bytecode;\n \n-import java.util.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.util.Strings;\n \n /**\n  * A conversion opcode such as <code>i2l, f2i</code>, etc.\n  * Changing the types of the instruction will automatically\n  * update the underlying opcode. Converting from one type to the same\n  * type will result in a <code>nop</code>.\n- * \n+ *\n  * @author Abe White\n  */\n public class ConvertInstruction extends TypedInstruction {\n-    private static final Class[][] _mappings = new Class[][] {\n+\n+    private static final Class[][] _mappings = new Class[][]{\n         { boolean.class, int.class }, { void.class, int.class },\n         { Object.class, int.class }, };\n-    private static final Class[][] _fromMappings = new Class[][] {\n+    private static final Class[][] _fromMappings = new Class[][]{\n         { boolean.class, int.class }, { void.class, int.class },\n         { Object.class, int.class }, { byte.class, int.class },\n         { char.class, int.class }, { short.class, int.class }, };\n@@ -50,47 +50,47 @@ public int getLogicalStackChange() {\n \n     public int getStackChange() {\n         switch (getOpcode()) {\n-        case Constants.I2L:\n-        case Constants.I2D:\n-        case Constants.F2L:\n-        case Constants.F2D:\n-            return 1;\n-        case Constants.L2I:\n-        case Constants.L2F:\n-        case Constants.D2I:\n-        case Constants.D2F:\n-            return -1;\n-        default:\n-            return 0;\n+            case Constants.I2L:\n+            case Constants.I2D:\n+            case Constants.F2L:\n+            case Constants.F2D:\n+                return 1;\n+            case Constants.L2I:\n+            case Constants.L2F:\n+            case Constants.D2I:\n+            case Constants.D2F:\n+                return -1;\n+            default:\n+                return 0;\n         }\n     }\n \n     public String getTypeName() {\n         switch (getOpcode()) {\n-        case Constants.L2I:\n-        case Constants.F2I:\n-        case Constants.D2I:\n-            return int.class.getName();\n-        case Constants.I2L:\n-        case Constants.F2L:\n-        case Constants.D2L:\n-            return long.class.getName();\n-        case Constants.I2F:\n-        case Constants.L2F:\n-        case Constants.D2F:\n-            return float.class.getName();\n-        case Constants.I2D:\n-        case Constants.L2D:\n-        case Constants.F2D:\n-            return double.class.getName();\n-        case Constants.I2B:\n-            return byte.class.getName();\n-        case Constants.I2C:\n-            return char.class.getName();\n-        case Constants.I2S:\n-            return short.class.getName();\n-        default:\n-            return _toType;\n+            case Constants.L2I:\n+            case Constants.F2I:\n+            case Constants.D2I:\n+                return int.class.getName();\n+            case Constants.I2L:\n+            case Constants.F2L:\n+            case Constants.D2L:\n+                return long.class.getName();\n+            case Constants.I2F:\n+            case Constants.L2F:\n+            case Constants.D2F:\n+                return float.class.getName();\n+            case Constants.I2D:\n+            case Constants.L2D:\n+            case Constants.F2D:\n+                return double.class.getName();\n+            case Constants.I2B:\n+                return byte.class.getName();\n+            case Constants.I2C:\n+                return char.class.getName();\n+            case Constants.I2S:\n+                return short.class.getName();\n+            default:\n+                return _toType;\n         }\n     }\n \n@@ -103,7 +103,7 @@ public TypedInstruction setType(String type) {\n         if (toType == null || fromType == null || toType.equals(fromType)) {\n             _toType = toType;\n             _fromType = fromType;\n-            return(TypedInstruction) setOpcode(Constants.NOP);\n+            return (TypedInstruction) setOpcode(Constants.NOP);\n         }\n \n         // ok, valid conversion possible, forget saved types\n@@ -114,53 +114,53 @@ public TypedInstruction setType(String type) {\n         char from = fromType.charAt(0);\n \n         switch (to) {\n-        case 'i':\n-            switch (from) {\n-            case 'l':\n-                return(TypedInstruction) setOpcode(Constants.L2I);\n-            case 'f':\n-                return(TypedInstruction) setOpcode(Constants.F2I);\n-            case 'd':\n-                return(TypedInstruction) setOpcode(Constants.D2I);\n-            }\n-        case 'l':\n-            switch (from) {\n-            case 'i':\n-                return(TypedInstruction) setOpcode(Constants.I2L);\n-            case 'f':\n-                return(TypedInstruction) setOpcode(Constants.F2L);\n-            case 'd':\n-                return(TypedInstruction) setOpcode(Constants.D2L);\n-            }\n-        case 'f':\n-            switch (from) {\n-            case 'i':\n-                return(TypedInstruction) setOpcode(Constants.I2F);\n-            case 'l':\n-                return(TypedInstruction) setOpcode(Constants.L2F);\n-            case 'd':\n-                return(TypedInstruction) setOpcode(Constants.D2F);\n-            }\n-        case 'd':\n-            switch (from) {\n             case 'i':\n-                return(TypedInstruction) setOpcode(Constants.I2D);\n+                switch (from) {\n+                    case 'l':\n+                        return (TypedInstruction) setOpcode(Constants.L2I);\n+                    case 'f':\n+                        return (TypedInstruction) setOpcode(Constants.F2I);\n+                    case 'd':\n+                        return (TypedInstruction) setOpcode(Constants.D2I);\n+                }\n             case 'l':\n-                return(TypedInstruction) setOpcode(Constants.L2D);\n+                switch (from) {\n+                    case 'i':\n+                        return (TypedInstruction) setOpcode(Constants.I2L);\n+                    case 'f':\n+                        return (TypedInstruction) setOpcode(Constants.F2L);\n+                    case 'd':\n+                        return (TypedInstruction) setOpcode(Constants.D2L);\n+                }\n             case 'f':\n-                return(TypedInstruction) setOpcode(Constants.F2D);\n-            }\n-        case 'b':\n-            if (from == 'i')\n-                return(TypedInstruction) setOpcode(Constants.I2B);\n-        case 'C':\n-            if (from == 'i')\n-                return(TypedInstruction) setOpcode(Constants.I2C);\n-        case 'S':\n-            if (from == 'i')\n-                return(TypedInstruction) setOpcode(Constants.I2S);\n-        default:\n-            throw new IllegalStateException();\n+                switch (from) {\n+                    case 'i':\n+                        return (TypedInstruction) setOpcode(Constants.I2F);\n+                    case 'l':\n+                        return (TypedInstruction) setOpcode(Constants.L2F);\n+                    case 'd':\n+                        return (TypedInstruction) setOpcode(Constants.D2F);\n+                }\n+            case 'd':\n+                switch (from) {\n+                    case 'i':\n+                        return (TypedInstruction) setOpcode(Constants.I2D);\n+                    case 'l':\n+                        return (TypedInstruction) setOpcode(Constants.L2D);\n+                    case 'f':\n+                        return (TypedInstruction) setOpcode(Constants.F2D);\n+                }\n+            case 'b':\n+                if (from == 'i')\n+                    return (TypedInstruction) setOpcode(Constants.I2B);\n+            case 'C':\n+                if (from == 'i')\n+                    return (TypedInstruction) setOpcode(Constants.I2C);\n+            case 'S':\n+                if (from == 'i')\n+                    return (TypedInstruction) setOpcode(Constants.I2S);\n+            default:\n+                throw new IllegalStateException();\n         }\n     }\n \n@@ -170,27 +170,27 @@ public TypedInstruction setType(String type) {\n      */\n     public String getFromTypeName() {\n         switch (getOpcode()) {\n-        case Constants.I2L:\n-        case Constants.I2F:\n-        case Constants.I2D:\n-        case Constants.I2B:\n-        case Constants.I2S:\n-        case Constants.I2C:\n-            return int.class.getName();\n-        case Constants.L2I:\n-        case Constants.L2F:\n-        case Constants.L2D:\n-            return long.class.getName();\n-        case Constants.F2I:\n-        case Constants.F2L:\n-        case Constants.F2D:\n-            return float.class.getName();\n-        case Constants.D2I:\n-        case Constants.D2L:\n-        case Constants.D2F:\n-            return double.class.getName();\n-        default:\n-            return _fromType;\n+            case Constants.I2L:\n+            case Constants.I2F:\n+            case Constants.I2D:\n+            case Constants.I2B:\n+            case Constants.I2S:\n+            case Constants.I2C:\n+                return int.class.getName();\n+            case Constants.L2I:\n+            case Constants.L2F:\n+            case Constants.L2D:\n+                return long.class.getName();\n+            case Constants.F2I:\n+            case Constants.F2L:\n+            case Constants.F2D:\n+                return float.class.getName();\n+            case Constants.D2I:\n+            case Constants.D2L:\n+            case Constants.D2F:\n+                return double.class.getName();\n+            default:\n+                return _fromType;\n         }\n     }\n \n@@ -219,7 +219,7 @@ public BCClass getFromTypeBC() {\n     /**\n      * Set the type being converted from. Types that have no direct\n      * support will be converted accordingly.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConvertInstruction setFromType(String type) {\n@@ -231,7 +231,7 @@ public ConvertInstruction setFromType(String type) {\n         if (toType == null || fromType == null || toType.equals(fromType)) {\n             _toType = toType;\n             _fromType = fromType;\n-            return(ConvertInstruction) setOpcode(Constants.NOP);\n+            return (ConvertInstruction) setOpcode(Constants.NOP);\n         }\n \n         // ok, valid conversion possible, forget saved types\n@@ -242,57 +242,57 @@ public ConvertInstruction setFromType(String type) {\n         char from = fromType.charAt(0);\n \n         switch (from) {\n-        case 'i':\n-            switch (to) {\n-            case 'l':\n-                return(ConvertInstruction) setOpcode(Constants.I2L);\n-            case 'f':\n-                return(ConvertInstruction) setOpcode(Constants.I2F);\n-            case 'd':\n-                return(ConvertInstruction) setOpcode(Constants.I2D);\n-            case 'b':\n-                return(ConvertInstruction) setOpcode(Constants.I2B);\n-            case 'c':\n-                return(ConvertInstruction) setOpcode(Constants.I2C);\n-            case 's':\n-                return(ConvertInstruction) setOpcode(Constants.I2S);\n-            }\n-        case 'l':\n-            switch (to) {\n             case 'i':\n-                return(ConvertInstruction) setOpcode(Constants.L2I);\n-            case 'f':\n-                return(ConvertInstruction) setOpcode(Constants.L2F);\n-            case 'd':\n-                return(ConvertInstruction) setOpcode(Constants.L2D);\n-            }\n-        case 'f':\n-            switch (to) {\n-            case 'i':\n-                return(ConvertInstruction) setOpcode(Constants.F2I);\n+                switch (to) {\n+                    case 'l':\n+                        return (ConvertInstruction) setOpcode(Constants.I2L);\n+                    case 'f':\n+                        return (ConvertInstruction) setOpcode(Constants.I2F);\n+                    case 'd':\n+                        return (ConvertInstruction) setOpcode(Constants.I2D);\n+                    case 'b':\n+                        return (ConvertInstruction) setOpcode(Constants.I2B);\n+                    case 'c':\n+                        return (ConvertInstruction) setOpcode(Constants.I2C);\n+                    case 's':\n+                        return (ConvertInstruction) setOpcode(Constants.I2S);\n+                }\n             case 'l':\n-                return(ConvertInstruction) setOpcode(Constants.F2L);\n-            case 'd':\n-                return(ConvertInstruction) setOpcode(Constants.F2D);\n-            }\n-        case 'd':\n-            switch (to) {\n-            case 'i':\n-                return(ConvertInstruction) setOpcode(Constants.D2I);\n-            case 'l':\n-                return(ConvertInstruction) setOpcode(Constants.D2L);\n+                switch (to) {\n+                    case 'i':\n+                        return (ConvertInstruction) setOpcode(Constants.L2I);\n+                    case 'f':\n+                        return (ConvertInstruction) setOpcode(Constants.L2F);\n+                    case 'd':\n+                        return (ConvertInstruction) setOpcode(Constants.L2D);\n+                }\n             case 'f':\n-                return(ConvertInstruction) setOpcode(Constants.D2F);\n-            }\n-        default:\n-            throw new IllegalStateException();\n+                switch (to) {\n+                    case 'i':\n+                        return (ConvertInstruction) setOpcode(Constants.F2I);\n+                    case 'l':\n+                        return (ConvertInstruction) setOpcode(Constants.F2L);\n+                    case 'd':\n+                        return (ConvertInstruction) setOpcode(Constants.F2D);\n+                }\n+            case 'd':\n+                switch (to) {\n+                    case 'i':\n+                        return (ConvertInstruction) setOpcode(Constants.D2I);\n+                    case 'l':\n+                        return (ConvertInstruction) setOpcode(Constants.D2L);\n+                    case 'f':\n+                        return (ConvertInstruction) setOpcode(Constants.D2F);\n+                }\n+            default:\n+                throw new IllegalStateException();\n         }\n     }\n \n     /**\n      * Set the type being converted from. Types that have no direct\n      * support will be converted accordingly.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConvertInstruction setFromType(Class type) {\n@@ -304,7 +304,7 @@ public ConvertInstruction setFromType(Class type) {\n     /**\n      * Set the type being converted from. Types that have no direct\n      * support will be converted accordingly.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public ConvertInstruction setFromType(BCClass type) {"},{"sha":"22bff4c2e4d45de3f705cd2d4b2d8baf553ced18","filename":"serp/src/main/java/serp/bytecode/Deprecated.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Deprecated.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Deprecated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Deprecated.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,14 +12,15 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Attribute signifying that a method or class is deprecated.\n- * \n+ *\n  * @author Abe White\n  */\n public class Deprecated extends Attribute {\n+\n     Deprecated(int nameIndex, Attributes owner) {\n         super(nameIndex, owner);\n     }"},{"sha":"792aaa86ae7b43b688f62ed189e7bca0ca4d3b96","filename":"serp/src/main/java/serp/bytecode/ExceptionHandler.java","status":"modified","additions":13,"deletions":7,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ExceptionHandler.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ExceptionHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ExceptionHandler.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,18 +12,24 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Strings;\n \n /**\n  * Represents a <code>try {} catch() {}</code> statement in bytecode.\n- * \n+ *\n  * @author Abe White\n  */\n-public class ExceptionHandler implements InstructionPtr, BCEntity, VisitAcceptor {\n+public class ExceptionHandler\n+    implements InstructionPtr, BCEntity, VisitAcceptor {\n+\n     private int _catchIndex = 0;\n     private Code _owner = null;\n "},{"sha":"b72cb7c386d429b77c3b33acf82830bd2b2d1db1","filename":"serp/src/main/java/serp/bytecode/Exceptions.java","status":"modified","additions":18,"deletions":10,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Exceptions.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,18 +12,26 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n \n /**\n  * Attribute declaring the checked exceptions a method can throw.\n- * \n+ *\n  * @author Abe White\n  */\n public class Exceptions extends Attribute {\n+\n     private List _indexes = new LinkedList();\n \n     Exceptions(int nameIndex, Attributes owner) {\n@@ -38,7 +46,7 @@ int getLength() {\n      * Return the owning method.\n      */\n     public BCMethod getMethod() {\n-        return(BCMethod) getOwner();\n+        return (BCMethod) getOwner();\n     }\n \n     /**\n@@ -163,7 +171,7 @@ public void clear() {\n \n     /**\n      * Remove an exception type thrown by this method.\n-     * \n+     *\n      * @return true if the method had the exception type, false otherwise\n      */\n     public boolean removeException(String type) {\n@@ -184,7 +192,7 @@ public boolean removeException(String type) {\n \n     /**\n      * Remove an exception thrown by this method.\n-     * \n+     *\n      * @return true if the method had the exception type, false otherwise\n      */\n     public boolean removeException(Class type) {\n@@ -195,7 +203,7 @@ public boolean removeException(Class type) {\n \n     /**\n      * Remove an exception thrown by this method.\n-     * \n+     *\n      * @return true if the method had the exception type, false otherwise\n      */\n     public boolean removeException(BCClass type) {"},{"sha":"25e93aeae1806f1d17730a7628fb56a65120576e","filename":"serp/src/main/java/serp/bytecode/FieldInstruction.java","status":"modified","additions":30,"deletions":26,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/FieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/FieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/FieldInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,19 +12,23 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.lang.reflect.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+\n+import serp.bytecode.lowlevel.ComplexEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.util.Strings;\n \n /**\n  * Instruction that takes as an argument a field to operate\n  * on. Examples include <code>getfield, getstatic, setfield, setstatic</code>.\n- * \n+ *\n  * @author Abe White\n  */\n public abstract class FieldInstruction extends Instruction {\n+\n     private int _index = 0;\n \n     FieldInstruction(Code owner, int opcode) {\n@@ -50,7 +54,7 @@ public int getFieldIndex() {\n     /**\n      * Set the index in the class {@link ConstantPool} of the\n      * {@link ComplexEntry} describing the field to operate on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldIndex(int index) {\n@@ -76,7 +80,7 @@ public BCField getField() {\n \n     /**\n      * Set the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setField(BCField field) {\n@@ -88,7 +92,7 @@ public FieldInstruction setField(BCField field) {\n \n     /**\n      * Set the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setField(Field field) {\n@@ -100,8 +104,8 @@ public FieldInstruction setField(Field field) {\n \n     /**\n      * Set the field this instruction operates on.\n-     * \n-     * @param dec the full class name of the field's declaring class\n+     *\n+     * @param dec  the full class name of the field's declaring class\n      * @param name the field name\n      * @param type the full class name of the field type\n      * @return this instruction, for method chaining\n@@ -120,13 +124,13 @@ public FieldInstruction setField(String dec, String name, String type) {\n         dec = getProject().getNameCache().getInternalForm(dec, false);\n         type = getProject().getNameCache().getInternalForm(type, true);\n \n-        return setFieldIndex(getPool().findFieldEntry (dec, name, type, true));\n+        return setFieldIndex(getPool().findFieldEntry(dec, name, type, true));\n     }\n \n     /**\n      * Set the field this instruction operates on, for fields that are\n      * declared by the current class.\n-     * \n+     *\n      * @param name the field name\n      * @param type the full class name of the field type\n      * @return this instruction, for method chaining\n@@ -138,8 +142,8 @@ public FieldInstruction setField(String name, String type) {\n \n     /**\n      * Set the field this instruction operates on.\n-     * \n-     * @param dec the field's declaring class\n+     *\n+     * @param dec  the field's declaring class\n      * @param name the field name\n      * @param type the class of the field type\n      * @return this instruction, for method chaining\n@@ -153,7 +157,7 @@ public FieldInstruction setField(Class dec, String name, Class type) {\n     /**\n      * Set the field this instruction operates on, for fields that are\n      * declared by the current class.\n-     * \n+     *\n      * @param name the field name\n      * @param type the class of the field type\n      * @return this instruction, for method chaining\n@@ -166,8 +170,8 @@ public FieldInstruction setField(String name, Class type) {\n \n     /**\n      * Set the field this instruction operates on.\n-     * \n-     * @param dec the field's declaring class\n+     *\n+     * @param dec  the field's declaring class\n      * @param name the field name\n      * @param type the class of the field type\n      * @return this instruction, for method chaining\n@@ -181,7 +185,7 @@ public FieldInstruction setField(BCClass dec, String name, BCClass type) {\n     /**\n      * Set the field this instruction operates on, for fields that are\n      * declared by the current class.\n-     * \n+     *\n      * @param name the field name\n      * @param type the class of the field type\n      * @return this instruction, for method chaining\n@@ -214,7 +218,7 @@ public String getFieldName() {\n \n     /**\n      * Set the name of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldName(String name) {\n@@ -262,7 +266,7 @@ public BCClass getFieldTypeBC() {\n \n     /**\n      * Set the type of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldType(String type) {\n@@ -271,7 +275,7 @@ public FieldInstruction setFieldType(String type) {\n \n     /**\n      * Set the type of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldType(Class type) {\n@@ -283,7 +287,7 @@ public FieldInstruction setFieldType(Class type) {\n \n     /**\n      * Set the type of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldType(BCClass type) {\n@@ -334,7 +338,7 @@ public BCClass getFieldDeclarerBC() {\n \n     /**\n      * Set the declaring class of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldDeclarer(String type) {\n@@ -343,7 +347,7 @@ public FieldInstruction setFieldDeclarer(String type) {\n \n     /**\n      * Set the declaring class of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldDeclarer(Class type) {\n@@ -355,7 +359,7 @@ public FieldInstruction setFieldDeclarer(Class type) {\n \n     /**\n      * Set the declaring class of the field this instruction operates on.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public FieldInstruction setFieldDeclarer(BCClass type) {"},{"sha":"7b9133a54e61afcf3bf078f72c096b4ce52ff616","filename":"serp/src/main/java/serp/bytecode/GetFieldInstruction.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/GetFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/GetFieldInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,14 +12,15 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Loads a value from a field onto the stack.\n- * \n+ *\n  * @author Abe White\n  */\n public class GetFieldInstruction extends FieldInstruction {\n+\n     GetFieldInstruction(Code owner, int opcode) {\n         super(owner, opcode);\n     }"},{"sha":"a36a0b26c7fd7f8f8dc286db787dc0a69c8972a8","filename":"serp/src/main/java/serp/bytecode/IIncInstruction.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/IIncInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/IIncInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IIncInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,19 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * The <code>iinc</code> instruction.\n- * \n+ *\n  * @author Abe White\n  */\n public class IIncInstruction extends LocalVariableInstruction {\n+\n     private int _inc = 0;\n \n     IIncInstruction(Code owner) {\n@@ -40,7 +44,7 @@ public int getIncrement() {\n \n     /**\n      * Set the increment on this IINC instruction.\n-     * \n+     *\n      * @return this Instruction, for method chaining\n      */\n     public IIncInstruction setIncrement(int val) {\n@@ -57,7 +61,7 @@ public boolean equalsInstruction(Instruction other) {\n             return false;\n \n         IIncInstruction ins = (IIncInstruction) other;\n-        return(getIncrement() == 0 || ins.getIncrement() == 0\n+        return (getIncrement() == 0 || ins.getIncrement() == 0\n             || getIncrement() == ins.getIncrement());\n     }\n "},{"sha":"3f98f7f62377f49b9a7aca344713186e782a38e4","filename":"serp/src/main/java/serp/bytecode/IfInstruction.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/IfInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/IfInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/IfInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,15 +12,15 @@\n  */\n package serp.bytecode;\n \n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * An if instruction such as <code>ifnull, ifeq</code>, etc.\n- * \n+ *\n  * @author Abe White\n  */\n public class IfInstruction extends JumpInstruction {\n+\n     IfInstruction(Code owner, int opcode) {\n         super(owner, opcode);\n     }\n@@ -31,38 +31,38 @@ public int getLogicalStackChange() {\n \n     public int getStackChange() {\n         switch (getOpcode()) {\n-        case Constants.IFACMPEQ:\n-        case Constants.IFACMPNE:\n-        case Constants.IFICMPEQ:\n-        case Constants.IFICMPNE:\n-        case Constants.IFICMPLT:\n-        case Constants.IFICMPGT:\n-        case Constants.IFICMPLE:\n-        case Constants.IFICMPGE:\n-            return -2;\n-        case Constants.IFEQ:\n-        case Constants.IFNE:\n-        case Constants.IFLT:\n-        case Constants.IFGT:\n-        case Constants.IFLE:\n-        case Constants.IFGE:\n-        case Constants.IFNULL:\n-        case Constants.IFNONNULL:\n-            return -1;\n-        default:\n-            return super.getStackChange();\n+            case Constants.IFACMPEQ:\n+            case Constants.IFACMPNE:\n+            case Constants.IFICMPEQ:\n+            case Constants.IFICMPNE:\n+            case Constants.IFICMPLT:\n+            case Constants.IFICMPGT:\n+            case Constants.IFICMPLE:\n+            case Constants.IFICMPGE:\n+                return -2;\n+            case Constants.IFEQ:\n+            case Constants.IFNE:\n+            case Constants.IFLT:\n+            case Constants.IFGT:\n+            case Constants.IFLE:\n+            case Constants.IFGE:\n+            case Constants.IFNULL:\n+            case Constants.IFNONNULL:\n+                return -1;\n+            default:\n+                return super.getStackChange();\n         }\n     }\n \n     public String getTypeName() {\n         switch (getOpcode()) {\n-        case Constants.IFACMPEQ:\n-        case Constants.IFACMPNE:\n-        case Constants.IFNULL:\n-        case Constants.IFNONNULL:\n-            return \"java.lang.Object\";\n-        default:\n-            return \"I\";\n+            case Constants.IFACMPEQ:\n+            case Constants.IFACMPNE:\n+            case Constants.IFNULL:\n+            case Constants.IFNONNULL:\n+                return \"java.lang.Object\";\n+            default:\n+                return \"I\";\n         }\n     }\n "},{"sha":"1cd9bfaaf831aeade02ec87f0b81b165d67a2f6b","filename":"serp/src/main/java/serp/bytecode/InnerClass.java","status":"modified","additions":21,"deletions":14,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InnerClass.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InnerClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClass.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,18 +12,25 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n-import serp.util.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ClassEntry;\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.lowlevel.UTF8Entry;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n+import serp.util.Strings;\n \n /**\n  * Any referenced class that is not a package member is represented by\n  * this structure. This includes member classes and interfaces.\n- * \n+ *\n  * @author Abe White\n  */\n public class InnerClass implements BCEntity, VisitAcceptor {\n+\n     private int _index = 0;\n     private int _nameIndex = 0;\n     private int _ownerIndex = 0;\n@@ -68,7 +75,7 @@ public void setAccessFlags(int accessFlags) {\n      * Manipulate the inner class access flags.\n      */\n     public boolean isPublic() {\n-        return(getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PUBLIC) > 0;\n     }\n \n     /**\n@@ -84,7 +91,7 @@ public void makePublic() {\n      * Manipulate the inner class access flags.\n      */\n     public boolean isProtected() {\n-        return(getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PROTECTED) > 0;\n     }\n \n     /**\n@@ -100,7 +107,7 @@ public void makeProtected() {\n      * Manipulate the inner class access flags.\n      */\n     public boolean isPrivate() {\n-        return(getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_PRIVATE) > 0;\n     }\n \n     /**\n@@ -116,7 +123,7 @@ public void makePrivate() {\n      * Manipulate the inner class access flags.\n      */\n     public boolean isFinal() {\n-        return(getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_FINAL) > 0;\n     }\n \n     /**\n@@ -133,7 +140,7 @@ public void setFinal(boolean on) {\n      * Manipulate the inner class access flags.\n      */\n     public boolean isStatic() {\n-        return(getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_STATIC) > 0;\n     }\n \n     /**\n@@ -150,7 +157,7 @@ public void setStatic(boolean on) {\n      * Manipulate the class access flags.\n      */\n     public boolean isInterface() {\n-        return(getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_INTERFACE) > 0;\n     }\n \n     /**\n@@ -168,7 +175,7 @@ public void setInterface(boolean on) {\n      * Manipulate the class access flags.\n      */\n     public boolean isAbstract() {\n-        return(getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n+        return (getAccessFlags() & Constants.ACCESS_ABSTRACT) > 0;\n     }\n \n     /**\n@@ -209,7 +216,7 @@ public void setNameIndex(int nameIndex) {\n     public String getName() {\n         if (getNameIndex() == 0)\n             return null;\n-        return((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n+        return ((UTF8Entry) getPool().getEntry(getNameIndex())).getValue();\n     }\n \n     /**\n@@ -328,7 +335,7 @@ public String getDeclarerName() {\n         if (getDeclarerIndex() == 0)\n             return null;\n \n-        ClassEntry entry = (ClassEntry) getPool().getEntry (getDeclarerIndex());\n+        ClassEntry entry = (ClassEntry) getPool().getEntry(getDeclarerIndex());\n         return getProject().getNameCache().getExternalForm\n             (entry.getNameEntry().getValue(), false);\n     }"},{"sha":"d260a2e7f713e24ed5bed73ba2898aa07322fc79","filename":"serp/src/main/java/serp/bytecode/InnerClasses.java","status":"modified","additions":24,"deletions":18,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InnerClasses.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InnerClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InnerClasses.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,17 +12,23 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Attribute describing all referenced classes that are not package\n  * members. This includes all member interfaces and classes.\n- * \n+ *\n  * @author Abe White\n  */\n public class InnerClasses extends Attribute {\n+\n     private List _innerClasses = new LinkedList();\n \n     InnerClasses(int nameIndex, Attributes owner) {\n@@ -33,7 +39,7 @@\n      * Return all referenced inner classes, or empty array if none.\n      */\n     public InnerClass[] getInnerClasses() {\n-        return(InnerClass[]) _innerClasses.toArray\n+        return (InnerClass[]) _innerClasses.toArray\n             (new InnerClass[_innerClasses.size()]);\n     }\n \n@@ -68,7 +74,7 @@ public InnerClass getInnerClass(String name) {\n                 || (inner != null && inner.equals(name)))\n                 matches.add(inners[i]);\n         }\n-        return(InnerClass[]) matches.toArray(new InnerClass[matches.size()]);\n+        return (InnerClass[]) matches.toArray(new InnerClass[matches.size()]);\n     }\n \n     /**\n@@ -85,7 +91,7 @@ public void setInnerClasses(InnerClass[] inners) {\n     /**\n      * Import an inner class from another entity, or make a copy of one\n      * on this entity.\n-     * \n+     *\n      * @return the newly added inner class\n      */\n     public InnerClass addInnerClass(InnerClass inner) {\n@@ -106,9 +112,9 @@ public InnerClass addInnerClass() {\n \n     /**\n      * Add an inner class.\n-     * \n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the full class name of the inner class\n+     *\n+     * @param name  the simple name of the class, or null if anonymous\n+     * @param type  the full class name of the inner class\n      * @param owner the declaring class, or null if not a member class\n      */\n     public InnerClass addInnerClass(String name, String type, String owner) {\n@@ -121,9 +127,9 @@ public InnerClass addInnerClass(String name, String type, String owner) {\n \n     /**\n      * Add an inner class.\n-     * \n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the class of the inner class\n+     *\n+     * @param name  the simple name of the class, or null if anonymous\n+     * @param type  the class of the inner class\n      * @param owner the declaring class, or null if not a member class\n      */\n     public InnerClass addInnerClass(String name, Class type, Class owner) {\n@@ -134,9 +140,9 @@ public InnerClass addInnerClass(String name, Class type, Class owner) {\n \n     /**\n      * Add an inner class.\n-     * \n-     * @param name the simple name of the class, or null if anonymous\n-     * @param type the class of the inner class\n+     *\n+     * @param name  the simple name of the class, or null if anonymous\n+     * @param type  the class of the inner class\n      * @param owner the declaring class, or null if not a member class\n      */\n     public InnerClass addInnerClass(String name, BCClass type, BCClass owner) {\n@@ -160,7 +166,7 @@ public void clear() {\n     /**\n      * Remove the inner class with the given name. Use null for anonymous\n      * classes.\n-     * \n+     *\n      * @return true if an inner class was removed, false otherwise\n      */\n     public boolean removeInnerClass(String name) {\n@@ -170,7 +176,7 @@ public boolean removeInnerClass(String name) {\n     /**\n      * Remove the given inner class. After being removed, the given inner\n      * class is invalid, and the result of any operations on it are undefined.\n-     * \n+     *\n      * @return true if the inner class was removed, false otherwise\n      */\n     public boolean removeInnerClass(InnerClass innerClass) {"},{"sha":"ae106c6b5463010de73c60d42af13680b1cf0900","filename":"serp/src/main/java/serp/bytecode/Instruction.java","status":"modified","additions":14,"deletions":10,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Instruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Instruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Instruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,17 +12,21 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n \n /**\n  * An opcode in a method of a class.\n- * \n+ *\n  * @author Abe White\n  */\n public class Instruction extends CodeEntry implements BCEntity, VisitAcceptor {\n+\n     private Code _owner = null;\n     private int _opcode = Constants.NOP;\n \n@@ -58,7 +62,7 @@ public int getOpcode() {\n \n     /**\n      * Set the opcode this instruction represents. For internal use only.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     Instruction setOpcode(int opcode) {\n@@ -80,7 +84,7 @@ public int getByteIndex() {\n     /**\n      * Return the line number of this instruction, or null if none. This\n      * method is subject to the validity constraints of {@link #getByteIndex}.\n-     * \n+     *\n      * @see LineNumberTable#getLineNumber(Instruction)\n      */\n     public LineNumber getLineNumber() {\n@@ -110,10 +114,10 @@ public int getLogicalStackChange() {\n     /**\n      * Return the number of stack positions this instruction pushes\n      * or pops during its execution.\n-     * \n+     *\n      * @return 0 if the stack is not affected by this instruction, a\n-     * positive number if it pushes onto the stack, and a negative\n-     * number if it pops from the stack\n+     *         positive number if it pushes onto the stack, and a negative\n+     *         number if it pops from the stack\n      */\n     public int getStackChange() {\n         return 0;"},{"sha":"8b094e3f70b42188170adea1db8f8514495c7a60","filename":"serp/src/main/java/serp/bytecode/InstructionPtr.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InstructionPtr.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InstructionPtr.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtr.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,14 +12,13 @@\n  */\n package serp.bytecode;\n \n-import java.util.*;\n-\n /**\n  * An entity that maintains ptrs to instructions in a code block.\n- * \n+ *\n  * @author Abe White\n  */\n public interface InstructionPtr {\n+\n     /**\n      * Use the byte indexes read from the class file to calculate and\n      * set references to the target instruction(s) for this ptr."},{"sha":"998f3ac3f9efb02b8e798be4437cd0c21604a22e","filename":"serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/InstructionPtrStrategy.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -17,11 +17,12 @@\n  * Instructions that InstructionPtrs point to. These strategies include,\n  * from least desirable to most desirable, using byte indexes,\n  * and storing a reference to the target Instruction proper.\n- * \n+ *\n  * @author Eric Lindauer\n  * @date 2002.7.26\n  */\n class InstructionPtrStrategy implements InstructionPtr {\n+\n     // the Instruction doing the targetting\n     private InstructionPtr _pointer;\n "},{"sha":"8e993d714d9d9796cd9ee8aabe53324946ac4b8e","filename":"serp/src/main/java/serp/bytecode/JumpInstruction.java","status":"modified","additions":42,"deletions":39,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/JumpInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/JumpInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/JumpInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,17 +12,20 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * An instruction that specifies a position in the code block to jump to.\n  * Examples include <code>go2, jsr</code>, etc.\n- * \n+ *\n  * @author Abe White\n  */\n public class JumpInstruction extends Instruction implements InstructionPtr {\n+\n     private InstructionPtrStrategy _target = new InstructionPtrStrategy(this);\n \n     JumpInstruction(Code owner, int opcode) {\n@@ -41,11 +44,11 @@ public int getStackChange() {\n \n     int getLength() {\n         switch (getOpcode()) {\n-        case Constants.GOTOW:\n-        case Constants.JSRW:\n-            return super.getLength() + 4;\n-        default:\n-            return super.getLength() + 2;\n+            case Constants.GOTOW:\n+            case Constants.JSRW:\n+                return super.getLength() + 4;\n+            default:\n+                return super.getLength() + 2;\n         }\n     }\n \n@@ -59,7 +62,7 @@ public Instruction getTarget() {\n     /**\n      * Set the instruction to jump to; the instruction must already be\n      * added to the code block.\n-     * \n+     *\n      * @return this instruction, for method chaining\n      */\n     public JumpInstruction setTarget(Instruction instruction) {\n@@ -79,7 +82,7 @@ public boolean equalsInstruction(Instruction other) {\n             return false;\n \n         Instruction target = ((JumpInstruction) other).getTarget();\n-        return(target == null || getTarget() == null || target == getTarget());\n+        return (target == null || getTarget() == null || target == getTarget());\n     }\n \n     public void updateTargets() {\n@@ -104,47 +107,47 @@ void read(DataInput in) throws IOException {\n         super.read(in);\n \n         switch (getOpcode()) {\n-        case Constants.GOTOW:\n-        case Constants.JSRW:\n-            setOffset(in.readInt());\n-            break;\n-        default:\n-            setOffset(in.readShort());\n+            case Constants.GOTOW:\n+            case Constants.JSRW:\n+                setOffset(in.readInt());\n+                break;\n+            default:\n+                setOffset(in.readShort());\n         }\n     }\n \n     void write(DataOutput out) throws IOException {\n         super.write(out);\n \n         switch (getOpcode()) {\n-        case Constants.GOTOW:\n-        case Constants.JSRW:\n-            out.writeInt(getOffset());\n-            break;\n-        default:\n-            out.writeShort(getOffset());\n+            case Constants.GOTOW:\n+            case Constants.JSRW:\n+                out.writeInt(getOffset());\n+                break;\n+            default:\n+                out.writeShort(getOffset());\n         }\n     }\n \n     void calculateOpcode() {\n         int offset;\n         switch (getOpcode()) {\n-        case Constants.GOTO:\n-        case Constants.GOTOW:\n-            offset = getOffset();\n-            if (offset < (2 << 16))\n-                setOpcode(Constants.GOTO);\n-            else\n-                setOpcode(Constants.GOTOW);\n-            break;\n-        case Constants.JSR:\n-        case Constants.JSRW:\n-            offset = getOffset();\n-            if (offset < (2 << 16))\n-                setOpcode(Constants.JSR);\n-            else\n-                setOpcode(Constants.JSRW);\n-            break;\n+            case Constants.GOTO:\n+            case Constants.GOTOW:\n+                offset = getOffset();\n+                if (offset < (2 << 16))\n+                    setOpcode(Constants.GOTO);\n+                else\n+                    setOpcode(Constants.GOTOW);\n+                break;\n+            case Constants.JSR:\n+            case Constants.JSRW:\n+                offset = getOffset();\n+                if (offset < (2 << 16))\n+                    setOpcode(Constants.JSR);\n+                else\n+                    setOpcode(Constants.JSRW);\n+                break;\n         }\n     }\n "},{"sha":"f84dee5e70b20890d50e0b91fe8c4fff552550ad","filename":"serp/src/main/java/serp/bytecode/LineNumber.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LineNumber.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LineNumber.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumber.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,19 +12,23 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.lowlevel.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import serp.bytecode.lowlevel.ConstantPool;\n+import serp.bytecode.visitor.BCVisitor;\n+import serp.bytecode.visitor.VisitAcceptor;\n \n /**\n  * A line number corresponds to a sequence of opcodes that map logically\n  * to a line of source code.\n- * \n+ *\n  * @author Abe White\n  */\n public class LineNumber\n     implements Comparable, InstructionPtr, BCEntity, VisitAcceptor {\n+\n     private int _line = 0;\n     private LineNumberTable _owner = null;\n "},{"sha":"1b776a483c2c2f2e39406834e1dfd710377f69ab","filename":"serp/src/main/java/serp/bytecode/LineNumberTable.java","status":"modified","additions":17,"deletions":11,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LineNumberTable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LineNumberTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LineNumberTable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331","patch":"@@ -12,19 +12,25 @@\n  */\n package serp.bytecode;\n \n-import java.io.*;\n-import java.util.*;\n-import serp.bytecode.visitor.*;\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import serp.bytecode.visitor.BCVisitor;\n \n /**\n  * Code blocks compiled from source have line number tables mapping\n  * opcodes to source lines. This table automatically maintains line\n  * numbers in ascending order by their start program counter position\n  * at all times.\n- * \n+ *\n  * @author Abe White\n  */\n public class LineNumberTable extends Attribute implements InstructionPtr {\n+\n     private List _lineNumbers = new ArrayList();\n \n     LineNumberTable(int nameIndex, Attributes owner) {\n@@ -36,7 +42,7 @@\n      */\n     public LineNumber[] getLineNumbers() {\n         Collections.sort(_lineNumbers);\n-        return(LineNumber[]) _lineNumbers.toArray\n+        return (LineNumber[]) _lineNumbers.toArray\n             (new LineNumber[_lineNumbers.size()]);\n     }\n \n@@ -47,7 +53,7 @@ public LineNumber getLineNumber(int pc) {\n         for (int i = _lineNumbers.size() - 1; i >= 0; i--)\n             if (((LineNumber) _lineNumbers.get(i)).\n                 _target.getByteIndex() <= pc)\n-                return(LineNumber) _lineNumbers.get(i);\n+                return (LineNumber) _lineNumbers.get(i);\n         return null;\n     }\n \n@@ -73,7 +79,7 @@ public void setLineNumbers(LineNumber[] lines) {\n \n     /**\n      * Import a line number from another method.\n-     * \n+     *\n      * @return the newly added line number\n      */\n     public LineNumber addLineNumber(LineNumber ln) {\n@@ -123,7 +129,7 @@ public void clear() {\n \n     /**\n      * Remove the given line.\n-     * \n+     *\n      * @return true if the line was removed, false otherwise\n      */\n     public boolean removeLineNumber(LineNumber ln) {\n@@ -136,7 +142,7 @@ public boolean removeLineNumber(LineNumber ln) {\n \n     /**\n      * Remove the line number for the given program counter.\n-     * \n+     *\n      * @return true if the line was removed, false otherwise\n      */\n     public boolean removeLineNumber(int pc) {\n@@ -145,7 +151,7 @@ public boolean removeLineNumber(int pc) {\n \n     /**\n      * Remove the line number for the given instruction.\n-     * \n+     *\n      * @return true if the line was removed, false otherwise\n      */\n     public boolean removeLineNumber(Instruction ins) {\n@@ -200,6 +206,6 @@ void write(DataOutput out, int length) throws IOException {\n     }\n \n     public Code getCode() {\n-        return(Code) getOwner();\n+        return (Code) getOwner();\n     }\n }"},{"sha":"401017d84678bdea2255470130c67a526d2414ef","filename":"serp/src/main/java/serp/bytecode/LoadInstruction.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LoadInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9ccb70befca02e0760021cf8c7a984c40fd23871","filename":"serp/src/main/java/serp/bytecode/Local.java","status":"modified","additions":9,"deletions":7,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Local.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Local.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Local.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"728098695003224d767a8aabb56de7c49a46af30","filename":"serp/src/main/java/serp/bytecode/LocalTable.java","status":"modified","additions":16,"deletions":12,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalTable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalTable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2a885fd02078c83f8fa5eb755b17816e0de87ff6","filename":"serp/src/main/java/serp/bytecode/LocalVariable.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"47cff4f019ae93a91c11809de40cf4d35e0246da","filename":"serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3b23db5ca279de892291c8e39916080b38b77dc5","filename":"serp/src/main/java/serp/bytecode/LocalVariableTable.java","status":"modified","additions":10,"deletions":9,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableTable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"790e246d3effd3739a6107063ad62dc53f637102","filename":"serp/src/main/java/serp/bytecode/LocalVariableType.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableType.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableType.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a34e8dea8db37ac72f4777a356c961dd9cfd132d","filename":"serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","status":"modified","additions":10,"deletions":9,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LocalVariableTypeTable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e917885bfb9dc7409df495747b3729cb58b50c84","filename":"serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","status":"modified","additions":23,"deletions":17,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/LookupSwitchInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"67a79da22631b16de72e27213ad4ae307e75b817","filename":"serp/src/main/java/serp/bytecode/MathInstruction.java","status":"modified","additions":108,"deletions":108,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MathInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"198ddd54c562787e3a2869f7cdd11f5e3353c05c","filename":"serp/src/main/java/serp/bytecode/MethodInstruction.java","status":"modified","additions":48,"deletions":42,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MethodInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MethodInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MethodInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f8687efb184351871b42b1d5b71464d66602e6af","filename":"serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorEnterInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3010d39f3e60ebd7275f94643eca7f92e83dc8ed","filename":"serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorExitInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"448249cfebb31590b8ff7a747d0969a726bfe852","filename":"serp/src/main/java/serp/bytecode/MonitorInstruction.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MonitorInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MonitorInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5a0475aa0904f98ec1cddcac326fbaf469928a34","filename":"serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/MultiANewArrayInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"571e1f8100d85e9ddd3d2bd263cae58f0039b0d2","filename":"serp/src/main/java/serp/bytecode/NameCache.java","status":"modified","additions":19,"deletions":14,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/NameCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/NameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NameCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f5374677289106fe998d8405351a518e68003e88","filename":"serp/src/main/java/serp/bytecode/NewArrayInstruction.java","status":"modified","additions":45,"deletions":42,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/NewArrayInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/NewArrayInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d0b83e81928b80265bdb6f07446e989b7b0594d9","filename":"serp/src/main/java/serp/bytecode/ObjectState.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ObjectState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ObjectState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ObjectState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"09031c9c0c36c381d6429ac3a400c1a469b16425","filename":"serp/src/main/java/serp/bytecode/PrimitiveState.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/PrimitiveState.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/PrimitiveState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PrimitiveState.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d7699300f6fc3c216473ac41d62a9085764e4fb7","filename":"serp/src/main/java/serp/bytecode/Project.java","status":"modified","additions":32,"deletions":26,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Project.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Project.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Project.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d467e871dd97af1dc8445615cd6585785cedcbcf","filename":"serp/src/main/java/serp/bytecode/PutFieldInstruction.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/PutFieldInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/PutFieldInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5421e1178f9d5024daa54928aa268a4a55c86dae","filename":"serp/src/main/java/serp/bytecode/RetInstruction.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/RetInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/RetInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/RetInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2f0c740d0fd7f378465ec4f9b9fab2c520c2ac89","filename":"serp/src/main/java/serp/bytecode/ReturnInstruction.java","status":"modified","additions":43,"deletions":44,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ReturnInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/ReturnInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/ReturnInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"973ffbd1536b1bc0e476c0cf62a6f0e55a617ac8","filename":"serp/src/main/java/serp/bytecode/SourceFile.java","status":"modified","additions":12,"deletions":6,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/SourceFile.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/SourceFile.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SourceFile.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"737d91f64ccc8f4fe596e7627f0bbd673c6be0bf","filename":"serp/src/main/java/serp/bytecode/StackInstruction.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/StackInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/StackInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StackInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a90f77a5747f48461dc98b38316a6d5c3c03ca9a","filename":"serp/src/main/java/serp/bytecode/State.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/State.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/State.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/State.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ab430b03db3d4981e62590a81af13d0ec467e19b","filename":"serp/src/main/java/serp/bytecode/StoreInstruction.java","status":"modified","additions":129,"deletions":120,"changes":249,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/StoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/StoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/StoreInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ad21c7b4b4de0cd2d656f4f8d83a8dcf65bfed8a","filename":"serp/src/main/java/serp/bytecode/SwitchInstruction.java","status":"modified","additions":15,"deletions":14,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/SwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/SwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/SwitchInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3baea0e19adc4aa9b2c767b9533a9fe941cb50ee","filename":"serp/src/main/java/serp/bytecode/Synthetic.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Synthetic.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/Synthetic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/Synthetic.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8f29d6dd7e2e88a2364930cc383336be692a73f0","filename":"serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","status":"modified","additions":20,"deletions":14,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TableSwitchInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ac21c5169260024195500fd3842b01567260aa44","filename":"serp/src/main/java/serp/bytecode/TypedInstruction.java","status":"modified","additions":16,"deletions":13,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/TypedInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/TypedInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/TypedInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8c69a8cba118b6e5e56f6801f9706c3879863c22","filename":"serp/src/main/java/serp/bytecode/UnknownAttribute.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/UnknownAttribute.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/UnknownAttribute.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/UnknownAttribute.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"35676396b404543208ce3b42f0e34e525b60cbc7","filename":"serp/src/main/java/serp/bytecode/WideInstruction.java","status":"modified","additions":120,"deletions":106,"changes":226,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/WideInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/WideInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/WideInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"262bda13961d6be722fc1ea4ea0fbd88b3b61167","filename":"serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","status":"modified","additions":10,"deletions":6,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ClassEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"c92a5ceca6a28d9fa352d33bdf2b078cb5dce779","filename":"serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","status":"modified","additions":11,"deletions":8,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ComplexEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"95bc86861f4f1434976363797dbc8dcde9d1e269","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"0a332ec4d594fd899c42e6d93988a06de9c1b5e5","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","status":"modified","additions":119,"deletions":100,"changes":219,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPool.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9f986646196be8fc8e9b91e93e7aee450a759df6","filename":"serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","status":"modified","additions":28,"deletions":24,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/ConstantPoolTable.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8ce8119cdce008a2bed8d21665f9488e8eaf6d6c","filename":"serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/DoubleEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a1f97e4f6cd17b39009b557da4e0df4064fe5bdc","filename":"serp/src/main/java/serp/bytecode/lowlevel/Entry.java","status":"modified","additions":32,"deletions":29,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/Entry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5ae7a7e43af4b6c9090dde74a64750c6061a95fa","filename":"serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FieldEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9a0698a4d33a2a2e9461341333762e123156868c","filename":"serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/FloatEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6afa0011a025916a62daf44fe8fae881687c1f35","filename":"serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/IntEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"7e28c7abb2f6ca4734436f6758f698d6644fdeed","filename":"serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/InterfaceMethodEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"d823ffbf8fc6e0d3bb6f3fb2b030c60877b5eb74","filename":"serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","status":"modified","additions":9,"deletions":5,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/LongEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"25a19a0fe35c505b4a054495243851e14e63470f","filename":"serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/MethodEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"54fcb8b63c7e158ad75ea4c12465c774449829a2","filename":"serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/NameAndTypeEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e9f55a1e238ef2e5e72e72c4627eee8d40c15a2f","filename":"serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","status":"modified","additions":10,"deletions":6,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/StringEntry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ccd1d7d879eb8ed0ceea72530068df937da11912","filename":"serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/UTF8Entry.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6047536ec192c1c177b12be283cb7923de458f23","filename":"serp/src/main/java/serp/bytecode/lowlevel/package.html","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/lowlevel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/lowlevel/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"9a4c00d451d7249a40d48a69551422452e591fea","filename":"serp/src/main/java/serp/bytecode/package.html","status":"modified","additions":141,"deletions":135,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"825387d169e87fe6967fd0bee70ff1dde4830d0b","filename":"serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","status":"modified","additions":15,"deletions":3,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/BCVisitor.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"781b12cdab9b9af786d12072ab22943e1eaa1a45","filename":"serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","status":"modified","additions":20,"deletions":4,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/PrettyPrintVisitor.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"5e3c408b59c6309c2dde47898d9b81853da419ed","filename":"serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/VisitAcceptor.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ea3ee7657e079cb30ed2e892fa608f4412fb9f91","filename":"serp/src/main/java/serp/bytecode/visitor/package.html","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/bytecode/visitor/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/bytecode/visitor/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"91bccc8cffc619e492911ef6d1751e07a59f4269","filename":"serp/src/main/java/serp/util/Numbers.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/Numbers.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/Numbers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Numbers.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"8e37f3d86e3057fff68cfcc49d76a2be5a8c6060","filename":"serp/src/main/java/serp/util/Strings.java","status":"modified","additions":25,"deletions":21,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/Strings.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/Strings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/Strings.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"94ac73a0d5dc5cbd055311597d94223d32b2360b","filename":"serp/src/main/java/serp/util/package.html","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/main/java/serp/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/main/java/serp/util/package.html?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"adfb3f17292a3dfb4a956c67ad2df43ae5d04f06","filename":"serp/src/test/java/serp/bytecode/AbstractStateTest.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/AbstractStateTest.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/AbstractStateTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/AbstractStateTest.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"34619ead5a4f89d964f5c923e02e45d34a4dc0c2","filename":"serp/src/test/java/serp/bytecode/TestArray.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArray.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArray.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArray.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"f9c38f615af44ccb24f5e78d03d1408ecdf723b7","filename":"serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayLoadInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"74590a9fc40d90967d31fc856da8de4fbcfe0259","filename":"serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestArrayStoreInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a275153a8b06aeab8cc3e985b01b3ec6655b9531","filename":"serp/src/test/java/serp/bytecode/TestAttributes.java","status":"modified","additions":8,"deletions":5,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestAttributes.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestAttributes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestAttributes.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"84a3d40e2a6d4d4b6586558e88f23b4d2a5bc42b","filename":"serp/src/test/java/serp/bytecode/TestBCClass.java","status":"modified","additions":13,"deletions":6,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestBCClass.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestBCClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestBCClass.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"70fc70d53b0a0ba67faae5f8d1b7f91b186ca839","filename":"serp/src/test/java/serp/bytecode/TestCode.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestCode.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestCode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestCode.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b7d073613efa6e21d41179263b1670694c940e4b","filename":"serp/src/test/java/serp/bytecode/TestConstantInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestConstantInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConstantInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"a4b025dfe54fc1a58e15f851864f56c0ce25ba82","filename":"serp/src/test/java/serp/bytecode/TestConvertInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestConvertInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestConvertInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"2f04c26d54269e5d7994619acb2e83e942cb1109","filename":"serp/src/test/java/serp/bytecode/TestLoadInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestLoadInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestLoadInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"ef3a2a4b8ebe4b019f0d8affc378b2c6ceaa45ac","filename":"serp/src/test/java/serp/bytecode/TestMathInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestMathInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestMathInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestMathInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"b201097b01bce30443414059fa043e354245b607","filename":"serp/src/test/java/serp/bytecode/TestNameCache.java","status":"modified","additions":8,"deletions":5,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestNameCache.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestNameCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestNameCache.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"71072ea94651878b6a02b15151dd4ea22358fd35","filename":"serp/src/test/java/serp/bytecode/TestPrimitive.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestPrimitive.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestPrimitive.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestPrimitive.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"621c163b018c31f50917239338969c2984d93f8b","filename":"serp/src/test/java/serp/bytecode/TestProject.java","status":"modified","additions":17,"deletions":12,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestProject.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestProject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestProject.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"3e0529987069aa3ad45e2e0752b1eef762202ca0","filename":"serp/src/test/java/serp/bytecode/TestStoreInstruction.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/TestStoreInstruction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/TestStoreInstruction.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"e68844dc1f838d05721e074e7f17ef1d81023e01","filename":"serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/bytecode/lowlevel/TestConstantPool.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"},{"sha":"6fd7102a305357ee708a7d58bd9b8af23684c5ba","filename":"serp/src/test/java/serp/util/TestStrings.java","status":"modified","additions":15,"deletions":12,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/util/TestStrings.java","raw_url":"https://github.com/apache/openjpa/raw/1fede626e2cad16f7bb4d77dd9fc3270a8b6b331/serp/src/test/java/serp/util/TestStrings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/serp/src/test/java/serp/util/TestStrings.java?ref=1fede626e2cad16f7bb4d77dd9fc3270a8b6b331"}]}

