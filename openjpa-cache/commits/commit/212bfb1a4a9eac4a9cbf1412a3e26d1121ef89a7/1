{"sha":"212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7","node_id":"MDY6Q29tbWl0MjA2MzY0OjIxMmJmYjFhNGE5ZWFjNGE5Y2JmMTQxMmEzZTI2ZDExMjFlZjg5YTc=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-08-14T18:37:41Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-08-14T18:37:41Z"},"message":"OPENJPA-1752: TestPessimisticLocks JUNIT test produced inconsistent behavior with various backends.\nSubmitted By: Catalina Wei\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/2.0.x@985560 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b631f3318eb90305906acf9011f186999f40e123","url":"https://api.github.com/repos/apache/openjpa/git/trees/b631f3318eb90305906acf9011f186999f40e123"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7","html_url":"https://github.com/apache/openjpa/commit/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"0a0d7f78100b5b6243751a66d1f4d6ed59ebaa0b","url":"https://api.github.com/repos/apache/openjpa/commits/0a0d7f78100b5b6243751a66d1f4d6ed59ebaa0b","html_url":"https://github.com/apache/openjpa/commit/0a0d7f78100b5b6243751a66d1f4d6ed59ebaa0b"}],"stats":{"total":72,"additions":47,"deletions":25},"files":[{"sha":"e154e55c58080ce6d6b1db0aad40959f580710c8","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","status":"modified","additions":47,"deletions":25,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","raw_url":"https://github.com/apache/openjpa/raw/212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java?ref=212bfb1a4a9eac4a9cbf1412a3e26d1121ef89a7","patch":"@@ -45,6 +45,7 @@\n public class TestPessimisticLocks extends SQLListenerTestCase {\n \n     private DBDictionary dict = null;\n+    private int lockWaitTime = 2000;\n \n     public void setUp() {\n         // Disable tests for any DB that has supportsQueryTimeout==false, like Postgres\n@@ -53,7 +54,7 @@ public void setUp() {\n             tempEMF = createEMF();\n         }\n         assertNotNull(tempEMF);\n-        DBDictionary dict = ((JDBCConfiguration)tempEMF.getConfiguration()).getDBDictionaryInstance();\n+        dict = ((JDBCConfiguration)tempEMF.getConfiguration()).getDBDictionaryInstance();\n         assertNotNull(dict);\n         if (!dict.supportsQueryTimeout)\n             setTestsDisabled(true);\n@@ -111,22 +112,25 @@ public void testFindAfterQueryWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Employee> employees = query.getResultList();\n         assertEquals(\"Expected 1 element with emplyee id=2\", employees.size(), 1);\n         assertTrue(\"Test Employee first name = 'first.2'\", employees.get(0).getFirstName().equals(\"first.1\")\n                 || employees.get(0).getFirstName().equals(\"first.2\"));\n \n         em2.getTransaction().begin();\n         Map<String, Object> hints = new HashMap<String, Object>();\n-        hints.put(\"javax.persistence.lock.timeout\", 2000);\n+        hints.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, should block and expected a\n         // PessimisticLockException\n         try {\n             em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, hints);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n-        } catch (Throwable e) {\n-            assertError(e, PessimisticLockException.class);\n+        } catch (Throwable e) {            \n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else \n+                assertError(e, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -140,15 +144,15 @@ public void testFindAfterQueryWithPessimisticLocks() {\n         // Lock all selected Departments, skip the first one, i.e should\n         // lock Department(20)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Department> depts = query2.getResultList();\n         assertEquals(\"Expected 1 element with department id=20\", depts.size(), 1);\n         assertTrue(\"Test department name = 'D20'\", depts.get(0).getName().equals(\"D10\")\n                 || depts.get(0).getName().equals(\"D20\"));\n \n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, no block since only department was\n         // locked\n         try {\n@@ -178,21 +182,24 @@ public void testFindAfterQueryOrderByWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Employee> q = query.getResultList();\n         assertEquals(\"Expected 1 element with emplyee id=2\", q.size(), 1);\n         assertEquals(\"Test Employee first name = 'first.2'\", q.get(0).getFirstName(), \"first.2\");\n \n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, should block and expected a\n         // PessimisticLockException\n         try {\n             em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else\n+                assertError(e, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -206,22 +213,25 @@ public void testFindAfterQueryOrderByWithPessimisticLocks() {\n         // Lock all selected Departments, skip the first one, i.e should\n         // lock Department(20)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Department> result = query.getResultList();\n         assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n         assertEquals(\"Test department name = 'D20'\", result.get(0).getName(), \"D20\");\n \n         em2.getTransaction().begin();\n         map.clear();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, no block since only department was\n         // locked\n         try {\n             Employee emp = em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n             assertNotNull(\"Query locks department only, therefore should find Employee.\", emp);\n             assertEquals(\"Test Employee first name = 'first.1'\", emp.getFirstName(), \"first.1\");\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithOrderClause)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else \n+                assertError(ex, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -241,22 +251,25 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         try {\n             em2.getTransaction().begin();\n             Map<String, Object> map = new HashMap<String, Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n+            map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n             // Lock Emplyee(1), no department should be locked\n             em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n \n             em1.getTransaction().begin();\n             Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10\").setFirstResult(1);\n             query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n+            query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n             // Lock all selected Department but skip the first, i.e. lock\n             // Department(20), should query successfully.\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertTrue(\"Test department name = 'D20'\", q.get(0).getName().equals(\"D10\")\n                     || q.get(0).getName().equals(\"D20\"));\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithMultipleTables)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else\n+                assertError(ex, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -267,7 +280,7 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         em2.getTransaction().begin();\n \n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(2), no department should be locked\n         em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n \n@@ -276,12 +289,15 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 1000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         try {\n             List<Employee> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else\n+                assertError(e, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -300,23 +316,26 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         EntityManager em2 = emf.createEntityManager();\n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(1), no department should be locked\n         em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n \n         em1.getTransaction().begin();\n         Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10 order by e.department.id\")\n                 .setFirstResult(1);\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         // Lock all selected Department but skip the first, i.e. lock\n         // Department(20), should query successfully.\n         try {\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertEquals(\"Test department name = 'D20'\", q.get(0).getName(), \"D20\");\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithMultipleTables)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else \n+                assertError(ex, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -327,7 +346,7 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         em2.getTransaction().begin();\n \n         map.clear();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(2), no department should be locked\n         em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n \n@@ -336,12 +355,15 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         try {\n             List<?> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else \n+                assertError(e, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();"}]}

