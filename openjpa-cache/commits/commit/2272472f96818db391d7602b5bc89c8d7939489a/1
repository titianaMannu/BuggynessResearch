{"sha":"2272472f96818db391d7602b5bc89c8d7939489a","node_id":"MDY6Q29tbWl0MjA2MzY0OjIyNzI0NzJmOTY4MThkYjM5MWQ3NjAyYjViYzg5YzhkNzkzOTQ4OWE=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-19T18:40:34Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-19T18:40:34Z"},"message":"Rollback query parameter validation, temporal type conversion, eager query compilation and duplicate NamedQuery annotation changes from 1.2.x branch\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@687120 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a724e87824a4e3352017169adb460df9ead6eae5","url":"https://api.github.com/repos/apache/openjpa/git/trees/a724e87824a4e3352017169adb460df9ead6eae5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/2272472f96818db391d7602b5bc89c8d7939489a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/2272472f96818db391d7602b5bc89c8d7939489a","html_url":"https://github.com/apache/openjpa/commit/2272472f96818db391d7602b5bc89c8d7939489a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/2272472f96818db391d7602b5bc89c8d7939489a/comments","author":null,"committer":null,"parents":[{"sha":"d147f40cecdb8fa771ffbf656743400a4357afc5","url":"https://api.github.com/repos/apache/openjpa/commits/d147f40cecdb8fa771ffbf656743400a4357afc5","html_url":"https://github.com/apache/openjpa/commit/d147f40cecdb8fa771ffbf656743400a4357afc5"}],"stats":{"total":1816,"additions":549,"deletions":1267},"files":[{"sha":"81b2cb2e5494b63a1c51c33cc4b084ad4fba4052","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","status":"modified","additions":1,"deletions":19,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -28,10 +28,8 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -120,17 +118,13 @@ private static String substituteParams(String sql, List params)\n             }\n         }\n \n-        int distinctParams = countDistinct(paramOrder);\n-        if (params.size() < distinctParams)\n-        \tthrow new UserException(_loc.get(\"sqlquery-fewer-params\", \n-        \t\tnew Object[] {sql, distinctParams, params.size(), params}));\n         // now go through the paramOrder list and re-order the params array\n         List translated = new ArrayList();\n         for (Iterator i = paramOrder.iterator(); i.hasNext();) {\n             int index = ((Number) i.next()).intValue() - 1;\n             if (index >= params.size())\n                 throw new UserException(_loc.get(\"sqlquery-missing-params\",\n-                    sql, String.valueOf(index+1), params));\n+                    sql, String.valueOf(index), params));\n             translated.add(params.get(index));\n         }\n \n@@ -139,18 +133,6 @@ private static String substituteParams(String sql, List params)\n         params.addAll(translated);\n         return buf.toString();\n     }\n-    \n-    static int countDistinct(List list) {\n-    \tif (list == null || list.isEmpty())\n-    \t\treturn 0;\n-    \tint distinct = 0;\n-    \tSet set = new HashSet();\n-    \tfor (Object o : list) {\n-    \t\tif (set.add(o))\n-    \t\t\tdistinct++;\n-    \t}\n-    \treturn distinct;\n-    }\n \n     public boolean supportsParameterDeclarations() {\n         return false;"},{"sha":"5c918cd85318cbd7821ef97cce57a87f0a12d686","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -22,8 +22,6 @@ mult-mapping-aggregate: Cannot perform an aggregate query on a hierarchy with \\\n \tunjoined subclasses: {0}\n sqlquery-missing-params: SQL query \"{0}\" declares a parameter index \"{1}\" for \\\n \twhich no value was given.  The given parameters were: {2}\n-sqlquery-fewer-params: SQL query \"{0}\" declares {1} distinct parameter(s), \\\n-\tbut only {2} parameters are given. Given parameter values are \"{3}\".  \n no-sql: You have not specified a SQL filter to execute in your SQL query.\n del-ins-cycle: An unresolvable constraint cycle was detected.  This typically \\\n \tmeans that you are persisting a new object with the same primary key value \\"},{"sha":"b23f5b90bb923c46a1af6e0559ff852a0f120f46","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":1,"deletions":5,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -908,11 +908,7 @@ public long updateAll(Map params) {\n             else if (key instanceof Number) {\r\n                 if (base == -1)\r\n                     base = positionalParameterBase(params.keySet());\r\n-                int arrayIndex = ((Number) key).intValue() - base;\r\n-                if (arrayIndex >= arr.length)\r\n-                \tthrow new UserException(_loc.get(\"gap-query-param\", \r\n-                \t\tnew Object[]{_query, key, params.size(), params}));\r\n-                arr[arrayIndex] = entry.getValue();\r\n+                arr[((Number) key).intValue() - base] = entry.getValue();\r\n             } else\r\n                 throw new UserException(_loc.get(\"bad-param-name\", key));\r\n         }\r"},{"sha":"1b5845769d80a1ba85922d93ec1d8be73f420fcf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":2,"deletions":19,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -1618,15 +1618,10 @@ private QueryMetaData getQueryMetaDataInternal(Class cls, String name,\n         ClassLoader envLoader) {\n         if (name == null)\n             return null;\n-        QueryMetaData qm = null;\n-        if (cls == null) {\n-        \tqm = searchQueryMetaDataByName(name);\n-        \tif (qm != null)\n-        \t\treturn qm;\n-        }\n+\n         // check cache\n         Object key = getQueryKey(cls, name);\n-        qm = (QueryMetaData) _queries.get(key);\n+        QueryMetaData qm = (QueryMetaData) _queries.get(key);\n         if (qm != null)\n             return qm;\n \n@@ -1699,18 +1694,6 @@ public synchronized boolean removeQueryMetaData(Class cls, String name) {\n             return false;\n         return _queries.remove(getQueryKey(cls, name)) != null;\n     }\n-    \n-    /**\n-     * Searches all cached query metadata by name. \n-     */\n-    public QueryMetaData searchQueryMetaDataByName(String name) {\n-    \tfor (Object key : _queries.keySet()) {\n-    \t\tif (key instanceof QueryKey)\n-    \t\t\tif (StringUtils.equals(((QueryKey)key).name, name))\n-    \t\t\t\treturn (QueryMetaData)_queries.get(key);\n-    \t}\n-    \treturn null;\n-    }\n \n     /**\n      * Return a unique key for a given QueryMetaData."},{"sha":"985d7de11dbaa70307fbd8eb0bbb374b467406f5","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":402,"deletions":405,"changes":807,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -1,405 +1,402 @@\n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-#\n-# http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.  \n-\n-cant-convert-result: There is no conversion between query projection type \\\n-\t\"{0}\" and result type \"{1}\".\n-unloaded-detached: Attempt to access an unloaded field of detached instance \\\n-\t\"{0}\".\n-meta-unknownid: Cannot manipulate identity of type \"{0}\": it''s identity type \\\n-\tis unknown.\n-new-abstract: Cannot create an instance of \"{0}\": abstract classes are not \\\n-    yet supported.\n-bad-new-query: Attempt to construct a query from an extent or class.  You must \\\n-\tpass a (possibly null) query string or template to the query factory \\\n-\tmethod when creating the query. \n-update-restrict: Detected attempt to modify field \"{0}\" with value strategy \\\n-\t\"restrict\".\n-reentrant-flush: Detected reentrant flush.  Make sure your flush-time instance \\\n-\tcallback methods or event listeners do not invoke any operations that \\\n-\trequire the in-progress flush to complete.\n-rolled-back: The transaction has been rolled back.  See the nested exceptions \\\n-\tfor details on the errors that occurred.\n-bad-lock-level: This lock manager does not recognize lock level \"{0}\".\n-pessimistic-mutate: You are attempting to directly mutate a persistent second \\\n-\tclass object (such as a collection or map field) that you obtained before \\\n-\tthe transaction began.  After beginning a datastore transaction, you \\\n-\tmust re-obtain any references to mutable second class objects from the \\\n-\towning persistent object.  Detected attempt to mutate value of field \"{0}\" \\\n-\tin instance \"{1}\".  This instance may not be locked correctly.\n-not-derefed: Encountered unknown dependent instance \"{0}\".  This error is \\\n-\toften caused by either removing a dependent instance from one dependent \\\n-\tfield, but not other dependent fields that reference it, or by removing a \\\n-\tdependent instance from its owning field, flushing \\\n-\t(causing the unreferenced dependent instance to be deleted), and then \\\n-\ttrying to assign the deleted instance to another field before commit.  \\\n-\tThe instance cannot be un-deleted, resulting in an error.  Make sure not \\\n-\tto leave dangling dependent references to objects, and to reassign \\\n-\tdependent objects before flush so that OpenJPA does not think they are \\\n-\tunreferenced and therefore safe to delete.\n-init-null-pc: Attempt to initialize a state manager with a null \\\n-\tpersistence-capable instance for type \"{0}\".  This is often caused by \\\n-\tattempting to load an instance of an abstract class, or \\\n-\tneglecting to use a class indicator when the base persistence-capable \\\n-\tclass in an inheritance tree is abstract.\n-init-sm-pc: Attempt to initialize a state manager with an instance that is \\\n-\talready managed (\"{0}\").  You might be trying to persist this instance \\\n-\tin two threads at the same time.\n-bad-ds-oid: The type \"{0}\" declares datastore identity but the value \\\n-\tpassed to lookup of type \"{1}\" is not a OpenJPA id instance.\n-null-oids: Some of the object ids passed to getObjectsById were null.\n-marked-rollback: The transaction cannot be committed, because it was already \\\n-\tmarked for rollback only.  The transaction will be rolled back instead. \\\n-    The cause of the rollback-only status is reported in the embedded stack.\n-refresh-flushed: You cannot refresh an instance that has been flushed to the \\\n-\tdata store.\n-pc-loader-different: Attempt to cast instance \"{0}\" to PersistenceCapable failed. \\\n-    The object implemented org.apache.openjpa.enhance.PersistenceCapable, \\\n-    but the instance of that interface was loaded by two different ClassLoaders: \\\n-    \"{1}\" and \"{2}\".\n-pc-cast: Attempt to cast instance \"{0}\" to PersistenceCapable failed.  Ensure \\\n-\tthat it has been enhanced.\n-del-instance: The instance of type \"{0}\" with oid \"{1}\" no longer exists in \\\n-\tthe data store.  This may mean that you deleted the instance in a separate \\\n-\ttransaction, but this context still has a cached version.\n-no-broker-class: The specified type \"{0}\" could not be loaded. Please ensure \\\n-\tthat the class exists in the project class path.\n-bad-embed: Attempt to set an embedded value for unembeddable field \"{0}\". \\\n-\tPlease report this error to OpenJPA support.\n-embed-ref: You are attempting to access an embedded object reference \\\n-\tthat was obtained before the last transaction status change. After \\\n-\ttransactions begin and end, all references to embedded objects become \\\n-\tinvalid; you have to re-acquire the reference from the owning persistent \\\n-\tobject.\n-deleted: Operation attempted on a deleted instance.\n-dirty: Illegal operation attempted on a dirty instance: dirty objects cannot \\\n-\tbe evicted or made transient or non-transactional.\n-nested-exceps: This operation failed for some instances.  See the nested \\\n-\texceptions array for details.\n-new: Illegal operation attempted on a newly persisted instance: new objects \\\n-\tcannot be evicted or made transient or non-transactional.\n-transient: Illegal operation attempted on a transient instance.\n-not-active: Can only perform operation while a transaction is active.\n-trans-active: The \"{0}\" transaction property cannot be set during an \\\n-\tactive transaction.\n-active: This operation cannot be performed while a Transaction is active.\n-closed: The context has been closed.  The stack trace at which the \\\n-\tcontext was closed is held in the embedded exception.\n-closed-notrace: The context has been closed.  The stack trace at which the \\\n-\tcontext was closed is available if Runtime=TRACE logging is enabled.\n-closed-factory: The factory has been closed.  The stack trace at \\\n-\twhich the factory was closed is held in the embedded exception.\n-closed-factory-notrace: The factory has been closed.  The stack trace at \\\n-\twhich the factory was closed is available if Runtime=TRACE logging is \\\n-\tenabled.\n-non-trans-read: To perform reads on persistent data outside of a transaction, \\\n-\tthe \"NontransactionalRead\" property must be set on the Transaction.\n-non-trans-write: To perform writes on persistent data outside of a \\\n-\ttransaction, the \"NontransactionalWrite\" property must be set to true.\n-write-operation: To perform this operation, it must be written within a transaction, \\\n-\tor your settings must allow nontransactional writes and must not detach \\\n-\tall nontransactional reads.\n-not-managed: The given instance \"{0}\" is not managed by this context.\n-trans-not-managed: This broker is not configured to use managed transactions.\n-bad-detached-op: You cannot perform operation {0} on detached object \"{1}\". \\\n-\tThis operation only applies to managed objects.\n-persist-detached: Attempt to persist detached object \"{0}\".  If this is a new \\\n-  instance, make sure any version and/or auto-generated primary key fields are \\\n-  null/default when persisting.\n-null-value: The field \"{0}\" of instance \"{1}\" contained a null value; \\\n-\tthe metadata for this field specifies that nulls are illegal.\n-change-identity: Attempt to change a primary key field of an instance that \\\n-\talready has a final object id.  Only new, unflushed instances whose id you \\\n-\thave not retrieved can have their primary keys changed.\n-managed-oid: You cannot assign managed object \"{0}\" to the primary key field \\\n-\tof \"{1}\".  Embedded primary key values must be transient objects.\n-changed-oid: You have modified the object id field of \"{2}\".  Its old value \\\n-\twas \"{0}\", and its new value is \"{1}\".  Object id fields are immutable \\\n-\tonce the object id of the instance has been assigned. \n-cache-exists: An object of type \"{0}\" with oid \"{1}\" already exists in this \\\n-\tcontext; another cannot be persisted.\n-null-trans: Attempt to commit a null javax.transaction.Transaction.  Some \\\n-\tapplication servers set the transaction to null if a rollback occurs.\n-end-trans-error: An exception occurred while ending the transaction.  This \\\n-\texception will be re-thrown.\n-not-bound: The file named \"{0}\" could not be found.\n-naming-exception: A NamingException was thrown while obtaining the \\\n-\tfactory at \"{0}\" from JNDI.\n-attach-deleted: The object \"{0}\" with id \"{1}\" has been deleted and \\\n-\tcannot be attached.\n-not-detachable: The class \"{0}\" does not declare the \"detachable\" metadata \\\n-\textension, so cannot be detached.\n-not-copyable: Attempt to copy field \"{0}\" failed.  The field is \\\n-\tnot copyable.  This can occur with custom SCO types. Only standard or \\\n-    immutable SCO types can be attached and detached.\n-no-detach-object-id: Cannot access the detached object id of class \"{0}\". \\\n-\tEnsure that the class has the \"detachable\" metadata extension, and \\\n-\tthe the class has been re-enhanced.\n-attach-version-del: Attempted to attach deleted instance type \"{0}\" with oid \\\n-\t\"{1}\".  If the instance is new, the version field should be left to its \\\n-\tdefault value.\n-attach-wrongclass: Attempted to attach instance \"{0}\" of type \"{1}\", but this \\\n-\tinstance is already in the datastore as type \"{2}\".\n-sjvm-acquired-lock: Acquired an exclusive lock \"{0}\" on oid \"{1}\".\n-sjvm-released-lock: Released lock \"{0}\".\n-conn-not-supported: This data store cannot return connections.\n-incremental-flush-not-supported: This data store does not support incremental \\\n-\tflushing.  If you got this error while performing a query, make sure that \\\n-\tyou have not set the FlushBeforeQueries option to true, either by \\\n-\tsetting that option in your configuration file, or by programmatically \\\n-\tsetting the current FetchConfiguration''s FlushBeforeQueries property \\\n-\tto QueryFlushModes.FLUSH_TRUE.\n-nontrans-read-not-supported: This data store does not support nontransactional \\\n-\treads.  Set the NontransactionalRead property to false.\n-optimistic-not-supported: This datastore does not support optimistic \\\n-\ttransactions.  Set the Optimistic property to false.\n-restore-unset: The RestoreValues option is off, so initial values are \\\n-\tnot available. Turn on RestoreValues to be able to obtain initial \\\n-\tvalues.\n-mutable-restore-unset: The RestoreValues option is not set to \"all\", \\\n-\tinitial values of mutable fields are not available. Set RestoreValues to \\\n-\t\"all\" in your properties to be able to obtain initial mutable values.\n-initial-unloaded: OpenJPA cannot provide the initial value for field \"{0}\" \\\n-\tbecause the field was never loaded before being changed.\n-dup-oid-assign: Attempt to assign id \"{0}\" to new instance \"{1}\" failed; \\\n-\tthere is already an object in the L1 cache with this id. \\\n-\tYou must delete this object (in a previous transaction or the current one) \\\n-\tbefore reusing its id.  This error can also occur when a horizontally \\\n-\tor vertically mapped classes uses auto-increment application identity and \\\n-\tdoes not use a hierarchy of application identity classes.\n-dup-load: Cannot load object with id \"{0}\".  Instance \"{1}\" with the same id \\\n-\talready exists in the L1 cache.  This can occur when you \\\n-\tassign an existing id to a new instance, and before flushing attempt to \\\n-\tload the existing instance for that id.\n-bad-id-value: The given value \"{0}\" cannot be converted into an identity \\\n-\tfor \"{2}\".  The value is the wrong type ({1}).\n-factory-init: Starting OpenJPA {0}\n-factory-properties: Properties: {0}\n-inverse-consistency: An inverse inconsistency in the object featureSelection was \\\n-\tdetected while flushing the field \"{0}\" of the instance with id \"{1}\" \\\n-\tin context \"{2}\".\n-no-brokerfactory: You did not name the factory class with the required \\\n-\tproperty openjpa.BrokerFactory.  Normally this property defaults \\\n-    appropriately; have you forgotten to include all the OpenJPA jars in your \\\n-    classpath?\n-brokerfactory-excep: There was an error when invoking the static \\\n-\tgetInstance method on the named factory class \"{0}\".  See the \\\n-\tnested exception for details.\n-new-brokerfactory-excep: There was an error when invoking the static \\\n-\tnewInstance method on the named factory class \"{0}\".  See the \\\n-\tnested exception for details.\n-bad-brokerfactory: Could not invoke the static getInstance method on the \\\n-\tnamed factory class \"{0}\".\n-bad-new-brokerfactory: Could not invoke the static newInstance method on the \\\n-\tnamed factory class \"{0}\".\n-bad-brokerfactory-class: The named BrokerFactory \"{0}\" is not valid.\n-instantiate-abstract: Cannot instantiate abstract class of type \"{0}\" with \\\n-\tobject id \"{1}\"; this may indicate that the inheritance discriminator \\\n-\tfor the class is not configured correctly.\n-nontrans-proxied: You cannot make a property access object created with \"new\" \\\n-\tnontransactional.\n-no-field: Field \"{0}\" is not declared in \"{1}\", or is not managed.\n-no-field-index: \"{0}\" is not the index of any managed field in \"{1}\".\n-cant-cascade-persist: Encountered unmanaged object in persistent field \\\n-\t\"{0}\" during flush.  However, this field does not \\\n-\tallow cascade persist. Set the cascade attribute for this field to \\\n-    CascadeType.PERSIST or CascadeType.ALL (JPA annotations) or \\\n-    \"persist\" or \"all\" (JPA orm.xml), or enable cascade-persist globally, \\\n-    or manually persist the related field value prior to flushing. \\\n-\tYou cannot flush unmanaged objects or graphs that have persistent \\\n-    associations to unmanaged objects.\n-cant-cascade-attach: Encountered new object in persistent field \\\n-\t\"{0}\" during attach.  However, this field does not \\\n-\tallow cascade attach. Set the cascade attribute for this field to \\\n-    CascadeType.MERGE or CascadeType.ALL (JPA annotations) or \\\n-    \"merge\" or \"all\" (JPA orm.xml). \\\n-    You cannot attach a reference to a new object without cascading.\n-ref-to-deleted: Encountered deleted object \"{0}\" in persistent field \\\n-\t\"{1}\" of managed object \"{2}\" during flush.\n-no-version-field: Encountered object \"{0}\" without a version field during \\\n-\tattach.  In order to attach an object, it must either be enhanced or must \\\n-\thave a version field.\n-inmem-agg-proj-var: Queries with aggregates or projections using variables \\\n-\tcurrently cannot be executed in-memory.  Either set IgnoreCache to true, \\\n-\tset the openjpa.FlushBeforeQueries property to true, or execute the query \\\n-\tbefore changing any instances in the transaction.  The offending query was \\\n-\ton type \"{0}\" with filter \"{1}\".\n-merged-order-with-result: This query on candidate type \"{0}\" with filter \"{1}\" \\\n-\tinvolves combining the results of multiple queries in memory. \\\n-\tYou have chosen to order the results on \"{2}\", but you have not selected \\\n-\tthis data in your setResult() clause.  Please include this ordering data \\\n-\tin setResult() so that OpenJPA can extract it for in-memory ordering.\n-bad-grouping: Your query on type \"{0}\" with filter \"{1}\" is invalid.  Your \\\n-    select and having clauses must only include aggregates or values that also \\\n-    appear in your grouping clause.\n-query-nosupport: The \"{0}\" query type does not support this operation.\n-query-unmapped: You cannot query unmapped type \"{0}\".\n-range-too-big: The range of the query is too big. Start index: \"{0}\", end \\\n-\tindex: \"{1}\". The range must be less than Integer.MAX_VALUE.\n-invalid-range: The query range from {0} to {1} is not valid.\n-no-impls: Unable to execute a query on type \"{0}\".  This class or interface \\\n-\tis not mapped, and does not have any mapped implementors.\n-bad-param-name: The parameter name or position \"{0}\" passed to \\\n-\texecute() is not valid.  All map keys must be a declared parameter \\\n-\tname or a number matching the parameter position. Native queries only \\\n-\tallow the use of positional parameters.\n-force-in-mem: This query on type \"{0}\" must load the entire candidate class \\\n-\textent and evaluate the query in-memory.  This may be very slow.  The \\\n-\tquery must be executed in memory because OpenJPA is configured with \\\n-\tIgnoreCache=false and FlushBeforeQueries=false and \\\n-\tthere are dirty instances that may affect the query''s outcome in the \\\n-\tcache.\n-cant-exec-inmem: Queries of this type (\"{0}\") cannot be executed in-memory. \\\n-\tEither set IgnoreCache to true, set the openjpa.FlushBeforeQueries \\\n-\tproperty to true, or execute the query before changing any instances in \\\n-\tthe transaction.\n-executing-query: Executing query: {0}\n-executing-query-with-params: Executing query: [{0}] with parameters: {1}\n-not-unique: The query on candidate type \"{0}\" with filter \"{1}\" was \\\n-\tconfigured to have a unique result, but more than one instance matched \\\n-\tthe query.\n-no-result: The query on candidate type \"{0}\" with filter \"{1}\" was \\\n-\tconfigured to have a unique result, but no instance matched \\\n-\tthe query.\n-serialized: Queries that have been serialized do not support this operation.\n-read-only: Attempt to modify a read-only query object.\n-no-class: A candidate Class must be specified before executing a query.\n-no-modify-resultclass: A query that declares a result class cannot be used \\\n-\tto perform bulk updates.\n-no-modify-unique: A query that declares unique results cannot be used \\\n-\tto perform bulk updates.\n-no-modify-range: A query that declares a result range cannot be used \\\n-\tto perform bulk updates.\n-unbound-param: Cannot execute query; the declared parameter \"{0}\" was \\\n-\tnot given a value.\n-unbound-params: Cannot execute query; some declared parameters were not given \\\n-\tvalues.  You must supply a value for each of the following parameters, \\\n-\tin the given order: {0}\n-extra-params: More parameters were passed to execute() than were declared: \\\n-\t{1} parameters were specified for query execution, but only {0} \\\n-\tparameters were declared in the query.\n-null-primitive-param: Parameter \"{0}\" was declared with a primitive type, but \\\n-\thas been given a null value.\n-merged-aggregate: This query on candidate type \"{0}\" with filter \"{1}\" \\\n-\tinvolves combining the results of multiple sub-queries.  However, because \\\n-\tthis query is for aggregate data, OpenJPA cannot combine the sub-query \\\n-\taggregates into correct final values.\n-bad-dec: The {1} declaration \"{0}\" is \\\n-\tnot valid. Variables and imports must be delimited with \";\".  Parameters \\\n-\tand orderings must be delimited with \",\".  Imports require the \"import\" \\\n-\tkeyword, and orderings require the \"ascending\" or \"descending\" keyword.\n-mod-bigdecimal: You cannot use the modulo operator (%) on numbers of type \\\n-\tBigDecimal.\n-cant-convert: Cannot convert object \"{0}\" of type \"{1}\" into an instance of \\\n-\t\"{2}\".\n-bad-method-class: You set the method name of this openjpa.MethodQL query to \\\n-\t\"{1}\", but class \"{0}\" is not a valid class name.  Make sure to fully \\\n-\tqualify the class name or to import its package into this query if the \\\n-\tclass is not in the query candidate class'' package. \n-method-not-static: Method \"{0}\" named in the MethodQL query must be static.\n-method-return-type-invalid: Method \"{0}\" named in the MethodQL query must \\\n-    have a return type that is assignable from ResultObjectProvider. Return \\\n-    type is: {1}.\n-no-method: You must set the query filter to the name of the method to execute \\\n-\tfor this MethodQL query instance.\n-method-error: There was an error invoking method \"{0}\" with arguments \"{1}\".\n-bad-param-type: The type \"{0}\" as used in the parameter declarations \\\n-\tcould not be found in the imports.\n-cant-set: Result type \"{0}\" does not have any public fields or setter methods \\\n-\tfor the projection or aggregate result element \"{1}\", nor does it have a \\\n-\tgeneric put(Object,Object) method that can be used, nor does it have a \\\n-\tpublic constructor that takes the types {2}.\n-pack-err: There was an error packing the projection and/or aggregate results \\\n-\tof the query into result type \"{0}\".  See the nested Throwable exception \\\n-\tfor details.\n-pack-instantiation-err: There was an error creating an instance of type \"{0}\" \\\n-\twhen packing the projection and/or aggregate results of the query. Ensure \\\n-\tthat you have defined a public no-args constructor in \"{0}\".\n-bad-inmem-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Object, \\\n-\tMap, FetchConfiguration)\" is not declared in type \"{1}\". \\\n-\tCheck the method name supplied in your MethodQL query filter.  \\\n-\tOpenJPA is attempting to execute this query in-memory; if you implemented \\\n-    the datastore method instead (a method with the same signature but without \\\n-    the Object argument) and want this query to execute in the datastore, \\\n-    either create the query before modifying objects in the current transaction, \\\n-\tset IgnoreCache to true, or set the openjpa.FlushBeforeQueries property to \\\n-\ttrue.\n-bad-datastore-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Map, \\\n-\tFetchConfiguration)\" is not declared in type \"{1}\".  Check \\\n-\tthe method name supplied in your MethodQL query filter.  OpenJPA is \\\n-\tattempting to execute this query against the datastore; if you implemented \\\n-\tthe in-memory method instead (a method with the same signature but with an \\\n-\tObject argument) and want this query to execute in-memory, supply a \\\n-\tCollection of candidates to filter.\n-only-update-constants: Bulk update queries when executed in memory \\\n-\tmay only update to constant values.\n-only-range-constants: Range values must be numeric constants.  Illegal query: \\\n-    {0}\n-no-savepoint-copy: Unable to copy field \"{0}\" for savepoint.\n-savepoint-exists: A savepoint with the name \"{0}\" already exists.  \\\n-\tEach savepoint name must be unique.\n-no-lastsavepoint: Cannot rollback/release last savepoint as no savepoint \\\n-\thas been set.\n-no-savepoint: You have not set a savepoint with the name \"{0}\"\n-savepoint-init: This savepoint has already been initialized.\n-savepoint-flush-not-supported: The configured SavepointManager does not \\\n-\tsupport incremental flushing when a savepoint has been set.  You must \\\n-\trelease your savepoints before flushing.\n-callback-err: Errors occurred processing listener callbacks.  See the nested \\\n-    exceptions for details.\n-bad-agg-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted into \\\n-\tan aggregate listener.\n-bad-filter-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted \\\n-\tinto a filter listener.\n-bad-setter-hint-arg: In query hint \"{0}\", cannot convert hint value \"{1}\" to \\\n-    type \"{2}\".\n-detach-val-mismatch: The instance \"{0}\" is managed by another context and \\\n-\tcannot be inspected for field values.\n-detach-val-badsm: The instance \"{0}\" has an unknown state manager which \\\n-\tprevents field inspection.\n-null-oid: Cannot perform find using null object id.\n-illegal-op-in-prestore: This operation is illegal when called during \\\n-\ttransaction completion.\n-no-expressions: The query cannot be executed because it has no \\\n-\tvalid expressions.\n-null-fg: Attempt to add null/empty fetch group name to fetch configuration.\n-null-field: Attempt to add null/empty field name to fetch configuration.\n-container-projection: Query projections cannot include array, collection, or \\\n-    map fields.  Invalid query: \"{0}\"\n-existing-value-override-excep: The generated value processing detected an \\\n-existing value assigned to this field: {0}.  This existing value was either \\\n-provided via an initializer or by calling the setter method.  You either need \\\n-to remove the @GeneratedValue annotation or modify the code to remove the \\\n-initializer processing.\n-invalid-tran-status: The transaction was not in a valid state ({0}) to \\\n-accept the \"{1}\" method invocation.  Processing will continue.\n-multi-threaded-access: Multiple concurrent threads attempted to access a \\\n-    single broker. By default brokers are not thread safe; if you require \\\n-    and/or intend a broker to be accessed by more than one thread, set the \\\n-    openjpa.Multithreaded property to true to override the default behavior.\n-no-saved-fields: No state snapshot is available for instance of type \"{0}\", \\\n-    but this instance uses state-comparison for dirty detection.\n-cant-serialize-flushed-broker: Serialization not allowed once a broker has \\\n-    been flushed.\n-cant-serialize-pessimistic-broker: Serialization not allowed for brokers with \\\n-    an active datastore (pessimistic) transaction.\n-cant-serialize-connected-broker: Serialization not allowed for brokers with \\\n-    an active connection to the database.\n-no-interface-metadata: No metadata was found for managed interface {0}.\n-fetch-configuration-stack-empty: Fetch configuration stack is empty.\n-gap-query-param: Parameter {1} for query \"{0}\" exceeds the number of {2} \\\n-\tbound parameters with following values \"{3}\". This can happen if you have \\\n-\tdeclared but missed to bind values for one or more parameters.\n+# Licensed to the Apache Software Foundation (ASF) under one\r\n+# or more contributor license agreements.  See the NOTICE file\r\n+# distributed with this work for additional information\r\n+# regarding copyright ownership.  The ASF licenses this file\r\n+# to you under the Apache License, Version 2.0 (the\r\n+# \"License\"); you may not use this file except in compliance\r\n+# with the License.  You may obtain a copy of the License at\r\n+#\r\n+# http://www.apache.org/licenses/LICENSE-2.0\r\n+#\r\n+# Unless required by applicable law or agreed to in writing,\r\n+# software distributed under the License is distributed on an\r\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+# KIND, either express or implied.  See the License for the\r\n+# specific language governing permissions and limitations\r\n+# under the License.  \r\n+\r\n+cant-convert-result: There is no conversion between query projection type \\\r\n+\t\"{0}\" and result type \"{1}\".\r\n+unloaded-detached: Attempt to access an unloaded field of detached instance \\\r\n+\t\"{0}\".\r\n+meta-unknownid: Cannot manipulate identity of type \"{0}\": it''s identity type \\\r\n+\tis unknown.\r\n+new-abstract: Cannot create an instance of \"{0}\": abstract classes are not \\\r\n+    yet supported.\r\n+bad-new-query: Attempt to construct a query from an extent or class.  You must \\\r\n+\tpass a (possibly null) query string or template to the query factory \\\r\n+\tmethod when creating the query. \r\n+update-restrict: Detected attempt to modify field \"{0}\" with value strategy \\\r\n+\t\"restrict\".\r\n+reentrant-flush: Detected reentrant flush.  Make sure your flush-time instance \\\r\n+\tcallback methods or event listeners do not invoke any operations that \\\r\n+\trequire the in-progress flush to complete.\r\n+rolled-back: The transaction has been rolled back.  See the nested exceptions \\\r\n+\tfor details on the errors that occurred.\r\n+bad-lock-level: This lock manager does not recognize lock level \"{0}\".\r\n+pessimistic-mutate: You are attempting to directly mutate a persistent second \\\r\n+\tclass object (such as a collection or map field) that you obtained before \\\r\n+\tthe transaction began.  After beginning a datastore transaction, you \\\r\n+\tmust re-obtain any references to mutable second class objects from the \\\r\n+\towning persistent object.  Detected attempt to mutate value of field \"{0}\" \\\r\n+\tin instance \"{1}\".  This instance may not be locked correctly.\r\n+not-derefed: Encountered unknown dependent instance \"{0}\".  This error is \\\r\n+\toften caused by either removing a dependent instance from one dependent \\\r\n+\tfield, but not other dependent fields that reference it, or by removing a \\\r\n+\tdependent instance from its owning field, flushing \\\r\n+\t(causing the unreferenced dependent instance to be deleted), and then \\\r\n+\ttrying to assign the deleted instance to another field before commit.  \\\r\n+\tThe instance cannot be un-deleted, resulting in an error.  Make sure not \\\r\n+\tto leave dangling dependent references to objects, and to reassign \\\r\n+\tdependent objects before flush so that OpenJPA does not think they are \\\r\n+\tunreferenced and therefore safe to delete.\r\n+init-null-pc: Attempt to initialize a state manager with a null \\\r\n+\tpersistence-capable instance for type \"{0}\".  This is often caused by \\\r\n+\tattempting to load an instance of an abstract class, or \\\r\n+\tneglecting to use a class indicator when the base persistence-capable \\\r\n+\tclass in an inheritance tree is abstract.\r\n+init-sm-pc: Attempt to initialize a state manager with an instance that is \\\r\n+\talready managed (\"{0}\").  You might be trying to persist this instance \\\r\n+\tin two threads at the same time.\r\n+bad-ds-oid: The type \"{0}\" declares datastore identity but the value \\\r\n+\tpassed to lookup of type \"{1}\" is not a OpenJPA id instance.\r\n+null-oids: Some of the object ids passed to getObjectsById were null.\r\n+marked-rollback: The transaction cannot be committed, because it was already \\\r\n+\tmarked for rollback only.  The transaction will be rolled back instead. \\\r\n+    The cause of the rollback-only status is reported in the embedded stack.\r\n+refresh-flushed: You cannot refresh an instance that has been flushed to the \\\r\n+\tdata store.\r\n+pc-loader-different: Attempt to cast instance \"{0}\" to PersistenceCapable failed. \\\r\n+    The object implemented org.apache.openjpa.enhance.PersistenceCapable, \\\r\n+    but the instance of that interface was loaded by two different ClassLoaders: \\\r\n+    \"{1}\" and \"{2}\".\r\n+pc-cast: Attempt to cast instance \"{0}\" to PersistenceCapable failed.  Ensure \\\r\n+\tthat it has been enhanced.\r\n+del-instance: The instance of type \"{0}\" with oid \"{1}\" no longer exists in \\\r\n+\tthe data store.  This may mean that you deleted the instance in a separate \\\r\n+\ttransaction, but this context still has a cached version.\r\n+no-broker-class: The specified type \"{0}\" could not be loaded. Please ensure \\\r\n+\tthat the class exists in the project class path.\r\n+bad-embed: Attempt to set an embedded value for unembeddable field \"{0}\". \\\r\n+\tPlease report this error to OpenJPA support.\r\n+embed-ref: You are attempting to access an embedded object reference \\\r\n+\tthat was obtained before the last transaction status change. After \\\r\n+\ttransactions begin and end, all references to embedded objects become \\\r\n+\tinvalid; you have to re-acquire the reference from the owning persistent \\\r\n+\tobject.\r\n+deleted: Operation attempted on a deleted instance.\r\n+dirty: Illegal operation attempted on a dirty instance: dirty objects cannot \\\r\n+\tbe evicted or made transient or non-transactional.\r\n+nested-exceps: This operation failed for some instances.  See the nested \\\r\n+\texceptions array for details.\r\n+new: Illegal operation attempted on a newly persisted instance: new objects \\\r\n+\tcannot be evicted or made transient or non-transactional.\r\n+transient: Illegal operation attempted on a transient instance.\r\n+not-active: Can only perform operation while a transaction is active.\r\n+trans-active: The \"{0}\" transaction property cannot be set during an \\\r\n+\tactive transaction.\r\n+active: This operation cannot be performed while a Transaction is active.\r\n+closed: The context has been closed.  The stack trace at which the \\\r\n+\tcontext was closed is held in the embedded exception.\r\n+closed-notrace: The context has been closed.  The stack trace at which the \\\r\n+\tcontext was closed is available if Runtime=TRACE logging is enabled.\r\n+closed-factory: The factory has been closed.  The stack trace at \\\r\n+\twhich the factory was closed is held in the embedded exception.\r\n+closed-factory-notrace: The factory has been closed.  The stack trace at \\\r\n+\twhich the factory was closed is available if Runtime=TRACE logging is \\\r\n+\tenabled.\r\n+non-trans-read: To perform reads on persistent data outside of a transaction, \\\r\n+\tthe \"NontransactionalRead\" property must be set on the Transaction.\r\n+non-trans-write: To perform writes on persistent data outside of a \\\r\n+\ttransaction, the \"NontransactionalWrite\" property must be set to true.\r\n+write-operation: To perform this operation, it must be written within a transaction, \\\r\n+\tor your settings must allow nontransactional writes and must not detach \\\r\n+\tall nontransactional reads.\r\n+not-managed: The given instance \"{0}\" is not managed by this context.\r\n+trans-not-managed: This broker is not configured to use managed transactions.\r\n+bad-detached-op: You cannot perform operation {0} on detached object \"{1}\". \\\r\n+\tThis operation only applies to managed objects.\r\n+persist-detached: Attempt to persist detached object \"{0}\".  If this is a new \\\r\n+  instance, make sure any version and/or auto-generated primary key fields are \\\r\n+  null/default when persisting.\r\n+null-value: The field \"{0}\" of instance \"{1}\" contained a null value; \\\r\n+\tthe metadata for this field specifies that nulls are illegal.\r\n+change-identity: Attempt to change a primary key field of an instance that \\\r\n+\talready has a final object id.  Only new, unflushed instances whose id you \\\r\n+\thave not retrieved can have their primary keys changed.\r\n+managed-oid: You cannot assign managed object \"{0}\" to the primary key field \\\r\n+\tof \"{1}\".  Embedded primary key values must be transient objects.\r\n+changed-oid: You have modified the object id field of \"{2}\".  Its old value \\\r\n+\twas \"{0}\", and its new value is \"{1}\".  Object id fields are immutable \\\r\n+\tonce the object id of the instance has been assigned. \r\n+cache-exists: An object of type \"{0}\" with oid \"{1}\" already exists in this \\\r\n+\tcontext; another cannot be persisted.\r\n+null-trans: Attempt to commit a null javax.transaction.Transaction.  Some \\\r\n+\tapplication servers set the transaction to null if a rollback occurs.\r\n+end-trans-error: An exception occurred while ending the transaction.  This \\\r\n+\texception will be re-thrown.\r\n+not-bound: The file named \"{0}\" could not be found.\r\n+naming-exception: A NamingException was thrown while obtaining the \\\r\n+\tfactory at \"{0}\" from JNDI.\r\n+attach-deleted: The object \"{0}\" with id \"{1}\" has been deleted and \\\r\n+\tcannot be attached.\r\n+not-detachable: The class \"{0}\" does not declare the \"detachable\" metadata \\\r\n+\textension, so cannot be detached.\r\n+not-copyable: Attempt to copy field \"{0}\" failed.  The field is \\\r\n+\tnot copyable.  This can occur with custom SCO types. Only standard or \\\r\n+    immutable SCO types can be attached and detached.\r\n+no-detach-object-id: Cannot access the detached object id of class \"{0}\". \\\r\n+\tEnsure that the class has the \"detachable\" metadata extension, and \\\r\n+\tthe the class has been re-enhanced.\r\n+attach-version-del: Attempted to attach deleted instance type \"{0}\" with oid \\\r\n+\t\"{1}\".  If the instance is new, the version field should be left to its \\\r\n+\tdefault value.\r\n+attach-wrongclass: Attempted to attach instance \"{0}\" of type \"{1}\", but this \\\r\n+\tinstance is already in the datastore as type \"{2}\".\r\n+sjvm-acquired-lock: Acquired an exclusive lock \"{0}\" on oid \"{1}\".\r\n+sjvm-released-lock: Released lock \"{0}\".\r\n+conn-not-supported: This data store cannot return connections.\r\n+incremental-flush-not-supported: This data store does not support incremental \\\r\n+\tflushing.  If you got this error while performing a query, make sure that \\\r\n+\tyou have not set the FlushBeforeQueries option to true, either by \\\r\n+\tsetting that option in your configuration file, or by programmatically \\\r\n+\tsetting the current FetchConfiguration''s FlushBeforeQueries property \\\r\n+\tto QueryFlushModes.FLUSH_TRUE.\r\n+nontrans-read-not-supported: This data store does not support nontransactional \\\r\n+\treads.  Set the NontransactionalRead property to false.\r\n+optimistic-not-supported: This datastore does not support optimistic \\\r\n+\ttransactions.  Set the Optimistic property to false.\r\n+restore-unset: The RestoreValues option is off, so initial values are \\\r\n+\tnot available. Turn on RestoreValues to be able to obtain initial \\\r\n+\tvalues.\r\n+mutable-restore-unset: The RestoreValues option is not set to \"all\", \\\r\n+\tinitial values of mutable fields are not available. Set RestoreValues to \\\r\n+\t\"all\" in your properties to be able to obtain initial mutable values.\r\n+initial-unloaded: OpenJPA cannot provide the initial value for field \"{0}\" \\\r\n+\tbecause the field was never loaded before being changed.\r\n+dup-oid-assign: Attempt to assign id \"{0}\" to new instance \"{1}\" failed; \\\r\n+\tthere is already an object in the L1 cache with this id. \\\r\n+\tYou must delete this object (in a previous transaction or the current one) \\\r\n+\tbefore reusing its id.  This error can also occur when a horizontally \\\r\n+\tor vertically mapped classes uses auto-increment application identity and \\\r\n+\tdoes not use a hierarchy of application identity classes.\r\n+dup-load: Cannot load object with id \"{0}\".  Instance \"{1}\" with the same id \\\r\n+\talready exists in the L1 cache.  This can occur when you \\\r\n+\tassign an existing id to a new instance, and before flushing attempt to \\\r\n+\tload the existing instance for that id.\r\n+bad-id-value: The given value \"{0}\" cannot be converted into an identity \\\r\n+\tfor \"{2}\".  The value is the wrong type ({1}).\r\n+factory-init: Starting OpenJPA {0}\r\n+factory-properties: Properties: {0}\r\n+inverse-consistency: An inverse inconsistency in the object featureSelection was \\\r\n+\tdetected while flushing the field \"{0}\" of the instance with id \"{1}\" \\\r\n+\tin context \"{2}\".\r\n+no-brokerfactory: You did not name the factory class with the required \\\r\n+\tproperty openjpa.BrokerFactory.  Normally this property defaults \\\r\n+    appropriately; have you forgotten to include all the OpenJPA jars in your \\\r\n+    classpath?\r\n+brokerfactory-excep: There was an error when invoking the static \\\r\n+\tgetInstance method on the named factory class \"{0}\".  See the \\\r\n+\tnested exception for details.\r\n+new-brokerfactory-excep: There was an error when invoking the static \\\r\n+\tnewInstance method on the named factory class \"{0}\".  See the \\\r\n+\tnested exception for details.\r\n+bad-brokerfactory: Could not invoke the static getInstance method on the \\\r\n+\tnamed factory class \"{0}\".\r\n+bad-new-brokerfactory: Could not invoke the static newInstance method on the \\\r\n+\tnamed factory class \"{0}\".\r\n+bad-brokerfactory-class: The named BrokerFactory \"{0}\" is not valid.\r\n+instantiate-abstract: Cannot instantiate abstract class of type \"{0}\" with \\\r\n+\tobject id \"{1}\"; this may indicate that the inheritance discriminator \\\r\n+\tfor the class is not configured correctly.\r\n+nontrans-proxied: You cannot make a property access object created with \"new\" \\\r\n+\tnontransactional.\r\n+no-field: Field \"{0}\" is not declared in \"{1}\", or is not managed.\r\n+no-field-index: \"{0}\" is not the index of any managed field in \"{1}\".\r\n+cant-cascade-persist: Encountered unmanaged object in persistent field \\\r\n+\t\"{0}\" during flush.  However, this field does not \\\r\n+\tallow cascade persist. Set the cascade attribute for this field to \\\r\n+    CascadeType.PERSIST or CascadeType.ALL (JPA annotations) or \\\r\n+    \"persist\" or \"all\" (JPA orm.xml), or enable cascade-persist globally, \\\r\n+    or manually persist the related field value prior to flushing. \\\r\n+\tYou cannot flush unmanaged objects or graphs that have persistent \\\r\n+    associations to unmanaged objects.\r\n+cant-cascade-attach: Encountered new object in persistent field \\\r\n+\t\"{0}\" during attach.  However, this field does not \\\r\n+\tallow cascade attach. Set the cascade attribute for this field to \\\r\n+    CascadeType.MERGE or CascadeType.ALL (JPA annotations) or \\\r\n+    \"merge\" or \"all\" (JPA orm.xml). \\\r\n+    You cannot attach a reference to a new object without cascading.\r\n+ref-to-deleted: Encountered deleted object \"{0}\" in persistent field \\\r\n+\t\"{1}\" of managed object \"{2}\" during flush.\r\n+no-version-field: Encountered object \"{0}\" without a version field during \\\r\n+\tattach.  In order to attach an object, it must either be enhanced or must \\\r\n+\thave a version field.\r\n+inmem-agg-proj-var: Queries with aggregates or projections using variables \\\r\n+\tcurrently cannot be executed in-memory.  Either set IgnoreCache to true, \\\r\n+\tset the openjpa.FlushBeforeQueries property to true, or execute the query \\\r\n+\tbefore changing any instances in the transaction.  The offending query was \\\r\n+\ton type \"{0}\" with filter \"{1}\".\r\n+merged-order-with-result: This query on candidate type \"{0}\" with filter \"{1}\" \\\r\n+\tinvolves combining the results of multiple queries in memory. \\\r\n+\tYou have chosen to order the results on \"{2}\", but you have not selected \\\r\n+\tthis data in your setResult() clause.  Please include this ordering data \\\r\n+\tin setResult() so that OpenJPA can extract it for in-memory ordering.\r\n+bad-grouping: Your query on type \"{0}\" with filter \"{1}\" is invalid.  Your \\\r\n+    select and having clauses must only include aggregates or values that also \\\r\n+    appear in your grouping clause.\r\n+query-nosupport: The \"{0}\" query type does not support this operation.\r\n+query-unmapped: You cannot query unmapped type \"{0}\".\r\n+range-too-big: The range of the query is too big. Start index: \"{0}\", end \\\r\n+\tindex: \"{1}\". The range must be less than Integer.MAX_VALUE.\r\n+invalid-range: The query range from {0} to {1} is not valid.\r\n+no-impls: Unable to execute a query on type \"{0}\".  This class or interface \\\r\n+\tis not mapped, and does not have any mapped implementors.\r\n+bad-param-name: The parameter name or position \"{0}\" passed to \\\r\n+\texecute() is not valid.  All map keys must be a declared parameter \\\r\n+\tname or a number matching the parameter position. Native queries only \\\r\n+\tallow the use of positional parameters.\r\n+force-in-mem: This query on type \"{0}\" must load the entire candidate class \\\r\n+\textent and evaluate the query in-memory.  This may be very slow.  The \\\r\n+\tquery must be executed in memory because OpenJPA is configured with \\\r\n+\tIgnoreCache=false and FlushBeforeQueries=false and \\\r\n+\tthere are dirty instances that may affect the query''s outcome in the \\\r\n+\tcache.\r\n+cant-exec-inmem: Queries of this type (\"{0}\") cannot be executed in-memory. \\\r\n+\tEither set IgnoreCache to true, set the openjpa.FlushBeforeQueries \\\r\n+\tproperty to true, or execute the query before changing any instances in \\\r\n+\tthe transaction.\r\n+executing-query: Executing query: {0}\r\n+executing-query-with-params: Executing query: [{0}] with parameters: {1}\r\n+not-unique: The query on candidate type \"{0}\" with filter \"{1}\" was \\\r\n+\tconfigured to have a unique result, but more than one instance matched \\\r\n+\tthe query.\r\n+no-result: The query on candidate type \"{0}\" with filter \"{1}\" was \\\r\n+\tconfigured to have a unique result, but no instance matched \\\r\n+\tthe query.\r\n+serialized: Queries that have been serialized do not support this operation.\r\n+read-only: Attempt to modify a read-only query object.\r\n+no-class: A candidate Class must be specified before executing a query.\r\n+no-modify-resultclass: A query that declares a result class cannot be used \\\r\n+\tto perform bulk updates.\r\n+no-modify-unique: A query that declares unique results cannot be used \\\r\n+\tto perform bulk updates.\r\n+no-modify-range: A query that declares a result range cannot be used \\\r\n+\tto perform bulk updates.\r\n+unbound-param: Cannot execute query; the declared parameter \"{0}\" was \\\r\n+\tnot given a value.\r\n+unbound-params: Cannot execute query; some declared parameters were not given \\\r\n+\tvalues.  You must supply a value for each of the following parameters, \\\r\n+\tin the given order: {0}\r\n+extra-params: More parameters were passed to execute() than were declared: \\\r\n+\t{1} parameters were specified for query execution, but only {0} \\\r\n+\tparameters were declared in the query.\r\n+null-primitive-param: Parameter \"{0}\" was declared with a primitive type, but \\\r\n+\thas been given a null value.\r\n+merged-aggregate: This query on candidate type \"{0}\" with filter \"{1}\" \\\r\n+\tinvolves combining the results of multiple sub-queries.  However, because \\\r\n+\tthis query is for aggregate data, OpenJPA cannot combine the sub-query \\\r\n+\taggregates into correct final values.\r\n+bad-dec: The {1} declaration \"{0}\" is \\\r\n+\tnot valid. Variables and imports must be delimited with \";\".  Parameters \\\r\n+\tand orderings must be delimited with \",\".  Imports require the \"import\" \\\r\n+\tkeyword, and orderings require the \"ascending\" or \"descending\" keyword.\r\n+mod-bigdecimal: You cannot use the modulo operator (%) on numbers of type \\\r\n+\tBigDecimal.\r\n+cant-convert: Cannot convert object \"{0}\" of type \"{1}\" into an instance of \\\r\n+\t\"{2}\".\r\n+bad-method-class: You set the method name of this openjpa.MethodQL query to \\\r\n+\t\"{1}\", but class \"{0}\" is not a valid class name.  Make sure to fully \\\r\n+\tqualify the class name or to import its package into this query if the \\\r\n+\tclass is not in the query candidate class'' package. \r\n+method-not-static: Method \"{0}\" named in the MethodQL query must be static.\r\n+method-return-type-invalid: Method \"{0}\" named in the MethodQL query must \\\r\n+    have a return type that is assignable from ResultObjectProvider. Return \\\r\n+    type is: {1}.\r\n+no-method: You must set the query filter to the name of the method to execute \\\r\n+\tfor this MethodQL query instance.\r\n+method-error: There was an error invoking method \"{0}\" with arguments \"{1}\".\r\n+bad-param-type: The type \"{0}\" as used in the parameter declarations \\\r\n+\tcould not be found in the imports.\r\n+cant-set: Result type \"{0}\" does not have any public fields or setter methods \\\r\n+\tfor the projection or aggregate result element \"{1}\", nor does it have a \\\r\n+\tgeneric put(Object,Object) method that can be used, nor does it have a \\\r\n+\tpublic constructor that takes the types {2}.\r\n+pack-err: There was an error packing the projection and/or aggregate results \\\r\n+\tof the query into result type \"{0}\".  See the nested Throwable exception \\\r\n+\tfor details.\r\n+pack-instantiation-err: There was an error creating an instance of type \"{0}\" \\\r\n+\twhen packing the projection and/or aggregate results of the query. Ensure \\\r\n+\tthat you have defined a public no-args constructor in \"{0}\".\r\n+bad-inmem-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Object, \\\r\n+\tMap, FetchConfiguration)\" is not declared in type \"{1}\". \\\r\n+\tCheck the method name supplied in your MethodQL query filter.  \\\r\n+\tOpenJPA is attempting to execute this query in-memory; if you implemented \\\r\n+    the datastore method instead (a method with the same signature but without \\\r\n+    the Object argument) and want this query to execute in the datastore, \\\r\n+    either create the query before modifying objects in the current transaction, \\\r\n+\tset IgnoreCache to true, or set the openjpa.FlushBeforeQueries property to \\\r\n+\ttrue.\r\n+bad-datastore-method: Method \"{0}(StoreContext, ClassMetaData, boolean, Map, \\\r\n+\tFetchConfiguration)\" is not declared in type \"{1}\".  Check \\\r\n+\tthe method name supplied in your MethodQL query filter.  OpenJPA is \\\r\n+\tattempting to execute this query against the datastore; if you implemented \\\r\n+\tthe in-memory method instead (a method with the same signature but with an \\\r\n+\tObject argument) and want this query to execute in-memory, supply a \\\r\n+\tCollection of candidates to filter.\r\n+only-update-constants: Bulk update queries when executed in memory \\\r\n+\tmay only update to constant values.\r\n+only-range-constants: Range values must be numeric constants.  Illegal query: \\\r\n+    {0}\r\n+no-savepoint-copy: Unable to copy field \"{0}\" for savepoint.\r\n+savepoint-exists: A savepoint with the name \"{0}\" already exists.  \\\r\n+\tEach savepoint name must be unique.\r\n+no-lastsavepoint: Cannot rollback/release last savepoint as no savepoint \\\r\n+\thas been set.\r\n+no-savepoint: You have not set a savepoint with the name \"{0}\"\r\n+savepoint-init: This savepoint has already been initialized.\r\n+savepoint-flush-not-supported: The configured SavepointManager does not \\\r\n+\tsupport incremental flushing when a savepoint has been set.  You must \\\r\n+\trelease your savepoints before flushing.\r\n+callback-err: Errors occurred processing listener callbacks.  See the nested \\\r\n+    exceptions for details.\r\n+bad-agg-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted into \\\r\n+\tan aggregate listener.\r\n+bad-filter-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted \\\r\n+\tinto a filter listener.\r\n+bad-setter-hint-arg: In query hint \"{0}\", cannot convert hint value \"{1}\" to \\\r\n+    type \"{2}\".\r\n+detach-val-mismatch: The instance \"{0}\" is managed by another context and \\\r\n+\tcannot be inspected for field values.\r\n+detach-val-badsm: The instance \"{0}\" has an unknown state manager which \\\r\n+\tprevents field inspection.\r\n+null-oid: Cannot perform find using null object id.\r\n+illegal-op-in-prestore: This operation is illegal when called during \\\r\n+\ttransaction completion.\r\n+no-expressions: The query cannot be executed because it has no \\\r\n+\tvalid expressions.\r\n+null-fg: Attempt to add null/empty fetch group name to fetch configuration.\r\n+null-field: Attempt to add null/empty field name to fetch configuration.\r\n+container-projection: Query projections cannot include array, collection, or \\\r\n+    map fields.  Invalid query: \"{0}\"\r\n+existing-value-override-excep: The generated value processing detected an \\\r\n+existing value assigned to this field: {0}.  This existing value was either \\\r\n+provided via an initializer or by calling the setter method.  You either need \\\r\n+to remove the @GeneratedValue annotation or modify the code to remove the \\\r\n+initializer processing.\r\n+invalid-tran-status: The transaction was not in a valid state ({0}) to \\\r\n+accept the \"{1}\" method invocation.  Processing will continue.\r\n+multi-threaded-access: Multiple concurrent threads attempted to access a \\\r\n+    single broker. By default brokers are not thread safe; if you require \\\r\n+    and/or intend a broker to be accessed by more than one thread, set the \\\r\n+    openjpa.Multithreaded property to true to override the default behavior.\r\n+no-saved-fields: No state snapshot is available for instance of type \"{0}\", \\\r\n+    but this instance uses state-comparison for dirty detection.\r\n+cant-serialize-flushed-broker: Serialization not allowed once a broker has \\\r\n+    been flushed.\r\n+cant-serialize-pessimistic-broker: Serialization not allowed for brokers with \\\r\n+    an active datastore (pessimistic) transaction.\r\n+cant-serialize-connected-broker: Serialization not allowed for brokers with \\\r\n+    an active connection to the database.\r\n+no-interface-metadata: No metadata was found for managed interface {0}.\r\n+fetch-configuration-stack-empty: Fetch configuration stack is empty.\n\\ No newline at end of file"},{"sha":"33ebe560614c1465ae6baa423fb2e4ced76dcb2e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestException.java","status":"modified","additions":1,"deletions":28,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestException.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestException.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -26,7 +26,6 @@\n import javax.persistence.EntityManager;\r\n import javax.persistence.EntityNotFoundException;\r\n import javax.persistence.OptimisticLockException;\r\n-import javax.persistence.Query;\r\n import javax.persistence.TransactionRequiredException;\r\n \r\n import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n@@ -158,39 +157,13 @@ public void testErrorCodeConfigurationHasAllKnownDictionaries() {\n \t\t}\r\n \t}\r\n \t\r\n-\t/**\r\n-\t * Invalid query throws IllegalArgumentException on construction \r\n-\t * as per JPA spec.\r\n-\t */\r\n-\tpublic void testIllegalArgumennExceptionOnInvalidQuery() {\r\n-\t    EntityManager em = emf.createEntityManager();\r\n-\t    try {\r\n-\t      em.createQuery(\"This is not a valid JPQL query\");\r\n-          fail(\"Did not throw IllegalArgumentException for invalid query.\");\r\n-\t    } catch (Throwable t) {\r\n-\t\t   assertException(t, IllegalArgumentException.class);\r\n-\t    }\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Invalid named query fails as per spec on factory based construction. \r\n-\t */\r\n-     public void testIllegalArgumennExceptionOnInvalidNamedQuery() {\r\n-         EntityManager em = emf.createEntityManager();\r\n-         try {\r\n-             Query query = em.createNamedQuery(\"This is invalid Named query\");\r\n-         } catch (Throwable t) {\r\n-             assertException(t, IllegalArgumentException.class);\r\n-         }\r\n-      }\r\n-\t\r\n \t/**\r\n \t * Asserts that the given expected type of the exception is equal to or a\r\n \t * subclass of the given throwable or any of its nested exception.\r\n \t * Otherwise fails assertion and prints the given throwable and its nested\r\n \t * exception on the console. \r\n \t */\r\n-\tpublic void assertException(Throwable t, Class expectedType) {\r\n+\tvoid assertException(Throwable t, Class expectedType) {\r\n \t\tif (!isExpectedException(t, expectedType)) {\r\n \t\t\tt.printStackTrace();\r\n \t\t\tprint(t, 0);\r"},{"sha":"1f2dd72adf823f7f8748fd633fb60c6b075336ef","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","status":"removed","additions":0,"deletions":292,"changes":292,"blob_url":"https://github.com/apache/openjpa/blob/d147f40cecdb8fa771ffbf656743400a4357afc5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","raw_url":"https://github.com/apache/openjpa/raw/d147f40cecdb8fa771ffbf656743400a4357afc5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestQueryParameterBinding.java?ref=d147f40cecdb8fa771ffbf656743400a4357afc5","patch":"@@ -1,292 +0,0 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.persistence.jdbc.query;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.Query;\r\n-\r\n-import org.apache.openjpa.persistence.ArgumentException;\r\n-import org.apache.openjpa.persistence.jdbc.query.domain.Binder;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-/**\r\n- * Tests validation of positional and named parameter binding for JPQL queries.\r\n- *  \r\n- *  \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class TestQueryParameterBinding extends SingleEMFTestCase {\r\n-\tprivate static String JPQL = \"SELECT p FROM Binder p \";\r\n-\t\r\n-\tprivate static int INT_VALUE    = 1;\r\n-\tprivate static String STR_VALUE = \"2\";\r\n-\tprivate static double DBL_VALUE = 3.0;\r\n-\t\r\n-\tprivate EntityManager em;\r\n-\t@Override\r\n-\tpublic void setUp() throws Exception {\r\n-\t\tsuper.setUp(CLEAR_TABLES, Binder.class);\r\n-\t\t\r\n-\t\tem = emf.createEntityManager();\r\n-\t\tem.getTransaction().begin();\r\n-\t\tem.persist(new Binder(INT_VALUE, STR_VALUE, DBL_VALUE));\r\n-\t\tem.getTransaction().commit();\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithPositionalBindingSucceeds() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(1, INT_VALUE);\r\n-\t\tq.setParameter(2, STR_VALUE);\r\n-\t\tq.setParameter(3, DBL_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1, q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithNamedBindingFails() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(\"p1\", INT_VALUE);\r\n-\t\tq.setParameter(\"p2\", STR_VALUE);\r\n-\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithInsufficientValuesFails() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(1, INT_VALUE);\r\n-\t\tq.setParameter(2, STR_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithExtraValuesFails() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(1, INT_VALUE);\r\n-\t\tq.setParameter(2, STR_VALUE);\r\n-\t\tq.setParameter(3, DBL_VALUE);\r\n-\t\tq.setParameter(4, 4);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\r\n-\tpublic void testPositionalParameterWithRepeatedValuesSucceeds() {\r\n-\t\tString jPQL_POSITIONAL_REPEATED_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=?1 OR p.p1=?1 AND p.p3=?2\";\r\n-\t\tQuery q = em.createQuery(jPQL_POSITIONAL_REPEATED_PARAM);\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  DBL_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1,q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithGapSucceeds() {\r\n-\t\tString JPQL_POSITIONAL_GAP_IN_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=?1 AND p.p2=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL_GAP_IN_PARAM);\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(3,  STR_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1,q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithGapFails() {\r\n-\t\tString JPQL_POSITIONAL_GAP_IN_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=?1 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL_GAP_IN_PARAM);\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  STR_VALUE);\r\n-\t\tq.setParameter(3,  DBL_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithNamedBindingSucceeds() {\r\n-\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n-\t\tq.setParameter(\"p1\", INT_VALUE);\r\n-\t\tq.setParameter(\"p2\", STR_VALUE);\r\n-\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1, q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithPositionalBindingFails() {\r\n-\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n-\t\tq.setParameter(1, INT_VALUE);\r\n-\t\tq.setParameter(2, STR_VALUE);\r\n-\t\tq.setParameter(3, DBL_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithInsufficientValuesFails() {\r\n-\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n-\t\tq.setParameter(\"p1\", INT_VALUE);\r\n-\t\tq.setParameter(\"p2\", STR_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithExtraValuesFails() {\r\n-\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n-\t\tq.setParameter(\"p1\", INT_VALUE);\r\n-\t\tq.setParameter(\"p2\", STR_VALUE);\r\n-\t\tq.setParameter(\"p3\", DBL_VALUE);\r\n-\t\tq.setParameter(\"p4\", 4);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\r\n-\tpublic void testNamedParameterWithRepeatedValuesSucceeds() {\r\n-\t\tString jPQL_NAMED_REPEATED_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=:p1 OR p.p1=:p1 AND p.p3=:p2\";\r\n-\t\tQuery q = em.createQuery(jPQL_NAMED_REPEATED_PARAM);\r\n-\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n-\t\tq.setParameter(\"p2\",  DBL_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1,q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithGapSucceeds() {\r\n-\t\tString JPQL_NAMED_GAP_IN_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=:p1 AND p.p2=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED_GAP_IN_PARAM);\r\n-\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n-\t\tq.setParameter(\"p3\",  STR_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1,q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithGapFails() {\r\n-\t\tString JPQL_NAMED_GAP_IN_PARAM  = \r\n-\t\t\tJPQL + \"WHERE p.p1=:p1 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED_GAP_IN_PARAM);\r\n-\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n-\t\tq.setParameter(\"p2\",  STR_VALUE);\r\n-\t\tq.setParameter(\"p3\",  DBL_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithWrongType() {\r\n-\t\tString JPQL_NAMED  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_NAMED);\r\n-\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n-\t\tq.setParameter(\"p2\",  DBL_VALUE);\r\n-\t\tq.setParameter(\"p3\",  STR_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithWrongType() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  DBL_VALUE);\r\n-\t\tq.setParameter(3,  STR_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testNamedParameterWithNullValue() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=:p1 AND p.p2=:p2 AND p.p3=:p3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(\"p1\",  INT_VALUE);\r\n-\t\tq.setParameter(\"p2\",  null);\r\n-\t\tq.setParameter(\"p3\",  null);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithNullValue() {\r\n-\t\tString JPQL_POSITIONAL  = JPQL + \"WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\";\r\n-\t\tQuery q = em.createQuery(JPQL_POSITIONAL);\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  null);\r\n-\t\tq.setParameter(3,  null);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithSingleResult() {\r\n-\t\tQuery q = em.createNamedQuery(\"JPQL_POSITIONAL\");\r\n-\t\t// \"SELECT p FROM Binder p WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\"\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  null);\r\n-\t\tq.setParameter(3,  null);\r\n-\t\t\r\n-\t\tfail(q, true);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithNativeQuery() {\r\n-\t\tQuery q = em.createNamedQuery(\"SQL_POSITIONAL\");\r\n-\t\t// \"SELECT p.id FROM Binder WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\"\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  STR_VALUE);\r\n-\t\tq.setParameter(3,  DBL_VALUE);\r\n-\t\t\r\n-\t\tassertEquals(1,q.getResultList().size());\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithNativeQueryFails() {\r\n-\t\tQuery q = em.createNamedQuery(\"SQL_POSITIONAL\");\r\n-\t\t// \"SELECT p.id FROM Binder WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\"\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(2,  STR_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\tpublic void testPositionalParameterWithNativeQueryFailsWithGap() {\r\n-\t\tQuery q = em.createNamedQuery(\"SQL_POSITIONAL\");\r\n-\t\t// \"SELECT p.id FROM Binder WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\"\r\n-\t\tq.setParameter(1,  INT_VALUE);\r\n-\t\tq.setParameter(3,  DBL_VALUE);\r\n-\t\t\r\n-\t\tfail(q);\r\n-\t}\r\n-\t\r\n-\t\r\n-\tvoid fail(Query q) {\r\n-\t\tfail(q, false);\r\n-\t}\r\n-\t\r\n-\tvoid fail(Query q, boolean single) {\r\n-\t\ttry {\r\n-\t\t\tif (single) \r\n-\t\t\t\tq.getSingleResult();\r\n-\t\t\telse \r\n-\t\t\t\tq.getResultList();\r\n-\t\t\tfail(\"Expeceted \" + ArgumentException.class.getName());\r\n-\t\t} catch (IllegalArgumentException ex) {\r\n-\t\t// good\r\n-\t\t\tSystem.err.println(\"*** ERROR \" + getName());\r\n-\t\t\tSystem.err.println(\"*** ERROR \" + ex.getMessage());\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-}\r"},{"sha":"43e3ea8c69662842a0269c8d3861ed82849af5a7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/cache/TestNonPrimaryKeyQueryParameters.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -80,6 +80,7 @@ public void testSelectQueryWithNoParameter() {\n \t\tEntityManager em = emf.createEntityManager();\r\n \r\n \t\tQuery query = em.createQuery(\"SELECT d from Department d\");\r\n+\t\tquery.setParameter(1, DEPT_NAME);\r\n \t\tDepartment dept = (Department) query.getSingleResult();\r\n \r\n \t\tassertEquals(FULLTIME_EMPLOYEE_COUNT, dept.getFullTimeEmployees()\r"},{"sha":"37fdb656d80f57cfe971b4a283f0ea3bb63c08cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/d147f40cecdb8fa771ffbf656743400a4357afc5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","raw_url":"https://github.com/apache/openjpa/raw/d147f40cecdb8fa771ffbf656743400a4357afc5/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Binder.java?ref=d147f40cecdb8fa771ffbf656743400a4357afc5","patch":"@@ -1,51 +0,0 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.persistence.jdbc.query.domain;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.NamedNativeQuery;\r\n-import javax.persistence.NamedQuery;\r\n-\r\n-@Entity\r\n-@NamedQuery(name=\"JPQL_POSITIONAL\", \r\n-\t\tquery=\"SELECT p FROM Binder p WHERE p.p1=?1 AND p.p2=?2 AND p.p3=?3\")\r\n-@NamedNativeQuery(name=\"SQL_POSITIONAL\",\r\n-\t\tquery=\"SELECT id, p1 FROM Binder WHERE p1=?1 AND p2=?2 AND p3=?3\")\r\n-public class Binder {\r\n-\t@Id\r\n-\t@GeneratedValue\r\n-\tprivate long id;\r\n-\t\r\n-\tprivate int p1;\r\n-\tprivate String p2;\r\n-\tprivate double p3;\r\n-\t\r\n-\tprotected Binder() {\r\n-\t\tthis(-1, \"-1\" , -1.0);\r\n-\t}\r\n-\t\r\n-\tpublic Binder(int i1, String i2, double i3) {\r\n-\t\tp1 = i1;\r\n-\t\tp2 = i2;\r\n-\t\tp3 = i3;\r\n-\t}\r\n-\t\r\n-}\r"},{"sha":"81b85f558e0d7110a15cbd9f5ead711230c7b1ea","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -33,11 +33,11 @@\n import javax.persistence.SqlResultSetMapping;\r\n import javax.persistence.Table;\r\n \r\n-@NamedQuery(name=\"FindXTwo\", query=\"select s from simple s where s.name = ?1\")\r\n+@NamedQuery(name=\"FindXTwo\", query=\"select s from simple s where s.name = :fname\")\r\n \r\n @NamedQueries( {\r\n-    @NamedQuery(name=\"FindOne\", query=\"select s from simple s where s.name = ?1\"),\r\n-    @NamedQuery(name=\"FindOne\", query=\"select s from simple s where s.name = ?1\"),\r\n+    @NamedQuery(name=\"FindOne\", query=\"select s from simple s where s.name = :fname\"),\r\n+    @NamedQuery(name=\"FindOne\", query=\"select s from simple s where s.name = :fname\"),\r\n     @NamedQuery(name=\"FindAll\", query=\"select s from simple s\")\r\n })\r\n \r"},{"sha":"920fd2a0103fe1e5bdef4ebd2264d70df24de866","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -27,11 +27,11 @@\n import javax.persistence.NamedQuery;\r\n import javax.persistence.Table;\r\n \r\n-@NamedQuery(name=\"FindXTwo\", query=\"select s from simple2 s where s.name = ?1\")\r\n+@NamedQuery(name=\"FindXTwo\", query=\"select s from simple2 s where s.name = :fname\")\r\n \r\n @NamedQueries( {\r\n-    @NamedQuery(name=\"FindOne\", query=\"select s from simple2 s where s.name = ?1\"),\r\n-    @NamedQuery(name=\"Find2One\", query=\"select s from simple2 s where s.name = ?1\"),\r\n+    @NamedQuery(name=\"FindOne\", query=\"select s from simple2 s where s.name = :fname\"),\r\n+    @NamedQuery(name=\"Find2One\", query=\"select s from simple2 s where s.name = :fname\"),\r\n     @NamedQuery(name=\"Find2All\", query=\"select s from simple2 s\")\r\n })\r\n \r"},{"sha":"630a61878ad48054b7943f4a203c4cf3af443fc4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDupNamedQuery.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -60,8 +60,8 @@ private void simpleQuery(boolean simple2, String findOneQName,\n         assertNotNull(list);\n         assertEquals(list.size(), 1);\n         Object o = list.get(0);\n-        assertTrue(simple2 ? o instanceof SimpleEntity2 \n-        \t\t: o instanceof SimpleEntity);\n+        assertSame(o.getClass(), simple2 ? SimpleEntity2.class\n+            : SimpleEntity.class);\n         assertEquals(simple2 ? ((SimpleEntity2) o).getValue()\n             : ((SimpleEntity) o).getValue(), ValueOne);\n \n@@ -71,8 +71,8 @@ private void simpleQuery(boolean simple2, String findOneQName,\n             assertEquals(list.size(), 2);\n             for (Iterator resultIter = list.iterator(); resultIter.hasNext();) {\n                 o = resultIter.next();\n-                assertTrue(simple2 ? o instanceof SimpleEntity2 \n-                \t\t: o instanceof SimpleEntity);\n+                assertSame(o.getClass(), simple2 ? SimpleEntity2.class\n+                    : SimpleEntity.class);\n                 String n = null;\n                 String v = null;\n                 if (simple2) {"},{"sha":"2c52402a3b25489e99d72b78509f4504872af08d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","status":"modified","additions":0,"deletions":101,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -18,13 +18,7 @@\n  */\n package org.apache.openjpa.persistence.test;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n import java.lang.reflect.Modifier;\n-import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n@@ -302,99 +296,4 @@ else if (o1 == null || o2 == null)\n         else if (o1.equals(o2))\n             fail(\"expected args to be different; compared equal.\");\n     }\n-\n-    /**\n-     * Round-trip a serializable object to bytes.\n-     */\n-    public static Object roundtrip(Object o) \n-        throws ClassNotFoundException, IOException {\n-        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(bytes);\n-        out.writeObject(o);\n-        out.flush();\n-        ObjectInputStream in = new ObjectInputStream(\n-            new ByteArrayInputStream(bytes.toByteArray()));\n-        return in.readObject();\n-    }\n-    \n-    // ================================================ \n-    // Utility methods for exception handling\n-    // ================================================\n-    /**\n-\t * Asserts that the given targetType is assignable from given actual \n-\t * Throwable.\n-\t */\n-    protected void assertException(final Throwable actual, Class targetType) {\n-\t\tassertException(actual, targetType, null);\n-\t}\n-\t\n-\t/**\n-\t * Asserts that the given targetType is assignable from given actual \n-\t * Throwable. Asserts that the nestedType is nested (possibly recursively) \n-\t * within the given actual Throwable.\n-\t * \n-\t * @param actual is the actual throwable to be tested\n-\t * @param targetType is expected type or super type of actual. If null, then\n-\t * the check is omitted.\n-\t * @param nestedTargetType is expected type of exception nested within\n-\t * actual. If null this search is omitted. \n-\t * \n-\t */\n-    protected void assertException(final Throwable actual, Class targetType,\n-\t\t\tClass nestedTargetType) {\n-\t\tassertNotNull(actual);\n-\t\tClass actualType = actual.getClass();\n-\t\tif (targetType != null && !targetType.isAssignableFrom(actualType)) {\n-\t\t\tactual.printStackTrace();\n-\t\t\tfail(targetType.getName() + \" is not assignable from \"\n-\t\t\t\t\t+ actualType.getName());\n-\t\t}\n-\n-\t\tif (nestedTargetType != null) {\n-\t\t\tThrowable nested = actual.getCause();\n-\t\t\tClass nestedActualType = (nested == null) ? null : nested.getClass();\n-\t\t\twhile (nestedActualType != null) {\n-\t\t\t\tif (nestedTargetType.isAssignableFrom(nestedActualType)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t} else {\n-\t\t\t\t\tThrowable next = nested.getCause();\n-\t\t\t\t\tif (next == null || next == nested)\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tnestedActualType = next.getClass();\n-\t\t\t\t\tnested     = next;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tactual.printStackTrace();\n-\t\t\tfail(\"No nested type \" + nestedTargetType + \" in \" + actual);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Assert that each of given keys are present in the message of the given\n-\t * Throwable.\n-\t */\n-    protected void assertMessage(Throwable actual, String... keys) {\n-\t\tif (actual == null || keys == null)\n-\t\t\treturn;\n-\t\tString message = actual.getMessage();\n-\t\tfor (String key : keys) {\n-\t\t\tassertTrue(key + \" is not in \" + message, message.contains(key));\n-\t\t}\n-\t}\n-    \n-    public void printException(Throwable t) {\n-    \tprintException(t, 2);\n-    }\n-    \n-    public void printException(Throwable t, int tab) {\n-\t\tif (t == null) return;\n-\t\tfor (int i=0; i<tab*4;i++) System.out.print(\" \");\n-\t\tString sqlState = (t instanceof SQLException) ? \n-\t\t\t\"(SQLState=\" + ((SQLException)t).getSQLState() + \":\" \n-\t\t\t\t+ t.getMessage() + \")\" : \"\";\n-\t\tSystem.out.println(t.getClass().getName() + sqlState);\n-\t\tif (t.getCause() == t) \n-\t\t\treturn;\n-\t\tprintException(t.getCause(), tab+2);\n-\t}\n }"},{"sha":"b310a3c740bc7a20c04914f3fa07af381b59b9fe","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":8,"deletions":13,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -1582,17 +1582,14 @@ private void parseNamedQueries(AnnotatedElement el, NamedQuery... queries) {\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"parse-query\", query.name()));\n \n-            meta = getRepository().searchQueryMetaDataByName(query.name());\n+            meta = getRepository().getCachedQueryMetaData(null, query.name());\n             if (meta != null) {\n-            \tClass definingType = meta.getDefiningType();\n-                if ((definingType == null || definingType != _cls) \n-                  && _log.isWarnEnabled()) {\n-                    _log.warn(_loc.get(\"dup-query\", query.name(), el, \n-                    \t\tdefiningType));\n-                }\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"dup-query\", query.name(), el));\n                 continue;\n             }\n-            meta = getRepository().addQueryMetaData(_cls, query.name());\n+\n+            meta = getRepository().addQueryMetaData(null, query.name());\n             meta.setQueryString(query.query());\n             meta.setLanguage(JPQLParser.LANG_JPQL);\n             for (QueryHint hint : query.hints())\n@@ -1626,12 +1623,10 @@ private void parseNamedNativeQueries(AnnotatedElement el,\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"parse-native-query\", query.name()));\n \n-            meta = getRepository().searchQueryMetaDataByName(query.name());\n+            meta = getRepository().getCachedQueryMetaData(null, query.name());\n             if (meta != null) {\n-            \tClass defType = meta.getDefiningType();\n-                if ((defType != _cls) && _log.isWarnEnabled()) {\n-                    _log.warn(_loc.get(\"dup-query\", query.name(), el, defType));\n-                }\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"dup-query\", query.name(), el));\n                 continue;\n             }\n "},{"sha":"b29248cd2e85c3ce1f2524a1b8685e0d547e9e3f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":10,"deletions":19,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -87,7 +87,7 @@\n     private Map<FetchConfiguration,FetchPlan> _plans =\r\n         new IdentityHashMap<FetchConfiguration,FetchPlan>(1);\r\n \r\n-    private RuntimeExceptionTranslator _ret =\r\n+    private RuntimeExceptionTranslator ret =\r\n         PersistenceExceptions.getRollbackTranslator(this);\r\n \r\n     public EntityManagerImpl() {\r\n@@ -104,8 +104,8 @@ public EntityManagerImpl(EntityManagerFactoryImpl factory,\n \r\n     private void initialize(EntityManagerFactoryImpl factory, Broker broker) {\r\n         _emf = factory;\r\n-        _broker = new DelegatingBroker(broker, _ret);\r\n-        _broker.setImplicitBehavior(this, _ret);\r\n+        _broker = new DelegatingBroker(broker, ret);\r\n+        _broker.setImplicitBehavior(this, ret);\r\n     }\r\n \r\n     /**\r\n@@ -867,24 +867,15 @@ public OpenJPAQuery createQuery(String query) {\n \r\n     public OpenJPAQuery createQuery(String language, String query) {\r\n         assertNotCloseInvoked();\r\n-        try {\r\n-            org.apache.openjpa.kernel.Query q = _broker.newQuery(language, \r\n-                query);\r\n-            // have to validate JPQL according to spec\r\n-            if (JPQLParser.LANG_JPQL.equals(language))\r\n-                q.compile(); \r\n-            return new QueryImpl(this, _ret, q);\r\n-        } catch (RuntimeException re) {\r\n-            throw PersistenceExceptions.toPersistenceException(re);\r\n-        }\r\n+        return new QueryImpl(this, ret, _broker.newQuery(language, query));\r\n     }\r\n \r\n     public OpenJPAQuery createQuery(Query query) {\r\n         if (query == null)\r\n             return createQuery((String) null);\r\n         assertNotCloseInvoked();\r\n         org.apache.openjpa.kernel.Query q = ((QueryImpl) query).getDelegate();\r\n-        return new QueryImpl(this, _ret, _broker.newQuery(q.getLanguage(),\r\n+        return new QueryImpl(this, ret, _broker.newQuery(q.getLanguage(),\r\n             q));\r\n     }\r\n \r\n@@ -900,7 +891,7 @@ public OpenJPAQuery createNamedQuery(String name) {\n             meta.setInto(del);\r\n             del.compile();\r\n \r\n-            OpenJPAQuery q = new QueryImpl(this, _ret, del);\r\n+            OpenJPAQuery q = new QueryImpl(this, ret, del);\r\n             String[] hints = meta.getHintKeys();\r\n             Object[] values = meta.getHintValues();\r\n             for (int i = 0; i < hints.length; i++)\r\n@@ -926,7 +917,7 @@ public OpenJPAQuery createNativeQuery(String query, String mappingName) {\n         org.apache.openjpa.kernel.Query kernelQuery = _broker.newQuery(\r\n             QueryLanguages.LANG_SQL, query);\r\n         kernelQuery.setResultMapping(null, mappingName);\r\n-        return new QueryImpl(this, _ret, kernelQuery);\r\n+        return new QueryImpl(this, ret, kernelQuery);\r\n     }\r\n \r\n     /**\r\n@@ -1244,7 +1235,7 @@ public boolean equals(Object other) {\n     public void readExternal(ObjectInput in)\r\n         throws IOException, ClassNotFoundException {\r\n         try {\r\n-            _ret = PersistenceExceptions.getRollbackTranslator(this);\r\n+            ret = PersistenceExceptions.getRollbackTranslator(this);\r\n \r\n             // this assumes that serialized Brokers are from something\r\n             // that extends AbstractBrokerFactory.\r\n@@ -1263,7 +1254,7 @@ public void readExternal(ObjectInput in)\n             initialize(emf, broker);\r\n         } catch (RuntimeException re) {\r\n             try {\r\n-                re = _ret.translate(re);\r\n+                re = ret.translate(re);\r\n             } catch (Exception e) {\r\n                 // ignore\r\n             }\r\n@@ -1285,7 +1276,7 @@ public void writeExternal(ObjectOutput out) throws IOException {\n             out.writeObject(baos.toByteArray());\r\n         } catch (RuntimeException re) {\r\n             try {\r\n-                re = _ret.translate(re);\r\n+                re = ret.translate(re);\r\n             } catch (Exception e) {\r\n                 // ignore\r\n             }\r"},{"sha":"f2209f189675c15b5f842a7c5a78d6cf0def02f4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","status":"modified","additions":94,"deletions":256,"changes":350,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryImpl.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -20,10 +20,7 @@\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Collection;\n import java.util.Collections;\n@@ -33,8 +30,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.TreeMap;\n-\n import javax.persistence.FlushModeType;\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n@@ -72,17 +67,18 @@\n     private transient EntityManagerImpl _em;\n     private transient FetchPlan _fetch;\n \n-\tprivate Map<String, Object> _named;\n-\tprivate Map<Integer, Object> _positional;\n-\n-\tprivate static Object GAP_FILLER = new Object();\n+    private Map _named;\n+    private List _positional;\n \n     /**\n      * Constructor; supply factory exception translator and delegate.\n      * \n-     * @param em  The EntityManager which created this query\n-     * @param ret Exception translater for this query\n-     * @param query The underlying \"kernel\" query.\n+     * @param em\n+     *            The EntityManager which created this query\n+     * @param ret\n+     *            Exception translater for this query\n+     * @param query\n+     *            The underlying \"kernel\" query.\n      */\n     public QueryImpl(EntityManagerImpl em, RuntimeExceptionTranslator ret,\n         org.apache.openjpa.kernel.Query query) {\n@@ -250,179 +246,47 @@ private Object execute() {\n \n         validateParameters();\n \n-\t\t// handle which types of parameters we are using, if any\n-\t\tif (_positional != null)\n-\t\t\treturn _query.execute(_positional);\n-\t\tif (_named != null)\n-\t\t\treturn _query.execute(_named);\n-\t\treturn _query.execute();\n-\t}\n-\t\n-\t/**\n-\t * Validate that the types of the parameters are correct.\n-\t * The idea is to catch as many validation error as possible at the facade\n-\t * layer itself.\n-\t * For native SQL queries, however, parameter validation is bypassed as\n-\t * we do not parse SQL.\n-\t * \n-\t * The expected parameters are parsed from the query and in a LinkedMap \n-\t *\tkey   : name of the parameter as declared in query\n-\t *  value : expected Class of allowed value\n-\t *  \n-\t * The bound parameters depends on positional or named parameter style\n-\t * \n-\t * TreeMap<Integer, Object> for positional parameters:\n-\t *   key   : 1-based Integer index\n-\t *   value : bound value. GAP_FILLER if the position is not set. This\n-\t *   simplifies validation at the kernel layer\n-\t *   \n-\t * Map<String, Object> for named parameters:\n-\t *   key   : parameter name\n-\t *   value : the bound value\n-\t *   \n-\t *  Validation accounts for \n-\t *    a) gaps in positional parameters\n-\t *       SELECT p FROM PObject p WHERE p.a1=?1 AND p.a3=?3\n-\t *    \n-\t *    b) repeated parameters\n-\t *       SELECT p FROM PObject p WHERE p.a1=?1 AND p.a2=?1 AND p.a3=?2\n-\t *       \n-\t *    c) parameter is bound but not declared\n-\t *    \n-\t *    d) parameter is declared but not bound\n-\t *    \n-\t *    e) parameter does not match the value type\n-\t *    \n-\t *    f) parameter is primitive type but bound to null value\n-\t */\n-\tprivate void validateParameters() {\n-\t\tif (isNative()) {\n-\t\t\tremoveGaps(_positional);\n-\t\t\treturn;\n-\t\t}\n-\t\tString query = getQueryString();\n-\t\tif (_positional != null) {\n-\t\t\tLinkedMap expected = _query.getParameterTypes();\n-\t\t\tMap<Integer, Object> actual = _positional;\n-\t\t\tfor (Object o : expected.keySet()) {\n-\t\t\t\tString position = (String) o;\n-\t\t\t\tClass expectedParamType = (Class) expected.get(position);\n-\t\t\t\ttry {\n-\t\t\t\t\tInteger.parseInt(position);\n-\t\t\t\t} catch (NumberFormatException ex) {\n-\t\t\t\t\tnewValidationException(\"param-style-mismatch\", query,\n-\t\t\t\t\t\t\texpected.asList(),\n-\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n-\t\t\t\t}\n-\t\t\t\tObject actualValue = actual.get(Integer.parseInt(position));\n-\t\t\t\tboolean valueUnspecified = (actualValue == GAP_FILLER)\n-\t\t\t\t\t\t|| (actualValue == null && (actual.size() < expected\n-\t\t\t\t\t\t\t\t.size()));\n-\t\t\t\tif (valueUnspecified) \n-\t\t\t\t\tnewValidationException(\"param-missing\", position, query,\n-\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n-\t\t\t\t\n-\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n-\t\t\t\t\tnewValidationException(\"param-type-null\", \n-\t\t\t\t\t\t\tposition, query, expectedParamType.getName());\n-\t\t\t\tif (actualValue != null &&\n-\t\t\t\t   !Filters.wrap(expectedParamType).isInstance(actualValue)) \n-\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n-\t\t\t\t\t\t\tposition, query, actualValue,\n-\t\t\t\t\t\t\tactualValue.getClass().getName(),\n-\t\t\t\t\t\t\texpectedParamType.getName());\n-\t\t\t\t\n-\t\t\t}\n-\t\t\tfor (Integer position : actual.keySet()) {\n-\t\t\t\tObject actualValue = actual.get(position);\n-\t\t\t\tClass expectedParamType = (Class) expected.get(\"\" + position);\n-\t\t\t\tboolean paramExpected = expected.containsKey(\"\" + position);\n-\t\t\t\tif (actualValue == GAP_FILLER) {\n-\t\t\t\t\tif (paramExpected) {\n-\t\t\t\t\t\tnewValidationException(\"param-missing\", position, query,\n-\t\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tif (!paramExpected)\n-\t\t\t\t\t\tnewValidationException(\"param-extra\", position, query,\n-\t\t\t\t\t\t\t\texpected.asList());\n-\t\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n-\t\t\t\t\t\tnewValidationException(\"param-type-null\", \n-\t\t\t\t\t\t\t\tposition, query, expectedParamType.getName());\n-\t\t\t\t\tif (actualValue != null \n-\t\t\t\t\t && !Filters.wrap(expectedParamType).isInstance(actualValue)) \n-\t\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n-\t\t\t\t\t\t\t\tposition, query, actualValue,\n-\t\t\t\t\t\t\t\tactualValue.getClass().getName(),\n-\t\t\t\t\t\t\t\texpectedParamType.getName());\n-\t\t\t\t\t\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} else if (_named != null) {\n-\t\t\tLinkedMap expected = _query.getParameterTypes();\n-\t\t\t// key : name of the parameter used while binding\n-\t\t\t// value : user supplied parameter value. null may mean either\n-\t\t\t// user has supplied a value or not specified at all\n-\t\t\tMap<String, Object> actual = _named;\n-\t\t\tfor (Object o : expected.keySet()) {\n-\t\t\t\tString expectedName = (String) o;\n-\t\t\t\tClass expectedParamType = (Class) expected.get(expectedName);\n-\t\t\t\tObject actualValue = actual.get(expectedName);\n-\t\t\t\tboolean valueUnspecified = !actual.containsKey(expectedName);\n-\t\t\t\tif (valueUnspecified) {\n-\t\t\t\t\tnewValidationException(\"param-missing\", expectedName, query,\n-\t\t\t\t\t\t\tArrays.toString(actual.keySet().toArray()));\n-\t\t\t\t}\n-\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n-\t\t\t\t\tnewValidationException(\"param-type-null\", \n-\t\t\t\t\t\t\texpectedName, query, expectedParamType.getName());\n-\t\t\t\tif (actualValue != null \n-\t\t\t\t && !Filters.wrap(expectedParamType).isInstance(actualValue)) {\n-\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n-\t\t\t\t\t\t\texpectedName, query, actualValue,\n-\t\t\t\t\t\t\tactualValue.getClass().getName(),\n-\t\t\t\t\t\t\texpectedParamType.getName());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor (String actualName : actual.keySet()) {\n-\t\t\t\tObject actualValue = actual.get(actualName);\n-\t\t\t\tClass expectedParamType = (Class) expected.get(actualName);\n-\t\t\t\tboolean paramExpected = expected.containsKey(actualName);\n-\t\t\t\tif (!paramExpected) {\n-\t\t\t\t\tnewValidationException(\"param-extra\", actualName, query,\n-\t\t\t\t\t\t\texpected.asList());\n-\t\t\t\t}\n-\t\t\t\tif (expectedParamType.isPrimitive() && actualValue == null)\n-\t\t\t\t\tnewValidationException(\"param-type-null\", \n-\t\t\t\t\t\t\tactualName, query, expectedParamType.getName());\n-\t\t\t\tif (actualValue != null \n-\t\t\t\t && !Filters.wrap(expectedParamType).isInstance(actualValue)) {\n-\t\t\t\t\tnewValidationException(\"param-type-mismatch\",\n-\t\t\t\t\t\t\tactualName, query, actualValue,\n-\t\t\t\t\t\t\tactualValue.getClass().getName(),\n-\t\t\t\t\t\t\texpectedParamType.getName());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\t\n-\tMap<Integer, Object> removeGaps(Map<Integer, Object> map) {\n-\t\tif (map == null || !map.containsValue(GAP_FILLER))\n-\t\t\treturn map;\n-\t\tList<Integer> gaps = new ArrayList<Integer>();\n-\t\tfor (Integer key : map.keySet())\n-\t\t\tif (map.get(key) == GAP_FILLER)\n-\t\t\t\tgaps.add(key);\n-\t\tfor (Integer gap : gaps) {\n-\t\t\tmap.remove(gap);\n-\t\t}\n-\t\treturn map;\n-\t}\n+        // handle which types of parameters we are using, if any\n+        if (_positional != null)\n+            return _query.execute(_positional.toArray());\n+        if (_named != null)\n+            return _query.execute(_named);\n+        return _query.execute();\n+    }\n \n-\tvoid newValidationException(String msgKey, Object...args) {\n-\t\tthrow new ArgumentException(_loc.get(msgKey, args), null, null, false);\n-\t}\n+    /**\n+     * Validate that the types of the parameters are correct.\n+     */\n+    private void validateParameters() {\n+        if (_positional != null) {\n+            LinkedMap types = _query.getParameterTypes();\n+            for (int i = 0,\n+                size = Math.min(_positional.size(), types.size());\n+                i < size; i++)\n+                validateParameter(String.valueOf(i),\n+                    (Class) types.getValue(i), _positional.get(i));\n+        } else if (_named != null) {\n+            Map types = _query.getParameterTypes();\n+            for (Iterator i = _named.entrySet().iterator(); i.hasNext();) {\n+                Map.Entry entry = (Map.Entry) i.next();\n+                String name = (String) entry.getKey();\n+                validateParameter(name, (Class) types.get(name),\n+                    entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private void validateParameter(String paramDesc, Class type, Object param) {\n+        // null parameters are allowed, so are not validated\n+        if (param == null || type == null)\n+            return;\n+\n+        // check the parameter against the wrapped type\n+        if (!Filters.wrap(type).isInstance(param))\n+            throw new ArgumentException(_loc.get(\"bad-param-type\",\n+                paramDesc, param.getClass().getName(), type.getName()),\n+                null, null, false);\n+    }\n \n     public List getResultList() {\n         _em.assertNotCloseInvoked();\n@@ -460,15 +324,15 @@ public int executeUpdate() {\n         if (_query.getOperation() == QueryOperations.OP_DELETE) {\n             // handle which types of parameters we are using, if any\n             if (_positional != null)\n-                return asInt(_query.deleteAll(_positional));\n+                return asInt(_query.deleteAll(_positional.toArray()));\n             if (_named != null)\n                 return asInt(_query.deleteAll(_named));\n             return asInt(_query.deleteAll());\n         }\n         if (_query.getOperation() == QueryOperations.OP_UPDATE) {\n             // handle which types of parameters we are using, if any\n             if (_positional != null)\n-                return asInt(_query.updateAll(_positional));\n+                return asInt(_query.updateAll(_positional.toArray()));\n             if (_named != null)\n                 return asInt(_query.updateAll(_named));\n             return asInt(_query.updateAll());\n@@ -569,76 +433,57 @@ private void hintToSetter(FetchPlan fetchPlan, String k, Object value) {\n \n     public OpenJPAQuery setParameter(int position, Calendar value,\n         TemporalType t) {\n-        return setParameter(position, convertTemporalType(value, t));\n+        return setParameter(position, value);\n     }\n \n     public OpenJPAQuery setParameter(int position, Date value,\n         TemporalType type) {\n-        return setParameter(position, convertTemporalType(value, type));\n+        return setParameter(position, value);\n     }\n \n-    /**\n-     * Converts the given Date to a value corresponding to given temporal type.\n-     */\n-    Object convertTemporalType(Date value, TemporalType type) {\n-            switch (type) {\n-            case DATE:\n-                    return value;\n-            case TIME:\n-                    return new Time(value.getTime());\n-            case TIMESTAMP:\n-                    return new Timestamp(value.getTime());\n-            default:\n-                    return null;\n-            }\n-    }\n-    \n-    Object convertTemporalType(Calendar value, TemporalType type) {\n-            return convertTemporalType(value.getTime(), type);\n-    }\n-    \n     public OpenJPAQuery setParameter(int position, Object value) {\n-\t\t_query.assertOpen();\n-\t\t_em.assertNotCloseInvoked();\n-\t\t_query.lock();\n-\t\ttry {\n-\t\t\tif (isNative() && position < 1) {\n-\t\t\t\tthrow new IllegalArgumentException(_loc.get(\"bad-pos-params\",\n-\t\t\t\t\t\tposition, _query.getQueryString()).toString());\n-\t\t\t}\n-\t\t\t// not allowed to mix positional and named parameters (EDR2 3.6.4)\n-\t\t\tif (_named != null)\n-\t\t\t\tthrow new InvalidStateException(_loc.get(\n-\t\t\t\t\t\t\"no-pos-named-params-mix\", _query.getQueryString()),\n-\t\t\t\t\t\tnull, null, false);\n-\n-\t\t\tif (position < 1)\n-\t\t\t\tthrow new InvalidStateException(_loc.get(\"illegal-index\",\n-\t\t\t\t\t\tposition), null, null, false);\n-\n-\t\t\tif (_positional == null)\n-\t\t\t\t_positional = new TreeMap<Integer, Object>();\n-\n-\t\t\t_positional.put(position, value);\n-\t\t\tfor (int i = 1; i < position; i++)\n-\t\t\t\tif (!_positional.containsKey(i))\n-\t\t\t\t\t_positional.put(i, GAP_FILLER);\n-\n-\t\t\treturn this;\n-\t\t} finally {\n-\t\t\t_query.unlock();\n-\t\t}\n-\t}\n+        _query.assertOpen();\n+        _em.assertNotCloseInvoked();\n+        _query.lock();\n+        try {\n+        \tif (isNative() && position < 1) {\n+        \t\tthrow new IllegalArgumentException(_loc.get(\"bad-pos-params\", \n+        \t\t      position, _query.getQueryString()).toString());\n+        \t}\n+            // not allowed to mix positional and named parameters (EDR2 3.6.4)\n+            if (_named != null)\n+                throw new InvalidStateException(_loc.get\n+                    (\"no-pos-named-params-mix\", _query.getQueryString()),\n+                    null, null, false);\n+\n+            if (position < 1)\n+                throw new InvalidStateException(_loc.get\n+                    (\"illegal-index\", position), null, null, false);\n+\n+            if (_positional == null)\n+                _positional = new ArrayList();\n+\n+            // make sure it is at least the requested size\n+            while (_positional.size() < position)\n+                _positional.add(null);\n \n+            // note that we add it to position - 1, since setPosition\n+            // starts at 1, while List starts at 0\n+            _positional.set(position - 1, value);\n+            return this;\n+        } finally {\n+            _query.unlock();\n+        }\n+    }\n \n     public OpenJPAQuery setParameter(String name, Calendar value,\n         TemporalType t) {\n-        return setParameter(name, convertTemporalType(value, t));\n+        return setParameter(name, value);\n     }\n \n     public OpenJPAQuery setParameter(String name, Date value,\n         TemporalType type) {\n-        return setParameter(name, convertTemporalType(value, type));\n+        return setParameter(name, value);\n     }\n \n     public OpenJPAQuery setParameter(String name, Object value) {\n@@ -673,21 +518,14 @@ public boolean hasPositionalParameters() {\n         return _positional != null;\n     }\n \n-\t/**\n-\t * Gets the array of positional parameter values. A value of\n-\t * <code>GAP_FILLER</code> indicates that user has not set the\n-\t * corresponding positional parameter. A value of null implies that user has\n-\t * set the value as null.\n-\t */\n-\tpublic Object[] getPositionalParameters() {\n-\t\t_query.lock();\n-\t\ttry {\n-\t\t\treturn (_positional == null) ? EMPTY_ARRAY : _positional.values()\n-\t\t\t\t\t.toArray();\n-\t\t} finally {\n-\t\t\t_query.unlock();\n-\t\t}\n-\t}\n+    public Object[] getPositionalParameters() {\n+        _query.lock();\n+        try {\n+            return (_positional == null) ? EMPTY_ARRAY : _positional.toArray();\n+        } finally {\n+            _query.unlock();\n+        }\n+    }\n \n     public OpenJPAQuery setParameters(Object... params) {\n         _query.assertOpen();"},{"sha":"30ab53773c9285552ff676ec242ab1a3984fe4d3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":3,"deletions":9,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -1391,15 +1391,9 @@ protected boolean startNamedQuery(Attributes attrs)\n         if (log.isTraceEnabled())\n             log.trace(_loc.get(\"parse-query\", name));\n \n-        QueryMetaData meta = getRepository().searchQueryMetaDataByName(name);\n-        if (meta != null) {\n-        \tClass defType = meta.getDefiningType();\n-            if ((defType != _cls) && log.isWarnEnabled()) {\n-            \tlog.warn(_loc.get(\"dup-query\", name, currentLocation(), defType));\n-            }\n-            pushElement(meta);\n-            return true;\n-        }\n+        QueryMetaData meta = getRepository().getCachedQueryMetaData(null, name);\n+        if (meta != null && log.isWarnEnabled())\n+            log.warn(_loc.get(\"override-query\", name, currentLocation()));\n \n         meta = getRepository().addQueryMetaData(null, name);\n         meta.setDefiningType(_cls);"},{"sha":"2323f27df46eff6e056cc37aebe611197356abdd","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","status":"modified","additions":2,"deletions":12,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -34,8 +34,7 @@ dup-metadata: Found duplicate metadata or mapping for \"{0}\".  Ignoring.\n dup-sequence: Found duplicate generator \"{0}\" in \"{1}\".  Ignoring.\n override-sequence: Found duplicate generator \"{0}\" in \"{1}\".  Overriding \\\n \tprevious definition.\n-dup-query: Ignoring duplicate query \"{0}\" in \"{1}\". A query with the same name \\\n-\tbeen already declared in \"{2}\".\n+dup-query: Found duplicate query \"{0}\" in \"{1}\".  Ignoring.\n override-query: Found duplicate query \"{0}\" in \"{1}\".  Overriding previous \\\n \tdefinition.\n no-seq-name: The sequence generator in \"{0}\" must declare a name.\n@@ -149,13 +148,4 @@ EntityManagerFactory-cat: Persistence.Advanced\n EntityManagerFactory-displayorder: 50\n EntityManagerFactory-expert: true\n EntityManagerFactory-interface: org.apache.openjpa.persistence.EntityManagerFactoryImpl\n-param-style-mismatch: Query \"{0}\" is declared with named parameters \"{1}\" but \\\n-\tactual parameters \"{2}\" are bound by position.\n-param-missing: Parameter \"{0}\" declared in \"{1}\" but is missing from the bound \\\n-\tparameters \"{2}\".\n-param-extra: Parameter \"{0}\" is bound to \"{1}\" but is missing from the \\\n-\tdeclared parameters \"{2}\".\n-param-type-mismatch: Parameter \"{0}\" declared in \"{1}\" is set to value of \\\n-\t\"{2}\" of type \"{3}\", but this parameter is bound to a field of type \"{4}\".\n-param-type-null: Parameter \"{0}\" declared in \"{1}\" is set to null, \\\n-\tbut this parameter is bound to a field of primitive type \"{2}\".\n+"},{"sha":"0fefc75c6f3d45ff6ad233d4f5353fed7858672b","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreManager.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -102,10 +102,6 @@ public DistributedStoreManager(DistributedJDBCConfiguration conf) {\n     public DistributedJDBCConfiguration getConfiguration() {\r\n         return _conf;\r\n     }\r\n-    \r\n-    public SliceStoreManager getSlice(int i) {\r\n-    \treturn _slices.get(i);\r\n-    }\r\n \r\n     /**\r\n      * Decides the index of the StoreManager by first looking at the\r"},{"sha":"b2450659f94bd6775efff3cf9f5480d108ed12dc","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","status":"modified","additions":14,"deletions":22,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/2272472f96818db391d7602b5bc89c8d7939489a/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedStoreQuery.java?ref=2272472f96818db391d7602b5bc89c8d7939489a","patch":"@@ -32,7 +32,6 @@\n import org.apache.openjpa.kernel.FetchConfiguration;\r\n import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n import org.apache.openjpa.kernel.StoreQuery;\r\n import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n@@ -62,15 +61,17 @@ void add(StoreQuery q) {\n \t\t_queries.add(q);\r\n \t}\r\n \t\r\n-\tpublic DistributedStoreManager getDistributedStore() {\r\n-\t\treturn (DistributedStoreManager)getStore();\r\n-\t}\r\n-\t\r\n     public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n     \tParallelExecutor ex = new ParallelExecutor(this, meta, subs, _parser, \r\n     \t\t\tctx.getCompilation());\r\n-        for (StoreQuery q : _queries) {\r\n-            ex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n+    \t\r\n+    \tFetchConfiguration fetch = getContext().getFetchConfiguration();\r\n+    \tDistributedStoreManager store = (DistributedStoreManager)getContext()\r\n+    \t    .getStoreContext().getStoreManager().getInnermostDelegate();\r\n+        List<SliceStoreManager> targets = store.getTargets(fetch);\r\n+        for (StoreQuery q:_queries) {\r\n+            if (targets.contains(((JDBCStoreQuery)q).getStore()))\r\n+                ex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n         }\r\n         return ex;\r\n     }\r\n@@ -116,23 +117,19 @@ public ParallelExecutor(DistributedStoreQuery dsq, ClassMetaData meta,\n          */\r\n         public ResultObjectProvider executeQuery(StoreQuery q,\r\n                 final Object[] params, final Range range) {\r\n+        \tResultObjectProvider[] tmp = new ResultObjectProvider[executors.size()];\r\n+        \tfinal Iterator<StoreQuery> qs = owner._queries.iterator();\r\n         \tfinal List<Future<ResultObjectProvider>> futures = \r\n         \t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n-        \tList<SliceStoreManager> targets = findTargets();\r\n-        \tfor (int i = 0; i < owner._queries.size(); i++) {\r\n-        \t\tStoreQuery query = owner._queries.get(i);\r\n-        \t\tStoreManager sm  = owner.getDistributedStore().getSlice(i);\r\n-        \t\tif (!targets.contains(sm))\r\n-        \t\t\tcontinue;\r\n+        \tint i = 0;\r\n+        \tfor (Executor ex:executors)  {\r\n         \t\tQueryExecutor call = new QueryExecutor();\r\n-        \t\tcall.executor = executors.get(i);\r\n-        \t\tcall.query    = query;\r\n+        \t\tcall.executor = ex;\r\n+        \t\tcall.query    = qs.next();\r\n         \t\tcall.params   = params;\r\n         \t\tcall.range    = range;\r\n         \t\tfutures.add(threadPool.submit(call)); \r\n         \t}\r\n-        \tint i = 0;\r\n-        \tResultObjectProvider[] tmp = new ResultObjectProvider[futures.size()];\r\n         \tfor (Future<ResultObjectProvider> future:futures) {\r\n         \t\ttry {\r\n \t\t\t\t\ttmp[i++] = future.get();\r\n@@ -213,11 +210,6 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n         \t}\r\n         \treturn new Integer(N);\r\n         }\r\n-        \r\n-        List<SliceStoreManager> findTargets() {\r\n-        \tFetchConfiguration fetch = owner.getContext().getFetchConfiguration();\r\n-        \treturn owner.getDistributedStore().getTargets(fetch);\r\n-        }\r\n \r\n \t}\r\n \t\r"}]}

