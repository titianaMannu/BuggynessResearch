{"sha":"27e0e704adafd18b6056e6f1b886b202d7e36e69","node_id":"MDY6Q29tbWl0MjA2MzY0OjI3ZTBlNzA0YWRhZmQxOGI2MDU2ZTZmMWI4ODZiMjAyZDdlMzZlNjk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2011-06-20T15:09:37Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2011-06-20T15:09:37Z"},"message":"OPENJPA-2008: Setting svn eol-style for DistributedSQLStoreQuery\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1137651 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7c19117fd72383006489605cb0d1dd55b2893e91","url":"https://api.github.com/repos/apache/openjpa/git/trees/7c19117fd72383006489605cb0d1dd55b2893e91"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/27e0e704adafd18b6056e6f1b886b202d7e36e69","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/27e0e704adafd18b6056e6f1b886b202d7e36e69","html_url":"https://github.com/apache/openjpa/commit/27e0e704adafd18b6056e6f1b886b202d7e36e69","comments_url":"https://api.github.com/repos/apache/openjpa/commits/27e0e704adafd18b6056e6f1b886b202d7e36e69/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"f0fbbaa26af65fd21cce0fc78dee7b545dfb93f6","url":"https://api.github.com/repos/apache/openjpa/commits/f0fbbaa26af65fd21cce0fc78dee7b545dfb93f6","html_url":"https://github.com/apache/openjpa/commit/f0fbbaa26af65fd21cce0fc78dee7b545dfb93f6"}],"stats":{"total":586,"additions":293,"deletions":293},"files":[{"sha":"fc8797cb9291df183216447dedf8b9ec4b4ee15e","filename":"openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","status":"modified","additions":293,"deletions":293,"changes":586,"blob_url":"https://github.com/apache/openjpa/blob/27e0e704adafd18b6056e6f1b886b202d7e36e69/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/27e0e704adafd18b6056e6f1b886b202d7e36e69/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-slice/src/main/java/org/apache/openjpa/slice/jdbc/DistributedSQLStoreQuery.java?ref=27e0e704adafd18b6056e6f1b886b202d7e36e69","patch":"@@ -1,293 +1,293 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.slice.jdbc;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.concurrent.Callable;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.ExecutorService;\r\n-import java.util.concurrent.Future;\r\n-import java.util.concurrent.SynchronousQueue;\r\n-import java.util.concurrent.ThreadFactory;\r\n-import java.util.concurrent.ThreadPoolExecutor;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\r\n-import org.apache.openjpa.jdbc.kernel.SQLStoreQuery;\r\n-import org.apache.openjpa.kernel.AbstractStoreQuery;\r\n-import org.apache.openjpa.kernel.BrokerImpl;\r\n-import org.apache.openjpa.kernel.ExpressionStoreQuery;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.QueryImpl;\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.ExpressionParser;\r\n-import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.slice.DistributedConfiguration;\r\n-import org.apache.openjpa.slice.SliceThread;\r\n-import org.apache.openjpa.util.StoreException;\r\n-\r\n-/**\r\n- * A query for distributed databases.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-@SuppressWarnings(\"serial\")\r\n-class DistributedSQLStoreQuery extends SQLStoreQuery {\r\n-\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\r\n-\r\n-\tpublic DistributedSQLStoreQuery(JDBCStore store) {\r\n-\t\tsuper(store);\r\n-\t}\r\n-\r\n-\tvoid add(StoreQuery q) {\r\n-\t\t_queries.add(q);\r\n-\t}\r\n-\r\n-\tpublic DistributedJDBCStoreManager getDistributedStore() {\r\n-\t\treturn (DistributedJDBCStoreManager) getStore();\r\n-\t}\r\n-\r\n-\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-\t\tboolean parallel = !getContext().getStoreContext().getBroker()\r\n-\t\t\t.getMultithreaded();\r\n-        ParallelExecutor ex = new ParallelExecutor(this, meta, parallel);\r\n-\t\tfor (StoreQuery q : _queries) {\r\n-\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\r\n-\t\t}\r\n-\t\treturn ex;\r\n-\t}\r\n-\r\n-\tpublic void setContext(QueryContext ctx) {\r\n-\t\tsuper.setContext(ctx);\r\n-\t\tfor (StoreQuery q : _queries)\r\n-\t\t\tq.setContext(ctx);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Executes queries on multiple databases.\r\n-\t * \r\n-\t * @author Pinaki Poddar\r\n-\t * \r\n-\t */\r\n-\tpublic static class ParallelExecutor extends\r\n-\t\t\tSQLStoreQuery.SQLExecutor {\r\n-\t\tprivate List<Executor> executors = new ArrayList<Executor>();\r\n-\t\tprivate DistributedSQLStoreQuery owner = null;\r\n-\r\n-        public ParallelExecutor(DistributedSQLStoreQuery dsq, ClassMetaData meta, boolean p) {\r\n-\t\t\tsuper(dsq, meta);\r\n-\t\t\towner = dsq;\r\n-\t\t}\r\n-\r\n-\t\tpublic void addExecutor(Executor ex) {\r\n-\t\t\texecutors.add(ex);\r\n-\t\t}\r\n-\r\n-\t\t/**\r\n-         * Each child query must be executed with slice context and not the\r\n-\t\t * given query context.\r\n-\t\t */\r\n-\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\r\n-\t\t\t\tfinal Object[] params, final Range range) {\r\n-\t\t\tList<Future<ResultObjectProvider>> futures = \r\n-\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\r\n-            final List<Executor> usedExecutors = new ArrayList<Executor>();\r\n-\t\t\tfinal List<ResultObjectProvider> rops = \r\n-\t\t\t\tnew ArrayList<ResultObjectProvider>();\r\n-\t\t\tList<SliceStoreManager> targets = findTargets();\r\n-\t\t\tQueryContext ctx = q.getContext();\r\n-\t\t\tboolean isReplicated = containsReplicated(ctx);\r\n-            ExecutorService threadPool = SliceThread.getPool();\r\n-\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\r\n-                // if replicated, then execute only on single slice\r\n-\t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-                StoreManager sm = owner.getDistributedStore().getSlice(i);\r\n-\t\t\t\tif (!targets.contains(sm))\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\tStoreQuery query = owner._queries.get(i);\r\n-\t\t\t\tExecutor executor = executors.get(i);\r\n-\t\t\t\tif (!targets.contains(sm))\r\n-\t\t\t\t\tcontinue;\r\n-\t\t\t\tusedExecutors.add(executor);\r\n-                QueryExecutor call = new QueryExecutor();\r\n-                call.executor = executor;\r\n-                call.query = query;\r\n-                call.params = params;\r\n-                call.range = range;\r\n-                futures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<ResultObjectProvider> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\trops.add(future.get());\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\tResultObjectProvider[] tmp = rops\r\n-                    .toArray(new ResultObjectProvider[rops.size()]);\r\n-\t\t\tResultObjectProvider result = null;\r\n-\t\t\tboolean[] ascending = getAscending(q);\r\n-\t\t\tboolean isAscending = ascending.length > 0;\r\n-\t\t\tboolean isAggregate = ctx.isAggregate();\r\n-\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\r\n-\t\t\tif (isAggregate) {\r\n-\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\r\n-\t\t\t\t\t\tgetQueryExpressions());\r\n-\t\t\t} else if (isAscending) {\r\n-                result = new OrderingMergedResultObjectProvider(tmp, ascending,\r\n-                    usedExecutors.toArray(new Executor[usedExecutors.size()]),\r\n-\t\t\t\t\tq, params);\r\n-\t\t\t} else {\r\n-\t\t\t\tresult = new MergedResultObjectProvider(tmp);\r\n-\t\t\t}\r\n-\t\t\tif (hasRange) {\r\n-                result = new RangeResultObjectProvider(result,\r\n-                        ctx.getStartRange(), ctx.getEndRange());\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\t/**\r\n-         * Scans metadata to find out if a replicated class is the candidate.\r\n-\t\t */\r\n-\t\tboolean containsReplicated(QueryContext query) {\r\n-\t\t\tClass<?> candidate = query.getCandidateType();\r\n-\t\t\tDistributedConfiguration conf = (DistributedConfiguration)query.getStoreContext()\r\n-\t\t\t    .getConfiguration();\r\n-\t\t\tif (candidate != null) {\r\n-\t\t\t    return conf.isReplicated(candidate);\r\n-\t\t\t}\r\n-\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\r\n-\t\t\tif (metas == null || metas.length < 1)\r\n-\t\t\t\treturn false;\r\n-\t\t\tfor (ClassMetaData meta : metas)\r\n-\t\t\t\tif (conf.isReplicated(meta.getDescribedType()))\r\n-\t\t\t\t\treturn true;\r\n-\t\t\treturn false;\r\n-\t\t}\r\n-\r\n-\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\r\n-\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-\t\t\tList<Future<Number>> futures = null;\r\n-\t\t\tint result = 0;\r\n-            ExecutorService threadPool = SliceThread.getPool();\r\n-\t\t\tfor (Executor ex : executors) {\r\n-\t\t\t\tif (futures == null)\r\n-                    futures = new ArrayList<Future<Number>>();\r\n-\t\t\t\tDeleteExecutor call = new DeleteExecutor();\r\n-\t\t\t\tcall.executor = ex;\r\n-\t\t\t\tcall.query = qs.next();\r\n-\t\t\t\tcall.params = params;\r\n-\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<Number> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tNumber n = future.get();\r\n-\t\t\t\t\tif (n != null)\r\n-\t\t\t\t\t\tresult += n.intValue();\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\r\n-\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\r\n-\t\t\tList<Future<Number>> futures = null;\r\n-\t\t\tint result = 0;\r\n-            ExecutorService threadPool = SliceThread.getPool();\r\n-\t\t\tfor (Executor ex : executors) {\r\n-\t\t\t\tif (futures == null)\r\n-                    futures = new ArrayList<Future<Number>>();\r\n-\t\t\t\tUpdateExecutor call = new UpdateExecutor();\r\n-\t\t\t\tcall.executor = ex;\r\n-\t\t\t\tcall.query = qs.next();\r\n-\t\t\t\tcall.params = params;\r\n-\t\t\t\tfutures.add(threadPool.submit(call));\r\n-\t\t\t}\r\n-\t\t\tfor (Future<Number> future : futures) {\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tNumber n = future.get();\r\n-                    result += (n == null) ? 0 : n.intValue();\r\n-\t\t\t\t} catch (InterruptedException e) {\r\n-\t\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t\t} catch (ExecutionException e) {\r\n-\t\t\t\t\tthrow new StoreException(e.getCause());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn result;\r\n-\t\t}\r\n-\r\n-\t\tList<SliceStoreManager> findTargets() {\r\n-\t\t\tFetchConfiguration fetch = owner.getContext()\r\n-\t\t\t\t\t.getFetchConfiguration();\r\n-\t\t\treturn owner.getDistributedStore().getTargets(fetch);\r\n-\t\t}\r\n-\t\t\r\n-\t}\r\n-\r\n-\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\t\tRange range;\r\n-\r\n-\t\tpublic ResultObjectProvider call() throws Exception {\r\n-\t\t\treturn executor.executeQuery(query, params, range);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic class DeleteExecutor implements Callable<Number> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\r\n-\t\tpublic Number call() throws Exception {\r\n-\t\t\treturn executor.executeDelete(query, params);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic class UpdateExecutor implements Callable<Number> {\r\n-\t\tStoreQuery query;\r\n-\t\tExecutor executor;\r\n-\t\tObject[] params;\r\n-\r\n-\t\tpublic Number call() throws Exception {\r\n-\t\t    return executor.executeUpdate(query, params);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.slice.jdbc;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreQuery;\n+import org.apache.openjpa.jdbc.kernel.SQLStoreQuery;\n+import org.apache.openjpa.kernel.AbstractStoreQuery;\n+import org.apache.openjpa.kernel.BrokerImpl;\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.QueryImpl;\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n+import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.slice.DistributedConfiguration;\n+import org.apache.openjpa.slice.SliceThread;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * A query for distributed databases.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+@SuppressWarnings(\"serial\")\n+class DistributedSQLStoreQuery extends SQLStoreQuery {\n+\tprivate List<StoreQuery> _queries = new ArrayList<StoreQuery>();\n+\n+\tpublic DistributedSQLStoreQuery(JDBCStore store) {\n+\t\tsuper(store);\n+\t}\n+\n+\tvoid add(StoreQuery q) {\n+\t\t_queries.add(q);\n+\t}\n+\n+\tpublic DistributedJDBCStoreManager getDistributedStore() {\n+\t\treturn (DistributedJDBCStoreManager) getStore();\n+\t}\n+\n+\tpublic Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+\t\tboolean parallel = !getContext().getStoreContext().getBroker()\n+\t\t\t.getMultithreaded();\n+        ParallelExecutor ex = new ParallelExecutor(this, meta, parallel);\n+\t\tfor (StoreQuery q : _queries) {\n+\t\t\tex.addExecutor(q.newDataStoreExecutor(meta, subs));\n+\t\t}\n+\t\treturn ex;\n+\t}\n+\n+\tpublic void setContext(QueryContext ctx) {\n+\t\tsuper.setContext(ctx);\n+\t\tfor (StoreQuery q : _queries)\n+\t\t\tq.setContext(ctx);\n+\t}\n+\n+\t/**\n+\t * Executes queries on multiple databases.\n+\t * \n+\t * @author Pinaki Poddar\n+\t * \n+\t */\n+\tpublic static class ParallelExecutor extends\n+\t\t\tSQLStoreQuery.SQLExecutor {\n+\t\tprivate List<Executor> executors = new ArrayList<Executor>();\n+\t\tprivate DistributedSQLStoreQuery owner = null;\n+\n+        public ParallelExecutor(DistributedSQLStoreQuery dsq, ClassMetaData meta, boolean p) {\n+\t\t\tsuper(dsq, meta);\n+\t\t\towner = dsq;\n+\t\t}\n+\n+\t\tpublic void addExecutor(Executor ex) {\n+\t\t\texecutors.add(ex);\n+\t\t}\n+\n+\t\t/**\n+         * Each child query must be executed with slice context and not the\n+\t\t * given query context.\n+\t\t */\n+\t\tpublic ResultObjectProvider executeQuery(StoreQuery q,\n+\t\t\t\tfinal Object[] params, final Range range) {\n+\t\t\tList<Future<ResultObjectProvider>> futures = \n+\t\t\t\tnew ArrayList<Future<ResultObjectProvider>>();\n+            final List<Executor> usedExecutors = new ArrayList<Executor>();\n+\t\t\tfinal List<ResultObjectProvider> rops = \n+\t\t\t\tnew ArrayList<ResultObjectProvider>();\n+\t\t\tList<SliceStoreManager> targets = findTargets();\n+\t\t\tQueryContext ctx = q.getContext();\n+\t\t\tboolean isReplicated = containsReplicated(ctx);\n+            ExecutorService threadPool = SliceThread.getPool();\n+\t\t\tfor (int i = 0; i < owner._queries.size(); i++) {\n+                // if replicated, then execute only on single slice\n+\t\t\t\tif (isReplicated && !usedExecutors.isEmpty()) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+                StoreManager sm = owner.getDistributedStore().getSlice(i);\n+\t\t\t\tif (!targets.contains(sm))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tStoreQuery query = owner._queries.get(i);\n+\t\t\t\tExecutor executor = executors.get(i);\n+\t\t\t\tif (!targets.contains(sm))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tusedExecutors.add(executor);\n+                QueryExecutor call = new QueryExecutor();\n+                call.executor = executor;\n+                call.query = query;\n+                call.params = params;\n+                call.range = range;\n+                futures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<ResultObjectProvider> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\trops.add(future.get());\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tResultObjectProvider[] tmp = rops\n+                    .toArray(new ResultObjectProvider[rops.size()]);\n+\t\t\tResultObjectProvider result = null;\n+\t\t\tboolean[] ascending = getAscending(q);\n+\t\t\tboolean isAscending = ascending.length > 0;\n+\t\t\tboolean isAggregate = ctx.isAggregate();\n+\t\t\tboolean hasRange = ctx.getEndRange() != Long.MAX_VALUE;\n+\t\t\tif (isAggregate) {\n+\t\t\t\tresult = new UniqueResultObjectProvider(tmp, q,\n+\t\t\t\t\t\tgetQueryExpressions());\n+\t\t\t} else if (isAscending) {\n+                result = new OrderingMergedResultObjectProvider(tmp, ascending,\n+                    usedExecutors.toArray(new Executor[usedExecutors.size()]),\n+\t\t\t\t\tq, params);\n+\t\t\t} else {\n+\t\t\t\tresult = new MergedResultObjectProvider(tmp);\n+\t\t\t}\n+\t\t\tif (hasRange) {\n+                result = new RangeResultObjectProvider(result,\n+                        ctx.getStartRange(), ctx.getEndRange());\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t/**\n+         * Scans metadata to find out if a replicated class is the candidate.\n+\t\t */\n+\t\tboolean containsReplicated(QueryContext query) {\n+\t\t\tClass<?> candidate = query.getCandidateType();\n+\t\t\tDistributedConfiguration conf = (DistributedConfiguration)query.getStoreContext()\n+\t\t\t    .getConfiguration();\n+\t\t\tif (candidate != null) {\n+\t\t\t    return conf.isReplicated(candidate);\n+\t\t\t}\n+\t\t\tClassMetaData[] metas = query.getAccessPathMetaDatas();\n+\t\t\tif (metas == null || metas.length < 1)\n+\t\t\t\treturn false;\n+\t\t\tfor (ClassMetaData meta : metas)\n+\t\t\t\tif (conf.isReplicated(meta.getDescribedType()))\n+\t\t\t\t\treturn true;\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tpublic Number executeDelete(StoreQuery q, Object[] params) {\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\n+\t\t\tList<Future<Number>> futures = null;\n+\t\t\tint result = 0;\n+            ExecutorService threadPool = SliceThread.getPool();\n+\t\t\tfor (Executor ex : executors) {\n+\t\t\t\tif (futures == null)\n+                    futures = new ArrayList<Future<Number>>();\n+\t\t\t\tDeleteExecutor call = new DeleteExecutor();\n+\t\t\t\tcall.executor = ex;\n+\t\t\t\tcall.query = qs.next();\n+\t\t\t\tcall.params = params;\n+\t\t\t\tfutures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<Number> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\tNumber n = future.get();\n+\t\t\t\t\tif (n != null)\n+\t\t\t\t\t\tresult += n.intValue();\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tpublic Number executeUpdate(StoreQuery q, Object[] params) {\n+\t\t\tIterator<StoreQuery> qs = owner._queries.iterator();\n+\t\t\tList<Future<Number>> futures = null;\n+\t\t\tint result = 0;\n+            ExecutorService threadPool = SliceThread.getPool();\n+\t\t\tfor (Executor ex : executors) {\n+\t\t\t\tif (futures == null)\n+                    futures = new ArrayList<Future<Number>>();\n+\t\t\t\tUpdateExecutor call = new UpdateExecutor();\n+\t\t\t\tcall.executor = ex;\n+\t\t\t\tcall.query = qs.next();\n+\t\t\t\tcall.params = params;\n+\t\t\t\tfutures.add(threadPool.submit(call));\n+\t\t\t}\n+\t\t\tfor (Future<Number> future : futures) {\n+\t\t\t\ttry {\n+\t\t\t\t\tNumber n = future.get();\n+                    result += (n == null) ? 0 : n.intValue();\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t} catch (ExecutionException e) {\n+\t\t\t\t\tthrow new StoreException(e.getCause());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tList<SliceStoreManager> findTargets() {\n+\t\t\tFetchConfiguration fetch = owner.getContext()\n+\t\t\t\t\t.getFetchConfiguration();\n+\t\t\treturn owner.getDistributedStore().getTargets(fetch);\n+\t\t}\n+\t\t\n+\t}\n+\n+\tstatic class QueryExecutor implements Callable<ResultObjectProvider> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\t\tRange range;\n+\n+\t\tpublic ResultObjectProvider call() throws Exception {\n+\t\t\treturn executor.executeQuery(query, params, range);\n+\t\t}\n+\t}\n+\n+\tstatic class DeleteExecutor implements Callable<Number> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\n+\t\tpublic Number call() throws Exception {\n+\t\t\treturn executor.executeDelete(query, params);\n+\t\t}\n+\t}\n+\n+\tstatic class UpdateExecutor implements Callable<Number> {\n+\t\tStoreQuery query;\n+\t\tExecutor executor;\n+\t\tObject[] params;\n+\n+\t\tpublic Number call() throws Exception {\n+\t\t    return executor.executeUpdate(query, params);\n+\t\t}\n+\t}\n+}"}]}

