{"sha":"286c870c34982406249acbcc8e799b817178ab2f","node_id":"MDY6Q29tbWl0MjA2MzY0OjI4NmM4NzBjMzQ5ODI0MDYyNDlhY2JjYzhlNzk5YjgxNzE3OGFiMmY=","commit":{"author":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2006-11-08T19:10:56Z"},"committer":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2006-11-08T19:10:56Z"},"message":"Replace the UUIDGenerator with an implementation based on the Apache Commons Id implementation.  This change removes the LGPL implication from the original implementation.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@472597 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c12cfe54180cd664bba69daa348d255130577544","url":"https://api.github.com/repos/apache/openjpa/git/trees/c12cfe54180cd664bba69daa348d255130577544"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/286c870c34982406249acbcc8e799b817178ab2f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/286c870c34982406249acbcc8e799b817178ab2f","html_url":"https://github.com/apache/openjpa/commit/286c870c34982406249acbcc8e799b817178ab2f","comments_url":"https://api.github.com/repos/apache/openjpa/commits/286c870c34982406249acbcc8e799b817178ab2f/comments","author":null,"committer":null,"parents":[{"sha":"e94e4937a40ad4309205a816db8328c3a27f1979","url":"https://api.github.com/repos/apache/openjpa/commits/e94e4937a40ad4309205a816db8328c3a27f1979","html_url":"https://github.com/apache/openjpa/commit/e94e4937a40ad4309205a816db8328c3a27f1979"}],"stats":{"total":348,"additions":273,"deletions":75},"files":[{"sha":"558b4d88eb53b33cb1dbf73ebc840b742218301c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=286c870c34982406249acbcc8e799b817178ab2f","patch":"@@ -0,0 +1,164 @@\n+/*\r\n+ * Copyright 2003-2006 The Apache Software Foundation.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.util;\r\n+\r\n+/**\r\n+ * This class came from the Apache Commons Id sandbox project in support\r\n+ * of the UUIDGenerator implementation.\r\n+ *\r\n+ * <p>Static methods for managing byte arrays (all methods follow Big\r\n+ * Endian order where most significant bits are in front).</p>\r\n+ *\r\n+ */\r\n+public final class Bytes {\r\n+\r\n+    /**\r\n+     * <p>Hide constructor in utility class.</p>\r\n+     */\r\n+    private Bytes() {\r\n+    }\r\n+\r\n+    /**\r\n+     * Appends two bytes array into one.\r\n+     *\r\n+     * @param a A byte[].\r\n+     * @param b A byte[].\r\n+     * @return A byte[].\r\n+     */\r\n+    public static byte[] append(byte[] a, byte[] b) {\r\n+        byte[] z = new byte[a.length + b.length];\r\n+        System.arraycopy(a, 0, z, 0, a.length);\r\n+        System.arraycopy(b, 0, z, a.length, b.length);\r\n+        return z;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a 8-byte array built from a long.\r\n+     *\r\n+     * @param n The number to convert.\r\n+     * @return A byte[].\r\n+     */\r\n+    public static byte[] toBytes(long n) {\r\n+        return toBytes(n, new byte[8]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Build a 8-byte array from a long.  No check is performed on the\r\n+     * array length.\r\n+     *\r\n+     * @param n The number to convert.\r\n+     * @param b The array to fill.\r\n+     * @return A byte[].\r\n+     */\r\n+    public static byte[] toBytes(long n, byte[] b) {\r\n+        b[7] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[6] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[5] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[4] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[3] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[2] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[1] = (byte) (n);\r\n+        n >>>= 8;\r\n+        b[0] = (byte) (n);\r\n+\r\n+        return b;\r\n+    }\r\n+\r\n+    /**\r\n+     * Build a long from first 8 bytes of the array.\r\n+     *\r\n+     * @param b The byte[] to convert.\r\n+     * @return A long.\r\n+     */\r\n+    public static long toLong(byte[] b) {\r\n+        return ((((long) b[7]) & 0xFF)\r\n+                + ((((long) b[6]) & 0xFF) << 8)\r\n+                + ((((long) b[5]) & 0xFF) << 16)\r\n+                + ((((long) b[4]) & 0xFF) << 24)\r\n+                + ((((long) b[3]) & 0xFF) << 32)\r\n+                + ((((long) b[2]) & 0xFF) << 40)\r\n+                + ((((long) b[1]) & 0xFF) << 48)\r\n+                + ((((long) b[0]) & 0xFF) << 56));\r\n+    }\r\n+\r\n+    /**\r\n+    * Compares two byte arrays for equality.\r\n+    *\r\n+    * @param a A byte[].\r\n+    * @param b A byte[].\r\n+    * @return True if the arrays have identical contents.\r\n+    */\r\n+    public static boolean areEqual(byte[] a, byte[] b) {\r\n+        int aLength = a.length;\r\n+        if (aLength != b.length) {\r\n+            return false;\r\n+        }\r\n+\r\n+        for (int i = 0; i < aLength; i++) {\r\n+            if (a[i] != b[i]) {\r\n+                return false;\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * <p>Compares two byte arrays as specified by <code>Comparable</code>.\r\n+     *\r\n+     * @param lhs - left hand value in the comparison operation.\r\n+     * @param rhs - right hand value in the comparison operation.\r\n+     * @return  a negative integer, zero, or a positive integer as <code>lhs</code>\r\n+     *  is less than, equal to, or greater than <code>rhs</code>.\r\n+     */\r\n+    public static int compareTo(byte[] lhs, byte[] rhs) {\r\n+        if (lhs == rhs) {\r\n+            return 0;\r\n+        }\r\n+        if (lhs == null) {\r\n+            return -1;\r\n+        }\r\n+        if (rhs == null) {\r\n+            return +1;\r\n+        }\r\n+        if (lhs.length != rhs.length) {\r\n+            return ((lhs.length < rhs.length) ? -1 : +1);\r\n+        }\r\n+        for (int i = 0; i < lhs.length; i++) {\r\n+            if (lhs[i] < rhs[i]) {\r\n+                return -1;\r\n+            } else if (lhs[i] > rhs[i]) {\r\n+                return 1;\r\n+            }\r\n+        }\r\n+        return 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Build a short from first 2 bytes of the array.\r\n+     *\r\n+     * @param b The byte[] to convert.\r\n+     * @return A short.\r\n+     */\r\n+    public static short toShort(byte[] b) {\r\n+        return  (short) ((b[1] & 0xFF) + ((b[0] & 0xFF) << 8));\r\n+    }\r\n+}\r"},{"sha":"0e8c17a04d383315f650b71ecb0b5f4b7a717a6a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","status":"modified","additions":107,"deletions":73,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/UUIDGenerator.java?ref=286c870c34982406249acbcc8e799b817178ab2f","patch":"@@ -23,18 +23,18 @@\n import org.apache.commons.lang.exception.NestableRuntimeException;\n \n /**\n- * UUID value generator. Based on the time-based generator in the LGPL\n- * project:<br /> \n- * http://www.doomdark.org/doomdark/proj/jug/<br />\n+ * UUID value generator.  Based on the time-based generator in the Apache\n+ * Commons Id project:  http://jakarta.apache.org/commons/sandbox/id/uuid.html\n+ *\n  * The code has been vastly simplified and modified to replace the ethernet\n  * address of the host machine with the IP, since we do not want to require\n  * native libs and Java cannot access the MAC address directly.\n- * Aside from the above modification, implements the IETF UUID draft\n- * specification, found here:<br />\n+ *\n+ * In spirit, implements the IETF UUID draft specification, found here:<br />\n  * http://www1.ics.uci.edu/~ejw/authoring/uuid-guid/draft-leach-uuids-guids-01\n  * .txt\n  *\n- * @author Abe White\n+ * @author Abe White, Kevin Sutter\n  * @nojavadoc\n  * @since 0.3.3\n  */\n@@ -48,13 +48,21 @@\n     private static final byte IDX_TIME_SEQ = 8;\n     private static final byte IDX_VARIATION = 8; // multiplexed\n \n+    // indexes and lengths within the timestamp for certain boundaries\n+    private static final byte TS_TIME_LO_IDX = 4;\n+    private static final byte TS_TIME_LO_LEN = 4;\n+    private static final byte TS_TIME_MID_IDX = 2;\n+    private static final byte TS_TIME_MID_LEN = 2;\n+    private static final byte TS_TIME_HI_IDX = 0;\n+    private static final byte TS_TIME_HI_LEN = 2;\n+\n     // offset to move from 1/1/1970, which is 0-time for Java, to gregorian\n     // 0-time 10/15/1582, and multiplier to go from 100nsec to msec units\n     private static final long GREG_OFFSET = 0x01b21dd213814000L;\n     private static final long MILLI_MULT = 10000L;\n \n-    // type of UUID; is this part of the spec?\n-    private final static byte TYPE_TIME_BASED = 1;\n+    // type of UUID -- time based\n+    private final static byte TYPE_TIME_BASED = 0x10;\n \n     // random number generator used to reduce conflicts with other JVMs, and\n     // hasher for strings.  note that secure random is very slow the first time\n@@ -65,18 +73,23 @@\n     // the MAC address is usually 6 bytes\n     private static final byte[] IP;\n \n-    // counter is initialized not to 0 but to a random 8-bit number, and each\n-    // time clock changes, lowest 8-bits of counter are preserved. the purpose\n-    // is to reduce chances of multi-JVM collisions without reducing perf\n-    // awhite: I don't really understand this precaution, but it was in the\n-    // original algo\n+    // counter is initialized to 0 and is incremented for each uuid request\n+    // within the same timestamp window.\n     private static int _counter;\n \n-    // last used millis time, and a randomized sequence that gets reset\n-    // whenever the time is reset\n-    private static long _last = 0L;\n-    private static byte[] _seq = new byte[2];\n+    // current timestamp (used to detect multiple uuid requests within same\n+    // timestamp)\n+    private static long _currentMillis;\n+\n+    // last used millis time, and a semi-random sequence that gets reset\n+    // when it overflows\n+    private static long _lastMillis = 0L;\n+    private static final int MAX_14BIT = 0x3FFF;\n+    private static short _seq = (short)RANDOM.nextInt(MAX_14BIT);\n \n+    /*\n+     * Static initializer to get the IP address of the host machine.\n+     */\n     static {\n         byte[] ip = null;\n         try {\n@@ -88,8 +101,6 @@\n         IP = new byte[6];\n         RANDOM.nextBytes(IP);\n         System.arraycopy(ip, 0, IP, 2, ip.length);\n-\n-        resetTime();\n     }\n \n     /**\n@@ -100,54 +111,35 @@\n         byte[] uuid = new byte[16];\n         System.arraycopy(IP, 0, uuid, 10, IP.length);\n \n-        // set time info\n-        long now = System.currentTimeMillis();\n+        // Set time info.  Have to do this processing within a synchronized\n+        // block because of the statics...\n+        long now = 0;\n         synchronized (UUIDGenerator.class) {\n-            // if time moves backwards somehow, spec says to reset randomization\n-            if (now < _last)\n-                resetTime();\n-            else if (now == _last && _counter == MILLI_MULT) {\n-                // if we run out of slots in this milli, increment\n-                now++;\n-                _last = now;\n-                _counter &= 0xFF; // rest counter?\n-            } else if (now > _last) {\n-                _last = now;\n-                _counter &= 0xFF; // rest counter?\n-            }\n-\n-            // translate timestamp to 100ns slot since beginning of gregorian\n-            now *= MILLI_MULT;\n-            now += GREG_OFFSET;\n-\n-            // add nano slot\n-            now += _counter;\n-            _counter++; // increment counter\n-\n-            // set random info\n-            for (int i = 0; i < _seq.length; i++)\n-                uuid[IDX_TIME_SEQ + i] = _seq[i];\n-        }\n+            // Get the time to use for this uuid.  This method has the side\n+            // effect of modifying the clock sequence, as well.\n+            now = getTime();\n \n-        // have to break up time because bytes are spread through uuid\n-        int timeHi = (int) (now >>> 32);\n-        int timeLo = (int) now;\n-\n-        uuid[IDX_TIME_HI] = (byte) (timeHi >>> 24);\n-        uuid[IDX_TIME_HI + 1] = (byte) (timeHi >>> 16);\n-        uuid[IDX_TIME_MID] = (byte) (timeHi >>> 8);\n-        uuid[IDX_TIME_MID + 1] = (byte) timeHi;\n+            // Insert the resulting clock sequence into the uuid\n+            uuid[IDX_TIME_SEQ] = (byte) ((_seq & 0x3F00) >>> 8);\n+            uuid[IDX_VARIATION] |= 0x80;\n+            uuid[IDX_TIME_SEQ+1] = (byte) (_seq & 0xFF);\n \n-        uuid[IDX_TIME_LO] = (byte) (timeLo >>> 24);\n-        uuid[IDX_TIME_LO + 1] = (byte) (timeLo >>> 16);\n-        uuid[IDX_TIME_LO + 2] = (byte) (timeLo >>> 8);\n-        uuid[IDX_TIME_LO + 3] = (byte) timeLo;\n+        }\n \n-        // set type info\n-        uuid[IDX_TYPE] &= (byte) 0x0F;\n-        uuid[IDX_TYPE] |= (byte) (TYPE_TIME_BASED << 4);\n-        uuid[IDX_VARIATION] &= 0x3F;\n-        uuid[IDX_VARIATION] |= 0x80;\n+        // have to break up time because bytes are spread through uuid\n+        byte[] timeBytes = Bytes.toBytes(now);\n+\n+        // Copy time low\n+        System.arraycopy(timeBytes, TS_TIME_LO_IDX, uuid, IDX_TIME_LO,\n+                TS_TIME_LO_LEN);\n+        // Copy time mid\n+        System.arraycopy(timeBytes, TS_TIME_MID_IDX, uuid, IDX_TIME_MID,\n+                TS_TIME_MID_LEN);\n+        // Copy time hi\n+        System.arraycopy(timeBytes, TS_TIME_HI_IDX, uuid, IDX_TIME_HI,\n+                TS_TIME_HI_LEN);\n+        //Set version (time-based)\n+        uuid[IDX_TYPE] |= TYPE_TIME_BASED; // 0001 0000\n \n         return uuid;\n     }\n@@ -172,16 +164,58 @@ public static String nextHex() {\n     }\n \n     /**\n-     * Reset the random time sequence and counter. Must be called from\n-     * synchronized code.\n+     * Get the timestamp to be used for this uuid.  Must be called from\n+     * a synchronized block.\n+     *\n+     * @return long timestamp\n+     */\n+    private static long getTime() {\n+        long newTime = getUUIDTime();\n+        if (newTime <= _lastMillis) {\n+            incrementSequence();\n+        }\n+        _lastMillis = newTime;\n+        return newTime;\n+    }\n+\n+    /**\n+     * Gets the appropriately modified timestamep for the UUID.  Must be called\n+     * from a synchronized block.\n+     *\n+     * @return long timestamp in 100ns intervals since the Gregorian change\n+     * offset\n+     */\n+    private static long getUUIDTime() {\n+        if (_currentMillis != System.currentTimeMillis()) {\n+            _currentMillis = System.currentTimeMillis();\n+            _counter = 0;  // reset counter\n+        }\n+\n+        // check to see if we have created too many uuid's for this timestamp\n+        if (_counter + 1 >= MILLI_MULT) {\n+            // Original algorithm threw exception.  Seemed like overkill.\n+            // Let's just increment the timestamp instead and start over...\n+            _currentMillis++;\n+            _counter = 0;\n+        }\n+\n+        // calculate time as current millis plus offset times 100 ns ticks\n+        long currentTime = (_currentMillis + GREG_OFFSET) * MILLI_MULT;\n+\n+        // return the uuid time plus the artificial tick counter incremented\n+        return currentTime + _counter++;\n+    }\n+\n+    /**\n+     * Increments the clock sequence for this uuid.  Must be called from a\n+     * synchronized block.\n      */\n-    private static void resetTime() {\n-        _last = 0L;\n-        RANDOM.nextBytes(_seq);\n-\n-        // awhite: I don't understand this; copied from original algo\n-        byte[] tmp = new byte[1];\n-        RANDOM.nextBytes(tmp);\n-        _counter = tmp[0] & 0xFF;\n+    private static void incrementSequence() {\n+        // increment, but if it's greater than its 14-bits, reset it\n+        if (++_seq > MAX_14BIT) {\n+            _seq = (short)RANDOM.nextInt(MAX_14BIT);  // semi-random\n+        }\n     }\n+\n+\n }"},{"sha":"02594809c6395ff8f8a3f31d4128f132913a1c48","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/286c870c34982406249acbcc8e799b817178ab2f/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestUUIDGenerator.java?ref=286c870c34982406249acbcc8e799b817178ab2f","patch":"@@ -26,13 +26,13 @@\n \n     public void testUniqueString() {\n         Set seen = new HashSet();\n-        for (int i = 0; i < 1000; i++)\n+        for (int i = 0; i < 10000; i++)\n             assertTrue(seen.add(UUIDGenerator.nextString()));\n     }\n \n     public void testUniqueHex() {\n         Set seen = new HashSet();\n-        for (int i = 0; i < 1000; i++)\n+        for (int i = 0; i < 10000; i++)\n             assertTrue(seen.add(UUIDGenerator.nextHex()));\n     }\n }"}]}

