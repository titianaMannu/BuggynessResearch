{"sha":"2a45dc5929232f897d20240d2891836dabff020d","node_id":"MDY6Q29tbWl0MjA2MzY0OjJhNDVkYzU5MjkyMzJmODk3ZDIwMjQwZDI4OTE4MzZkYWJmZjAyMGQ=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-01-25T19:41:47Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-01-25T19:41:47Z"},"message":"OPENJPA-437\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@615316 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8567bb64f86aa942ac2d5b57b9b885957e3ef79a","url":"https://api.github.com/repos/apache/openjpa/git/trees/8567bb64f86aa942ac2d5b57b9b885957e3ef79a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/2a45dc5929232f897d20240d2891836dabff020d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/2a45dc5929232f897d20240d2891836dabff020d","html_url":"https://github.com/apache/openjpa/commit/2a45dc5929232f897d20240d2891836dabff020d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/2a45dc5929232f897d20240d2891836dabff020d/comments","author":null,"committer":null,"parents":[{"sha":"d4454e5a1f0793345269a9985d094f88f892a0b0","url":"https://api.github.com/repos/apache/openjpa/commits/d4454e5a1f0793345269a9985d094f88f892a0b0","html_url":"https://github.com/apache/openjpa/commit/d4454e5a1f0793345269a9985d094f88f892a0b0"}],"stats":{"total":27,"additions":16,"deletions":11},"files":[{"sha":"cb146acfd69d8decd9fb45bcc7888a000dc64fd4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":16,"deletions":11,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/2a45dc5929232f897d20240d2891836dabff020d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/2a45dc5929232f897d20240d2891836dabff020d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=2a45dc5929232f897d20240d2891836dabff020d","patch":"@@ -97,6 +97,7 @@\n     // that we can re-load them for each new broker\n     private transient Collection _pcClassNames = null;\n     private transient Collection _pcClassLoaders = null;\n+    private transient boolean _persistentTypesLoaded = false;\n \n     // lifecycle listeners to pass to each broker\n     private transient Map _lifecycleListeners = null;\n@@ -256,28 +257,31 @@ protected void addListeners(BrokerImpl broker) {\n     /**\n      * Load the configured persistent classes list. Performed automatically\n      * whenever a broker is created.\n-     * \n-     * This method is synchronized due to the possible creation of new brokers\n-     * (entity managers) by multiple threads (clients).  The two data structures\n-     * used by this method (_pcClassNames and _pcClassLoaders) are not thread\n-     * safe and this was an easy, efficient solution (OPENJPA-437).\n      */\n-    private synchronized void loadPersistentTypes(ClassLoader envLoader) {\n-        // no listed persistent types?\n-        if (_pcClassNames != null && _pcClassNames.isEmpty())\n+    private void loadPersistentTypes(ClassLoader envLoader) {\n+        // if we've loaded the persistent types and the class name list\n+        // is empty, then we can simply return. Note that there is a\n+        // potential threading scenario in which _persistentTypesLoaded is\n+        // false when read, but the work to populate _pcClassNames has\n+        // already been done. This is ok; _pcClassNames can tolerate\n+        // concurrent access, so the worst case is that the list is\n+        // persistent type data is processed multiple times, which this\n+        // algorithm takes into account.\n+        if (_persistentTypesLoaded && _pcClassNames.isEmpty())\n             return;\n \n         // cache persistent type names if not already\n         ClassLoader loader = _conf.getClassResolverInstance().\n             getClassLoader(getClass(), envLoader);\n         Collection toRedefine = new ArrayList();\n-        if (_pcClassNames == null) {\n+        if (!_persistentTypesLoaded) {\n             Collection clss = _conf.getMetaDataRepositoryInstance().\n                 loadPersistentTypes(false, loader);\n             if (clss.isEmpty())\n-                _pcClassNames = Collections.EMPTY_LIST;\n+                _pcClassNames = Collections.EMPTY_SET;\n             else {\n-                _pcClassNames = new ArrayList(clss.size());\n+                _pcClassNames = new ConcurrentReferenceHashSet(\n+                    ConcurrentReferenceHashSet.HARD);\n                 for (Iterator itr = clss.iterator(); itr.hasNext();) {\n                     Class cls = (Class) itr.next();\n                     _pcClassNames.add(cls.getName());\n@@ -286,6 +290,7 @@ private synchronized void loadPersistentTypes(ClassLoader envLoader) {\n                 }\n                 _pcClassLoaders.add(loader);\n             }\n+            _persistentTypesLoaded = true;\n         } else {\n             // reload with this loader\n             if (_pcClassLoaders.add(loader)) {"}]}

