{"sha":"315a47945cf5fef9c01dd5c43c85f264dfdf1cad","node_id":"MDY6Q29tbWl0MjA2MzY0OjMxNWE0Nzk0NWNmNWZlZjljMDFkZDVjNDNjODVmMjY0ZGZkZjFjYWQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-12-09T16:53:06Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-12-09T16:53:06Z"},"message":"OPENJPA-1884: setting svn eol style\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1044031 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f5e0b6a7a9294486028ebc9e9dcd1668a2021144","url":"https://api.github.com/repos/apache/openjpa/git/trees/f5e0b6a7a9294486028ebc9e9dcd1668a2021144"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/315a47945cf5fef9c01dd5c43c85f264dfdf1cad","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/315a47945cf5fef9c01dd5c43c85f264dfdf1cad","html_url":"https://github.com/apache/openjpa/commit/315a47945cf5fef9c01dd5c43c85f264dfdf1cad","comments_url":"https://api.github.com/repos/apache/openjpa/commits/315a47945cf5fef9c01dd5c43c85f264dfdf1cad/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"20c1d07a3816342f09f4103bacb730d3d86a43c2","url":"https://api.github.com/repos/apache/openjpa/commits/20c1d07a3816342f09f4103bacb730d3d86a43c2","html_url":"https://github.com/apache/openjpa/commit/20c1d07a3816342f09f4103bacb730d3d86a43c2"}],"stats":{"total":446,"additions":223,"deletions":223},"files":[{"sha":"ee587a6e8e75e72591e1a51975b90e1188104809","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","status":"modified","additions":223,"deletions":223,"changes":446,"blob_url":"https://github.com/apache/openjpa/blob/315a47945cf5fef9c01dd5c43c85f264dfdf1cad/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","raw_url":"https://github.com/apache/openjpa/raw/315a47945cf5fef9c01dd5c43c85f264dfdf1cad/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java?ref=315a47945cf5fef9c01dd5c43c85f264dfdf1cad","patch":"@@ -1,223 +1,223 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.persistence.cache.jpa;\r\n-\r\n-import java.util.Random;\r\n-\r\n-import javax.persistence.Cache;\r\n-import javax.persistence.CacheStoreMode;\r\n-import javax.persistence.EntityManager;\r\n-import javax.persistence.EntityManagerFactory;\r\n-import javax.persistence.EntityNotFoundException;\r\n-import javax.persistence.LockModeType;\r\n-\r\n-\r\n-import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-/**\r\n- * Verifies L2 operations using multiple entity manager factories. The EMF which\r\n- * does updates does not have the data cache enabled thus, it does not send\r\n- * sjvm updates upon commit.\r\n- */\r\n-public class TestMultiEMFCacheModes extends SingleEMFTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp( CLEAR_TABLES, CacheableEntity.class,\r\n-               \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\",\r\n-               \"openjpa.DataCache\", \"true\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Verifies that the data cache us updated via a em.refresh operation when \r\n-     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the\r\n-     * entity is updated in the database.\r\n-     */\r\n-    public void testCacheRefreshModeRefresh() {\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        \r\n-        // Create a new cacheable entity\r\n-        CacheableEntity ce = createEntity(em);\r\n-        int ceid = ce.getId();\r\n-\r\n-        // Clear the L1\r\n-        em.clear();\r\n-        \r\n-        // Clear the L2 cache\r\n-        Cache cache = emf.getCache();\r\n-        cache.evictAll();\r\n-        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n-\r\n-        // Find the entity, reloading it into the L2 \r\n-        em.getTransaction().begin();\r\n-        ce = em.find(CacheableEntity.class, ceid);\r\n-        assertTrue(em.contains(ce));\r\n-        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n-        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\r\n-        assertEquals(ce.getName(), \"Cached Entity\");\r\n-        assertEquals(ce.getVersion(), 1);\r\n-        em.getTransaction().commit();\r\n-\r\n-        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\r\n-        // sjvm remote commit provider would evict the entity upon update, throwing\r\n-        // off the intent of this variation.\r\n-        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\r\n-            \"openjpa.LockManager\", \"mixed\",\r\n-            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\r\n-        EntityManager em2 = emf2.createEntityManager();\r\n-        \r\n-        // Find + lock, then update the entity and commit\r\n-        em2.getTransaction().begin();\r\n-        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid, LockModeType.PESSIMISTIC_FORCE_INCREMENT);\r\n-        ce2.setName(\"Updated Cached Entity\");\r\n-        em2.getTransaction().commit();\r\n-        em2.close();\r\n-        emf2.close();\r\n-\r\n-        // Refresh the entity - this will load the entity into the L1 and with storeMode=REFRESH, \r\n-        // should also refresh it in the L2\r\n-        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\r\n-        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\r\n-        em.refresh(ce, cacheStoreModeMap);\r\n-\r\n-        // Verify the entity was updated\r\n-        verifyUpdatedEntity(ce, ceid);\r\n-\r\n-        // Verify loading from the L1\r\n-        ce = em.find(CacheableEntity.class, ceid);\r\n-        \r\n-        // Verify the entity was updated\r\n-        verifyUpdatedEntity(ce, ceid);\r\n-\r\n-        // Clear the L1\r\n-        em.clear();\r\n-\r\n-        // Assert the L2 contains the entity\r\n-        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n-\r\n-        // Reload the entity from the L2\r\n-        ce = em.find(CacheableEntity.class, ceid);\r\n-        \r\n-        // Verify the entity in the L2 was updated\r\n-        verifyUpdatedEntity(ce, ceid);\r\n-\r\n-        em.close();\r\n-    }\r\n-\r\n-    /**\r\n-     * Verifies that the data cache us updated via a em.refresh operation when \r\n-     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the \r\n-     * record is removed from the database.\r\n-     */\r\n-    public void testCacheRefreshModeRefreshDelete() {\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-\r\n-        // Create a new cachable entity\r\n-        CacheableEntity ce = createEntity(em);\r\n-        int ceid = ce.getId();\r\n-\r\n-        // Clear the L2 cache\r\n-        Cache cache = emf.getCache();\r\n-        cache.evictAll();\r\n-        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n-\r\n-        // Find the entity, reloading it into the L2 \r\n-        em.getTransaction().begin();\r\n-        ce = em.find(CacheableEntity.class, ceid);\r\n-        assertTrue(em.contains(ce));\r\n-        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n-        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\r\n-        assertEquals(ce.getName(), \"Cached Entity\");\r\n-        assertEquals(ce.getVersion(), 1);\r\n-        em.getTransaction().commit();\r\n-\r\n-        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\r\n-        // sjvm remote commit provider would evict the entity upon delete, throwing\r\n-        // off the intent of this variation.\r\n-        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\r\n-            \"openjpa.LockManager\", \"mixed\",\r\n-            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\r\n-        EntityManager em2 = emf2.createEntityManager();\r\n-\r\n-        // Find and delete the entity in a separate context with no L2 configured\r\n-        em2.getTransaction().begin();\r\n-        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid);\r\n-        assertNotNull(ce2);\r\n-        em2.remove(ce2);\r\n-        em2.getTransaction().commit();\r\n-        em2.close();\r\n-        emf2.close();\r\n-\r\n-        // Refresh the entity with storeMode=REFRESH.  The entity has been deleted so it will be\r\n-        // purged from the L2 cache when the DB load fails.\r\n-        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\r\n-        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\r\n-        try {\r\n-            em.refresh(ce, cacheStoreModeMap);\r\n-            fail(\"Refresh operation should have thrown an exception\");\r\n-        } catch (EntityNotFoundException e) {\r\n-            // expected exception\r\n-        }\r\n-\r\n-        // Try loading from the L1 - OpenJPA will detect the entity was\r\n-        // removed in another transaction.\r\n-        try {\r\n-            ce = em.find(CacheableEntity.class, ceid);\r\n-            fail(\"OpenJPA should have detected the removed entity\");\r\n-        } catch (EntityNotFoundException e) {\r\n-            // expected exception\r\n-        }\r\n-\r\n-        // Clear the L1\r\n-        em.clear();\r\n-\r\n-        // Assert the L2 no longer contains the entity\r\n-        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n-\r\n-        // Attempt to reload entity from the L2 or database\r\n-        ce = em.find(CacheableEntity.class, ceid);\r\n-\r\n-        // Verify the entity was removed from L2 and DB\r\n-        assertNull(ce);\r\n-\r\n-        em.close();\r\n-\t}\r\n-\r\n-\tprivate CacheableEntity createEntity(EntityManager em) {\r\n-        CacheableEntity ce = new CacheableEntity();\r\n-        int ceid = new Random().nextInt();\r\n-        ce.setId(ceid);\r\n-        ce.setName(\"Cached Entity\");\r\n-\r\n-        // Persist the new cachable entity\r\n-        em.getTransaction().begin();\r\n-        em.persist(ce);\r\n-        em.getTransaction().commit();\r\n-        em.clear();\r\n-        return ce;\r\n-    }\r\n-\r\n-    private void verifyUpdatedEntity(CacheableEntity ce, int id) {\r\n-        assertEquals(id, ce.getId());\r\n-        assertEquals(\"Updated Cached Entity\", ce.getName());\r\n-        assertEquals(2, ce.getVersion());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.cache.jpa;\n+\n+import java.util.Random;\n+\n+import javax.persistence.Cache;\n+import javax.persistence.CacheStoreMode;\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.EntityNotFoundException;\n+import javax.persistence.LockModeType;\n+\n+\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Verifies L2 operations using multiple entity manager factories. The EMF which\n+ * does updates does not have the data cache enabled thus, it does not send\n+ * sjvm updates upon commit.\n+ */\n+public class TestMultiEMFCacheModes extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp( CLEAR_TABLES, CacheableEntity.class,\n+               \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\",\n+               \"openjpa.DataCache\", \"true\");\n+    }\n+\n+    /**\n+     * Verifies that the data cache us updated via a em.refresh operation when \n+     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the\n+     * entity is updated in the database.\n+     */\n+    public void testCacheRefreshModeRefresh() {\n+\n+        EntityManager em = emf.createEntityManager();\n+        \n+        // Create a new cacheable entity\n+        CacheableEntity ce = createEntity(em);\n+        int ceid = ce.getId();\n+\n+        // Clear the L1\n+        em.clear();\n+        \n+        // Clear the L2 cache\n+        Cache cache = emf.getCache();\n+        cache.evictAll();\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\n+\n+        // Find the entity, reloading it into the L2 \n+        em.getTransaction().begin();\n+        ce = em.find(CacheableEntity.class, ceid);\n+        assertTrue(em.contains(ce));\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\n+        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\n+        assertEquals(ce.getName(), \"Cached Entity\");\n+        assertEquals(ce.getVersion(), 1);\n+        em.getTransaction().commit();\n+\n+        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\n+        // sjvm remote commit provider would evict the entity upon update, throwing\n+        // off the intent of this variation.\n+        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\n+            \"openjpa.LockManager\", \"mixed\",\n+            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\n+        EntityManager em2 = emf2.createEntityManager();\n+        \n+        // Find + lock, then update the entity and commit\n+        em2.getTransaction().begin();\n+        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid, LockModeType.PESSIMISTIC_FORCE_INCREMENT);\n+        ce2.setName(\"Updated Cached Entity\");\n+        em2.getTransaction().commit();\n+        em2.close();\n+        emf2.close();\n+\n+        // Refresh the entity - this will load the entity into the L1 and with storeMode=REFRESH, \n+        // should also refresh it in the L2\n+        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\n+        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\n+        em.refresh(ce, cacheStoreModeMap);\n+\n+        // Verify the entity was updated\n+        verifyUpdatedEntity(ce, ceid);\n+\n+        // Verify loading from the L1\n+        ce = em.find(CacheableEntity.class, ceid);\n+        \n+        // Verify the entity was updated\n+        verifyUpdatedEntity(ce, ceid);\n+\n+        // Clear the L1\n+        em.clear();\n+\n+        // Assert the L2 contains the entity\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\n+\n+        // Reload the entity from the L2\n+        ce = em.find(CacheableEntity.class, ceid);\n+        \n+        // Verify the entity in the L2 was updated\n+        verifyUpdatedEntity(ce, ceid);\n+\n+        em.close();\n+    }\n+\n+    /**\n+     * Verifies that the data cache us updated via a em.refresh operation when \n+     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the \n+     * record is removed from the database.\n+     */\n+    public void testCacheRefreshModeRefreshDelete() {\n+\n+        EntityManager em = emf.createEntityManager();\n+\n+        // Create a new cachable entity\n+        CacheableEntity ce = createEntity(em);\n+        int ceid = ce.getId();\n+\n+        // Clear the L2 cache\n+        Cache cache = emf.getCache();\n+        cache.evictAll();\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\n+\n+        // Find the entity, reloading it into the L2 \n+        em.getTransaction().begin();\n+        ce = em.find(CacheableEntity.class, ceid);\n+        assertTrue(em.contains(ce));\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\n+        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\n+        assertEquals(ce.getName(), \"Cached Entity\");\n+        assertEquals(ce.getVersion(), 1);\n+        em.getTransaction().commit();\n+\n+        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\n+        // sjvm remote commit provider would evict the entity upon delete, throwing\n+        // off the intent of this variation.\n+        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\n+            \"openjpa.LockManager\", \"mixed\",\n+            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\n+        EntityManager em2 = emf2.createEntityManager();\n+\n+        // Find and delete the entity in a separate context with no L2 configured\n+        em2.getTransaction().begin();\n+        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid);\n+        assertNotNull(ce2);\n+        em2.remove(ce2);\n+        em2.getTransaction().commit();\n+        em2.close();\n+        emf2.close();\n+\n+        // Refresh the entity with storeMode=REFRESH.  The entity has been deleted so it will be\n+        // purged from the L2 cache when the DB load fails.\n+        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\n+        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\n+        try {\n+            em.refresh(ce, cacheStoreModeMap);\n+            fail(\"Refresh operation should have thrown an exception\");\n+        } catch (EntityNotFoundException e) {\n+            // expected exception\n+        }\n+\n+        // Try loading from the L1 - OpenJPA will detect the entity was\n+        // removed in another transaction.\n+        try {\n+            ce = em.find(CacheableEntity.class, ceid);\n+            fail(\"OpenJPA should have detected the removed entity\");\n+        } catch (EntityNotFoundException e) {\n+            // expected exception\n+        }\n+\n+        // Clear the L1\n+        em.clear();\n+\n+        // Assert the L2 no longer contains the entity\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\n+\n+        // Attempt to reload entity from the L2 or database\n+        ce = em.find(CacheableEntity.class, ceid);\n+\n+        // Verify the entity was removed from L2 and DB\n+        assertNull(ce);\n+\n+        em.close();\n+\t}\n+\n+\tprivate CacheableEntity createEntity(EntityManager em) {\n+        CacheableEntity ce = new CacheableEntity();\n+        int ceid = new Random().nextInt();\n+        ce.setId(ceid);\n+        ce.setName(\"Cached Entity\");\n+\n+        // Persist the new cachable entity\n+        em.getTransaction().begin();\n+        em.persist(ce);\n+        em.getTransaction().commit();\n+        em.clear();\n+        return ce;\n+    }\n+\n+    private void verifyUpdatedEntity(CacheableEntity ce, int id) {\n+        assertEquals(id, ce.getId());\n+        assertEquals(\"Updated Cached Entity\", ce.getName());\n+        assertEquals(2, ce.getVersion());\n+    }\n+}"}]}

