{"sha":"31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50","node_id":"MDY6Q29tbWl0MjA2MzY0OjMxYzQ3OTBjMzI4ZmEyMDhlZDhiOWUzYzRlZDRiYjhiMTY4YjljNTA=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-10-03T01:35:09Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-10-03T01:35:09Z"},"message":"OPENJPA-1327 Doc update for JPA2 JPQL Query\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@821214 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3a2c617402b1922f943570edd5f6e83e5cc8423b","url":"https://api.github.com/repos/apache/openjpa/git/trees/3a2c617402b1922f943570edd5f6e83e5cc8423b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50","html_url":"https://github.com/apache/openjpa/commit/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50","comments_url":"https://api.github.com/repos/apache/openjpa/commits/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50/comments","author":null,"committer":null,"parents":[{"sha":"58539dd83369c3a64907bc22c418ba8684e29274","url":"https://api.github.com/repos/apache/openjpa/commits/58539dd83369c3a64907bc22c418ba8684e29274","html_url":"https://github.com/apache/openjpa/commit/58539dd83369c3a64907bc22c418ba8684e29274"}],"stats":{"total":540,"additions":404,"deletions":136},"files":[{"sha":"84de55101a295bb34c141ad99f724fbf79f29155","filename":"openjpa-project/src/doc/manual/jpa_overview_query.xml","status":"modified","additions":404,"deletions":136,"changes":540,"blob_url":"https://github.com/apache/openjpa/blob/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50/openjpa-project/src/doc/manual/jpa_overview_query.xml","raw_url":"https://github.com/apache/openjpa/raw/31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50/openjpa-project/src/doc/manual/jpa_overview_query.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_query.xml?ref=31c4790c328fa208ed8b9e3c4ed4bb8b168b9c50","patch":"@@ -665,7 +665,12 @@ Digest</classname> are <classname>Magazine</classname> subclasses.\n <programlisting>SELECT x FROM Magazine x WHERE x.price &lt; 5</programlisting>\n             <para>\n Non-polymorphic queries or queries whose polymorphism is restricted can be specified using entity\n-type expressions in the WHERE clause to restrict the domain of the query.\n+type expressions (see <xref linkend=\"jpa_langref_entity_type_expressions\"/> ) \n+ in the <literal>WHERE</literal> clause to restrict the domain of the query. \n+For example, the following query returns instances of <classname>Digest</classname>:\n+<programlisting>\n+SELECT x FROM Magazine WHERE TYPE(x) = Digest\n+</programlisting>\n             </para>\n         </section>\n         <section id=\"jpa_overview_query_params\">\n@@ -723,7 +728,7 @@ This code substitutes <literal>JDJ</literal> for the <literal> :titleParam\n             </para>\n             <para>\n All input parameters must be single-valued, except in IN expressions \n-(see section <xref linkend=\"jpa_langref_in\"/>), which support the use of collection-valued\n+(see <xref linkend=\"jpa_langref_in_expressions\"/>), which support the use of collection-valued\n  input parameters. \n             </para>\n         </section>\n@@ -1147,7 +1152,7 @@ QL_statement ::= select_statement | update_statement | delete_statement\n                 </listitem>\n             </itemizedlist>\n             <para> \n-The complete BNF for JPQL is defined in <xref linkend=\"jpa_langref_bnf\"/>.\n+The complete BNF for JPQL is defined in <xref linkend=\"jpa_langref_bnf\"/>. \n Any JPQL statement may be constructed dynamically or may be statically defined \n in a metadata annotation or XML descriptor element. All statement types may \n have parameters, as discussed in <xref linkend=\"jpa_langref_input_params\"/>.\n@@ -1436,6 +1441,17 @@ join_single_valued_association_path_expression\n                 </listitem>\n                 <listitem>\n                     <para>\n+join_collection_valued_path_expression::=\n+identification_variable.{single_valued_embeddable_object_field.}*collection_valued_field                    \n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+join_single_valued_path_expression::=\n+identification_variable.{single_valued_embeddable_object_field.}*single_valued_object_field                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n join_spec ::= [ LEFT [OUTER] | INNER ] JOIN\n                         </para>\n                     </listitem>\n@@ -2195,7 +2211,7 @@ in the <literal>FROM</literal> clause of a query\n except in an <literal>empty_collection_comparison_expression</literal>, \n in a <literal>collection_member_expression</literal>, or\n as an argument to the <literal>SIZE</literal> operator. \n-See Sections <xref linkend=\"jpa_langref_empty_comp\"/>,  <xref linkend=\"jpa_langref_collection_member\"/>, \n+See <xref linkend=\"jpa_langref_empty_comp\"/>,  <xref linkend=\"jpa_langref_collection_member\"/>, \n and <xref linkend=\"jpa_langref_arithmetic\"/>.       \n                 </para>\n             </section>\n@@ -2212,7 +2228,7 @@ the <literal>FROM</literal> clause and a join condition in the <literal>WHERE\n The main use case for this generalized style of join is when a join condition does not involve\n a foreign key relationship that is mapped to an entity relationship. For Example,\n                 </para>\n-<example>SELECT c FROM Customer c, Employee e WHERE c.hatsize = e.shoesize</example>\n+<programlisting>SELECT c FROM Customer c, Employee e WHERE c.hatsize = e.shoesize</programlisting>\n                 <para>\n In general, use of this style of inner join (also referred to as theta-join) is less typical than explicitly\n defined joins over relationships.\n@@ -2256,16 +2272,19 @@ join_spec ::= [ LEFT [OUTER] | INNER ] JOIN\n                     </listitem>\n                 </itemizedlist>\n                 <para>\n-The following inner and outer join operation types are supported.\n+The inner and outer join operation types described in \n+<xref linkend=\"jpa_langref_inner_joins\"/> and <xref linkend=\"jpa_langref_outer_joins\"/> are supported.\n                 </para>\n                 <section id=\"jpa_langref_inner_joins\">\n                     <title>\n                         JPQL Inner Joins (Relationship Joins)\n                     </title>\n                     <para>\n-The syntax for the inner join operation is <programlisting>\n+The syntax for the inner join operation is <itemizedlist>\n+<listitem>\n [ INNER ] JOIN join_association_path_expression [AS] identification_variable\n-</programlisting> For example, the query below joins over the relationship\n+</listitem>\n+</itemizedlist> For example, the query below joins over the relationship\n between publishers and magazines. This type of join typically equates to a join\n over a foreign key relationship in the database. \n                     </para>\n@@ -2304,8 +2323,10 @@ WHERE c.address.zipcode = '95054'\n <literal>LEFT JOIN</literal> and <literal>LEFT OUTER JOIN</literal> are\n synonymous. They enable the retrieval of a set of entities where matching values\n in the join condition may be absent. The syntax for a left outer join is:\n-<programlisting>LEFT [OUTER] JOIN join_association_path_expression [AS] identification_variable\n-</programlisting>\n+<itemizedlist>\n+<listitem>LEFT [OUTER] JOIN join_association_path_expression [AS] identification_variable\n+</listitem>\n+</itemizedlist>\n                     </para>\n                     <para>\n For example: <programlisting>SELECT pub FROM Publisher pub LEFT JOIN pub.magazines mag WHERE pub.revenue &gt; 1000000\n@@ -2423,7 +2444,7 @@ query can depend on whether there are any values of the declared type.\n                 <para>\n For example, the <literal>FROM</literal> clause below defines a query over \n all orders that have line items and existing\n-products. If there are no <litera.>Product</litera.> instances in the database, \n+products. If there are no <literal>Product</literal> instances in the database, \n the domain of the query is empty and no\n order is selected.\n                 </para>\n@@ -2445,8 +2466,8 @@ the query criteria.\n                 </para>\n                 <para>\n Non-polymorphic queries or queries whose polymorphism is restricted can be specified using entity\n-type expressions in the WHERE clause to restrict the domain of the query.\n-See section <xref linked=\"jpa_langref_entity_type_expressions\"/>.\n+type expressions in the <literal>WHERE</literal> clause to restrict the domain of the query.\n+See <xref linkend=\"jpa_langref_entity_type_expressions\"/>.\n                 </para>\n             </section>\n         </section>\n@@ -2607,8 +2628,8 @@ arithmetic operations involving the input parameter will return an unknown\n value. See <xref linkend=\"jpa_langref_null_values\"/>.\n                 </para>\n                 <para>\n-All input parameters must be single-valued, except in IN expressions (see section\n-<xref linkend=\"jpa_lagref_in_expression\"/>), which support the use of collection-valued\n+All input parameters must be single-valued, except in IN expressions (see \n+<xref linkend=\"jpa_langref_in_expressions\"/> ), which support the use of collection-valued\n input parameters.\n                 </para>\n                 <section id=\"jpa_langref_pos_params\">\n@@ -2671,8 +2692,8 @@ comparison operations, logical operations, path expressions that evaluate to\n boolean values, boolean literals, and boolean input parameters. \n                 </para>\n                 <para>\n-The scalar expressions described in section <xref linkend=\"jpa_langref_scalar_expressions\"/> \n- can be used in conditional expressions. \n+The scalar expressions described in <xref linkend=\"jpa_langref_scalar_expressions\"/> \n+  can be used in conditional expressions. \n                 </para>\n                 <para>\n Standard bracketing ()\n@@ -2840,7 +2861,7 @@ FROM CreditCard c JOIN c.transactionHistory t\n WHERE c.holder.name = ‘John Doe’ AND INDEX(t) BETWEEN 0 AND 9\n </programlisting>\n             </section>\n-            <section id=\"jpa_langref_in\">\n+            <section id=\"jpa_langref_in_expressions\">\n                 <title>\n                     JPQL In Expressions\n                 </title>\n@@ -2861,7 +2882,8 @@ in_item ::= literal | single_valued_input_parameter\n                     </itemizedlist>\n                 </para>\n                 <para>\n-The <literal>state_field_path_expression</literal> must have a string, numeric, or enum value.\n+The <literal>state_field_path_expression</literal> must have a string, numeric, \n+date, time, timestamp, or enum value.\n                 </para>\n                 <para>\n  The literal and/or input_parameter values must be <literal>like</literal> \n@@ -3133,56 +3155,60 @@ magazine: <programlisting>SELECT auth FROM Author auth\n                 </title>\n                 <para>\n Subqueries may be used in the <literal>WHERE</literal> or <literal>HAVING\n-</literal> clause. The syntax for subqueries is as follows: <itemizedlist>\n-<listitem><para>subquery ::= simple_select_clause subquery_from_clause\n-[where_clause] [groupby_clause] [having_clause]\n-                            </para>\n-                        </listitem>\n-                    </itemizedlist>\n+</literal> clause. The syntax for subqueries is as follows:\n                 </para>\n-                <para>\n-Subqueries are restricted to the <literal>WHERE</literal> and <literal>HAVING\n-</literal> clauses in this release. Support for subqueries in the <literal>FROM\n-</literal> clause will be considered in a later release of the specification.\n-<itemizedlist><listitem><para>simple_select_clause ::= SELECT [DISTINCT]\n+<itemizedlist>\n+                    <listitem>\n+                        <para>\n+subquery ::= simple_select_clause subquery_from_clause\n+[where_clause] [groupby_clause] [having_clause]\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+simple_select_clause ::= SELECT [DISTINCT]\n simple_select_expression\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n subquery_from_clause ::= FROM subselect_identification_variable_declaration {,\n subselect_identification_variable_declaration |\n collection_member_declaration }*\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n subselect_identification_variable_declaration ::=\n identification_variable_declaration | derived_path_expression [AS]\n identification_variable {join}* | derived_collection_member_declaration\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n simple_select_expression ::= single_valued_path_expression |\n scalar_expression |\n aggregate_expression | identification_variable\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n derived_path_expression ::=\n superquery_identification_variable.{single_valued_object_field.}*collection_valued_field |\n superquery_identification_variable.{single_valued_object_field.}*single_valued_object_field\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n derived_collection_member_declaration ::=\n IN superquery_identification_variable.{single_valued_object_field.}*collection_valued_field \n-                            </para>\n-                        </listitem>\n-                    </itemizedlist>\n+                        </para>\n+                    </listitem>\n+                </itemizedlist>\n+                <para>\n+Subqueries are restricted to the <literal>WHERE</literal> and <literal>HAVING\n+</literal> clauses in this release. Support for subqueries in the <literal>FROM\n+</literal> clause will be considered in a later release of the specification. \n                 </para>\n                 <para>\n Examples: <programlisting>SELECT DISTINCT auth FROM Author auth\n@@ -3240,7 +3266,7 @@ The arithmetic operators are:\n Arithmetic operations use numeric promotion.\n                 </para>\n                 <para>\n-Arithmetic functions are described in section <xref linkend=\"jpa_langref_arithmetic\"/>.\n+Arithmetic functions are described in  <xref linkend=\"jpa_langref_arithmetic\"/>.\n                 </para>\n                 </para>\n             </section>\n@@ -3397,7 +3423,7 @@ the database server.\n                 </title>\n                 <para>\n The following forms of case expressions are supported: general case expressions, simple case expressions,\n-coalesce expressions, and nullif expressions.[\n+coalesce expressions, and nullif expressions.\n <itemizedlist>\n <listitem>\n case_expression::=\n@@ -3707,7 +3733,7 @@ the <literal>OBJECT</literal> operator. The <literal>SELECT</literal> clause\n must not use the OBJECT operator to qualify path expressions.\n             </para>\n             <para>\n-A result_variable may be used to name a select_item in the query result. \n+A <literal>result_variable</literal> may be used to name a <literal>select_item</literal> in the query result. \n  For example,\n <programlisting>\n SELECT c, COUNT(l) AS itemCount\n@@ -3796,7 +3822,7 @@ and map value respectively.\n                             <para>\n The result type of a \n <literal>scalar_expression</literal> is the type of the scalar value to which the expression\n-evaluates. The result type of a numeric <literal>scalar_expression</literal> is defined in section\n+evaluates. The result type of a numeric <literal>scalar_expression</literal> is defined in \n <xref linkend=\"jpa_langref_scalar_expressions\"/>\n                             </para>\n                         </listitem>\n@@ -3809,7 +3835,7 @@ resulting abstract schema type corresponds.\n                         </listitem>\n                         <listitem>\n                             <para>\n-The result type of aggregate_expression is defined in section\n+The result type of aggregate_expression is defined in \n <xref linkend=\"jpa_langref_aggregates\"/>.\n                             </para>\n                         </listitem>\n@@ -4013,13 +4039,13 @@ The type of a numeric expression in the query result is determined as follows:\n An operand that corresponds to a persistent state-field is of the same type as that persistent state-field.\n                     </para>\n                     <para>\n-An operand that corresponds to one of arithmetic functions described in section \n-<xref linkend=\"jpa_langref_arithmetic\"/> is of the type defined by section \n+An operand that corresponds to one of arithmetic functions described in  \n+<xref linkend=\"jpa_langref_arithmetic\"/> is of the type defined by  \n <xref linkend=\"jpa_langref_arithmetic\"/>.\n                     </para>\n                     <para>\n-An operand that corresponds to one of an aggregate functions described in section \n-<xref linkend=\"jpa_langref_aggregates\"/> is of the type defined by section \n+An operand that corresponds to one of an aggregate functions described in  \n+<xref linkend=\"jpa_langref_aggregates\"/> is of the type defined by  \n <xref linkend=\"jpa_langref_aggregates\"/>.\n                     </para>\n                     <para>\n@@ -4086,20 +4112,106 @@ orderby_item ::= { state_field_path_expression | result_variable } [ASC | DESC]\n                 </itemizedlist>\n             </para>\n             <para>\n-When the <literal>ORDER BY</literal> clause is used in a query, each element of\n-the <literal>SELECT</literal> clause of the query must be one of the following:\n-an identification variable x, optionally denoted as <literal>OBJECT(x)</literal>\n-, a single_valued_association_path_expression, or a state_field_path_expression.\n-For example: <programlisting>\n+An orderby_item must be one of the following:\n+            </para>\n+<itemizedlist>\n+    <listitem>\n+    <para>\n+    A <literal>state_field_path_expression</literal> that evaluates to an orderable state field of an entity or\n+embeddable class abstract schema type designated in the SELECT clause by one of the following:\n+    </para>\n+    <itemizedlist>\n+        <listitem>\n+        <para>a <literal>general_identification_variable</literal></para>\n+        </listitem>\n+        <listitem>\n+        <para>a <literal>single_valued_object_path_expression</literal></para>\n+        </listitem>\n+    </itemizedlist>\n+    </listitem>\n+    <listitem>\n+        <para>\n+A <literal>state_field_path_expression</literal> that evaluates to the same state field of the same entity or\n+embeddable abstract schema type as a <literal>state_field_path_expression</literal> \n+in the <literal>SELECT</literal> clause.\n+        </para>\n+    </listitem>\n+    <listitem>\n+        <para>\n+A <literal>result_variable</literal> that refers to an orderable item in the \n+<literal>SELECT</literal> clause for which the same\n+<literal>result_variable</literal> has been specified. \n+This may be the result of an <literal>aggregate_expression</literal>, a\n+<literal>scalar_expression</literal>, \n+or a <literal>state_field_path_expression</literal> in the <literal>SELECT</literal> clause.\n+        </para>\n+    </listitem>\n+</itemizedlist>\n+            <para>\n+For example, the five queries below are legal. \n+            </para>\n+<programlisting>\n SELECT pub FROM Publisher pub ORDER BY pub.revenue, pub.name\n-</programlisting> If more than one orderby_item is specified, the left-to-right\n-sequence of the orderby_item elements determines the precedence, whereby the\n-leftmost orderby_item has highest precedence. The keyword <literal>ASC</literal>\n+</programlisting> \n+<programlisting>\n+SELECT o\n+FROM Customer c JOIN c.orders o JOIN c.address a\n+WHERE a.state = ‘CA’\n+ORDER BY o.quantity DESC, o.totalcost\n+</programlisting> \n+<programlisting>\n+SELECT o.quantity, a.zipcode\n+FROM Customer c JOIN c.orders o JOIN c.address a\n+WHERE a.state = ‘CA’\n+ORDER BY o.quantity, a.zipcode\n+</programlisting> \n+<programlisting>\n+SELECT o.quantity, o.cost*1.08 AS taxedCost, a.zipcode\n+FROM Customer c JOIN c.orders o JOIN c.address a\n+WHERE a.state = ‘CA’ AND a.county = ‘Santa Clara’\n+ORDER BY o.quantity, taxedCost, a.zipcode\n+</programlisting> \n+<programlisting>\n+SELECT AVG(o.quantity) as q, a.zipcode\n+FROM Customer c JOIN c.orders o JOIN c.address a\n+WHERE a.state = ‘CA’\n+GROUP BY a.zipcode\n+ORDER BY q DESC\n+</programlisting> \n+<para>\n+The following two queries are not legal because the <literal>orderby_item</literal> \n+is not reflected in the <literal>SELECT</literal>\n+clause of the query.\n+</para>\n+<programlisting>\n+SELECT p.product_name\n+FROM Order o JOIN o.lineItems l JOIN l.product p JOIN o.customer c\n+WHERE c.lastname = ‘Smith’ AND c.firstname = ‘John’\n+ORDER BY p.price\n+</programlisting> \n+<programlisting>\n+SELECT p.product_name\n+FROM Order o, IN(o.lineItems) l JOIN o.customer c\n+WHERE c.lastname = ‘Smith’ AND c.firstname = ‘John’\n+ORDER BY o.quantity\n+</programlisting> \n+          <para>\n+If more than one <literal>orderby_item</literal> is specified, the left-to-right\n+sequence of the <literal>orderby_item</literal> elements determines the precedence, whereby the\n+leftmost <literal>orderby_item</literal> has highest precedence. \n+          </para>\n+          <para>\n+The keyword <literal>ASC</literal>\n specifies that ascending ordering be used; the keyword <literal>DESC</literal>\n specifies that descending ordering be used. Ascending ordering is the default.\n+           </para>\n+           <para>\n SQL rules for the ordering of null values apply: that is, all null values must\n appear before all non-null values in the ordering or all null values must appear\n-after all non-null values in the ordering, but it is not specified which. The\n+after all non-null values in the ordering, but it is not specified which.\n+           </para>\n+           <para> \n+The\n ordering of the query result is preserved in the result of the query method if\n the <literal>ORDER BY</literal> clause is used.\n             </para>\n@@ -4120,20 +4232,20 @@ schema type may be specified in the <literal>FROM</literal> or <literal>UPDATE\n                     </listitem>\n                     <listitem>\n                         <para>\n-update_clause ::= UPDATE abstract_schema_name [[AS] identification_variable] SET\n+update_clause ::= UPDATE entity_name [[AS] identification_variable] SET\n update_item {, update_item}*\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n update_item ::= [identification_variable.]{state_field |\n-single_valued_association_field} = new_value\n+single_valued_object_field} = new_value\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-new_value ::= simple_arithmetic_expression | string_primary | datetime_primary |\n-boolean_primary | enum_primary simple_entity_expression | NULL\n+new_value ::= scalar_expression | \n+simple_entity_expression | NULL\n                         </para>\n                     </listitem>\n                     <listitem>\n@@ -4143,26 +4255,40 @@ delete_statement ::= delete_clause [where_clause]\n                     </listitem>\n                     <listitem>\n                         <para>\n-delete_clause ::= DELETE FROM abstract_schema_name [[AS]\n+delete_clause ::= DELETE FROM entity_name [[AS]\n identification_variable]\n                         </para>\n                     </listitem>\n                 </itemizedlist>\n             </para>\n             <para>\n The syntax of the <literal>WHERE</literal> clause is described in\n-<xref linkend=\"jpa_langref_where\"/>. A delete operation only applies to\n+<xref linkend=\"jpa_langref_where\"/>. \n+            </para>\n+            <para>\n+A delete operation only applies to\n entities of the specified class and its subclasses. It does not cascade to\n-related entities. The new_value specified for an update operation must be\n-compatible in type with the state-field to which it is assigned. Bulk update\n+related entities. \n+            </para>\n+            <para>\n+The <literal>new_value</literal> specified for an update operation must be\n+compatible in type with the state-field to which it is assigned. \n+            </para>\n+            <para>\n+Bulk update\n maps directly to a database update operation, bypassing optimistic locking\n checks. Portable applications must manually update the value of the version\n column, if desired, and/or manually validate the value of the version column.\n+            </para>\n+            <para>\n The persistence context is not synchronized with the result of the bulk update\n-or delete. Caution should be used when executing bulk update or delete\n+or delete. \n+            </para>\n+            <para>\n+Caution should be used when executing bulk update or delete\n operations because they may result in inconsistencies between the database and\n the entities in the active persistence context. In general, bulk update and\n-delete operations should only be performed within a separate transaction or at\n+delete operations should only be performed within a transaction in a new persistence context or at\n the beginning of a transaction (before entities have been accessed whose state\n might be affected by such operations).\n             </para>\n@@ -4225,18 +4351,29 @@ semantics of query comparisons involving the empty string and <literal>NULL\n                 JPQL Equality and Comparison Semantics\n             </title>\n             <para>\n-Only the values of like types are permitted to be compared. A type is like\n+Only the values of <literal>like</literal> types are permitted to be compared. A type is <literal>like</literal> \n another type if they correspond to the same Java language type, or if one is a\n primitive Java language type and the other is the wrappered Java class type\n-equivalent (e.g., int and Integer are like types in this sense). There is one\n+equivalent (e.g., <literal>int</literal> and <literal>Integer</literal> are like types in this sense). There is one\n exception to this rule: it is valid to compare numeric values for which the\n rules of numeric promotion apply. Conditional expressions attempting to compare\n-non-like type values are disallowed except for this numeric case. Note that the\n+non-like type values are disallowed except for this numeric case. \n+            </para>\n+            <para>\n+Note that the\n arithmetic operators and comparison operators are permitted to be applied to\n state-fields and input parameters of the wrappered Java class equivalents to the\n-primitive numeric Java types. Two entities of the same abstract schema type are\n-equal if and only if they have the same primary key value. Only\n-equality/inequality comparisons over enums are required to be supported.\n+primitive numeric Java types. \n+            </para>\n+            <para>\n+Two entities of the same abstract schema type are\n+equal if and only if they have the same primary key value.\n+            </para>\n+            <para>\n+Equality/inequality comparisons over enums are supported.\n+            </para>\n+            <para>\n+Comparisons over instances of embeddable class or map entry types are not supported.\n             </para>\n         </section>\n         <section id=\"jpa_langref_bnf\">\n@@ -4245,7 +4382,7 @@ equality/inequality comparisons over enums are required to be supported.\n             </title>\n             <para>\n The following is the BNF for the Java Persistence query language, from section\n-4.14 of the JSR 220 specification.\n+4.14 of the JSR 317 specification.\n             </para>\n             <itemizedlist>\n                 <listitem>\n@@ -4283,7 +4420,7 @@ fetch_join }*\n                 </listitem>\n                 <listitem>\n                     <para>\n-range_variable_declaration ::= abstract_schema_name [ <literal>AS</literal> ]\n+range_variable_declaration ::= entity_name [ <literal>AS</literal> ]\n identification_variable\n                     </para>\n                 </listitem>\n@@ -4301,106 +4438,120 @@ join_association_path_expression\n                 </listitem>\n                 <listitem>\n                     <para>\n-association_path_expression ::= collection_valued_path_expression |\n-single_valued_association_path_expression\n-                    </para>\n-                </listitem>\n-                <listitem>\n-                    <para>\n join_spec ::= [ <literal>LEFT</literal> [ <literal>OUTER</literal> ]| <literal>\n INNER</literal> ] <literal>JOIN</literal>\n                     </para>\n                 </listitem>\n-                <listitem>\n+                 <listitem>\n                     <para>\n join_association_path_expression ::= join_collection_valued_path_expression |\n-join_single_valued_association_path_expression\n+join_single_valued_path_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n join_collection_valued_path_expression ::=\n-identification_variable.collection_valued_association_field\n+identification_variable.{single_valued_embeddable_object_field.}*collection_valued_field\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-join_single_valued_association_path_expression ::=\n-identification_variable.single_valued_association_field\n+join_single_valued_path_expression ::=\n+identification_variable.{single_valued_embeddable_object_field.}*single_valued_object_field\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n collection_member_declaration ::= <literal>IN</literal>\n-(collection_valued_path_expression) [ <literal>AS</literal> ]\n+(join_collection_valued_path_expression) [ <literal>AS</literal> ]\n identification_variable\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-single_valued_path_expression ::= state_field_path_expression |\n-single_valued_association_path_expression\n+qualified_identification_variable ::=\n+KEY(identification_variable) |\n+VALUE(identification_variable) |\n+ENTRY(identification_variable)\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-state_field_path_expression ::= {identification_variable |\n-single_valued_association_path_expression}.state_field\n+single_valued_path_expression ::= \n+qualified_identification_variable |\n+state_field_path_expression |\n+single_valued_object_path_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-single_valued_association_path_expression ::=\n-identification_variable.{single_valued_association_field.}*\n-single_valued_association_field\n+general_identification_variable ::=\n+identification_variable |\n+KEY(identification_variable) |\n+VALUE(identification_variable)        \n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-collection_valued_path_expression ::=\n-identification_variable.{single_valued_association_field.}*collection_valued_association_field\n+state_field_path_expression ::= \n+general_identification_variable.{single_valued_object_field.}*state_field\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+single_valued_object_path_expression ::=\n+general_identification_variable.{single_valued_object_field.}*\n+single_valued_object_field\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-state_field ::= {embedded_class_state_field.}*simple_state_field\n+collection_valued_path_expression ::=\n+general_identification_variable.{single_valued_object_field.}*collection_valued_field\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-update_clause ::= <literal>UPDATE</literal> abstract_schema_name [[ <literal>AS\n+update_clause ::= <literal>UPDATE</literal> entity_name [[ <literal>AS\n </literal> ] identification_variable] <literal>SET</literal> update_item {,\n update_item}*\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n update_item ::= [identification_variable.]{state_field |\n-single_valued_association_field}= new_value\n+single_valued_object_field}= new_value\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-new_value ::= simple_arithmetic_expression | string_primary | datetime_primary |\n-boolean_primary | enum_primary simple_entity_expression | <literal>NULL\n+new_value ::= scalar_expression | \n+simple_entity_expression | <literal>NULL\n </literal>\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n delete_clause ::= <literal>DELETE</literal><literal>FROM</literal>\n-abstract_schema_name [[ <literal>AS</literal> ] identification_variable]\n+entity_name [[ <literal>AS</literal> ] identification_variable]\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n select_clause ::= <literal>SELECT</literal> [ <literal>DISTINCT</literal> ]\n-select_expression {, select_expression}*\n+select_item {, select_item}*\n+                    </para>\n+                </listitem>\n+                    <para>\n+select_item ::= select_expression [[AS] result_variable]\n                     </para>\n+                <listitem>\n                 </listitem>\n                 <listitem>\n                     <para>\n-select_expression ::= single_valued_path_expression | aggregate_expression |\n+select_expression ::= single_valued_path_expression | \n+scalar_expression |\n+aggregate_expression |\n identification_variable | <literal>OBJECT</literal> (identification_variable)|\n constructor_expression\n                     </para>\n@@ -4413,7 +4564,10 @@ constructor_item {, constructor_item}*)\n                 </listitem>\n                 <listitem>\n                     <para>\n-constructor_item ::= single_valued_path_expression | aggregate_expression\n+constructor_item ::= single_valued_path_expression | \n+scalar_expression |\n+aggregate_expression |\n+identification_variable\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4422,7 +4576,7 @@ aggregate_expression ::= { <literal>AVG</literal> | <literal>MAX</literal> |\n <literal>MIN</literal> | <literal>SUM</literal> }([ <literal>DISTINCT</literal>\n ] state_field_path_expression) | <literal>COUNT</literal> ([ <literal>DISTINCT\n </literal> ] identification_variable | state_field_path_expression |\n-single_valued_association_path_expression)\n+single_valued_object_path_expression)\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4454,7 +4608,7 @@ orderby_item}*\n                 </listitem>\n                 <listitem>\n                     <para>\n-orderby_item ::= state_field_path_expression [ <literal>ASC</literal> |\n+orderby_item ::= state_field_path_expression | result_variable [ <literal>ASC</literal> |\n <literal>DESC</literal> ]\n                     </para>\n                 </listitem>\n@@ -4468,14 +4622,28 @@ subquery ::= simple_select_clause subquery_from_clause [where_clause]\n                     <para>\n subquery_from_clause ::= <literal>FROM</literal>\n subselect_identification_variable_declaration {,\n-subselect_identification_variable_declaration}*\n+subselect_identification_variable_declaration | \n+collection_member_declaration}*\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n subselect_identification_variable_declaration ::=\n-identification_variable_declaration | association_path_expression [ <literal>AS\n-</literal> ] identification_variable | collection_member_declaration\n+identification_variable_declaration | derived_path_expression [ <literal>AS\n+</literal> ] identification_variable | derived_collection_member_declaration\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+derived_path_expression ::=\n+superquery_identification_variable.{single_valued_object_field.}*collection_valued_field |\n+superquery_identification_variable.{single_valued_object_field.}*single_valued_object_field\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+derived_collection_member_declaration ::=\n+IN superquery_identification_variable.{single_valued_object_field.}*collection_valued_field\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4487,7 +4655,19 @@ simple_select_clause ::= <literal>SELECT</literal> [ <literal>DISTINCT</literal>\n                 <listitem>\n                     <para>\n simple_select_expression ::= single_valued_path_expression |\n-aggregate_expression | identification_variable\n+scalar_expression | aggregate_expression | identification_variable\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+scalar_expression ::=\n+simple_arithmetic_expression |\n+string_primary |\n+enum_primary |\n+datetime_primary |\n+boolean_primary |\n+case_expression |\n+entity_type_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4532,13 +4712,13 @@ datetime_expression <literal>AND</literal> datetime_expression\n                 </listitem>\n                 <listitem>\n                     <para>\n-in_expression ::= state_field_path_expression [ <literal>NOT</literal> ]\n-<literal>IN</literal> ( in_item {, in_item}* | subquery)\n+in_expression ::= {state_field_path_expression | type_discriminator} [ <literal>NOT</literal> ]\n+<literal>IN</literal> {( in_item {, in_item}*) | (subquery) | collection_valued_input_parameter }\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-in_item ::= literal | input_parameter\n+in_item ::= literal | single_valued_input_parameter\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4568,6 +4748,22 @@ collection_valued_path_expression\n                 </listitem>\n                 <listitem>\n                     <para>\n+entity_or_value_expression ::=\n+single_valued_object_path_expression |\n+state_field_path_expression |\n+simple_entity_or_value_expression\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+simple_entity_or_value_expression ::=\n+identification_variable |\n+input_parameter |\n+literal\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n exists_expression ::= [ <literal>NOT</literal> ] <literal>EXISTS</literal>\n (subquery)\n                     </para>\n@@ -4587,7 +4783,8 @@ enum_expression {=|&lt;&gt;} {enum_expression | all_or_any_expression} |\n datetime_expression comparison_operator {datetime_expression |\n all_or_any_expression} | entity_expression {= |&lt;&gt; } {entity_expression |\n all_or_any_expression} | arithmetic_expression comparison_operator\n-{arithmetic_expression | all_or_any_expression}\n+{arithmetic_expression | all_or_any_expression} |\n+entity_type_expression { =|&lt;&gt;>} entity_type_expression}\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4621,7 +4818,8 @@ arithmetic_factor ::= [{+ |-}] arithmetic_primary\n                     <para>\n arithmetic_primary ::= state_field_path_expression | numeric_literal |\n (simple_arithmetic_expression) | input_parameter | functions_returning_numerics\n-| aggregate_expression\n+| aggregate_expression |\n+case_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4632,7 +4830,8 @@ string_expression ::= string_primary |(subquery)\n                 <listitem>\n                     <para>\n string_primary ::= state_field_path_expression | string_literal |\n-input_parameter | functions_returning_strings | aggregate_expression\n+input_parameter | functions_returning_strings | aggregate_expression |\n+case_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4643,7 +4842,9 @@ datetime_expression ::= datetime_primary |(subquery)\n                 <listitem>\n                     <para>\n datetime_primary ::= state_field_path_expression | input_parameter |\n-functions_returning_datetime | aggregate_expression\n+functions_returning_datetime | aggregate_expression |\n+case_expression |\n+date_time_timestamp_literal\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4655,6 +4856,7 @@ boolean_expression ::= boolean_primary |(subquery)\n                     <para>\n boolean_primary ::= state_field_path_expression | boolean_literal |\n input_parameter |\n+case_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4664,12 +4866,13 @@ enum_expression ::= enum_primary |(subquery)\n                 </listitem>\n                 <listitem>\n                     <para>\n-enum_primary ::= state_field_path_expression | enum_literal | input_parameter |\n+enum_primary ::= state_field_path_expression | enum_literal | input_parameter | \n+case_expression\n                     </para>\n                 </listitem>\n                 <listitem>\n                     <para>\n-entity_expression ::= single_valued_association_path_expression |\n+entity_expression ::= single_valued_object_path_expression |\n simple_entity_expression\n                     </para>\n                 </listitem>\n@@ -4680,13 +4883,30 @@ simple_entity_expression ::= identification_variable | input_parameter\n                 </listitem>\n                 <listitem>\n                     <para>\n+entity_type_expression ::=\n+type_discriminator |\n+entity_type_literal |\n+input_parameter\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n+type_discriminator ::=\n+<literal>TYPE</literal>(identification_variable |\n+single_valued_object_path_expression |\n+input_parameter)\n+                    </para>\n+                </listitem>\n+                <listitem>\n+                    <para>\n functions_returning_numerics ::= <literal>LENGTH</literal> (string_primary)|\n <literal>LOCATE</literal> (string_primary,string_primary [,\n simple_arithmetic_expression]) | <literal>ABS</literal>\n (simple_arithmetic_expression) | <literal>SQRT</literal>\n (simple_arithmetic_expression) | <literal>MOD</literal>\n (simple_arithmetic_expression, simple_arithmetic_expression) | <literal>SIZE\n-</literal> (collection_valued_path_expression)\n+</literal> (collection_valued_path_expression) |\n+<literal>INDEX</literal>(identification_variable)\n                     </para>\n                 </listitem>\n                 <listitem>\n@@ -4699,7 +4919,7 @@ CURRENT_TIME</literal> | <literal>CURRENT_TIMESTAMP</literal>\n                     <para>\n functions_returning_strings ::= <literal>CONCAT</literal> (string_primary,\n string_primary) | <literal>SUBSTRING</literal> (string_primary,\n-simple_arithmetic_expression,simple_arithmetic_expression)| <literal>TRIM\n+simple_arithmetic_expression[,simple_arithmetic_expression])| <literal>TRIM\n </literal> ([[trim_specification] [trim_character] <literal>FROM</literal> ]\n string_primary) | <literal>LOWER</literal> (string_primary) | <literal>UPPER\n </literal> (string_primary)\n@@ -4711,6 +4931,54 @@ trim_specification ::= <literal>LEADING</literal> | <literal>TRAILING</literal>\n | <literal>BOTH</literal>\n                     </para>\n                 </listitem>\n+                <listitem>\n+                    <para>\n+case_expression ::=\n+general_case_expression |\n+simple_case_expression |\n+coalesce_expression |\n+nullif_expression\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+general_case_expression::=\n+<literal>CASE</literal> when_clause {when_clause}* <literal>ELSE</literal> scalar_expression <literal>END</literal>\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+when_clause::= <literal>WHEN</literal> conditional_expression <literal>THEN</literal> scalar_expression\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+simple_case_expression::=\n+<literal>CASE</literal> case_operand simple_when_clause {simple_when_clause}*\n+<literal>ELSE</literal> scalar_expression\n+<literal>END</literal>\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+case_operand::= state_field_path_expression | type_discriminator\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+simple_when_clause::= <literal>WHEN</literal> scalar_expression <literal>THEN</literal> scalar_expression    \n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+coalesce_expression::= <literal>COALESCE</literal>(scalar_expression {, scalar_expression}+)\n+                    </para>\n+                </listitem>\n+                 <listitem>\n+                    <para>\n+nullif_expression::= <literal>NULLIF</literal>(scalar_expression, scalar_expression)\n+                    </para>\n+                </listitem>\n             </itemizedlist>\n         </section>\n     </section>"}]}

