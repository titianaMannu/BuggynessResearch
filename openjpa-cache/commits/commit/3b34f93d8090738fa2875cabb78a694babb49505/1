{"sha":"3b34f93d8090738fa2875cabb78a694babb49505","node_id":"MDY6Q29tbWl0MjA2MzY0OjNiMzRmOTNkODA5MDczOGZhMjg3NWNhYmI3OGE2OTRiYWJiNDk1MDU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:45:15Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:45:15Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.0.x@757280 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dbc19bb7427cb31222e578de42866a57b67309c0","url":"https://api.github.com/repos/apache/openjpa/git/trees/dbc19bb7427cb31222e578de42866a57b67309c0"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/3b34f93d8090738fa2875cabb78a694babb49505","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/3b34f93d8090738fa2875cabb78a694babb49505","html_url":"https://github.com/apache/openjpa/commit/3b34f93d8090738fa2875cabb78a694babb49505","comments_url":"https://api.github.com/repos/apache/openjpa/commits/3b34f93d8090738fa2875cabb78a694babb49505/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"4f62f9b70764b093db97f9a98aa52df1ccc4f17e","url":"https://api.github.com/repos/apache/openjpa/commits/4f62f9b70764b093db97f9a98aa52df1ccc4f17e","html_url":"https://github.com/apache/openjpa/commit/4f62f9b70764b093db97f9a98aa52df1ccc4f17e"}],"stats":{"total":36968,"additions":18484,"deletions":18484},"files":[{"sha":"3db3198dd04ab43f37ef467c5cf6283796d4d45f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":545,"deletions":545,"changes":1090,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,546 +1,546 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowImpl;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n-import org.apache.openjpa.lib.graph.Edge;\r\n-import org.apache.openjpa.lib.graph.Graph;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ConstraintUpdateManager\r\n-    extends AbstractUpdateManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ConstraintUpdateManager.class);\r\n-\r\n-    public boolean orderDirty() {\r\n-        return false;\r\n-    }\r\n-\r\n-    protected PreparedStatementManager newPreparedStatementManager\r\n-        (JDBCStore store, Connection conn) {\r\n-        return new PreparedStatementManagerImpl(store, conn);\r\n-    }\r\n-\r\n-    protected RowManager newRowManager() {\r\n-        return new RowManagerImpl(false);\r\n-    }\r\n-\r\n-    protected Collection flush(RowManager rowMgr,\r\n-        PreparedStatementManager psMgr, Collection exceps) {\r\n-        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n-\r\n-        // first take care of all secondary table deletes and 'all row' deletes\r\n-        // (which are probably secondary table deletes), since no foreign\r\n-        // keys ever rely on secondary table pks\r\n-        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n-        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n-\r\n-        // now do any 'all row' updates\r\n-        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n-\r\n-        // analyze foreign keys\r\n-        Collection inserts = rmimpl.getInserts();\r\n-        Collection updates = rmimpl.getUpdates();\r\n-        Collection deletes = rmimpl.getDeletes();\r\n-        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n-        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n-\r\n-        // flush insert graph, if any\r\n-        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n-        try {\r\n-            flushGraph(graphs[0], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // flush the rest of the inserts and updates; inserts before updates\r\n-        // because some update fks might reference pks that have to be inserted\r\n-        flush(inserts, psMgr);\r\n-        flush(updates, psMgr);\r\n-\r\n-        // flush the delete graph, if any\r\n-        try {\r\n-            flushGraph(graphs[1], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // put the remainder of the deletes after updates because some updates\r\n-        // may be nulling fks to rows that are going to be deleted\r\n-        flush(deletes, psMgr);\r\n-\r\n-        // take care of all secondary table inserts and updates last, since\r\n-        // they may rely on previous inserts or updates, but nothing relies\r\n-        // on them\r\n-        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n-\r\n-        // flush any left over prepared statements\r\n-        psMgr.flush();\r\n-        return exceps;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze foreign key dependencies on the given rows\r\n-     * and create an insert and a delete graph to execute.  The insert\r\n-     * graph will be flushed before all other rows, and the delete graph will\r\n-     * be flushed after them.\r\n-     */\r\n-    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n-        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n-        // if there are any deletes, we have to map the insert objects on their\r\n-        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n-        Map insertMap = null;\r\n-        OpenJPAStateManager sm;\r\n-        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n-            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n-            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n-                sm = ((Row) itr.next()).getPrimaryKey();\r\n-                if (sm != null && sm.getObjectId() != null)\r\n-                    insertMap.put(sm.getObjectId(), sm);\r\n-            }\r\n-        }\r\n-\r\n-        // first construct the graph for deletes; this may expand to include\r\n-        // inserts and updates as well if there are any inserts that rely on\r\n-        // deletes (delete-then-insert-same-pk cases)\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        OpenJPAStateManager fkVal;\r\n-        boolean ignoreUpdates = true;\r\n-        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            row2 = getInsertRow(insertMap, rowMgr, row);\r\n-            if (row2 != null) {\r\n-                ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n-            }\r\n-\r\n-            // now check this row's fks against other deletes\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                // when deleting ref fks they'll just set a where value, so\r\n-                // check both for fk updates (relation fks) and wheres (ref fks)\r\n-                fkVal = row.getForeignKeySet(fks[j]);\r\n-                if (fkVal == null)\r\n-                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n-                if (fkVal == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_DELETE, fkVal, false);\r\n-                if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n-                        fks[j]);\r\n-            }\r\n-        }\r\n-\r\n-        if (ignoreUpdates)\r\n-            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n-        else {\r\n-            // put inserts *and updates* in the delete graph; they all rely\r\n-            // on each other\r\n-            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n-            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if there is an insert for for the same table and primary\r\n-     * key values as the given delete row.\r\n-     */\r\n-    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n-        if (insertMap == null)\r\n-            return null;\r\n-\r\n-        OpenJPAStateManager sm = row.getPrimaryKey();\r\n-        if (sm == null)\r\n-            return null;\r\n-\r\n-        // look for a new object whose insert id is the same as this delete one\r\n-        Object oid = sm.getObjectId();\r\n-        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n-        if (nsm == null)\r\n-            return null;\r\n-\r\n-        // found new object; get its row\r\n-        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n-        return (row == null || row.isValid()) ? row : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the given rows against the inserts, placing dependencies\r\n-     * in the given graph.\r\n-     */\r\n-    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n-        Graph graph) {\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        Column[] cols;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            // check this row's fks against inserts; a logical fk to an auto-inc\r\n-            // column is treated just as actual database fk because the result\r\n-            // is the same: the pk row has to be inserted before the fk row\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                if (row.getForeignKeySet(fks[j]) == null)\r\n-                    continue;\r\n-\r\n-                // see if this row is dependent on another.  if it's only\r\n-                // depenent on itself, see if the fk is logical or deferred, in\r\n-                // which case it must be an auto-inc because otherwise we\r\n-                // wouldn't have recorded it\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n-                if (row2 != null && row2.isValid() && (row2 != row\r\n-                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n-            }\r\n-\r\n-            // see if there are any relation id columns dependent on\r\n-            // auto-inc objects\r\n-            cols = row.getTable().getRelationIdColumns();\r\n-            for (int j = 0; j < cols.length; j++) {\r\n-                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n-                if (sm == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n-                    sm, false);\r\n-                if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n-            }\r\n-        }\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base table for the given instance.\r\n-     */\r\n-    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n-        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n-        while (cls.getJoinablePCSuperclassMapping() != null)\r\n-            cls = cls.getJoinablePCSuperclassMapping();\r\n-        return cls.getTable();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge between the given rows in the given foreign key graph.\r\n-     */\r\n-    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n-        Object fk) {\r\n-        // delay creation of the graph\r\n-        if (graph == null)\r\n-            graph = new Graph();\r\n-\r\n-        row1.setDependent(true);\r\n-        row2.setDependent(true);\r\n-        graph.addNode(row1);\r\n-        graph.addNode(row2);\r\n-\r\n-        // add an edge from row1 to row2, and set the fk causing the\r\n-        // dependency as the user object so we can retrieve it when resolving\r\n-        // circular constraints\r\n-        Edge edge = new Edge(row1, row2, true);\r\n-        edge.setUserObject(fk);\r\n-        graph.addEdge(edge);\r\n-\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given graph of rows in the proper order.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param psMgr The prepared statement manager to use to issue the\r\n-     * statements\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n-        boolean autoAssign)\r\n-        throws SQLException {\r\n-        if (graph == null)\r\n-            return;\r\n-\r\n-        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        Collection insertUpdates = new LinkedList();\r\n-        Collection deleteUpdates = new LinkedList();\r\n-        boolean recalculate;\r\n-\r\n-        // Handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, \r\n-        //   then use an update statement to null A's fk to B before flushing, \r\n-        //   and then flush\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, then flush,\r\n-        //   and after flushing, use an update to set the fk back to A\r\n-        // Depending on where circular dependencies are broken, the  \r\n-        // topological order of the graph nodes has to be re-calculated.\r\n-        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n-                deleteUpdates, insertUpdates);\r\n-        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n-                deleteUpdates, insertUpdates);\r\n-\r\n-        if (recalculate) {\r\n-            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n-        }\r\n-\r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        flush(deleteUpdates, psMgr);\r\n-        Collection nodes = dfa.getSortedNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-        flush(insertUpdates, psMgr);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by delete operations.\r\n-     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n-     * statement to null A's fk to B before deleting B, then delete A.\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param deleteUpdates Collection of update statements that are executed\r\n-     * before the delete operations are flushed \r\n-     */\r\n-    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n-        throws SQLException {\r\n-        PrimaryRow row;\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-\r\n-        // copy where conditions into new update that nulls the fk\r\n-        row = (PrimaryRow) edge.getTo();\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        row.copyInto(update, true);\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-        } else\r\n-            update.setNull((Column) edge.getUserObject());\r\n-\r\n-        deleteUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by insert operations.\r\n-     * If inserted row A has a circular fk to updated/inserted row B,\r\n-     * then null the fk in the B row object, then flush,\r\n-     * and after flushing, use an update to set the fk back to A.\r\n-     * @param row Row to be flushed\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param insertUpdates Collection of update statements that are executed\r\n-     * after the insert/update operations are flushed \r\n-     */\r\n-    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n-        Collection insertUpdates) throws SQLException {\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-        Column col;\r\n-\r\n-        // copy where conditions into new update that sets the fk\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        if (row.getAction() == Row.ACTION_INSERT) {\r\n-            if (row.getPrimaryKey() == null)\r\n-                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-            update.wherePrimaryKey(row.getPrimaryKey());\r\n-        } else {\r\n-            // Row.ACTION_UPDATE\r\n-            row.copyInto(update, true);\r\n-        }\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                row.getForeignKeySet(fk));\r\n-            row.clearForeignKey(fk);\r\n-        } else {\r\n-            col = (Column) edge.getUserObject();\r\n-            update.setRelationId(col, row.getRelationIdSet(col),\r\n-                row.getRelationIdCallback(col));\r\n-            row.clearRelationId(col);\r\n-        }\r\n-\r\n-        insertUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds a nullable foreign key by walking the dependency cycle. \r\n-     * Circular dependencies can be broken at this point.\r\n-     * @param cycle Cycle in the dependency graph.\r\n-     * @return Edge corresponding to a nullable foreign key.\r\n-     */\r\n-    private Edge findBreakableLink(List cycle) {\r\n-        Edge breakableLink = null;\r\n-        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n-            Edge edge = (Edge) iter.next();\r\n-            Object userObject = edge.getUserObject();\r\n-            if (userObject instanceof ForeignKey) {\r\n-                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n-                     breakableLink = edge;\r\n-                     break;\r\n-                 }\r\n-            } else if (userObject instanceof Column) {\r\n-                if (!((Column) userObject).isNotNull()) {\r\n-                    breakableLink = edge;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        return breakableLink;\r\n-    }\r\n-\r\n-    /**\r\n-     * Re-calculates the DepthFirstSearch analysis of the graph \r\n-     * after some of the edges have been removed. Ensures\r\n-     * that the dependency graph is cycle free.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        DepthFirstAnalysis dfa;\r\n-        // clear previous traversal data\r\n-        graph.clearTraversal();\r\n-        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        // make sure that the graph is non-cyclic now\r\n-        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n-        return dfa;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve circular dependencies by identifying and breaking\r\n-     * a nullable foreign key.\r\n-     * @param graph Dependency graph.\r\n-     * @param edges Collection of edges. Each edge indicates a possible \r\n-     * circular dependency\r\n-     * @param deleteUpdates Collection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed before \r\n-     * the rows in the dependency graph are flushed\r\n-     * @param insertUpdates CCollection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed after \r\n-     * the rows in the dependency graph are flushed\r\n-     * @return Depending on where circular dependencies are broken, the  \r\n-     * topological order of the graph nodes has to be re-calculated.\r\n-     */\r\n-    private boolean resolveCycles(Graph graph, Collection edges,\r\n-        Collection deleteUpdates, Collection insertUpdates)\r\n-        throws SQLException {\r\n-        boolean recalculate = false;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            List cycle = edge.getCycle();\r\n-\r\n-            if (cycle != null) {\r\n-                // find a nullable foreign key\r\n-                Edge breakableLink = findBreakableLink(cycle);\r\n-                if (breakableLink == null) {\r\n-                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n-                }\r\n-\r\n-                // topologic node order must be re-calculated,  if the\r\n-                // breakable link is different from the edge where\r\n-                // the circular dependency was originally detected\r\n-                if (edge != breakableLink) {\r\n-                    recalculate = true;\r\n-                }\r\n-\r\n-                if (!breakableLink.isRemovedFromGraph()) {\r\n-\r\n-                    // use a primary row update to prevent setting pk and fk values\r\n-                    // until after flush, to get latest auto-increment values\r\n-                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n-                    if (row.getAction() == Row.ACTION_DELETE) {\r\n-                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n-                    } else {\r\n-                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n-                    }\r\n-                    graph.removeEdge(breakableLink);\r\n-                }\r\n-            }\r\n-        }\r\n-        return recalculate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n-     * and auto-assign settings.\r\n-     */\r\n-    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        return new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given collection of secondary rows.\r\n-     */\r\n-    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n-        if (rows.size() == 0)\r\n-            return;\r\n-\r\n-        RowImpl row;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n-            row = (RowImpl) itr.next();\r\n-            if (row.isValid() && !row.isDependent())\r\n-                psMgr.flush(row);\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\n+import org.apache.openjpa.lib.graph.Edge;\n+import org.apache.openjpa.lib.graph.Graph;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\n+ *\n+ * @since 1.0.0\n+ */\n+public class ConstraintUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ConstraintUpdateManager.class);\n+\n+    public boolean orderDirty() {\n+        return false;\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(false);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // analyze foreign keys\n+        Collection inserts = rmimpl.getInserts();\n+        Collection updates = rmimpl.getUpdates();\n+        Collection deletes = rmimpl.getDeletes();\n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\n+\n+        // flush insert graph, if any\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\n+        try {\n+            flushGraph(graphs[0], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // flush the rest of the inserts and updates; inserts before updates\n+        // because some update fks might reference pks that have to be inserted\n+        flush(inserts, psMgr);\n+        flush(updates, psMgr);\n+\n+        // flush the delete graph, if any\n+        try {\n+            flushGraph(graphs[1], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // put the remainder of the deletes after updates because some updates\n+        // may be nulling fks to rows that are going to be deleted\n+        flush(deletes, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze foreign key dependencies on the given rows\n+     * and create an insert and a delete graph to execute.  The insert\n+     * graph will be flushed before all other rows, and the delete graph will\n+     * be flushed after them.\n+     */\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\n+        // if there are any deletes, we have to map the insert objects on their\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\n+        Map insertMap = null;\n+        OpenJPAStateManager sm;\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\n+                sm = ((Row) itr.next()).getPrimaryKey();\n+                if (sm != null && sm.getObjectId() != null)\n+                    insertMap.put(sm.getObjectId(), sm);\n+            }\n+        }\n+\n+        // first construct the graph for deletes; this may expand to include\n+        // inserts and updates as well if there are any inserts that rely on\n+        // deletes (delete-then-insert-same-pk cases)\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        OpenJPAStateManager fkVal;\n+        boolean ignoreUpdates = true;\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            row2 = getInsertRow(insertMap, rowMgr, row);\n+            if (row2 != null) {\n+                ignoreUpdates = false;\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\n+            }\n+\n+            // now check this row's fks against other deletes\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                // when deleting ref fks they'll just set a where value, so\n+                // check both for fk updates (relation fks) and wheres (ref fks)\n+                fkVal = row.getForeignKeySet(fks[j]);\n+                if (fkVal == null)\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\n+                if (fkVal == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_DELETE, fkVal, false);\n+                if (row2 != null && row2.isValid() && row2 != row)\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\n+                        fks[j]);\n+            }\n+        }\n+\n+        if (ignoreUpdates)\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\n+        else {\n+            // put inserts *and updates* in the delete graph; they all rely\n+            // on each other\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if there is an insert for for the same table and primary\n+     * key values as the given delete row.\n+     */\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\n+        if (insertMap == null)\n+            return null;\n+\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        if (sm == null)\n+            return null;\n+\n+        // look for a new object whose insert id is the same as this delete one\n+        Object oid = sm.getObjectId();\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\n+        if (nsm == null)\n+            return null;\n+\n+        // found new object; get its row\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\n+        return (row == null || row.isValid()) ? row : null;\n+    }\n+\n+    /**\n+     * Analyze the given rows against the inserts, placing dependencies\n+     * in the given graph.\n+     */\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n+        Graph graph) {\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        Column[] cols;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            // check this row's fks against inserts; a logical fk to an auto-inc\n+            // column is treated just as actual database fk because the result\n+            // is the same: the pk row has to be inserted before the fk row\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                if (row.getForeignKeySet(fks[j]) == null)\n+                    continue;\n+\n+                // see if this row is dependent on another.  if it's only\n+                // depenent on itself, see if the fk is logical or deferred, in\n+                // which case it must be an auto-inc because otherwise we\n+                // wouldn't have recorded it\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\n+                if (row2 != null && row2.isValid() && (row2 != row\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\n+            }\n+\n+            // see if there are any relation id columns dependent on\n+            // auto-inc objects\n+            cols = row.getTable().getRelationIdColumns();\n+            for (int j = 0; j < cols.length; j++) {\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\n+                if (sm == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\n+                    sm, false);\n+                if (row2 != null && row2.isValid())\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\n+            }\n+        }\n+        return graph;\n+    }\n+\n+    /**\n+     * Return the base table for the given instance.\n+     */\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        return cls.getTable();\n+    }\n+\n+    /**\n+     * Add an edge between the given rows in the given foreign key graph.\n+     */\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\n+        Object fk) {\n+        // delay creation of the graph\n+        if (graph == null)\n+            graph = new Graph();\n+\n+        row1.setDependent(true);\n+        row2.setDependent(true);\n+        graph.addNode(row1);\n+        graph.addNode(row2);\n+\n+        // add an edge from row1 to row2, and set the fk causing the\n+        // dependency as the user object so we can retrieve it when resolving\n+        // circular constraints\n+        Edge edge = new Edge(row1, row2, true);\n+        edge.setUserObject(fk);\n+        graph.addEdge(edge);\n+\n+        return graph;\n+    }\n+\n+    /**\n+     * Flush the given graph of rows in the proper order.\n+     * @param graph The graph of statements to be walked\n+     * @param psMgr The prepared statement manager to use to issue the\n+     * statements\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n+        boolean autoAssign)\n+        throws SQLException {\n+        if (graph == null)\n+            return;\n+\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        Collection insertUpdates = new LinkedList();\n+        Collection deleteUpdates = new LinkedList();\n+        boolean recalculate;\n+\n+        // Handle circular constraints:\n+        // - if deleted row A has a ciricular fk to deleted row B, \n+        //   then use an update statement to null A's fk to B before flushing, \n+        //   and then flush\n+        // - if inserted row A has a circular fk to updated/inserted row B,\n+        //   then null the fk in the B row object, then flush,\n+        //   and after flushing, use an update to set the fk back to A\n+        // Depending on where circular dependencies are broken, the  \n+        // topological order of the graph nodes has to be re-calculated.\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\n+                deleteUpdates, insertUpdates);\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\n+                deleteUpdates, insertUpdates);\n+\n+        if (recalculate) {\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\n+        }\n+\n+        // flush delete updates to null fks, then all rows in order, then\n+        // the insert updates to set circular fk values\n+        flush(deleteUpdates, psMgr);\n+        Collection nodes = dfa.getSortedNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            psMgr.flush((RowImpl) itr.next());\n+        flush(insertUpdates, psMgr);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by delete operations.\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \n+     * statement to null A's fk to B before deleting B, then delete A.\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param deleteUpdates Collection of update statements that are executed\n+     * before the delete operations are flushed \n+     */\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\n+        throws SQLException {\n+        PrimaryRow row;\n+        RowImpl update;\n+        ForeignKey fk;\n+\n+        // copy where conditions into new update that nulls the fk\n+        row = (PrimaryRow) edge.getTo();\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        row.copyInto(update, true);\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\n+        } else\n+            update.setNull((Column) edge.getUserObject());\n+\n+        deleteUpdates.add(update);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by insert operations.\n+     * If inserted row A has a circular fk to updated/inserted row B,\n+     * then null the fk in the B row object, then flush,\n+     * and after flushing, use an update to set the fk back to A.\n+     * @param row Row to be flushed\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param insertUpdates Collection of update statements that are executed\n+     * after the insert/update operations are flushed \n+     */\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\n+        Collection insertUpdates) throws SQLException {\n+        RowImpl update;\n+        ForeignKey fk;\n+        Column col;\n+\n+        // copy where conditions into new update that sets the fk\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            if (row.getPrimaryKey() == null)\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\n+            update.wherePrimaryKey(row.getPrimaryKey());\n+        } else {\n+            // Row.ACTION_UPDATE\n+            row.copyInto(update, true);\n+        }\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\n+                row.getForeignKeySet(fk));\n+            row.clearForeignKey(fk);\n+        } else {\n+            col = (Column) edge.getUserObject();\n+            update.setRelationId(col, row.getRelationIdSet(col),\n+                row.getRelationIdCallback(col));\n+            row.clearRelationId(col);\n+        }\n+\n+        insertUpdates.add(update);\n+    }\n+\n+    /**\n+     * Finds a nullable foreign key by walking the dependency cycle. \n+     * Circular dependencies can be broken at this point.\n+     * @param cycle Cycle in the dependency graph.\n+     * @return Edge corresponding to a nullable foreign key.\n+     */\n+    private Edge findBreakableLink(List cycle) {\n+        Edge breakableLink = null;\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\n+            Edge edge = (Edge) iter.next();\n+            Object userObject = edge.getUserObject();\n+            if (userObject instanceof ForeignKey) {\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\n+                     breakableLink = edge;\n+                     break;\n+                 }\n+            } else if (userObject instanceof Column) {\n+                if (!((Column) userObject).isNotNull()) {\n+                    breakableLink = edge;\n+                    break;\n+                }\n+            }\n+        }\n+        return breakableLink;\n+    }\n+\n+    /**\n+     * Re-calculates the DepthFirstSearch analysis of the graph \n+     * after some of the edges have been removed. Ensures\n+     * that the dependency graph is cycle free.\n+     * @param graph The graph of statements to be walked\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        DepthFirstAnalysis dfa;\n+        // clear previous traversal data\n+        graph.clearTraversal();\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        // make sure that the graph is non-cyclic now\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\n+        return dfa;\n+    }\n+\n+    /**\n+     * Resolve circular dependencies by identifying and breaking\n+     * a nullable foreign key.\n+     * @param graph Dependency graph.\n+     * @param edges Collection of edges. Each edge indicates a possible \n+     * circular dependency\n+     * @param deleteUpdates Collection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed before \n+     * the rows in the dependency graph are flushed\n+     * @param insertUpdates CCollection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed after \n+     * the rows in the dependency graph are flushed\n+     * @return Depending on where circular dependencies are broken, the  \n+     * topological order of the graph nodes has to be re-calculated.\n+     */\n+    private boolean resolveCycles(Graph graph, Collection edges,\n+        Collection deleteUpdates, Collection insertUpdates)\n+        throws SQLException {\n+        boolean recalculate = false;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            List cycle = edge.getCycle();\n+\n+            if (cycle != null) {\n+                // find a nullable foreign key\n+                Edge breakableLink = findBreakableLink(cycle);\n+                if (breakableLink == null) {\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\n+                }\n+\n+                // topologic node order must be re-calculated,  if the\n+                // breakable link is different from the edge where\n+                // the circular dependency was originally detected\n+                if (edge != breakableLink) {\n+                    recalculate = true;\n+                }\n+\n+                if (!breakableLink.isRemovedFromGraph()) {\n+\n+                    // use a primary row update to prevent setting pk and fk values\n+                    // until after flush, to get latest auto-increment values\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\n+                    if (row.getAction() == Row.ACTION_DELETE) {\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\n+                    } else {\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\n+                    }\n+                    graph.removeEdge(breakableLink);\n+                }\n+            }\n+        }\n+        return recalculate;\n+    }\n+\n+    /**\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\n+     * and auto-assign settings.\n+     */\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        return new DepthFirstAnalysis(graph);\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.size() == 0)\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\n+            row = (RowImpl) itr.next();\n+            if (row.isValid() && !row.isDependent())\n+                psMgr.flush(row);\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"8a4b2204e0f104dbf7ebafc3147c444136ca2515","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":780,"deletions":780,"changes":1560,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,780 +1,780 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-import java.util.Arrays;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Index;\r\n-import org.apache.openjpa.jdbc.schema.Schema;\r\n-import org.apache.openjpa.jdbc.schema.Sequence;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UnsupportedException;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Dictionary for IBM DB2 database.\r\n- */\r\n-public class DB2Dictionary\r\n-    extends AbstractDB2Dictionary {\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DB2Dictionary.class);\r\n-\r\n-    public String optimizeClause = \"optimize for\";\r\n-    public String rowClause = \"row\";\r\n-    protected int db2ServerType = 0;\r\n-    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n-    public static final int db2UDBV81OrEarlier = 2;\r\n-    public static final int db2ZOSV8xOrLater = 3;\r\n-    public static final int db2UDBV82OrLater = 4;\r\n-    public static final int db2ISeriesV5R4OrLater = 5;\r\n-\tprivate static final String forUpdate = \"FOR UPDATE\";\r\n-    private static final String withRSClause = \"WITH RS\";\r\n-    private static final String withRRClause = \"WITH RR\";\r\n-    private static final String useKeepUpdateLockClause\r\n-        = \"USE AND KEEP UPDATE LOCKS\";\r\n-    private static final String useKeepExclusiveLockClause\r\n-        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n-    private static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n-    protected String databaseProductName = \"\";\r\n-    protected String databaseProductVersion = \"\";\r\n-    protected int maj = 0;\r\n-    protected int min = 0;\r\n-\r\n-    public DB2Dictionary() {\r\n-        platform = \"DB2\";\r\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-            + \"SYSIBM.SYSTABLES\";\r\n-        supportsSelectEndIndex = true;\r\n-\r\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n-\r\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n-        sequenceNameSQL = \"SEQNAME = ?\";\r\n-        characterColumnSize = 254;\r\n-\r\n-        binaryTypeName = \"BLOB(1M)\";\r\n-        longVarbinaryTypeName = \"BLOB(1M)\";\r\n-        varbinaryTypeName = \"BLOB(1M)\";\r\n-        clobTypeName = \"CLOB(1M)\";\r\n-        longVarcharTypeName = \"LONG VARCHAR\";\r\n-        datePrecision = MICRO;\r\n-        storeCharsAsNumbers = false;\r\n-\r\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n-        }));\r\n-        systemSchemas = new String(\r\n-                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n-        maxConstraintNameLength = 18;\r\n-        maxIndexNameLength = 18;\r\n-        maxColumnNameLength = 30;\r\n-        supportsDeferredConstraints = false;\r\n-        supportsDefaultDeleteAction = false;\r\n-        supportsAlterTableWithDropColumn = false;\r\n-\r\n-        supportsNullTableForGetColumns = false;\r\n-        requiresCastForMathFunctions = true;\r\n-        requiresCastForComparisons = true;\r\n-\r\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n-        }));\r\n-        \r\n-        selectWordSet.add(\"WITH\");\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccessResultSet(Select sel,\r\n-        boolean forUpdate) {\r\n-        return !forUpdate\r\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n-    }\r\n-\r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n-        boolean subselect) {\r\n-        // appends the literal range string, since DB2 is unable to handle\r\n-        // a bound parameter for it\r\n-        // do not generate FETCH FIRST clause for subselect\r\n-        if (!subselect)\r\n-            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-                append(\" ROWS ONLY\");\r\n-    }\r\n-\r\n-    public String[] getCreateSequenceSQL(Sequence seq) {\r\n-        String[] sql = super.getCreateSequenceSQL(seq);\r\n-        if (seq.getAllocate() > 1)\r\n-            sql[0] += \" CACHE \" + seq.getAllocate();\r\n-        return sql;\r\n-    }\r\n-\r\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(sequenceSQL);\r\n-        if (schemaName != null || sequenceName != null)\r\n-            buf.append(\" WHERE \");\r\n-        if (schemaName != null) {\r\n-            buf.append(sequenceSchemaSQL);\r\n-            if (sequenceName != null)\r\n-                buf.append(\" AND \");\r\n-        }\r\n-        if (sequenceName != null)\r\n-            buf.append(sequenceNameSQL);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public Connection decorate(Connection conn)\r\n-        throws SQLException {\r\n-        // some versions of the DB2 driver seem to default to\r\n-        // READ_UNCOMMITTED, which will prevent locking from working\r\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n-        // the same instance); if we have not overridden the\r\n-        // transaction isolation in the configuration, default to\r\n-        // TRANSACTION_READ_COMMITTED\r\n-        conn = super.decorate(conn);\r\n-\r\n-        if (conf.getTransactionIsolationConstant() == -1\r\n-            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n-            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n-\r\n-        return conn;\r\n-    }\r\n-\r\n-    private boolean isJDBC3(DatabaseMetaData meta) {\r\n-        try {\r\n-            // JDBC3-only method, so it might throw a AbstractMethodError\r\n-            return meta.getJDBCMajorVersion() >= 3;\r\n-        } catch (Throwable t) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-\r\n-    public void connectedConfiguration(Connection conn) throws SQLException {\r\n-    \tsuper.connectedConfiguration(conn);\r\n-\r\n-    \tDatabaseMetaData metaData = conn.getMetaData();\r\n-        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n-        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n-        \r\n-        // Determine the type of DB2 database\r\n-        // First check for AS/400\r\n-        getProductVersionMajorMinorForISeries();\r\n-\r\n-        if (maj > 0) {\r\n-            if (isDB2ISeriesV5R3OrEarlier())\r\n-                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n-            else if (isDB2ISeriesV5R4OrLater())\r\n-                db2ServerType = db2ISeriesV5R4OrLater;\r\n-        }\r\n-        \r\n-    \tif (db2ServerType == 0) {\r\n-    \t    if (isJDBC3(metaData)) {\r\n-    \t        maj = metaData.getDatabaseMajorVersion();\r\n-    \t        min = metaData.getDatabaseMinorVersion();\r\n-    \t    }\r\n-    \t    else\r\n-    \t        getProductVersionMajorMinor();\r\n-\r\n-    \t    // Determine the type of DB2 database for ZOS & UDB\r\n-    \t    if (isDB2UDBV81OrEarlier())\r\n-    \t        db2ServerType = db2UDBV81OrEarlier;\r\n-    \t    else if (isDB2ZOSV8xOrLater())\r\n-    \t        db2ServerType = db2ZOSV8xOrLater;\r\n-    \t    else if (isDB2UDBV82OrLater())\r\n-    \t        db2ServerType = db2UDBV82OrLater;\r\n-        }\r\n-\r\n-        // verify that databae product is supported\r\n-        if (db2ServerType == 0 || maj == 0)\r\n-            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n-                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n-\r\n-    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n-    \t    supportsLockingWithMultipleTables = true;\r\n-    \t    supportsLockingWithInnerJoin = true;\r\n-    \t    supportsLockingWithOuterJoin = true;\r\n-    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n-    \t    if (maj >=9)\r\n-    \t        supportsXMLColumn = true;\r\n-    \t}\r\n-\r\n-        // platform specific settings\r\n-        switch (db2ServerType) {\r\n-        case  db2ZOSV8xOrLater:\r\n-            // DB2 Z/OS \r\n-            characterColumnSize = 255;\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n-                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n-            sequenceNameSQL = \"NAME = ?\";\r\n-            if (maj == 8)\r\n-                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n-                // long to decimal\r\n-                bigintTypeName = \"DECIMAL(31,0)\";\r\n-            break;\r\n-        case db2ISeriesV5R3OrEarlier:\r\n-        case db2ISeriesV5R4OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-                + \"QSYS2.SYSTABLES\";\r\n-            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n-                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n-            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the update clause for the query based on the\r\n-     * updateClause and isolationLevel hints\r\n-     */\r\n-    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n-        boolean isForUpdate, Select sel) {\r\n-        int isolationLevel;\r\n-        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n-        // \"optimize for\" clause appears before \"for update\" clause.\r\n-        StringBuffer forUpdateString = new StringBuffer(\r\n-            getOptimizeClause(sel));\r\n-        try {\r\n-            // Determine the isolationLevel; the fetch\r\n-            // configuration data overrides the persistence.xml value\r\n-            if (fetch != null && fetch.getIsolation() != -1)\r\n-                isolationLevel = fetch.getIsolation();\r\n-            else\r\n-                isolationLevel = conf.getTransactionIsolationConstant();\r\n-\r\n-            if (isForUpdate) {\r\n-                switch(db2ServerType) {\r\n-                case db2ISeriesV5R3OrEarlier:\r\n-                case db2UDBV81OrEarlier:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n-                        forUpdateString.append(\" \").append(forUpdateClause);\r\n-                    else \r\n-                        forUpdateString.append(\" \").append(forUpdate)\r\n-                            .append(\" \").append(withRSClause);\r\n-                    break;\r\n-                case db2ZOSV8xOrLater:\r\n-                case db2UDBV82OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);   \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);                            \r\n-                    }\r\n-                    break;\r\n-                case db2ISeriesV5R4OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);       \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);\r\n-                    }\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        catch (Exception e) {\r\n-            if (log.isTraceEnabled())\r\n-                log.error(e.toString(),e);\r\n-        }\r\n-        return forUpdateString.toString();\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV82OrLater() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n-             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n-             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n-    }\r\n-\r\n-    public boolean isDB2ZOSV8xOrLater() {\r\n-       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n-            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n-            && maj >= 8;\r\n-           \r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n-       return (databaseProductName.indexOf(\"AS\") != -1\r\n-           && ((maj == 5 && min <=3) || maj < 5));\r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R4OrLater() {\r\n-       return databaseProductName.indexOf(\"AS\") != -1\r\n-           && (maj >=6 || (maj == 5 && min >=4));\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV81OrEarlier() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n-            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n-            && ((maj == 8 && min <= 1) || maj < 8);\r\n-    }\r\n-\r\n-    /** Get the version Major/Minor for the ISeries\r\n-     */\r\n-    private void getProductVersionMajorMinorForISeries() {\r\n-        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n-        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n-        // ISeries                               DB2 UDB for AS/400\r\n-        //   (Native)                            V5R4M0\r\n-        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n-            // default to V5R4\r\n-            maj = 5;\r\n-            min = 4;\r\n-            int index = databaseProductVersion.indexOf('V');\r\n-            if (index != -1) {\r\n-            \tString s = databaseProductVersion.substring(index);\r\n-            \ts = s.toUpperCase();\r\n-\r\n-            \tStringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n-            \t\t\t, false);\r\n-            \tif (stringtokenizer.countTokens() == 3) {\r\n-            \t\tString s1 = stringtokenizer.nextToken();\r\n-            \t\tmaj = Integer.parseInt(s1);\r\n-            \t\tString s2 =  stringtokenizer.nextToken();\r\n-            \t\tmin = Integer.parseInt(s2);\r\n-            \t}\r\n-            }\r\n-            else {\r\n-            \tindex = databaseProductVersion.indexOf('0');\r\n-            \tif (index != -1) {\r\n-            \t\tString s = databaseProductVersion.substring(index);\r\n-            \t\ts = s.toUpperCase();\r\n-           \t\t\tStringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n-           \t\t\t\t\t, false);                    \r\n-           \t\t\tif (stringtokenizer.countTokens() == 2) {\r\n-           \t\t\t\tString s1 = stringtokenizer.nextToken();\r\n-           \t\t\t\tmaj = Integer.parseInt(s1);\r\n-           \t\t\t\tString s2 =  stringtokenizer.nextToken();\r\n-           \t\t\t\tmin = Integer.parseInt(s2);\r\n-           \t\t\t}\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    private void getProductVersionMajorMinor() {\r\n-        // Incase JDBC driver version is lower than 3\r\n-        // use following info to determine Major and Minor \r\n-        //                        CLI    vs      JCC\r\n-        // ZDBV8 DBProdName       DB2            DB2\r\n-        //       DBProdVersion    08.01.0005     DSN08015\r\n-        // ZDBV9                  DB2            DB2\r\n-        //                        09.01.0005     DSN09015\r\n-        // WinV9                  DB2/NT         DB2/NT\r\n-        //                        09.01.0000     SQL09010\r\n-        // SolarisV9                             DB2/SUN64\r\n-        //                                       SQL0901\r\n-        // Linux                  DB2/LINUX      DB2/LINUX\r\n-        //                        09.01.0000     SQL0901\r\n-        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n-            maj = 9;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n-            maj = 8;\r\n-            min = 2;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected String getOptimizeClause(Select sel) {\r\n-        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            buf.append(\" \").append(optimizeClause).append(\" \")\r\n-                .append(String.valueOf(sel.getExpectedResultCount()))\r\n-                .append(\" \").append(rowClause);\r\n-            return buf.toString();\r\n-        }\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n-        Object failed) {\r\n-        if (causes != null && causes.length > 0)\r\n-            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n-        return super.newStoreException(msg, causes, failed);\r\n-    }\r\n-\r\n-    /**\r\n-     *  Append exception information from SQLCA to the exsisting\r\n-     *  exception meassage\r\n-     */\r\n-    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n-       final String GETSQLCA =\"getSqlca\";\r\n-       String exceptionMsg = new String();\r\n-       try {\r\n-            Method sqlcaM2 = sqle.getNextException().getClass()\r\n-                             .getMethod(GETSQLCA,null);\r\n-            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n-                                          new Object[] {});\r\n-            Method  getSqlErrpMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrp\", null);\r\n-            Method  getSqlWarnMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlWarn\", null);\r\n-            Method  getSqlErrdMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrd\", null);\r\n-            StringBuffer errdStr = new StringBuffer();\r\n-\r\n-            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n-            for (int i = 0; i < errds.length; i++)\r\n-                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n-                    append(errds[i]);\r\n-            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n-                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n-                    + \", Errd=\" + errdStr);\r\n-\r\n-            String Warn = new String((char[]) getSqlWarnMethd.\r\n-                    invoke(sqlca, new Object[]{}));\r\n-            if(Warn.trim().length() != 0)\r\n-                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n-            else\r\n-                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n-            msg = msg.concat(exceptionMsg);\r\n-            return msg;\r\n-        } catch (Throwable t) {\r\n-            return sqle.getMessage();\r\n-        }\r\n-    }\r\n-\r\n-    public int getDb2ServerType() {\r\n-        return db2ServerType;\r\n-    }\r\n-    \r\n-    protected void appendLength(SQLBuffer buf, int type) {\r\n-        if (type == Types.VARCHAR)\r\n-            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n-                append(\")\");\r\n-    }\r\n-\r\n-    /**\r\n-     * If this dictionary supports XML type,\r\n-     * use this method to append xml predicate.\r\n-     * \r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison\r\n-     * @param rhs the right hand side of the comparison\r\n-     * @param lhsxml indicates whether the left operand maps to xml\r\n-     * @param rhsxml indicates whether the right operand maps to xml\r\n-     */\r\n-    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n-        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n-        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n-        if (lhsxml && rhsxml)\r\n-            appendXmlComparison2(buf, op, lhs, rhs);\r\n-        else if (lhsxml)\r\n-            appendXmlComparison1(buf, op, lhs, rhs);\r\n-        else \r\n-            appendXmlComparison1(buf, op, rhs, lhs);\r\n-    }\r\n-\r\n-    /**\r\n-     * Append an xml comparison predicate.\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison\r\n-     */\r\n-    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        boolean castrhs = false;\r\n-        Class rc = Filters.wrap(rhs.getType());\r\n-        int type = 0;\r\n-        if (rhs.isConstant()) {\r\n-            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n-            castrhs = true;\r\n-        }\r\n-        \r\n-        appendXmlExists(buf, lhs);\r\n-\r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        \r\n-        if (castrhs)\r\n-            appendCast(buf, rhs, type);\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\" AS \\\"\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        buf.append(\"\\\")\");\r\n-    }\r\n-    \r\n-    /**\r\n-     * Append an xml comparison predicate. (both operands map to xml column)\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison (maps to xml column)\r\n-     */\r\n-    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        appendXmlExists(buf, lhs);\r\n-        \r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\").append(rhs.getColumnAlias(\r\n-            rhs.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*/\");\r\n-        rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        appendXmlVar(buf, rhs);\r\n-        buf.append(\")\");\r\n-    }\r\n-    \r\n-    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\" AS \").\r\n-            append(\"\\\"\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"\\\"\");        \r\n-    }\r\n-    \r\n-    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(\"XMLEXISTS('\");\r\n-        buf.append(\"$\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*[\");\r\n-        val.appendTo(buf);        \r\n-    }\r\n-    \r\n-    /**\r\n-     * add CAST for a scalar function where operand is a param\r\n-     * \r\n-     * @param func original string\r\n-     * @param target substring to look for\r\n-     * @param asString \r\n-     * @return updated string (func)\r\n-     */\r\n-    private String addCastAsString(String func, String target, \r\n-            String asString) {\r\n-        String fstring = func;\r\n-        if (func.indexOf(target) != -1)\r\n-            fstring = Strings.replace(\r\n-                func, target, \"CAST(\" + target + asString + \")\");\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * add CAST for a function operator where operand is a param\r\n-     * \r\n-     * @param func function name\r\n-     * @param val type\r\n-     * @return updated string (func)\r\n-     */\r\n-    public String addCastAsType(String func, Val val) {\r\n-        String fstring = null;\r\n-        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n-            .getType()), false));\r\n-        fstring = \"CAST(? AS \" + type + \")\";\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the correct CAST function syntax\r\n-     * \r\n-     * @param val operand of cast\r\n-     * @param func original string\r\n-     * @return a String with the correct CAST function syntax\r\n-     */\r\n-    public String getCastFunction(Val val, String func) {\r\n-        if (val instanceof Lit || val instanceof Param)\r\n-            if (func.indexOf(\"VARCHAR\") == -1)\r\n-                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n-        return func;\r\n-    }\r\n-\r\n-    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n-            FilterValue start) {\r\n-        if (find.getValue() != null) { // non constants\r\n-            buf.append(\"(LOCATE(CAST((\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000)), \");\r\n-        } else {\r\n-            // this is a constant\r\n-            buf.append(\"(LOCATE(\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\", \");\r\n-        }\r\n-        if (str.getValue() != null) {\r\n-            buf.append(\"CAST((\");\r\n-            str.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000))\");\r\n-        } else {\r\n-            str.appendTo(buf);\r\n-        }\r\n-        if (start != null) {\r\n-            if (start.getValue() == null) {\r\n-                buf.append(\", CAST((\");\r\n-                start.appendTo(buf);\r\n-                buf.append(\") AS INTEGER) + 1\");\r\n-            } else {\r\n-                buf.append(\", \");\r\n-                start.appendTo(buf);\r\n-            }\r\n-        }\r\n-        buf.append(\") - 1)\");\r\n-    }\r\n-\r\n-    /** \r\n-     * Cast the specified value to the specified type.\r\n-     *\r\n-     * @param buf the buffer to append the cast to\r\n-     * @param val the value to cast\r\n-     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n-     */\r\n-    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n-\r\n-        // Convert the cast function: \"CAST({0} AS {1})\"\r\n-        int firstParam = castFunction.indexOf(\"{0}\");\r\n-        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n-        String mid = castFunction.substring(firstParam + 3);\r\n-        int secondParam = mid.indexOf(\"{1}\");\r\n-        String post;\r\n-        if (secondParam > -1) {\r\n-            post = mid.substring(secondParam + 3); // \")\"\r\n-            mid = mid.substring(0, secondParam); // \" AS \"\r\n-        } else\r\n-            post = \"\";\r\n-\r\n-        // No need to add CAST if the value is a constant\r\n-        if (val instanceof Lit || val instanceof Param) {\r\n-            buf.append(pre);\r\n-            val.appendTo(buf);\r\n-            buf.append(mid);\r\n-            buf.append(getTypeName(type));\r\n-            appendLength(buf, type);\r\n-            buf.append(post);\r\n-        } else {\r\n-            val.appendTo(buf);\r\n-            String sqlString = buf.getSQL(false);\r\n-            if (sqlString.endsWith(\"?\")) {\r\n-                // case \"(?\" - convert to \"CAST(? AS type\"\r\n-                String typeName = getTypeName(type);\r\n-                if (String.class.equals(val.getType()))\r\n-                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n-                String str = \"CAST(? AS \" + typeName + \")\";\r\n-                buf.replaceSqlString(sqlString.length() - 1,\r\n-                        sqlString.length(), str);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an index if necessary for some database tables\r\n-     */\r\n-    public void createIndexIfNecessary(Schema schema, String table,\r\n-            Column pkColumn) {\r\n-        if (isDB2ZOSV8xOrLater()) {\r\n-            // build the index for the sequence tables\r\n-            // the index name will the fully qualified table name + _IDX\r\n-            Table tab = schema.getTable(table);\r\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n-            idx.setUnique(true);\r\n-            idx.addColumn(pkColumn);\r\n-        }\r\n-    }\r\n-    \r\n-    String nullSafe(String s) {\r\n-    \treturn s == null ? \"\" : s;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Dictionary for IBM DB2 database.\n+ */\n+public class DB2Dictionary\n+    extends AbstractDB2Dictionary {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DB2Dictionary.class);\n+\n+    public String optimizeClause = \"optimize for\";\n+    public String rowClause = \"row\";\n+    protected int db2ServerType = 0;\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\n+    public static final int db2UDBV81OrEarlier = 2;\n+    public static final int db2ZOSV8xOrLater = 3;\n+    public static final int db2UDBV82OrLater = 4;\n+    public static final int db2ISeriesV5R4OrLater = 5;\n+\tprivate static final String forUpdate = \"FOR UPDATE\";\n+    private static final String withRSClause = \"WITH RS\";\n+    private static final String withRRClause = \"WITH RR\";\n+    private static final String useKeepUpdateLockClause\n+        = \"USE AND KEEP UPDATE LOCKS\";\n+    private static final String useKeepExclusiveLockClause\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\n+    private static final String forReadOnlyClause = \"FOR READ ONLY\";\n+    protected String databaseProductName = \"\";\n+    protected String databaseProductVersion = \"\";\n+    protected int maj = 0;\n+    protected int min = 0;\n+\n+    public DB2Dictionary() {\n+        platform = \"DB2\";\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+            + \"SYSIBM.SYSTABLES\";\n+        supportsSelectEndIndex = true;\n+\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n+\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n+        sequenceNameSQL = \"SEQNAME = ?\";\n+        characterColumnSize = 254;\n+\n+        binaryTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        varbinaryTypeName = \"BLOB(1M)\";\n+        clobTypeName = \"CLOB(1M)\";\n+        longVarcharTypeName = \"LONG VARCHAR\";\n+        datePrecision = MICRO;\n+        storeCharsAsNumbers = false;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n+        }));\n+        systemSchemas = new String(\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 18;\n+        maxColumnNameLength = 30;\n+        supportsDeferredConstraints = false;\n+        supportsDefaultDeleteAction = false;\n+        supportsAlterTableWithDropColumn = false;\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n+        }));\n+        \n+        selectWordSet.add(\"WITH\");\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // appends the literal range string, since DB2 is unable to handle\n+        // a bound parameter for it\n+        // do not generate FETCH FIRST clause for subselect\n+        if (!subselect)\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n+                append(\" ROWS ONLY\");\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(sequenceSQL);\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(sequenceSchemaSQL);\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(sequenceNameSQL);\n+        return buf.toString();\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        // some versions of the DB2 driver seem to default to\n+        // READ_UNCOMMITTED, which will prevent locking from working\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\n+        // the same instance); if we have not overridden the\n+        // transaction isolation in the configuration, default to\n+        // TRANSACTION_READ_COMMITTED\n+        conn = super.decorate(conn);\n+\n+        if (conf.getTransactionIsolationConstant() == -1\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\n+\n+        return conn;\n+    }\n+\n+    private boolean isJDBC3(DatabaseMetaData meta) {\n+        try {\n+            // JDBC3-only method, so it might throw a AbstractMethodError\n+            return meta.getJDBCMajorVersion() >= 3;\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+    \tsuper.connectedConfiguration(conn);\n+\n+    \tDatabaseMetaData metaData = conn.getMetaData();\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\n+        \n+        // Determine the type of DB2 database\n+        // First check for AS/400\n+        getProductVersionMajorMinorForISeries();\n+\n+        if (maj > 0) {\n+            if (isDB2ISeriesV5R3OrEarlier())\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\n+            else if (isDB2ISeriesV5R4OrLater())\n+                db2ServerType = db2ISeriesV5R4OrLater;\n+        }\n+        \n+    \tif (db2ServerType == 0) {\n+    \t    if (isJDBC3(metaData)) {\n+    \t        maj = metaData.getDatabaseMajorVersion();\n+    \t        min = metaData.getDatabaseMinorVersion();\n+    \t    }\n+    \t    else\n+    \t        getProductVersionMajorMinor();\n+\n+    \t    // Determine the type of DB2 database for ZOS & UDB\n+    \t    if (isDB2UDBV81OrEarlier())\n+    \t        db2ServerType = db2UDBV81OrEarlier;\n+    \t    else if (isDB2ZOSV8xOrLater())\n+    \t        db2ServerType = db2ZOSV8xOrLater;\n+    \t    else if (isDB2UDBV82OrLater())\n+    \t        db2ServerType = db2UDBV82OrLater;\n+        }\n+\n+        // verify that databae product is supported\n+        if (db2ServerType == 0 || maj == 0)\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \n+\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n+    \t    supportsLockingWithMultipleTables = true;\n+    \t    supportsLockingWithInnerJoin = true;\n+    \t    supportsLockingWithOuterJoin = true;\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n+    \t    if (maj >=9)\n+    \t        supportsXMLColumn = true;\n+    \t}\n+\n+        // platform specific settings\n+        switch (db2ServerType) {\n+        case  db2ZOSV8xOrLater:\n+            // DB2 Z/OS \n+            characterColumnSize = 255;\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\n+            sequenceNameSQL = \"NAME = ?\";\n+            if (maj == 8)\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\n+                // long to decimal\n+                bigintTypeName = \"DECIMAL(31,0)\";\n+            break;\n+        case db2ISeriesV5R3OrEarlier:\n+        case db2ISeriesV5R4OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+                + \"QSYS2.SYSTABLES\";\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Get the update clause for the query based on the\n+     * updateClause and isolationLevel hints\n+     */\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n+        boolean isForUpdate, Select sel) {\n+        int isolationLevel;\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n+        // \"optimize for\" clause appears before \"for update\" clause.\n+        StringBuffer forUpdateString = new StringBuffer(\n+            getOptimizeClause(sel));\n+        try {\n+            // Determine the isolationLevel; the fetch\n+            // configuration data overrides the persistence.xml value\n+            if (fetch != null && fetch.getIsolation() != -1)\n+                isolationLevel = fetch.getIsolation();\n+            else\n+                isolationLevel = conf.getTransactionIsolationConstant();\n+\n+            if (isForUpdate) {\n+                switch(db2ServerType) {\n+                case db2ISeriesV5R3OrEarlier:\n+                case db2UDBV81OrEarlier:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\n+                        forUpdateString.append(\" \").append(forUpdateClause);\n+                    else \n+                        forUpdateString.append(\" \").append(forUpdate)\n+                            .append(\" \").append(withRSClause);\n+                    break;\n+                case db2ZOSV8xOrLater:\n+                case db2UDBV82OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);   \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);                            \n+                    }\n+                    break;\n+                case db2ISeriesV5R4OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);       \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            if (log.isTraceEnabled())\n+                log.error(e.toString(),e);\n+        }\n+        return forUpdateString.toString();\n+    }\n+\n+    public boolean isDB2UDBV82OrLater() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\n+    }\n+\n+    public boolean isDB2ZOSV8xOrLater() {\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\n+            && maj >= 8;\n+           \n+    }\n+\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\n+       return (databaseProductName.indexOf(\"AS\") != -1\n+           && ((maj == 5 && min <=3) || maj < 5));\n+    }\n+\n+    public boolean isDB2ISeriesV5R4OrLater() {\n+       return databaseProductName.indexOf(\"AS\") != -1\n+           && (maj >=6 || (maj == 5 && min >=4));\n+    }\n+\n+    public boolean isDB2UDBV81OrEarlier() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \n+            || databaseProductName.indexOf(\"DB2/\") != -1) \n+            && ((maj == 8 && min <= 1) || maj < 8);\n+    }\n+\n+    /** Get the version Major/Minor for the ISeries\n+     */\n+    private void getProductVersionMajorMinorForISeries() {\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n+        // ISeries                               DB2 UDB for AS/400\n+        //   (Native)                            V5R4M0\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\n+            // default to V5R4\n+            maj = 5;\n+            min = 4;\n+            int index = databaseProductVersion.indexOf('V');\n+            if (index != -1) {\n+            \tString s = databaseProductVersion.substring(index);\n+            \ts = s.toUpperCase();\n+\n+            \tStringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n+            \t\t\t, false);\n+            \tif (stringtokenizer.countTokens() == 3) {\n+            \t\tString s1 = stringtokenizer.nextToken();\n+            \t\tmaj = Integer.parseInt(s1);\n+            \t\tString s2 =  stringtokenizer.nextToken();\n+            \t\tmin = Integer.parseInt(s2);\n+            \t}\n+            }\n+            else {\n+            \tindex = databaseProductVersion.indexOf('0');\n+            \tif (index != -1) {\n+            \t\tString s = databaseProductVersion.substring(index);\n+            \t\ts = s.toUpperCase();\n+           \t\t\tStringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n+           \t\t\t\t\t, false);                    \n+           \t\t\tif (stringtokenizer.countTokens() == 2) {\n+           \t\t\t\tString s1 = stringtokenizer.nextToken();\n+           \t\t\t\tmaj = Integer.parseInt(s1);\n+           \t\t\t\tString s2 =  stringtokenizer.nextToken();\n+           \t\t\t\tmin = Integer.parseInt(s2);\n+           \t\t\t}\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void getProductVersionMajorMinor() {\n+        // Incase JDBC driver version is lower than 3\n+        // use following info to determine Major and Minor \n+        //                        CLI    vs      JCC\n+        // ZDBV8 DBProdName       DB2            DB2\n+        //       DBProdVersion    08.01.0005     DSN08015\n+        // ZDBV9                  DB2            DB2\n+        //                        09.01.0005     DSN09015\n+        // WinV9                  DB2/NT         DB2/NT\n+        //                        09.01.0000     SQL09010\n+        // SolarisV9                             DB2/SUN64\n+        //                                       SQL0901\n+        // Linux                  DB2/LINUX      DB2/LINUX\n+        //                        09.01.0000     SQL0901\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\n+            maj = 9;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n+            maj = 8;\n+            min = 2;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        }\n+    }\n+\n+    protected String getOptimizeClause(Select sel) {\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\" \").append(optimizeClause).append(\" \")\n+                .append(String.valueOf(sel.getExpectedResultCount()))\n+                .append(\" \").append(rowClause);\n+            return buf.toString();\n+        }\n+\n+        return \"\";\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        if (causes != null && causes.length > 0)\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\n+        return super.newStoreException(msg, causes, failed);\n+    }\n+\n+    /**\n+     *  Append exception information from SQLCA to the exsisting\n+     *  exception meassage\n+     */\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n+       final String GETSQLCA =\"getSqlca\";\n+       String exceptionMsg = new String();\n+       try {\n+            Method sqlcaM2 = sqle.getNextException().getClass()\n+                             .getMethod(GETSQLCA,null);\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n+                                          new Object[] {});\n+            Method  getSqlErrpMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrp\", null);\n+            Method  getSqlWarnMethd = sqlca.getClass().\n+            getMethod(\"getSqlWarn\", null);\n+            Method  getSqlErrdMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrd\", null);\n+            StringBuffer errdStr = new StringBuffer();\n+\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n+            for (int i = 0; i < errds.length; i++)\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n+                    append(errds[i]);\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\n+                    + \", Errd=\" + errdStr);\n+\n+            String Warn = new String((char[]) getSqlWarnMethd.\n+                    invoke(sqlca, new Object[]{}));\n+            if(Warn.trim().length() != 0)\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\n+            else\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\n+            msg = msg.concat(exceptionMsg);\n+            return msg;\n+        } catch (Throwable t) {\n+            return sqle.getMessage();\n+        }\n+    }\n+\n+    public int getDb2ServerType() {\n+        return db2ServerType;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n+                append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+\n+    /**\n+     * Append an xml comparison predicate.\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = false;\n+        Class rc = Filters.wrap(rhs.getType());\n+        int type = 0;\n+        if (rhs.isConstant()) {\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+            castrhs = true;\n+        }\n+        \n+        appendXmlExists(buf, lhs);\n+\n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        \n+        if (castrhs)\n+            appendCast(buf, rhs, type);\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\" AS \\\"\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        buf.append(\"\\\")\");\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate. (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        appendXmlExists(buf, lhs);\n+        \n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\").append(rhs.getColumnAlias(\n+            rhs.getFieldMapping().getColumns()[0])).\n+            append(\"/*/\");\n+        rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        appendXmlVar(buf, rhs);\n+        buf.append(\")\");\n+    }\n+    \n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\" AS \").\n+            append(\"\\\"\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"\\\"\");        \n+    }\n+    \n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"XMLEXISTS('\");\n+        buf.append(\"$\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"/*[\");\n+        val.appendTo(buf);        \n+    }\n+    \n+    /**\n+     * add CAST for a scalar function where operand is a param\n+     * \n+     * @param func original string\n+     * @param target substring to look for\n+     * @param asString \n+     * @return updated string (func)\n+     */\n+    private String addCastAsString(String func, String target, \n+            String asString) {\n+        String fstring = func;\n+        if (func.indexOf(target) != -1)\n+            fstring = Strings.replace(\n+                func, target, \"CAST(\" + target + asString + \")\");\n+        return fstring;\n+    }\n+\n+    /**\n+     * add CAST for a function operator where operand is a param\n+     * \n+     * @param func function name\n+     * @param val type\n+     * @return updated string (func)\n+     */\n+    public String addCastAsType(String func, Val val) {\n+        String fstring = null;\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\n+            .getType()), false));\n+        fstring = \"CAST(? AS \" + type + \")\";\n+        return fstring;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func) {\n+        if (val instanceof Lit || val instanceof Param)\n+            if (func.indexOf(\"VARCHAR\") == -1)\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\n+        return func;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        if (find.getValue() != null) { // non constants\n+            buf.append(\"(LOCATE(CAST((\");\n+            find.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000)), \");\n+        } else {\n+            // this is a constant\n+            buf.append(\"(LOCATE(\");\n+            find.appendTo(buf);\n+            buf.append(\", \");\n+        }\n+        if (str.getValue() != null) {\n+            buf.append(\"CAST((\");\n+            str.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000))\");\n+        } else {\n+            str.appendTo(buf);\n+        }\n+        if (start != null) {\n+            if (start.getValue() == null) {\n+                buf.append(\", CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER) + 1\");\n+            } else {\n+                buf.append(\", \");\n+                start.appendTo(buf);\n+            }\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+\n+    /** \n+     * Cast the specified value to the specified type.\n+     *\n+     * @param buf the buffer to append the cast to\n+     * @param val the value to cast\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\n+     */\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n+\n+        // Convert the cast function: \"CAST({0} AS {1})\"\n+        int firstParam = castFunction.indexOf(\"{0}\");\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\n+        String mid = castFunction.substring(firstParam + 3);\n+        int secondParam = mid.indexOf(\"{1}\");\n+        String post;\n+        if (secondParam > -1) {\n+            post = mid.substring(secondParam + 3); // \")\"\n+            mid = mid.substring(0, secondParam); // \" AS \"\n+        } else\n+            post = \"\";\n+\n+        // No need to add CAST if the value is a constant\n+        if (val instanceof Lit || val instanceof Param) {\n+            buf.append(pre);\n+            val.appendTo(buf);\n+            buf.append(mid);\n+            buf.append(getTypeName(type));\n+            appendLength(buf, type);\n+            buf.append(post);\n+        } else {\n+            val.appendTo(buf);\n+            String sqlString = buf.getSQL(false);\n+            if (sqlString.endsWith(\"?\")) {\n+                // case \"(?\" - convert to \"CAST(? AS type\"\n+                String typeName = getTypeName(type);\n+                if (String.class.equals(val.getType()))\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\n+                String str = \"CAST(? AS \" + typeName + \")\";\n+                buf.replaceSqlString(sqlString.length() - 1,\n+                        sqlString.length(), str);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an index if necessary for some database tables\n+     */\n+    public void createIndexIfNecessary(Schema schema, String table,\n+            Column pkColumn) {\n+        if (isDB2ZOSV8xOrLater()) {\n+            // build the index for the sequence tables\n+            // the index name will the fully qualified table name + _IDX\n+            Table tab = schema.getTable(table);\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            idx.setUnique(true);\n+            idx.addColumn(pkColumn);\n+        }\n+    }\n+    \n+    String nullSafe(String s) {\n+    \treturn s == null ? \"\" : s;\n+    }\n+}"},{"sha":"66fa6057c6af1df883d1dd1b1114f7b6f974c7a4","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.instrument.Instrumentation;\r\n-import java.lang.instrument.ClassFileTransformer;\r\n-import java.lang.instrument.ClassDefinition;\r\n-import java.lang.instrument.UnmodifiableClassException;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.Method;\r\n-import java.security.ProtectionDomain;\r\n-import java.util.Map;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.ArrayList;\r\n-import java.io.IOException;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing classes. Supports Java 5 VMs that\r\n- * have a javaagent installed on the command line as well as newer VMs without\r\n- * any javaagent flag.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ClassRedefiner {\r\n-\r\n-    private static final Localizer _loc = \r\n-        Localizer.forPackage(ClassRedefiner.class);\r\n-\r\n-    private static Boolean _canRedefine = null;\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, this method will redefine\r\n-     * all the element's methods such that field accesses are intercepted\r\n-     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\r\n-     * this method is a no-op.\r\n-     */\r\n-    public static void redefineClasses(OpenJPAConfiguration conf,\r\n-        final Map<Class,byte[]> classes) {\r\n-        if (classes == null || classes.size() == 0 || !canRedefineClasses())\r\n-            return;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        Instrumentation inst = null;\r\n-        ClassFileTransformer t = null;\r\n-        try {\r\n-            inst = InstrumentationFactory.getInstrumentation();\r\n-\r\n-            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\r\n-            if (JavaVersions.VERSION >= 6) {\r\n-                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\r\n-\r\n-                t = new ClassFileTransformer() {\r\n-                    public byte[] transform(ClassLoader loader, String clsName,\r\n-                        Class<?> classBeingRedefined, ProtectionDomain pd,\r\n-                        byte[] classfileBuffer) {\r\n-                        return classes.get(classBeingRedefined);\r\n-                    }\r\n-                };\r\n-                \r\n-                // these are Java 6 methods, and we don't have a Java 6 build\r\n-                // module yet. The cost of reflection here is negligible\r\n-                // compared to the redefinition / enhancement costs in total,\r\n-                // so this should not be a big problem.\r\n-                Method meth = inst.getClass().getMethod(\"addTransformer\",\r\n-                    new Class[] { ClassFileTransformer.class, boolean.class });\r\n-                meth.invoke(inst, new Object[] { t, true });\r\n-                meth = inst.getClass().getMethod(\"retransformClasses\",\r\n-                    new Class[] { array.getClass() });\r\n-                meth.invoke(inst, new Object[] { array });\r\n-            } else {\r\n-                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\r\n-                // in a Java 5 context, we can use class redefinition instead\r\n-                ClassDefinition[] defs = new ClassDefinition[array.length];\r\n-                for (int i = 0; i < defs.length; i++)\r\n-                    defs[i] = new ClassDefinition(array[i],\r\n-                        classes.get(array[i]));\r\n-                inst.redefineClasses(defs);\r\n-            }\r\n-        } catch (NoSuchMethodException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (IllegalAccessException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (InvocationTargetException e) {\r\n-            throw new UserException(e.getCause());\r\n-        } catch (IOException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (UnmodifiableClassException e) {\r\n-            throw new InternalException(e);\r\n-        } finally {\r\n-            if (inst != null && t != null)\r\n-                inst.removeTransformer(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return whether or not this VM has an instrumentation installed that\r\n-     * permits redefinition of classes. This assumes that all the arguments\r\n-     * will be modifiable classes according to\r\n-     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\r\n-     * only checks whether or not an instrumentation is available and\r\n-     * if retransformation is possible.\r\n-     */\r\n-    public static boolean canRedefineClasses() {\r\n-        if (_canRedefine == null) {\r\n-            try {\r\n-                Instrumentation inst = InstrumentationFactory\r\n-                    .getInstrumentation();\r\n-                if (inst == null) {\r\n-                    _canRedefine = Boolean.FALSE;\r\n-                } else if (JavaVersions.VERSION == 5) {\r\n-                    // if inst is non-null and we're using Java 5,\r\n-                    // isRetransformClassesSupported isn't available,\r\n-                    // so we use the more basic class redefinition\r\n-                    // instead.\r\n-                    _canRedefine = Boolean.TRUE;\r\n-                } else {\r\n-                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\r\n-                        \"isRetransformClassesSupported\").invoke(inst);\r\n-                }\r\n-            } catch (Exception e) {\r\n-                _canRedefine = Boolean.FALSE;\r\n-            }\r\n-        }\r\n-        return _canRedefine.booleanValue();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.ClassDefinition;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Redefines the method bodies of existing classes. Supports Java 5 VMs that\n+ * have a javaagent installed on the command line as well as newer VMs without\n+ * any javaagent flag.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ClassRedefiner {\n+\n+    private static final Localizer _loc = \n+        Localizer.forPackage(ClassRedefiner.class);\n+\n+    private static Boolean _canRedefine = null;\n+\n+    /**\n+     * For each element in <code>classes</code>, this method will redefine\n+     * all the element's methods such that field accesses are intercepted\n+     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\n+     * this method is a no-op.\n+     */\n+    public static void redefineClasses(OpenJPAConfiguration conf,\n+        final Map<Class,byte[]> classes) {\n+        if (classes == null || classes.size() == 0 || !canRedefineClasses())\n+            return;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        Instrumentation inst = null;\n+        ClassFileTransformer t = null;\n+        try {\n+            inst = InstrumentationFactory.getInstrumentation();\n+\n+            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\n+            if (JavaVersions.VERSION >= 6) {\n+                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\n+\n+                t = new ClassFileTransformer() {\n+                    public byte[] transform(ClassLoader loader, String clsName,\n+                        Class<?> classBeingRedefined, ProtectionDomain pd,\n+                        byte[] classfileBuffer) {\n+                        return classes.get(classBeingRedefined);\n+                    }\n+                };\n+                \n+                // these are Java 6 methods, and we don't have a Java 6 build\n+                // module yet. The cost of reflection here is negligible\n+                // compared to the redefinition / enhancement costs in total,\n+                // so this should not be a big problem.\n+                Method meth = inst.getClass().getMethod(\"addTransformer\",\n+                    new Class[] { ClassFileTransformer.class, boolean.class });\n+                meth.invoke(inst, new Object[] { t, true });\n+                meth = inst.getClass().getMethod(\"retransformClasses\",\n+                    new Class[] { array.getClass() });\n+                meth.invoke(inst, new Object[] { array });\n+            } else {\n+                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\n+                // in a Java 5 context, we can use class redefinition instead\n+                ClassDefinition[] defs = new ClassDefinition[array.length];\n+                for (int i = 0; i < defs.length; i++)\n+                    defs[i] = new ClassDefinition(array[i],\n+                        classes.get(array[i]));\n+                inst.redefineClasses(defs);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new InternalException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new UserException(e.getCause());\n+        } catch (IOException e) {\n+            throw new InternalException(e);\n+        } catch (ClassNotFoundException e) {\n+            throw new InternalException(e);\n+        } catch (UnmodifiableClassException e) {\n+            throw new InternalException(e);\n+        } finally {\n+            if (inst != null && t != null)\n+                inst.removeTransformer(t);\n+        }\n+    }\n+\n+    /**\n+     * @return whether or not this VM has an instrumentation installed that\n+     * permits redefinition of classes. This assumes that all the arguments\n+     * will be modifiable classes according to\n+     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\n+     * only checks whether or not an instrumentation is available and\n+     * if retransformation is possible.\n+     */\n+    public static boolean canRedefineClasses() {\n+        if (_canRedefine == null) {\n+            try {\n+                Instrumentation inst = InstrumentationFactory\n+                    .getInstrumentation();\n+                if (inst == null) {\n+                    _canRedefine = Boolean.FALSE;\n+                } else if (JavaVersions.VERSION == 5) {\n+                    // if inst is non-null and we're using Java 5,\n+                    // isRetransformClassesSupported isn't available,\n+                    // so we use the more basic class redefinition\n+                    // instead.\n+                    _canRedefine = Boolean.TRUE;\n+                } else {\n+                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\n+                        \"isRetransformClassesSupported\").invoke(inst);\n+                }\n+            } catch (Exception e) {\n+                _canRedefine = Boolean.FALSE;\n+            }\n+        }\n+        return _canRedefine.booleanValue();\n+    }\n }\n\\ No newline at end of file"},{"sha":"1228778462a11d1f0f25075b69d3f1ddf04ecdd8","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":280,"deletions":280,"changes":560,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,280 +1,280 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.IOException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.BytecodeWriter;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.GeneratedClasses;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.bytecode.BCClass;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing unenhanced classes to make them\r\n- * notify state managers of mutations.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ManagedClassSubclasser {\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        ManagedClassSubclasser.class);\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, creates and registers a\r\n-     * new subclass that implements {@link PersistenceCapable}, and prepares\r\n-     * OpenJPA to handle new instances of the unenhanced type. If this is\r\n-     * invoked in a Java 6 environment, this method will redefine the methods\r\n-     * for each class in the argument list such that field accesses are\r\n-     * intercepted in-line. If invoked in a Java 5 environment, this\r\n-     * redefinition is not possible; in these contexts, when using field\r\n-     * access, OpenJPA will need to do state comparisons to detect any change\r\n-     * to any instance at any time, and when using property access, OpenJPA\r\n-     * will need to do state comparisons to detect changes to newly inserted\r\n-     * instances after a flush has been called.\r\n-     *\r\n-     * @return the new subclasses, or <code>null</code> if <code>classes</code>\r\n-     * is <code>null</code>.\r\n-     * @throws UserException if <code>conf</code> requires build-time\r\n-     * enhancement and <code>classes</code> includes unenhanced types.\r\n-     *\r\n-     * @since 1.0.0\r\n-     */\r\n-    public static List<Class> prepareUnenhancedClasses(\r\n-        final OpenJPAConfiguration conf,\r\n-        final Collection<? extends Class> classes,\r\n-        final ClassLoader envLoader) {\r\n-        if (classes == null)\r\n-            return null;\r\n-        if (classes.size() == 0)\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        if (conf.getRuntimeUnenhancedClassesConstant()\r\n-            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\r\n-            Collection unenhanced = new ArrayList();\r\n-            for (Class cls : classes)\r\n-                if (!PersistenceCapable.class.isAssignableFrom(cls))\r\n-                    unenhanced.add(cls);\r\n-            if (unenhanced.size() > 0) {\r\n-                Message msg = _loc.get(\"runtime-optimization-disabled\",\r\n-                    unenhanced);\r\n-                if (conf.getRuntimeUnenhancedClassesConstant()\r\n-                    == RuntimeUnenhancedClasssesModes.WARN)\r\n-                    log.warn(msg);\r\n-                else\r\n-                    throw new UserException(msg);\r\n-            }\r\n-            return null;\r\n-        }\r\n-\r\n-        boolean redefine = ClassRedefiner.canRedefineClasses();\r\n-        if (redefine)\r\n-            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\r\n-                classes));\r\n-        else\r\n-            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\r\n-                classes));\r\n-\r\n-        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\r\n-        final List subs = new ArrayList(classes.size());\r\n-        final List ints = new ArrayList(classes.size());\r\n-        Set<Class> unspecified = null;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n-            final Class cls = (Class) iter.next();\r\n-            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\r\n-\r\n-            enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n-                public void write(BCClass bc) throws IOException {\r\n-                    ManagedClassSubclasser.write(bc, enhancer, map,\r\n-                        cls, subs, ints);\r\n-                }\r\n-            });\r\n-            if (redefine)\r\n-                enhancer.setRedefine(true);\r\n-            enhancer.setCreateSubclass(true);\r\n-            enhancer.setAddDefaultConstructor(true);\r\n-\r\n-            // set this before enhancement as well as after since enhancement\r\n-            // uses a different metadata repository, and the metadata config\r\n-            // matters in the enhancement contract. Don't do any warning here,\r\n-            // since we'll issue warnings when we do the final metadata\r\n-            // reconfiguration at the end of this method.\r\n-            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\r\n-\r\n-            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\r\n-                classes, unspecified);\r\n-\r\n-            int runResult = enhancer.run();\r\n-            if (runResult == PCEnhancer.ENHANCE_PC) {\r\n-                try {\r\n-                    enhancer.record();\r\n-                } catch (IOException e) {\r\n-                    // our impl of BytecodeWriter doesn't throw IOException\r\n-                    throw new InternalException(e);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        if (unspecified != null && !unspecified.isEmpty())\r\n-            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\r\n-                classes, unspecified));\r\n-\r\n-        ClassRedefiner.redefineClasses(conf, map);\r\n-        for (Class cls : map.keySet()) {\r\n-            setIntercepting(conf, envLoader, cls);\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        }\r\n-        for (Class cls : (Collection<Class>) subs)\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        for (Class cls : (Collection<Class>) ints)\r\n-            setIntercepting(conf, envLoader, cls);\r\n-\r\n-        return subs;\r\n-    }\r\n-\r\n-    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\r\n-            unspecified);\r\n-\r\n-        for (FieldMetaData fmd : meta.getFields()) {\r\n-            if (fmd.isTransient())\r\n-                continue;\r\n-            if (fmd.isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getType(), classes,\r\n-                    unspecified);\r\n-            if (fmd.getElement() != null && fmd.getElement().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getKey() != null && fmd.getKey().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getValue() != null && fmd.getValue().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\r\n-                    classes, unspecified);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static Set<Class> collectUnspecifiedType(Class cls,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        if (cls != null && !classes.contains(cls)\r\n-            && !ImplHelper.isManagedType(null, cls)) {\r\n-            if (unspecified == null)\r\n-                unspecified = new HashSet<Class>();\r\n-            unspecified.add(cls);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static void configureMetaData(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        configureMetaData(meta, conf, redefineAvailable, true);\r\n-    }\r\n-\r\n-    private static void configureMetaData(ClassMetaData meta,\r\n-        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\r\n-\r\n-        setDetachedState(meta);\r\n-\r\n-        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\r\n-            && !redefineAvailable) {\r\n-            // only warn about declared fields; superclass fields will be\r\n-            // warned about when the superclass is handled\r\n-            for (FieldMetaData fmd : meta.getDeclaredFields()) {\r\n-                switch (fmd.getTypeCode()) {\r\n-                    case JavaTypes.COLLECTION:\r\n-                    case JavaTypes.MAP:\r\n-                        // we can lazily load these, since we own the\r\n-                        // relationship container\r\n-                        break;\r\n-                    default:\r\n-                        if (!fmd.isInDefaultFetchGroup()\r\n-                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\r\n-                            Log log = conf.getLog(\r\n-                                OpenJPAConfiguration.LOG_ENHANCE);\r\n-                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\r\n-                                meta.getDescribedType().getName(),\r\n-                                fmd.getName()));\r\n-                            fmd.setInDefaultFetchGroup(true);\r\n-                        }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void write(BCClass bc, PCEnhancer enhancer,\r\n-        Map<Class, byte[]> map, Class cls, List subs, List ints)\r\n-        throws IOException {\r\n-\r\n-        if (bc == enhancer.getManagedTypeBytecode()) {\r\n-            // if it was already defined, don't put it in the map,\r\n-            // but do set the metadata accordingly.\r\n-            if (enhancer.isAlreadyRedefined())\r\n-                ints.add(bc.getType());\r\n-            else if (JavaVersions.VERSION >= 5)\r\n-                map.put(bc.getType(), bc.toByteArray());\r\n-        } else {\r\n-            if (!enhancer.isAlreadySubclassed()) {\r\n-                // this is the new subclass\r\n-                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\r\n-                    cls, PersistenceCapable.class);\r\n-                subs.add(GeneratedClasses.loadBCClass(bc, loader));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void setIntercepting(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        meta.setIntercepting(true);\r\n-    }\r\n-\r\n-    /**\r\n-     * If the metadata is configured to use a synthetic\r\n-     * detached state, reset it to not use a detached\r\n-     * state field, since we can't add fields when redefining.\r\n-     */\r\n-    private static void setDetachedState(ClassMetaData meta) {\r\n-        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\r\n-            meta.setDetachedState(null);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.BytecodeWriter;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.GeneratedClasses;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+import serp.bytecode.BCClass;\n+\n+/**\n+ * Redefines the method bodies of existing unenhanced classes to make them\n+ * notify state managers of mutations.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ManagedClassSubclasser {\n+    private static final Localizer _loc = Localizer.forPackage(\n+        ManagedClassSubclasser.class);\n+\n+    /**\n+     * For each element in <code>classes</code>, creates and registers a\n+     * new subclass that implements {@link PersistenceCapable}, and prepares\n+     * OpenJPA to handle new instances of the unenhanced type. If this is\n+     * invoked in a Java 6 environment, this method will redefine the methods\n+     * for each class in the argument list such that field accesses are\n+     * intercepted in-line. If invoked in a Java 5 environment, this\n+     * redefinition is not possible; in these contexts, when using field\n+     * access, OpenJPA will need to do state comparisons to detect any change\n+     * to any instance at any time, and when using property access, OpenJPA\n+     * will need to do state comparisons to detect changes to newly inserted\n+     * instances after a flush has been called.\n+     *\n+     * @return the new subclasses, or <code>null</code> if <code>classes</code>\n+     * is <code>null</code>.\n+     * @throws UserException if <code>conf</code> requires build-time\n+     * enhancement and <code>classes</code> includes unenhanced types.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static List<Class> prepareUnenhancedClasses(\n+        final OpenJPAConfiguration conf,\n+        final Collection<? extends Class> classes,\n+        final ClassLoader envLoader) {\n+        if (classes == null)\n+            return null;\n+        if (classes.size() == 0)\n+            return Collections.EMPTY_LIST;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        if (conf.getRuntimeUnenhancedClassesConstant()\n+            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\n+            Collection unenhanced = new ArrayList();\n+            for (Class cls : classes)\n+                if (!PersistenceCapable.class.isAssignableFrom(cls))\n+                    unenhanced.add(cls);\n+            if (unenhanced.size() > 0) {\n+                Message msg = _loc.get(\"runtime-optimization-disabled\",\n+                    unenhanced);\n+                if (conf.getRuntimeUnenhancedClassesConstant()\n+                    == RuntimeUnenhancedClasssesModes.WARN)\n+                    log.warn(msg);\n+                else\n+                    throw new UserException(msg);\n+            }\n+            return null;\n+        }\n+\n+        boolean redefine = ClassRedefiner.canRedefineClasses();\n+        if (redefine)\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\n+                classes));\n+        else\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\n+                classes));\n+\n+        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\n+        final List subs = new ArrayList(classes.size());\n+        final List ints = new ArrayList(classes.size());\n+        Set<Class> unspecified = null;\n+        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\n+            final Class cls = (Class) iter.next();\n+            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\n+\n+            enhancer.setBytecodeWriter(new BytecodeWriter() {\n+                public void write(BCClass bc) throws IOException {\n+                    ManagedClassSubclasser.write(bc, enhancer, map,\n+                        cls, subs, ints);\n+                }\n+            });\n+            if (redefine)\n+                enhancer.setRedefine(true);\n+            enhancer.setCreateSubclass(true);\n+            enhancer.setAddDefaultConstructor(true);\n+\n+            // set this before enhancement as well as after since enhancement\n+            // uses a different metadata repository, and the metadata config\n+            // matters in the enhancement contract. Don't do any warning here,\n+            // since we'll issue warnings when we do the final metadata\n+            // reconfiguration at the end of this method.\n+            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\n+\n+            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\n+                classes, unspecified);\n+\n+            int runResult = enhancer.run();\n+            if (runResult == PCEnhancer.ENHANCE_PC) {\n+                try {\n+                    enhancer.record();\n+                } catch (IOException e) {\n+                    // our impl of BytecodeWriter doesn't throw IOException\n+                    throw new InternalException(e);\n+                }\n+            }\n+        }\n+\n+        if (unspecified != null && !unspecified.isEmpty())\n+            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\n+                classes, unspecified));\n+\n+        ClassRedefiner.redefineClasses(conf, map);\n+        for (Class cls : map.keySet()) {\n+            setIntercepting(conf, envLoader, cls);\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        }\n+        for (Class cls : (Collection<Class>) subs)\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        for (Class cls : (Collection<Class>) ints)\n+            setIntercepting(conf, envLoader, cls);\n+\n+        return subs;\n+    }\n+\n+    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\n+            unspecified);\n+\n+        for (FieldMetaData fmd : meta.getFields()) {\n+            if (fmd.isTransient())\n+                continue;\n+            if (fmd.isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getType(), classes,\n+                    unspecified);\n+            if (fmd.getElement() != null && fmd.getElement().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\n+                    classes, unspecified);\n+            if (fmd.getKey() != null && fmd.getKey().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\n+                    classes, unspecified);\n+            if (fmd.getValue() != null && fmd.getValue().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\n+                    classes, unspecified);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static Set<Class> collectUnspecifiedType(Class cls,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        if (cls != null && !classes.contains(cls)\n+            && !ImplHelper.isManagedType(null, cls)) {\n+            if (unspecified == null)\n+                unspecified = new HashSet<Class>();\n+            unspecified.add(cls);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static void configureMetaData(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        configureMetaData(meta, conf, redefineAvailable, true);\n+    }\n+\n+    private static void configureMetaData(ClassMetaData meta,\n+        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\n+\n+        setDetachedState(meta);\n+\n+        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\n+            && !redefineAvailable) {\n+            // only warn about declared fields; superclass fields will be\n+            // warned about when the superclass is handled\n+            for (FieldMetaData fmd : meta.getDeclaredFields()) {\n+                switch (fmd.getTypeCode()) {\n+                    case JavaTypes.COLLECTION:\n+                    case JavaTypes.MAP:\n+                        // we can lazily load these, since we own the\n+                        // relationship container\n+                        break;\n+                    default:\n+                        if (!fmd.isInDefaultFetchGroup()\n+                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\n+                            Log log = conf.getLog(\n+                                OpenJPAConfiguration.LOG_ENHANCE);\n+                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\n+                                meta.getDescribedType().getName(),\n+                                fmd.getName()));\n+                            fmd.setInDefaultFetchGroup(true);\n+                        }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void write(BCClass bc, PCEnhancer enhancer,\n+        Map<Class, byte[]> map, Class cls, List subs, List ints)\n+        throws IOException {\n+\n+        if (bc == enhancer.getManagedTypeBytecode()) {\n+            // if it was already defined, don't put it in the map,\n+            // but do set the metadata accordingly.\n+            if (enhancer.isAlreadyRedefined())\n+                ints.add(bc.getType());\n+            else if (JavaVersions.VERSION >= 5)\n+                map.put(bc.getType(), bc.toByteArray());\n+        } else {\n+            if (!enhancer.isAlreadySubclassed()) {\n+                // this is the new subclass\n+                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\n+                    cls, PersistenceCapable.class);\n+                subs.add(GeneratedClasses.loadBCClass(bc, loader));\n+            }\n+        }\n+    }\n+\n+    private static void setIntercepting(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        meta.setIntercepting(true);\n+    }\n+\n+    /**\n+     * If the metadata is configured to use a synthetic\n+     * detached state, reset it to not use a detached\n+     * state field, since we can't add fields when redefining.\n+     */\n+    private static void setDetachedState(ClassMetaData meta) {\n+        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\n+            meta.setDetachedState(null);\n+    }\n+}"},{"sha":"ce0958229f1aec56780e61974d3e32f908c1d0dd","filename":"openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"modified","additions":93,"deletions":93,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,93 +1,93 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.util.List;\r\n-import java.util.ArrayList;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-/**\r\n- * Tests that {@link Reflection#getDeclaredMethod(Class, String, Class)}\r\n- * returns the most-derived class's method when called from a type hierarchy.\r\n- * See OPENJPA-251.\r\n- */\r\n-public class TestGetDeclaredMethod extends TestCase {\r\n-\r\n-    public void testGetDeclaredMethod() {\r\n-        Method meth =\r\n-            Reflection.getDeclaredMethod(Impl.class, \"getObject\", null);\r\n-        assertEquals(Impl.class, meth.getDeclaringClass());\r\n-        assertEquals(String.class, meth.getReturnType());\r\n-    }\r\n-\r\n-    public void testMostDerived() throws NoSuchMethodException {\r\n-        Method impl = Impl.class.getDeclaredMethod(\"getObject\", null);\r\n-        Method iface = Iface.class.getDeclaredMethod(\"getObject\", null);\r\n-        Method other = Other.class.getDeclaredMethod(\"getObject\", null);\r\n-        assertEquals(Impl.class, Reflection.mostDerived(impl, iface)\r\n-            .getDeclaringClass());\r\n-        assertEquals(Impl.class, Reflection.mostDerived(iface, impl)\r\n-            .getDeclaringClass());\r\n-        try {\r\n-            Reflection.mostDerived(iface, other);\r\n-            fail(\"'iface' and 'other' are not from related types\");\r\n-        } catch (IllegalArgumentException e) {\r\n-            // expected\r\n-        }\r\n-    }\r\n-\r\n-    public void testGenerics() throws NoSuchMethodException {\r\n-        List<Method> meths = new ArrayList<Method>();\r\n-        for (Method meth : GenericsImpl.class.getDeclaredMethods()) {\r\n-            if (\"getObject\".equals(meth.getName()))\r\n-                meths.add(meth);\r\n-        }\r\n-        assertEquals(2, meths.size());\r\n-        assertEquals(String.class, Reflection.mostDerived(meths.get(0),\r\n-            meths.get(1)).getReturnType());\r\n-    }\r\n-    \r\n-    interface Iface {\r\n-        Object getObject();\r\n-    }\r\n-\r\n-    static class Impl implements Iface {\r\n-        public String getObject() {\r\n-            return \"string\";\r\n-        }\r\n-    }\r\n-\r\n-    static class Other {\r\n-        public String getObject() {\r\n-            return \"other\";\r\n-        }\r\n-    }\r\n-\r\n-    interface GenericsIface<T> {\r\n-        public T getObject();\r\n-    }\r\n-\r\n-    static class GenericsImpl implements GenericsIface {\r\n-        public String getObject() {\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests that {@link Reflection#getDeclaredMethod(Class, String, Class)}\n+ * returns the most-derived class's method when called from a type hierarchy.\n+ * See OPENJPA-251.\n+ */\n+public class TestGetDeclaredMethod extends TestCase {\n+\n+    public void testGetDeclaredMethod() {\n+        Method meth =\n+            Reflection.getDeclaredMethod(Impl.class, \"getObject\", null);\n+        assertEquals(Impl.class, meth.getDeclaringClass());\n+        assertEquals(String.class, meth.getReturnType());\n+    }\n+\n+    public void testMostDerived() throws NoSuchMethodException {\n+        Method impl = Impl.class.getDeclaredMethod(\"getObject\", null);\n+        Method iface = Iface.class.getDeclaredMethod(\"getObject\", null);\n+        Method other = Other.class.getDeclaredMethod(\"getObject\", null);\n+        assertEquals(Impl.class, Reflection.mostDerived(impl, iface)\n+            .getDeclaringClass());\n+        assertEquals(Impl.class, Reflection.mostDerived(iface, impl)\n+            .getDeclaringClass());\n+        try {\n+            Reflection.mostDerived(iface, other);\n+            fail(\"'iface' and 'other' are not from related types\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGenerics() throws NoSuchMethodException {\n+        List<Method> meths = new ArrayList<Method>();\n+        for (Method meth : GenericsImpl.class.getDeclaredMethods()) {\n+            if (\"getObject\".equals(meth.getName()))\n+                meths.add(meth);\n+        }\n+        assertEquals(2, meths.size());\n+        assertEquals(String.class, Reflection.mostDerived(meths.get(0),\n+            meths.get(1)).getReturnType());\n+    }\n+    \n+    interface Iface {\n+        Object getObject();\n+    }\n+\n+    static class Impl implements Iface {\n+        public String getObject() {\n+            return \"string\";\n+        }\n+    }\n+\n+    static class Other {\n+        public String getObject() {\n+            return \"other\";\n+        }\n+    }\n+\n+    interface GenericsIface<T> {\n+        public T getObject();\n+    }\n+\n+    static class GenericsImpl implements GenericsIface {\n+        public String getObject() {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"a8e5bb124bc013c11c3e4a2172f39148dd737a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Adds datastore based extension to ProductDerivation.  \r\n- *\r\n- * @since 0.4.1\r\n- * @author Pinaki Poddar\r\n- */\r\n-public interface OpenJPAProductDerivation extends ProductDerivation {\r\n-\r\n-    public static final int TYPE_SPEC = 0;\r\n-    public static final int TYPE_STORE = 200;\r\n-    public static final int TYPE_SPEC_STORE = 300;\r\n-    public static final int TYPE_PRODUCT_STORE = 400;\r\n-\r\n-    /**\r\n-     * Load default alias options into the given map.  Each entry maps an\r\n-     * alias to a broker factory class name.  Replace anything previously \r\n-     * under the desired keys.\r\n-     */\r\n-    public void putBrokerFactoryAliases(Map aliases);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+import java.util.Map;\n+\n+/**\n+ * Adds datastore based extension to ProductDerivation.  \n+ *\n+ * @since 0.4.1\n+ * @author Pinaki Poddar\n+ */\n+public interface OpenJPAProductDerivation extends ProductDerivation {\n+\n+    public static final int TYPE_SPEC = 0;\n+    public static final int TYPE_STORE = 200;\n+    public static final int TYPE_SPEC_STORE = 300;\n+    public static final int TYPE_PRODUCT_STORE = 400;\n+\n+    /**\n+     * Load default alias options into the given map.  Each entry maps an\n+     * alias to a broker factory class name.  Replace anything previously \n+     * under the desired keys.\n+     */\n+    public void putBrokerFactoryAliases(Map aliases);\n+}"},{"sha":"1ba500fa71877e166aa92a9c9b5ba04ab94f107a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":94,"deletions":94,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,94 +1,94 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Hashtable;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.ParseException;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A cache of compiled queries.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.9.6 (also existed in prior versions of Kodo)\r\n- * @nojavadoc\r\n- */\r\n-public class QueryCompilationCacheValue\r\n-    extends PluginValue {\r\n-\r\n-    public static final String[] ALIASES = {\r\n-        \"true\", CacheMap.class.getName(),\r\n-        \"all\", ConcurrentHashMap.class.getName(),\r\n-        \"false\", null,\r\n-    };\r\n-\r\n-    public QueryCompilationCacheValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-\r\n-    public Object newInstance(String clsName, Class type,\r\n-        Configuration conf, boolean fatal) {\r\n-        // make sure map handles concurrency\r\n-        Map map;\r\n-        \r\n-        try {\r\n-            map = (Map) super.newInstance(clsName, type, conf, fatal);\r\n-        } catch (ParseException pe) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the ParseException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        } catch (IllegalArgumentException iae) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the IllegalArgumentException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        }\r\n-\r\n-        if (map != null && !(map instanceof Hashtable)\r\n-            && !(map instanceof CacheMap)\r\n-            && !(map instanceof ConcurrentMap))\r\n-            map = Collections.synchronizedMap(map);\r\n-        return map;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.ParseException;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A cache of compiled queries.\n+ *\n+ * @author Abe White\n+ * @since 0.9.6 (also existed in prior versions of Kodo)\n+ * @nojavadoc\n+ */\n+public class QueryCompilationCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+\n+    public QueryCompilationCacheValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // make sure map handles concurrency\n+        Map map;\n+        \n+        try {\n+            map = (Map) super.newInstance(clsName, type, conf, fatal);\n+        } catch (ParseException pe) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the ParseException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        } catch (IllegalArgumentException iae) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the IllegalArgumentException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        }\n+\n+        if (map != null && !(map instanceof Hashtable)\n+            && !(map instanceof CacheMap)\n+            && !(map instanceof ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+\t}\n+}"},{"sha":"3904232254b3c6af09c6ebad37e46f7795acdc6f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can convert a positional index for a\r\n- * {@link FieldMetaData} that uses property access into the underlying\r\n- * field name. Instances of {@link DynamicPersistenceCapable} for types\r\n- * that use property access will implement this interface.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface AttributeTranslator {\r\n-    public String pcAttributeIndexToFieldName(int i);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can convert a positional index for a\n+ * {@link FieldMetaData} that uses property access into the underlying\n+ * field name. Instances of {@link DynamicPersistenceCapable} for types\n+ * that use property access will implement this interface.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface AttributeTranslator {\n+    public String pcAttributeIndexToFieldName(int i);\n+}"},{"sha":"945fa0a9dbc2371ab3e369ba543ce011cdfb498b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,30 +1,30 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Helper methods for dynamically-redefined managed types.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class DynamicPCHelper {\r\n-    public static boolean isDetached(Object o) {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Helper methods for dynamically-redefined managed types.\n+ *\n+ * @since 1.0.0\n+ */\n+public class DynamicPCHelper {\n+    public static boolean isDetached(Object o) {\n+        throw new UnsupportedOperationException();\n+    }\n+}"},{"sha":"78614624c6c833d8ecaa23f13903ad1c11a50d5a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances that implement this marker interface are dynamically-generated\r\n- * subtypes of managed types that were loaded before being enhanced.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface DynamicPersistenceCapable {\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances that implement this marker interface are dynamically-generated\n+ * subtypes of managed types that were loaded before being enhanced.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface DynamicPersistenceCapable {\n+}"},{"sha":"ebdd746c8638de5766fb5d0add78c927b6d4b0fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can provide an underlying instance.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface ManagedInstanceProvider {\r\n-    public Object getManagedInstance();\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can provide an underlying instance.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface ManagedInstanceProvider {\n+    public Object getManagedInstance();\n+}"},{"sha":"aef221a3223762557d2d3c570628c63e318767b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"modified","additions":272,"deletions":272,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,272 +1,272 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.Method;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCMethod;\r\n-\r\n-/**\r\n- *\t<p>Validates that a given type meets the JPA contract, plus a few\r\n- *  OpenJPA-specific additions for subclassing / redefinition:\r\n- *\r\n- *\t<ul>\r\n- * \t\t<li>must have an accessible no-args constructor</li>\r\n- * \t\t<li>must be a public or protected class</li>\r\n- * \t\t<li>must not be final</li>\r\n- * \t\t<li>must not extend an enhanced class</li>\r\n- *\t\t<li>all persistent data represented by accessible setter/getter\r\n- * \t\t\tmethods (persistent properties)</li>\r\n- * \t\t<li>if versioning is to be used, exactly one persistent property for\r\n- * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\r\n- *\r\n- * \t\t<li>When using property access, the backing field for a persistent\r\n- *          property must be:\r\n- * \t\t\t<ul>\r\n- * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\r\n- * \t\t\t\t<li>private</li>\r\n- * \t\t\t\t<li>set only in the designated setter,\r\n- * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\r\n- * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\r\n- * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\r\n- * \t\t\t\t<li>read only in the designated getter and the\r\n- * \t\t\t\t\tconstructor.</li>\r\n- *\t\t\t</ul>\r\n- * \t\t</li>\r\n- * \t</ul>\r\n- *\r\n- * \t<p>If you use this technique and use the <code>new</code> keyword instead of\r\n- * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\r\n- *  with persistent-new-flushed instances, since OpenJPA cannot in this case\r\n- *  track what happens to such an instance.</p>\r\n- *\r\n- * \t@since 1.0.0\r\n- */\r\n-public class PCSubclassValidator {\r\n-\r\n-    private static final Localizer loc =\r\n-        Localizer.forPackage(PCSubclassValidator.class);\r\n-\r\n-    private final ClassMetaData meta;\r\n-    private final BCClass pc;\r\n-    private final Log log;\r\n-    private final boolean failOnContractViolations;\r\n-\r\n-    private Collection errors;\r\n-    private Collection contractViolations;\r\n-\r\n-    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\r\n-        boolean enforceContractViolations) {\r\n-        this.meta = meta;\r\n-        this.pc = bc;\r\n-        this.log = log;\r\n-        this.failOnContractViolations = enforceContractViolations;\r\n-    }\r\n-\r\n-    public void assertCanSubclass() {\r\n-        Class superclass = meta.getDescribedType();\r\n-        String name = superclass.getName();\r\n-        if (superclass.isInterface())\r\n-            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\r\n-        if (Modifier.isFinal(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\r\n-        if (Modifier.isPrivate(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\r\n-        if (PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\r\n-\r\n-        try {\r\n-            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\r\n-            if (!(Modifier.isProtected(c.getModifiers())\r\n-                || Modifier.isPublic(c.getModifiers())))\r\n-                addError(loc.get(\"subclasser-private-ctor\", name), meta);\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            addError(loc.get(\"subclasser-no-void-ctor\", name),\r\n-                meta);\r\n-        }\r\n-\r\n-        // if the BCClass we loaded is already pc and the superclass is not,\r\n-        // then we should never get here, so let's make sure that the\r\n-        // calling context is caching correctly by throwing an exception.\r\n-        if (pc.isInstanceOf(PersistenceCapable.class) &&\r\n-            !PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            throw new InternalException(\r\n-                loc.get(\"subclasser-class-already-pc\", name));\r\n-\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\r\n-            checkPropertiesAreInterceptable();\r\n-\r\n-        if (errors != null && !errors.isEmpty())\r\n-            throw new UserException(errors.toString());\r\n-        else if (contractViolations != null &&\r\n-            !contractViolations.isEmpty() && log.isWarnEnabled())\r\n-            log.warn(contractViolations.toString());\r\n-    }\r\n-\r\n-    private void checkPropertiesAreInterceptable() {\r\n-        // just considers accessor methods for now.\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            Method getter = (Method) fmds[i].getBackingMember();\r\n-            if (getter == null) {\r\n-                addError(loc.get(\"subclasser-no-getter\",\r\n-                    fmds[i].getName()), fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\r\n-\r\n-            Method setter = setterForField(fmds[i]);\r\n-            if (setter == null) {\r\n-                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\r\n-                    fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\r\n-            if (assignedField == null)\r\n-                continue;\r\n-\r\n-            if (assignedField != returnedField)\r\n-                addContractViolation(loc.get\r\n-                    (\"subclasser-setter-getter-field-mismatch\",\r\n-                        fmds[i].getName(), returnedField,assignedField),\r\n-                    fmds[i]);\r\n-\r\n-            // ### scan through all the rest of the class to make sure it\r\n-            // ### doesn't use the field.\r\n-        }\r\n-    }\r\n-\r\n-    private Method setterForField(FieldMetaData fmd) {\r\n-        try {\r\n-            return fmd.getDeclaringType().getDeclaredMethod(\r\n-                \"set\" + StringUtils.capitalize(fmd.getName()),\r\n-                new Class[]{ fmd.getDeclaredType() });\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the name of the field that is returned by <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         returned, or if it cannot be determined what is returned.\r\n-     */\r\n-    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-getter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the field that is set in <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         set, or if it cannot be determined what is set.\r\n-     */\r\n-    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-setter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    private BCMethod getBCMethod(Method meth) {\r\n-        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\r\n-        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\r\n-    }\r\n-\r\n-    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        String className = fmd.getDefiningMetaData().\r\n-            getDescribedType().getName();\r\n-        if (!(Modifier.isProtected(meth.getModifiers())\r\n-            || Modifier.isPublic(meth.getModifiers())))\r\n-            addError(loc.get(\"subclasser-private-accessors-unsupported\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isFinal(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-final-methods-not-allowed\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isNative(meth.getModifiers()))\r\n-            addContractViolation(loc.get\r\n-                (\"subclasser-native-methods-not-allowed\", className,\r\n-                    meth.getName()),\r\n-                fmd);\r\n-        if (Modifier.isStatic(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-static-methods-not-supported\",\r\n-                className, meth.getName()), fmd);\r\n-    }\r\n-\r\n-    private void addError(Message s, ClassMetaData cls) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-meta\", s,\r\n-            cls.getDescribedType().getName(),\r\n-            cls.getSourceFile()));\r\n-    }\r\n-\r\n-    private void addError(Message s, FieldMetaData fmd) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-field\", s,\r\n-            fmd.getFullName(),\r\n-            fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-\r\n-    private void addContractViolation(Message m, FieldMetaData fmd) {\r\n-        // add the violation as an error in case we're processing violations\r\n-        // as errors; this keeps them in the order that they were found rather\r\n-        // than just adding the violations to the end of the list.\r\n-        if (failOnContractViolations)\r\n-            addError(m, fmd);\r\n-\r\n-        if (contractViolations == null)\r\n-            contractViolations = new ArrayList();\r\n-\r\n-        contractViolations.add(loc.get\r\n-            (\"subclasser-contract-violation-field\", m.getMessage(),\r\n-                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.lib.log.Log;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCMethod;\n+\n+/**\n+ *\t<p>Validates that a given type meets the JPA contract, plus a few\n+ *  OpenJPA-specific additions for subclassing / redefinition:\n+ *\n+ *\t<ul>\n+ * \t\t<li>must have an accessible no-args constructor</li>\n+ * \t\t<li>must be a public or protected class</li>\n+ * \t\t<li>must not be final</li>\n+ * \t\t<li>must not extend an enhanced class</li>\n+ *\t\t<li>all persistent data represented by accessible setter/getter\n+ * \t\t\tmethods (persistent properties)</li>\n+ * \t\t<li>if versioning is to be used, exactly one persistent property for\n+ * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\n+ *\n+ * \t\t<li>When using property access, the backing field for a persistent\n+ *          property must be:\n+ * \t\t\t<ul>\n+ * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\n+ * \t\t\t\t<li>private</li>\n+ * \t\t\t\t<li>set only in the designated setter,\n+ * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\n+ * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\n+ * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\n+ * \t\t\t\t<li>read only in the designated getter and the\n+ * \t\t\t\t\tconstructor.</li>\n+ *\t\t\t</ul>\n+ * \t\t</li>\n+ * \t</ul>\n+ *\n+ * \t<p>If you use this technique and use the <code>new</code> keyword instead of\n+ * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\n+ *  with persistent-new-flushed instances, since OpenJPA cannot in this case\n+ *  track what happens to such an instance.</p>\n+ *\n+ * \t@since 1.0.0\n+ */\n+public class PCSubclassValidator {\n+\n+    private static final Localizer loc =\n+        Localizer.forPackage(PCSubclassValidator.class);\n+\n+    private final ClassMetaData meta;\n+    private final BCClass pc;\n+    private final Log log;\n+    private final boolean failOnContractViolations;\n+\n+    private Collection errors;\n+    private Collection contractViolations;\n+\n+    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\n+        boolean enforceContractViolations) {\n+        this.meta = meta;\n+        this.pc = bc;\n+        this.log = log;\n+        this.failOnContractViolations = enforceContractViolations;\n+    }\n+\n+    public void assertCanSubclass() {\n+        Class superclass = meta.getDescribedType();\n+        String name = superclass.getName();\n+        if (superclass.isInterface())\n+            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\n+        if (Modifier.isFinal(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\n+        if (Modifier.isPrivate(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\n+        if (PersistenceCapable.class.isAssignableFrom(superclass))\n+            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\n+\n+        try {\n+            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\n+            if (!(Modifier.isProtected(c.getModifiers())\n+                || Modifier.isPublic(c.getModifiers())))\n+                addError(loc.get(\"subclasser-private-ctor\", name), meta);\n+        }\n+        catch (NoSuchMethodException e) {\n+            addError(loc.get(\"subclasser-no-void-ctor\", name),\n+                meta);\n+        }\n+\n+        // if the BCClass we loaded is already pc and the superclass is not,\n+        // then we should never get here, so let's make sure that the\n+        // calling context is caching correctly by throwing an exception.\n+        if (pc.isInstanceOf(PersistenceCapable.class) &&\n+            !PersistenceCapable.class.isAssignableFrom(superclass))\n+            throw new InternalException(\n+                loc.get(\"subclasser-class-already-pc\", name));\n+\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\n+            checkPropertiesAreInterceptable();\n+\n+        if (errors != null && !errors.isEmpty())\n+            throw new UserException(errors.toString());\n+        else if (contractViolations != null &&\n+            !contractViolations.isEmpty() && log.isWarnEnabled())\n+            log.warn(contractViolations.toString());\n+    }\n+\n+    private void checkPropertiesAreInterceptable() {\n+        // just considers accessor methods for now.\n+        FieldMetaData[] fmds = meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            Method getter = (Method) fmds[i].getBackingMember();\n+            if (getter == null) {\n+                addError(loc.get(\"subclasser-no-getter\",\n+                    fmds[i].getName()), fmds[i]);\n+                continue;\n+            }\n+            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\n+\n+            Method setter = setterForField(fmds[i]);\n+            if (setter == null) {\n+                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\n+                    fmds[i]);\n+                continue;\n+            }\n+            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\n+            if (assignedField == null)\n+                continue;\n+\n+            if (assignedField != returnedField)\n+                addContractViolation(loc.get\n+                    (\"subclasser-setter-getter-field-mismatch\",\n+                        fmds[i].getName(), returnedField,assignedField),\n+                    fmds[i]);\n+\n+            // ### scan through all the rest of the class to make sure it\n+            // ### doesn't use the field.\n+        }\n+    }\n+\n+    private Method setterForField(FieldMetaData fmd) {\n+        try {\n+            return fmd.getDeclaringType().getDeclaredMethod(\n+                \"set\" + StringUtils.capitalize(fmd.getName()),\n+                new Class[]{ fmd.getDeclaredType() });\n+        }\n+        catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @return the name of the field that is returned by <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         returned, or if it cannot be determined what is returned.\n+     */\n+    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-getter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    /**\n+     * @return the field that is set in <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         set, or if it cannot be determined what is set.\n+     */\n+    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-setter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    private BCMethod getBCMethod(Method meth) {\n+        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\n+        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\n+    }\n+\n+    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\n+        String className = fmd.getDefiningMetaData().\n+            getDescribedType().getName();\n+        if (!(Modifier.isProtected(meth.getModifiers())\n+            || Modifier.isPublic(meth.getModifiers())))\n+            addError(loc.get(\"subclasser-private-accessors-unsupported\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isFinal(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-final-methods-not-allowed\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isNative(meth.getModifiers()))\n+            addContractViolation(loc.get\n+                (\"subclasser-native-methods-not-allowed\", className,\n+                    meth.getName()),\n+                fmd);\n+        if (Modifier.isStatic(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-static-methods-not-supported\",\n+                className, meth.getName()), fmd);\n+    }\n+\n+    private void addError(Message s, ClassMetaData cls) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-meta\", s,\n+            cls.getDescribedType().getName(),\n+            cls.getSourceFile()));\n+    }\n+\n+    private void addError(Message s, FieldMetaData fmd) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-field\", s,\n+            fmd.getFullName(),\n+            fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+\n+    private void addContractViolation(Message m, FieldMetaData fmd) {\n+        // add the violation as an error in case we're processing violations\n+        // as errors; this keeps them in the order that they were found rather\n+        // than just adding the violations to the end of the list.\n+        if (failOnContractViolations)\n+            addError(m, fmd);\n+\n+        if (contractViolations == null)\n+            contractViolations = new ArrayList();\n+\n+        contractViolations.add(loc.get\n+            (\"subclasser-contract-violation-field\", m.getMessage(),\n+                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+}"},{"sha":"d155a1b530c1c2738b9b3de2b0b445f7f045dd77","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"modified","additions":188,"deletions":188,"changes":376,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,188 +1,188 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * Helper methods for managed types that use method redefinition for field\r\n- * tracking.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class RedefinitionHelper {\r\n-\r\n-    /**\r\n-     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\r\n-     * {@link StateManagerImpl}.\r\n-     */\r\n-    public static void dirtyCheck(StateManager sm) {\r\n-        if (sm instanceof StateManagerImpl)\r\n-            ((StateManagerImpl) sm).dirtyCheck();\r\n-    }\r\n-\r\n-    /**\r\n-     * Notify the state manager for <code>o</code> (if any) that a field\r\n-     * is about to be accessed.\r\n-     */\r\n-    public static void accessingField(Object o, int absoluteIndex) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.accessingField(absoluteIndex);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, boolean cur,\r\n-        boolean next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingBooleanField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, char cur, char next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingCharField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, byte cur, byte next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingByteField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, short cur, short next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingShortField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, int cur, int next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingIntField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, long cur, long next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingLongField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, float cur, float next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingFloatField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, double cur,\r\n-        double next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingDoubleField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, String cur,\r\n-        String next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingStringField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, Object cur,\r\n-        Object next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingObjectField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * Helper methods for managed types that use method redefinition for field\n+ * tracking.\n+ *\n+ * @since 1.0.0\n+ */\n+public class RedefinitionHelper {\n+\n+    /**\n+     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\n+     * {@link StateManagerImpl}.\n+     */\n+    public static void dirtyCheck(StateManager sm) {\n+        if (sm instanceof StateManagerImpl)\n+            ((StateManagerImpl) sm).dirtyCheck();\n+    }\n+\n+    /**\n+     * Notify the state manager for <code>o</code> (if any) that a field\n+     * is about to be accessed.\n+     */\n+    public static void accessingField(Object o, int absoluteIndex) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.accessingField(absoluteIndex);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, boolean cur,\n+        boolean next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingBooleanField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, char cur, char next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingCharField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, byte cur, byte next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingByteField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, short cur, short next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingShortField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, int cur, int next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingIntField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, long cur, long next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingLongField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, float cur, float next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingFloatField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, double cur,\n+        double next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingDoubleField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, String cur,\n+        String next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingStringField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, Object cur,\n+        Object next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingObjectField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+}"},{"sha":"daf5d060d3c3d6d0d77c4717a8ce420fd9d58def","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":353,"deletions":353,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,353 +1,353 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Method;\r\n-\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.util.ApplicationIds;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.ObjectId;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-\r\n-/**\r\n- * Implementation of the {@link PersistenceCapable} interface that can handle\r\n- * the persistence-capable contract for instances that were not enhanced\r\n- * before class load time.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ReflectingPersistenceCapable\r\n-    implements PersistenceCapable, ManagedInstanceProvider {\r\n-\r\n-    private Object o;\r\n-    private StateManager sm;\r\n-    private PersistenceCapable pcSubclassInstance;\r\n-    private ClassMetaData meta;\r\n-\r\n-    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\r\n-        this.o = o;\r\n-        Class type = o.getClass();\r\n-        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n-        meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(type, null, true);\r\n-    }\r\n-\r\n-    public int pcGetEnhancementContractVersion() {\r\n-        return PCEnhancer.ENHANCER_VERSION;\r\n-    }\r\n-\r\n-    public Object pcGetGenericContext() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getGenericContext();\r\n-    }\r\n-\r\n-    public StateManager pcGetStateManager() {\r\n-        return sm;\r\n-    }\r\n-\r\n-    public void pcReplaceStateManager(StateManager sm) {\r\n-        this.sm = sm;\r\n-    }\r\n-\r\n-    public void pcProvideField(int i) {\r\n-        switch (meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                sm.providedBooleanField(this, i,\r\n-                    ((Boolean) getValue(i, o)).booleanValue());\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                sm.providedByteField(this, i,\r\n-                    ((Byte) getValue(i, o)).byteValue());\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                sm.providedCharField(this, i,\r\n-                    ((Character) getValue(i, o)).charValue());\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                sm.providedDoubleField(this, i,\r\n-                    ((Double) getValue(i, o)).doubleValue());\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                sm.providedFloatField(this, i,\r\n-                    ((Float) getValue(i, o)).floatValue());\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                sm.providedIntField(this, i,\r\n-                    ((Integer) getValue(i, o)).intValue());\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                sm.providedLongField(this, i,\r\n-                    ((Long) getValue(i, o)).longValue());\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                sm.providedShortField(this, i,\r\n-                    ((Short) getValue(i, o)).shortValue());\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                sm.providedStringField(this, i,\r\n-                    (String) getValue(i, o));\r\n-                break;\r\n-            default:\r\n-                sm.providedObjectField(this, i, getValue(i, o));\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcProvideFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcProvideField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcReplaceField(int i) {\r\n-        switch(meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                setValue(i, o, Boolean.valueOf(\r\n-                    sm.replaceBooleanField(this, i)));\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                setValue(i, o, new Character(sm.replaceCharField(this, i)));\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                setValue(i, o, new Long(sm.replaceLongField(this, i)));\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                setValue(i, o, new Short(sm.replaceShortField(this, i)));\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                setValue(i, o, sm.replaceStringField(this, i));\r\n-                break;\r\n-            default:\r\n-                setValue(i, o, sm.replaceObjectField(this, i));\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcReplaceFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcReplaceField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcCopyField(Object fromObject, int i) {\r\n-        // this doesn't need switch treatment because we're just\r\n-        // reflecting on both sides, bypassing field managers.\r\n-        setValue(i, o, getValue(i, fromObject));\r\n-    }\r\n-\r\n-    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcCopyField(fromObject, fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcDirty(String fieldName) {\r\n-        if (sm != null)\r\n-            sm.dirty(fieldName);\r\n-    }\r\n-\r\n-    public Object pcFetchObjectId() {\r\n-        if (sm != null)\r\n-            return sm.fetchObjectId();\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public Object pcGetVersion() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getVersion();\r\n-    }\r\n-\r\n-    public boolean pcIsDirty() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else {\r\n-            if (sm instanceof StateManagerImpl)\r\n-                ((StateManagerImpl) sm).dirtyCheck();\r\n-            return sm.isDirty();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean pcIsTransactional() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isTransactional();\r\n-    }\r\n-\r\n-    public boolean pcIsPersistent() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isPersistent();\r\n-    }\r\n-\r\n-    public boolean pcIsNew() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isNew();\r\n-    }\r\n-\r\n-    public boolean pcIsDeleted() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isDeleted();\r\n-    }\r\n-\r\n-    // null == unknown\r\n-    public Boolean pcIsDetached() {\r\n-        if (sm != null)\r\n-            return Boolean.valueOf(sm.isDetached());\r\n-\r\n-        // ##### we could do a lot more here if a detached state field\r\n-        // ##### was specified.\r\n-        return null;\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, clear);\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\r\n-        boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\r\n-    }\r\n-\r\n-    public Object pcNewObjectIdInstance() {\r\n-        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\r\n-        Object[] pks = new Object[pkFields.length];\r\n-        for (int i = 0; i < pkFields.length; i++)\r\n-            pks[i] = getValue(pkFields[i].getIndex(), o);\r\n-        return ApplicationIds.fromPKValues(pks, meta);\r\n-    }\r\n-    \r\n-    public Object pcNewObjectIdInstance(Object oid) {\r\n-        return pcSubclassInstance.pcNewObjectIdInstance(oid);\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(Object oid) {\r\n-        Object target;\r\n-        if (oid instanceof ObjectId)\r\n-            target = ((ObjectId) oid).getId();\r\n-        else\r\n-            target = oid;\r\n-\r\n-        FieldMetaData[] pks = meta.getPrimaryKeyFields();\r\n-        for (int i = 0; i < pks.length; i++) {\r\n-            Object val = getValue(pks[i].getIndex(), o);\r\n-            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\r\n-                true);\r\n-            Reflection.set(target, f, val);\r\n-        }\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\r\n-        Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object pcGetDetachedState() {\r\n-        // ##### we can implement this if a state field has been set\r\n-        return null;\r\n-    }\r\n-\r\n-    public void pcSetDetachedState(Object state) {\r\n-        // StateManagerImpl will invoke this with null during instance\r\n-        // initialization\r\n-        if (state != null)\r\n-            throw new UnsupportedOperationException();\r\n-        // ##### we can implement this if a state field has been set\r\n-    }\r\n-\r\n-    public Object getManagedInstance() {\r\n-        return o;\r\n-    }\r\n-\r\n-    private Object getValue(int i, Object o) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findGetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                return Reflection.get(o, meth);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                return Reflection.get(o, field);\r\n-            }\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            return Reflection.get(o, field);\r\n-        }\r\n-    }\r\n-\r\n-    private String toFieldName(int i) {\r\n-        if (pcSubclassInstance instanceof AttributeTranslator)\r\n-            return ((AttributeTranslator) pcSubclassInstance)\r\n-                .pcAttributeIndexToFieldName(i);\r\n-        else\r\n-            return meta.getField(i).getName();\r\n-    }\r\n-\r\n-    private void setValue(int i, Object o, Object val) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findSetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                Reflection.set(o, meth, val);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                Reflection.set(o, field, val);\r\n-            }\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            Reflection.set(o, field, val);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.ObjectId;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+\n+/**\n+ * Implementation of the {@link PersistenceCapable} interface that can handle\n+ * the persistence-capable contract for instances that were not enhanced\n+ * before class load time.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ReflectingPersistenceCapable\n+    implements PersistenceCapable, ManagedInstanceProvider {\n+\n+    private Object o;\n+    private StateManager sm;\n+    private PersistenceCapable pcSubclassInstance;\n+    private ClassMetaData meta;\n+\n+    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\n+        this.o = o;\n+        Class type = o.getClass();\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\n+        meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(type, null, true);\n+    }\n+\n+    public int pcGetEnhancementContractVersion() {\n+        return PCEnhancer.ENHANCER_VERSION;\n+    }\n+\n+    public Object pcGetGenericContext() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getGenericContext();\n+    }\n+\n+    public StateManager pcGetStateManager() {\n+        return sm;\n+    }\n+\n+    public void pcReplaceStateManager(StateManager sm) {\n+        this.sm = sm;\n+    }\n+\n+    public void pcProvideField(int i) {\n+        switch (meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                sm.providedBooleanField(this, i,\n+                    ((Boolean) getValue(i, o)).booleanValue());\n+                break;\n+            case JavaTypes.BYTE:\n+                sm.providedByteField(this, i,\n+                    ((Byte) getValue(i, o)).byteValue());\n+                break;\n+            case JavaTypes.CHAR:\n+                sm.providedCharField(this, i,\n+                    ((Character) getValue(i, o)).charValue());\n+                break;\n+            case JavaTypes.DOUBLE:\n+                sm.providedDoubleField(this, i,\n+                    ((Double) getValue(i, o)).doubleValue());\n+                break;\n+            case JavaTypes.FLOAT:\n+                sm.providedFloatField(this, i,\n+                    ((Float) getValue(i, o)).floatValue());\n+                break;\n+            case JavaTypes.INT:\n+                sm.providedIntField(this, i,\n+                    ((Integer) getValue(i, o)).intValue());\n+                break;\n+            case JavaTypes.LONG:\n+                sm.providedLongField(this, i,\n+                    ((Long) getValue(i, o)).longValue());\n+                break;\n+            case JavaTypes.SHORT:\n+                sm.providedShortField(this, i,\n+                    ((Short) getValue(i, o)).shortValue());\n+                break;\n+            case JavaTypes.STRING:\n+                sm.providedStringField(this, i,\n+                    (String) getValue(i, o));\n+                break;\n+            default:\n+                sm.providedObjectField(this, i, getValue(i, o));\n+                break;\n+        }\n+    }\n+\n+    public void pcProvideFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcProvideField(fieldIndices[i]);\n+    }\n+\n+    public void pcReplaceField(int i) {\n+        switch(meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                setValue(i, o, Boolean.valueOf(\n+                    sm.replaceBooleanField(this, i)));\n+                break;\n+            case JavaTypes.BYTE:\n+                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\n+                break;\n+            case JavaTypes.CHAR:\n+                setValue(i, o, new Character(sm.replaceCharField(this, i)));\n+                break;\n+            case JavaTypes.DOUBLE:\n+                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\n+                break;\n+            case JavaTypes.FLOAT:\n+                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\n+                break;\n+            case JavaTypes.INT:\n+                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\n+                break;\n+            case JavaTypes.LONG:\n+                setValue(i, o, new Long(sm.replaceLongField(this, i)));\n+                break;\n+            case JavaTypes.SHORT:\n+                setValue(i, o, new Short(sm.replaceShortField(this, i)));\n+                break;\n+            case JavaTypes.STRING:\n+                setValue(i, o, sm.replaceStringField(this, i));\n+                break;\n+            default:\n+                setValue(i, o, sm.replaceObjectField(this, i));\n+                break;\n+        }\n+    }\n+\n+    public void pcReplaceFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcReplaceField(fieldIndices[i]);\n+    }\n+\n+    public void pcCopyField(Object fromObject, int i) {\n+        // this doesn't need switch treatment because we're just\n+        // reflecting on both sides, bypassing field managers.\n+        setValue(i, o, getValue(i, fromObject));\n+    }\n+\n+    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcCopyField(fromObject, fieldIndices[i]);\n+    }\n+\n+    public void pcDirty(String fieldName) {\n+        if (sm != null)\n+            sm.dirty(fieldName);\n+    }\n+\n+    public Object pcFetchObjectId() {\n+        if (sm != null)\n+            return sm.fetchObjectId();\n+        else\n+            return null;\n+    }\n+\n+    public Object pcGetVersion() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getVersion();\n+    }\n+\n+    public boolean pcIsDirty() {\n+        if (sm == null)\n+            return false;\n+        else {\n+            if (sm instanceof StateManagerImpl)\n+                ((StateManagerImpl) sm).dirtyCheck();\n+            return sm.isDirty();\n+        }\n+    }\n+\n+    public boolean pcIsTransactional() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isTransactional();\n+    }\n+\n+    public boolean pcIsPersistent() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isPersistent();\n+    }\n+\n+    public boolean pcIsNew() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isNew();\n+    }\n+\n+    public boolean pcIsDeleted() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isDeleted();\n+    }\n+\n+    // null == unknown\n+    public Boolean pcIsDetached() {\n+        if (sm != null)\n+            return Boolean.valueOf(sm.isDetached());\n+\n+        // ##### we could do a lot more here if a detached state field\n+        // ##### was specified.\n+        return null;\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, clear);\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\n+        boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\n+    }\n+\n+    public Object pcNewObjectIdInstance() {\n+        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\n+        Object[] pks = new Object[pkFields.length];\n+        for (int i = 0; i < pkFields.length; i++)\n+            pks[i] = getValue(pkFields[i].getIndex(), o);\n+        return ApplicationIds.fromPKValues(pks, meta);\n+    }\n+    \n+    public Object pcNewObjectIdInstance(Object oid) {\n+        return pcSubclassInstance.pcNewObjectIdInstance(oid);\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(Object oid) {\n+        Object target;\n+        if (oid instanceof ObjectId)\n+            target = ((ObjectId) oid).getId();\n+        else\n+            target = oid;\n+\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\n+        for (int i = 0; i < pks.length; i++) {\n+            Object val = getValue(pks[i].getIndex(), o);\n+            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\n+                true);\n+            Reflection.set(target, f, val);\n+        }\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\n+        Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public Object pcGetDetachedState() {\n+        // ##### we can implement this if a state field has been set\n+        return null;\n+    }\n+\n+    public void pcSetDetachedState(Object state) {\n+        // StateManagerImpl will invoke this with null during instance\n+        // initialization\n+        if (state != null)\n+            throw new UnsupportedOperationException();\n+        // ##### we can implement this if a state field has been set\n+    }\n+\n+    public Object getManagedInstance() {\n+        return o;\n+    }\n+\n+    private Object getValue(int i, Object o) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            if (!meta.isIntercepting()) {\n+                Method meth = Reflection.findGetter(meta.getDescribedType(),\n+                    meta.getField(i).getName(), true);\n+                return Reflection.get(o, meth);\n+            } else {\n+                Field field = Reflection.findField(meta.getDescribedType(),\n+                    toFieldName(i), true);\n+                return Reflection.get(o, field);\n+            }\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            return Reflection.get(o, field);\n+        }\n+    }\n+\n+    private String toFieldName(int i) {\n+        if (pcSubclassInstance instanceof AttributeTranslator)\n+            return ((AttributeTranslator) pcSubclassInstance)\n+                .pcAttributeIndexToFieldName(i);\n+        else\n+            return meta.getField(i).getName();\n+    }\n+\n+    private void setValue(int i, Object o, Object val) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            if (!meta.isIntercepting()) {\n+                Method meth = Reflection.findSetter(meta.getDescribedType(),\n+                    meta.getField(i).getName(), true);\n+                Reflection.set(o, meth, val);\n+            } else {\n+                Field field = Reflection.findField(meta.getDescribedType(),\n+                    toFieldName(i), true);\n+                Reflection.set(o, field, val);\n+            }\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            Reflection.set(o, field, val);\n+        }\n+    }\n+}"},{"sha":"41848ae2942c0d72bac8123c2663ba6124caaa31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\r\n- * configuration setting.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface RuntimeUnenhancedClasssesModes {\r\n-    public final static int SUPPORTED = 0;\r\n-    public final static int UNSUPPORTED = 1;\r\n-    public final static int WARN = 2;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\n+ * configuration setting.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface RuntimeUnenhancedClasssesModes {\n+    public final static int SUPPORTED = 0;\n+    public final static int UNSUPPORTED = 1;\n+    public final static int WARN = 2;\n+}"},{"sha":"4c2ba87e2c6a9ef03124fb598aae0218f6e25e95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,56 +1,56 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import java.util.EventObject;\r\n-\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-\r\n-/**\r\n- * Event fired when a {@link BrokerFactory} is created.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class BrokerFactoryEvent\r\n-    extends EventObject {\r\n-\r\n-    /**\r\n-     * Fired after a {@link BrokerFactory} has been fully created.\r\n-     * This happens after the factory has been made read-only.\r\n-     */\r\n-    public static final int BROKER_FACTORY_CREATED = 0;\r\n-\r\n-    private int eventType;\r\n-\r\n-    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\r\n-        super(brokerFactory);\r\n-        this.eventType = eventType;\r\n-    }\r\n-\r\n-    public BrokerFactory getBrokerFactory() {\r\n-        return (BrokerFactory) getSource();\r\n-    }\r\n-\r\n-    /**\r\n-     * @return one of the event type codes defined in this event class.\r\n-     */\r\n-    public int getEventType() {\r\n-        return eventType;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import java.util.EventObject;\n+\n+import org.apache.openjpa.kernel.BrokerFactory;\n+\n+/**\n+ * Event fired when a {@link BrokerFactory} is created.\n+ *\n+ * @since 1.0.0\n+ */\n+public class BrokerFactoryEvent\n+    extends EventObject {\n+\n+    /**\n+     * Fired after a {@link BrokerFactory} has been fully created.\n+     * This happens after the factory has been made read-only.\n+     */\n+    public static final int BROKER_FACTORY_CREATED = 0;\n+\n+    private int eventType;\n+\n+    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\n+        super(brokerFactory);\n+        this.eventType = eventType;\n+    }\n+\n+    public BrokerFactory getBrokerFactory() {\n+        return (BrokerFactory) getSource();\n+    }\n+\n+    /**\n+     * @return one of the event type codes defined in this event class.\n+     */\n+    public int getEventType() {\n+        return eventType;\n+    }\n+}"},{"sha":"183e7ebf4084b11e2a3b6588a4bbe9abcccdeb35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,53 +1,53 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * {@link EventManager} responsible for notifying listeners of\r\n- * {@link BrokerFactoryEvent}s.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class BrokerFactoryEventManager\r\n-    extends AbstractConcurrentEventManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        BrokerFactoryEventManager.class);\r\n-\r\n-    private final Configuration _conf;\r\n-\r\n-    public BrokerFactoryEventManager(Configuration conf) {\r\n-        _conf = conf;\r\n-    }\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        try {\r\n-            BrokerFactoryEvent e = (BrokerFactoryEvent) event;\r\n-            ((BrokerFactoryListener) listener).eventFired(e);\r\n-        } catch (Exception e) {\r\n-            _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(\r\n-                _loc.get(\"broker-factory-listener-exception\"), e);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * {@link EventManager} responsible for notifying listeners of\n+ * {@link BrokerFactoryEvent}s.\n+ *\n+ * @since 1.0.0\n+ */\n+public class BrokerFactoryEventManager\n+    extends AbstractConcurrentEventManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage(\n+        BrokerFactoryEventManager.class);\n+\n+    private final Configuration _conf;\n+\n+    public BrokerFactoryEventManager(Configuration conf) {\n+        _conf = conf;\n+    }\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        try {\n+            BrokerFactoryEvent e = (BrokerFactoryEvent) event;\n+            ((BrokerFactoryListener) listener).eventFired(e);\n+        } catch (Exception e) {\n+            _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(\n+                _loc.get(\"broker-factory-listener-exception\"), e);\n+        }\n+    }\n+}"},{"sha":"35f129c5d49ba00ddd51f06f3bfb309fe75488a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,35 +1,35 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * Interface for listening to {@link BrokerFactoryEvent} objects. Should be\r\n- * registered with a {@link OpenJPAConfiguration}'s\r\n- * {@link BrokerFactoryEventManager}.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface BrokerFactoryListener {\r\n-\r\n-    /**\r\n-     * Invoked after a {@link BrokerFactory} has been fully created.\r\n-     * This happens after the factory has been made read-only.\r\n-     */\r\n-    public void eventFired(BrokerFactoryEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * Interface for listening to {@link BrokerFactoryEvent} objects. Should be\n+ * registered with a {@link OpenJPAConfiguration}'s\n+ * {@link BrokerFactoryEventManager}.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface BrokerFactoryListener {\n+\n+    /**\n+     * Invoked after a {@link BrokerFactory} has been fully created.\n+     * This happens after the factory has been made read-only.\n+     */\n+    public void eventFired(BrokerFactoryEvent event);\n+}"},{"sha":"a0525a0537b3f5e769415a113612e75d39d3d540","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,33 +1,33 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface PostDeleteListener {\r\n-    \r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link DeleteListener#afterDelete(LifecycleEvent)} in that the latter\r\n-     * is called after the delete operation, whereas this is called after the\r\n-     * delete statements have been sent to the data store.\r\n-     */\r\n-    public void afterDeletePerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface PostDeleteListener {\n+    \n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link DeleteListener#afterDelete(LifecycleEvent)} in that the latter\n+     * is called after the delete operation, whereas this is called after the\n+     * delete statements have been sent to the data store.\n+     */\n+    public void afterDeletePerformed(LifecycleEvent event);\n+}"},{"sha":"7af19bb90d32c6ac853a103a4fb374285a9a3383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,33 +1,33 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface PostPersistListener {\r\n-\r\n-    /**\r\n-     * Receives notifications after a persist operation has been written to the\r\n-     * data store. Differs from {@link PersistListener#afterPersist} in that\r\n-     * the latter is called at the end of the persist() operation itself, not\r\n-     * after the flush.\r\n-     */\r\n-    public void afterPersistPerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface PostPersistListener {\n+\n+    /**\n+     * Receives notifications after a persist operation has been written to the\n+     * data store. Differs from {@link PersistListener#afterPersist} in that\n+     * the latter is called at the end of the persist() operation itself, not\n+     * after the flush.\n+     */\n+    public void afterPersistPerformed(LifecycleEvent event);\n+}"},{"sha":"a9f24b061c04bc6b2fa11379e73d520eb16548ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,42 +1,42 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface UpdateListener {\r\n-\r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link StoreListener#beforeStore} in that the latter is called for\r\n-     * updated and new records, whereas this is only invoked for updated\r\n-     * records.\r\n-     */\r\n-    public void beforeUpdate(LifecycleEvent event);\r\n-\r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link StoreListener#afterStore} in that the latter is called for\r\n-     * updated and new records, whereas this is only invoked for updated\r\n-     * records, and that this is called after the record is actually flushed\r\n-     * to the store.\r\n-     */\r\n-    public void afterUpdatePerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface UpdateListener {\n+\n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link StoreListener#beforeStore} in that the latter is called for\n+     * updated and new records, whereas this is only invoked for updated\n+     * records.\n+     */\n+    public void beforeUpdate(LifecycleEvent event);\n+\n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link StoreListener#afterStore} in that the latter is called for\n+     * updated and new records, whereas this is only invoked for updated\n+     * records, and that this is called after the record is actually flushed\n+     * to the store.\n+     */\n+    public void afterUpdatePerformed(LifecycleEvent event);\n+}"},{"sha":"d84345fea6d8e158bdf595d852c9611bf91d8920","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":388,"deletions":388,"changes":776,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,388 +1,388 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.Serializable;\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Captures fetch group metadata.\r\n- */\r\n-public class FetchGroup \r\n-    implements Serializable {\r\n-\r\n-    /**\r\n-     * Name of the default fetch group.\r\n-     */\r\n-    public static final String NAME_DEFAULT = \"default\";\r\n-\r\n-    /**\r\n-     * Name of the \"all\" fetch group.\r\n-     */\r\n-    public static final String NAME_ALL = \"all\";\r\n-\r\n-    /**\r\n-     * Default field recursion depth.\r\n-     */\r\n-    public static final int RECURSION_DEPTH_DEFAULT = 1;\r\n-\r\n-    /**\r\n-     * Infinite depth.\r\n-     */\r\n-\tpublic static final int DEPTH_INFINITE = -1;\r\n-\r\n-    /**\r\n-     *  Standard default fetch group.\r\n-     */\r\n-    static final FetchGroup DEFAULT = new FetchGroup(NAME_DEFAULT, true);\r\n-\r\n-    /**\r\n-     *  Standard \"all\" fetch group.\r\n-     */\r\n-    static final FetchGroup ALL = new FetchGroup(NAME_ALL, false);\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (FetchGroup.class);\r\n-\r\n-    private final String _name;\r\n-    private final ClassMetaData _meta;\r\n-    private final boolean _readOnly;\r\n-    private List _includes;\r\n-    private Set  _containedBy;\r\n-    private Map _depths;\r\n-    private Boolean _postLoad;\r\n-\r\n-    /**\r\n-     * Constructor; supply immutable name.\r\n-     *\r\n-     * @param name must not by null or empty.\r\n-     */\r\n-    FetchGroup(ClassMetaData cm, String name) {\r\n-        _meta = cm;\r\n-        _name = name;\r\n-        _readOnly = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Internal constructor for builtin fetch groups.\r\n-     */\r\n-    private FetchGroup(String name, boolean postLoad) {\r\n-        _meta = null;\r\n-        _name = name;\r\n-        _postLoad = (postLoad) ? Boolean.TRUE : Boolean.FALSE;\r\n-        _readOnly = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy state from the given fetch group.\r\n-     */\r\n-    void copy(FetchGroup fg) {\r\n-        if (fg._includes != null)\r\n-            for (Iterator itr = fg._includes.iterator(); itr.hasNext();)\r\n-                addDeclaredInclude((String) itr.next());\r\n-        if (fg._containedBy != null) \r\n-        \tthis._containedBy = new HashSet(fg._containedBy);\r\n-        \r\n-        if (fg._depths != null) {\r\n-            Map.Entry entry;\r\n-            for (Iterator itr = fg._depths.entrySet().iterator(); \r\n-                itr.hasNext();) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                setRecursionDepth((FieldMetaData) entry.getKey(), ((Number) \r\n-                    entry.getValue()).intValue());\r\n-            }\r\n-        }\r\n-        if (fg._postLoad != null)\r\n-            _postLoad = fg._postLoad;\r\n-    }\r\n-\r\n-    /**\r\n-     * Fetch group name.\r\n-     */\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    /**\r\n-     * Includes given fetch group within this receiver.\r\n-     */\r\n-    public void addDeclaredInclude(String fgName) {\r\n-        if (_readOnly)\r\n-            throw new UnsupportedOperationException();\r\n-        if (StringUtils.isEmpty(fgName))\r\n-            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\r\n-        if (_includes == null)\r\n-            _includes = new ArrayList();\r\n-        if (!_includes.contains(fgName))\r\n-            _includes.add(fgName);\r\n-    }\r\n-\r\n-    /**\r\n-     * Affirms if given fetch group is included by this receiver.  Includes\r\n-     * superclass definition of fetch group and optionally other included \r\n-     * groups.\r\n-     *\r\n-     * @param recurse if true then recursively checks within the included\r\n-     * fecth groups\r\n-     */\r\n-    public boolean includes(String fgName, boolean recurse) {\r\n-        // check our includes\r\n-        if (_includes != null) {\r\n-            if (_includes.contains(fgName))\r\n-                return true;\r\n-            if (recurse && _meta!=null) {\r\n-                FetchGroup fg;\r\n-                for (Iterator i = _includes.iterator(); i.hasNext();) {\r\n-                    fg = _meta.getFetchGroup((String) i.next());\r\n-                    if (fg != null && fg.includes(fgName, true))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-        }\r\n-        if (_meta != null) {\r\n-            // check superclass includes\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null)\r\n-                    return supFG.includes(fgName, recurse);\r\n-            }\r\n-        }\r\n-        return false;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Adds this receiver as one of the included fetch groups of the given\r\n-     * parent. \r\n-     * The parent fecth group will include this receiver as a side-effect of\r\n-     * this call.\r\n-     * \r\n-     * @see #includes(String, boolean)\r\n-     * @see #addDeclaredInclude(String) \r\n-     * \r\n-     * @return true if given parent is a new addition. false othrwise.\r\n-     * @since 1.1.1   \r\n-     */\r\n-    public boolean addContainedBy(FetchGroup parent) {\r\n-    \tparent.addDeclaredInclude(this.getName());\r\n-    \tif (_containedBy==null)\r\n-    \t\t_containedBy = new HashSet();\r\n-    \treturn _containedBy.add(parent.getName());\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the name of the fetch groups in which this receiver has been\r\n-     * included.\r\n-     * \r\n-     * @see #addContainedBy(FetchGroup)\r\n-     * @since 1.1.1   \r\n-     */\r\n-    public Set getContainedBy() {\r\n-    \treturn (_containedBy == null) ? Collections.EMPTY_SET :\r\n-            Collections.unmodifiableSet(_containedBy);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the fetch group names declared included by this group.\r\n-     */\r\n-    public String[] getDeclaredIncludes() {\r\n-        // only used during serialization; no need to cache\r\n-        return (_includes == null) ? new String[0]\r\n-            : (String[]) _includes.toArray(new String[_includes.size()]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursion depth for the given field.  This is the depth of relations of\r\n-     * the same class as this one we can fetch through the given field.\r\n-     */\r\n-    public void setRecursionDepth(FieldMetaData fm, int depth) {\r\n-        if (_readOnly)\r\n-            throw new UnsupportedOperationException();\r\n-        if (depth < -1)\r\n-            throw new MetaDataException(_loc.get(\"invalid-fg-depth\", _name, fm, \r\n-                Numbers.valueOf(depth)));\r\n-        if (_depths == null)\r\n-            _depths = new HashMap();\r\n-        _depths.put(fm, Numbers.valueOf(depth));\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursion depth for the given field.  This is the depth of relations of\r\n-     * the same class as this one we can fetch through the given field.\r\n-     */\r\n-    public int getRecursionDepth(FieldMetaData fm) {\r\n-        Number depth = findRecursionDepth(fm);\r\n-        return (depth == null) ? RECURSION_DEPTH_DEFAULT : depth.intValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the recursion depth declared for the given field, or \r\n-     * 0 if none.\r\n-     */\r\n-    public int getDeclaredRecursionDepth(FieldMetaData fm) {\r\n-        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n-        return (depth == null) ? 0 : depth.intValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper to find recursion depth recursively in our includes.\r\n-     */\r\n-    private Number findRecursionDepth(FieldMetaData fm) { \r\n-        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n-        if (depth != null)\r\n-            return depth;\r\n-\r\n-        // check for superclass declaration of depth\r\n-        Number max = null;\r\n-        if (_meta != null && fm.getDeclaringMetaData() != _meta) {\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null)\r\n-                    max = supFG.findRecursionDepth(fm);\r\n-            }\r\n-        }\r\n-        if (_includes == null)\r\n-            return max;\r\n-\r\n-        // find largest included depth\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            fg = _meta.getFetchGroup((String) itr.next());\r\n-            depth = (fg == null) ? null : fg.findRecursionDepth(fm);\r\n-            if (depth != null && (max == null \r\n-                || depth.intValue() > max.intValue()))\r\n-                max = depth;\r\n-        }\r\n-        return max;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the fields with declared recursion depths in this group.\r\n-     */\r\n-    public FieldMetaData[] getDeclaredRecursionDepthFields() {\r\n-        // used in serialization only; no need to cache\r\n-        if (_depths == null)\r\n-            return new FieldMetaData[0];\r\n-         return (FieldMetaData[]) _depths.keySet().toArray\r\n-            (new FieldMetaData[_depths.size()]);\r\n-    } \r\n-\r\n-    /**\r\n-     * Whether loading this fetch group causes a post-load callback on the\r\n-     * loaded instance.\r\n-     */\r\n-    public void setPostLoad (boolean flag) {\r\n-        if (_readOnly && flag != isPostLoad())\r\n-            throw new UnsupportedOperationException();\r\n-    \t_postLoad = (flag) ? Boolean.TRUE : Boolean.FALSE;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether loading this fetch group causes a post-load callback on the\r\n-     * loaded instance.\r\n-     */\r\n-    public boolean isPostLoad () {\r\n-    \tif (_postLoad != null)\r\n-            return _postLoad.booleanValue();\r\n-\r\n-        if (_meta != null) {\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null && supFG.isPostLoad())\r\n-                    return true;\r\n-            }\r\n-        }\r\n-\r\n-        if (_includes == null)\r\n-            return false;\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            fg = _meta.getFetchGroup((String) itr.next());\r\n-            if (fg != null && fg.isPostLoad())\r\n-                return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the post-load value is declared for this group.  \r\n-     */\r\n-    public boolean isPostLoadExplicit() {\r\n-        return _postLoad != null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve and validate fetch group metadata.\r\n-     */\r\n-    public void resolve() {\r\n-        if (_includes == null)\r\n-            return;\r\n-\r\n-        // validate includes\r\n-        String name;\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            name = (String) itr.next();\r\n-            if (name.equals(_name))\r\n-                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n-            fg = _meta.getFetchGroup(name);\r\n-            if (fg == null)\r\n-                throw new MetaDataException(_loc.get(\"bad-fg-include\", this,\r\n-                    name));\r\n-            if (fg.includes(_name, true))\r\n-                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Affirms equality if the other has the same name and declaring type.\r\n-     */\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (!(other instanceof FetchGroup))\r\n-            return false;\r\n-        FetchGroup that = (FetchGroup) other;\r\n-        return _name.equals(that._name)\r\n-            && ObjectUtils.equals(_meta, that._meta);\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return _name.hashCode() + ((_meta == null) ? 0 : _meta.hashCode());\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return ((_meta == null) ? \"Builtin\" : _meta.toString ()) + \".\" + _name;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.MetaDataException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Captures fetch group metadata.\n+ */\n+public class FetchGroup \n+    implements Serializable {\n+\n+    /**\n+     * Name of the default fetch group.\n+     */\n+    public static final String NAME_DEFAULT = \"default\";\n+\n+    /**\n+     * Name of the \"all\" fetch group.\n+     */\n+    public static final String NAME_ALL = \"all\";\n+\n+    /**\n+     * Default field recursion depth.\n+     */\n+    public static final int RECURSION_DEPTH_DEFAULT = 1;\n+\n+    /**\n+     * Infinite depth.\n+     */\n+\tpublic static final int DEPTH_INFINITE = -1;\n+\n+    /**\n+     *  Standard default fetch group.\n+     */\n+    static final FetchGroup DEFAULT = new FetchGroup(NAME_DEFAULT, true);\n+\n+    /**\n+     *  Standard \"all\" fetch group.\n+     */\n+    static final FetchGroup ALL = new FetchGroup(NAME_ALL, false);\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (FetchGroup.class);\n+\n+    private final String _name;\n+    private final ClassMetaData _meta;\n+    private final boolean _readOnly;\n+    private List _includes;\n+    private Set  _containedBy;\n+    private Map _depths;\n+    private Boolean _postLoad;\n+\n+    /**\n+     * Constructor; supply immutable name.\n+     *\n+     * @param name must not by null or empty.\n+     */\n+    FetchGroup(ClassMetaData cm, String name) {\n+        _meta = cm;\n+        _name = name;\n+        _readOnly = false;\n+    }\n+\n+    /**\n+     * Internal constructor for builtin fetch groups.\n+     */\n+    private FetchGroup(String name, boolean postLoad) {\n+        _meta = null;\n+        _name = name;\n+        _postLoad = (postLoad) ? Boolean.TRUE : Boolean.FALSE;\n+        _readOnly = true;\n+    }\n+\n+    /**\n+     * Copy state from the given fetch group.\n+     */\n+    void copy(FetchGroup fg) {\n+        if (fg._includes != null)\n+            for (Iterator itr = fg._includes.iterator(); itr.hasNext();)\n+                addDeclaredInclude((String) itr.next());\n+        if (fg._containedBy != null) \n+        \tthis._containedBy = new HashSet(fg._containedBy);\n+        \n+        if (fg._depths != null) {\n+            Map.Entry entry;\n+            for (Iterator itr = fg._depths.entrySet().iterator(); \n+                itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                setRecursionDepth((FieldMetaData) entry.getKey(), ((Number) \n+                    entry.getValue()).intValue());\n+            }\n+        }\n+        if (fg._postLoad != null)\n+            _postLoad = fg._postLoad;\n+    }\n+\n+    /**\n+     * Fetch group name.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * Includes given fetch group within this receiver.\n+     */\n+    public void addDeclaredInclude(String fgName) {\n+        if (_readOnly)\n+            throw new UnsupportedOperationException();\n+        if (StringUtils.isEmpty(fgName))\n+            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\n+        if (_includes == null)\n+            _includes = new ArrayList();\n+        if (!_includes.contains(fgName))\n+            _includes.add(fgName);\n+    }\n+\n+    /**\n+     * Affirms if given fetch group is included by this receiver.  Includes\n+     * superclass definition of fetch group and optionally other included \n+     * groups.\n+     *\n+     * @param recurse if true then recursively checks within the included\n+     * fecth groups\n+     */\n+    public boolean includes(String fgName, boolean recurse) {\n+        // check our includes\n+        if (_includes != null) {\n+            if (_includes.contains(fgName))\n+                return true;\n+            if (recurse && _meta!=null) {\n+                FetchGroup fg;\n+                for (Iterator i = _includes.iterator(); i.hasNext();) {\n+                    fg = _meta.getFetchGroup((String) i.next());\n+                    if (fg != null && fg.includes(fgName, true))\n+                        return true;\n+                }\n+            }\n+        }\n+        if (_meta != null) {\n+            // check superclass includes\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null)\n+                    return supFG.includes(fgName, recurse);\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Adds this receiver as one of the included fetch groups of the given\n+     * parent. \n+     * The parent fecth group will include this receiver as a side-effect of\n+     * this call.\n+     * \n+     * @see #includes(String, boolean)\n+     * @see #addDeclaredInclude(String) \n+     * \n+     * @return true if given parent is a new addition. false othrwise.\n+     * @since 1.1.1   \n+     */\n+    public boolean addContainedBy(FetchGroup parent) {\n+    \tparent.addDeclaredInclude(this.getName());\n+    \tif (_containedBy==null)\n+    \t\t_containedBy = new HashSet();\n+    \treturn _containedBy.add(parent.getName());\n+    }\n+    \n+    /**\n+     * Gets the name of the fetch groups in which this receiver has been\n+     * included.\n+     * \n+     * @see #addContainedBy(FetchGroup)\n+     * @since 1.1.1   \n+     */\n+    public Set getContainedBy() {\n+    \treturn (_containedBy == null) ? Collections.EMPTY_SET :\n+            Collections.unmodifiableSet(_containedBy);\n+    }\n+\n+    /**\n+     * Return the fetch group names declared included by this group.\n+     */\n+    public String[] getDeclaredIncludes() {\n+        // only used during serialization; no need to cache\n+        return (_includes == null) ? new String[0]\n+            : (String[]) _includes.toArray(new String[_includes.size()]);\n+    }\n+\n+    /**\n+     * Recursion depth for the given field.  This is the depth of relations of\n+     * the same class as this one we can fetch through the given field.\n+     */\n+    public void setRecursionDepth(FieldMetaData fm, int depth) {\n+        if (_readOnly)\n+            throw new UnsupportedOperationException();\n+        if (depth < -1)\n+            throw new MetaDataException(_loc.get(\"invalid-fg-depth\", _name, fm, \n+                Numbers.valueOf(depth)));\n+        if (_depths == null)\n+            _depths = new HashMap();\n+        _depths.put(fm, Numbers.valueOf(depth));\n+    }\n+\n+    /**\n+     * Recursion depth for the given field.  This is the depth of relations of\n+     * the same class as this one we can fetch through the given field.\n+     */\n+    public int getRecursionDepth(FieldMetaData fm) {\n+        Number depth = findRecursionDepth(fm);\n+        return (depth == null) ? RECURSION_DEPTH_DEFAULT : depth.intValue();\n+    }\n+\n+    /**\n+     * Return the recursion depth declared for the given field, or \n+     * 0 if none.\n+     */\n+    public int getDeclaredRecursionDepth(FieldMetaData fm) {\n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\n+        return (depth == null) ? 0 : depth.intValue();\n+    }\n+\n+    /**\n+     * Helper to find recursion depth recursively in our includes.\n+     */\n+    private Number findRecursionDepth(FieldMetaData fm) { \n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\n+        if (depth != null)\n+            return depth;\n+\n+        // check for superclass declaration of depth\n+        Number max = null;\n+        if (_meta != null && fm.getDeclaringMetaData() != _meta) {\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null)\n+                    max = supFG.findRecursionDepth(fm);\n+            }\n+        }\n+        if (_includes == null)\n+            return max;\n+\n+        // find largest included depth\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            fg = _meta.getFetchGroup((String) itr.next());\n+            depth = (fg == null) ? null : fg.findRecursionDepth(fm);\n+            if (depth != null && (max == null \n+                || depth.intValue() > max.intValue()))\n+                max = depth;\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Return the fields with declared recursion depths in this group.\n+     */\n+    public FieldMetaData[] getDeclaredRecursionDepthFields() {\n+        // used in serialization only; no need to cache\n+        if (_depths == null)\n+            return new FieldMetaData[0];\n+         return (FieldMetaData[]) _depths.keySet().toArray\n+            (new FieldMetaData[_depths.size()]);\n+    } \n+\n+    /**\n+     * Whether loading this fetch group causes a post-load callback on the\n+     * loaded instance.\n+     */\n+    public void setPostLoad (boolean flag) {\n+        if (_readOnly && flag != isPostLoad())\n+            throw new UnsupportedOperationException();\n+    \t_postLoad = (flag) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether loading this fetch group causes a post-load callback on the\n+     * loaded instance.\n+     */\n+    public boolean isPostLoad () {\n+    \tif (_postLoad != null)\n+            return _postLoad.booleanValue();\n+\n+        if (_meta != null) {\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null && supFG.isPostLoad())\n+                    return true;\n+            }\n+        }\n+\n+        if (_includes == null)\n+            return false;\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            fg = _meta.getFetchGroup((String) itr.next());\n+            if (fg != null && fg.isPostLoad())\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Whether the post-load value is declared for this group.  \n+     */\n+    public boolean isPostLoadExplicit() {\n+        return _postLoad != null;\n+    }\n+\n+    /**\n+     * Resolve and validate fetch group metadata.\n+     */\n+    public void resolve() {\n+        if (_includes == null)\n+            return;\n+\n+        // validate includes\n+        String name;\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            name = (String) itr.next();\n+            if (name.equals(_name))\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\n+            fg = _meta.getFetchGroup(name);\n+            if (fg == null)\n+                throw new MetaDataException(_loc.get(\"bad-fg-include\", this,\n+                    name));\n+            if (fg.includes(_name, true))\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\n+        }\n+    }\n+    \n+    /**\n+     * Affirms equality if the other has the same name and declaring type.\n+     */\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof FetchGroup))\n+            return false;\n+        FetchGroup that = (FetchGroup) other;\n+        return _name.equals(that._name)\n+            && ObjectUtils.equals(_meta, that._meta);\n+    }\n+\n+    public int hashCode() {\n+        return _name.hashCode() + ((_meta == null) ? 0 : _meta.hashCode());\n+    }\n+\n+    public String toString() {\n+        return ((_meta == null) ? \"Builtin\" : _meta.toString ()) + \".\" + _name;\n+    }\n+}"},{"sha":"0974e89ff5051ae7f84ff33bd6722731fce4db64","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"modified","additions":130,"deletions":130,"changes":260,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,130 +1,130 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-import java.io.Serializable;\r\n-\r\n-import org.apache.openjpa.lib.meta.SourceTracker;\r\n-import org.apache.openjpa.lib.xml.Commentable;\r\n-\r\n-/**\r\n- * Metadata about a persistence-aware type.\r\n- *\r\n- * @author Pinaki Poddar\r\n- */\r\n-public class NonPersistentMetaData \r\n-\timplements Comparable, SourceTracker, Commentable, MetaDataContext,\r\n-        Serializable {\r\n-    public static final int TYPE_PERSISTENCE_AWARE = 1;\r\n-    public static final int TYPE_NON_MAPPED_INTERFACE = 2;\r\n-\r\n-    private final MetaDataRepository _repos;\r\n-\tprivate final Class _class;\r\n-    private final int _type;\r\n-\t\r\n-    private File _srcFile = null;\r\n-    private int _srcType = SRC_OTHER;\r\n-    private String[] _comments = null;\r\n-    private int _listIndex = -1;\r\n-\t\r\n-\tprotected NonPersistentMetaData(Class cls, MetaDataRepository repos, \r\n-        int type) {\r\n-\t\t_repos = repos;\r\n-\t\t_class = cls;\r\n-        _type = type;\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Owning repository.\r\n-     */\r\n-\tpublic MetaDataRepository getRepository() {\r\n-\t\treturn _repos;\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Persistence-aware type.\r\n-     */\r\n-\tpublic Class getDescribedType() {\r\n-\t\treturn _class;\r\n-\t}\r\n-\r\n-    /**\r\n-     * The type of metadata.\r\n-     */\r\n-    public int getType() {\r\n-        return _type;\r\n-    }\r\n-\t\r\n-    /**\r\n-     * The index in which this class was listed in the metadata. Defaults to\r\n-     * <code>-1</code> if this class was not listed in the metadata.\r\n-     */\r\n-    public int getListingIndex() {\r\n-        return _listIndex;\r\n-    }\r\n-\r\n-    /**\r\n-     * The index in which this field was listed in the metadata. Defaults to\r\n-     * <code>-1</code> if this class was not listed in the metadata.\r\n-     */\r\n-    public void setListingIndex(int index) {\r\n-        _listIndex = index;\r\n-    }\r\n-\r\n-    public File getSourceFile() {\r\n-        return _srcFile;\r\n-    }\r\n-\r\n-    public Object getSourceScope() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public int getSourceType() {\r\n-        return _srcType;\r\n-    }\r\n-\r\n-    public void setSource(File file, int srcType) {\r\n-        _srcFile = file;\r\n-        _srcType = srcType;\r\n-    }\r\n-\r\n-    public String getResourceName() {\r\n-        return _class.getName();\r\n-    }\r\n-\r\n-    public String[] getComments() {\r\n-        return (_comments == null) ? ClassMetaData.EMPTY_COMMENTS : _comments;\r\n-    }\r\n-\r\n-    public void setComments(String[] comments) {\r\n-        _comments = comments;\r\n-    }\r\n-    \r\n-    public int compareTo(Object o) {\r\n-        if (o == this)\r\n-            return 0;\r\n-        if (!(o instanceof NonPersistentMetaData))\r\n-        \treturn 1;\r\n-        NonPersistentMetaData other = (NonPersistentMetaData) o;\r\n-        if (_type != other.getType())\r\n-            return _type - other.getType();\r\n-        return _class.getName().compareTo(other.getDescribedType().getName());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.xml.Commentable;\n+\n+/**\n+ * Metadata about a persistence-aware type.\n+ *\n+ * @author Pinaki Poddar\n+ */\n+public class NonPersistentMetaData \n+\timplements Comparable, SourceTracker, Commentable, MetaDataContext,\n+        Serializable {\n+    public static final int TYPE_PERSISTENCE_AWARE = 1;\n+    public static final int TYPE_NON_MAPPED_INTERFACE = 2;\n+\n+    private final MetaDataRepository _repos;\n+\tprivate final Class _class;\n+    private final int _type;\n+\t\n+    private File _srcFile = null;\n+    private int _srcType = SRC_OTHER;\n+    private String[] _comments = null;\n+    private int _listIndex = -1;\n+\t\n+\tprotected NonPersistentMetaData(Class cls, MetaDataRepository repos, \n+        int type) {\n+\t\t_repos = repos;\n+\t\t_class = cls;\n+        _type = type;\n+\t}\n+\t\n+    /**\n+     * Owning repository.\n+     */\n+\tpublic MetaDataRepository getRepository() {\n+\t\treturn _repos;\n+\t}\n+\t\n+    /**\n+     * Persistence-aware type.\n+     */\n+\tpublic Class getDescribedType() {\n+\t\treturn _class;\n+\t}\n+\n+    /**\n+     * The type of metadata.\n+     */\n+    public int getType() {\n+        return _type;\n+    }\n+\t\n+    /**\n+     * The index in which this class was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public int getListingIndex() {\n+        return _listIndex;\n+    }\n+\n+    /**\n+     * The index in which this field was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public void setListingIndex(int index) {\n+        _listIndex = index;\n+    }\n+\n+    public File getSourceFile() {\n+        return _srcFile;\n+    }\n+\n+    public Object getSourceScope() {\n+        return null;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File file, int srcType) {\n+        _srcFile = file;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return _class.getName();\n+    }\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? ClassMetaData.EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+    \n+    public int compareTo(Object o) {\n+        if (o == this)\n+            return 0;\n+        if (!(o instanceof NonPersistentMetaData))\n+        \treturn 1;\n+        NonPersistentMetaData other = (NonPersistentMetaData) o;\n+        if (_type != other.getType())\n+            return _type - other.getType();\n+        return _class.getName().compareTo(other.getDescribedType().getName());\n+    }\n+}"},{"sha":"b5aa972b4fb87ff1a09254f3aa2ec68300d48be2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.math.BigDecimal;\r\n-\r\n-/**\r\n- * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\r\n- * @since 1.1.0\r\n- */\r\n-public class BigDecimalId\r\n-    extends OpenJPAId {\r\n-\r\n-    private final BigDecimal key;\r\n-\r\n-    public BigDecimalId(Class cls, String key) {\r\n-        this(cls, (key == null) ? null : new BigDecimal(key));\r\n-    }\r\n-\r\n-    public BigDecimalId(Class cls, BigDecimal key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigDecimalId(Class cls, BigDecimal key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigDecimal getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        if (key == null)\r\n-            return \"NULL\";\r\n-\r\n-        return key.toString();\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        if (key != null)\r\n-            return key.hashCode();\r\n-\r\n-        return 0;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId other) {\r\n-        if(key == null)\r\n-            return false;\r\n-\r\n-        return key.equals(other);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\n+ * @since 1.1.0\n+ */\n+public class BigDecimalId\n+    extends OpenJPAId {\n+\n+    private final BigDecimal key;\n+\n+    public BigDecimalId(Class cls, String key) {\n+        this(cls, (key == null) ? null : new BigDecimal(key));\n+    }\n+\n+    public BigDecimalId(Class cls, BigDecimal key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public BigDecimalId(Class cls, BigDecimal key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public BigDecimal getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return key;\n+    }\n+\n+    public String toString() {\n+        if (key == null)\n+            return \"NULL\";\n+\n+        return key.toString();\n+    }\n+\n+    protected int idHash() {\n+        if (key != null)\n+            return key.hashCode();\n+\n+        return 0;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId other) {\n+        if(key == null)\n+            return false;\n+\n+        return key.equals(other);\n+    }\n+}"},{"sha":"55a597610226c591557dba9cd68d6f1f66a83dd2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,75 +1,75 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.math.BigInteger;\r\n-\r\n-/**\r\n- * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\r\n- * @since 1.1.0\r\n- */\r\n-public class BigIntegerId\r\n-    extends OpenJPAId {\r\n-\r\n-    private final BigInteger key;\r\n-\r\n-    public BigIntegerId(Class cls, String key) {\r\n-        this(cls, (key == null) ? null : new BigInteger(key));\r\n-    }\r\n-\r\n-    public BigIntegerId(Class cls, BigInteger key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigIntegerId(Class cls, BigInteger key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigInteger getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        if (key == null)\r\n-            return \"NULL\";\r\n-\r\n-        return key.toString();\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        if (key != null)\r\n-            return key.hashCode();\r\n-\r\n-        return 0;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId other) {\r\n-        if (key == null)\r\n-            return false;\r\n-\r\n-        return key.equals(other);\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\n+ * @since 1.1.0\n+ */\n+public class BigIntegerId\n+    extends OpenJPAId {\n+\n+    private final BigInteger key;\n+\n+    public BigIntegerId(Class cls, String key) {\n+        this(cls, (key == null) ? null : new BigInteger(key));\n+    }\n+\n+    public BigIntegerId(Class cls, BigInteger key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public BigIntegerId(Class cls, BigInteger key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public BigInteger getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return key;\n+    }\n+\n+    public String toString() {\n+        if (key == null)\n+            return \"NULL\";\n+\n+        return key.toString();\n+    }\n+\n+    protected int idHash() {\n+        if (key != null)\n+            return key.hashCode();\n+\n+        return 0;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId other) {\n+        if (key == null)\n+            return false;\n+\n+        return key.equals(other);\n+    }\n+\n+}"},{"sha":"16168945faa8b8f594bb874de7ee8cccf0e09631","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.security.AccessController;\r\n-import java.security.PrivilegedActionException;\r\n-import java.lang.reflect.Constructor;\r\n-\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCClassLoader;\r\n-\r\n-/**\r\n- * Utility methods when generating classes, including at runtime.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class GeneratedClasses {\r\n-\r\n-    /**\r\n-     * Return the more derived loader of the class laoders for the given \r\n-     * classes.\r\n-     */\r\n-    public static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\r\n-        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\r\n-            J2DoPrivHelper.getClassLoaderAction(c1));\r\n-        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\r\n-            J2DoPrivHelper.getClassLoaderAction(c2));\r\n-        if (l1 == l2)\r\n-            return l1;\r\n-        if (l1 == null)\r\n-            return l2;\r\n-        if (l2 == null)\r\n-            return l1;\r\n-\r\n-        if(canLoad(l1, c2)) {\r\n-            return l1;\r\n-        }\r\n-        return l2;\r\n-    }\r\n-\r\n-    /**\r\n-     * Load the class represented by the given bytecode.\r\n-     */\r\n-    public static Class loadBCClass(BCClass bc, ClassLoader loader) {\r\n-        BCClassLoader bcloader = (BCClassLoader) AccessController\r\n-                .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(bc\r\n-                        .getProject(), loader));\r\n-        try {\r\n-            Class c = Class.forName(bc.getName(), true, bcloader);\r\n-            bc.getProject().clear();\r\n-            return c;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(bc.getName()).setCause(t);\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return true if the given loader will load the same version of a given \r\n-     * class.  \r\n-     * \r\n-     * @param loader Classloader to use.\r\n-     * @param clazz  Expected class. \r\n-     * @return true if loader.load(clazz.getName()) == clazz. Otherwise false.\r\n-     */\r\n-    private static boolean canLoad(ClassLoader loader, Class clazz) {\r\n-        Class loaded = null;\r\n-        try {\r\n-            loaded = loader.loadClass(clazz.getName());\r\n-        } catch (ClassNotFoundException e) {\r\n-            // Rely on caller to handle return value = false.\r\n-        }\r\n-        return clazz == loaded;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.lang.reflect.Constructor;\n+\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCClassLoader;\n+\n+/**\n+ * Utility methods when generating classes, including at runtime.\n+ *\n+ * @since 1.0.0\n+ */\n+public class GeneratedClasses {\n+\n+    /**\n+     * Return the more derived loader of the class laoders for the given \n+     * classes.\n+     */\n+    public static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\n+        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\n+            J2DoPrivHelper.getClassLoaderAction(c1));\n+        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\n+            J2DoPrivHelper.getClassLoaderAction(c2));\n+        if (l1 == l2)\n+            return l1;\n+        if (l1 == null)\n+            return l2;\n+        if (l2 == null)\n+            return l1;\n+\n+        if(canLoad(l1, c2)) {\n+            return l1;\n+        }\n+        return l2;\n+    }\n+\n+    /**\n+     * Load the class represented by the given bytecode.\n+     */\n+    public static Class loadBCClass(BCClass bc, ClassLoader loader) {\n+        BCClassLoader bcloader = (BCClassLoader) AccessController\n+                .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(bc\n+                        .getProject(), loader));\n+        try {\n+            Class c = Class.forName(bc.getName(), true, bcloader);\n+            bc.getProject().clear();\n+            return c;\n+        } catch (Throwable t) {\n+            throw new GeneralException(bc.getName()).setCause(t);\n+        }\n+    }\n+    \n+    /**\n+     * Return true if the given loader will load the same version of a given \n+     * class.  \n+     * \n+     * @param loader Classloader to use.\n+     * @param clazz  Expected class. \n+     * @return true if loader.load(clazz.getName()) == clazz. Otherwise false.\n+     */\n+    private static boolean canLoad(ClassLoader loader, Class clazz) {\n+        Class loaded = null;\n+        try {\n+            loaded = loader.loadClass(clazz.getName());\n+        } catch (ClassNotFoundException e) {\n+            // Rely on caller to handle return value = false.\n+        }\n+        return clazz == loaded;\n+    }\n+}"},{"sha":"d3ba1e8b12a90b6fb0c5077d30569105b1850cfb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,115 +1,115 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Repository of store-specific facade classes. This is used by facade \r\n- * implementations to wrap store-specific components without knowing \r\n- * about all possible back-ends.\r\n- */\r\n-public class StoreFacadeTypeRegistry {\r\n-\r\n-    private Map _impls = new ConcurrentHashMap();\r\n-\r\n-    /**\r\n-     * Register a facade implementation.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the class implementing the facade\r\n-     */\r\n-    public void registerImplementation(Class facadeType, Class storeType, \r\n-        Class implType) {\r\n-        Object key = (storeType == null) ? (Object) facadeType \r\n-            : new Key(facadeType, storeType);\r\n-        _impls.put(key, implType);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return the implementation for the given facade and store.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the registered implementor\r\n-     */\r\n-    public Class getImplementation(Class facadeType, Class storeType) {\r\n-        // traverse store type hierarchy to store manager to find most specific\r\n-        // store avaialble\r\n-        Class impl;\r\n-        for (; storeType != null && storeType != StoreManager.class; \r\n-            storeType = storeType.getSuperclass()) {\r\n-            impl = (Class) _impls.get(new Key(facadeType, storeType));\r\n-            if (impl != null)\r\n-                return impl; \r\n-        }    \r\n-        return (Class) _impls.get(facadeType);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return the implementation for the given facade and store. If no \r\n-     * registered implementation is found then returns the given default type\r\n-     * provided it the facade type is assignable from the deafult type.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the registered implementor\r\n-     * @param defaultType class if no registered implementation is available.\r\n-     */\r\n-    public Class getImplementation(Class facadeType, Class storeType, \r\n-    \tClass defaultType) {\r\n-    \tClass result = getImplementation(facadeType, storeType);\r\n-    \tif (result == null)\r\n-    \t\tresult = defaultType;\r\n-    \tif (facadeType == null || !facadeType.isAssignableFrom(result))\r\n-    \t\tthrow new InternalException();\r\n-    \treturn result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Lookup key for facade+store hash.\r\n-     */\r\n-    private static class Key {\r\n-        public final Class _facadeType;\r\n-        public final Class _storeType;\r\n-\r\n-        public Key(Class facadeType, Class storeType) {\r\n-            _facadeType = facadeType;\r\n-            _storeType = storeType;\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            return _facadeType.hashCode() ^ _storeType.hashCode();\r\n-        }\r\n-\r\n-        public boolean equals(Object other) {\r\n-            if (other == this)\r\n-                return true;\r\n-            Key k = (Key) other;\r\n-            return _facadeType == k._facadeType && _storeType == k._storeType;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Repository of store-specific facade classes. This is used by facade \n+ * implementations to wrap store-specific components without knowing \n+ * about all possible back-ends.\n+ */\n+public class StoreFacadeTypeRegistry {\n+\n+    private Map _impls = new ConcurrentHashMap();\n+\n+    /**\n+     * Register a facade implementation.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the class implementing the facade\n+     */\n+    public void registerImplementation(Class facadeType, Class storeType, \n+        Class implType) {\n+        Object key = (storeType == null) ? (Object) facadeType \n+            : new Key(facadeType, storeType);\n+        _impls.put(key, implType);\n+    }\n+    \n+    /**\n+     * Return the implementation for the given facade and store.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the registered implementor\n+     */\n+    public Class getImplementation(Class facadeType, Class storeType) {\n+        // traverse store type hierarchy to store manager to find most specific\n+        // store avaialble\n+        Class impl;\n+        for (; storeType != null && storeType != StoreManager.class; \n+            storeType = storeType.getSuperclass()) {\n+            impl = (Class) _impls.get(new Key(facadeType, storeType));\n+            if (impl != null)\n+                return impl; \n+        }    \n+        return (Class) _impls.get(facadeType);\n+    }\n+    \n+    /**\n+     * Return the implementation for the given facade and store. If no \n+     * registered implementation is found then returns the given default type\n+     * provided it the facade type is assignable from the deafult type.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the registered implementor\n+     * @param defaultType class if no registered implementation is available.\n+     */\n+    public Class getImplementation(Class facadeType, Class storeType, \n+    \tClass defaultType) {\n+    \tClass result = getImplementation(facadeType, storeType);\n+    \tif (result == null)\n+    \t\tresult = defaultType;\n+    \tif (facadeType == null || !facadeType.isAssignableFrom(result))\n+    \t\tthrow new InternalException();\n+    \treturn result;\n+    }\n+\n+    /**\n+     * Lookup key for facade+store hash.\n+     */\n+    private static class Key {\n+        public final Class _facadeType;\n+        public final Class _storeType;\n+\n+        public Key(Class facadeType, Class storeType) {\n+            _facadeType = facadeType;\n+            _storeType = storeType;\n+        }\n+\n+        public int hashCode() {\n+            return _facadeType.hashCode() ^ _storeType.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            Key k = (Key) other;\n+            return _facadeType == k._facadeType && _storeType == k._storeType;\n+        }\n+    }\n+}"},{"sha":"e83a9aa3ea0ab2af91e8a01b31f5697e30aeb62d","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,57 +1,57 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Test class for build transformation performed by WASManagedRuntime.\r\n- *\r\n- */\r\n-public class TestWASManagedRuntime extends TestCase {\r\n-\r\n-    /**\r\n-     * This test will verify that the WASManagedRuntime$WASSynchronization\r\n-     * class was properly modified by the maven build process (reference\r\n-     * the top level pom.xml).  This testcase will not execute properly\r\n-     * within Eclipse since the Eclipse target directory (probably) hasn't\r\n-     * been modified via the maven build.\r\n-     *\r\n-     * @throws ClassNotFoundException\r\n-     * @author Michael Dick\r\n-     */\r\n-    public void testInterfaceAdded() throws ClassNotFoundException {\r\n-\r\n-        String msg = null;\r\n-\r\n-        try {\r\n-            Class.forName(WASManagedRuntime.CLASS);\r\n-            fail(\"expected an exception to be thrown\");\r\n-        } catch (NoClassDefFoundError e) {\r\n-            msg = e.getMessage();\r\n-        }\r\n-        String interfaceName = Strings.\r\n-            getClassName(WASManagedRuntime.INTERFACE);\r\n-        assertTrue(\"message should have contained \"\r\n-            + interfaceName + \", but was '\" + msg + \"'\",\r\n-            msg.indexOf(interfaceName) != -1);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.ee;\n+\n+import junit.framework.TestCase;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Test class for build transformation performed by WASManagedRuntime.\n+ *\n+ */\n+public class TestWASManagedRuntime extends TestCase {\n+\n+    /**\n+     * This test will verify that the WASManagedRuntime$WASSynchronization\n+     * class was properly modified by the maven build process (reference\n+     * the top level pom.xml).  This testcase will not execute properly\n+     * within Eclipse since the Eclipse target directory (probably) hasn't\n+     * been modified via the maven build.\n+     *\n+     * @throws ClassNotFoundException\n+     * @author Michael Dick\n+     */\n+    public void testInterfaceAdded() throws ClassNotFoundException {\n+\n+        String msg = null;\n+\n+        try {\n+            Class.forName(WASManagedRuntime.CLASS);\n+            fail(\"expected an exception to be thrown\");\n+        } catch (NoClassDefFoundError e) {\n+            msg = e.getMessage();\n+        }\n+        String interfaceName = Strings.\n+            getClassName(WASManagedRuntime.INTERFACE);\n+        assertTrue(\"message should have contained \"\n+            + interfaceName + \", but was '\" + msg + \"'\",\n+            msg.indexOf(interfaceName) != -1);\n+    }\n+}"},{"sha":"82a3edcf6f3963bc8dd2b1f6e8ba431593b76e2c","filename":"openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-import java.lang.reflect.AnnotatedElement;\r\n-import java.security.PrivilegedAction;\r\n-\r\n-/**\r\n- * Helper class to obtain the Privilege(Exception)Action object to perform\r\n- * Java 2 doPrivilege security sensitive function call in the following\r\n- * methods:\r\n- * <ul>\r\n- * <li>AnnotatedElement.getAnnotations\r\n- * <li>AnnotatedElement.getDeclaredAnnotations\r\n- * <li>AnnotatedElement.isAnnotationPresent\r\n- * </ul>\r\n- *\r\n- * @author Albert Lee\r\n- */\r\n-\r\n-public abstract class J2DoPriv5Helper extends J2DoPrivHelper {\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for AnnotatedElement.getAnnotations().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Annotation[]\r\n-     */\r\n-    public static final PrivilegedAction getAnnotationsAction(\r\n-        final AnnotatedElement element) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.getAnnotations();\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for\r\n-     *   AnnotatedElement.getDeclaredAnnotations().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Annotation[]\r\n-     */\r\n-    public static final PrivilegedAction getDeclaredAnnotationsAction(\r\n-        final AnnotatedElement element) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.getDeclaredAnnotations();\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for\r\n-     *   AnnotatedElement.isAnnotationPresent().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Boolean\r\n-     */\r\n-    public static final PrivilegedAction isAnnotationPresentAction(\r\n-        final AnnotatedElement element, final Class annotationClazz) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.isAnnotationPresent(annotationClazz)\r\n-                    ? Boolean.TRUE : Boolean.FALSE;\r\n-            }\r\n-        };\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import java.lang.reflect.AnnotatedElement;\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * Helper class to obtain the Privilege(Exception)Action object to perform\n+ * Java 2 doPrivilege security sensitive function call in the following\n+ * methods:\n+ * <ul>\n+ * <li>AnnotatedElement.getAnnotations\n+ * <li>AnnotatedElement.getDeclaredAnnotations\n+ * <li>AnnotatedElement.isAnnotationPresent\n+ * </ul>\n+ *\n+ * @author Albert Lee\n+ */\n+\n+public abstract class J2DoPriv5Helper extends J2DoPrivHelper {\n+\n+    /**\n+     * Return a PrivilegeAction object for AnnotatedElement.getAnnotations().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Annotation[]\n+     */\n+    public static final PrivilegedAction getAnnotationsAction(\n+        final AnnotatedElement element) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.getAnnotations();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a PrivilegeAction object for\n+     *   AnnotatedElement.getDeclaredAnnotations().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Annotation[]\n+     */\n+    public static final PrivilegedAction getDeclaredAnnotationsAction(\n+        final AnnotatedElement element) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.getDeclaredAnnotations();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a PrivilegeAction object for\n+     *   AnnotatedElement.isAnnotationPresent().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Boolean\n+     */\n+    public static final PrivilegedAction isAnnotationPresentAction(\n+        final AnnotatedElement element, final Class annotationClazz) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.isAnnotationPresent(annotationClazz)\n+                    ? Boolean.TRUE : Boolean.FALSE;\n+            }\n+        };\n+    }\n+}"},{"sha":"94b98bf8e5253d78219852b530e1777a6be16662","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf;\r\n-/**\r\n- * Exception recognized by {@link ProductDerivations bootstrap} framework.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * @since 0.4.1.4\r\n- *\r\n- */\r\n-public class BootstrapException extends RuntimeException {\r\n-\r\n-\tprivate boolean _fatal = false;\r\n-\t\r\n-\tpublic BootstrapException() {\r\n-\t\tsuper();\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(String message) {\r\n-\t\tsuper(message);\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(Throwable cause) {\r\n-\t\tsuper(cause);\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(String message, Throwable cause) {\r\n-\t\tsuper(message, cause);\r\n-\t}\r\n-\t\r\n-\tpublic BootstrapException setFatal(boolean fatal) {\r\n-\t\t_fatal = fatal;\r\n-\t\treturn this;\r\n-\t}\r\n-\t\r\n-\tpublic boolean isFatal() {\r\n-\t\treturn _fatal;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf;\n+/**\n+ * Exception recognized by {@link ProductDerivations bootstrap} framework.\n+ * \n+ * @author Pinaki Poddar\n+ * @since 0.4.1.4\n+ *\n+ */\n+public class BootstrapException extends RuntimeException {\n+\n+\tprivate boolean _fatal = false;\n+\t\n+\tpublic BootstrapException() {\n+\t\tsuper();\n+\t}\n+\n+\tpublic BootstrapException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\tpublic BootstrapException(Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n+\n+\tpublic BootstrapException(String message, Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+\t\n+\tpublic BootstrapException setFatal(boolean fatal) {\n+\t\t_fatal = fatal;\n+\t\treturn this;\n+\t}\n+\t\n+\tpublic boolean isFatal() {\n+\t\treturn _fatal;\n+\t}\n+}"},{"sha":"e40e160910ef01d40326a0b10f353465a76c7eb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"modified","additions":145,"deletions":145,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,145 +1,145 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-/**\r\n- * <p>Performs a breadth-first walk of a given {@link Graph},\r\n- * notifying visitors as it sees each node.  See the BFS algorithm\r\n- * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n- * Rivest.</p>\r\n- * <p/>\r\n- * <p>Each {@link GraphVisitor} will be notified when a node\r\n- * is colored black (nodeVisited), edge seen (edgeVisited),\r\n- * and a node is seen for the first time, i.e. colored gray (nodeSeen).</p>\r\n- *\r\n- * @author Steve Kim\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class BreadthFirstWalk {\r\n-\r\n-    private final Graph _graph;\r\n-    private final Set _visitors = new HashSet();\r\n-    private final List _queue = new LinkedList();\r\n-    private final Map _nodeInfo = new HashMap();\r\n-\r\n-    public BreadthFirstWalk(Graph graph) {\r\n-        _graph = graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Begins the breadth first traversal.\r\n-     */\r\n-    public void walk() {\r\n-        _queue.clear();\r\n-        _nodeInfo.clear();\r\n-\r\n-        Collection nodes = _graph.getNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            _nodeInfo.put(itr.next(), new NodeInfo());\r\n-\r\n-        Object node;\r\n-        NodeInfo info;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            if (info.color == NodeInfo.COLOR_WHITE)\r\n-                enqueue(node, info);\r\n-            processQueue();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Process the queue to see what data needs to be obtained.\r\n-     */\r\n-    private void processQueue() {\r\n-        Object node;\r\n-        Object other;\r\n-        NodeInfo info;\r\n-        NodeInfo otherInfo;\r\n-        Collection edges;\r\n-        Edge edge;\r\n-        while (_queue.size() > 0) {\r\n-            node = _queue.remove(0);\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            visit(node, info);\r\n-\r\n-            edges = _graph.getEdgesFrom(node);\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-                edge = (Edge) itr.next();\r\n-                edgeVisited(edge);\r\n-                other = edge.getOther(node);\r\n-                otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n-                if (otherInfo.color == NodeInfo.COLOR_WHITE)\r\n-                    enqueue(other, otherInfo);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Push the given node onto the queue to be processed.\r\n-     * Notify visitors.\r\n-     */\r\n-    protected void enqueue(Object node, NodeInfo info) {\r\n-        _queue.add(node);\r\n-        info.color = NodeInfo.COLOR_GRAY;\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).nodeSeen(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * Visit the node.  Mark the node black and notify visitors.\r\n-     */\r\n-    protected void visit(Object node, NodeInfo info) {\r\n-        info.color = NodeInfo.COLOR_BLACK;\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).nodeVisited(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * An edge is seen.  Notify visitors.\r\n-     */\r\n-    protected void edgeVisited(Edge edge) {\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).edgeVisited(edge);\r\n-    }\r\n-\r\n-    /**\r\n-     * add a {@link GraphVisitor} to be notified during breadth first search.\r\n-     */\r\n-    public void addGraphVisitor(GraphVisitor visitor) {\r\n-        _visitors.add(visitor);\r\n-    }\r\n-\r\n-    /**\r\n-     * remove a given {@link GraphVisitor} from the listener set.\r\n-     */\r\n-    public void removeGraphVisitor(GraphVisitor visitor) {\r\n-        _visitors.remove(visitor);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>Performs a breadth-first walk of a given {@link Graph},\n+ * notifying visitors as it sees each node.  See the BFS algorithm\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\n+ * Rivest.</p>\n+ * <p/>\n+ * <p>Each {@link GraphVisitor} will be notified when a node\n+ * is colored black (nodeVisited), edge seen (edgeVisited),\n+ * and a node is seen for the first time, i.e. colored gray (nodeSeen).</p>\n+ *\n+ * @author Steve Kim\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class BreadthFirstWalk {\n+\n+    private final Graph _graph;\n+    private final Set _visitors = new HashSet();\n+    private final List _queue = new LinkedList();\n+    private final Map _nodeInfo = new HashMap();\n+\n+    public BreadthFirstWalk(Graph graph) {\n+        _graph = graph;\n+    }\n+\n+    /**\n+     * Begins the breadth first traversal.\n+     */\n+    public void walk() {\n+        _queue.clear();\n+        _nodeInfo.clear();\n+\n+        Collection nodes = _graph.getNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            _nodeInfo.put(itr.next(), new NodeInfo());\n+\n+        Object node;\n+        NodeInfo info;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            if (info.color == NodeInfo.COLOR_WHITE)\n+                enqueue(node, info);\n+            processQueue();\n+        }\n+    }\n+\n+    /**\n+     * Process the queue to see what data needs to be obtained.\n+     */\n+    private void processQueue() {\n+        Object node;\n+        Object other;\n+        NodeInfo info;\n+        NodeInfo otherInfo;\n+        Collection edges;\n+        Edge edge;\n+        while (_queue.size() > 0) {\n+            node = _queue.remove(0);\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            visit(node, info);\n+\n+            edges = _graph.getEdgesFrom(node);\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+                edge = (Edge) itr.next();\n+                edgeVisited(edge);\n+                other = edge.getOther(node);\n+                otherInfo = (NodeInfo) _nodeInfo.get(other);\n+                if (otherInfo.color == NodeInfo.COLOR_WHITE)\n+                    enqueue(other, otherInfo);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Push the given node onto the queue to be processed.\n+     * Notify visitors.\n+     */\n+    protected void enqueue(Object node, NodeInfo info) {\n+        _queue.add(node);\n+        info.color = NodeInfo.COLOR_GRAY;\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).nodeSeen(node);\n+    }\n+\n+    /**\n+     * Visit the node.  Mark the node black and notify visitors.\n+     */\n+    protected void visit(Object node, NodeInfo info) {\n+        info.color = NodeInfo.COLOR_BLACK;\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).nodeVisited(node);\n+    }\n+\n+    /**\n+     * An edge is seen.  Notify visitors.\n+     */\n+    protected void edgeVisited(Edge edge) {\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).edgeVisited(edge);\n+    }\n+\n+    /**\n+     * add a {@link GraphVisitor} to be notified during breadth first search.\n+     */\n+    public void addGraphVisitor(GraphVisitor visitor) {\n+        _visitors.add(visitor);\n+    }\n+\n+    /**\n+     * remove a given {@link GraphVisitor} from the listener set.\n+     */\n+    public void removeGraphVisitor(GraphVisitor visitor) {\n+        _visitors.remove(visitor);\n+    }\n+}"},{"sha":"f1f5001cf0da8c0c7d9a01cd62bb96df94a7f054","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":358,"deletions":358,"changes":716,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,358 +1,358 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Comparator;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * <p>Performs a depth-first analysis of a given {@link Graph}, caching\r\n- * information about the graph's nodes and edges.  See the DFS algorithm\r\n- * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n- * Rivest.  The algorithm has been modified to group sibling nodes without\r\n- * connections together during the topological sort.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class DepthFirstAnalysis {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DepthFirstAnalysis.class);\r\n-\r\n-    private final Graph _graph;\r\n-    private final Map _nodeInfo = new HashMap();\r\n-    private Comparator _comp;\r\n-\r\n-    /**\r\n-     * Constructor.  Performs the analysis on the given graph and caches\r\n-     * the resulting information.\r\n-     */\r\n-    public DepthFirstAnalysis(Graph graph) {\r\n-        _graph = graph;\r\n-\r\n-        // initialize node infos\r\n-        Collection nodes = graph.getNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            _nodeInfo.put(itr.next(), new NodeInfo());\r\n-\r\n-        // visit all nodes -- see intro to algo's book\r\n-        NodeInfo info;\r\n-        Object node;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            if (info.color == NodeInfo.COLOR_WHITE)\r\n-                visit(graph, node, info, 0, new LinkedList());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Visit a node.  See Introduction to Algorithms book for details.\r\n-     */\r\n-    private int visit(Graph graph, Object node, NodeInfo info, int time, \r\n-        List path) {\r\n-        // discover node\r\n-        info.color = NodeInfo.COLOR_GRAY;\r\n-\r\n-        // explore all vertices from that node depth first\r\n-        Collection edges = graph.getEdgesFrom(node);\r\n-        Edge edge;\r\n-        Object other;\r\n-        NodeInfo otherInfo;\r\n-        int maxChildTime = time - 1;\r\n-        int childTime;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            other = edge.getOther(node);\r\n-            otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n-            if (otherInfo.color == NodeInfo.COLOR_WHITE) {\r\n-                // undiscovered node; recurse into it\r\n-                path.add(edge);\r\n-                childTime = visit(graph, other, otherInfo, time, path);\r\n-                path.remove(edge);\r\n-                edge.setType(Edge.TYPE_TREE);\r\n-            } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\r\n-                childTime = -1;\r\n-                edge.setType(Edge.TYPE_BACK);\r\n-                // calculate the cycle including this edge\r\n-                edge.setCycle(cycleForBackEdge(edge, path));\r\n-            } else {\r\n-                childTime = otherInfo.finished;\r\n-                edge.setType(Edge.TYPE_FORWARD);\r\n-                // find the cycle including this edge\r\n-                List cycle = new LinkedList();\r\n-                cycle.add(edge);\r\n-                if (cycleForForwardEdge(graph, other, node, cycle)) {\r\n-                    edge.setCycle(cycle);\r\n-                }\r\n-            }\r\n-            maxChildTime = Math.max(maxChildTime, childTime);\r\n-        }\r\n-\r\n-        // finished with node\r\n-        info.color = NodeInfo.COLOR_BLACK;\r\n-        info.finished = maxChildTime + 1;\r\n-        return info.finished;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the comparator that should be used for ordering groups of nodes\r\n-     * with the same dependencies.\r\n-     */\r\n-    public void setNodeComparator(Comparator comp) {\r\n-        _comp = comp;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the nodes in topologically-sorted order.  This is often used\r\n-     * to order dependencies.  If each graph edge (u, v) represents a\r\n-     * dependency of v on u, then this method will return the nodes in the\r\n-     * order that they should be evaluated to satisfy all dependencies.  Of\r\n-     * course, if the graph is cyclic (has back edges), then no such ordering\r\n-     * is possible, though this method will still return the correct order\r\n-     * as if edges creating the cycles did not exist.\r\n-     */\r\n-    public List getSortedNodes() {\r\n-        Map.Entry[] entries = (Map.Entry[]) _nodeInfo.entrySet().\r\n-            toArray(new Map.Entry[_nodeInfo.size()]);\r\n-        Arrays.sort(entries, new NodeInfoComparator(_comp));\r\n-        return new NodeList(entries);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all edges of the given type.  This method can be used to\r\n-     * discover all edges that cause cycles in the graph by passing it\r\n-     * the {@link Edge#TYPE_BACK} or {@link Edge#TYPE_FORWARD} edge type.\r\n-     */\r\n-    public Collection getEdges(int type) {\r\n-        Collection typed = null;\r\n-        Edge edge;\r\n-        Object node;\r\n-        for (Iterator nodes = _graph.getNodes().iterator(); nodes.hasNext();) {\r\n-            node = nodes.next();\r\n-            for (Iterator itr = _graph.getEdgesFrom(node).iterator();\r\n-                itr.hasNext();) {\r\n-                edge = (Edge) itr.next();\r\n-                if (edge.getType() == type) {\r\n-                    if (typed == null)\r\n-                        typed = new ArrayList();\r\n-                    typed.add(edge);\r\n-                }\r\n-            }\r\n-        }\r\n-        return (typed == null) ? Collections.EMPTY_LIST : typed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the logical time that the given node was finished in\r\n-     * the graph walk, or -1 if the node is not part of the graph.\r\n-     */\r\n-    public int getFinishedTime(Object node) {\r\n-        NodeInfo info = (NodeInfo) _nodeInfo.get(node);\r\n-        if (info == null)\r\n-            return -1;\r\n-        return info.finished;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a list of graph edges forming a cycle. The cycle begins \r\n-     * with a type {@link Edge#TYPE_BACK} edge.\r\n-     * @param backEdge \"Starting\" edge of the cycle\r\n-     * @param path Continuous list of graph edges, may be null\r\n-     * @param pos Index of the first edge in path continuing the cycle\r\n-     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n-     */\r\n-    private List buildCycle(Edge backEdge, List path, int pos) {\r\n-        int length = path != null ? path.size() - pos : 0;\r\n-        List cycle = new ArrayList(length + 1);\r\n-        cycle.add(0, backEdge);\r\n-        for (int i = 0; i < length; i++) {\r\n-            cycle.add(i + 1, path.get(pos + i));\r\n-        }\r\n-        return cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Computes the list of edges forming a cycle. The cycle always exists for\r\n-     * a type {@link Edge#TYPE_BACK} edge. This method should only be called \r\n-     * for type {@link Edge#TYPE_BACK} edges. \r\n-     * @param edge Edge where the cycle was detected\r\n-     * @param path Path consisting of edges to the edge's starting node\r\n-     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n-     */\r\n-    private List cycleForBackEdge(Edge edge, List path) {\r\n-        if (edge.getType() != Edge.TYPE_BACK) {\r\n-            return null;\r\n-        }\r\n-        \r\n-        List cycle;\r\n-        int pos = 0;\r\n-        if (path != null && !edge.getFrom().equals(edge.getTo())) {\r\n-            // Not a single edge loop\r\n-            pos = findNodeInPath(edge.getTo(), path);\r\n-            assert (pos >= 0): _loc.get(\"node-not-on-path\", edge, edge.getTo()); \r\n-        } else {\r\n-            assert (edge.getFrom().equals(edge.getTo())): \r\n-                _loc.get(\"edge-no-loop\", edge).getMessage();\r\n-            path = null;\r\n-        }\r\n-        cycle = buildCycle(edge, path, pos); \r\n-        assert (cycle != null): _loc.get(\"cycle-null\", edge).getMessage();\r\n-        return cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Computes the cycle of edges including node cycleTo. The cycle must not \r\n-     * necessarily exist. This method should only be called for type \r\n-     * {@link Edge#TYPE_FORWARD} edges.\r\n-     * @param graph Graph\r\n-     * @param node Current node\r\n-     * @param cycleTo End node for loop\r\n-     * @param path Path from loop end node to current node\r\n-     * @return True if a cycle has been found. The cycle will be contained in\r\n-     * the <code>path</code> parameter.\r\n-     */\r\n-    private boolean cycleForForwardEdge(Graph graph, Object node,\r\n-        Object cycleTo, List path) {                   \r\n-        boolean found = false;\r\n-        Collection edges = graph.getEdgesFrom(node);\r\n-        for (Iterator itr = edges.iterator(); !found && itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            Object other = edge.getOther(node);\r\n-            // Single edge loops are ignored\r\n-            if (!node.equals(other)) {\r\n-                if (other.equals(cycleTo)) {\r\n-                    // Cycle complete\r\n-                    path.add(edge);\r\n-                    found = true;\r\n-                } else if (!path.contains(edge)){\r\n-                    // Walk this edge\r\n-                    path.add(edge);\r\n-                    found = cycleForForwardEdge(graph, other, cycleTo, path);\r\n-                    if (!found) {\r\n-                        // Remove edge again\r\n-                        path.remove(edge);                    \r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-        return found;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Finds the position of the edge starting from a particular node in the \r\n-     * continuous list of edges.\r\n-     * @param node Node on the cycle.\r\n-     * @param path Continuous list of graph edges.\r\n-     * @return Edge index if found, -1 otherwise.\r\n-     */\r\n-    private int findNodeInPath(Object node, List path) {\r\n-        int pos = -1;\r\n-        if (path != null) {\r\n-            for (int i = 0; i < path.size(); i++) {\r\n-                if (((Edge)path.get(i)).getFrom().equals(node)) {\r\n-                    pos = i;\r\n-                }\r\n-            }\r\n-        }\r\n-        return pos;\r\n-    }\r\n-\r\n-    /**\r\n-     * Test, if the analysis didn't find cycles.\r\n-     */\r\n-    public boolean hasNoCycles() {\r\n-        // a) there must not be any back edges\r\n-        if (!getEdges(Edge.TYPE_BACK).isEmpty()) {\r\n-            return false;\r\n-        }\r\n-        // b) there might be forward edges\r\n-        // make sure these don't indicate cycles\r\n-        Collection edges = getEdges(Edge.TYPE_FORWARD);\r\n-        if (!edges.isEmpty()) {\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-                Edge edge = (Edge) itr.next();\r\n-                if (edge.getCycle() != null)  {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Comparator for toplogically sorting entries in the node info map.\r\n-     */\r\n-    private static class NodeInfoComparator\r\n-        implements Comparator {\r\n-\r\n-        private final Comparator _subComp;\r\n-\r\n-        public NodeInfoComparator(Comparator subComp) {\r\n-            _subComp = subComp;\r\n-        }\r\n-\r\n-        public int compare(Object o1, Object o2) {\r\n-            Map.Entry e1 = (Map.Entry) o1;\r\n-            Map.Entry e2 = (Map.Entry) o2;\r\n-            NodeInfo n1 = (NodeInfo) e1.getValue();\r\n-            NodeInfo n2 = (NodeInfo) e2.getValue();\r\n-\r\n-            // sort by finished order\r\n-            int ret = n1.finished - n2.finished;\r\n-            if (ret == 0 && _subComp != null)\r\n-                ret = _subComp.compare(e1.getKey(), e2.getKey());\r\n-            return ret;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     *\tList of node-to-nodeinfo entries that exposes just the nodes.\r\n-     */\r\n-    private static class NodeList\r\n-        extends AbstractList {\r\n-\r\n-        private final Map.Entry[] _entries;\r\n-\r\n-        public NodeList(Map.Entry[] entries) {\r\n-            _entries = entries;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            return _entries[idx].getKey();\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _entries.length;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Performs a depth-first analysis of a given {@link Graph}, caching\n+ * information about the graph's nodes and edges.  See the DFS algorithm\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\n+ * Rivest.  The algorithm has been modified to group sibling nodes without\n+ * connections together during the topological sort.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class DepthFirstAnalysis {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DepthFirstAnalysis.class);\n+\n+    private final Graph _graph;\n+    private final Map _nodeInfo = new HashMap();\n+    private Comparator _comp;\n+\n+    /**\n+     * Constructor.  Performs the analysis on the given graph and caches\n+     * the resulting information.\n+     */\n+    public DepthFirstAnalysis(Graph graph) {\n+        _graph = graph;\n+\n+        // initialize node infos\n+        Collection nodes = graph.getNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            _nodeInfo.put(itr.next(), new NodeInfo());\n+\n+        // visit all nodes -- see intro to algo's book\n+        NodeInfo info;\n+        Object node;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            if (info.color == NodeInfo.COLOR_WHITE)\n+                visit(graph, node, info, 0, new LinkedList());\n+        }\n+    }\n+\n+    /**\n+     * Visit a node.  See Introduction to Algorithms book for details.\n+     */\n+    private int visit(Graph graph, Object node, NodeInfo info, int time, \n+        List path) {\n+        // discover node\n+        info.color = NodeInfo.COLOR_GRAY;\n+\n+        // explore all vertices from that node depth first\n+        Collection edges = graph.getEdgesFrom(node);\n+        Edge edge;\n+        Object other;\n+        NodeInfo otherInfo;\n+        int maxChildTime = time - 1;\n+        int childTime;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            other = edge.getOther(node);\n+            otherInfo = (NodeInfo) _nodeInfo.get(other);\n+            if (otherInfo.color == NodeInfo.COLOR_WHITE) {\n+                // undiscovered node; recurse into it\n+                path.add(edge);\n+                childTime = visit(graph, other, otherInfo, time, path);\n+                path.remove(edge);\n+                edge.setType(Edge.TYPE_TREE);\n+            } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\n+                childTime = -1;\n+                edge.setType(Edge.TYPE_BACK);\n+                // calculate the cycle including this edge\n+                edge.setCycle(cycleForBackEdge(edge, path));\n+            } else {\n+                childTime = otherInfo.finished;\n+                edge.setType(Edge.TYPE_FORWARD);\n+                // find the cycle including this edge\n+                List cycle = new LinkedList();\n+                cycle.add(edge);\n+                if (cycleForForwardEdge(graph, other, node, cycle)) {\n+                    edge.setCycle(cycle);\n+                }\n+            }\n+            maxChildTime = Math.max(maxChildTime, childTime);\n+        }\n+\n+        // finished with node\n+        info.color = NodeInfo.COLOR_BLACK;\n+        info.finished = maxChildTime + 1;\n+        return info.finished;\n+    }\n+\n+    /**\n+     * Set the comparator that should be used for ordering groups of nodes\n+     * with the same dependencies.\n+     */\n+    public void setNodeComparator(Comparator comp) {\n+        _comp = comp;\n+    }\n+\n+    /**\n+     * Return the nodes in topologically-sorted order.  This is often used\n+     * to order dependencies.  If each graph edge (u, v) represents a\n+     * dependency of v on u, then this method will return the nodes in the\n+     * order that they should be evaluated to satisfy all dependencies.  Of\n+     * course, if the graph is cyclic (has back edges), then no such ordering\n+     * is possible, though this method will still return the correct order\n+     * as if edges creating the cycles did not exist.\n+     */\n+    public List getSortedNodes() {\n+        Map.Entry[] entries = (Map.Entry[]) _nodeInfo.entrySet().\n+            toArray(new Map.Entry[_nodeInfo.size()]);\n+        Arrays.sort(entries, new NodeInfoComparator(_comp));\n+        return new NodeList(entries);\n+    }\n+\n+    /**\n+     * Return all edges of the given type.  This method can be used to\n+     * discover all edges that cause cycles in the graph by passing it\n+     * the {@link Edge#TYPE_BACK} or {@link Edge#TYPE_FORWARD} edge type.\n+     */\n+    public Collection getEdges(int type) {\n+        Collection typed = null;\n+        Edge edge;\n+        Object node;\n+        for (Iterator nodes = _graph.getNodes().iterator(); nodes.hasNext();) {\n+            node = nodes.next();\n+            for (Iterator itr = _graph.getEdgesFrom(node).iterator();\n+                itr.hasNext();) {\n+                edge = (Edge) itr.next();\n+                if (edge.getType() == type) {\n+                    if (typed == null)\n+                        typed = new ArrayList();\n+                    typed.add(edge);\n+                }\n+            }\n+        }\n+        return (typed == null) ? Collections.EMPTY_LIST : typed;\n+    }\n+\n+    /**\n+     * Return the logical time that the given node was finished in\n+     * the graph walk, or -1 if the node is not part of the graph.\n+     */\n+    public int getFinishedTime(Object node) {\n+        NodeInfo info = (NodeInfo) _nodeInfo.get(node);\n+        if (info == null)\n+            return -1;\n+        return info.finished;\n+    }\n+\n+    /**\n+     * Returns a list of graph edges forming a cycle. The cycle begins \n+     * with a type {@link Edge#TYPE_BACK} edge.\n+     * @param backEdge \"Starting\" edge of the cycle\n+     * @param path Continuous list of graph edges, may be null\n+     * @param pos Index of the first edge in path continuing the cycle\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\n+     */\n+    private List buildCycle(Edge backEdge, List path, int pos) {\n+        int length = path != null ? path.size() - pos : 0;\n+        List cycle = new ArrayList(length + 1);\n+        cycle.add(0, backEdge);\n+        for (int i = 0; i < length; i++) {\n+            cycle.add(i + 1, path.get(pos + i));\n+        }\n+        return cycle;\n+    }\n+\n+    /**\n+     * Computes the list of edges forming a cycle. The cycle always exists for\n+     * a type {@link Edge#TYPE_BACK} edge. This method should only be called \n+     * for type {@link Edge#TYPE_BACK} edges. \n+     * @param edge Edge where the cycle was detected\n+     * @param path Path consisting of edges to the edge's starting node\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\n+     */\n+    private List cycleForBackEdge(Edge edge, List path) {\n+        if (edge.getType() != Edge.TYPE_BACK) {\n+            return null;\n+        }\n+        \n+        List cycle;\n+        int pos = 0;\n+        if (path != null && !edge.getFrom().equals(edge.getTo())) {\n+            // Not a single edge loop\n+            pos = findNodeInPath(edge.getTo(), path);\n+            assert (pos >= 0): _loc.get(\"node-not-on-path\", edge, edge.getTo()); \n+        } else {\n+            assert (edge.getFrom().equals(edge.getTo())): \n+                _loc.get(\"edge-no-loop\", edge).getMessage();\n+            path = null;\n+        }\n+        cycle = buildCycle(edge, path, pos); \n+        assert (cycle != null): _loc.get(\"cycle-null\", edge).getMessage();\n+        return cycle;\n+    }\n+\n+    /**\n+     * Computes the cycle of edges including node cycleTo. The cycle must not \n+     * necessarily exist. This method should only be called for type \n+     * {@link Edge#TYPE_FORWARD} edges.\n+     * @param graph Graph\n+     * @param node Current node\n+     * @param cycleTo End node for loop\n+     * @param path Path from loop end node to current node\n+     * @return True if a cycle has been found. The cycle will be contained in\n+     * the <code>path</code> parameter.\n+     */\n+    private boolean cycleForForwardEdge(Graph graph, Object node,\n+        Object cycleTo, List path) {                   \n+        boolean found = false;\n+        Collection edges = graph.getEdgesFrom(node);\n+        for (Iterator itr = edges.iterator(); !found && itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            Object other = edge.getOther(node);\n+            // Single edge loops are ignored\n+            if (!node.equals(other)) {\n+                if (other.equals(cycleTo)) {\n+                    // Cycle complete\n+                    path.add(edge);\n+                    found = true;\n+                } else if (!path.contains(edge)){\n+                    // Walk this edge\n+                    path.add(edge);\n+                    found = cycleForForwardEdge(graph, other, cycleTo, path);\n+                    if (!found) {\n+                        // Remove edge again\n+                        path.remove(edge);                    \n+                    }\n+                }\n+            }\n+        }\n+        return found;\n+    }\n+    \n+    /**\n+     * Finds the position of the edge starting from a particular node in the \n+     * continuous list of edges.\n+     * @param node Node on the cycle.\n+     * @param path Continuous list of graph edges.\n+     * @return Edge index if found, -1 otherwise.\n+     */\n+    private int findNodeInPath(Object node, List path) {\n+        int pos = -1;\n+        if (path != null) {\n+            for (int i = 0; i < path.size(); i++) {\n+                if (((Edge)path.get(i)).getFrom().equals(node)) {\n+                    pos = i;\n+                }\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    /**\n+     * Test, if the analysis didn't find cycles.\n+     */\n+    public boolean hasNoCycles() {\n+        // a) there must not be any back edges\n+        if (!getEdges(Edge.TYPE_BACK).isEmpty()) {\n+            return false;\n+        }\n+        // b) there might be forward edges\n+        // make sure these don't indicate cycles\n+        Collection edges = getEdges(Edge.TYPE_FORWARD);\n+        if (!edges.isEmpty()) {\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+                Edge edge = (Edge) itr.next();\n+                if (edge.getCycle() != null)  {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Comparator for toplogically sorting entries in the node info map.\n+     */\n+    private static class NodeInfoComparator\n+        implements Comparator {\n+\n+        private final Comparator _subComp;\n+\n+        public NodeInfoComparator(Comparator subComp) {\n+            _subComp = subComp;\n+        }\n+\n+        public int compare(Object o1, Object o2) {\n+            Map.Entry e1 = (Map.Entry) o1;\n+            Map.Entry e2 = (Map.Entry) o2;\n+            NodeInfo n1 = (NodeInfo) e1.getValue();\n+            NodeInfo n2 = (NodeInfo) e2.getValue();\n+\n+            // sort by finished order\n+            int ret = n1.finished - n2.finished;\n+            if (ret == 0 && _subComp != null)\n+                ret = _subComp.compare(e1.getKey(), e2.getKey());\n+            return ret;\n+        }\n+    }\n+\n+    /**\n+     *\tList of node-to-nodeinfo entries that exposes just the nodes.\n+     */\n+    private static class NodeList\n+        extends AbstractList {\n+\n+        private final Map.Entry[] _entries;\n+\n+        public NodeList(Map.Entry[] entries) {\n+            _entries = entries;\n+        }\n+\n+        public Object get(int idx) {\n+            return _entries[idx].getKey();\n+        }\n+\n+        public int size() {\n+            return _entries.length;\n+\t\t}\n+\t}\n+}"},{"sha":"aa57109b62f5fcfde616c78983d9928b955271b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":222,"deletions":222,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,222 +1,222 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\r\n- * and a weight.  Edges can be either directed or undirected.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class Edge {\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a tree edge if node v was first discovered by\r\n-     * traversing the edge.\r\n-     */\r\n-    public static final int TYPE_TREE = 1;\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a back edge if it creates a cycle back to an\r\n-     * ancestor in the graph.\r\n-     */\r\n-    public static final int TYPE_BACK = 2;\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a forward edge if it is not a tree or back edge.\r\n-     */\r\n-    public static final int TYPE_FORWARD = 3;\r\n-\r\n-    private final Object _from;\r\n-    private final Object _to;\r\n-    private final boolean _directed;\r\n-\r\n-    private int _type = 0;\r\n-    private double _weight = 0;\r\n-    private Object _userObj = null;\r\n-    private List _cycle = null;\r\n-    private boolean _removedFromGraph = false;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param    from        the node the edge comes from\r\n-     * @param    to            the node the edge goes to\r\n-     * @param    directed    whether the edge is directed\r\n-     */\r\n-    public Edge(Object from, Object to, boolean directed) {\r\n-        if (from == null)\r\n-            throw new NullPointerException(\"from == null\");\r\n-        if (to == null)\r\n-            throw new NullPointerException(\"to == null\");\r\n-        _from = from;\r\n-        _to = to;\r\n-        _directed = directed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param    from        the node the edge comes from\r\n-     * @param    to            the node the edge goes to\r\n-     * @param    directed    whether the edge is directed\r\n-     * @param    userObject    an associated object\r\n-     */\r\n-    public Edge(Object from, Object to, boolean directed, Object userObject) {\r\n-        this(from, to, directed);\r\n-        _userObj = userObject;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node the edge links from.\r\n-     */\r\n-    public Object getFrom() {\r\n-        return _from;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node the edge links to.\r\n-     */\r\n-    public Object getTo() {\r\n-        return _to;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node on the opposite end of the given one, or null if the\r\n-     * given node is not part of this edge.\r\n-     */\r\n-    public Object getOther(Object node) {\r\n-        if (_to.equals(node))\r\n-            return _from;\r\n-        if (_from.equals(node))\r\n-            return _to;\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if this edge links to the given node.  For undirected edges,\r\n-     * this method returns true if either side is equal to the given node.\r\n-     */\r\n-    public boolean isTo(Object node) {\r\n-        return _to.equals(node) || (!_directed && _from.equals(node));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if this edge links from the given node.  For undirected\r\n-     * edges, this method returns true if either side is equal to the given\r\n-     * node.\r\n-     */\r\n-    public boolean isFrom(Object node) {\r\n-        return _from.equals(node) || (!_directed && _to.equals(node));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the edge is directed.\r\n-     */\r\n-    public boolean isDirected() {\r\n-        return _directed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the weight of the edge.\r\n-     */\r\n-    public double getWeight() {\r\n-        return _weight;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the weight of the edge.\r\n-     */\r\n-    public void setWeight(double weight) {\r\n-        _weight = weight;\r\n-    }\r\n-\r\n-    /**\r\n-     * Arbitrary user object associated with the edge.\r\n-     */\r\n-    public Object getUserObject() {\r\n-        return _userObj;\r\n-    }\r\n-\r\n-    /**\r\n-     * Arbitrary user object associated with the edge.\r\n-     */\r\n-    public void setUserObject(Object obj) {\r\n-        _userObj = obj;\r\n-    }\r\n-\r\n-    /**\r\n-     * Traversal bookkeeping info.\r\n-     */\r\n-    public int getType() {\r\n-        return _type;\r\n-    }\r\n-\r\n-    /**\r\n-     * Traversal bookkeeping info.\r\n-     */\r\n-    public void setType(int type) {\r\n-        _type = type;\r\n-    }\r\n-\r\n-    /**\r\n-     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n-     */\r\n-    public List getCycle() {\r\n-        return _cycle;\r\n-    }\r\n-    \r\n-    /**\r\n-     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n-     */\r\n-    public void setCycle(List cycle) {\r\n-        _cycle = cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns if this edge is (still) part of the graph.\r\n-     */\r\n-    public boolean isRemovedFromGraph() {\r\n-        return _removedFromGraph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Mark this edge as removed from the graph.\r\n-     */\r\n-    public void setRemovedFromGraph() {\r\n-        this._removedFromGraph = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear traversal info.\r\n-     */\r\n-    public void clearTraversal() {\r\n-        _type = 0;\r\n-        _cycle = null;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return super.toString() + \"[from=\" + getFrom() + \";to=\" + getTo()\r\n-            + \";directed=\" + isDirected () + \";weight=\" + getWeight () + \"]\";\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.List;\n+\n+/**\n+ * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\n+ * and a weight.  Edges can be either directed or undirected.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class Edge {\n+\n+    /**\n+     * An edge (u, v) is a tree edge if node v was first discovered by\n+     * traversing the edge.\n+     */\n+    public static final int TYPE_TREE = 1;\n+\n+    /**\n+     * An edge (u, v) is a back edge if it creates a cycle back to an\n+     * ancestor in the graph.\n+     */\n+    public static final int TYPE_BACK = 2;\n+\n+    /**\n+     * An edge (u, v) is a forward edge if it is not a tree or back edge.\n+     */\n+    public static final int TYPE_FORWARD = 3;\n+\n+    private final Object _from;\n+    private final Object _to;\n+    private final boolean _directed;\n+\n+    private int _type = 0;\n+    private double _weight = 0;\n+    private Object _userObj = null;\n+    private List _cycle = null;\n+    private boolean _removedFromGraph = false;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    from        the node the edge comes from\n+     * @param    to            the node the edge goes to\n+     * @param    directed    whether the edge is directed\n+     */\n+    public Edge(Object from, Object to, boolean directed) {\n+        if (from == null)\n+            throw new NullPointerException(\"from == null\");\n+        if (to == null)\n+            throw new NullPointerException(\"to == null\");\n+        _from = from;\n+        _to = to;\n+        _directed = directed;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    from        the node the edge comes from\n+     * @param    to            the node the edge goes to\n+     * @param    directed    whether the edge is directed\n+     * @param    userObject    an associated object\n+     */\n+    public Edge(Object from, Object to, boolean directed, Object userObject) {\n+        this(from, to, directed);\n+        _userObj = userObject;\n+    }\n+\n+    /**\n+     * Return the node the edge links from.\n+     */\n+    public Object getFrom() {\n+        return _from;\n+    }\n+\n+    /**\n+     * Return the node the edge links to.\n+     */\n+    public Object getTo() {\n+        return _to;\n+    }\n+\n+    /**\n+     * Return the node on the opposite end of the given one, or null if the\n+     * given node is not part of this edge.\n+     */\n+    public Object getOther(Object node) {\n+        if (_to.equals(node))\n+            return _from;\n+        if (_from.equals(node))\n+            return _to;\n+        return null;\n+    }\n+\n+    /**\n+     * Return true if this edge links to the given node.  For undirected edges,\n+     * this method returns true if either side is equal to the given node.\n+     */\n+    public boolean isTo(Object node) {\n+        return _to.equals(node) || (!_directed && _from.equals(node));\n+    }\n+\n+    /**\n+     * Return true if this edge links from the given node.  For undirected\n+     * edges, this method returns true if either side is equal to the given\n+     * node.\n+     */\n+    public boolean isFrom(Object node) {\n+        return _from.equals(node) || (!_directed && _to.equals(node));\n+    }\n+\n+    /**\n+     * Return whether the edge is directed.\n+     */\n+    public boolean isDirected() {\n+        return _directed;\n+    }\n+\n+    /**\n+     * Return the weight of the edge.\n+     */\n+    public double getWeight() {\n+        return _weight;\n+    }\n+\n+    /**\n+     * Set the weight of the edge.\n+     */\n+    public void setWeight(double weight) {\n+        _weight = weight;\n+    }\n+\n+    /**\n+     * Arbitrary user object associated with the edge.\n+     */\n+    public Object getUserObject() {\n+        return _userObj;\n+    }\n+\n+    /**\n+     * Arbitrary user object associated with the edge.\n+     */\n+    public void setUserObject(Object obj) {\n+        _userObj = obj;\n+    }\n+\n+    /**\n+     * Traversal bookkeeping info.\n+     */\n+    public int getType() {\n+        return _type;\n+    }\n+\n+    /**\n+     * Traversal bookkeeping info.\n+     */\n+    public void setType(int type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\n+     */\n+    public List getCycle() {\n+        return _cycle;\n+    }\n+    \n+    /**\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\n+     */\n+    public void setCycle(List cycle) {\n+        _cycle = cycle;\n+    }\n+\n+    /**\n+     * Returns if this edge is (still) part of the graph.\n+     */\n+    public boolean isRemovedFromGraph() {\n+        return _removedFromGraph;\n+    }\n+\n+    /**\n+     * Mark this edge as removed from the graph.\n+     */\n+    public void setRemovedFromGraph() {\n+        this._removedFromGraph = true;\n+    }\n+\n+    /**\n+     * Clear traversal info.\n+     */\n+    public void clearTraversal() {\n+        _type = 0;\n+        _cycle = null;\n+    }\n+\n+    public String toString() {\n+        return super.toString() + \"[from=\" + getFrom() + \";to=\" + getTo()\n+            + \";directed=\" + isDirected () + \";weight=\" + getWeight () + \"]\";\n+\t}\n+}"},{"sha":"77f9d74ead100310ffe8136d3f3039c8b5b5d95f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,202 +1,202 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedHashMap;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * <p>Graph representation using the adjacency list form.  See the book\r\n- * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class Graph {\r\n-\r\n-    /**\r\n-     * Map each node to list of edges from that node.\r\n-     * Using a LinkedHashMap to ensure order of iterator processing.\r\n-     */ \r\n-    private final Map _nodes = new LinkedHashMap();\r\n-\r\n-    /**\r\n-     * Clear the graph.\r\n-     */\r\n-    public void clear() {\r\n-        _nodes.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if the graph contains the given node.\r\n-     */\r\n-    public boolean containsNode(Object node) {\r\n-        return _nodes.containsKey(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a view of all nodes in the graph.\r\n-     */\r\n-    public Collection getNodes() {\r\n-        return _nodes.keySet();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a node to the graph.  Adding a node a second time has no effect.\r\n-     */\r\n-    public void addNode(Object node) {\r\n-        if (node == null)\r\n-            throw new NullPointerException(\"node = null\");\r\n-        if (!containsNode(node))\r\n-            _nodes.put(node, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove a node from the graph.  All edges to and from the node\r\n-     * will be cleared.\r\n-     *\r\n-     * @return true if the node was removed, false otherwise\r\n-     */\r\n-    public boolean removeNode(Object node) {\r\n-        boolean rem = containsNode(node);\r\n-        if (rem) {\r\n-            Collection edges = getEdgesTo(node);\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();)\r\n-                removeEdge((Edge) itr.next());\r\n-            _nodes.remove(node);\r\n-        }\r\n-        return rem;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all edges in the graph.\r\n-     */\r\n-    public Collection getEdges() {\r\n-        Collection all = new HashSet();\r\n-        Collection edges;\r\n-        for (Iterator itr = _nodes.values().iterator(); itr.hasNext();) {\r\n-            edges = (Collection) itr.next();\r\n-            if (edges != null)\r\n-                all.addAll(edges);\r\n-        }\r\n-        return all;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges from a particular node.\r\n-     */\r\n-    public Collection getEdgesFrom(Object node) {\r\n-        Collection edges = (Collection) _nodes.get(node);\r\n-        return (edges == null) ? Collections.EMPTY_LIST : edges;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges to a particular node.\r\n-     */\r\n-    public Collection getEdgesTo(Object node) {\r\n-        Collection edges = getEdges();\r\n-        Collection to = new ArrayList();\r\n-        Edge edge;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            if (edge.isTo(node))\r\n-                to.add(edge);\r\n-        }\r\n-        return to;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges from one node to another.\r\n-     */\r\n-    public Collection getEdges(Object from, Object to) {\r\n-        Collection edges = getEdgesFrom(from);\r\n-        Collection matches = new ArrayList(edges.size());\r\n-        Edge edge;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            if (edge.isTo(to))\r\n-                matches.add(edge);\r\n-        }\r\n-        return matches;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge to the graph.\r\n-     */\r\n-    public void addEdge(Edge edge) {\r\n-        if (!containsNode(edge.getTo()))\r\n-            throw new IllegalArgumentException(edge.getTo().toString());\r\n-        if (!containsNode(edge.getFrom()))\r\n-            throw new IllegalArgumentException(edge.getFrom().toString());\r\n-\r\n-        Collection from = (Collection) _nodes.get(edge.getFrom());\r\n-        if (from == null) {\r\n-            from = new ArrayList(3);\r\n-            _nodes.put(edge.getFrom(), from);\r\n-        }\r\n-        from.add(edge);\r\n-\r\n-        if (!edge.isDirected() && !edge.getFrom().equals(edge.getTo())) {\r\n-            Collection to = (Collection) _nodes.get(edge.getTo());\r\n-            if (to == null) {\r\n-                to = new ArrayList(3);\r\n-                _nodes.put(edge.getTo(), to);\r\n-            }\r\n-            to.add(edge);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove an edge from the graph.\r\n-     *\r\n-     * @return true if the edge was removed, false if not in the graph\r\n-     */\r\n-    public boolean removeEdge(Edge edge) {\r\n-        Collection edges = (Collection) _nodes.get(edge.getFrom());\r\n-        if (edges == null)\r\n-            return false;\r\n-        boolean rem = edges.remove(edge);\r\n-        if (rem && !edge.isDirected()) {\r\n-            edges = (Collection) _nodes.get(edge.getTo());\r\n-            if (edges != null)\r\n-                edges.remove(edge);\r\n-        }\r\n-        return rem;\r\n-    }\r\n-\r\n-    /**\r\n-     *\tClear all nodes and edges of the bookkeeping information from their\r\n-     *\tlast traversal.\r\n-     */\r\n-    public void clearTraversal() {\r\n-        Collection edges;\r\n-        for (Iterator vals = _nodes.values().iterator(); vals.hasNext();) {\r\n-            edges = (Collection) vals.next();\r\n-            if (edges != null)\r\n-                for (Iterator ed = edges.iterator(); ed.hasNext();)\r\n-                    ((Edge) ed.next()).clearTraversal ();\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * <p>Graph representation using the adjacency list form.  See the book\n+ * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class Graph {\n+\n+    /**\n+     * Map each node to list of edges from that node.\n+     * Using a LinkedHashMap to ensure order of iterator processing.\n+     */ \n+    private final Map _nodes = new LinkedHashMap();\n+\n+    /**\n+     * Clear the graph.\n+     */\n+    public void clear() {\n+        _nodes.clear();\n+    }\n+\n+    /**\n+     * Return true if the graph contains the given node.\n+     */\n+    public boolean containsNode(Object node) {\n+        return _nodes.containsKey(node);\n+    }\n+\n+    /**\n+     * Return a view of all nodes in the graph.\n+     */\n+    public Collection getNodes() {\n+        return _nodes.keySet();\n+    }\n+\n+    /**\n+     * Add a node to the graph.  Adding a node a second time has no effect.\n+     */\n+    public void addNode(Object node) {\n+        if (node == null)\n+            throw new NullPointerException(\"node = null\");\n+        if (!containsNode(node))\n+            _nodes.put(node, null);\n+    }\n+\n+    /**\n+     * Remove a node from the graph.  All edges to and from the node\n+     * will be cleared.\n+     *\n+     * @return true if the node was removed, false otherwise\n+     */\n+    public boolean removeNode(Object node) {\n+        boolean rem = containsNode(node);\n+        if (rem) {\n+            Collection edges = getEdgesTo(node);\n+            for (Iterator itr = edges.iterator(); itr.hasNext();)\n+                removeEdge((Edge) itr.next());\n+            _nodes.remove(node);\n+        }\n+        return rem;\n+    }\n+\n+    /**\n+     * Return all edges in the graph.\n+     */\n+    public Collection getEdges() {\n+        Collection all = new HashSet();\n+        Collection edges;\n+        for (Iterator itr = _nodes.values().iterator(); itr.hasNext();) {\n+            edges = (Collection) itr.next();\n+            if (edges != null)\n+                all.addAll(edges);\n+        }\n+        return all;\n+    }\n+\n+    /**\n+     * Return all the edges from a particular node.\n+     */\n+    public Collection getEdgesFrom(Object node) {\n+        Collection edges = (Collection) _nodes.get(node);\n+        return (edges == null) ? Collections.EMPTY_LIST : edges;\n+    }\n+\n+    /**\n+     * Return all the edges to a particular node.\n+     */\n+    public Collection getEdgesTo(Object node) {\n+        Collection edges = getEdges();\n+        Collection to = new ArrayList();\n+        Edge edge;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            if (edge.isTo(node))\n+                to.add(edge);\n+        }\n+        return to;\n+    }\n+\n+    /**\n+     * Return all the edges from one node to another.\n+     */\n+    public Collection getEdges(Object from, Object to) {\n+        Collection edges = getEdgesFrom(from);\n+        Collection matches = new ArrayList(edges.size());\n+        Edge edge;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            if (edge.isTo(to))\n+                matches.add(edge);\n+        }\n+        return matches;\n+    }\n+\n+    /**\n+     * Add an edge to the graph.\n+     */\n+    public void addEdge(Edge edge) {\n+        if (!containsNode(edge.getTo()))\n+            throw new IllegalArgumentException(edge.getTo().toString());\n+        if (!containsNode(edge.getFrom()))\n+            throw new IllegalArgumentException(edge.getFrom().toString());\n+\n+        Collection from = (Collection) _nodes.get(edge.getFrom());\n+        if (from == null) {\n+            from = new ArrayList(3);\n+            _nodes.put(edge.getFrom(), from);\n+        }\n+        from.add(edge);\n+\n+        if (!edge.isDirected() && !edge.getFrom().equals(edge.getTo())) {\n+            Collection to = (Collection) _nodes.get(edge.getTo());\n+            if (to == null) {\n+                to = new ArrayList(3);\n+                _nodes.put(edge.getTo(), to);\n+            }\n+            to.add(edge);\n+        }\n+    }\n+\n+    /**\n+     * Remove an edge from the graph.\n+     *\n+     * @return true if the edge was removed, false if not in the graph\n+     */\n+    public boolean removeEdge(Edge edge) {\n+        Collection edges = (Collection) _nodes.get(edge.getFrom());\n+        if (edges == null)\n+            return false;\n+        boolean rem = edges.remove(edge);\n+        if (rem && !edge.isDirected()) {\n+            edges = (Collection) _nodes.get(edge.getTo());\n+            if (edges != null)\n+                edges.remove(edge);\n+        }\n+        return rem;\n+    }\n+\n+    /**\n+     *\tClear all nodes and edges of the bookkeeping information from their\n+     *\tlast traversal.\n+     */\n+    public void clearTraversal() {\n+        Collection edges;\n+        for (Iterator vals = _nodes.values().iterator(); vals.hasNext();) {\n+            edges = (Collection) vals.next();\n+            if (edges != null)\n+                for (Iterator ed = edges.iterator(); ed.hasNext();)\n+                    ((Edge) ed.next()).clearTraversal ();\n+\t\t}\n+\t}\n+}"},{"sha":"b9c67ff6daef47f8283e81ae68d4682c458c69ca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,47 +1,47 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-/**\r\n- * <p>A helper interface that allows third parties to be notified of\r\n- * graph events during graph traversals</p>\r\n- *\r\n- * @author Steve Kim\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public interface GraphVisitor {\r\n-\r\n-    /**\r\n-     * May not be called.  The meaning of this method is dependent\r\n-     * on the traversal being used.  See each appropriate graph\r\n-     * walker for details.\r\n-     */\r\n-    public void nodeSeen(Object node);\r\n-\r\n-    /**\r\n-     * will only be called once per node\r\n-     */\r\n-    public void nodeVisited(Object node);\r\n-\r\n-    /**\r\n-     * may visit the node twice (both sides)\r\n-     */\r\n-    public void edgeVisited(Edge edge);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+/**\n+ * <p>A helper interface that allows third parties to be notified of\n+ * graph events during graph traversals</p>\n+ *\n+ * @author Steve Kim\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public interface GraphVisitor {\n+\n+    /**\n+     * May not be called.  The meaning of this method is dependent\n+     * on the traversal being used.  See each appropriate graph\n+     * walker for details.\n+     */\n+    public void nodeSeen(Object node);\n+\n+    /**\n+     * will only be called once per node\n+     */\n+    public void nodeVisited(Object node);\n+\n+    /**\n+     * may visit the node twice (both sides)\n+     */\n+    public void edgeVisited(Edge edge);\n+}"},{"sha":"9ece659a36b83abf2776a321fac1b2178f77d51d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,35 +1,35 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-/**\r\n- * <p>Struct used to track graph node information during traversal.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- */\r\n-class NodeInfo {\r\n-\r\n-    public static final int COLOR_WHITE = 0;\r\n-    public static final int COLOR_GRAY = 1;\r\n-    public static final int COLOR_BLACK = 2;\r\n-\r\n-    public int finished = 0;\r\n-    public int color = COLOR_WHITE;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+/**\n+ * <p>Struct used to track graph node information during traversal.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ */\n+class NodeInfo {\n+\n+    public static final int COLOR_WHITE = 0;\n+    public static final int COLOR_GRAY = 1;\n+    public static final int COLOR_BLACK = 2;\n+\n+    public int finished = 0;\n+    public int color = COLOR_WHITE;\n+}"},{"sha":"6f3b4e03facbf8a58630a4147c9e9ea6792e37dd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"modified","additions":773,"deletions":773,"changes":1546,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,773 +1,773 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.jdbc;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-\r\n-/**\r\n- * Wrapper around a DatabaseMetadata instance.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public class DelegatingDatabaseMetaData implements DatabaseMetaData {\r\n-\r\n-    private final DatabaseMetaData _metaData;\r\n-    private final Connection _conn;\r\n-\r\n-    public DelegatingDatabaseMetaData(DatabaseMetaData metaData,\r\n-        Connection conn) {\r\n-        _conn = conn;\r\n-        _metaData = metaData;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base underlying database metadata.\r\n-     */\r\n-    public DatabaseMetaData getInnermostDelegate() {\r\n-        return _metaData instanceof DelegatingDatabaseMetaData ?\r\n-            ((DelegatingDatabaseMetaData) _metaData).getInnermostDelegate()\r\n-            : _metaData;\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return getInnermostDelegate().hashCode();\r\n-    }\r\n-\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (other instanceof DelegatingDatabaseMetaData)\r\n-            other = ((DelegatingDatabaseMetaData) other)\r\n-                .getInnermostDelegate();\r\n-        return getInnermostDelegate().equals(other);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        StringBuffer buf = new StringBuffer(\"metadata \").append(hashCode());\r\n-        buf.append(\"[\").append(_metaData.toString()).append(\"]\");\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public boolean allProceduresAreCallable() throws SQLException {\r\n-        return _metaData.allProceduresAreCallable();\r\n-    }\r\n-\r\n-    public boolean allTablesAreSelectable() throws SQLException {\r\n-        return _metaData.allTablesAreSelectable();\r\n-    }\r\n-\r\n-    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\r\n-        return _metaData.dataDefinitionCausesTransactionCommit();\r\n-    }\r\n-\r\n-    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\r\n-        return _metaData.dataDefinitionIgnoredInTransactions();\r\n-    }\r\n-\r\n-    public boolean deletesAreDetected(int type) throws SQLException {\r\n-        return _metaData.deletesAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\r\n-        return _metaData.doesMaxRowSizeIncludeBlobs();\r\n-    }\r\n-\r\n-    public ResultSet getBestRowIdentifier(String catalog,\r\n-        String schema, String table, int scope, boolean nullable)\r\n-        throws SQLException {\r\n-        return _metaData.getBestRowIdentifier(catalog, schema,\r\n-            table, scope, nullable);\r\n-    }\r\n-\r\n-    public ResultSet getCatalogs() throws SQLException {\r\n-        return _metaData.getCatalogs();\r\n-    }\r\n-\r\n-    public String getCatalogSeparator() throws SQLException {\r\n-        return _metaData.getCatalogSeparator();\r\n-    }\r\n-\r\n-    public String getCatalogTerm() throws SQLException {\r\n-        return _metaData.getCatalogTerm();\r\n-    }\r\n-\r\n-    public ResultSet getColumnPrivileges(String catalog, String schema,\r\n-        String table, String columnNamePattern) throws SQLException {\r\n-        return _metaData.getColumnPrivileges(catalog, schema,\r\n-            table, columnNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getColumns(String catalog, String schemaPattern,\r\n-        String tableNamePattern, String columnNamePattern) throws SQLException {\r\n-        return _metaData.getColumns(catalog, schemaPattern,\r\n-            tableNamePattern, columnNamePattern);\r\n-    }\r\n-\r\n-    public Connection getConnection() throws SQLException {\r\n-        return _conn;\r\n-    }\r\n-\r\n-    public ResultSet getCrossReference(String primaryCatalog,\r\n-        String primarySchema, String primaryTable, String foreignCatalog,\r\n-        String foreignSchema, String foreignTable) throws SQLException {\r\n-        return _metaData.getCrossReference(primaryCatalog, primarySchema,\r\n-            primaryTable, foreignCatalog, foreignSchema, foreignTable);\r\n-    }\r\n-\r\n-    public String getDatabaseProductName() throws SQLException {\r\n-        return _metaData.getDatabaseProductName();\r\n-    }\r\n-\r\n-    public String getDatabaseProductVersion() throws SQLException {\r\n-        return _metaData.getDatabaseProductVersion();\r\n-    }\r\n-\r\n-    public int getDefaultTransactionIsolation() throws SQLException {\r\n-        return _metaData.getDefaultTransactionIsolation();\r\n-    }\r\n-\r\n-    public int getDriverMajorVersion() {\r\n-        return _metaData.getDriverMajorVersion();\r\n-    }\r\n-\r\n-    public int getDriverMinorVersion() {\r\n-        return _metaData.getDriverMinorVersion();\r\n-    }\r\n-\r\n-    public String getDriverName() throws SQLException {\r\n-        return _metaData.getDriverName();\r\n-    }\r\n-\r\n-    public String getDriverVersion() throws SQLException {\r\n-        return _metaData.getDriverVersion();\r\n-    }\r\n-\r\n-    public ResultSet getExportedKeys(String catalog, String schema,\r\n-        String table) throws SQLException {\r\n-        return _metaData.getExportedKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public String getExtraNameCharacters() throws SQLException {\r\n-        return _metaData.getExtraNameCharacters();\r\n-    }\r\n-\r\n-    public String getIdentifierQuoteString() throws SQLException {\r\n-        return _metaData.getIdentifierQuoteString();\r\n-    }\r\n-\r\n-    public ResultSet getImportedKeys(String catalog, String schema,\r\n-        String table) throws SQLException {\r\n-        return _metaData.getImportedKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public ResultSet getIndexInfo(String catalog, String schema,\r\n-        String table, boolean unique, boolean approximate) throws SQLException {\r\n-        return _metaData.getIndexInfo(catalog, schema, table, unique,\r\n-            approximate);\r\n-    }\r\n-\r\n-    public int getMaxBinaryLiteralLength() throws SQLException {\r\n-        return _metaData.getMaxBinaryLiteralLength();\r\n-    }\r\n-\r\n-    public int getMaxCatalogNameLength() throws SQLException {\r\n-        return _metaData.getMaxCatalogNameLength();\r\n-    }\r\n-\r\n-    public int getMaxCharLiteralLength() throws SQLException {\r\n-        return _metaData.getMaxCharLiteralLength();\r\n-    }\r\n-\r\n-    public int getMaxColumnNameLength() throws SQLException {\r\n-        return _metaData.getMaxColumnNameLength();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInGroupBy() throws SQLException {\r\n-        return _metaData.getMaxColumnsInGroupBy();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInIndex() throws SQLException {\r\n-        return _metaData.getMaxColumnsInIndex();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInOrderBy() throws SQLException {\r\n-        return _metaData.getMaxColumnsInOrderBy();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInSelect() throws SQLException {\r\n-        return _metaData.getMaxColumnsInSelect();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInTable() throws SQLException {\r\n-        return _metaData.getMaxColumnsInTable();\r\n-    }\r\n-\r\n-    public int getMaxConnections() throws SQLException {\r\n-        return _metaData.getMaxConnections();\r\n-    }\r\n-\r\n-    public int getMaxCursorNameLength() throws SQLException {\r\n-        return _metaData.getMaxCursorNameLength();\r\n-    }\r\n-\r\n-    public int getMaxIndexLength() throws SQLException {\r\n-        return _metaData.getMaxIndexLength();\r\n-    }\r\n-\r\n-    public int getMaxProcedureNameLength() throws SQLException {\r\n-        return _metaData.getMaxProcedureNameLength();\r\n-    }\r\n-\r\n-    public int getMaxRowSize() throws SQLException {\r\n-        return _metaData.getMaxRowSize();\r\n-    }\r\n-\r\n-    public int getMaxSchemaNameLength() throws SQLException {\r\n-        return _metaData.getMaxSchemaNameLength();\r\n-    }\r\n-\r\n-    public int getMaxStatementLength() throws SQLException {\r\n-        return _metaData.getMaxStatementLength();\r\n-    }\r\n-\r\n-    public int getMaxStatements() throws SQLException {\r\n-        return _metaData.getMaxStatements();\r\n-    }\r\n-\r\n-    public int getMaxTableNameLength() throws SQLException {\r\n-        return _metaData.getMaxTableNameLength();\r\n-    }\r\n-\r\n-    public int getMaxTablesInSelect() throws SQLException {\r\n-        return _metaData.getMaxTablesInSelect();\r\n-    }\r\n-\r\n-    public int getMaxUserNameLength() throws SQLException {\r\n-        return _metaData.getMaxUserNameLength();\r\n-    }\r\n-\r\n-    public String getNumericFunctions() throws SQLException {\r\n-        return _metaData.getNumericFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getPrimaryKeys(String catalog, String schema, String table)\r\n-        throws SQLException {\r\n-        return _metaData.getPrimaryKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public ResultSet getProcedureColumns(String catalog, String schemaPattern,\r\n-        String procedureNamePattern, String columnNamePattern)\r\n-        throws SQLException {\r\n-        return _metaData.getProcedureColumns(catalog, schemaPattern,\r\n-            procedureNamePattern, columnNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getProcedures(String catalog, String schemaPattern,\r\n-        String procedureNamePattern) throws SQLException {\r\n-        return _metaData.getProcedures(catalog, schemaPattern,\r\n-            procedureNamePattern);\r\n-    }\r\n-\r\n-    public String getProcedureTerm() throws SQLException {\r\n-        return _metaData.getProcedureTerm();\r\n-    }\r\n-\r\n-    public ResultSet getSchemas() throws SQLException {\r\n-        return _metaData.getSchemas();\r\n-    }\r\n-\r\n-    public String getSchemaTerm() throws SQLException {\r\n-        return _metaData.getSchemaTerm();\r\n-    }\r\n-\r\n-    public String getSearchStringEscape() throws SQLException {\r\n-        return _metaData.getSearchStringEscape();\r\n-    }\r\n-\r\n-    public String getSQLKeywords() throws SQLException {\r\n-        return _metaData.getSQLKeywords();\r\n-    }\r\n-\r\n-    public String getStringFunctions() throws SQLException {\r\n-        return _metaData.getStringFunctions();\r\n-    }\r\n-\r\n-    public String getSystemFunctions() throws SQLException {\r\n-        return _metaData.getSystemFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getTablePrivileges(String catalog,\r\n-        String schemaPattern, String tableNamePattern) throws SQLException {\r\n-        return _metaData.getTablePrivileges(catalog, schemaPattern,\r\n-            tableNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getTables(String catalog, String schemaPattern,\r\n-        String tableNamePattern, String[] types) throws SQLException {\r\n-        return _metaData.getTables(catalog, schemaPattern,\r\n-            tableNamePattern, types);\r\n-    }\r\n-\r\n-    public ResultSet getTableTypes() throws SQLException {\r\n-        return _metaData.getTableTypes();\r\n-    }\r\n-\r\n-    public String getTimeDateFunctions() throws SQLException {\r\n-        return _metaData.getTimeDateFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getTypeInfo() throws SQLException {\r\n-        return _metaData.getTypeInfo();\r\n-    }\r\n-\r\n-    public ResultSet getUDTs(String catalog, String schemaPattern,\r\n-        String typeNamePattern, int[] types) throws SQLException {\r\n-        return _metaData.getUDTs(catalog, schemaPattern,\r\n-            typeNamePattern, types);\r\n-    }\r\n-\r\n-    public String getURL() throws SQLException {\r\n-        return _metaData.getURL();\r\n-    }\r\n-\r\n-    public String getUserName() throws SQLException {\r\n-        return _metaData.getUserName();\r\n-    }\r\n-\r\n-    public ResultSet getVersionColumns(String catalog,\r\n-        String schema, String table) throws SQLException {\r\n-        return _metaData.getVersionColumns(catalog, schema, table);\r\n-    }\r\n-\r\n-    public boolean insertsAreDetected(int type) throws SQLException {\r\n-        return _metaData.insertsAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean isCatalogAtStart() throws SQLException {\r\n-        return _metaData.isCatalogAtStart();\r\n-    }\r\n-\r\n-    public boolean isReadOnly() throws SQLException {\r\n-        return _metaData.isReadOnly();\r\n-    }\r\n-\r\n-    public boolean nullPlusNonNullIsNull() throws SQLException {\r\n-        return _metaData.nullPlusNonNullIsNull();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedAtEnd() throws SQLException {\r\n-        return _metaData.nullsAreSortedAtEnd();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedAtStart() throws SQLException {\r\n-        return _metaData.nullsAreSortedAtStart();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedHigh() throws SQLException {\r\n-        return _metaData.nullsAreSortedHigh();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedLow() throws SQLException {\r\n-        return _metaData.nullsAreSortedLow();\r\n-    }\r\n-\r\n-    public boolean othersDeletesAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersDeletesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean othersInsertsAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersInsertsAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean othersUpdatesAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersUpdatesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownDeletesAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownDeletesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownInsertsAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownInsertsAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownUpdatesAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownUpdatesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean storesLowerCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesLowerCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesLowerCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesMixedCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesMixedCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesMixedCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesUpperCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesUpperCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesUpperCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsAlterTableWithAddColumn() throws SQLException {\r\n-        return _metaData.supportsAlterTableWithAddColumn();\r\n-    }\r\n-\r\n-    public boolean supportsAlterTableWithDropColumn() throws SQLException {\r\n-        return _metaData.supportsAlterTableWithDropColumn();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92EntryLevelSQL();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92FullSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92FullSQL();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92IntermediateSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92IntermediateSQL();\r\n-    }\r\n-\r\n-    public boolean supportsBatchUpdates() throws SQLException {\r\n-        return _metaData.supportsBatchUpdates();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInDataManipulation() throws SQLException {\r\n-        return _metaData.supportsCatalogsInDataManipulation();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\r\n-        return _metaData.supportsCatalogsInIndexDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInPrivilegeDefinitions()\r\n-        throws SQLException {\r\n-        return _metaData.supportsCatalogsInPrivilegeDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\r\n-        return _metaData.supportsCatalogsInProcedureCalls();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\r\n-        return _metaData.supportsCatalogsInTableDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsColumnAliasing() throws SQLException {\r\n-        return _metaData.supportsColumnAliasing();\r\n-    }\r\n-\r\n-    public boolean supportsConvert() throws SQLException {\r\n-        return _metaData.supportsConvert();\r\n-    }\r\n-\r\n-    public boolean supportsConvert(int fromType, int toType)\r\n-        throws SQLException {\r\n-        return _metaData.supportsConvert(fromType, toType);\r\n-    }\r\n-\r\n-    public boolean supportsCoreSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsCoreSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsCorrelatedSubqueries() throws SQLException {\r\n-        return _metaData.supportsCorrelatedSubqueries();\r\n-    }\r\n-\r\n-    public boolean supportsDataDefinitionAndDataManipulationTransactions()\r\n-        throws SQLException {\r\n-        return _metaData\r\n-            .supportsDataDefinitionAndDataManipulationTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsDataManipulationTransactionsOnly()\r\n-        throws SQLException {\r\n-        return _metaData.supportsDataManipulationTransactionsOnly();\r\n-    }\r\n-\r\n-    public boolean supportsDifferentTableCorrelationNames()\r\n-        throws SQLException {\r\n-        return _metaData.supportsDifferentTableCorrelationNames();\r\n-    }\r\n-\r\n-    public boolean supportsExpressionsInOrderBy() throws SQLException {\r\n-        return _metaData.supportsExpressionsInOrderBy();\r\n-    }\r\n-\r\n-    public boolean supportsExtendedSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsExtendedSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsFullOuterJoins() throws SQLException {\r\n-        return _metaData.supportsFullOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsGroupBy() throws SQLException {\r\n-        return _metaData.supportsGroupBy();\r\n-    }\r\n-\r\n-    public boolean supportsGroupByBeyondSelect() throws SQLException {\r\n-        return _metaData.supportsGroupByBeyondSelect();\r\n-    }\r\n-\r\n-    public boolean supportsGroupByUnrelated() throws SQLException {\r\n-        return _metaData.supportsGroupByUnrelated();\r\n-    }\r\n-\r\n-    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\r\n-        return _metaData.supportsIntegrityEnhancementFacility();\r\n-    }\r\n-\r\n-    public boolean supportsLikeEscapeClause() throws SQLException {\r\n-        return _metaData.supportsLikeEscapeClause();\r\n-    }\r\n-\r\n-    public boolean supportsLimitedOuterJoins() throws SQLException {\r\n-        return _metaData.supportsLimitedOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsMinimumSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsMinimumSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsMixedCaseIdentifiers() throws SQLException {\r\n-        return _metaData.supportsMixedCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.supportsMixedCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleResultSets() throws SQLException {\r\n-        return _metaData.supportsMultipleResultSets();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleTransactions() throws SQLException {\r\n-        return _metaData.supportsMultipleTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsNonNullableColumns() throws SQLException {\r\n-        return _metaData.supportsNonNullableColumns();\r\n-    }\r\n-\r\n-    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\r\n-        return _metaData.supportsOpenCursorsAcrossCommit();\r\n-    }\r\n-\r\n-    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\r\n-        return _metaData.supportsOpenCursorsAcrossRollback();\r\n-    }\r\n-\r\n-    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\r\n-        return _metaData.supportsOpenStatementsAcrossCommit();\r\n-    }\r\n-\r\n-    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\r\n-        return _metaData.supportsOpenStatementsAcrossRollback();\r\n-    }\r\n-\r\n-    public boolean supportsOrderByUnrelated() throws SQLException {\r\n-        return _metaData.supportsOrderByUnrelated();\r\n-    }\r\n-\r\n-    public boolean supportsOuterJoins() throws SQLException {\r\n-        return _metaData.supportsOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsPositionedDelete() throws SQLException {\r\n-        return _metaData.supportsPositionedDelete();\r\n-    }\r\n-\r\n-    public boolean supportsPositionedUpdate() throws SQLException {\r\n-        return _metaData.supportsPositionedUpdate();\r\n-    }\r\n-\r\n-    public boolean supportsResultSetConcurrency(int type, int concurrency)\r\n-        throws SQLException {\r\n-        return _metaData.supportsResultSetConcurrency(type, concurrency);\r\n-    }\r\n-\r\n-    public boolean supportsResultSetType(int type) throws SQLException {\r\n-        return _metaData.supportsResultSetType(type);\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInDataManipulation() throws SQLException {\r\n-        return _metaData.supportsSchemasInDataManipulation();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInIndexDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInPrivilegeDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInProcedureCalls() throws SQLException {\r\n-        return _metaData.supportsSchemasInProcedureCalls();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInTableDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInTableDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSelectForUpdate() throws SQLException {\r\n-        return _metaData.supportsSelectForUpdate();\r\n-    }\r\n-\r\n-    public boolean supportsStoredProcedures() throws SQLException {\r\n-        return _metaData.supportsStoredProcedures();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInComparisons() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInComparisons();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInExists() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInExists();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInIns() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInIns();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInQuantifieds();\r\n-    }\r\n-\r\n-    public boolean supportsTableCorrelationNames() throws SQLException {\r\n-        return _metaData.supportsTableCorrelationNames();\r\n-    }\r\n-\r\n-    public boolean supportsTransactionIsolationLevel(int level)\r\n-        throws SQLException {\r\n-        return _metaData.supportsTransactionIsolationLevel(level);\r\n-    }\r\n-\r\n-    public boolean supportsTransactions() throws SQLException {\r\n-        return _metaData.supportsTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsUnion() throws SQLException {\r\n-        return _metaData.supportsUnion();\r\n-    }\r\n-\r\n-    public boolean supportsUnionAll() throws SQLException {\r\n-        return _metaData.supportsUnionAll();\r\n-    }\r\n-\r\n-    public boolean updatesAreDetected(int type) throws SQLException {\r\n-        return _metaData.updatesAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean usesLocalFilePerTable() throws SQLException {\r\n-        return _metaData.usesLocalFilePerTable();\r\n-    }\r\n-\r\n-    public boolean usesLocalFiles() throws SQLException {\r\n-        return _metaData.usesLocalFiles();\r\n-    }\r\n-\r\n-    // JDBC 3.0 methods(unsupported) follow; these are required to be able to\r\n-    // compile against JDK 1.4\r\n-\r\n-    public boolean supportsSavepoints() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsNamedParameters() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleOpenResults() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsGetGeneratedKeys() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getSuperTypes(String catalog, String schemaPatter,\r\n-        String typeNamePattern) throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getSuperTables(String catalog, String schemaPatter,\r\n-        String tableNamePattern) throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getAttributes(String catalog, String schemaPatter,\r\n-        String typeNamePattern, String attributeNamePattern)\r\n-        throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsResultSetHoldability(int holdability)\r\n-        throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getResultSetHoldability() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getDatabaseMajorVersion() throws SQLException {\r\n-        return _metaData.getDatabaseMajorVersion();\r\n-    }\r\n-\r\n-    public int getDatabaseMinorVersion() throws SQLException {\r\n-        return _metaData.getDatabaseMinorVersion();\r\n-    }\r\n-\r\n-    public int getJDBCMajorVersion() throws SQLException {\r\n-        return _metaData.getJDBCMajorVersion();\r\n-    }\r\n-\r\n-    public int getJDBCMinorVersion() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getSQLStateType() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean locatorsUpdateCopy() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsStatementPooling() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+/**\n+ * Wrapper around a DatabaseMetadata instance.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class DelegatingDatabaseMetaData implements DatabaseMetaData {\n+\n+    private final DatabaseMetaData _metaData;\n+    private final Connection _conn;\n+\n+    public DelegatingDatabaseMetaData(DatabaseMetaData metaData,\n+        Connection conn) {\n+        _conn = conn;\n+        _metaData = metaData;\n+    }\n+\n+    /**\n+     * Return the base underlying database metadata.\n+     */\n+    public DatabaseMetaData getInnermostDelegate() {\n+        return _metaData instanceof DelegatingDatabaseMetaData ?\n+            ((DelegatingDatabaseMetaData) _metaData).getInnermostDelegate()\n+            : _metaData;\n+    }\n+\n+    public int hashCode() {\n+        return getInnermostDelegate().hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (other instanceof DelegatingDatabaseMetaData)\n+            other = ((DelegatingDatabaseMetaData) other)\n+                .getInnermostDelegate();\n+        return getInnermostDelegate().equals(other);\n+    }\n+\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(\"metadata \").append(hashCode());\n+        buf.append(\"[\").append(_metaData.toString()).append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    public boolean allProceduresAreCallable() throws SQLException {\n+        return _metaData.allProceduresAreCallable();\n+    }\n+\n+    public boolean allTablesAreSelectable() throws SQLException {\n+        return _metaData.allTablesAreSelectable();\n+    }\n+\n+    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\n+        return _metaData.dataDefinitionCausesTransactionCommit();\n+    }\n+\n+    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\n+        return _metaData.dataDefinitionIgnoredInTransactions();\n+    }\n+\n+    public boolean deletesAreDetected(int type) throws SQLException {\n+        return _metaData.deletesAreDetected(type);\n+    }\n+\n+    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\n+        return _metaData.doesMaxRowSizeIncludeBlobs();\n+    }\n+\n+    public ResultSet getBestRowIdentifier(String catalog,\n+        String schema, String table, int scope, boolean nullable)\n+        throws SQLException {\n+        return _metaData.getBestRowIdentifier(catalog, schema,\n+            table, scope, nullable);\n+    }\n+\n+    public ResultSet getCatalogs() throws SQLException {\n+        return _metaData.getCatalogs();\n+    }\n+\n+    public String getCatalogSeparator() throws SQLException {\n+        return _metaData.getCatalogSeparator();\n+    }\n+\n+    public String getCatalogTerm() throws SQLException {\n+        return _metaData.getCatalogTerm();\n+    }\n+\n+    public ResultSet getColumnPrivileges(String catalog, String schema,\n+        String table, String columnNamePattern) throws SQLException {\n+        return _metaData.getColumnPrivileges(catalog, schema,\n+            table, columnNamePattern);\n+    }\n+\n+    public ResultSet getColumns(String catalog, String schemaPattern,\n+        String tableNamePattern, String columnNamePattern) throws SQLException {\n+        return _metaData.getColumns(catalog, schemaPattern,\n+            tableNamePattern, columnNamePattern);\n+    }\n+\n+    public Connection getConnection() throws SQLException {\n+        return _conn;\n+    }\n+\n+    public ResultSet getCrossReference(String primaryCatalog,\n+        String primarySchema, String primaryTable, String foreignCatalog,\n+        String foreignSchema, String foreignTable) throws SQLException {\n+        return _metaData.getCrossReference(primaryCatalog, primarySchema,\n+            primaryTable, foreignCatalog, foreignSchema, foreignTable);\n+    }\n+\n+    public String getDatabaseProductName() throws SQLException {\n+        return _metaData.getDatabaseProductName();\n+    }\n+\n+    public String getDatabaseProductVersion() throws SQLException {\n+        return _metaData.getDatabaseProductVersion();\n+    }\n+\n+    public int getDefaultTransactionIsolation() throws SQLException {\n+        return _metaData.getDefaultTransactionIsolation();\n+    }\n+\n+    public int getDriverMajorVersion() {\n+        return _metaData.getDriverMajorVersion();\n+    }\n+\n+    public int getDriverMinorVersion() {\n+        return _metaData.getDriverMinorVersion();\n+    }\n+\n+    public String getDriverName() throws SQLException {\n+        return _metaData.getDriverName();\n+    }\n+\n+    public String getDriverVersion() throws SQLException {\n+        return _metaData.getDriverVersion();\n+    }\n+\n+    public ResultSet getExportedKeys(String catalog, String schema,\n+        String table) throws SQLException {\n+        return _metaData.getExportedKeys(catalog, schema, table);\n+    }\n+\n+    public String getExtraNameCharacters() throws SQLException {\n+        return _metaData.getExtraNameCharacters();\n+    }\n+\n+    public String getIdentifierQuoteString() throws SQLException {\n+        return _metaData.getIdentifierQuoteString();\n+    }\n+\n+    public ResultSet getImportedKeys(String catalog, String schema,\n+        String table) throws SQLException {\n+        return _metaData.getImportedKeys(catalog, schema, table);\n+    }\n+\n+    public ResultSet getIndexInfo(String catalog, String schema,\n+        String table, boolean unique, boolean approximate) throws SQLException {\n+        return _metaData.getIndexInfo(catalog, schema, table, unique,\n+            approximate);\n+    }\n+\n+    public int getMaxBinaryLiteralLength() throws SQLException {\n+        return _metaData.getMaxBinaryLiteralLength();\n+    }\n+\n+    public int getMaxCatalogNameLength() throws SQLException {\n+        return _metaData.getMaxCatalogNameLength();\n+    }\n+\n+    public int getMaxCharLiteralLength() throws SQLException {\n+        return _metaData.getMaxCharLiteralLength();\n+    }\n+\n+    public int getMaxColumnNameLength() throws SQLException {\n+        return _metaData.getMaxColumnNameLength();\n+    }\n+\n+    public int getMaxColumnsInGroupBy() throws SQLException {\n+        return _metaData.getMaxColumnsInGroupBy();\n+    }\n+\n+    public int getMaxColumnsInIndex() throws SQLException {\n+        return _metaData.getMaxColumnsInIndex();\n+    }\n+\n+    public int getMaxColumnsInOrderBy() throws SQLException {\n+        return _metaData.getMaxColumnsInOrderBy();\n+    }\n+\n+    public int getMaxColumnsInSelect() throws SQLException {\n+        return _metaData.getMaxColumnsInSelect();\n+    }\n+\n+    public int getMaxColumnsInTable() throws SQLException {\n+        return _metaData.getMaxColumnsInTable();\n+    }\n+\n+    public int getMaxConnections() throws SQLException {\n+        return _metaData.getMaxConnections();\n+    }\n+\n+    public int getMaxCursorNameLength() throws SQLException {\n+        return _metaData.getMaxCursorNameLength();\n+    }\n+\n+    public int getMaxIndexLength() throws SQLException {\n+        return _metaData.getMaxIndexLength();\n+    }\n+\n+    public int getMaxProcedureNameLength() throws SQLException {\n+        return _metaData.getMaxProcedureNameLength();\n+    }\n+\n+    public int getMaxRowSize() throws SQLException {\n+        return _metaData.getMaxRowSize();\n+    }\n+\n+    public int getMaxSchemaNameLength() throws SQLException {\n+        return _metaData.getMaxSchemaNameLength();\n+    }\n+\n+    public int getMaxStatementLength() throws SQLException {\n+        return _metaData.getMaxStatementLength();\n+    }\n+\n+    public int getMaxStatements() throws SQLException {\n+        return _metaData.getMaxStatements();\n+    }\n+\n+    public int getMaxTableNameLength() throws SQLException {\n+        return _metaData.getMaxTableNameLength();\n+    }\n+\n+    public int getMaxTablesInSelect() throws SQLException {\n+        return _metaData.getMaxTablesInSelect();\n+    }\n+\n+    public int getMaxUserNameLength() throws SQLException {\n+        return _metaData.getMaxUserNameLength();\n+    }\n+\n+    public String getNumericFunctions() throws SQLException {\n+        return _metaData.getNumericFunctions();\n+    }\n+\n+    public ResultSet getPrimaryKeys(String catalog, String schema, String table)\n+        throws SQLException {\n+        return _metaData.getPrimaryKeys(catalog, schema, table);\n+    }\n+\n+    public ResultSet getProcedureColumns(String catalog, String schemaPattern,\n+        String procedureNamePattern, String columnNamePattern)\n+        throws SQLException {\n+        return _metaData.getProcedureColumns(catalog, schemaPattern,\n+            procedureNamePattern, columnNamePattern);\n+    }\n+\n+    public ResultSet getProcedures(String catalog, String schemaPattern,\n+        String procedureNamePattern) throws SQLException {\n+        return _metaData.getProcedures(catalog, schemaPattern,\n+            procedureNamePattern);\n+    }\n+\n+    public String getProcedureTerm() throws SQLException {\n+        return _metaData.getProcedureTerm();\n+    }\n+\n+    public ResultSet getSchemas() throws SQLException {\n+        return _metaData.getSchemas();\n+    }\n+\n+    public String getSchemaTerm() throws SQLException {\n+        return _metaData.getSchemaTerm();\n+    }\n+\n+    public String getSearchStringEscape() throws SQLException {\n+        return _metaData.getSearchStringEscape();\n+    }\n+\n+    public String getSQLKeywords() throws SQLException {\n+        return _metaData.getSQLKeywords();\n+    }\n+\n+    public String getStringFunctions() throws SQLException {\n+        return _metaData.getStringFunctions();\n+    }\n+\n+    public String getSystemFunctions() throws SQLException {\n+        return _metaData.getSystemFunctions();\n+    }\n+\n+    public ResultSet getTablePrivileges(String catalog,\n+        String schemaPattern, String tableNamePattern) throws SQLException {\n+        return _metaData.getTablePrivileges(catalog, schemaPattern,\n+            tableNamePattern);\n+    }\n+\n+    public ResultSet getTables(String catalog, String schemaPattern,\n+        String tableNamePattern, String[] types) throws SQLException {\n+        return _metaData.getTables(catalog, schemaPattern,\n+            tableNamePattern, types);\n+    }\n+\n+    public ResultSet getTableTypes() throws SQLException {\n+        return _metaData.getTableTypes();\n+    }\n+\n+    public String getTimeDateFunctions() throws SQLException {\n+        return _metaData.getTimeDateFunctions();\n+    }\n+\n+    public ResultSet getTypeInfo() throws SQLException {\n+        return _metaData.getTypeInfo();\n+    }\n+\n+    public ResultSet getUDTs(String catalog, String schemaPattern,\n+        String typeNamePattern, int[] types) throws SQLException {\n+        return _metaData.getUDTs(catalog, schemaPattern,\n+            typeNamePattern, types);\n+    }\n+\n+    public String getURL() throws SQLException {\n+        return _metaData.getURL();\n+    }\n+\n+    public String getUserName() throws SQLException {\n+        return _metaData.getUserName();\n+    }\n+\n+    public ResultSet getVersionColumns(String catalog,\n+        String schema, String table) throws SQLException {\n+        return _metaData.getVersionColumns(catalog, schema, table);\n+    }\n+\n+    public boolean insertsAreDetected(int type) throws SQLException {\n+        return _metaData.insertsAreDetected(type);\n+    }\n+\n+    public boolean isCatalogAtStart() throws SQLException {\n+        return _metaData.isCatalogAtStart();\n+    }\n+\n+    public boolean isReadOnly() throws SQLException {\n+        return _metaData.isReadOnly();\n+    }\n+\n+    public boolean nullPlusNonNullIsNull() throws SQLException {\n+        return _metaData.nullPlusNonNullIsNull();\n+    }\n+\n+    public boolean nullsAreSortedAtEnd() throws SQLException {\n+        return _metaData.nullsAreSortedAtEnd();\n+    }\n+\n+    public boolean nullsAreSortedAtStart() throws SQLException {\n+        return _metaData.nullsAreSortedAtStart();\n+    }\n+\n+    public boolean nullsAreSortedHigh() throws SQLException {\n+        return _metaData.nullsAreSortedHigh();\n+    }\n+\n+    public boolean nullsAreSortedLow() throws SQLException {\n+        return _metaData.nullsAreSortedLow();\n+    }\n+\n+    public boolean othersDeletesAreVisible(int type) throws SQLException {\n+        return _metaData.othersDeletesAreVisible(type);\n+    }\n+\n+    public boolean othersInsertsAreVisible(int type) throws SQLException {\n+        return _metaData.othersInsertsAreVisible(type);\n+    }\n+\n+    public boolean othersUpdatesAreVisible(int type) throws SQLException {\n+        return _metaData.othersUpdatesAreVisible(type);\n+    }\n+\n+    public boolean ownDeletesAreVisible(int type) throws SQLException {\n+        return _metaData.ownDeletesAreVisible(type);\n+    }\n+\n+    public boolean ownInsertsAreVisible(int type) throws SQLException {\n+        return _metaData.ownInsertsAreVisible(type);\n+    }\n+\n+    public boolean ownUpdatesAreVisible(int type) throws SQLException {\n+        return _metaData.ownUpdatesAreVisible(type);\n+    }\n+\n+    public boolean storesLowerCaseIdentifiers() throws SQLException {\n+        return _metaData.storesLowerCaseIdentifiers();\n+    }\n+\n+    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesLowerCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean storesMixedCaseIdentifiers() throws SQLException {\n+        return _metaData.storesMixedCaseIdentifiers();\n+    }\n+\n+    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesMixedCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean storesUpperCaseIdentifiers() throws SQLException {\n+        return _metaData.storesUpperCaseIdentifiers();\n+    }\n+\n+    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesUpperCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean supportsAlterTableWithAddColumn() throws SQLException {\n+        return _metaData.supportsAlterTableWithAddColumn();\n+    }\n+\n+    public boolean supportsAlterTableWithDropColumn() throws SQLException {\n+        return _metaData.supportsAlterTableWithDropColumn();\n+    }\n+\n+    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\n+        return _metaData.supportsANSI92EntryLevelSQL();\n+    }\n+\n+    public boolean supportsANSI92FullSQL() throws SQLException {\n+        return _metaData.supportsANSI92FullSQL();\n+    }\n+\n+    public boolean supportsANSI92IntermediateSQL() throws SQLException {\n+        return _metaData.supportsANSI92IntermediateSQL();\n+    }\n+\n+    public boolean supportsBatchUpdates() throws SQLException {\n+        return _metaData.supportsBatchUpdates();\n+    }\n+\n+    public boolean supportsCatalogsInDataManipulation() throws SQLException {\n+        return _metaData.supportsCatalogsInDataManipulation();\n+    }\n+\n+    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\n+        return _metaData.supportsCatalogsInIndexDefinitions();\n+    }\n+\n+    public boolean supportsCatalogsInPrivilegeDefinitions()\n+        throws SQLException {\n+        return _metaData.supportsCatalogsInPrivilegeDefinitions();\n+    }\n+\n+    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\n+        return _metaData.supportsCatalogsInProcedureCalls();\n+    }\n+\n+    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\n+        return _metaData.supportsCatalogsInTableDefinitions();\n+    }\n+\n+    public boolean supportsColumnAliasing() throws SQLException {\n+        return _metaData.supportsColumnAliasing();\n+    }\n+\n+    public boolean supportsConvert() throws SQLException {\n+        return _metaData.supportsConvert();\n+    }\n+\n+    public boolean supportsConvert(int fromType, int toType)\n+        throws SQLException {\n+        return _metaData.supportsConvert(fromType, toType);\n+    }\n+\n+    public boolean supportsCoreSQLGrammar() throws SQLException {\n+        return _metaData.supportsCoreSQLGrammar();\n+    }\n+\n+    public boolean supportsCorrelatedSubqueries() throws SQLException {\n+        return _metaData.supportsCorrelatedSubqueries();\n+    }\n+\n+    public boolean supportsDataDefinitionAndDataManipulationTransactions()\n+        throws SQLException {\n+        return _metaData\n+            .supportsDataDefinitionAndDataManipulationTransactions();\n+    }\n+\n+    public boolean supportsDataManipulationTransactionsOnly()\n+        throws SQLException {\n+        return _metaData.supportsDataManipulationTransactionsOnly();\n+    }\n+\n+    public boolean supportsDifferentTableCorrelationNames()\n+        throws SQLException {\n+        return _metaData.supportsDifferentTableCorrelationNames();\n+    }\n+\n+    public boolean supportsExpressionsInOrderBy() throws SQLException {\n+        return _metaData.supportsExpressionsInOrderBy();\n+    }\n+\n+    public boolean supportsExtendedSQLGrammar() throws SQLException {\n+        return _metaData.supportsExtendedSQLGrammar();\n+    }\n+\n+    public boolean supportsFullOuterJoins() throws SQLException {\n+        return _metaData.supportsFullOuterJoins();\n+    }\n+\n+    public boolean supportsGroupBy() throws SQLException {\n+        return _metaData.supportsGroupBy();\n+    }\n+\n+    public boolean supportsGroupByBeyondSelect() throws SQLException {\n+        return _metaData.supportsGroupByBeyondSelect();\n+    }\n+\n+    public boolean supportsGroupByUnrelated() throws SQLException {\n+        return _metaData.supportsGroupByUnrelated();\n+    }\n+\n+    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\n+        return _metaData.supportsIntegrityEnhancementFacility();\n+    }\n+\n+    public boolean supportsLikeEscapeClause() throws SQLException {\n+        return _metaData.supportsLikeEscapeClause();\n+    }\n+\n+    public boolean supportsLimitedOuterJoins() throws SQLException {\n+        return _metaData.supportsLimitedOuterJoins();\n+    }\n+\n+    public boolean supportsMinimumSQLGrammar() throws SQLException {\n+        return _metaData.supportsMinimumSQLGrammar();\n+    }\n+\n+    public boolean supportsMixedCaseIdentifiers() throws SQLException {\n+        return _metaData.supportsMixedCaseIdentifiers();\n+    }\n+\n+    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.supportsMixedCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean supportsMultipleResultSets() throws SQLException {\n+        return _metaData.supportsMultipleResultSets();\n+    }\n+\n+    public boolean supportsMultipleTransactions() throws SQLException {\n+        return _metaData.supportsMultipleTransactions();\n+    }\n+\n+    public boolean supportsNonNullableColumns() throws SQLException {\n+        return _metaData.supportsNonNullableColumns();\n+    }\n+\n+    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\n+        return _metaData.supportsOpenCursorsAcrossCommit();\n+    }\n+\n+    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\n+        return _metaData.supportsOpenCursorsAcrossRollback();\n+    }\n+\n+    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\n+        return _metaData.supportsOpenStatementsAcrossCommit();\n+    }\n+\n+    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\n+        return _metaData.supportsOpenStatementsAcrossRollback();\n+    }\n+\n+    public boolean supportsOrderByUnrelated() throws SQLException {\n+        return _metaData.supportsOrderByUnrelated();\n+    }\n+\n+    public boolean supportsOuterJoins() throws SQLException {\n+        return _metaData.supportsOuterJoins();\n+    }\n+\n+    public boolean supportsPositionedDelete() throws SQLException {\n+        return _metaData.supportsPositionedDelete();\n+    }\n+\n+    public boolean supportsPositionedUpdate() throws SQLException {\n+        return _metaData.supportsPositionedUpdate();\n+    }\n+\n+    public boolean supportsResultSetConcurrency(int type, int concurrency)\n+        throws SQLException {\n+        return _metaData.supportsResultSetConcurrency(type, concurrency);\n+    }\n+\n+    public boolean supportsResultSetType(int type) throws SQLException {\n+        return _metaData.supportsResultSetType(type);\n+    }\n+\n+    public boolean supportsSchemasInDataManipulation() throws SQLException {\n+        return _metaData.supportsSchemasInDataManipulation();\n+    }\n+\n+    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInIndexDefinitions();\n+    }\n+\n+    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInPrivilegeDefinitions();\n+    }\n+\n+    public boolean supportsSchemasInProcedureCalls() throws SQLException {\n+        return _metaData.supportsSchemasInProcedureCalls();\n+    }\n+\n+    public boolean supportsSchemasInTableDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInTableDefinitions();\n+    }\n+\n+    public boolean supportsSelectForUpdate() throws SQLException {\n+        return _metaData.supportsSelectForUpdate();\n+    }\n+\n+    public boolean supportsStoredProcedures() throws SQLException {\n+        return _metaData.supportsStoredProcedures();\n+    }\n+\n+    public boolean supportsSubqueriesInComparisons() throws SQLException {\n+        return _metaData.supportsSubqueriesInComparisons();\n+    }\n+\n+    public boolean supportsSubqueriesInExists() throws SQLException {\n+        return _metaData.supportsSubqueriesInExists();\n+    }\n+\n+    public boolean supportsSubqueriesInIns() throws SQLException {\n+        return _metaData.supportsSubqueriesInIns();\n+    }\n+\n+    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\n+        return _metaData.supportsSubqueriesInQuantifieds();\n+    }\n+\n+    public boolean supportsTableCorrelationNames() throws SQLException {\n+        return _metaData.supportsTableCorrelationNames();\n+    }\n+\n+    public boolean supportsTransactionIsolationLevel(int level)\n+        throws SQLException {\n+        return _metaData.supportsTransactionIsolationLevel(level);\n+    }\n+\n+    public boolean supportsTransactions() throws SQLException {\n+        return _metaData.supportsTransactions();\n+    }\n+\n+    public boolean supportsUnion() throws SQLException {\n+        return _metaData.supportsUnion();\n+    }\n+\n+    public boolean supportsUnionAll() throws SQLException {\n+        return _metaData.supportsUnionAll();\n+    }\n+\n+    public boolean updatesAreDetected(int type) throws SQLException {\n+        return _metaData.updatesAreDetected(type);\n+    }\n+\n+    public boolean usesLocalFilePerTable() throws SQLException {\n+        return _metaData.usesLocalFilePerTable();\n+    }\n+\n+    public boolean usesLocalFiles() throws SQLException {\n+        return _metaData.usesLocalFiles();\n+    }\n+\n+    // JDBC 3.0 methods(unsupported) follow; these are required to be able to\n+    // compile against JDK 1.4\n+\n+    public boolean supportsSavepoints() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsNamedParameters() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsMultipleOpenResults() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsGetGeneratedKeys() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getSuperTypes(String catalog, String schemaPatter,\n+        String typeNamePattern) throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getSuperTables(String catalog, String schemaPatter,\n+        String tableNamePattern) throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getAttributes(String catalog, String schemaPatter,\n+        String typeNamePattern, String attributeNamePattern)\n+        throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsResultSetHoldability(int holdability)\n+        throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getResultSetHoldability() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getDatabaseMajorVersion() throws SQLException {\n+        return _metaData.getDatabaseMajorVersion();\n+    }\n+\n+    public int getDatabaseMinorVersion() throws SQLException {\n+        return _metaData.getDatabaseMinorVersion();\n+    }\n+\n+    public int getJDBCMajorVersion() throws SQLException {\n+        return _metaData.getJDBCMajorVersion();\n+    }\n+\n+    public int getJDBCMinorVersion() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getSQLStateType() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean locatorsUpdateCopy() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsStatementPooling() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n+"},{"sha":"9eebc566c3e3ad02e0a90637e22163f10eda369b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"modified","additions":167,"deletions":167,"changes":334,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,167 +1,167 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-/**\r\n- * This class came from the Apache Commons Id sandbox project in support\r\n- * of the UUIDGenerator implementation.\r\n- *\r\n- * <p>Static methods for managing byte arrays (all methods follow Big\r\n- * Endian order where most significant bits are in front).</p>\r\n- */\r\n-public final class Bytes {\r\n-\r\n-    /**\r\n-     * <p>Hide constructor in utility class.</p>\r\n-     */\r\n-    private Bytes() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Appends two bytes array into one.\r\n-     *\r\n-     * @param a A byte[].\r\n-     * @param b A byte[].\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] append(byte[] a, byte[] b) {\r\n-        byte[] z = new byte[a.length + b.length];\r\n-        System.arraycopy(a, 0, z, 0, a.length);\r\n-        System.arraycopy(b, 0, z, a.length, b.length);\r\n-        return z;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a 8-byte array built from a long.\r\n-     *\r\n-     * @param n The number to convert.\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] toBytes(long n) {\r\n-        return toBytes(n, new byte[8]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a 8-byte array from a long.  No check is performed on the\r\n-     * array length.\r\n-     *\r\n-     * @param n The number to convert.\r\n-     * @param b The array to fill.\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] toBytes(long n, byte[] b) {\r\n-        b[7] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[6] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[5] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[4] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[3] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[2] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[1] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[0] = (byte) (n);\r\n-\r\n-        return b;\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a long from first 8 bytes of the array.\r\n-     *\r\n-     * @param b The byte[] to convert.\r\n-     * @return A long.\r\n-     */\r\n-    public static long toLong(byte[] b) {\r\n-        return ((((long) b[7]) & 0xFF)\r\n-                + ((((long) b[6]) & 0xFF) << 8)\r\n-                + ((((long) b[5]) & 0xFF) << 16)\r\n-                + ((((long) b[4]) & 0xFF) << 24)\r\n-                + ((((long) b[3]) & 0xFF) << 32)\r\n-                + ((((long) b[2]) & 0xFF) << 40)\r\n-                + ((((long) b[1]) & 0xFF) << 48)\r\n-                + ((((long) b[0]) & 0xFF) << 56));\r\n-    }\r\n-\r\n-    /**\r\n-    * Compares two byte arrays for equality.\r\n-    *\r\n-    * @param a A byte[].\r\n-    * @param b A byte[].\r\n-    * @return True if the arrays have identical contents.\r\n-    */\r\n-    public static boolean areEqual(byte[] a, byte[] b) {\r\n-        int aLength = a.length;\r\n-        if (aLength != b.length) {\r\n-            return false;\r\n-        }\r\n-\r\n-        for (int i = 0; i < aLength; i++) {\r\n-            if (a[i] != b[i]) {\r\n-                return false;\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Compares two byte arrays as specified by <code>Comparable</code>.\r\n-     *\r\n-     * @param lhs - left hand value in the comparison operation.\r\n-     * @param rhs - right hand value in the comparison operation.\r\n-     * @return  a negative integer, zero, or a positive integer as \r\n-     * <code>lhs</code> is less than, equal to, or greater than \r\n-     * <code>rhs</code>.\r\n-     */\r\n-    public static int compareTo(byte[] lhs, byte[] rhs) {\r\n-        if (lhs == rhs) {\r\n-            return 0;\r\n-        }\r\n-        if (lhs == null) {\r\n-            return -1;\r\n-        }\r\n-        if (rhs == null) {\r\n-            return +1;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            return ((lhs.length < rhs.length) ? -1 : +1);\r\n-        }\r\n-        for (int i = 0; i < lhs.length; i++) {\r\n-            if (lhs[i] < rhs[i]) {\r\n-                return -1;\r\n-            } else if (lhs[i] > rhs[i]) {\r\n-                return 1;\r\n-            }\r\n-        }\r\n-        return 0;\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a short from first 2 bytes of the array.\r\n-     *\r\n-     * @param b The byte[] to convert.\r\n-     * @return A short.\r\n-     */\r\n-    public static short toShort(byte[] b) {\r\n-        return  (short) ((b[1] & 0xFF) + ((b[0] & 0xFF) << 8));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.util;\n+\n+/**\n+ * This class came from the Apache Commons Id sandbox project in support\n+ * of the UUIDGenerator implementation.\n+ *\n+ * <p>Static methods for managing byte arrays (all methods follow Big\n+ * Endian order where most significant bits are in front).</p>\n+ */\n+public final class Bytes {\n+\n+    /**\n+     * <p>Hide constructor in utility class.</p>\n+     */\n+    private Bytes() {\n+    }\n+\n+    /**\n+     * Appends two bytes array into one.\n+     *\n+     * @param a A byte[].\n+     * @param b A byte[].\n+     * @return A byte[].\n+     */\n+    public static byte[] append(byte[] a, byte[] b) {\n+        byte[] z = new byte[a.length + b.length];\n+        System.arraycopy(a, 0, z, 0, a.length);\n+        System.arraycopy(b, 0, z, a.length, b.length);\n+        return z;\n+    }\n+\n+    /**\n+     * Returns a 8-byte array built from a long.\n+     *\n+     * @param n The number to convert.\n+     * @return A byte[].\n+     */\n+    public static byte[] toBytes(long n) {\n+        return toBytes(n, new byte[8]);\n+    }\n+\n+    /**\n+     * Build a 8-byte array from a long.  No check is performed on the\n+     * array length.\n+     *\n+     * @param n The number to convert.\n+     * @param b The array to fill.\n+     * @return A byte[].\n+     */\n+    public static byte[] toBytes(long n, byte[] b) {\n+        b[7] = (byte) (n);\n+        n >>>= 8;\n+        b[6] = (byte) (n);\n+        n >>>= 8;\n+        b[5] = (byte) (n);\n+        n >>>= 8;\n+        b[4] = (byte) (n);\n+        n >>>= 8;\n+        b[3] = (byte) (n);\n+        n >>>= 8;\n+        b[2] = (byte) (n);\n+        n >>>= 8;\n+        b[1] = (byte) (n);\n+        n >>>= 8;\n+        b[0] = (byte) (n);\n+\n+        return b;\n+    }\n+\n+    /**\n+     * Build a long from first 8 bytes of the array.\n+     *\n+     * @param b The byte[] to convert.\n+     * @return A long.\n+     */\n+    public static long toLong(byte[] b) {\n+        return ((((long) b[7]) & 0xFF)\n+                + ((((long) b[6]) & 0xFF) << 8)\n+                + ((((long) b[5]) & 0xFF) << 16)\n+                + ((((long) b[4]) & 0xFF) << 24)\n+                + ((((long) b[3]) & 0xFF) << 32)\n+                + ((((long) b[2]) & 0xFF) << 40)\n+                + ((((long) b[1]) & 0xFF) << 48)\n+                + ((((long) b[0]) & 0xFF) << 56));\n+    }\n+\n+    /**\n+    * Compares two byte arrays for equality.\n+    *\n+    * @param a A byte[].\n+    * @param b A byte[].\n+    * @return True if the arrays have identical contents.\n+    */\n+    public static boolean areEqual(byte[] a, byte[] b) {\n+        int aLength = a.length;\n+        if (aLength != b.length) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < aLength; i++) {\n+            if (a[i] != b[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Compares two byte arrays as specified by <code>Comparable</code>.\n+     *\n+     * @param lhs - left hand value in the comparison operation.\n+     * @param rhs - right hand value in the comparison operation.\n+     * @return  a negative integer, zero, or a positive integer as \n+     * <code>lhs</code> is less than, equal to, or greater than \n+     * <code>rhs</code>.\n+     */\n+    public static int compareTo(byte[] lhs, byte[] rhs) {\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null) {\n+            return -1;\n+        }\n+        if (rhs == null) {\n+            return +1;\n+        }\n+        if (lhs.length != rhs.length) {\n+            return ((lhs.length < rhs.length) ? -1 : +1);\n+        }\n+        for (int i = 0; i < lhs.length; i++) {\n+            if (lhs[i] < rhs[i]) {\n+                return -1;\n+            } else if (lhs[i] > rhs[i]) {\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Build a short from first 2 bytes of the array.\n+     *\n+     * @param b The byte[] to convert.\n+     * @return A short.\n+     */\n+    public static short toShort(byte[] b) {\n+        return  (short) ((b[1] & 0xFF) + ((b[0] & 0xFF) << 8));\n+    }\n+}"},{"sha":"fcea58dd616124f857324a3784039d3b59f9c6fd","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,63 +1,63 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.File;\r\n-import java.io.FileReader;\r\n-import java.io.IOException;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-\r\n-public class TestXMLCaseConversions extends TestCase {\r\n-\r\n-    public void testToXMLName() {\r\n-        assertEquals(\"easy-xml-conversion\", \r\n-            ConfigurationImpl.toXMLName(\"easyXmlConversion\"));\r\n-        assertEquals(\"initial-caps\", \r\n-            ConfigurationImpl.toXMLName(\"InitialCaps\"));\r\n-        assertEquals(\"nodash\", \r\n-            ConfigurationImpl.toXMLName(\"nodash\"));\r\n-        assertEquals(\"anothernodash\", \r\n-            ConfigurationImpl.toXMLName(\"Anothernodash\"));\r\n-        assertEquals(\"multiple-caps\", \r\n-            ConfigurationImpl.toXMLName(\"MUltipleCaps\"));\r\n-        assertEquals(\"trailing-multi-caps\", \r\n-            ConfigurationImpl.toXMLName(\"TrailingMultiCAPS\"));\r\n-        assertEquals(\"two-i-nner-caps\", \r\n-            ConfigurationImpl.toXMLName(\"TwoINnerCaps\"));\r\n-        assertEquals(\"four-inn-er-caps\", \r\n-            ConfigurationImpl.toXMLName(\"FourINNErCaps\"));\r\n-        assertEquals(\"inner-3-number\", \r\n-            ConfigurationImpl.toXMLName(\"Inner3Number\"));\r\n-        assertEquals(\"inner-03-number\", \r\n-            ConfigurationImpl.toXMLName(\"Inner03Number\"));\r\n-    }\r\n-    \r\n-    public static void main(String[] args) throws IOException {\r\n-        BufferedReader r = new BufferedReader (new FileReader(new File(args[0])));\r\n-        while (true) {\r\n-            String s = r.readLine();\r\n-            if (s == null)\r\n-                break;\r\n-            System.out.println(s + \": \" + ConfigurationImpl.toXMLName(s));\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+\n+public class TestXMLCaseConversions extends TestCase {\n+\n+    public void testToXMLName() {\n+        assertEquals(\"easy-xml-conversion\", \n+            ConfigurationImpl.toXMLName(\"easyXmlConversion\"));\n+        assertEquals(\"initial-caps\", \n+            ConfigurationImpl.toXMLName(\"InitialCaps\"));\n+        assertEquals(\"nodash\", \n+            ConfigurationImpl.toXMLName(\"nodash\"));\n+        assertEquals(\"anothernodash\", \n+            ConfigurationImpl.toXMLName(\"Anothernodash\"));\n+        assertEquals(\"multiple-caps\", \n+            ConfigurationImpl.toXMLName(\"MUltipleCaps\"));\n+        assertEquals(\"trailing-multi-caps\", \n+            ConfigurationImpl.toXMLName(\"TrailingMultiCAPS\"));\n+        assertEquals(\"two-i-nner-caps\", \n+            ConfigurationImpl.toXMLName(\"TwoINnerCaps\"));\n+        assertEquals(\"four-inn-er-caps\", \n+            ConfigurationImpl.toXMLName(\"FourINNErCaps\"));\n+        assertEquals(\"inner-3-number\", \n+            ConfigurationImpl.toXMLName(\"Inner3Number\"));\n+        assertEquals(\"inner-03-number\", \n+            ConfigurationImpl.toXMLName(\"Inner03Number\"));\n+    }\n+    \n+    public static void main(String[] args) throws IOException {\n+        BufferedReader r = new BufferedReader (new FileReader(new File(args[0])));\n+        while (true) {\n+            String s = r.readLine();\n+            if (s == null)\n+                break;\n+            System.out.println(s + \": \" + ConfigurationImpl.toXMLName(s));\n+        }\n+    }\n+}"},{"sha":"e06648dc6642844a5e502df682eb7213b41f2abc","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,109 +1,109 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf.test;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.IOException;\r\n-import java.net.URL;\r\n-import java.util.MissingResourceException;\r\n-import java.util.Properties;\r\n-\r\n-import org.apache.openjpa.lib.conf.AbstractProductDerivation;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-\r\n-/**\r\n- * A Product Derivation to test loading of global and default configuration with\r\n- * System settings.  Reads its global from a file specified by \r\n- * <code>\"openjpatest.properties\"</code> system property.\r\n- *\r\n- * @author Pinaki Poddar\r\n- * @author Abe White\r\n- */\r\n-public class ConfigurationTestProductDerivation \r\n-    extends AbstractProductDerivation {\r\n-    \r\n-    public static boolean closed = false;\r\n-\r\n-    public int getType() {\r\n-        return ProductDerivation.TYPE_PRODUCT;\r\n-    }\r\n-    \r\n-    public void beforeConfigurationClose(Configuration conf) {\r\n-        closed = true;\r\n-    }\r\n-\r\n-    public ConfigurationProvider loadGlobals(ClassLoader loader)\r\n-        throws IOException {\r\n-        return load(null, loader);\r\n-    }\r\n-\r\n-    public ConfigurationProvider load(String rsrc, ClassLoader loader)\r\n-        throws IOException {\r\n-        if (rsrc == null)\r\n-            rsrc = System.getProperty(\"openjpatest.properties\");\r\n-        if (rsrc == null || !rsrc.endsWith(\".properties\"))\r\n-            return null;\r\n-\r\n-        URL url = findResource(rsrc, loader);\r\n-        if (url == null)\r\n-            throw new MissingResourceException(rsrc, getClass().getName(), \r\n-                rsrc);\r\n-\r\n-        InputStream in = url.openStream();\r\n-        Properties props = new Properties();\r\n-        if (in != null) {\r\n-            try {\r\n-                props.load(in);\r\n-                return new MapConfigurationProvider(props);\r\n-            } finally {\r\n-                try { in.close(); } catch (Exception e) {}\r\n-            }\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Locate the given resource.\r\n-     */\r\n-    private URL findResource(String rsrc, ClassLoader loader)\r\n-        throws IOException {\r\n-        if (loader != null)\r\n-            return loader.getResource(rsrc);\r\n-\r\n-        // in jbuilder the classloader can be null\r\n-        URL url = null;\r\n-        loader = getClass().getClassLoader();\r\n-        if (loader != null)\r\n-            url = loader.getResource(rsrc);\r\n-        if (url == null) {\r\n-            loader = Thread.currentThread().getContextClassLoader();\r\n-            if (loader != null)\r\n-                url = loader.getResource(rsrc);\r\n-        }\r\n-        if (url == null) {\r\n-            loader = ClassLoader.getSystemClassLoader();\r\n-            if (loader != null)\r\n-                url = loader.getResource(rsrc);\r\n-        }\r\n-        return url;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf.test;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.MissingResourceException;\n+import java.util.Properties;\n+\n+import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+\n+/**\n+ * A Product Derivation to test loading of global and default configuration with\n+ * System settings.  Reads its global from a file specified by \n+ * <code>\"openjpatest.properties\"</code> system property.\n+ *\n+ * @author Pinaki Poddar\n+ * @author Abe White\n+ */\n+public class ConfigurationTestProductDerivation \n+    extends AbstractProductDerivation {\n+    \n+    public static boolean closed = false;\n+\n+    public int getType() {\n+        return ProductDerivation.TYPE_PRODUCT;\n+    }\n+    \n+    public void beforeConfigurationClose(Configuration conf) {\n+        closed = true;\n+    }\n+\n+    public ConfigurationProvider loadGlobals(ClassLoader loader)\n+        throws IOException {\n+        return load(null, loader);\n+    }\n+\n+    public ConfigurationProvider load(String rsrc, ClassLoader loader)\n+        throws IOException {\n+        if (rsrc == null)\n+            rsrc = System.getProperty(\"openjpatest.properties\");\n+        if (rsrc == null || !rsrc.endsWith(\".properties\"))\n+            return null;\n+\n+        URL url = findResource(rsrc, loader);\n+        if (url == null)\n+            throw new MissingResourceException(rsrc, getClass().getName(), \n+                rsrc);\n+\n+        InputStream in = url.openStream();\n+        Properties props = new Properties();\n+        if (in != null) {\n+            try {\n+                props.load(in);\n+                return new MapConfigurationProvider(props);\n+            } finally {\n+                try { in.close(); } catch (Exception e) {}\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Locate the given resource.\n+     */\n+    private URL findResource(String rsrc, ClassLoader loader)\n+        throws IOException {\n+        if (loader != null)\n+            return loader.getResource(rsrc);\n+\n+        // in jbuilder the classloader can be null\n+        URL url = null;\n+        loader = getClass().getClassLoader();\n+        if (loader != null)\n+            url = loader.getResource(rsrc);\n+        if (url == null) {\n+            loader = Thread.currentThread().getContextClassLoader();\n+            if (loader != null)\n+                url = loader.getResource(rsrc);\n+        }\n+        if (url == null) {\n+            loader = ClassLoader.getSystemClassLoader();\n+            if (loader != null)\n+                url = loader.getResource(rsrc);\n+        }\n+        return url;\n+    }\n+}"},{"sha":"1df285153bb30953b5a7799b6be28fdd79b236bb","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":152,"deletions":152,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.lib.test.AbstractTestCase;\r\n-\r\n-/**\r\n- * <p>Tests the {@link DepthFirstAnalysis} type.</p>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class TestDepthFirstAnalysis\r\n-    extends AbstractTestCase {\r\n-\r\n-    private DepthFirstAnalysis _dfa = null;\r\n-\r\n-    public void setUp() {\r\n-        setUpGraph1();   \r\n-    }\r\n-    \r\n-    public void setUpGraph1() {\r\n-        Graph graph = new Graph();\r\n-        Object node1 = new Object();\r\n-        Object node2 = new Object();\r\n-        Object node3 = new Object();\r\n-        Object node4 = new Object();\r\n-        graph.addNode(node1);\r\n-        graph.addNode(node2);\r\n-        graph.addNode(node3);\r\n-        graph.addNode(node4);\r\n-        graph.addEdge(new Edge(node1, node2, true));\r\n-        graph.addEdge(new Edge(node2, node3, true));\r\n-        graph.addEdge(new Edge(node3, node1, true));\r\n-        graph.addEdge(new Edge(node3, node4, true));\r\n-        graph.addEdge(new Edge(node2, node2, true));\r\n-        _dfa = new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    public void setUpGraph2() {\r\n-        Graph graph = new Graph();\r\n-        Integer node1 = new Integer(1);\r\n-        Integer node2 = new Integer(2);\r\n-        Integer node3 = new Integer(3);\r\n-        Integer node4 = new Integer(4);\r\n-        Integer node5 = new Integer(5);\r\n-        graph.addNode(node2);  // has to be first node for testcase\r\n-        graph.addNode(node5);\r\n-        graph.addNode(node4);\r\n-        graph.addNode(node3);\r\n-        graph.addNode(node1);\r\n-        graph.addEdge(new Edge(node5, node4, true));\r\n-        graph.addEdge(new Edge(node4, node3, true));\r\n-        graph.addEdge(new Edge(node3, node3, true));\r\n-        graph.addEdge(new Edge(node3, node2, true));\r\n-        graph.addEdge(new Edge(node2, node5, true));\r\n-        graph.addEdge(new Edge(node2, node4, true));\r\n-        graph.addEdge(new Edge(node1, node4, true));\r\n-        _dfa = new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    public void testNodeSorting() {\r\n-        Collection nodes = _dfa.getSortedNodes();\r\n-        assertEquals(4, nodes.size());\r\n-\r\n-        int time = 0;\r\n-        Object node;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            assertTrue(time <= _dfa.getFinishedTime(node));\r\n-            time = _dfa.getFinishedTime(node);\r\n-        }\r\n-    }\r\n-\r\n-    public void testEdgeTyping() {\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0.getTo().equals(edge0.getFrom()))\r\n-                || edge1.getTo().equals(edge1.getFrom()));\r\n-    }\r\n-\r\n-    public void testBackEdges() {\r\n-        setUpGraph2();\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        if (edge0.getTo().equals(edge0.getFrom())) {\r\n-            assertTrue(edge0.getCycle() != null && edge0.getCycle().size() == 1);\r\n-            List cycle = edge1.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 4);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\r\n-        } else if (edge1.getTo().equals(edge1.getFrom())) {\r\n-            assertTrue(edge1.getCycle() != null && edge1.getCycle().size() == 1);            \r\n-            assertTrue(edge1 == edge1.getCycle());\r\n-            List cycle = edge0.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 4);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\r\n-        } else {\r\n-            // should not happen\r\n-            assertFalse(true);\r\n-        }\r\n-    }\r\n-    \r\n-    public void testForwardEdges() {\r\n-        setUpGraph2();\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_FORWARD);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        if (edge0.getCycle() == null) {\r\n-            List cycle = edge1.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 3);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\r\n-        } else if (edge1.getCycle() == null) {\r\n-            List cycle = edge0.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 3);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\r\n-        } else {\r\n-            // should not happen\r\n-            assertFalse(true);\r\n-        }\r\n-    }\r\n-    \r\n-    public static void main(String[] args) {\r\n-        main(TestDepthFirstAnalysis.class);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.test.AbstractTestCase;\n+\n+/**\n+ * <p>Tests the {@link DepthFirstAnalysis} type.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class TestDepthFirstAnalysis\n+    extends AbstractTestCase {\n+\n+    private DepthFirstAnalysis _dfa = null;\n+\n+    public void setUp() {\n+        setUpGraph1();   \n+    }\n+    \n+    public void setUpGraph1() {\n+        Graph graph = new Graph();\n+        Object node1 = new Object();\n+        Object node2 = new Object();\n+        Object node3 = new Object();\n+        Object node4 = new Object();\n+        graph.addNode(node1);\n+        graph.addNode(node2);\n+        graph.addNode(node3);\n+        graph.addNode(node4);\n+        graph.addEdge(new Edge(node1, node2, true));\n+        graph.addEdge(new Edge(node2, node3, true));\n+        graph.addEdge(new Edge(node3, node1, true));\n+        graph.addEdge(new Edge(node3, node4, true));\n+        graph.addEdge(new Edge(node2, node2, true));\n+        _dfa = new DepthFirstAnalysis(graph);\n+    }\n+\n+    public void setUpGraph2() {\n+        Graph graph = new Graph();\n+        Integer node1 = new Integer(1);\n+        Integer node2 = new Integer(2);\n+        Integer node3 = new Integer(3);\n+        Integer node4 = new Integer(4);\n+        Integer node5 = new Integer(5);\n+        graph.addNode(node2);  // has to be first node for testcase\n+        graph.addNode(node5);\n+        graph.addNode(node4);\n+        graph.addNode(node3);\n+        graph.addNode(node1);\n+        graph.addEdge(new Edge(node5, node4, true));\n+        graph.addEdge(new Edge(node4, node3, true));\n+        graph.addEdge(new Edge(node3, node3, true));\n+        graph.addEdge(new Edge(node3, node2, true));\n+        graph.addEdge(new Edge(node2, node5, true));\n+        graph.addEdge(new Edge(node2, node4, true));\n+        graph.addEdge(new Edge(node1, node4, true));\n+        _dfa = new DepthFirstAnalysis(graph);\n+    }\n+\n+    public void testNodeSorting() {\n+        Collection nodes = _dfa.getSortedNodes();\n+        assertEquals(4, nodes.size());\n+\n+        int time = 0;\n+        Object node;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            assertTrue(time <= _dfa.getFinishedTime(node));\n+            time = _dfa.getFinishedTime(node);\n+        }\n+    }\n+\n+    public void testEdgeTyping() {\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0.getTo().equals(edge0.getFrom()))\n+                || edge1.getTo().equals(edge1.getFrom()));\n+    }\n+\n+    public void testBackEdges() {\n+        setUpGraph2();\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        if (edge0.getTo().equals(edge0.getFrom())) {\n+            assertTrue(edge0.getCycle() != null && edge0.getCycle().size() == 1);\n+            List cycle = edge1.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 4);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\n+        } else if (edge1.getTo().equals(edge1.getFrom())) {\n+            assertTrue(edge1.getCycle() != null && edge1.getCycle().size() == 1);            \n+            assertTrue(edge1 == edge1.getCycle());\n+            List cycle = edge0.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 4);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\n+        } else {\n+            // should not happen\n+            assertFalse(true);\n+        }\n+    }\n+    \n+    public void testForwardEdges() {\n+        setUpGraph2();\n+        Collection edges = _dfa.getEdges(Edge.TYPE_FORWARD);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        if (edge0.getCycle() == null) {\n+            List cycle = edge1.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 3);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\n+        } else if (edge1.getCycle() == null) {\n+            List cycle = edge0.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 3);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\n+        } else {\n+            // should not happen\n+            assertFalse(true);\n+        }\n+    }\n+    \n+    public static void main(String[] args) {\n+        main(TestDepthFirstAnalysis.class);\n+    }\n+}"},{"sha":"3b21530ffeb82b4c131a042d4b88c688da26bc08","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,148 +1,148 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.openjpa.lib.test.AbstractTestCase;\r\n-\r\n-/**\r\n- * <p>Tests the {@link Graph} type, and in so doing implicitly tests the\r\n- * {@link Edge} as well.</p>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class TestGraph\r\n-    extends AbstractTestCase {\r\n-\r\n-    private Graph _graph = new Graph();\r\n-    private Object _node1 = new Object();\r\n-    private Object _node2 = new Object();\r\n-    private Object _node3 = new Object();\r\n-    private Edge _edge1 = new Edge(_node1, _node2, true);\r\n-    private Edge _edge2 = new Edge(_node2, _node3, true);\r\n-    private Edge _edge3 = new Edge(_node1, _node3, false);\r\n-    private Edge _edge4 = new Edge(_node2, _node2, false);\r\n-\r\n-    public void setUp() {\r\n-        _graph.addNode(_node1);\r\n-        _graph.addNode(_node2);\r\n-        _graph.addNode(_node3);\r\n-        _graph.addEdge(_edge1);\r\n-        _graph.addEdge(_edge2);\r\n-        _graph.addEdge(_edge3);\r\n-        _graph.addEdge(_edge4);\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests adding and retrieving nodes and edges.\r\n-     */\r\n-    public void testAddRetrieve() {\r\n-        assertEquals(3, _graph.getNodes().size());\r\n-        assertEquals(4, _graph.getEdges().size());\r\n-\r\n-        Collection edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge3)\r\n-            || (edge0 == _edge3 && edge1 == _edge1));\r\n-\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdges(_node1, _node3);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-        edges = _graph.getEdges(_node3, _node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdgesFrom(_node2);\r\n-        assertEquals(2, edges.size());\r\n-        itr = edges.iterator();\r\n-        edge0 = (Edge) itr.next();\r\n-        edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge2 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge2));\r\n-\r\n-        edges = _graph.getEdgesTo(_node2);\r\n-        assertEquals(2, edges.size());\r\n-        itr = edges.iterator();\r\n-        edge0 = (Edge) itr.next();\r\n-        edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge1));\r\n-\r\n-        edges = _graph.getEdges(_node2, _node2);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge4, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdgesFrom(_node3);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test removing edges.\r\n-     */\r\n-    public void testRemoveEdges() {\r\n-        assertTrue(_graph.removeEdge(_edge2));\r\n-        Collection edges = _graph.getEdgesFrom(_node2);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge4, edges.iterator().next());\r\n-\r\n-        assertTrue(_graph.removeEdge(_edge3));\r\n-        edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge1, edges.iterator().next());\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(0, edges.size());\r\n-        edges = _graph.getEdgesTo(_node3);\r\n-        assertEquals(0, edges.size());\r\n-        edges = _graph.getEdgesFrom(_node3);\r\n-        assertEquals(0, edges.size());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test removing nodes.\r\n-     */\r\n-    public void testRemoveNodes() {\r\n-        assertTrue(_graph.removeNode(_node3));\r\n-        Collection edges = _graph.getEdges();\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge1));\r\n-        edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge1, edges.iterator().next());\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(0, edges.size());\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-        main(TestGraph.class);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.lib.test.AbstractTestCase;\n+\n+/**\n+ * <p>Tests the {@link Graph} type, and in so doing implicitly tests the\n+ * {@link Edge} as well.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class TestGraph\n+    extends AbstractTestCase {\n+\n+    private Graph _graph = new Graph();\n+    private Object _node1 = new Object();\n+    private Object _node2 = new Object();\n+    private Object _node3 = new Object();\n+    private Edge _edge1 = new Edge(_node1, _node2, true);\n+    private Edge _edge2 = new Edge(_node2, _node3, true);\n+    private Edge _edge3 = new Edge(_node1, _node3, false);\n+    private Edge _edge4 = new Edge(_node2, _node2, false);\n+\n+    public void setUp() {\n+        _graph.addNode(_node1);\n+        _graph.addNode(_node2);\n+        _graph.addNode(_node3);\n+        _graph.addEdge(_edge1);\n+        _graph.addEdge(_edge2);\n+        _graph.addEdge(_edge3);\n+        _graph.addEdge(_edge4);\n+    }\n+\n+    /**\n+     * Tests adding and retrieving nodes and edges.\n+     */\n+    public void testAddRetrieve() {\n+        assertEquals(3, _graph.getNodes().size());\n+        assertEquals(4, _graph.getEdges().size());\n+\n+        Collection edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge3)\n+            || (edge0 == _edge3 && edge1 == _edge1));\n+\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+\n+        edges = _graph.getEdges(_node1, _node3);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+        edges = _graph.getEdges(_node3, _node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+\n+        edges = _graph.getEdgesFrom(_node2);\n+        assertEquals(2, edges.size());\n+        itr = edges.iterator();\n+        edge0 = (Edge) itr.next();\n+        edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge2 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge2));\n+\n+        edges = _graph.getEdgesTo(_node2);\n+        assertEquals(2, edges.size());\n+        itr = edges.iterator();\n+        edge0 = (Edge) itr.next();\n+        edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge1));\n+\n+        edges = _graph.getEdges(_node2, _node2);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge4, edges.iterator().next());\n+\n+        edges = _graph.getEdgesFrom(_node3);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+    }\n+\n+    /**\n+     * Test removing edges.\n+     */\n+    public void testRemoveEdges() {\n+        assertTrue(_graph.removeEdge(_edge2));\n+        Collection edges = _graph.getEdgesFrom(_node2);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge4, edges.iterator().next());\n+\n+        assertTrue(_graph.removeEdge(_edge3));\n+        edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge1, edges.iterator().next());\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(0, edges.size());\n+        edges = _graph.getEdgesTo(_node3);\n+        assertEquals(0, edges.size());\n+        edges = _graph.getEdgesFrom(_node3);\n+        assertEquals(0, edges.size());\n+    }\n+\n+    /**\n+     * Test removing nodes.\n+     */\n+    public void testRemoveNodes() {\n+        assertTrue(_graph.removeNode(_node3));\n+        Collection edges = _graph.getEdges();\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge1));\n+        edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge1, edges.iterator().next());\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(0, edges.size());\n+    }\n+\n+    public static void main(String[] args) {\n+        main(TestGraph.class);\n+\t}\n+}"},{"sha":"fb440e74af504743de2b0c79803d7c32fe8659e6","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":1562,"deletions":1562,"changes":3124,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"6110d8e41c3e69050541117f7e8875b1b8f9e1f1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":400,"deletions":400,"changes":800,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,400 +1,400 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-import java.io.BufferedInputStream;\r\n-import java.io.BufferedReader;\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.StringBufferInputStream;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.List;\r\n-import java.util.Properties;\r\n-\r\n-import junit.framework.TestCase;\r\n-import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\r\n-\r\n-// things to test:\r\n-// - delimiters in keys\r\n-// - escape chars, including \\:, \\= in files(as generated by Properties)\r\n-// - unicode\r\n-// - non-String keys / vals\r\n-// - list() method behavior\r\n-\r\n-public class TestPropertiesParser extends TestCase {\r\n-\r\n-    private static final String LS = System.getProperty( \"line.separator\" );\r\n-\r\n-    public void testSimpleProperties() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"key: value\" + LS);\r\n-        buf.append(\"key2: value2\"); // no EOL -- this is intentional\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{\r\n-            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\r\n-    }\r\n-\r\n-    public void testComments() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"# this is a comment\" + LS);\r\n-        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n-        buf.append(\" \t# \tand more with interesting whitespace\t\" + LS);\r\n-        buf.append(\"! and with a ! delimiter\" + LS);\r\n-        buf.append(\"! and with escape \\t chars\" + LS);\r\n-        buf.append(\"#and a comment with no whitespace\" + LS);\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertEquals(0, p.size());\r\n-    }\r\n-\r\n-    public void testMixedContent() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"# this is a comment\" + LS);\r\n-        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n-        buf.append(\"foo: bar#baz\" + LS);\r\n-        buf.append(\"! and with a ! delimiter\" + LS);\r\n-        buf.append(\"! and with escape \\t chars\" + LS);\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\r\n-    }\r\n-\r\n-    public void testMultiLineInput() throws IOException {\r\n-        String s = \"foo: bar\\\\\" + LS + \"more line goes here\";\r\n-        Properties p = toProperties(s);\r\n-        assertProperties(\r\n-            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\r\n-    }\r\n-\r\n-    public void testEmptyLines() throws IOException {\r\n-        Properties p = toProperties(LS + \"foo: bar\" + LS + LS + \"baz: val\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-    }\r\n-\r\n-    public void testAddProperties() throws IOException {\r\n-        // intentionally left out the trailing end line\r\n-        String s = \"foo: bar\" + LS + \"baz: val\";\r\n-        Properties p = toProperties(s);\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-\r\n-        p.put(\"new-key\", \"val1\");\r\n-        p.put(\"new-key-2\", \"val2\");\r\n-        p.put(\"another-new-key\", \"val3\");\r\n-        assertRoundTrip(s + LS + \"new-key: val1\" + LS + \"new-key-2: val2\" + LS +\r\n-            \"another-new-key: val3\" + LS, p);\r\n-    }\r\n-\r\n-    public void testAddAndMutateProperties() throws IOException {\r\n-        // intentionally left out the trailing end line\r\n-        Properties p = toProperties(\"foo: bar\" + LS + \"baz: val\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-\r\n-        p.put(\"new-key\", \"new value\");\r\n-        p.put(\"foo\", \"barbar\");\r\n-        assertRoundTrip(\"foo: barbar\" + LS + \"baz: val\" + LS \r\n-            + \"new-key: new value\" + LS, p);\r\n-    }\r\n-\r\n-    public void testEscapedEquals() throws IOException {\r\n-        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\r\n-    }\r\n-\r\n-    public void testLineTypes() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"   !comment\" + LS + \" \\t  \" + LS + \"name = no\" + LS + \"    \"\r\n-            + \"#morec\\tomm\\\\\" + LS + \"ents\" + LS + LS + \"  dog=no\\\\cat   \" + LS \r\n-            + \"burps    :\" + LS + \"test=\" + LS + \"date today\" + LS + LS + LS \r\n-            + \"long\\\\\" + LS + \"   value=tryin \\\\\" + LS + \" \"\r\n-            + \"gto\" + LS + \"4:vier\" + LS + \"vier     :4\");\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{\r\n-            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\r\n-            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\r\n-            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\r\n-        }, p);\r\n-    }\r\n-\r\n-    public void testSpecialChars() throws Throwable {\r\n-        testSpecialChars(false, true);\r\n-        testSpecialChars(true, true);\r\n-        testSpecialChars(false, false);\r\n-        testSpecialChars(true, false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Test that special characters work.\r\n-     *\r\n-     * @param formattingProps if true, test against the\r\n-     * FormatPreservingProperties, otherwise test\r\n-     * against a normal Properties instance(for validation of the test case).\r\n-     * @param value whether to test the key or the value\r\n-     */\r\n-    public void testSpecialChars(boolean formattingProps, boolean value)\r\n-        throws Throwable {\r\n-        List valueList = new ArrayList(Arrays.asList(new String[]{\r\n-            \"xxyy\", \"xx\\\\yy\", \"xx\" + LS + \"yy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\r\n-            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\" + LS + \"\\\\\\t\\r\\t\" \r\n-            + LS + \"yy\",\r\n-            \"xx\\\\r\" + LS + \"\\\\\\t\\\\r\\t\\\\nyy\",\r\n-            \"xx\\r\" + LS + \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\" + LS + \"yy\",\r\n-            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\r\n-\r\n-        // also store every individual character\r\n-        for (char c = 'a'; c < 'Z'; c++) {\r\n-            valueList.add(new String(new char[]{ c }));\r\n-            valueList.add(new String(new char[]{ c, '\\\\', c }));\r\n-            valueList.add(new String(new char[]{ '\\\\', c }));\r\n-        }\r\n-\r\n-        String[] values = (String[]) valueList.toArray(new String[0]);\r\n-\r\n-        final String dummy = \"XXX\";\r\n-\r\n-        for (int i = 0; i < values.length; i++) {\r\n-            // test special characters in either keys or values\r\n-            String val = value ? values[i] : dummy;\r\n-            String key = value ? dummy : values[i];\r\n-\r\n-            Properties p = formattingProps ?\r\n-                new FormatPreservingProperties() : new Properties();\r\n-            if (p instanceof FormatPreservingProperties) {\r\n-                // set these properties so we behave the same way as\r\n-                // java.util.Properties\r\n-                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\r\n-                ((FormatPreservingProperties) p).\r\n-                    setAddWhitespaceAfterDelimiter(false);\r\n-            }\r\n-\r\n-            p.setProperty(key, val);\r\n-            ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-            p.store(out, null);\r\n-\r\n-            Properties copy = new Properties();\r\n-            copy.setProperty(key, val);\r\n-            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\r\n-            copy.store(copyOut, null);\r\n-\r\n-            p = formattingProps ?\r\n-                new FormatPreservingProperties() : new Properties();\r\n-\r\n-            InputStream in = new BufferedInputStream\r\n-                (new ByteArrayInputStream(out.toByteArray()));\r\n-\r\n-            try {\r\n-                // make sure that the 2 properties serialized are the same\r\n-                String copyOutString = stripComments(copyOut.toByteArray());\r\n-                String outString = stripComments(out.toByteArray());\r\n-                assertEquals(copyOutString, outString);\r\n-\r\n-                p.load(in);\r\n-\r\n-                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\r\n-                    p.getProperty(key));\r\n-                assertEquals(val.trim(), p.getProperty(key).trim());\r\n-            } catch (Throwable ioe) {\r\n-                if (!formattingProps)\r\n-                    throw ioe;\r\n-\r\n-                // bug(1211, ioe,\r\n-                // \"Cannot store backslash in FormatPreservingProperties\");\r\n-                throw ioe;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    static Character randomChar() {\r\n-        char [] TEST_CHAR_ARRAY = new char []{\r\n-            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\r\n-            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\r\n-            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\r\n-            '2', '3', '4', '5', '6', '7', '8', '9' };\r\n-\r\n-        return new Character(TEST_CHAR_ARRAY[\r\n-            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\r\n-    }\r\n-\r\n-    static String randomString(int len) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\r\n-            buf.append(randomChar());\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public void testEquivalentStore() throws IOException {\r\n-        Properties p1 = new Properties();\r\n-        FormatPreservingProperties p2 = new FormatPreservingProperties();\r\n-\r\n-        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\r\n-        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\r\n-\r\n-        String[] values =\r\n-            new String[] { \r\n-                \"x\", \r\n-                \"x\" + LS + \"y\", \r\n-                \"x\\\\ny\", \r\n-                \"x\\ty\", \r\n-                \"x\\\\ty\",\r\n-                \"x\\fy\", \r\n-                \"x\\\\fy\", \r\n-                \"x\\ry\", \r\n-                \"x\\\\ry\", \r\n-                \"C:\\\\Foo Bar\\\\Baz\",\r\n-                randomString(5).replace('a', '\\\\'),\r\n-                randomString(500).replace('a', '\\\\'),\r\n-                randomString(5000).replace('a', '\\\\'), \r\n-                };\r\n-\r\n-        for (int i = 0; i < values.length; i++) {\r\n-            p1.clear();\r\n-            p2.clear();\r\n-\r\n-            p1.setProperty(\"xxx\", values[i]);\r\n-            p2.setProperty(\"xxx\", values[i]);\r\n-\r\n-            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n-            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\r\n-\r\n-            p1.store(out1, null);\r\n-            p2.store(out2, null);\r\n-\r\n-            String s1 = new String(out1.toByteArray());\r\n-            String s2 = new String(out2.toByteArray());\r\n-\r\n-            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\r\n-                s1.indexOf(s2) != -1);\r\n-        }\r\n-    }\r\n-\r\n-    static String stripComments(byte[] bytes) throws IOException {\r\n-        BufferedReader reader = new BufferedReader(new InputStreamReader\r\n-            (new ByteArrayInputStream(bytes)));\r\n-        StringBuffer sbuf = new StringBuffer();\r\n-        String line;\r\n-        while ((line = reader.readLine()) != null) {\r\n-            // skip comments\r\n-            if (line.trim().startsWith(\"#\"))\r\n-                continue;\r\n-\r\n-            sbuf.append(line);\r\n-            sbuf.append(LS);\r\n-        }\r\n-\r\n-        return sbuf.toString();\r\n-    }\r\n-\r\n-    public void testDuplicateProperties() throws IOException {\r\n-        FormatPreservingProperties p = new FormatPreservingProperties();\r\n-        try {\r\n-            toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n-            fail(\"expected duplicate keys to cause exception\");\r\n-        } catch (DuplicateKeyException e) {\r\n-            // expected\r\n-        }\r\n-\r\n-        // now test the expected behavior when duplicates are allowed.\r\n-        p = new FormatPreservingProperties();\r\n-        p.setAllowDuplicates(true);\r\n-        toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n-        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\r\n-    }\r\n-\r\n-    public void testMultipleLoads() throws IOException {\r\n-        String props = \"foo=bar\" + LS + \"baz=quux\";\r\n-        String props2 = \"a=b\" + LS + \"c=d\";\r\n-        Properties vanilla = new Properties();\r\n-        vanilla.load(new BufferedInputStream\r\n-            (new StringBufferInputStream(props)));\r\n-        vanilla.load(new BufferedInputStream\r\n-            (new StringBufferInputStream(props2)));\r\n-\r\n-        Properties p = new FormatPreservingProperties();\r\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\r\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\r\n-        assertPropertiesSame(vanilla, p);\r\n-    }\r\n-\r\n-    protected FormatPreservingProperties toProperties(String s)\r\n-        throws IOException {\r\n-        return toProperties(s, new FormatPreservingProperties());\r\n-    }\r\n-\r\n-    protected FormatPreservingProperties toProperties(String s,\r\n-        FormatPreservingProperties p) throws IOException {\r\n-        Properties vanilla = new Properties();\r\n-        vanilla.load(new StringBufferInputStream(s));\r\n-\r\n-        p.load(new StringBufferInputStream(s));\r\n-        assertRoundTrip(s, p);\r\n-\r\n-        assertPropertiesSame(vanilla, p);\r\n-\r\n-        return p;\r\n-    }\r\n-\r\n-    private void assertRoundTrip(String s, Properties p) throws IOException {\r\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-        p.store(out, null);\r\n-        assertEquals(s, out.toString());\r\n-\r\n-        // also check serializable\r\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n-        new ObjectOutputStream(bout).writeObject(p);\r\n-\r\n-        try {\r\n-            FormatPreservingProperties deserialized =\r\n-                (FormatPreservingProperties) new ObjectInputStream\r\n-                    (new ByteArrayInputStream(bout.toByteArray())).\r\n-                    readObject();\r\n-            assertEquals(p, deserialized);\r\n-\r\n-            out = new ByteArrayOutputStream();\r\n-            deserialized.store(out, null);\r\n-            assertEquals(s, out.toString());\r\n-        } catch (ClassNotFoundException cnfe) {\r\n-            fail(cnfe + \"\");\r\n-        }\r\n-    }\r\n-\r\n-    public static void assertEquals(String expected, String actual) {\r\n-        if (expected == actual)\r\n-            return;\r\n-\r\n-        if (expected == null || !expected.equals(actual))\r\n-            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\r\n-    }\r\n-\r\n-    private void assertPropertiesSame(Properties vanilla, Properties p) {\r\n-        assertEquals(vanilla, p);\r\n-    }\r\n-\r\n-    protected void assertProperties(String[][] strings, Properties p) {\r\n-        for (int i = 0; i < strings.length; i++)\r\n-            assertEquals(strings[i][1], p.get(strings[i][0]));\r\n-\r\n-        assertEquals(strings.length, p.size());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.StringBufferInputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\n+\n+// things to test:\n+// - delimiters in keys\n+// - escape chars, including \\:, \\= in files(as generated by Properties)\n+// - unicode\n+// - non-String keys / vals\n+// - list() method behavior\n+\n+public class TestPropertiesParser extends TestCase {\n+\n+    private static final String LS = System.getProperty( \"line.separator\" );\n+\n+    public void testSimpleProperties() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"key: value\" + LS);\n+        buf.append(\"key2: value2\"); // no EOL -- this is intentional\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{\n+            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\n+    }\n+\n+    public void testComments() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\" + LS);\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\n+        buf.append(\" \t# \tand more with interesting whitespace\t\" + LS);\n+        buf.append(\"! and with a ! delimiter\" + LS);\n+        buf.append(\"! and with escape \\t chars\" + LS);\n+        buf.append(\"#and a comment with no whitespace\" + LS);\n+        Properties p = toProperties(buf.toString());\n+        assertEquals(0, p.size());\n+    }\n+\n+    public void testMixedContent() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\" + LS);\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\n+        buf.append(\"foo: bar#baz\" + LS);\n+        buf.append(\"! and with a ! delimiter\" + LS);\n+        buf.append(\"! and with escape \\t chars\" + LS);\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\n+    }\n+\n+    public void testMultiLineInput() throws IOException {\n+        String s = \"foo: bar\\\\\" + LS + \"more line goes here\";\n+        Properties p = toProperties(s);\n+        assertProperties(\n+            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\n+    }\n+\n+    public void testEmptyLines() throws IOException {\n+        Properties p = toProperties(LS + \"foo: bar\" + LS + LS + \"baz: val\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+    }\n+\n+    public void testAddProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        String s = \"foo: bar\" + LS + \"baz: val\";\n+        Properties p = toProperties(s);\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+\n+        p.put(\"new-key\", \"val1\");\n+        p.put(\"new-key-2\", \"val2\");\n+        p.put(\"another-new-key\", \"val3\");\n+        assertRoundTrip(s + LS + \"new-key: val1\" + LS + \"new-key-2: val2\" + LS +\n+            \"another-new-key: val3\" + LS, p);\n+    }\n+\n+    public void testAddAndMutateProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        Properties p = toProperties(\"foo: bar\" + LS + \"baz: val\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+\n+        p.put(\"new-key\", \"new value\");\n+        p.put(\"foo\", \"barbar\");\n+        assertRoundTrip(\"foo: barbar\" + LS + \"baz: val\" + LS \n+            + \"new-key: new value\" + LS, p);\n+    }\n+\n+    public void testEscapedEquals() throws IOException {\n+        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\n+    }\n+\n+    public void testLineTypes() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"   !comment\" + LS + \" \\t  \" + LS + \"name = no\" + LS + \"    \"\n+            + \"#morec\\tomm\\\\\" + LS + \"ents\" + LS + LS + \"  dog=no\\\\cat   \" + LS \n+            + \"burps    :\" + LS + \"test=\" + LS + \"date today\" + LS + LS + LS \n+            + \"long\\\\\" + LS + \"   value=tryin \\\\\" + LS + \" \"\n+            + \"gto\" + LS + \"4:vier\" + LS + \"vier     :4\");\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{\n+            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\n+            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\n+            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\n+        }, p);\n+    }\n+\n+    public void testSpecialChars() throws Throwable {\n+        testSpecialChars(false, true);\n+        testSpecialChars(true, true);\n+        testSpecialChars(false, false);\n+        testSpecialChars(true, false);\n+    }\n+\n+    /**\n+     * Test that special characters work.\n+     *\n+     * @param formattingProps if true, test against the\n+     * FormatPreservingProperties, otherwise test\n+     * against a normal Properties instance(for validation of the test case).\n+     * @param value whether to test the key or the value\n+     */\n+    public void testSpecialChars(boolean formattingProps, boolean value)\n+        throws Throwable {\n+        List valueList = new ArrayList(Arrays.asList(new String[]{\n+            \"xxyy\", \"xx\\\\yy\", \"xx\" + LS + \"yy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\n+            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\" + LS + \"\\\\\\t\\r\\t\" \n+            + LS + \"yy\",\n+            \"xx\\\\r\" + LS + \"\\\\\\t\\\\r\\t\\\\nyy\",\n+            \"xx\\r\" + LS + \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\" + LS + \"yy\",\n+            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\n+\n+        // also store every individual character\n+        for (char c = 'a'; c < 'Z'; c++) {\n+            valueList.add(new String(new char[]{ c }));\n+            valueList.add(new String(new char[]{ c, '\\\\', c }));\n+            valueList.add(new String(new char[]{ '\\\\', c }));\n+        }\n+\n+        String[] values = (String[]) valueList.toArray(new String[0]);\n+\n+        final String dummy = \"XXX\";\n+\n+        for (int i = 0; i < values.length; i++) {\n+            // test special characters in either keys or values\n+            String val = value ? values[i] : dummy;\n+            String key = value ? dummy : values[i];\n+\n+            Properties p = formattingProps ?\n+                new FormatPreservingProperties() : new Properties();\n+            if (p instanceof FormatPreservingProperties) {\n+                // set these properties so we behave the same way as\n+                // java.util.Properties\n+                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\n+                ((FormatPreservingProperties) p).\n+                    setAddWhitespaceAfterDelimiter(false);\n+            }\n+\n+            p.setProperty(key, val);\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            p.store(out, null);\n+\n+            Properties copy = new Properties();\n+            copy.setProperty(key, val);\n+            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\n+            copy.store(copyOut, null);\n+\n+            p = formattingProps ?\n+                new FormatPreservingProperties() : new Properties();\n+\n+            InputStream in = new BufferedInputStream\n+                (new ByteArrayInputStream(out.toByteArray()));\n+\n+            try {\n+                // make sure that the 2 properties serialized are the same\n+                String copyOutString = stripComments(copyOut.toByteArray());\n+                String outString = stripComments(out.toByteArray());\n+                assertEquals(copyOutString, outString);\n+\n+                p.load(in);\n+\n+                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\n+                    p.getProperty(key));\n+                assertEquals(val.trim(), p.getProperty(key).trim());\n+            } catch (Throwable ioe) {\n+                if (!formattingProps)\n+                    throw ioe;\n+\n+                // bug(1211, ioe,\n+                // \"Cannot store backslash in FormatPreservingProperties\");\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    static Character randomChar() {\n+        char [] TEST_CHAR_ARRAY = new char []{\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n+            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n+            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\n+            '2', '3', '4', '5', '6', '7', '8', '9' };\n+\n+        return new Character(TEST_CHAR_ARRAY[\n+            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\n+    }\n+\n+    static String randomString(int len) {\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\n+            buf.append(randomChar());\n+        return buf.toString();\n+    }\n+\n+    public void testEquivalentStore() throws IOException {\n+        Properties p1 = new Properties();\n+        FormatPreservingProperties p2 = new FormatPreservingProperties();\n+\n+        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\n+        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\n+\n+        String[] values =\n+            new String[] { \n+                \"x\", \n+                \"x\" + LS + \"y\", \n+                \"x\\\\ny\", \n+                \"x\\ty\", \n+                \"x\\\\ty\",\n+                \"x\\fy\", \n+                \"x\\\\fy\", \n+                \"x\\ry\", \n+                \"x\\\\ry\", \n+                \"C:\\\\Foo Bar\\\\Baz\",\n+                randomString(5).replace('a', '\\\\'),\n+                randomString(500).replace('a', '\\\\'),\n+                randomString(5000).replace('a', '\\\\'), \n+                };\n+\n+        for (int i = 0; i < values.length; i++) {\n+            p1.clear();\n+            p2.clear();\n+\n+            p1.setProperty(\"xxx\", values[i]);\n+            p2.setProperty(\"xxx\", values[i]);\n+\n+            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\n+            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\n+\n+            p1.store(out1, null);\n+            p2.store(out2, null);\n+\n+            String s1 = new String(out1.toByteArray());\n+            String s2 = new String(out2.toByteArray());\n+\n+            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\n+                s1.indexOf(s2) != -1);\n+        }\n+    }\n+\n+    static String stripComments(byte[] bytes) throws IOException {\n+        BufferedReader reader = new BufferedReader(new InputStreamReader\n+            (new ByteArrayInputStream(bytes)));\n+        StringBuffer sbuf = new StringBuffer();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            // skip comments\n+            if (line.trim().startsWith(\"#\"))\n+                continue;\n+\n+            sbuf.append(line);\n+            sbuf.append(LS);\n+        }\n+\n+        return sbuf.toString();\n+    }\n+\n+    public void testDuplicateProperties() throws IOException {\n+        FormatPreservingProperties p = new FormatPreservingProperties();\n+        try {\n+            toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\n+            fail(\"expected duplicate keys to cause exception\");\n+        } catch (DuplicateKeyException e) {\n+            // expected\n+        }\n+\n+        // now test the expected behavior when duplicates are allowed.\n+        p = new FormatPreservingProperties();\n+        p.setAllowDuplicates(true);\n+        toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\n+        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\n+    }\n+\n+    public void testMultipleLoads() throws IOException {\n+        String props = \"foo=bar\" + LS + \"baz=quux\";\n+        String props2 = \"a=b\" + LS + \"c=d\";\n+        Properties vanilla = new Properties();\n+        vanilla.load(new BufferedInputStream\n+            (new StringBufferInputStream(props)));\n+        vanilla.load(new BufferedInputStream\n+            (new StringBufferInputStream(props2)));\n+\n+        Properties p = new FormatPreservingProperties();\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\n+        assertPropertiesSame(vanilla, p);\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s)\n+        throws IOException {\n+        return toProperties(s, new FormatPreservingProperties());\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s,\n+        FormatPreservingProperties p) throws IOException {\n+        Properties vanilla = new Properties();\n+        vanilla.load(new StringBufferInputStream(s));\n+\n+        p.load(new StringBufferInputStream(s));\n+        assertRoundTrip(s, p);\n+\n+        assertPropertiesSame(vanilla, p);\n+\n+        return p;\n+    }\n+\n+    private void assertRoundTrip(String s, Properties p) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        p.store(out, null);\n+        assertEquals(s, out.toString());\n+\n+        // also check serializable\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bout).writeObject(p);\n+\n+        try {\n+            FormatPreservingProperties deserialized =\n+                (FormatPreservingProperties) new ObjectInputStream\n+                    (new ByteArrayInputStream(bout.toByteArray())).\n+                    readObject();\n+            assertEquals(p, deserialized);\n+\n+            out = new ByteArrayOutputStream();\n+            deserialized.store(out, null);\n+            assertEquals(s, out.toString());\n+        } catch (ClassNotFoundException cnfe) {\n+            fail(cnfe + \"\");\n+        }\n+    }\n+\n+    public static void assertEquals(String expected, String actual) {\n+        if (expected == actual)\n+            return;\n+\n+        if (expected == null || !expected.equals(actual))\n+            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\n+    }\n+\n+    private void assertPropertiesSame(Properties vanilla, Properties p) {\n+        assertEquals(vanilla, p);\n+    }\n+\n+    protected void assertProperties(String[][] strings, Properties p) {\n+        for (int i = 0; i < strings.length; i++)\n+            assertEquals(strings[i][1], p.get(strings[i][0]));\n+\n+        assertEquals(strings.length, p.size());\n+    }\n+}"},{"sha":"26bf2ee59116dcd7461b3f105061b05dfe67f99e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,109 +1,109 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.Value;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-/**\r\n- * Tests dynamic modification of configuration property.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class TestDynamicConfiguration extends SingleEMFTestCase {\r\n-\r\n-    public void testConfigurationIsEqualByValueAndHashCode() {\r\n-\t\tOpenJPAEntityManagerFactorySPI emf1 = createEMF();\r\n-\t\tassertNotNull(emf1);\r\n-\t\tOpenJPAConfiguration conf1 = emf1.getConfiguration();\r\n-\t\t\r\n-\t\tOpenJPAEntityManagerFactorySPI emf2 = createEMF();\r\n-\t\tassertNotNull(emf2);\r\n-\t\tOpenJPAConfiguration conf2 = emf2.getConfiguration();\r\n-\t\t\r\n-\t\tassertFalse(emf1==emf2);\r\n-\t\tassertFalse(emf1.equals(emf2));\r\n-\t\tassertFalse(conf1==conf2);\r\n-\t\tassertEquals(conf1, conf2);\r\n-\t\tassertEquals(conf1.hashCode(), conf2.hashCode());\r\n-\t\tassertEquals(conf1.toProperties(false), conf2.toProperties(false));\r\n-\t}\r\n-\t\r\n-\tpublic void testConfigurationIsReadOnlyAfterFirstConstruction() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\tassertFalse(conf.isReadOnly());\r\n-\t\temf.createEntityManager();\r\n-\t\tassertTrue(conf.isReadOnly());\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicValuesCanNotBeChangedDirectly() {\r\n-\t\temf.createEntityManager();\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\r\n-\t\tint oldValue = conf.getLockTimeout();\r\n-\t\tint newValue = oldValue + 10;\r\n-\t\ttry {\r\n-\t\t\tconf.setLockTimeout(newValue);\r\n-\t\t\tfail(\"Expected exception to modify configuration directly\");\r\n-\t\t} catch (Exception ex) { // good\r\n-\t\t\tassertEquals(oldValue, conf.getLockTimeout());\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicValuesCanBeChanged() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\r\n-\t\tint oldValue = conf.getLockTimeout();\r\n-\t\tint newValue = oldValue + 10;\r\n-\t\t\r\n-\t\tconf.modifyDynamic(\"LockTimeout\", newValue);\r\n-\t\tassertEquals(newValue, conf.getLockTimeout());\r\n-\t}\r\n-\r\n-\tpublic void testDynamicValuesAreCorrectlySet() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicChangeDoesNotChangeHashCode() {\r\n-\t\tOpenJPAConfiguration conf1 = emf.getConfiguration();\r\n-\t\t\r\n-\t\tint oldValue = conf1.getLockTimeout();\r\n-\t\tint newValue = oldValue+10;\r\n-\t\tint oldHash = conf1.hashCode();\r\n-\t\tconf1.modifyDynamic(\"LockTimeout\", newValue);\r\n-\t\tint newHash = conf1.hashCode();\r\n-\t\t\r\n-\t\tassertEquals(oldHash, newHash);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.Value;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Tests dynamic modification of configuration property.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class TestDynamicConfiguration extends SingleEMFTestCase {\n+\n+    public void testConfigurationIsEqualByValueAndHashCode() {\n+\t\tOpenJPAEntityManagerFactorySPI emf1 = createEMF();\n+\t\tassertNotNull(emf1);\n+\t\tOpenJPAConfiguration conf1 = emf1.getConfiguration();\n+\t\t\n+\t\tOpenJPAEntityManagerFactorySPI emf2 = createEMF();\n+\t\tassertNotNull(emf2);\n+\t\tOpenJPAConfiguration conf2 = emf2.getConfiguration();\n+\t\t\n+\t\tassertFalse(emf1==emf2);\n+\t\tassertFalse(emf1.equals(emf2));\n+\t\tassertFalse(conf1==conf2);\n+\t\tassertEquals(conf1, conf2);\n+\t\tassertEquals(conf1.hashCode(), conf2.hashCode());\n+\t\tassertEquals(conf1.toProperties(false), conf2.toProperties(false));\n+\t}\n+\t\n+\tpublic void testConfigurationIsReadOnlyAfterFirstConstruction() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\tassertFalse(conf.isReadOnly());\n+\t\temf.createEntityManager();\n+\t\tassertTrue(conf.isReadOnly());\n+\t}\n+\t\n+\tpublic void testDynamicValuesCanNotBeChangedDirectly() {\n+\t\temf.createEntityManager();\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\n+\t\tint oldValue = conf.getLockTimeout();\n+\t\tint newValue = oldValue + 10;\n+\t\ttry {\n+\t\t\tconf.setLockTimeout(newValue);\n+\t\t\tfail(\"Expected exception to modify configuration directly\");\n+\t\t} catch (Exception ex) { // good\n+\t\t\tassertEquals(oldValue, conf.getLockTimeout());\n+\t\t}\n+\t}\n+\t\n+\tpublic void testDynamicValuesCanBeChanged() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\n+\t\tint oldValue = conf.getLockTimeout();\n+\t\tint newValue = oldValue + 10;\n+\t\t\n+\t\tconf.modifyDynamic(\"LockTimeout\", newValue);\n+\t\tassertEquals(newValue, conf.getLockTimeout());\n+\t}\n+\n+\tpublic void testDynamicValuesAreCorrectlySet() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\t}\n+\t\n+\tpublic void testDynamicChangeDoesNotChangeHashCode() {\n+\t\tOpenJPAConfiguration conf1 = emf.getConfiguration();\n+\t\t\n+\t\tint oldValue = conf1.getLockTimeout();\n+\t\tint newValue = oldValue+10;\n+\t\tint oldHash = conf1.hashCode();\n+\t\tconf1.modifyDynamic(\"LockTimeout\", newValue);\n+\t\tint newHash = conf1.hashCode();\n+\t\t\n+\t\tassertEquals(oldHash, newHash);\n+\t}\n+}"},{"sha":"fac8bfb92a46e8ba8edf1f18dc75499919f808bb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":595,"deletions":595,"changes":1190,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,596 +1,596 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ByteArrayInputStream;\r\n-import java.util.List;\r\n-import java.util.Collections;\r\n-import java.lang.reflect.Field;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n-import org.apache.openjpa.persistence.JPAFacadeHelper;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.event.AbstractLifecycleListener;\r\n-import org.apache.openjpa.event.LifecycleEvent;\r\n-\r\n-public abstract class AbstractUnenhancedClassTest\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    // ##### To do:\r\n-    // - clearing in pnew property-access without redefinition\r\n-    // - figure out how to auto-test the redefinition code, either in Java 5\r\n-    //   or in Java 6\r\n-    // - run CTS in the following combinations:\r\n-    //   * Java 6\r\n-    //   * Java 5 with javaagent\r\n-    //   * Java 5 without javaagent\r\n-\r\n-    public void setUp() {\r\n-        setUp(getUnenhancedClass(), getUnenhancedSubclass(), CLEAR_TABLES);\r\n-        // trigger class redefinition\r\n-        emf.createEntityManager().close();\r\n-    }\r\n-\r\n-    protected abstract Class<? extends UnenhancedType> getUnenhancedClass();\r\n-\r\n-    protected abstract UnenhancedType newUnenhancedInstance();\r\n-\r\n-    protected abstract Class<? extends UnenhancedSubtype> getUnenhancedSubclass();\r\n-\r\n-    protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\r\n-\r\n-    private UnenhancedType newInstance(boolean sub) {\r\n-        return sub ? newUnenhancedSubclassInstance()\r\n-            : newUnenhancedInstance();\r\n-    }\r\n-\r\n-    public void testMetaData() {\r\n-        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\r\n-            getUnenhancedClass());\r\n-        assertEquals(ClassRedefiner.canRedefineClasses(),\r\n-            meta.isIntercepting());\r\n-    }\r\n-\r\n-    public void testImplHelperCalls() {\r\n-        assertTrue(ImplHelper.isManagedType(null, getUnenhancedClass()));\r\n-\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        assertFalse(un instanceof PersistenceCapable);\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n-            emf.getConfiguration());\r\n-        assertNotNull(pc);\r\n-        assertTrue(ImplHelper.isManageable(un));\r\n-    }\r\n-\r\n-    public void testBasicPersistenceCapableBehavior() {\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        un.setStringField(\"bar\");\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n-            emf.getConfiguration());\r\n-        assertFalse(pc.pcIsDeleted());\r\n-        assertFalse(pc.pcIsDirty());\r\n-        assertFalse(pc.pcIsNew());\r\n-        assertFalse(pc.pcIsPersistent());\r\n-        assertFalse(pc.pcIsTransactional());\r\n-    }\r\n-\r\n-    public void testPCRegistry() {\r\n-        assertTrue(PCRegistry.isRegistered(getUnenhancedClass()));\r\n-        PersistenceCapable pc = PCRegistry.newInstance(\r\n-            getUnenhancedClass(), null, false);\r\n-        assertNotNull(pc);\r\n-    }\r\n-\r\n-    public void testClearingOnSubtypeInstance() {\r\n-        // the boolean at the end of newInstance will cause clear to be invoked\r\n-        UnenhancedType un = (UnenhancedType)\r\n-            PCRegistry.newInstance(getUnenhancedClass(), null, true);\r\n-        assertEquals(null, un.getStringField());\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnOpenJPAType() {\r\n-        getObjectIdHelper(true, false);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnOpenJPATypeSubclass() {\r\n-        getObjectIdHelper(false, false);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnUserDefined() {\r\n-        getObjectIdHelper(true, true);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnUserDefinedSubclass() {\r\n-        getObjectIdHelper(false, true);\r\n-    }\r\n-\r\n-    private void getObjectIdHelper(boolean sub, boolean userDefined) {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-        }\r\n-\r\n-        assertNotNull(em.getObjectId(un));\r\n-    }\r\n-\r\n-    public void testOperationsOnUserDefined() {\r\n-        opsHelper(false, true);\r\n-    }\r\n-\r\n-    public void testSubclassOperationsOnUserDefined() {\r\n-        opsHelper(true, true);\r\n-    }\r\n-\r\n-    public void testOperationsOnOpenJPADefined() {\r\n-        opsHelper(false, false);\r\n-    }\r\n-\r\n-    public void testSubclassOperationsOnOpenJPADefined() {\r\n-        opsHelper(true, false);\r\n-    }\r\n-\r\n-    private void opsHelper(boolean sub, boolean userDefined) {\r\n-        OpenJPAEntityManager em = null;\r\n-        try {\r\n-            UnenhancedType un = newInstance(sub);\r\n-            em = emf.createEntityManager();\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.persist(un);\r\n-            un.setStringField(\"bar\");\r\n-            assertEquals(\"bar\", un.getStringField());\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            em.flush();\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            assertTrue(un.getId() != 0);\r\n-            UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\r\n-            assertSame(un, un2);\r\n-            em.getTransaction().commit();\r\n-            assertPersistenceContext(em, un, false, false, sub);\r\n-            un2 = em.find(getUnenhancedClass(), un.getId());\r\n-            assertSame(un, un2);\r\n-\r\n-            if (!userDefined) {\r\n-                em.close();\r\n-                em = emf.createEntityManager();\r\n-            }\r\n-\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertNotNull(un);\r\n-            if (!userDefined)\r\n-                assertTrue(un instanceof PersistenceCapable);\r\n-            assertEquals(\"bar\", un.getStringField());\r\n-            em.getTransaction().begin();\r\n-            un.setStringField(\"baz\");\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-\r\n-            if (sub)\r\n-                ((UnenhancedSubtype) un).setIntField(17);\r\n-\r\n-            assertTrue(em.isDirty(un));\r\n-            \r\n-            em.getTransaction().commit();\r\n-\r\n-            // make sure that the values are still up-to-date after\r\n-            // the commit happens\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-            \r\n-            em.close();\r\n-\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertNotNull(un);\r\n-            assertTrue(un instanceof PersistenceCapable);\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-            if (sub)\r\n-                assertEquals(17, ((UnenhancedSubtype) un).getIntField());\r\n-            em.close();\r\n-        } finally {\r\n-            if (em != null && em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            if (em != null && em.isOpen())\r\n-                em.close();\r\n-        }\r\n-    }\r\n-\r\n-    private void assertPersistenceContext(OpenJPAEntityManager em,\r\n-        UnenhancedType un, boolean transactional, boolean dirty, boolean sub) {\r\n-        assertEquals(transactional, em.getTransactionalObjects().contains(un));\r\n-        assertEquals(dirty, em.getDirtyObjects().contains(un));\r\n-        if (dirty) {\r\n-            Class cls = sub ? getUnenhancedSubclass() : getUnenhancedClass();\r\n-            assertTrue(em.getUpdatedClasses().contains(cls)\r\n-                || em.getPersistedClasses().contains(cls));\r\n-        }\r\n-    }\r\n-\r\n-    public void testRelations() {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedSubtype un = newUnenhancedSubclassInstance();\r\n-        em.persist(un);\r\n-        un.setStringField(\"aoeu\");\r\n-        UnenhancedSubtype related = newUnenhancedSubclassInstance();\r\n-        un.setRelated(related);\r\n-        related.setStringField(\"snth\");\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        un = (UnenhancedSubtype) em.find(getUnenhancedClass(), un.getId());\r\n-        assertEquals(\"aoeu\", un.getStringField());\r\n-        assertNotNull(un.getRelated());\r\n-        assertEquals(\"snth\", un.getRelated().getStringField());\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testEnhancer() throws IOException {\r\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedClass()), null);\r\n-        Class sub = subs.get(0);\r\n-        assertNotNull(sub);\r\n-        assertEquals(\"org.apache.openjpa.enhance.\"\r\n-            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n-            sub.getName());\r\n-        assertTrue(PersistenceCapable.class.isAssignableFrom(sub));\r\n-        assertTrue(getUnenhancedClass().isAssignableFrom(sub));\r\n-    }\r\n-\r\n-    public void testPCSubclassName() {\r\n-        assertEquals(\"org.apache.openjpa.enhance.\"\r\n-            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n-            PCEnhancer.toPCSubclassName(getUnenhancedClass()));\r\n-    }\r\n-\r\n-    public void testEvictionInUserCreatedInstance()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        evictionHelper(true);\r\n-    }\r\n-\r\n-    public void testEvictionInOpenJPACreatedInstance()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        evictionHelper(false);\r\n-    }\r\n-\r\n-    private void evictionHelper(boolean userDefined)\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertTrue(getUnenhancedClass() != un.getClass());\r\n-        }\r\n-\r\n-        em.evict(un);\r\n-        OpenJPAStateManager sm = (OpenJPAStateManager)\r\n-            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\r\n-\r\n-        // we only expect lazy loading to work when we can redefine classes\r\n-        // or when accessing a property-access record that OpenJPA created.\r\n-        if (ClassRedefiner.canRedefineClasses()\r\n-            || (!userDefined && sm.getMetaData().getAccessType()\r\n-                != ClassMetaData.ACCESS_FIELD)) {\r\n-\r\n-            assertFalse(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-\r\n-            // make sure that the value was cleared...\r\n-            Field field = getUnenhancedClass().getDeclaredField(\r\n-                isFieldAccessTest() ? \"stringField\" : \"sf\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(null, field.get(un));\r\n-\r\n-            // ... and that it gets reloaded properly\r\n-            assertEquals(\"foo\", un.getStringField());\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-        } else {\r\n-            // unredefined properties with user-defined instance, or any\r\n-            // unredefined field access\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-\r\n-            // make sure that the value was not cleared\r\n-            Field field = getUnenhancedClass().getDeclaredField(\r\n-                isFieldAccessTest() ? \"stringField\" : \"sf\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(\"foo\", field.get(un));\r\n-        }\r\n-\r\n-        em.close();\r\n-    }\r\n-\r\n-    protected abstract boolean isFieldAccessTest();\r\n-\r\n-    public void testLazyLoading()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        assertTrue(getUnenhancedClass() != un.getClass());\r\n-        OpenJPAStateManager sm = (OpenJPAStateManager)\r\n-            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\r\n-\r\n-        // we only expect lazy loading to work when we can redefine classes\r\n-        // or when accessing a property-access record that OpenJPA created.\r\n-        if (ClassRedefiner.canRedefineClasses()\r\n-            || (sm.getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD))\r\n-        {\r\n-            assertFalse(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-            // make sure that the value was cleared\r\n-            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(null, field.get(un));\r\n-        } else {\r\n-            // unredefined field access\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-            // make sure that the value was loaded already\r\n-            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(\"lazy\", field.get(un));\r\n-        }\r\n-\r\n-        // make sure that the value is available, one way or another\r\n-        assertEquals(\"lazy\", un.getLazyField());\r\n-        assertTrue(sm.getLoaded()\r\n-            .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testSerializationOfUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(true, false);\r\n-    }\r\n-\r\n-    public void testSerializationOfUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(true, true);\r\n-    }\r\n-\r\n-    public void testSerializationOfOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(false, false);\r\n-    }\r\n-\r\n-    public void testSerializationOfOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(false, true);\r\n-    }\r\n-\r\n-    private void serializationHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-\r\n-        if (sub) {\r\n-            UnenhancedType related = newInstance(false);\r\n-            related.setStringField(\"related\");\r\n-            ((UnenhancedSubtype) un).setRelated(related);\r\n-        }\r\n-\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-        ObjectOutputStream oout = new ObjectOutputStream(out);\r\n-        oout.writeObject(un);\r\n-        oout.flush();\r\n-        byte[] bytes = out.toByteArray();\r\n-\r\n-        ObjectInputStream oin = new ObjectInputStream(\r\n-            new ByteArrayInputStream(bytes));\r\n-        UnenhancedType deserialized = (UnenhancedType) oin.readObject();\r\n-\r\n-        copiedInstanceHelper(sub, em, un, deserialized, false);\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testCloningOfUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(true, false);\r\n-    }\r\n-\r\n-    public void testCloningOfUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(true, true);\r\n-    }\r\n-\r\n-    public void testCloningOfOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(false, false);\r\n-    }\r\n-\r\n-    public void testCloningOfOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(false, true);\r\n-    }\r\n-\r\n-    private void cloneHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-\r\n-        if (sub) {\r\n-            UnenhancedType related = newInstance(false);\r\n-            related.setStringField(\"related\");\r\n-            ((UnenhancedSubtype) un).setRelated(related);\r\n-        }\r\n-\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        UnenhancedType cloned = (UnenhancedType) un.clone();\r\n-\r\n-        copiedInstanceHelper(sub, em, un, cloned, true);\r\n-        em.close();\r\n-    }\r\n-\r\n-    private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\r\n-        UnenhancedType un, UnenhancedType copy, boolean viaClone) {\r\n-        assertNotSame(un, copy);\r\n-        if (!viaClone)\r\n-            assertEquals(sub ? getUnenhancedSubclass() : getUnenhancedClass(),\r\n-                copy.getClass());\r\n-        assertEquals(un.getId(), copy.getId());\r\n-        assertEquals(un.getStringField(), copy.getStringField());\r\n-        if (sub) {\r\n-            assertEquals(\r\n-                ((UnenhancedSubtype) un).getIntField(),\r\n-                ((UnenhancedSubtype) copy).getIntField());\r\n-            assertNotSame(\r\n-                ((UnenhancedSubtype) un).getRelated(),\r\n-                ((UnenhancedSubtype) copy).getRelated());\r\n-            assertEquals(\r\n-                ((UnenhancedSubtype) un).getRelated().getId(),\r\n-                ((UnenhancedSubtype) copy).getRelated().getId());\r\n-        }\r\n-\r\n-        assertFalse(em.isDetached(un));\r\n-        assertTrue(em.isDetached(copy));\r\n-        copy.setStringField(\"offline update\");\r\n-\r\n-        em.getTransaction().begin();\r\n-        assertSame(un, em.merge(copy));\r\n-        assertTrue(em.isDirty(un));\r\n-        assertEquals(\"offline update\", un.getStringField());\r\n-        em.getTransaction().commit();\r\n-    }\r\n-\r\n-    public void testListenersOnUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(true, false);\r\n-    }\r\n-\r\n-    public void testListenersOnUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(true, true);\r\n-    }\r\n-\r\n-    public void testListenersOnOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(false, false);\r\n-    }\r\n-\r\n-    public void testListenersOnOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(false, true);\r\n-    }\r\n-\r\n-    private void listenerHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        ListenerImpl listener = new ListenerImpl();\r\n-        emf.addLifecycleListener(listener, (Class[]) null);\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        listener.invoked = false;\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        em.getTransaction().begin();\r\n-        un.setStringField(\"updated\");\r\n-        em.getTransaction().commit();\r\n-        assertTrue(listener.invoked);\r\n-        em.close();\r\n-\r\n-        assertEquals(\"updated\", listener.stringField);\r\n-    }\r\n-\r\n-    public void testGetMetaDataOfSubtype() {\r\n-        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\r\n-            getUnenhancedClass());\r\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedClass()), null);\r\n-        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\r\n-\r\n-        meta = JPAFacadeHelper.getMetaData(emf, getUnenhancedSubclass());\r\n-        subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedSubclass()), null);\r\n-        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\r\n-    }\r\n-\r\n-    private class ListenerImpl\r\n-        extends AbstractLifecycleListener {\r\n-\r\n-        String stringField;\r\n-        boolean invoked;\r\n-\r\n-        @Override\r\n-        public void afterStore(LifecycleEvent event) {\r\n-            invoked = true;\r\n-            stringField = ((UnenhancedType) event.getSource()).getStringField();\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.IOException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.util.List;\n+import java.util.Collections;\n+import java.lang.reflect.Field;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.event.AbstractLifecycleListener;\n+import org.apache.openjpa.event.LifecycleEvent;\n+\n+public abstract class AbstractUnenhancedClassTest\n+    extends SingleEMFTestCase {\n+\n+    // ##### To do:\n+    // - clearing in pnew property-access without redefinition\n+    // - figure out how to auto-test the redefinition code, either in Java 5\n+    //   or in Java 6\n+    // - run CTS in the following combinations:\n+    //   * Java 6\n+    //   * Java 5 with javaagent\n+    //   * Java 5 without javaagent\n+\n+    public void setUp() {\n+        setUp(getUnenhancedClass(), getUnenhancedSubclass(), CLEAR_TABLES);\n+        // trigger class redefinition\n+        emf.createEntityManager().close();\n+    }\n+\n+    protected abstract Class<? extends UnenhancedType> getUnenhancedClass();\n+\n+    protected abstract UnenhancedType newUnenhancedInstance();\n+\n+    protected abstract Class<? extends UnenhancedSubtype> getUnenhancedSubclass();\n+\n+    protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\n+\n+    private UnenhancedType newInstance(boolean sub) {\n+        return sub ? newUnenhancedSubclassInstance()\n+            : newUnenhancedInstance();\n+    }\n+\n+    public void testMetaData() {\n+        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\n+            getUnenhancedClass());\n+        assertEquals(ClassRedefiner.canRedefineClasses(),\n+            meta.isIntercepting());\n+    }\n+\n+    public void testImplHelperCalls() {\n+        assertTrue(ImplHelper.isManagedType(null, getUnenhancedClass()));\n+\n+        UnenhancedType un = newUnenhancedInstance();\n+        assertFalse(un instanceof PersistenceCapable);\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\n+            emf.getConfiguration());\n+        assertNotNull(pc);\n+        assertTrue(ImplHelper.isManageable(un));\n+    }\n+\n+    public void testBasicPersistenceCapableBehavior() {\n+        UnenhancedType un = newUnenhancedInstance();\n+        un.setStringField(\"bar\");\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\n+            emf.getConfiguration());\n+        assertFalse(pc.pcIsDeleted());\n+        assertFalse(pc.pcIsDirty());\n+        assertFalse(pc.pcIsNew());\n+        assertFalse(pc.pcIsPersistent());\n+        assertFalse(pc.pcIsTransactional());\n+    }\n+\n+    public void testPCRegistry() {\n+        assertTrue(PCRegistry.isRegistered(getUnenhancedClass()));\n+        PersistenceCapable pc = PCRegistry.newInstance(\n+            getUnenhancedClass(), null, false);\n+        assertNotNull(pc);\n+    }\n+\n+    public void testClearingOnSubtypeInstance() {\n+        // the boolean at the end of newInstance will cause clear to be invoked\n+        UnenhancedType un = (UnenhancedType)\n+            PCRegistry.newInstance(getUnenhancedClass(), null, true);\n+        assertEquals(null, un.getStringField());\n+    }\n+\n+    public void testGetObjectIdOnOpenJPAType() {\n+        getObjectIdHelper(true, false);\n+    }\n+\n+    public void testGetObjectIdOnOpenJPATypeSubclass() {\n+        getObjectIdHelper(false, false);\n+    }\n+\n+    public void testGetObjectIdOnUserDefined() {\n+        getObjectIdHelper(true, true);\n+    }\n+\n+    public void testGetObjectIdOnUserDefinedSubclass() {\n+        getObjectIdHelper(false, true);\n+    }\n+\n+    private void getObjectIdHelper(boolean sub, boolean userDefined) {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedType un = newInstance(sub);\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+        }\n+\n+        assertNotNull(em.getObjectId(un));\n+    }\n+\n+    public void testOperationsOnUserDefined() {\n+        opsHelper(false, true);\n+    }\n+\n+    public void testSubclassOperationsOnUserDefined() {\n+        opsHelper(true, true);\n+    }\n+\n+    public void testOperationsOnOpenJPADefined() {\n+        opsHelper(false, false);\n+    }\n+\n+    public void testSubclassOperationsOnOpenJPADefined() {\n+        opsHelper(true, false);\n+    }\n+\n+    private void opsHelper(boolean sub, boolean userDefined) {\n+        OpenJPAEntityManager em = null;\n+        try {\n+            UnenhancedType un = newInstance(sub);\n+            em = emf.createEntityManager();\n+\n+            em.getTransaction().begin();\n+            em.persist(un);\n+            un.setStringField(\"bar\");\n+            assertEquals(\"bar\", un.getStringField());\n+            assertPersistenceContext(em, un, true, true, sub);\n+            em.flush();\n+            assertPersistenceContext(em, un, true, true, sub);\n+            assertTrue(un.getId() != 0);\n+            UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\n+            assertSame(un, un2);\n+            em.getTransaction().commit();\n+            assertPersistenceContext(em, un, false, false, sub);\n+            un2 = em.find(getUnenhancedClass(), un.getId());\n+            assertSame(un, un2);\n+\n+            if (!userDefined) {\n+                em.close();\n+                em = emf.createEntityManager();\n+            }\n+\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertNotNull(un);\n+            if (!userDefined)\n+                assertTrue(un instanceof PersistenceCapable);\n+            assertEquals(\"bar\", un.getStringField());\n+            em.getTransaction().begin();\n+            un.setStringField(\"baz\");\n+            assertPersistenceContext(em, un, true, true, sub);\n+            assertEquals(\"baz\", un.getStringField());\n+\n+            if (sub)\n+                ((UnenhancedSubtype) un).setIntField(17);\n+\n+            assertTrue(em.isDirty(un));\n+            \n+            em.getTransaction().commit();\n+\n+            // make sure that the values are still up-to-date after\n+            // the commit happens\n+            assertEquals(\"baz\", un.getStringField());\n+            \n+            em.close();\n+\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertNotNull(un);\n+            assertTrue(un instanceof PersistenceCapable);\n+            assertEquals(\"baz\", un.getStringField());\n+            if (sub)\n+                assertEquals(17, ((UnenhancedSubtype) un).getIntField());\n+            em.close();\n+        } finally {\n+            if (em != null && em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            if (em != null && em.isOpen())\n+                em.close();\n+        }\n+    }\n+\n+    private void assertPersistenceContext(OpenJPAEntityManager em,\n+        UnenhancedType un, boolean transactional, boolean dirty, boolean sub) {\n+        assertEquals(transactional, em.getTransactionalObjects().contains(un));\n+        assertEquals(dirty, em.getDirtyObjects().contains(un));\n+        if (dirty) {\n+            Class cls = sub ? getUnenhancedSubclass() : getUnenhancedClass();\n+            assertTrue(em.getUpdatedClasses().contains(cls)\n+                || em.getPersistedClasses().contains(cls));\n+        }\n+    }\n+\n+    public void testRelations() {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedSubtype un = newUnenhancedSubclassInstance();\n+        em.persist(un);\n+        un.setStringField(\"aoeu\");\n+        UnenhancedSubtype related = newUnenhancedSubclassInstance();\n+        un.setRelated(related);\n+        related.setStringField(\"snth\");\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        un = (UnenhancedSubtype) em.find(getUnenhancedClass(), un.getId());\n+        assertEquals(\"aoeu\", un.getStringField());\n+        assertNotNull(un.getRelated());\n+        assertEquals(\"snth\", un.getRelated().getStringField());\n+        em.close();\n+    }\n+\n+    public void testEnhancer() throws IOException {\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedClass()), null);\n+        Class sub = subs.get(0);\n+        assertNotNull(sub);\n+        assertEquals(\"org.apache.openjpa.enhance.\"\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\n+            sub.getName());\n+        assertTrue(PersistenceCapable.class.isAssignableFrom(sub));\n+        assertTrue(getUnenhancedClass().isAssignableFrom(sub));\n+    }\n+\n+    public void testPCSubclassName() {\n+        assertEquals(\"org.apache.openjpa.enhance.\"\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\n+            PCEnhancer.toPCSubclassName(getUnenhancedClass()));\n+    }\n+\n+    public void testEvictionInUserCreatedInstance()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        evictionHelper(true);\n+    }\n+\n+    public void testEvictionInOpenJPACreatedInstance()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        evictionHelper(false);\n+    }\n+\n+    private void evictionHelper(boolean userDefined)\n+        throws NoSuchFieldException, IllegalAccessException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newUnenhancedInstance();\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertTrue(getUnenhancedClass() != un.getClass());\n+        }\n+\n+        em.evict(un);\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\n+            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\n+\n+        // we only expect lazy loading to work when we can redefine classes\n+        // or when accessing a property-access record that OpenJPA created.\n+        if (ClassRedefiner.canRedefineClasses()\n+            || (!userDefined && sm.getMetaData().getAccessType()\n+                != ClassMetaData.ACCESS_FIELD)) {\n+\n+            assertFalse(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+\n+            // make sure that the value was cleared...\n+            Field field = getUnenhancedClass().getDeclaredField(\n+                isFieldAccessTest() ? \"stringField\" : \"sf\");\n+            field.setAccessible(true);\n+            assertEquals(null, field.get(un));\n+\n+            // ... and that it gets reloaded properly\n+            assertEquals(\"foo\", un.getStringField());\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+        } else {\n+            // unredefined properties with user-defined instance, or any\n+            // unredefined field access\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+\n+            // make sure that the value was not cleared\n+            Field field = getUnenhancedClass().getDeclaredField(\n+                isFieldAccessTest() ? \"stringField\" : \"sf\");\n+            field.setAccessible(true);\n+            assertEquals(\"foo\", field.get(un));\n+        }\n+\n+        em.close();\n+    }\n+\n+    protected abstract boolean isFieldAccessTest();\n+\n+    public void testLazyLoading()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newUnenhancedInstance();\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        assertTrue(getUnenhancedClass() != un.getClass());\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\n+            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\n+\n+        // we only expect lazy loading to work when we can redefine classes\n+        // or when accessing a property-access record that OpenJPA created.\n+        if (ClassRedefiner.canRedefineClasses()\n+            || (sm.getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD))\n+        {\n+            assertFalse(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+            // make sure that the value was cleared\n+            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\n+            field.setAccessible(true);\n+            assertEquals(null, field.get(un));\n+        } else {\n+            // unredefined field access\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+            // make sure that the value was loaded already\n+            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\n+            field.setAccessible(true);\n+            assertEquals(\"lazy\", field.get(un));\n+        }\n+\n+        // make sure that the value is available, one way or another\n+        assertEquals(\"lazy\", un.getLazyField());\n+        assertTrue(sm.getLoaded()\n+            .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+        em.close();\n+    }\n+\n+    public void testSerializationOfUserDefinedInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(true, false);\n+    }\n+\n+    public void testSerializationOfUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(true, true);\n+    }\n+\n+    public void testSerializationOfOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(false, false);\n+    }\n+\n+    public void testSerializationOfOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(false, true);\n+    }\n+\n+    private void serializationHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+\n+        if (sub) {\n+            UnenhancedType related = newInstance(false);\n+            related.setStringField(\"related\");\n+            ((UnenhancedSubtype) un).setRelated(related);\n+        }\n+\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        ObjectOutputStream oout = new ObjectOutputStream(out);\n+        oout.writeObject(un);\n+        oout.flush();\n+        byte[] bytes = out.toByteArray();\n+\n+        ObjectInputStream oin = new ObjectInputStream(\n+            new ByteArrayInputStream(bytes));\n+        UnenhancedType deserialized = (UnenhancedType) oin.readObject();\n+\n+        copiedInstanceHelper(sub, em, un, deserialized, false);\n+        em.close();\n+    }\n+\n+    public void testCloningOfUserDefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(true, false);\n+    }\n+\n+    public void testCloningOfUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(true, true);\n+    }\n+\n+    public void testCloningOfOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(false, false);\n+    }\n+\n+    public void testCloningOfOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(false, true);\n+    }\n+\n+    private void cloneHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+\n+        if (sub) {\n+            UnenhancedType related = newInstance(false);\n+            related.setStringField(\"related\");\n+            ((UnenhancedSubtype) un).setRelated(related);\n+        }\n+\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        UnenhancedType cloned = (UnenhancedType) un.clone();\n+\n+        copiedInstanceHelper(sub, em, un, cloned, true);\n+        em.close();\n+    }\n+\n+    private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\n+        UnenhancedType un, UnenhancedType copy, boolean viaClone) {\n+        assertNotSame(un, copy);\n+        if (!viaClone)\n+            assertEquals(sub ? getUnenhancedSubclass() : getUnenhancedClass(),\n+                copy.getClass());\n+        assertEquals(un.getId(), copy.getId());\n+        assertEquals(un.getStringField(), copy.getStringField());\n+        if (sub) {\n+            assertEquals(\n+                ((UnenhancedSubtype) un).getIntField(),\n+                ((UnenhancedSubtype) copy).getIntField());\n+            assertNotSame(\n+                ((UnenhancedSubtype) un).getRelated(),\n+                ((UnenhancedSubtype) copy).getRelated());\n+            assertEquals(\n+                ((UnenhancedSubtype) un).getRelated().getId(),\n+                ((UnenhancedSubtype) copy).getRelated().getId());\n+        }\n+\n+        assertFalse(em.isDetached(un));\n+        assertTrue(em.isDetached(copy));\n+        copy.setStringField(\"offline update\");\n+\n+        em.getTransaction().begin();\n+        assertSame(un, em.merge(copy));\n+        assertTrue(em.isDirty(un));\n+        assertEquals(\"offline update\", un.getStringField());\n+        em.getTransaction().commit();\n+    }\n+\n+    public void testListenersOnUserDefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(true, false);\n+    }\n+\n+    public void testListenersOnUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(true, true);\n+    }\n+\n+    public void testListenersOnOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(false, false);\n+    }\n+\n+    public void testListenersOnOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(false, true);\n+    }\n+\n+    private void listenerHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        ListenerImpl listener = new ListenerImpl();\n+        emf.addLifecycleListener(listener, (Class[]) null);\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        listener.invoked = false;\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        em.getTransaction().begin();\n+        un.setStringField(\"updated\");\n+        em.getTransaction().commit();\n+        assertTrue(listener.invoked);\n+        em.close();\n+\n+        assertEquals(\"updated\", listener.stringField);\n+    }\n+\n+    public void testGetMetaDataOfSubtype() {\n+        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\n+            getUnenhancedClass());\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedClass()), null);\n+        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\n+\n+        meta = JPAFacadeHelper.getMetaData(emf, getUnenhancedSubclass());\n+        subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedSubclass()), null);\n+        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\n+    }\n+\n+    private class ListenerImpl\n+        extends AbstractLifecycleListener {\n+\n+        String stringField;\n+        boolean invoked;\n+\n+        @Override\n+        public void afterStore(LifecycleEvent event) {\n+            invoked = true;\n+            stringField = ((UnenhancedType) event.getSource()).getStringField();\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"c3ab5d217aed21ba58efb48c0555c60f8e5d360b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.List;\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-public class TestDataCachingAndUnenhancedPropertyAccess\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    @Override\r\n-    public void setUp() {\r\n-        setUp(UnenhancedIdentityIdPropertyAccess.class, CLEAR_TABLES,\r\n-            \"openjpa.DataCache\", \"true\",\r\n-            \"openjpa.RemoteCommitProvider\", \"sjvm\");\r\n-    }\r\n-\r\n-    public void testSimpleDataCacheOperation() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        em.persist(new UnenhancedIdentityIdPropertyAccess());\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testAccessIdBeforeCommit() {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedIdentityIdPropertyAccess o =\r\n-            new UnenhancedIdentityIdPropertyAccess();\r\n-        em.persist(o);\r\n-        em.getObjectId(o);\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.List;\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+public class TestDataCachingAndUnenhancedPropertyAccess\n+    extends SingleEMFTestCase {\n+\n+    @Override\n+    public void setUp() {\n+        setUp(UnenhancedIdentityIdPropertyAccess.class, CLEAR_TABLES,\n+            \"openjpa.DataCache\", \"true\",\n+            \"openjpa.RemoteCommitProvider\", \"sjvm\");\n+    }\n+\n+    public void testSimpleDataCacheOperation() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.persist(new UnenhancedIdentityIdPropertyAccess());\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testAccessIdBeforeCommit() {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedIdentityIdPropertyAccess o =\n+            new UnenhancedIdentityIdPropertyAccess();\n+        em.persist(o);\n+        em.getObjectId(o);\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n }\n\\ No newline at end of file"},{"sha":"4348b23b976d9c8a7f360eb57a57167c8add4f8c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,45 +1,45 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-public class TestEnhancementConfiguration\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    public void testEnhancementConfiguration() {\r\n-        try {\r\n-            emf = createEMF(\r\n-                \"openjpa.RuntimeUnenhancedClasses\", \"unsupported\",\r\n-                UnenhancedFieldAccess.class, CLEAR_TABLES);\r\n-            assertFalse(ImplHelper.isManagedType(emf.getConfiguration(),\r\n-                UnenhancedFieldAccess.class));\r\n-            emf.createEntityManager().close();\r\n-            fail(\"should not be possible to fully-initialize a system \" +\r\n-                \"that depends on unenhanced types but disables runtime\" +\r\n-                \"redefinition.\");\r\n-        } catch (Exception e) {\r\n-            assertTrue(e.getMessage().contains(\r\n-                \"This configuration disallows runtime optimization\"));\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+public class TestEnhancementConfiguration\n+    extends SingleEMFTestCase {\n+\n+    public void testEnhancementConfiguration() {\n+        try {\n+            emf = createEMF(\n+                \"openjpa.RuntimeUnenhancedClasses\", \"unsupported\",\n+                UnenhancedFieldAccess.class, CLEAR_TABLES);\n+            assertFalse(ImplHelper.isManagedType(emf.getConfiguration(),\n+                UnenhancedFieldAccess.class));\n+            emf.createEntityManager().close();\n+            fail(\"should not be possible to fully-initialize a system \" +\n+                \"that depends on unenhanced types but disables runtime\" +\n+                \"redefinition.\");\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(\n+                \"This configuration disallows runtime optimization\"));\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"44077384fc3daa7e93cb4052d0648cdaf87e143e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,46 +1,46 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import junit.framework.TestCase;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCMethod;\r\n-import serp.bytecode.Project;\r\n-\r\n-public class TestPCEnhancerFindField\r\n-    extends TestCase {\r\n-\r\n-    private String field;\r\n-\r\n-    public String myMethod() {\r\n-        if (Math.abs(1) == 1)\r\n-            return field;\r\n-        else\r\n-            return field;\r\n-    }\r\n-\r\n-    public void testPCEnhancerFindField() {\r\n-        Project proj = new Project();\r\n-        BCClass bc = proj.loadClass(getClass());\r\n-        BCMethod meth = bc.getMethods(\"myMethod\")[0];\r\n-        BCField field = PCEnhancer.getReturnedField(meth);\r\n-        assertEquals(\"field\", field.getName());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import junit.framework.TestCase;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Project;\n+\n+public class TestPCEnhancerFindField\n+    extends TestCase {\n+\n+    private String field;\n+\n+    public String myMethod() {\n+        if (Math.abs(1) == 1)\n+            return field;\n+        else\n+            return field;\n+    }\n+\n+    public void testPCEnhancerFindField() {\n+        Project proj = new Project();\n+        BCClass bc = proj.loadClass(getClass());\n+        BCMethod meth = bc.getMethods(\"myMethod\")[0];\n+        BCField field = PCEnhancer.getReturnedField(meth);\n+        assertEquals(\"field\", field.getName());\n+    }\n+}"},{"sha":"677d1d81481dca64b2498baf20bdcf2f53dd8f7e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,38 +1,38 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-public class TestRelationToUnlistedClass\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedUnlistedReferer.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testRelationToUnlistedClass() {\r\n-        try {\r\n-            emf.createEntityManager().close();\r\n-            fail(\"should not be able to initialize system\");\r\n-        } catch (Exception e) {\r\n-            assertTrue(e.getMessage().startsWith(\"One or more of the types\"));\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+public class TestRelationToUnlistedClass\n+    extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedUnlistedReferer.class, CLEAR_TABLES);\n+    }\n+\n+    public void testRelationToUnlistedClass() {\n+        try {\n+            emf.createEntityManager().close();\n+            fail(\"should not be able to initialize system\");\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().startsWith(\"One or more of the types\"));\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"36f3949ec4b1728119b9caaee47252435180e149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,75 +1,75 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n-\r\n-public class TestUnenhancedCompoundPK\r\n-    extends SingleEMTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedCompoundPKFieldAccess.class,\r\n-            UnenhancedCompoundPKPropertyAccess.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessUserDefined() {\r\n-        UnenhancedCompoundPKFieldAccess un\r\n-            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n-        UnenhancedCompoundPKFieldAccess.PK oid\r\n-            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKFieldAccess un\r\n-            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n-        UnenhancedCompoundPKFieldAccess.PK oid\r\n-            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    public void testCompoundPKPropertyAccessUserDefined() {\r\n-        UnenhancedCompoundPKPropertyAccess un\r\n-            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n-        UnenhancedCompoundPKPropertyAccess.PK oid\r\n-            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKPropertyAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKPropertyAccess un\r\n-            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n-        UnenhancedCompoundPKPropertyAccess.PK oid\r\n-            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\r\n-        em.getTransaction().begin();\r\n-        em.persist(o);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        em.find(o.getClass(), oid);\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n+\n+public class TestUnenhancedCompoundPK\n+    extends SingleEMTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedCompoundPKFieldAccess.class,\n+            UnenhancedCompoundPKPropertyAccess.class, CLEAR_TABLES);\n+    }\n+\n+    public void testCompoundPKFieldAccessUserDefined() {\n+        UnenhancedCompoundPKFieldAccess un\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\n+        UnenhancedCompoundPKFieldAccess.PK oid\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKFieldAccessOpenJPADefined() {\n+        UnenhancedCompoundPKFieldAccess un\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\n+        UnenhancedCompoundPKFieldAccess.PK oid\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    public void testCompoundPKPropertyAccessUserDefined() {\n+        UnenhancedCompoundPKPropertyAccess un\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\n+        UnenhancedCompoundPKPropertyAccess.PK oid\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKPropertyAccessOpenJPADefined() {\n+        UnenhancedCompoundPKPropertyAccess un\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\n+        UnenhancedCompoundPKPropertyAccess.PK oid\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\n+        em.getTransaction().begin();\n+        em.persist(o);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        em.find(o.getClass(), oid);\n+    }\n }\n\\ No newline at end of file"},{"sha":"866bbc5bee6c06761bd90ff06e72babfc23f3f20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,57 +1,57 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n-\r\n-public class TestUnenhancedCompoundPKSubclass extends SingleEMTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedCompoundPKFieldAccessSuperclass.class,\r\n-            UnenhancedCompoundPKFieldAccessSubclass.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessUserDefined() {\r\n-        UnenhancedCompoundPKFieldAccessSuperclass un =\r\n-            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\r\n-        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\r\n-            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKFieldAccessSuperclass un =\r\n-            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\r\n-        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\r\n-            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\r\n-        em.getTransaction().begin();\r\n-        em.persist(o);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        em.find(o.getClass(), oid);\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n+\n+public class TestUnenhancedCompoundPKSubclass extends SingleEMTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedCompoundPKFieldAccessSuperclass.class,\n+            UnenhancedCompoundPKFieldAccessSubclass.class, CLEAR_TABLES);\n+    }\n+\n+    public void testCompoundPKFieldAccessUserDefined() {\n+        UnenhancedCompoundPKFieldAccessSuperclass un =\n+            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\n+        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\n+            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKFieldAccessOpenJPADefined() {\n+        UnenhancedCompoundPKFieldAccessSuperclass un =\n+            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\n+        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\n+            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\n+        em.getTransaction().begin();\n+        em.persist(o);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        em.find(o.getClass(), oid);\n+    }\n+}"},{"sha":"1e69bf9170405d7cfe5dcc6cf5bcfdbaf565cc25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedFieldAccess\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedFieldAccess.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedFieldAccess();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedFieldAccessSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedFieldAccessSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return true;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedFieldAccess\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedFieldAccess.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedFieldAccess();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedFieldAccessSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedFieldAccessSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return true;\n+    }\n+}"},{"sha":"01b3294f53a3e05549e31cc2eb14f66c63943caf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,42 +1,42 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedFieldAccessPrimitiveWrapper\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedFieldAccessPrimitiveWrapper.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedFieldAccessPrimitiveWrapper();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedFieldAccessPrimitiveWrapperSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedFieldAccessPrimitiveWrapperSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return true;\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedFieldAccessPrimitiveWrapper\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedFieldAccessPrimitiveWrapper.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedFieldAccessPrimitiveWrapper();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedFieldAccessPrimitiveWrapperSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedFieldAccessPrimitiveWrapperSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return true;\n+    }\n+}"},{"sha":"638018e5ac44a2effc583b577274faedc43e25dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedPropertyAccess\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedPropertyAccess.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedPropertyAccess();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedPropertyAccessSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedPropertyAccessSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return false;\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedPropertyAccess\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedPropertyAccess.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedPropertyAccess();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedPropertyAccessSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedPropertyAccessSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return false;\n+    }\n }\n\\ No newline at end of file"},{"sha":"33298a5cf356431f08bd4f939007db1f2b045389","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,87 +1,87 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.IdClass;\r\n-import javax.persistence.Id;\r\n-\r\n-import org.apache.openjpa.enhance.UnenhancedCompoundPKFieldAccess.PK;\r\n-\r\n-@Entity\r\n-@IdClass(PK.class)\r\n-public class UnenhancedCompoundPKFieldAccess {\r\n-\r\n-    @Id private int id0;\r\n-    @Id private int id1;\r\n-\r\n-    protected UnenhancedCompoundPKFieldAccess() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKFieldAccess(\r\n-        int i0, int i1) {\r\n-        id0 = i0;\r\n-        id1 = i1;\r\n-    }\r\n-\r\n-    public static class PK {\r\n-        static {\r\n-            // register persistent class in JVM\r\n-            try {\r\n-                Class.forName(UnenhancedCompoundPKFieldAccess.class.getName());\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-            }\r\n-        }\r\n-\r\n-        public int id0;\r\n-        public int id1;\r\n-\r\n-        public PK() {\r\n-        }\r\n-\r\n-        public PK(int i0, int i1) {\r\n-            id0 = i0;\r\n-            id1 = i1;\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.valueOf(id0)\r\n-                + \"::\" + String.valueOf(id1);\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            int rs = 17;\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            return rs;\r\n-        }\r\n-\r\n-        public boolean equals(Object obj) {\r\n-            if(this == obj)\r\n-                return true;\r\n-            if(obj == null || obj.getClass() != getClass())\r\n-                return false;\r\n-\r\n-            PK other = (PK) obj;\r\n-            return (id0 == other.id0)\r\n-                && (id1 == other.id1);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.IdClass;\n+import javax.persistence.Id;\n+\n+import org.apache.openjpa.enhance.UnenhancedCompoundPKFieldAccess.PK;\n+\n+@Entity\n+@IdClass(PK.class)\n+public class UnenhancedCompoundPKFieldAccess {\n+\n+    @Id private int id0;\n+    @Id private int id1;\n+\n+    protected UnenhancedCompoundPKFieldAccess() {\n+    }\n+\n+    public UnenhancedCompoundPKFieldAccess(\n+        int i0, int i1) {\n+        id0 = i0;\n+        id1 = i1;\n+    }\n+\n+    public static class PK {\n+        static {\n+            // register persistent class in JVM\n+            try {\n+                Class.forName(UnenhancedCompoundPKFieldAccess.class.getName());\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        public int id0;\n+        public int id1;\n+\n+        public PK() {\n+        }\n+\n+        public PK(int i0, int i1) {\n+            id0 = i0;\n+            id1 = i1;\n+        }\n+\n+        public String toString() {\n+            return String.valueOf(id0)\n+                + \"::\" + String.valueOf(id1);\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            return rs;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if(this == obj)\n+                return true;\n+            if(obj == null || obj.getClass() != getClass())\n+                return false;\n+\n+            PK other = (PK) obj;\n+            return (id0 == other.id0)\n+                && (id1 == other.id1);\n+        }\n+    }\n+}"},{"sha":"f79a4c9b6e48486661631c90007b1a794cd5cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,34 +1,34 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.IdClass;\r\n-\r\n-@Entity\r\n-@IdClass(UnenhancedCompoundPKFieldAccessSubclass.PK.class)\r\n-public class UnenhancedCompoundPKFieldAccessSubclass\r\n-    extends UnenhancedCompoundPKFieldAccessSuperclass {\r\n-\r\n-    public UnenhancedCompoundPKFieldAccessSubclass() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKFieldAccessSubclass(int i0, int i1) {\r\n-        super(i0, i1);\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.IdClass;\n+\n+@Entity\n+@IdClass(UnenhancedCompoundPKFieldAccessSubclass.PK.class)\n+public class UnenhancedCompoundPKFieldAccessSubclass\n+    extends UnenhancedCompoundPKFieldAccessSuperclass {\n+\n+    public UnenhancedCompoundPKFieldAccessSubclass() {\n+    }\n+\n+    public UnenhancedCompoundPKFieldAccessSubclass(int i0, int i1) {\n+        super(i0, i1);\n+    }\n+}"},{"sha":"0b101412e10ad756e28c4daf13e566277a434856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","status":"modified","additions":88,"deletions":88,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,88 +1,88 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Id;\r\n-import javax.persistence.IdClass;\r\n-import javax.persistence.MappedSuperclass;\r\n-\r\n-@MappedSuperclass\r\n-@IdClass(UnenhancedCompoundPKFieldAccessSuperclass.PK.class)\r\n-public class UnenhancedCompoundPKFieldAccessSuperclass {\r\n-\r\n-    @Id\r\n-    private int id0;\r\n-    @Id\r\n-    private int id1;\r\n-\r\n-    protected UnenhancedCompoundPKFieldAccessSuperclass() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKFieldAccessSuperclass(int i0, int i1) {\r\n-        id0 = i0;\r\n-        id1 = i1;\r\n-    }\r\n-\r\n-    public static class PK {\r\n-\r\n-        static {\r\n-            // register persistent class in JVM\r\n-            try {\r\n-                Class.forName(\r\n-                    UnenhancedCompoundPKFieldAccessSuperclass.class.getName());\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-            }\r\n-        }\r\n-\r\n-        public int id0;\r\n-        public int id1;\r\n-\r\n-        public PK() {\r\n-        }\r\n-\r\n-        public PK(int i0, int i1) {\r\n-            id0 = i0;\r\n-            id1 = i1;\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.valueOf(id0)\r\n-                + \"::\" + String.valueOf(id1);\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            int rs = 17;\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            return rs;\r\n-        }\r\n-\r\n-        public boolean equals(Object obj) {\r\n-            if (this == obj)\r\n-                return true;\r\n-            if (obj == null || obj.getClass() != getClass())\r\n-                return false;\r\n-\r\n-            UnenhancedCompoundPKFieldAccessSuperclass.PK other =\r\n-                (UnenhancedCompoundPKFieldAccessSuperclass.PK) obj;\r\n-            return (id0 == other.id0)\r\n-                && (id1 == other.id1);\r\n-        }\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Id;\n+import javax.persistence.IdClass;\n+import javax.persistence.MappedSuperclass;\n+\n+@MappedSuperclass\n+@IdClass(UnenhancedCompoundPKFieldAccessSuperclass.PK.class)\n+public class UnenhancedCompoundPKFieldAccessSuperclass {\n+\n+    @Id\n+    private int id0;\n+    @Id\n+    private int id1;\n+\n+    protected UnenhancedCompoundPKFieldAccessSuperclass() {\n+    }\n+\n+    public UnenhancedCompoundPKFieldAccessSuperclass(int i0, int i1) {\n+        id0 = i0;\n+        id1 = i1;\n+    }\n+\n+    public static class PK {\n+\n+        static {\n+            // register persistent class in JVM\n+            try {\n+                Class.forName(\n+                    UnenhancedCompoundPKFieldAccessSuperclass.class.getName());\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        public int id0;\n+        public int id1;\n+\n+        public PK() {\n+        }\n+\n+        public PK(int i0, int i1) {\n+            id0 = i0;\n+            id1 = i1;\n+        }\n+\n+        public String toString() {\n+            return String.valueOf(id0)\n+                + \"::\" + String.valueOf(id1);\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            return rs;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null || obj.getClass() != getClass())\n+                return false;\n+\n+            UnenhancedCompoundPKFieldAccessSuperclass.PK other =\n+                (UnenhancedCompoundPKFieldAccessSuperclass.PK) obj;\n+            return (id0 == other.id0)\n+                && (id1 == other.id1);\n+        }\n+    }\n+}"},{"sha":"03e33912f6de6f6a27ba78fc31a9cd86f2c2b3ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"modified","additions":122,"deletions":122,"changes":244,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,122 +1,122 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.IdClass;\r\n-import javax.persistence.Id;\r\n-\r\n-import org.apache.openjpa.enhance.UnenhancedCompoundPKPropertyAccess.PK;\r\n-\r\n-@Entity\r\n-@IdClass(PK.class)\r\n-public class UnenhancedCompoundPKPropertyAccess {\r\n-\r\n-    private int id0;\r\n-    private int id1;\r\n-\r\n-    protected UnenhancedCompoundPKPropertyAccess() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKPropertyAccess(\r\n-        int i0, int i1) {\r\n-        id0 = i0;\r\n-        id1 = i1;\r\n-    }\r\n-\r\n-    @Id\r\n-    public int getId0() {\r\n-        return id0;\r\n-    }\r\n-\r\n-    public void setId0(int id0) {\r\n-        this.id0 = id0;\r\n-    }\r\n-\r\n-    @Id\r\n-    public int getId1() {\r\n-        return id1;\r\n-    }\r\n-\r\n-    public void setId1(int id1) {\r\n-        this.id1 = id1;\r\n-    }\r\n-\r\n-    public static class PK {\r\n-        static {\r\n-            // register persistent class in JVM\r\n-            try {\r\n-                Class.forName(\r\n-                    UnenhancedCompoundPKPropertyAccess.class.getName());\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-            }\r\n-        }\r\n-\r\n-        public int id0;\r\n-        public int id1;\r\n-\r\n-        public PK() {\r\n-        }\r\n-\r\n-        public PK(int i0, int i1) {\r\n-            id0 = i0;\r\n-            id1 = i1;\r\n-        }\r\n-\r\n-        public int getId0() {\r\n-            return id0;\r\n-        }\r\n-\r\n-        public void setId0(int id0) {\r\n-            this.id0 = id0;\r\n-        }\r\n-\r\n-        public int getId1() {\r\n-            return id1;\r\n-        }\r\n-\r\n-        public void setId1(int id1) {\r\n-            this.id1 = id1;\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.valueOf(id0)\r\n-                + \"::\" + String.valueOf(id1);\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            int rs = 17;\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            return rs;\r\n-        }\r\n-\r\n-        public boolean equals(Object obj) {\r\n-            if(this == obj)\r\n-                return true;\r\n-            if(obj == null || obj.getClass() != getClass())\r\n-                return false;\r\n-\r\n-            PK other = (PK) obj;\r\n-            return (id0 == other.id0)\r\n-                && (id1 == other.id1);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.IdClass;\n+import javax.persistence.Id;\n+\n+import org.apache.openjpa.enhance.UnenhancedCompoundPKPropertyAccess.PK;\n+\n+@Entity\n+@IdClass(PK.class)\n+public class UnenhancedCompoundPKPropertyAccess {\n+\n+    private int id0;\n+    private int id1;\n+\n+    protected UnenhancedCompoundPKPropertyAccess() {\n+    }\n+\n+    public UnenhancedCompoundPKPropertyAccess(\n+        int i0, int i1) {\n+        id0 = i0;\n+        id1 = i1;\n+    }\n+\n+    @Id\n+    public int getId0() {\n+        return id0;\n+    }\n+\n+    public void setId0(int id0) {\n+        this.id0 = id0;\n+    }\n+\n+    @Id\n+    public int getId1() {\n+        return id1;\n+    }\n+\n+    public void setId1(int id1) {\n+        this.id1 = id1;\n+    }\n+\n+    public static class PK {\n+        static {\n+            // register persistent class in JVM\n+            try {\n+                Class.forName(\n+                    UnenhancedCompoundPKPropertyAccess.class.getName());\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        public int id0;\n+        public int id1;\n+\n+        public PK() {\n+        }\n+\n+        public PK(int i0, int i1) {\n+            id0 = i0;\n+            id1 = i1;\n+        }\n+\n+        public int getId0() {\n+            return id0;\n+        }\n+\n+        public void setId0(int id0) {\n+            this.id0 = id0;\n+        }\n+\n+        public int getId1() {\n+            return id1;\n+        }\n+\n+        public void setId1(int id1) {\n+            this.id1 = id1;\n+        }\n+\n+        public String toString() {\n+            return String.valueOf(id0)\n+                + \"::\" + String.valueOf(id1);\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            return rs;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if(this == obj)\n+                return true;\n+            if(obj == null || obj.getClass() != getClass())\n+                return false;\n+\n+            PK other = (PK) obj;\n+            return (id0 == other.id0)\n+                && (id1 == other.id1);\n+        }\n+    }\n+}"},{"sha":"acfbaa2c3928a3f7646aa6f60d22acb2b42c6c51","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,81 +1,81 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.Serializable;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Version;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.Inheritance;\r\n-import javax.persistence.InheritanceType;\r\n-import javax.persistence.Table;\r\n-import javax.persistence.Basic;\r\n-import javax.persistence.FetchType;\r\n-\r\n-import org.apache.openjpa.persistence.DetachedState;\r\n-\r\n-@Entity\r\n-@Table(name=\"UN_FIELD\")\r\n-@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n-public class UnenhancedFieldAccess\r\n-    implements UnenhancedType, Serializable, Cloneable {\r\n-    \r\n-    @Id @GeneratedValue private int id;\r\n-    @Version public int version;\r\n-    protected String stringField = \"foo\";\r\n-\r\n-    @Basic(fetch = FetchType.LAZY)\r\n-    private String lazyField = \"lazy\";\r\n-\r\n-    public int getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setStringField(String s) {\r\n-        stringField = s;\r\n-    }\r\n-\r\n-    public String getStringField() {\r\n-        return stringField;\r\n-    }\r\n-\r\n-    public String getLazyField() {\r\n-        return lazyField;\r\n-    }\r\n-\r\n-    public boolean equals(Object o) {\r\n-        if (o == this)\r\n-            return true;\r\n-        if (o == null)\r\n-            return false;\r\n-        if (!getClass().isAssignableFrom(o.getClass()))\r\n-            return false;\r\n-\r\n-        return id == ((UnenhancedFieldAccess) o).id;\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        return super.clone();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.Serializable;\n+import javax.persistence.Entity;\n+import javax.persistence.Version;\n+import javax.persistence.Id;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Inheritance;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.Table;\n+import javax.persistence.Basic;\n+import javax.persistence.FetchType;\n+\n+import org.apache.openjpa.persistence.DetachedState;\n+\n+@Entity\n+@Table(name=\"UN_FIELD\")\n+@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n+public class UnenhancedFieldAccess\n+    implements UnenhancedType, Serializable, Cloneable {\n+    \n+    @Id @GeneratedValue private int id;\n+    @Version public int version;\n+    protected String stringField = \"foo\";\n+\n+    @Basic(fetch = FetchType.LAZY)\n+    private String lazyField = \"lazy\";\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setStringField(String s) {\n+        stringField = s;\n+    }\n+\n+    public String getStringField() {\n+        return stringField;\n+    }\n+\n+    public String getLazyField() {\n+        return lazyField;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+        if (o == null)\n+            return false;\n+        if (!getClass().isAssignableFrom(o.getClass()))\n+            return false;\n+\n+        return id == ((UnenhancedFieldAccess) o).id;\n+    }\n+\n+    public int hashCode() {\n+        return id;\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+}"},{"sha":"31c009a84689d904afc140ea1f9bb69bf7af8cda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,81 +1,81 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.Serializable;\r\n-import javax.persistence.Basic;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.FetchType;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.Inheritance;\r\n-import javax.persistence.InheritanceType;\r\n-import javax.persistence.Table;\r\n-import javax.persistence.Version;\r\n-\r\n-@Entity\r\n-@Table(name = \"UN_FIELD_WRAP\")\r\n-@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n-public class UnenhancedFieldAccessPrimitiveWrapper\r\n-    implements UnenhancedType, Serializable, Cloneable {\r\n-\r\n-    @Id\r\n-    @GeneratedValue\r\n-    private Integer id;\r\n-    @Version\r\n-    public int version;\r\n-    protected String stringField = \"foo\";\r\n-\r\n-    @Basic(fetch = FetchType.LAZY)\r\n-    private String lazyField = \"lazy\";\r\n-\r\n-    public int getId() {\r\n-        return id == null ? -1 : id;\r\n-    }\r\n-\r\n-    public void setStringField(String s) {\r\n-        stringField = s;\r\n-    }\r\n-\r\n-    public String getStringField() {\r\n-        return stringField;\r\n-    }\r\n-\r\n-    public String getLazyField() {\r\n-        return lazyField;\r\n-    }\r\n-\r\n-    public boolean equals(Object o) {\r\n-        if (o == this)\r\n-            return true;\r\n-        if (o == null)\r\n-            return false;\r\n-        if (!getClass().isAssignableFrom(o.getClass()))\r\n-            return false;\r\n-\r\n-        return id == ((UnenhancedFieldAccessPrimitiveWrapper) o).id;\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return id == null ? 0 : id;\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        return super.clone();\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.Serializable;\n+import javax.persistence.Basic;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.Inheritance;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.Table;\n+import javax.persistence.Version;\n+\n+@Entity\n+@Table(name = \"UN_FIELD_WRAP\")\n+@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n+public class UnenhancedFieldAccessPrimitiveWrapper\n+    implements UnenhancedType, Serializable, Cloneable {\n+\n+    @Id\n+    @GeneratedValue\n+    private Integer id;\n+    @Version\n+    public int version;\n+    protected String stringField = \"foo\";\n+\n+    @Basic(fetch = FetchType.LAZY)\n+    private String lazyField = \"lazy\";\n+\n+    public int getId() {\n+        return id == null ? -1 : id;\n+    }\n+\n+    public void setStringField(String s) {\n+        stringField = s;\n+    }\n+\n+    public String getStringField() {\n+        return stringField;\n+    }\n+\n+    public String getLazyField() {\n+        return lazyField;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+        if (o == null)\n+            return false;\n+        if (!getClass().isAssignableFrom(o.getClass()))\n+            return false;\n+\n+        return id == ((UnenhancedFieldAccessPrimitiveWrapper) o).id;\n+    }\n+\n+    public int hashCode() {\n+        return id == null ? 0 : id;\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+}"},{"sha":"d8780d021fbbfe217ff4712a3530da767e9728c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,55 +1,55 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.CascadeType;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.OneToOne;\r\n-\r\n-@Entity\r\n-public class UnenhancedFieldAccessPrimitiveWrapperSubclass\r\n-    extends UnenhancedFieldAccessPrimitiveWrapper\r\n-    implements UnenhancedSubtype {\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL)\r\n-    private UnenhancedFieldAccessPrimitiveWrapper related;\r\n-    private int intField;\r\n-\r\n-    public UnenhancedType getRelated() {\r\n-        return related;\r\n-    }\r\n-\r\n-    public void setRelated(UnenhancedType related) {\r\n-        this.related = (UnenhancedFieldAccessPrimitiveWrapper) related;\r\n-    }\r\n-\r\n-    public void setIntField(int i) {\r\n-        intField = i;\r\n-    }\r\n-\r\n-    public int getIntField() {\r\n-        return intField;\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        UnenhancedFieldAccessPrimitiveWrapperSubclass un =\r\n-            (UnenhancedFieldAccessPrimitiveWrapperSubclass) super.clone();\r\n-        un.setRelated((UnenhancedType) getRelated().clone());\r\n-        return un;\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.OneToOne;\n+\n+@Entity\n+public class UnenhancedFieldAccessPrimitiveWrapperSubclass\n+    extends UnenhancedFieldAccessPrimitiveWrapper\n+    implements UnenhancedSubtype {\n+\n+    @OneToOne(cascade = CascadeType.ALL)\n+    private UnenhancedFieldAccessPrimitiveWrapper related;\n+    private int intField;\n+\n+    public UnenhancedType getRelated() {\n+        return related;\n+    }\n+\n+    public void setRelated(UnenhancedType related) {\n+        this.related = (UnenhancedFieldAccessPrimitiveWrapper) related;\n+    }\n+\n+    public void setIntField(int i) {\n+        intField = i;\n+    }\n+\n+    public int getIntField() {\n+        return intField;\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        UnenhancedFieldAccessPrimitiveWrapperSubclass un =\n+            (UnenhancedFieldAccessPrimitiveWrapperSubclass) super.clone();\n+        un.setRelated((UnenhancedType) getRelated().clone());\n+        return un;\n+    }\n+}"},{"sha":"ac928a6c7adaf9207f13a4dd18d4cb216a4cdd8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,56 +1,56 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.CascadeType;\r\n-\r\n-@Entity\r\n-public class UnenhancedFieldAccessSubclass\r\n-    extends UnenhancedFieldAccess \r\n-    implements UnenhancedSubtype {\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL)\r\n-    private UnenhancedFieldAccess related;\r\n-    private int intField;\r\n-\r\n-    public UnenhancedType getRelated() {\r\n-        return related;\r\n-    }\r\n-\r\n-    public void setRelated(UnenhancedType related) {\r\n-        this.related = (UnenhancedFieldAccess) related;\r\n-    }\r\n-\r\n-    public void setIntField(int i) {\r\n-        intField = i;\r\n-    }\r\n-\r\n-    public int getIntField() {\r\n-        return intField;\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        UnenhancedFieldAccessSubclass un =\r\n-            (UnenhancedFieldAccessSubclass) super.clone();\r\n-        un.setRelated((UnenhancedType) getRelated().clone());\r\n-        return un;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.OneToOne;\n+import javax.persistence.Entity;\n+import javax.persistence.CascadeType;\n+\n+@Entity\n+public class UnenhancedFieldAccessSubclass\n+    extends UnenhancedFieldAccess \n+    implements UnenhancedSubtype {\n+\n+    @OneToOne(cascade = CascadeType.ALL)\n+    private UnenhancedFieldAccess related;\n+    private int intField;\n+\n+    public UnenhancedType getRelated() {\n+        return related;\n+    }\n+\n+    public void setRelated(UnenhancedType related) {\n+        this.related = (UnenhancedFieldAccess) related;\n+    }\n+\n+    public void setIntField(int i) {\n+        intField = i;\n+    }\n+\n+    public int getIntField() {\n+        return intField;\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        UnenhancedFieldAccessSubclass un =\n+            (UnenhancedFieldAccessSubclass) super.clone();\n+        un.setRelated((UnenhancedType) getRelated().clone());\n+        return un;\n+    }\n+}"},{"sha":"1044e0f3c99938d343149dab394caa6080d1362c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.GenerationType;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.PrePersist;\r\n-\r\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n-\r\n-@Entity\r\n-public class UnenhancedIdentityIdPropertyAccess {\r\n-\r\n-    private int id;\r\n-    private String stringField;\r\n-\r\n-    public UnenhancedIdentityIdPropertyAccess() {\r\n-    }\r\n-\r\n-    @Id\r\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n-    public int getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setId(int id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public String getStringField() {\r\n-        return stringField;\r\n-    }\r\n-\r\n-    public void setStringField(String stringField) {\r\n-        this.stringField = stringField;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.PrePersist;\n+\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+\n+@Entity\n+public class UnenhancedIdentityIdPropertyAccess {\n+\n+    private int id;\n+    private String stringField;\n+\n+    public UnenhancedIdentityIdPropertyAccess() {\n+    }\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public String getStringField() {\n+        return stringField;\n+    }\n+\n+    public void setStringField(String stringField) {\n+        this.stringField = stringField;\n+    }\n+}"},{"sha":"22efc08eed127653ccf7d9f0babf4c140e24a931","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"modified","additions":96,"deletions":96,"changes":192,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,97 +1,97 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.Serializable;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Version;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.Basic;\r\n-import javax.persistence.Inheritance;\r\n-import javax.persistence.InheritanceType;\r\n-import javax.persistence.Table;\r\n-import javax.persistence.FetchType;\r\n-\r\n-@Entity\r\n-@Table(name=\"UN_PROP\")\r\n-@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n-public class UnenhancedPropertyAccess\r\n-    implements UnenhancedType, Serializable, Cloneable {\r\n-\r\n-    private int id;\r\n-    private int version;\r\n-    private String sf = \"foo\";\r\n-    private String lazyField = \"lazy\";\r\n-\r\n-    @Id @GeneratedValue\r\n-    public int getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setId(int id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    @Version\r\n-    protected int getVersion() {\r\n-        return version;\r\n-    }\r\n-\r\n-    protected void setVersion(int v) {\r\n-        version = v;\r\n-    }\r\n-\r\n-    @Basic\r\n-    public String getStringField() {\r\n-        return sf;\r\n-    }\r\n-\r\n-    public void setStringField(String s) {\r\n-        sf = s;\r\n-    }\r\n-\r\n-    @Basic(fetch = FetchType.LAZY)\r\n-    public String getLazyField() {\r\n-        return lazyField;\r\n-    }\r\n-\r\n-    public void setLazyField(String s) {\r\n-        lazyField = s;\r\n-    }\r\n-\r\n-    public boolean equals(Object o) {\r\n-        if (o == this)\r\n-            return true;\r\n-        if (o == null)\r\n-            return false;\r\n-        if (!getClass().isAssignableFrom(o.getClass()))\r\n-            return false;\r\n-\r\n-        return getId() == ((UnenhancedPropertyAccess) o).getId();\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return getId();\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        return super.clone();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.Serializable;\n+import javax.persistence.Entity;\n+import javax.persistence.Version;\n+import javax.persistence.Id;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Basic;\n+import javax.persistence.Inheritance;\n+import javax.persistence.InheritanceType;\n+import javax.persistence.Table;\n+import javax.persistence.FetchType;\n+\n+@Entity\n+@Table(name=\"UN_PROP\")\n+@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n+public class UnenhancedPropertyAccess\n+    implements UnenhancedType, Serializable, Cloneable {\n+\n+    private int id;\n+    private int version;\n+    private String sf = \"foo\";\n+    private String lazyField = \"lazy\";\n+\n+    @Id @GeneratedValue\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    @Version\n+    protected int getVersion() {\n+        return version;\n+    }\n+\n+    protected void setVersion(int v) {\n+        version = v;\n+    }\n+\n+    @Basic\n+    public String getStringField() {\n+        return sf;\n+    }\n+\n+    public void setStringField(String s) {\n+        sf = s;\n+    }\n+\n+    @Basic(fetch = FetchType.LAZY)\n+    public String getLazyField() {\n+        return lazyField;\n+    }\n+\n+    public void setLazyField(String s) {\n+        lazyField = s;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == this)\n+            return true;\n+        if (o == null)\n+            return false;\n+        if (!getClass().isAssignableFrom(o.getClass()))\n+            return false;\n+\n+        return getId() == ((UnenhancedPropertyAccess) o).getId();\n+    }\n+\n+    public int hashCode() {\n+        return getId();\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n }\n\\ No newline at end of file"},{"sha":"de4cfa30a848eba647d418771a08575506bceac7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,60 +1,60 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.Transient;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.CascadeType;\r\n-\r\n-import org.apache.openjpa.persistence.Type;\r\n-\r\n-@Entity\r\n-public class UnenhancedPropertyAccessSubclass\r\n-    extends UnenhancedPropertyAccess\r\n-    implements UnenhancedSubtype {\r\n-\r\n-    private UnenhancedPropertyAccess related;\r\n-    private int intField;\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL)\r\n-    @Type(UnenhancedPropertyAccess.class)\r\n-    public UnenhancedType getRelated() {\r\n-        return related;\r\n-    }\r\n-\r\n-    public void setRelated(UnenhancedType related) {\r\n-        this.related = (UnenhancedPropertyAccess) related;\r\n-    }\r\n-\r\n-    public void setIntField(int i) {\r\n-        intField = i;\r\n-    }\r\n-\r\n-    public int getIntField() {\r\n-        return intField;\r\n-    }\r\n-\r\n-    public Object clone() throws CloneNotSupportedException {\r\n-        UnenhancedPropertyAccessSubclass un =\r\n-            (UnenhancedPropertyAccessSubclass) super.clone();\r\n-        un.setRelated((UnenhancedType) getRelated().clone());\r\n-        return un;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.OneToOne;\n+import javax.persistence.Transient;\n+import javax.persistence.Entity;\n+import javax.persistence.CascadeType;\n+\n+import org.apache.openjpa.persistence.Type;\n+\n+@Entity\n+public class UnenhancedPropertyAccessSubclass\n+    extends UnenhancedPropertyAccess\n+    implements UnenhancedSubtype {\n+\n+    private UnenhancedPropertyAccess related;\n+    private int intField;\n+\n+    @OneToOne(cascade = CascadeType.ALL)\n+    @Type(UnenhancedPropertyAccess.class)\n+    public UnenhancedType getRelated() {\n+        return related;\n+    }\n+\n+    public void setRelated(UnenhancedType related) {\n+        this.related = (UnenhancedPropertyAccess) related;\n+    }\n+\n+    public void setIntField(int i) {\n+        intField = i;\n+    }\n+\n+    public int getIntField() {\n+        return intField;\n+    }\n+\n+    public Object clone() throws CloneNotSupportedException {\n+        UnenhancedPropertyAccessSubclass un =\n+            (UnenhancedPropertyAccessSubclass) super.clone();\n+        un.setRelated((UnenhancedType) getRelated().clone());\n+        return un;\n+    }\n+}"},{"sha":"79331c7248bf9c206d7d10f68299054c65a06776","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public interface UnenhancedSubtype\r\n-    extends UnenhancedType {\r\n-\r\n-    UnenhancedType getRelated();\r\n-\r\n-    void setRelated(UnenhancedType related);\r\n-\r\n-    void setIntField(int i);\r\n-\r\n-    int getIntField();\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public interface UnenhancedSubtype\n+    extends UnenhancedType {\n+\n+    UnenhancedType getRelated();\n+\n+    void setRelated(UnenhancedType related);\n+\n+    void setIntField(int i);\n+\n+    int getIntField();\n+}"},{"sha":"ef19b8f1ef93b8b12e96c6edee65fcab5c2e1789","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,34 +1,34 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Used in {@link AbstractUnenhancedClassTest}\r\n- */\r\n-public interface UnenhancedType {\r\n-\r\n-    int getId();\r\n-\r\n-    void setStringField(String s);\r\n-    String getStringField();\r\n-\r\n-    String getLazyField();\r\n-\r\n-    Object clone() throws CloneNotSupportedException;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Used in {@link AbstractUnenhancedClassTest}\n+ */\n+public interface UnenhancedType {\n+\n+    int getId();\n+\n+    void setStringField(String s);\n+    String getStringField();\n+\n+    String getLazyField();\n+\n+    Object clone() throws CloneNotSupportedException;\n+}"},{"sha":"5bca64e0d83fac455829c82d17728c7d79f9c039","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Id;\r\n-\r\n-@Entity\r\n-public class UnenhancedUnlistedClass {\r\n-    @Id\r\n-    private int id;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class UnenhancedUnlistedClass {\n+    @Id\n+    private int id;\n+}"},{"sha":"b44ff2fedb2a7d4cdc7312509682e7c788748b82","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","status":"modified","additions":32,"deletions":32,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,32 +1,32 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.OneToOne;\r\n-\r\n-@Entity\r\n-public class UnenhancedUnlistedReferer {\r\n-    @Id\r\n-    private int id;\r\n-\r\n-    @OneToOne\r\n-    private UnenhancedUnlistedClass other;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+\n+@Entity\n+public class UnenhancedUnlistedReferer {\n+    @Id\n+    private int id;\n+\n+    @OneToOne\n+    private UnenhancedUnlistedClass other;\n+}"},{"sha":"26f684183541e3b1f98b051f0cd1e291892b2dd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,59 +1,59 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.persistence.simple.AllFieldTypes;\r\n-\r\n-public class TestLifecycleListener\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(AllFieldTypes.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testMutationsInLifecycleListener() {\r\n-        emf.addLifecycleListener(new AbstractLifecycleListener() {\r\n-            @Override\r\n-            public void beforePersist(LifecycleEvent event) {\r\n-                ((AllFieldTypes) event.getSource()).setLongField(17);\r\n-            }\r\n-        }, (Class[]) null);\r\n-\r\n-        AllFieldTypes aft = new AllFieldTypes();\r\n-        aft.setStringField(\"foo\");\r\n-        aft.setIntField(5);\r\n-\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        em.persist(aft);\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        aft = (AllFieldTypes) em.createQuery(\"select o from AllFieldTypes o\")\r\n-            .getSingleResult();\r\n-        // is changed in the listener impl\r\n-        assertEquals(17, aft.getLongField());\r\n-        em.close();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.persistence.simple.AllFieldTypes;\n+\n+public class TestLifecycleListener\n+    extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp(AllFieldTypes.class, CLEAR_TABLES);\n+    }\n+\n+    public void testMutationsInLifecycleListener() {\n+        emf.addLifecycleListener(new AbstractLifecycleListener() {\n+            @Override\n+            public void beforePersist(LifecycleEvent event) {\n+                ((AllFieldTypes) event.getSource()).setLongField(17);\n+            }\n+        }, (Class[]) null);\n+\n+        AllFieldTypes aft = new AllFieldTypes();\n+        aft.setStringField(\"foo\");\n+        aft.setIntField(5);\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.persist(aft);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        aft = (AllFieldTypes) em.createQuery(\"select o from AllFieldTypes o\")\n+            .getSingleResult();\n+        // is changed in the listener impl\n+        assertEquals(17, aft.getLongField());\n+        em.close();\n+    }\n }\n\\ No newline at end of file"},{"sha":"d9172f21616f9858b8c256dda7bb474ab54be5ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,86 +1,86 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-import java.util.Collections;\r\n-import javax.persistence.Persistence;\r\n-\r\n-import org.apache.openjpa.persistence.test.PersistenceTestCase;\r\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-import org.apache.openjpa.persistence.JPAFacadeHelper;\r\n-\r\n-public class TestSJVMRemoteCommitProvider\r\n-    extends PersistenceTestCase {\r\n-\r\n-    private OpenJPAEntityManagerFactorySPI emf1;\r\n-    private OpenJPAEntityManagerFactorySPI emf2;\r\n-    private ListenerImpl listen1;\r\n-    private ListenerImpl listen2;\r\n-\r\n-    public void setUp() {\r\n-        Map sjvm1 = new HashMap();\r\n-        sjvm1.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\r\n-        // set this to differentiate emf1 from the other emf below\r\n-        sjvm1.put(\"openjpa.DetachState\", \"true\");\r\n-        emf1 = (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(\r\n-            Persistence.createEntityManagerFactory(\"test\", sjvm1));\r\n-        emf1.getConfiguration().getRemoteCommitEventManager().addListener(\r\n-            listen1 = new ListenerImpl());\r\n-\r\n-        Map sjvm2 = new HashMap();\r\n-        sjvm2.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\r\n-        sjvm2.put(\"openjpa.DetachState\", \"false\"); // differentiate from above\r\n-        emf2 = (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(\r\n-            Persistence.createEntityManagerFactory(\"test\", sjvm2));\r\n-        emf2.getConfiguration().getRemoteCommitEventManager().addListener(\r\n-            listen2 = new ListenerImpl());\r\n-    }\r\n-\r\n-    public void testSJVMRemoteCommitProvider() {\r\n-        assertNotSame(JPAFacadeHelper.toBrokerFactory(emf1),\r\n-            JPAFacadeHelper.toBrokerFactory(emf2));\r\n-        \r\n-        emf1.getConfiguration().getRemoteCommitEventManager()\r\n-            .getRemoteCommitProvider().broadcast(\r\n-                new RemoteCommitEvent(RemoteCommitEvent.PAYLOAD_OIDS,\r\n-                    Collections.EMPTY_SET,\r\n-                    Collections.EMPTY_SET,\r\n-                    Collections.EMPTY_SET,\r\n-                    Collections.EMPTY_SET));\r\n-\r\n-        assertEquals(0, listen1.eventCount);\r\n-        assertEquals(1, listen2.eventCount);\r\n-    }\r\n-\r\n-    private class ListenerImpl\r\n-        implements RemoteCommitListener {\r\n-\r\n-        private int eventCount;\r\n-\r\n-        public void afterCommit(RemoteCommitEvent event) {\r\n-            eventCount++;\r\n-        }\r\n-\r\n-        public void close() {\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Collections;\n+import javax.persistence.Persistence;\n+\n+import org.apache.openjpa.persistence.test.PersistenceTestCase;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\n+\n+public class TestSJVMRemoteCommitProvider\n+    extends PersistenceTestCase {\n+\n+    private OpenJPAEntityManagerFactorySPI emf1;\n+    private OpenJPAEntityManagerFactorySPI emf2;\n+    private ListenerImpl listen1;\n+    private ListenerImpl listen2;\n+\n+    public void setUp() {\n+        Map sjvm1 = new HashMap();\n+        sjvm1.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\n+        // set this to differentiate emf1 from the other emf below\n+        sjvm1.put(\"openjpa.DetachState\", \"true\");\n+        emf1 = (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(\n+            Persistence.createEntityManagerFactory(\"test\", sjvm1));\n+        emf1.getConfiguration().getRemoteCommitEventManager().addListener(\n+            listen1 = new ListenerImpl());\n+\n+        Map sjvm2 = new HashMap();\n+        sjvm2.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\n+        sjvm2.put(\"openjpa.DetachState\", \"false\"); // differentiate from above\n+        emf2 = (OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(\n+            Persistence.createEntityManagerFactory(\"test\", sjvm2));\n+        emf2.getConfiguration().getRemoteCommitEventManager().addListener(\n+            listen2 = new ListenerImpl());\n+    }\n+\n+    public void testSJVMRemoteCommitProvider() {\n+        assertNotSame(JPAFacadeHelper.toBrokerFactory(emf1),\n+            JPAFacadeHelper.toBrokerFactory(emf2));\n+        \n+        emf1.getConfiguration().getRemoteCommitEventManager()\n+            .getRemoteCommitProvider().broadcast(\n+                new RemoteCommitEvent(RemoteCommitEvent.PAYLOAD_OIDS,\n+                    Collections.EMPTY_SET,\n+                    Collections.EMPTY_SET,\n+                    Collections.EMPTY_SET,\n+                    Collections.EMPTY_SET));\n+\n+        assertEquals(0, listen1.eventCount);\n+        assertEquals(1, listen2.eventCount);\n+    }\n+\n+    private class ListenerImpl\n+        implements RemoteCommitListener {\n+\n+        private int eventCount;\n+\n+        public void afterCommit(RemoteCommitEvent event) {\n+            eventCount++;\n+        }\n+\n+        public void close() {\n+        }\n+    }\n+}"},{"sha":"77ed7187289d221aa425477eb377e373002a997d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,79 +1,79 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import javax.persistence.CascadeType;\r\n-import javax.persistence.Column;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.GenerationType;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.JoinColumn;\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.Version;\r\n-\r\n-import org.apache.openjpa.persistence.jdbc.ForeignKey;\r\n-\r\n-@Entity\r\n-public class EntityA {\r\n-\r\n-    @Id\r\n-    @Column(name = \"entitya_id\", nullable = false)\r\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n-    private Integer id;\r\n-\r\n-    private String name;\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL, optional = false)\r\n-    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\",\r\n-        nullable = false)\r\n-    @ForeignKey\r\n-    private EntityB entityB;\r\n-\r\n-    @Version\r\n-    private Integer optLock;\r\n-\r\n-    public EntityA() {\r\n-    }\r\n-\r\n-    public void setId(Integer id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public Integer getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public EntityB getEntityB() {\r\n-        return this.entityB;\r\n-    }\r\n-\r\n-    public void setEntityB(EntityB entityB) {\r\n-        this.entityB = entityB;\r\n-    }\r\n-\r\n-    public String getName() {\r\n-        return this.name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Version;\n+\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\n+\n+@Entity\n+public class EntityA {\n+\n+    @Id\n+    @Column(name = \"entitya_id\", nullable = false)\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Integer id;\n+\n+    private String name;\n+\n+    @OneToOne(cascade = CascadeType.ALL, optional = false)\n+    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\",\n+        nullable = false)\n+    @ForeignKey\n+    private EntityB entityB;\n+\n+    @Version\n+    private Integer optLock;\n+\n+    public EntityA() {\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public EntityB getEntityB() {\n+        return this.entityB;\n+    }\n+\n+    public void setEntityB(EntityB entityB) {\n+        this.entityB = entityB;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+"},{"sha":"0c9f8697b41b87115e18f0e3e912811f2669d46d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,79 +1,79 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import javax.persistence.CascadeType;\r\n-import javax.persistence.Column;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.GenerationType;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.JoinColumn;\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.Version;\r\n-\r\n-import org.apache.openjpa.persistence.jdbc.ForeignKey;\r\n-\r\n-@Entity\r\n-public class EntityB {\r\n-\r\n-    @Id\r\n-    @Column(name = \"entityb_id\", nullable = false)\r\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n-    private Integer id;\r\n-\r\n-    private String name;\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL, optional = false)\r\n-    @JoinColumn(name = \"entityc_id\", referencedColumnName = \"entityc_id\",\r\n-        nullable = false)\r\n-    @ForeignKey\r\n-    private EntityC entityC;\r\n-\r\n-    @Version\r\n-    private Integer optLock;\r\n-\r\n-    public EntityB() {\r\n-    }\r\n-\r\n-    public void setId(Integer id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public Integer getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public EntityC getEntityC() {\r\n-        return this.entityC;\r\n-    }\r\n-\r\n-    public void setEntityC(EntityC entityC) {\r\n-        this.entityC = entityC;\r\n-    }\r\n-\r\n-    public String getName() {\r\n-        return this.name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Version;\n+\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\n+\n+@Entity\n+public class EntityB {\n+\n+    @Id\n+    @Column(name = \"entityb_id\", nullable = false)\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Integer id;\n+\n+    private String name;\n+\n+    @OneToOne(cascade = CascadeType.ALL, optional = false)\n+    @JoinColumn(name = \"entityc_id\", referencedColumnName = \"entityc_id\",\n+        nullable = false)\n+    @ForeignKey\n+    private EntityC entityC;\n+\n+    @Version\n+    private Integer optLock;\n+\n+    public EntityB() {\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public EntityC getEntityC() {\n+        return this.entityC;\n+    }\n+\n+    public void setEntityC(EntityC entityC) {\n+        this.entityC = entityC;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+"},{"sha":"36e7328d2d8d100873b8a268e01b1168bf1c1cbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,81 +1,81 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import javax.persistence.CascadeType;\r\n-import javax.persistence.Column;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.GenerationType;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.JoinColumn;\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.Version;\r\n-\r\n-import org.apache.openjpa.persistence.Dependent;\r\n-import org.apache.openjpa.persistence.jdbc.ForeignKey;\r\n-\r\n-@Entity\r\n-public class EntityC {\r\n-\r\n-    @Id\r\n-    @Column(name = \"entityc_id\", nullable = false)\r\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n-    private Integer id;\r\n-\r\n-    private String name;\r\n-\r\n-    @OneToOne(cascade = CascadeType.ALL, optional = false)\r\n-    @JoinColumn(name = \"entityd_id\", referencedColumnName = \"entityd_id\",\r\n-        nullable = false)\r\n-    @ForeignKey\r\n-    @Dependent\r\n-    private EntityD entityD;\r\n-\r\n-    @Version\r\n-    private Integer optLock;\r\n-\r\n-    public EntityC() {\r\n-    }\r\n-\r\n-    public void setId(Integer id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public Integer getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public EntityD getEntityD() {\r\n-        return this.entityD;\r\n-    }\r\n-\r\n-    public void setEntityD(EntityD entityD) {\r\n-        this.entityD = entityD;\r\n-    }\r\n-\r\n-    public String getName() {\r\n-        return this.name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Version;\n+\n+import org.apache.openjpa.persistence.Dependent;\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\n+\n+@Entity\n+public class EntityC {\n+\n+    @Id\n+    @Column(name = \"entityc_id\", nullable = false)\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Integer id;\n+\n+    private String name;\n+\n+    @OneToOne(cascade = CascadeType.ALL, optional = false)\n+    @JoinColumn(name = \"entityd_id\", referencedColumnName = \"entityd_id\",\n+        nullable = false)\n+    @ForeignKey\n+    @Dependent\n+    private EntityD entityD;\n+\n+    @Version\n+    private Integer optLock;\n+\n+    public EntityC() {\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public EntityD getEntityD() {\n+        return this.entityD;\n+    }\n+\n+    public void setEntityD(EntityD entityD) {\n+        this.entityD = entityD;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+"},{"sha":"7239aace49a18303b4adaa5bcdb79aff82f39258","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":90,"deletions":90,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,90 +1,90 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import org.apache.openjpa.persistence.jdbc.ForeignKey;\r\n-\r\n-import javax.persistence.Column;\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.GeneratedValue;\r\n-import javax.persistence.GenerationType;\r\n-import javax.persistence.Id;\r\n-import javax.persistence.Version;\r\n-import javax.persistence.OneToOne;\r\n-import javax.persistence.JoinColumn;\r\n-\r\n-@Entity\r\n-public class EntityD {\r\n-\r\n-    @Id\r\n-    @Column(name = \"entityd_id\", nullable = false)\r\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n-    private Integer id;\r\n-\r\n-    private String name;\r\n-\r\n-    @OneToOne\r\n-    @JoinColumn(name = \"entitya_id\", referencedColumnName = \"entitya_id\")\r\n-    @ForeignKey\r\n-    private EntityA entityA;\r\n-    \r\n-    @OneToOne\r\n-    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\")\r\n-    @ForeignKey\r\n-    private EntityB entityB;\r\n-    \r\n-    @Version\r\n-    private Integer optLock;\r\n-\r\n-    public EntityD() {\r\n-    }\r\n-\r\n-    public void setId(Integer id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public Integer getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public EntityA getEntityA() {\r\n-        return this.entityA;\r\n-    }\r\n-\r\n-    public void setEntityA(EntityA entityA) {\r\n-        this.entityA = entityA;\r\n-    }\r\n-\r\n-    public EntityB getEntityB() {\r\n-        return entityB;\r\n-    }\r\n-\r\n-    public void setEntityB(EntityB entityB) {\r\n-        this.entityB = entityB;\r\n-    }\r\n-    \r\n-    public String getName() {\r\n-        return this.name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        this.name = name;\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.Version;\n+import javax.persistence.OneToOne;\n+import javax.persistence.JoinColumn;\n+\n+@Entity\n+public class EntityD {\n+\n+    @Id\n+    @Column(name = \"entityd_id\", nullable = false)\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Integer id;\n+\n+    private String name;\n+\n+    @OneToOne\n+    @JoinColumn(name = \"entitya_id\", referencedColumnName = \"entitya_id\")\n+    @ForeignKey\n+    private EntityA entityA;\n+    \n+    @OneToOne\n+    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\")\n+    @ForeignKey\n+    private EntityB entityB;\n+    \n+    @Version\n+    private Integer optLock;\n+\n+    public EntityD() {\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public EntityA getEntityA() {\n+        return this.entityA;\n+    }\n+\n+    public void setEntityA(EntityA entityA) {\n+        this.entityA = entityA;\n+    }\n+\n+    public EntityB getEntityB() {\n+        return entityB;\n+    }\n+\n+    public void setEntityB(EntityB entityB) {\n+        this.entityB = entityB;\n+    }\n+    \n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+"},{"sha":"2ca371885c908f1027dcafafb364c7777cc1bda5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":157,"deletions":157,"changes":314,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,157 +1,157 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-/**\r\n- * Test that sql statements get flushed in an order which does not violate\r\n- * non-nullable foreign key constraints on inserts and deletes.\r\n- *\r\n- * @author Reece Garrett\r\n- */\r\n-public class TestNoForeignKeyViolation\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    private EntityA entityA;\r\n-    private EntityB entityB;\r\n-    private EntityC entityC;\r\n-    private EntityD entityD;\r\n-\r\n-    public void setUp() {\r\n-        setUp(EntityA.class, EntityB.class, EntityC.class, EntityD.class, EntityE.class);\r\n-\r\n-        createTestData();\r\n-    }\r\n-\r\n-    private void createTestData() {\r\n-        entityA = new EntityA();\r\n-        entityB = new EntityB();\r\n-        entityC = new EntityC();\r\n-        entityD = new EntityD();\r\n-        entityA.setName(\"entityA\");\r\n-        entityB.setName(\"entityB\");\r\n-        entityC.setName(\"entityC\");\r\n-        entityD.setName(\"entityD\");\r\n-        entityA.setEntityB(entityB);\r\n-        entityB.setEntityC(entityC);\r\n-        entityC.setEntityD(entityD);\r\n-    }\r\n-\r\n-    public void testSqlOrder() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        try {\r\n-            em.getTransaction().begin();\r\n-            em.persist(entityA);\r\n-            em.getTransaction().commit();\r\n-\r\n-            EntityD newEntityD = new EntityD();\r\n-            newEntityD.setName(\"newEntityD\");\r\n-            entityC.setEntityD(newEntityD);\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.merge(entityC);\r\n-            em.getTransaction().commit();\r\n-\r\n-            EntityC newEntityC = new EntityC();\r\n-            newEntityC.setName(\"newEntityC\");\r\n-            newEntityD = new EntityD();\r\n-            newEntityD.setName(\"newNewEntityD\");\r\n-            newEntityC.setEntityD(newEntityD);\r\n-            entityB.setEntityC(newEntityC);\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.merge(entityB);\r\n-            em.getTransaction().commit();\r\n-        }\r\n-        finally {\r\n-            if (em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            em.close();\r\n-        }\r\n-    }\r\n-    \r\n-    public void testSimpleCycle() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        try {\r\n-            em.getTransaction().begin();\r\n-            entityD.setEntityA(entityA);\r\n-            em.persist(entityA);\r\n-            em.getTransaction().commit();\r\n-        }\r\n-        finally {\r\n-            if (em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            em.close();\r\n-        }\r\n-    }\r\n-    \r\n-    public void testComplexCycle() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        try {\r\n-            EntityE entityE = new EntityE();\r\n-            entityE.setName(\"entityE\");\r\n-            entityE.setEntityB(entityB);\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.persist(entityE);\r\n-            entityD.setEntityA(entityA);\r\n-            em.persist(entityA);\r\n-            em.getTransaction().commit();\r\n-            \r\n-            em.getTransaction().begin();\r\n-            em.remove(entityE);\r\n-            em.remove(entityA);\r\n-            em.getTransaction().commit();\r\n-        }\r\n-        finally {\r\n-            if (em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            em.close();\r\n-        }\r\n-    }\r\n-\r\n-    public void testComplexTwoCycles() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        try {\r\n-            EntityE entityE = new EntityE();\r\n-            entityE.setName(\"entityE\");\r\n-            entityE.setEntityB(entityB);\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.persist(entityE);\r\n-            entityD.setEntityA(entityA);\r\n-            entityD.setEntityB(entityB);\r\n-            em.persist(entityA);\r\n-            em.getTransaction().commit();\r\n-            \r\n-            em.getTransaction().begin();\r\n-            em.remove(entityE);\r\n-            em.remove(entityA);\r\n-            em.getTransaction().commit();\r\n-        }\r\n-        finally {\r\n-            if (em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            em.close();\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Test that sql statements get flushed in an order which does not violate\n+ * non-nullable foreign key constraints on inserts and deletes.\n+ *\n+ * @author Reece Garrett\n+ */\n+public class TestNoForeignKeyViolation\n+    extends SingleEMFTestCase {\n+\n+    private EntityA entityA;\n+    private EntityB entityB;\n+    private EntityC entityC;\n+    private EntityD entityD;\n+\n+    public void setUp() {\n+        setUp(EntityA.class, EntityB.class, EntityC.class, EntityD.class, EntityE.class);\n+\n+        createTestData();\n+    }\n+\n+    private void createTestData() {\n+        entityA = new EntityA();\n+        entityB = new EntityB();\n+        entityC = new EntityC();\n+        entityD = new EntityD();\n+        entityA.setName(\"entityA\");\n+        entityB.setName(\"entityB\");\n+        entityC.setName(\"entityC\");\n+        entityD.setName(\"entityD\");\n+        entityA.setEntityB(entityB);\n+        entityB.setEntityC(entityC);\n+        entityC.setEntityD(entityD);\n+    }\n+\n+    public void testSqlOrder() {\n+        EntityManager em = emf.createEntityManager();\n+        try {\n+            em.getTransaction().begin();\n+            em.persist(entityA);\n+            em.getTransaction().commit();\n+\n+            EntityD newEntityD = new EntityD();\n+            newEntityD.setName(\"newEntityD\");\n+            entityC.setEntityD(newEntityD);\n+\n+            em.getTransaction().begin();\n+            em.merge(entityC);\n+            em.getTransaction().commit();\n+\n+            EntityC newEntityC = new EntityC();\n+            newEntityC.setName(\"newEntityC\");\n+            newEntityD = new EntityD();\n+            newEntityD.setName(\"newNewEntityD\");\n+            newEntityC.setEntityD(newEntityD);\n+            entityB.setEntityC(newEntityC);\n+\n+            em.getTransaction().begin();\n+            em.merge(entityB);\n+            em.getTransaction().commit();\n+        }\n+        finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+    \n+    public void testSimpleCycle() {\n+        EntityManager em = emf.createEntityManager();\n+        try {\n+            em.getTransaction().begin();\n+            entityD.setEntityA(entityA);\n+            em.persist(entityA);\n+            em.getTransaction().commit();\n+        }\n+        finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+    \n+    public void testComplexCycle() {\n+        EntityManager em = emf.createEntityManager();\n+        try {\n+            EntityE entityE = new EntityE();\n+            entityE.setName(\"entityE\");\n+            entityE.setEntityB(entityB);\n+\n+            em.getTransaction().begin();\n+            em.persist(entityE);\n+            entityD.setEntityA(entityA);\n+            em.persist(entityA);\n+            em.getTransaction().commit();\n+            \n+            em.getTransaction().begin();\n+            em.remove(entityE);\n+            em.remove(entityA);\n+            em.getTransaction().commit();\n+        }\n+        finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+\n+    public void testComplexTwoCycles() {\n+        EntityManager em = emf.createEntityManager();\n+        try {\n+            EntityE entityE = new EntityE();\n+            entityE.setName(\"entityE\");\n+            entityE.setEntityB(entityB);\n+\n+            em.getTransaction().begin();\n+            em.persist(entityE);\n+            entityD.setEntityA(entityA);\n+            entityD.setEntityB(entityB);\n+            em.persist(entityA);\n+            em.getTransaction().commit();\n+            \n+            em.getTransaction().begin();\n+            em.remove(entityE);\n+            em.remove(entityA);\n+            em.getTransaction().commit();\n+        }\n+        finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+}"},{"sha":"f240d27db0a753ecef0458f3dd56a0579fddf673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,54 +1,54 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.kernel;\r\n-\r\n-import javax.persistence.Persistence;\r\n-\r\n-import junit.framework.TestCase;\r\n-import org.apache.openjpa.event.BrokerFactoryListener;\r\n-import org.apache.openjpa.event.BrokerFactoryEvent;\r\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-\r\n-public class TestBrokerFactoryEventManager\r\n-    extends TestCase {\r\n-\r\n-    public void testCreateEvent() {\r\n-        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\r\n-            OpenJPAPersistence.cast(\r\n-                Persistence.createEntityManagerFactory(\"test\"));\r\n-        ListenerImpl listener = new ListenerImpl();\r\n-        emf.getConfiguration().getBrokerFactoryEventManager()\r\n-            .addListener(listener);\r\n-        emf.createEntityManager().close();\r\n-        assertTrue(listener.createEventReceived);\r\n-        emf.close();\r\n-    }\r\n-\r\n-    private class ListenerImpl implements BrokerFactoryListener {\r\n-\r\n-        boolean createEventReceived = false;\r\n-\r\n-        public void eventFired(BrokerFactoryEvent event) {\r\n-            if (event.getEventType()\r\n-                == BrokerFactoryEvent.BROKER_FACTORY_CREATED)\r\n-                createEventReceived = true;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.kernel;\n+\n+import javax.persistence.Persistence;\n+\n+import junit.framework.TestCase;\n+import org.apache.openjpa.event.BrokerFactoryListener;\n+import org.apache.openjpa.event.BrokerFactoryEvent;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+\n+public class TestBrokerFactoryEventManager\n+    extends TestCase {\n+\n+    public void testCreateEvent() {\n+        OpenJPAEntityManagerFactorySPI emf = (OpenJPAEntityManagerFactorySPI)\n+            OpenJPAPersistence.cast(\n+                Persistence.createEntityManagerFactory(\"test\"));\n+        ListenerImpl listener = new ListenerImpl();\n+        emf.getConfiguration().getBrokerFactoryEventManager()\n+            .addListener(listener);\n+        emf.createEntityManager().close();\n+        assertTrue(listener.createEventReceived);\n+        emf.close();\n+    }\n+\n+    private class ListenerImpl implements BrokerFactoryListener {\n+\n+        boolean createEventReceived = false;\n+\n+        public void eventFired(BrokerFactoryEvent event) {\n+            if (event.getEventType()\n+                == BrokerFactoryEvent.BROKER_FACTORY_CREATED)\n+                createEventReceived = true;\n+        }\n+    }\n+}"},{"sha":"63dc8813a393366d422650aab0ce1188a5af5fd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java?ref=3b34f93d8090738fa2875cabb78a694babb49505","patch":"@@ -1,76 +1,76 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.kernel;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-import org.apache.openjpa.persistence.simple.AllFieldTypes;\r\n-import org.apache.openjpa.event.AbstractLifecycleListener;\r\n-import org.apache.openjpa.event.AbstractTransactionListener;\r\n-import org.apache.openjpa.event.LifecycleEvent;\r\n-import org.apache.openjpa.event.TransactionEvent;\r\n-\r\n-public class TestBrokerFactoryListenerRegistry\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    private int persistCount = 0;\r\n-    private int beginCount = 0;\r\n-\r\n-    @Override\r\n-    public void setUp() {\r\n-        super.setUp(AllFieldTypes.class);\r\n-    }\r\n-\r\n-    @Override\r\n-    protected OpenJPAEntityManagerFactorySPI createEMF(Object... props) {\r\n-        OpenJPAEntityManagerFactorySPI emf = super.createEMF(props);\r\n-        emf.addLifecycleListener(new AbstractLifecycleListener() {\r\n-            @Override\r\n-            public void beforePersist(LifecycleEvent event) {\r\n-                persistCount++;\r\n-            }\r\n-        }, null);\r\n-        emf.addTransactionListener(new AbstractTransactionListener() {\r\n-            @Override\r\n-            public void afterBegin(TransactionEvent event) {\r\n-                beginCount++;\r\n-            }\r\n-        });\r\n-        return emf;\r\n-    }\r\n-\r\n-    public void testLifecycleListenerRegistry() {\r\n-        beginCount = 0;\r\n-        persistCount = 0;\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        try {\r\n-            em.persist(new AllFieldTypes());\r\n-            em.flush();\r\n-            assertEquals(1, beginCount);\r\n-            assertEquals(1, persistCount);\r\n-        } finally {\r\n-            em.getTransaction().rollback();\r\n-            em.close();\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.kernel;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.simple.AllFieldTypes;\n+import org.apache.openjpa.event.AbstractLifecycleListener;\n+import org.apache.openjpa.event.AbstractTransactionListener;\n+import org.apache.openjpa.event.LifecycleEvent;\n+import org.apache.openjpa.event.TransactionEvent;\n+\n+public class TestBrokerFactoryListenerRegistry\n+    extends SingleEMFTestCase {\n+\n+    private int persistCount = 0;\n+    private int beginCount = 0;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp(AllFieldTypes.class);\n+    }\n+\n+    @Override\n+    protected OpenJPAEntityManagerFactorySPI createEMF(Object... props) {\n+        OpenJPAEntityManagerFactorySPI emf = super.createEMF(props);\n+        emf.addLifecycleListener(new AbstractLifecycleListener() {\n+            @Override\n+            public void beforePersist(LifecycleEvent event) {\n+                persistCount++;\n+            }\n+        }, null);\n+        emf.addTransactionListener(new AbstractTransactionListener() {\n+            @Override\n+            public void afterBegin(TransactionEvent event) {\n+                beginCount++;\n+            }\n+        });\n+        return emf;\n+    }\n+\n+    public void testLifecycleListenerRegistry() {\n+        beginCount = 0;\n+        persistCount = 0;\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        try {\n+            em.persist(new AllFieldTypes());\n+            em.flush();\n+            assertEquals(1, beginCount);\n+            assertEquals(1, persistCount);\n+        } finally {\n+            em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+}"},{"sha":"f6b9a378d1cd0db051afa7bfa5e9567ec445d715","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"6c680f396d953f78380404fb7c53026040fed2a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"8beb7ab736ea24ff0f777abb321cb8a5b19792d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"08c5920215ae8121adaee83d21602274327d6cdc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"b78fe8d34b60149ceba969d635985fd299593a58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"05ed3493fdc58c53daa645febc953b936b41d33c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"2b13764fba949b3424a444de42a01302ff964f61","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"39ef5ea8a20dc9cb3f99473fa076cb127f478357","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"7d009a87d32d1172de6c9ff85930bc296bc81b12","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"621180768fcf366cdd8521186941159331987896","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","status":"modified","additions":114,"deletions":114,"changes":228,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"5fa00056b2ed4b6af11592f9402bdaf1a3bd9a92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"48dfc2fe7009288899dba539b59b84abdae8e208","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"becb017e968756a45cebaef05d610831e39f1bb5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"2a4c4c6659a0a0c259560d7d833caa3538b178dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","status":"modified","additions":101,"deletions":101,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"d800ec33b215895d0d4ebbbcaa9da3e93bd64e56","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","status":"modified","additions":175,"deletions":175,"changes":350,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"2aea112c2ecd6542c97f915f0272fdccd00c4b3b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"7ba8a6ed5beeddc81bf5e37adfe1f89e45630dee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"f24944b3d0a6127ee6f02e26fee4146076bf5b72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","status":"modified","additions":105,"deletions":105,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"fdb7a2156b2bce5114cb97f7036fe9602ca40ff6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"242a09c3227a33a56618aa1fb7805f7bad80c0d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","status":"modified","additions":174,"deletions":174,"changes":348,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ec2f5062db30b71118905e1ab508f71c3532f726","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","status":"modified","additions":72,"deletions":72,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"080327c1385fbfdaf00a638246dfeccd0ba02921","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"8b1bc084abfaded0295fa5e5ec6f27e84801e1a6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ead3fb0f9dabaa7f9e786d902d5c8ab9307b14b7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"5912f6ffbbcf9ea384e2be1cab978d06e6a8306d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","status":"modified","additions":23,"deletions":23,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"d0a1fe951da85603d2a1a4de939c2513e1cd2bae","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"aec9b9c6e60c6fe87469ec985d65532543fb8f69","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"e4cb7fd95b21cc956413c8cfbd4ab244f68453cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"7f3f5b8cfbd6fe10f6cc7e74de2506ce188e8b11","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"d25787b8dd3308a4b4e380b25040f23b8413b932","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","status":"modified","additions":112,"deletions":112,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"4a58be28ea33356a0e0d4df24c98abfa08dfd2d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"1b56f4ef92f2499081d5ea0b548d3b642aac3ee0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"22b248f17cac08f9dbcc1735a722ad64bd61c7ed","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","status":"modified","additions":61,"deletions":61,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"c972c3d5b9da04aed29b5dae303fc5bb8cc39bb4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"b442917faa976369d559923627fa99a787072bec","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"b7ad1369f2d8c9391f60823b6c3268b23964db6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"886f1236a6326994802e96317d11c89681864572","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ff6857bbb787807c462040ff0c354c4577579378","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"58947ed002d2e50b3eb133edc20c854ac620d4c2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ae0534c85816e4ae786993a2072aad3ccae3ec30","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"34b3f97224196e516e1912e398221f1d14ca3bb2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","status":"modified","additions":165,"deletions":165,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"50cb00df18f3cb100c085e8f9a8abe48c66fc220","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","status":"modified","additions":104,"deletions":104,"changes":208,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"54d266f0582b068389bc3f49e834b444faf11cd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"0b90b93ab6e09424a5764ac3d7491d9e92028902","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","status":"modified","additions":65,"deletions":65,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"b13cfcb10758e676a294c733e4d0bd6f2dc4e9f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntitySub.java","status":"modified","additions":36,"deletions":36,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntitySub.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntitySub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/ManyOneEntitySub.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"0760ad5cdeb335206fd19033608f7c6408610483","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"fc389048adc795703cc174b638bf6cbf736ec8ce","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/SimpleEntity2.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"43b22bf899d400fd83832e9d62c119191ef2b02d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDataStoreActions.java","status":"modified","additions":39,"deletions":39,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDataStoreActions.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDataStoreActions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDataStoreActions.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"8fb0a383c7ff79e5b79c60781d4956e37d36f38e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDistinctQueries.java","status":"modified","additions":98,"deletions":98,"changes":196,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDistinctQueries.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDistinctQueries.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestDistinctQueries.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"46a7bbad0cc84700059dde18760576f43ef6844e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestEscapedSingleQuotesInJPQL.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestEscapedSingleQuotesInJPQL.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestEscapedSingleQuotesInJPQL.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestEscapedSingleQuotesInJPQL.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"702292d4995e5669c6dcd65f838bf7107cf8af19","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestInMemoryQueryMatchEscapes.java","status":"modified","additions":69,"deletions":69,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestInMemoryQueryMatchEscapes.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestInMemoryQueryMatchEscapes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestInMemoryQueryMatchEscapes.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"d0cdbddd6fe77833c5fe52624ac28a4bb34afaee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestMethodQLQuery.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestMethodQLQuery.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestMethodQLQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestMethodQLQuery.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"13aa958a7f9b883f22ec9e7b33cced57ce827b96","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/BasicEntity.java","status":"modified","additions":61,"deletions":61,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/BasicEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/BasicEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/BasicEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"4a50af786785888d07e254cf7ade30e9d73c18ae","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyChild.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyChild.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyChild.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyChild.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"f61fce26ae83a3a13099dd57833111089347b60d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyParent.java","status":"modified","additions":69,"deletions":69,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyParent.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyParent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/CascadingOneManyParent.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"88b94bd0101dcbe1a7ca48d008d4d8eb0d87063a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreBasicEntity.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreBasicEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreBasicEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreBasicEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"bf5128c667b7be92e0d696ab98bb26d0c64d3884","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreManyOneIdOwner.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreManyOneIdOwner.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreManyOneIdOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/DataStoreManyOneIdOwner.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"8906e9f48be51827186af0991034e859a277a097","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/EmbeddableWithRelation.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/EmbeddableWithRelation.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/EmbeddableWithRelation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/EmbeddableWithRelation.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"0bbf14cc56cd9e744f7e888b5156392787f542df","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneCompoundIdOwner.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneCompoundIdOwner.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneCompoundIdOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneCompoundIdOwner.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ef4b09e5a8beb90a101ad8078c1a9cdbea472502","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneIdOwner.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneIdOwner.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneIdOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/ManyOneIdOwner.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"6ab328b509cf4e292cf71e0fd3e6e2baedb7be01","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/MultipleSameTypedEmbedded.java","status":"modified","additions":80,"deletions":80,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/MultipleSameTypedEmbedded.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/MultipleSameTypedEmbedded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/MultipleSameTypedEmbedded.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ae0891dbe3db032c29c7b476f9b67cb8dc259933","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TargetedIFaceRelationParent.java","status":"modified","additions":64,"deletions":64,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TargetedIFaceRelationParent.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TargetedIFaceRelationParent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TargetedIFaceRelationParent.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"cc8b2bac8b03b473648c92a2bc6eeb4e199ae201","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestBulkUpdatesAndEmbeddedFields.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestBulkUpdatesAndEmbeddedFields.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestBulkUpdatesAndEmbeddedFields.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestBulkUpdatesAndEmbeddedFields.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"425d4fa19d3df7d677652579e32dcf9336b12886","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/NamedEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/NamedEntity.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"3c44eb6be10df5e254df5973dc824630640bca43","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestBasicAnnotation.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestBasicAnnotation.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestBasicAnnotation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestBasicAnnotation.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"47ae8de872b02e53be7b030465c7f950c537b23a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMerge.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMerge.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMerge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestEntityManagerMerge.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"b9a124711d955798ece423695b84685a9c0c1259","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","status":"modified","additions":94,"deletions":94,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/simple/TestPersistence.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"e402a73631126dcf751d15120422e2cff4a7b26b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoClearType.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoClearType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoClearType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoClearType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"88aa1adcf1d24afc34fc761c134f6833cb64513a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoDetachType.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoDetachType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoDetachType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AutoDetachType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"02fe56f5f92a672db799f2222dd188cfbd1d18dd","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/CallbackMode.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/CallbackMode.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/CallbackMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/CallbackMode.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"5a77e82585e9f5d56c297ae3357bba6a25487f86","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConnectionRetainMode.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConnectionRetainMode.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConnectionRetainMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/ConnectionRetainMode.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"db6a0fd0d243bd3e1f5ba93eec92af0d70b5e2e9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachStateType.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachStateType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachStateType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/DetachStateType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"185b30aeffb844a9d6c91778e1ac07bca1c0b0e0","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":1130,"deletions":1130,"changes":2260,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"ffef42e7559028b56d6afd197fcfa802abdad5a6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/JPAFacadeHelper.java","status":"modified","additions":319,"deletions":319,"changes":638,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/JPAFacadeHelper.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/JPAFacadeHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/JPAFacadeHelper.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"a5b7058f17db59e2a392c32c2e6d9bba0a66c9db","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactorySPI.java","status":"modified","additions":71,"deletions":71,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactorySPI.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactorySPI.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerFactorySPI.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"135fcc780537b8d4afd161103a24880aa5190a7b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerSPI.java","status":"modified","additions":104,"deletions":104,"changes":208,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerSPI.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerSPI.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityManagerSPI.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"7b7cf8597f629ec6de030e6fe28b0134bcc6576b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityTransaction.java","status":"modified","additions":71,"deletions":71,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityTransaction.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityTransaction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEntityTransaction.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"bde8162b0cadca75840c5c38b8600653cf1eb54a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuerySPI.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuerySPI.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuerySPI.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAQuerySPI.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"a683f8d12b72876d0ce91f76135f511eeae890ec","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryOperationType.java","status":"modified","additions":59,"deletions":59,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryOperationType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryOperationType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/QueryOperationType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"f65439b9c4969ae1c68dc6e6aade5cf20979ffe8","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RestoreStateType.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RestoreStateType.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RestoreStateType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/RestoreStateType.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"},{"sha":"a98a9661bdf63e66e19a873b4ba321aa43d2e5ab","filename":"openjpa-persistence/src/test/java/org/apache/openjpa/persistence/TestEnumToKernelConstantMappings.java","status":"modified","additions":270,"deletions":270,"changes":540,"blob_url":"https://github.com/apache/openjpa/blob/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/test/java/org/apache/openjpa/persistence/TestEnumToKernelConstantMappings.java","raw_url":"https://github.com/apache/openjpa/raw/3b34f93d8090738fa2875cabb78a694babb49505/openjpa-persistence/src/test/java/org/apache/openjpa/persistence/TestEnumToKernelConstantMappings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/test/java/org/apache/openjpa/persistence/TestEnumToKernelConstantMappings.java?ref=3b34f93d8090738fa2875cabb78a694babb49505"}]}

