{"sha":"3eff16e07afd3ce6252574ded5a54920b2965c1f","node_id":"MDY6Q29tbWl0MjA2MzY0OjNlZmYxNmUwN2FmZDNjZTYyNTI1NzRkZWQ1YTU0OTIwYjI5NjVjMWY=","commit":{"author":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2009-05-08T19:53:16Z"},"committer":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2009-05-08T19:53:16Z"},"message":"OPENJPA-1074 Maintain contiguous index for collection element removal\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@773070 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2b4db4b5f9a89cc68d1beff8b08665653fa5b47b","url":"https://api.github.com/repos/apache/openjpa/git/trees/2b4db4b5f9a89cc68d1beff8b08665653fa5b47b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/3eff16e07afd3ce6252574ded5a54920b2965c1f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/3eff16e07afd3ce6252574ded5a54920b2965c1f","html_url":"https://github.com/apache/openjpa/commit/3eff16e07afd3ce6252574ded5a54920b2965c1f","comments_url":"https://api.github.com/repos/apache/openjpa/commits/3eff16e07afd3ce6252574ded5a54920b2965c1f/comments","author":null,"committer":null,"parents":[{"sha":"c5f203f3f2920a059afddcf9228fcf04be2d4388","url":"https://api.github.com/repos/apache/openjpa/commits/c5f203f3f2920a059afddcf9228fcf04be2d4388","html_url":"https://github.com/apache/openjpa/commit/c5f203f3f2920a059afddcf9228fcf04be2d4388"}],"stats":{"total":280,"additions":273,"deletions":7},"files":[{"sha":"90c9fc8306716dd46ff9c07c2ef8981e0c5ca144","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java?ref=3eff16e07afd3ce6252574ded5a54920b2965c1f","patch":"@@ -197,8 +197,12 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                 ct = proxy.getChangeTracker();\n         }\n \n-        // if no fine-grained change tracking then just delete and reinsert\n-        if (ct == null || !ct.isTracking()) {\n+        Column order = field.getOrderColumn();\n+\n+        // if no fine-grained change tracking or if an item was removed\n+        // from an ordered collection, delete and reinsert\n+        if (ct == null || !ct.isTracking() ||\n+            (order != null && !ct.getRemoved().isEmpty())) {\n             delete(sm, store, rm);\n             insert(sm, store, rm, obj);\n             return;\n@@ -227,7 +231,6 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                 field.getJoinColumnIO(), sm);\n \n             int seq = ct.getNextSequence();\n-            Column order = field.getOrderColumn();\n             boolean setOrder = field.getOrderColumnIO().isInsertable(order,\n                 false);\n             for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {"},{"sha":"9736d58cad0c8f4252f379ca89e5540a25cbe294","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java?ref=3eff16e07afd3ce6252574ded5a54920b2965c1f","patch":"@@ -186,8 +186,12 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                 ct = proxy.getChangeTracker();\n         }\n \n-        // if no fine-grained change tracking then just delete and reinsert\n-        if (ct == null || !ct.isTracking()) {\n+        Column order = field.getOrderColumn();\n+\n+        // if no fine-grained change tracking or if an item was removed\n+        // from an ordered collection, delete and reinsert\n+        if (ct == null || !ct.isTracking() ||\n+            (order != null && !ct.getRemoved().isEmpty())) {\n             delete(sm, store, rm);\n             insert(sm, rm, obj);\n             return;\n@@ -220,7 +224,6 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                 field.getJoinColumnIO(), sm);\n \n             int seq = ct.getNextSequence();\n-            Column order = field.getOrderColumn();\n             boolean setOrder = field.getOrderColumnIO().isInsertable(order,\n                 false);\n             for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {"},{"sha":"c1378a91f941f14abc73e168611c62974502b55d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/order/TestOrderColumn.java","status":"modified","additions":261,"deletions":1,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/order/TestOrderColumn.java","raw_url":"https://github.com/apache/openjpa/raw/3eff16e07afd3ce6252574ded5a54920b2965c1f/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/order/TestOrderColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/order/TestOrderColumn.java?ref=3eff16e07afd3ce6252574ded5a54920b2965c1f","patch":"@@ -74,6 +74,266 @@ public void setUp() {\n         }\n     }\n \n+    /*\n+     * Verifies that a collection remains contiguous and element\n+     * indexes are reordered if an element is removed for a\n+     * OneToMany relationship \n+     */\n+    public void testOneToManyElementRemoval() {\n+        OpenJPAEntityManagerSPI em = emf.createEntityManager();\n+\n+        // Verify field name is the default via fm\n+        validateOrderColumnName(BattingOrder.class, \"batters\", \n+            \"batters_ORDER\");// \"batters_ORDER\");\n+\n+        // Create some data\n+        Player[] players = new Player[10];\n+        ArrayList<Player> playersArr = new ArrayList<Player>();\n+        em.getTransaction().begin();\n+        for (int i = 0; i < 10 ; i++) {\n+            players[i] = new Player(\"Player\" + i, i+100);\n+            em.persist(players[i]);\n+            playersArr.add(players[i]);\n+        }\n+        em.getTransaction().commitAndResume();\n+                      \n+        // Persist the related entities\n+        BattingOrder order = new BattingOrder();\n+        order.setBatters(playersArr);\n+        em.persist(order);\n+        em.getTransaction().commit();\n+        em.refresh(order);\n+        em.clear();\n+        \n+        // Verify order is correct.\n+        BattingOrder newOrder = em.find(BattingOrder.class, order.id);\n+        assertNotNull(newOrder);\n+        for (int i = 0; i < 10 ; i++) {\n+            assertEquals(newOrder.getBatters().get(i), (players[i]));\n+        }\n+        \n+        // Remove some items\n+        em.getTransaction().begin();\n+        newOrder.getBatters().remove(1);\n+        playersArr.remove(1);\n+        newOrder.getBatters().remove(5);\n+        playersArr.remove(5);        \n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        // Simple assertion via find\n+        newOrder = em.find(BattingOrder.class, order.id);\n+        assertNotNull(newOrder);\n+        assertNotNull(newOrder.getBatters());\n+        assertEquals(playersArr.size(), newOrder.getBatters().size());\n+        for (int i = 0; i < playersArr.size() ; i++) {\n+              assertEquals(newOrder.getBatters().get(i), (playersArr.get(i)));\n+        }\n+\n+        // Stronger assertion via INDEX value\n+        validateIndexAndValues(em, \"BattingOrder\", \"batters\", 0, \n+            playersArr.toArray(), \"id\", \n+            order.id);\n+        \n+        em.close();        \n+    }\n+\n+    /*\n+     * Verifies that a collection remains contiguous and element\n+     * indexes are reordered if an element is removed for an\n+     * ElementCollection \n+     */\n+    public void testElementCollectionElementRemoval() {\n+        OpenJPAEntityManagerSPI em = emf.createEntityManager();\n+        Game game = new Game();\n+        \n+        // Verify field name is the default via fm\n+        validateOrderColumnName(Game.class, \"rainDates\", \n+            \"dateOrder\"); \n+        \n+        // Create a list of basic types\n+        java.sql.Date dates[] = new java.sql.Date[10];\n+        ArrayList<java.sql.Date> rainDates = new ArrayList<java.sql.Date>(10);\n+        Calendar today = Calendar.getInstance();\n+        for (int i = 0; i < 10; i++) {\n+            today.set(2009, 1, i+1);\n+            dates[i] = new java.sql.Date(today.getTimeInMillis());\n+        }\n+        // Add in reverse order\n+        for (int i = 9; i >= 0; i--) {\n+            rainDates.add(dates[i]);\n+        }\n+        game.setRainDates(rainDates);\n+        \n+        em.getTransaction().begin();\n+        em.persist(game);\n+        em.getTransaction().commit();\n+               \n+        em.clear();\n+        \n+        Game newGame = em.find(Game.class, game.getId());\n+        assertNotNull(newGame);\n+        // Verify the order\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(game.getRainDates().get(i),\n+                rainDates.get(i));\n+        }\n+        \n+        // Remove some dates\n+        em.getTransaction().begin();\n+        game.getRainDates().remove(4);\n+        rainDates.remove(4);\n+        game.getRainDates().remove(2);\n+        rainDates.remove(2);\n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        newGame = em.find(Game.class, game.getId());\n+        assertNotNull(newGame);\n+        assertNotNull(game.getRainDates());\n+        assertEquals(8, game.getRainDates().size());\n+        // Verify the order\n+        for (int i = 0; i < game.getRainDates().size(); i++) {\n+            assertEquals(game.getRainDates().get(i),\n+                rainDates.get(i));\n+        }\n+        \n+        em.close();\n+    }\n+    /*\n+     * Verifies that a collection remains contiguous and element\n+     * indexes are reordered if an element is inserted into the collection. \n+     */\n+    public void testOneToManyElementInsert() {\n+        OpenJPAEntityManagerSPI em = emf.createEntityManager();\n+\n+        // Verify field name is the default via fm\n+        validateOrderColumnName(BattingOrder.class, \"batters\", \n+            \"batters_ORDER\");// \"batters_ORDER\");\n+\n+        // Create some data\n+        Player[] players = new Player[10];\n+        ArrayList<Player> playersArr = new ArrayList<Player>();\n+        em.getTransaction().begin();\n+        for (int i = 0; i < 10 ; i++) {\n+            players[i] = new Player(\"Player\" + i, i+100);\n+            em.persist(players[i]);\n+            playersArr.add(players[i]);\n+        }\n+        em.getTransaction().commitAndResume();\n+                      \n+        // Persist the related entities\n+        BattingOrder order = new BattingOrder();\n+        order.setBatters(playersArr);\n+        em.persist(order);\n+        em.getTransaction().commitAndResume();\n+        em.refresh(order);\n+        \n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        // Verify order is correct.\n+        BattingOrder newOrder = em.find(BattingOrder.class, order.id);\n+        assertNotNull(newOrder);\n+        for (int i = 0; i < 10 ; i++) {\n+            assertEquals(newOrder.getBatters().get(i), (players[i]));\n+        }\n+                \n+        Player p = new Player(\"PlayerNew\", 150);\n+        playersArr.add(2, p);\n+\n+        Player p2 = new Player(\"PlayerNew2\", 151);\n+        playersArr.add(p2);\n+        // Add an item at index 2 and at the end of the list \n+        em.getTransaction().begin();\n+        newOrder.getBatters().add(2, p);\n+        newOrder.getBatters().add(p2);\n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        // Simple assertion via find\n+        newOrder = em.find(BattingOrder.class, order.id);\n+        assertNotNull(newOrder);\n+        assertNotNull(newOrder.getBatters());\n+        assertEquals(playersArr.size(), newOrder.getBatters().size());\n+        for (int i = 0; i < playersArr.size() ; i++) {\n+              assertEquals(newOrder.getBatters().get(i), (playersArr.get(i)));\n+        }\n+\n+        // Stronger assertion via INDEX value\n+        validateIndexAndValues(em, \"BattingOrder\", \"batters\", 0, \n+            playersArr.toArray(), \"id\", \n+            order.id);\n+        \n+        em.close();        \n+    }\n+    /*\n+     * Verifies that a collection remains contiguous and element\n+     * indexes are reordered if an element is inserted into an\n+     * ElementCollection \n+     */\n+    public void testElementCollectionElementInsert() {\n+        OpenJPAEntityManagerSPI em = emf.createEntityManager();\n+        Game game = new Game();\n+        \n+        // Verify field name is the default via fm\n+        validateOrderColumnName(Game.class, \"rainDates\", \n+            \"dateOrder\"); \n+        \n+        // Create a list of basic types\n+        java.sql.Date dates[] = new java.sql.Date[10];\n+        ArrayList<java.sql.Date> rainDates = new ArrayList<java.sql.Date>(10);\n+        Calendar today = Calendar.getInstance();\n+        for (int i = 0; i < 10; i++) {\n+            today.set(2009, 1, i+1);\n+            dates[i] = new java.sql.Date(today.getTimeInMillis());\n+        }\n+        // Add in reverse order\n+        for (int i = 9; i >= 0; i--) {\n+            rainDates.add(dates[i]);\n+        }\n+        game.setRainDates(rainDates);\n+        \n+        em.getTransaction().begin();\n+        em.persist(game);\n+        em.getTransaction().commit();\n+               \n+        em.clear();\n+        \n+        Game newGame = em.find(Game.class, game.getId());\n+        assertNotNull(newGame);\n+        // Verify the order\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(game.getRainDates().get(i),\n+                rainDates.get(i));\n+        }\n+        \n+        // Add some dates\n+        today.set(2009, 1, 15);\n+        rainDates.add(1, new java.sql.Date(today.getTimeInMillis()));\n+        today.set(2009, 1, 20);\n+        rainDates.add(6, new java.sql.Date(today.getTimeInMillis()));\n+        \n+        em.getTransaction().begin();\n+        game.getRainDates().add(1, rainDates.get(1));\n+        game.getRainDates().add(6, rainDates.get(6));\n+        em.getTransaction().commit();\n+        em.clear();\n+\n+        newGame = em.find(Game.class, game.getId());\n+        assertNotNull(newGame);\n+        assertNotNull(game.getRainDates());\n+        assertEquals(12, game.getRainDates().size());\n+        // Verify the order\n+        for (int i = 0; i < game.getRainDates().size(); i++) {\n+            assertEquals(game.getRainDates().get(i),\n+                rainDates.get(i));\n+        }\n+        \n+        em.close();\n+    }\n+\n+    \n     /*\n      * Validates use of OrderColumn with OneToMany using the default\n      * order column name\n@@ -851,7 +1111,7 @@ private void validateIndexAndValues(OpenJPAEntityManagerSPI em,\n         List rlist = qry.getResultList();  \n         \n         assertNotNull(rlist);\n-        assertEquals(rlist.size(), objs.length); \n+        assertEquals(objs.length, rlist.size()); \n         TreeMap<Long, Object> objMap = new TreeMap<Long, Object>();\n         for (int i = 0; i < objs.length; i++)\n         {"}]}

