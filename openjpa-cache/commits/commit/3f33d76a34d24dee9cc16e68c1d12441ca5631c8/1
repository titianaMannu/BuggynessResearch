{"sha":"3f33d76a34d24dee9cc16e68c1d12441ca5631c8","node_id":"MDY6Q29tbWl0MjA2MzY0OjNmMzNkNzZhMzRkMjRkZWU5Y2MxNmU2OGMxZDEyNDQxY2E1NjMxYzg=","commit":{"author":{"name":"Heath Thomann","email":"hthomann@apache.org","date":"2014-05-01T03:24:11Z"},"committer":{"name":"Heath Thomann","email":"hthomann@apache.org","date":"2014-05-01T03:24:11Z"},"message":"OPENJPA-2476: Fixed OptimisticLockEx due to rounding of a Timestamp\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1591541 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0616156cd62ad70ba8dd05bec0e6baf8d0a07059","url":"https://api.github.com/repos/apache/openjpa/git/trees/0616156cd62ad70ba8dd05bec0e6baf8d0a07059"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/3f33d76a34d24dee9cc16e68c1d12441ca5631c8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/3f33d76a34d24dee9cc16e68c1d12441ca5631c8","html_url":"https://github.com/apache/openjpa/commit/3f33d76a34d24dee9cc16e68c1d12441ca5631c8","comments_url":"https://api.github.com/repos/apache/openjpa/commits/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/comments","author":null,"committer":null,"parents":[{"sha":"4f23e3fc95bf43ed598bdbd05988faa118ac35f2","url":"https://api.github.com/repos/apache/openjpa/commits/4f23e3fc95bf43ed598bdbd05988faa118ac35f2","html_url":"https://github.com/apache/openjpa/commit/4f23e3fc95bf43ed598bdbd05988faa118ac35f2"}],"stats":{"total":289,"additions":268,"deletions":21},"files":[{"sha":"af7ac11657bca0e51cc9e644cd031178613024ed","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":5,"deletions":15,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=3f33d76a34d24dee9cc16e68c1d12441ca5631c8","patch":"@@ -96,6 +96,7 @@\n import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.Seq;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n import org.apache.openjpa.kernel.exps.Path;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n@@ -1288,24 +1289,13 @@ public void setTime(PreparedStatement stmnt, int idx, Time val,\n     public void setTimestamp(PreparedStatement stmnt, int idx,\n         Timestamp val, Calendar cal, Column col)\n         throws SQLException {\n-        // ensure that we do not insert dates at a greater precision than\n-        // that at which they will be returned by a SELECT\n-        int rounded = (int) Math.round(val.getNanos() /\n-            (double) datePrecision);\n-        int nanos = rounded * datePrecision;\n-        if (nanos > 999999999) {\n-            // rollover to next second\n-            val.setTime(val.getTime() + 1000);\n-            nanos = 0;\n-        }\n         \n-        Timestamp valForStmnt = new Timestamp(val.getTime());\n-        valForStmnt.setNanos(nanos);\n-\n+        val = StateManagerImpl.roundTimestamp(val, datePrecision);\n+        \n         if (cal == null)\n-            stmnt.setTimestamp(idx, valForStmnt);\n+            stmnt.setTimestamp(idx, val);\n         else\n-            stmnt.setTimestamp(idx, valForStmnt, cal);\n+            stmnt.setTimestamp(idx, val, cal);\n     }\n \n     /**"},{"sha":"b4fc048b49014d0cc3756ca106f7c3e24415ab8b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":41,"deletions":3,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=3f33d76a34d24dee9cc16e68c1d12441ca5631c8","patch":"@@ -25,6 +25,7 @@\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.lang.reflect.Modifier;\n+import java.sql.Timestamp;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -159,6 +160,8 @@\n     \n     private transient ReentrantLock _instanceLock = null;\n \n+    private int _datePrecision = -1;\n+        \n     /**\n      * <p>set to <code>false</code> to prevent the postLoad method from\n      * sending lifecycle callback events.</p>\n@@ -716,13 +719,48 @@ Object getLoadVersion() {\n     public void setNextVersion(Object version) {\n         assignVersionField(version);\n     }\n-\n+    \n+    public static Timestamp roundTimestamp(Timestamp val, int datePrecision) {\n+        // ensure that we do not insert dates at a greater precision than\n+        // that at which they will be returned by a SELECT\n+        int rounded = (int) Math.round(val.getNanos() / (double) datePrecision);\n+        long time = val.getTime();\n+        int nanos = rounded * datePrecision;\n+        if (nanos > 999999999) {\n+            // rollover to next second\n+            time = time + 1000;\n+            nanos = 0;\n+        }\n+\n+        val = new Timestamp(time);\n+        val.setNanos(nanos);\n+        return val;\n+    }\n+    \n     private void assignVersionField(Object version) {\n+\n+        if (version instanceof Timestamp) {\n+            if (_datePrecision == -1) {\n+                try {\n+                    OpenJPAConfiguration conf = _broker.getConfiguration();\n+                    Class confCls = Class.forName(\"org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl\");\n+                    if (confCls.isAssignableFrom(conf.getClass())) {\n+                        Object o = conf.getClass().getMethod(\"getDBDictionaryInstance\").invoke(conf, (Object[]) null);\n+                        _datePrecision = o.getClass().getField(\"datePrecision\").getInt(o);\n+                    } else {\n+                        _datePrecision = 1000;\n+                    }\n+                } catch (Throwable e) {\n+                    _datePrecision = 1000;\n+                }\n+            }\n+\n+            version = roundTimestamp((Timestamp) version, _datePrecision);\n+        }\n         _version = version;\n         FieldMetaData vfield = _meta.getVersionField();\n         if (vfield != null)\n-            store(vfield.getIndex(), JavaTypes.convert(version,\n-                vfield.getTypeCode()));\n+            store(vfield.getIndex(), JavaTypes.convert(version, vfield.getTypeCode()));\n     }\n \n     public PCState getPCState() {"},{"sha":"205eb7551e314888c453b797e6dccb3d4b0e95f0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/TestTimestampOptLockEx.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/TestTimestampOptLockEx.java","raw_url":"https://github.com/apache/openjpa/raw/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/TestTimestampOptLockEx.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/TestTimestampOptLockEx.java?ref=3f33d76a34d24dee9cc16e68c1d12441ca5631c8","patch":"@@ -0,0 +1,129 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.optlockex.timestamp;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityTransaction;\r\n+\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/*\r\n+ * Test create for JIRA OPENJPA-2476, see it for a very detailed\r\n+ * description of the issue.\r\n+ */\r\n+public class TestTimestampOptLockEx extends SingleEMFTestCase {    \r\n+\r\n+    @Override\r\n+    public void setUp() {\r\n+        // By default we'd round a Timestamp to the nearest millisecond on Oracle (see DBDictionary.datePrecision \r\n+        // and DBDictionary.setTimestamp) and nearest microsecond on DB2 (see DB2Dictionary.datePrecision and \r\n+        // DBDictionary.setTimestamp) when sending the value to the db...if we change datePrecision to 1, we round to \r\n+        // the nearest nanosecond.  On DB2 and Oracle, it appears the default precision is microseconds but it seems\r\n+        // DB2 truncates (no rounding) to microsecond for anything it is given with greater precision, whereas Oracle\r\n+        // rounds.  So in the case of DB2, this test will pass if datePrecision=1, but still fails on Oracle.\r\n+        // On the other hand, if we set the datePrecision to 1000000 and run against DB2, the test will fail.\r\n+\r\n+        // This test requires datePrecision to be set to the same precision as the Timestamp column.\r\n+        // I've only been testing on Oracle and DB2 and not sure how other DBs treat a Timestamps precision\r\n+        // by default.  In VersionTSEntity I use a Timestamp(3) but this is not supported on, at least, Derby\r\n+        // and older versions of DB2...at this time I'll enable only on Oracle.\r\n+        setSupportedDatabases(org.apache.openjpa.jdbc.sql.OracleDictionary.class);\r\n+        if (isTestsDisabled()) {\r\n+            return;\r\n+        }        \r\n+  \r\n+        // Set datePrecision=1000000 for Oracle since we are using Timestamp(3)....on Oracle\r\n+        // the default is 1000000 so we shouldn't need to set it, but lets set it to future\r\n+        // proof the test.\r\n+        super.setUp(DROP_TABLES, \"openjpa.jdbc.DBDictionary\", \"datePrecision=1000000\", VersionTSEntity.class);\r\n+    }\r\n+    \r\n+    public void testUpdate() {\r\n+        poplulate();\r\n+        //This loop is necessary since we need a timestamp which has been rounded up\r\n+        //by the database, or by OpenJPA such that the in-memory version of the Timestamp\r\n+        //varies from that which is in the database.\r\n+        for (int i = 0; i < 50000; i++) {\r\n+            EntityManager em = emf.createEntityManager();\r\n+            EntityTransaction tx = em.getTransaction();\r\n+\r\n+            // Find an existing VersionTSEntity:\r\n+            // stored with microsecond precision, e.g. 2014-01-21 13:16:46.595428\r\n+            VersionTSEntity t = em.find(VersionTSEntity.class, 1);\r\n+\r\n+            tx.begin();\r\n+            t.setSomeInt(t.getSomeInt() + 1);\r\n+            t = em.merge(t);\r\n+\r\n+            tx.commit();\r\n+            // If this clear is removed the test works fine.\r\n+            em.clear();\r\n+\r\n+            // Lets say at this point the 'in-memory' timestamp is: 2014-01-22 07:22:11.548778567.  What we \r\n+            // actually sent to the DB (via the previous merge) is by default rounded (see DBDictionary.setTimestamp) \r\n+            // to the nearest millisecond on Oracle (see DBDictionary.datePrecision) and nearest microsecond on \r\n+            // DB2 (see DB2Dictionary.datePrecision) when sending the value to the db.\r\n+            // Therefore, what we actually send to the db is: 2014-01-22 07:22:11.548779 (for DB2) or \r\n+            // 2014-01-22 07:22:11.549 (for Oracle).  Notice in either case we rounded up.\r\n+\r\n+            // now, do a merge with the unchanged entity\r\n+            tx = em.getTransaction();\r\n+            tx.begin();\r\n+\r\n+            t = em.merge(t); // this results in a select of VersionTSEntity\r\n+            \r\n+            //This 'fixes' the issue (but customer doesn't really want to add this):\r\n+            //em.refresh(t);\r\n+            \r\n+            // Here is where things get interesting.....an error will happen here when the timestamp \r\n+            // has been rounded up, as I'll explain:\r\n+            // As part of this merge/commit, we select the timestamp from the db to get its value \r\n+            // (see method ColumnVersionStrategy.checkVersion below), i.e: \r\n+            // 'SELECT t0.updateTimestamp FROM VersionTSEntity t0 WHERE t0.id = ?'.  \r\n+            // We then compare the 'in-memory' timestamp to that which we got back from the DB, i.e. on \r\n+            // DB2 we compare:\r\n+            // in-mem:  2014-01-22 07:22:11.548778567\r\n+            // from db: 2014-01-22 07:22:11.548779\r\n+            // Because these do not 'compare' properly (the db version is greater), we throw the OptimisticLockEx!!\r\n+            // For completeness, lets look at an example where the timestamp is as follows after the above \r\n+            // update: 2014-01-22 07:22:11.548771234.  We would send to DB2\r\n+            // the following value: 2014-01-22 07:22:11.548771.  Then, as part of the very last merge/commit, we'd \r\n+            // compare:\r\n+            // in-mem:  2014-01-22 07:22:11.548771234\r\n+            // from db: 2014-01-22 07:22:11.548771\r\n+            // These two would 'compare' properly (the db version is lesser), as such we would not throw an \r\n+            // OptLockEx and the test works fine.\r\n+            tx.commit();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+    \r\n+    public void poplulate(){\r\n+        EntityManager em = emf.createEntityManager();\r\n+        EntityTransaction tx = em.getTransaction();\r\n+        tx.begin();\r\n+        VersionTSEntity r = new VersionTSEntity();\r\n+        \r\n+        r.setId(1L);\r\n+        r.setSomeInt(0);\r\n+        em.persist(r);\r\n+        tx.commit();\r\n+        em.close();        \r\n+    }\r\n+}\r"},{"sha":"8b2945b1ef8281406e50d0748c368a60d6059f97","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/VersionTSEntity.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/VersionTSEntity.java","raw_url":"https://github.com/apache/openjpa/raw/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/VersionTSEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/optlockex/timestamp/VersionTSEntity.java?ref=3f33d76a34d24dee9cc16e68c1d12441ca5631c8","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.optlockex.timestamp;\r\n+\r\n+import java.io.Serializable;\r\n+import java.sql.Timestamp;\r\n+\r\n+import javax.persistence.Column;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.Id;\r\n+import javax.persistence.Version;\r\n+\r\n+@Entity\r\n+public class VersionTSEntity implements Serializable {\r\n+\r\n+    private static final long serialVersionUID = 2948711625184868242L;\r\n+\r\n+    @Id\r\n+    private Long id;\r\n+    \r\n+    @Version\r\n+    @Column(columnDefinition=\"TIMESTAMP(3)\")\r\n+    private Timestamp updateTimestamp;\r\n+\r\n+    private Integer someInt;\r\n+\r\n+    public Long getId() {\r\n+        return this.id;\r\n+    }\r\n+\r\n+    public void setId(Long id) {\r\n+        this.id = id;\r\n+    }\r\n+\r\n+    public Timestamp getUpdateTimestamp() {\r\n+        return this.updateTimestamp;\r\n+    }\r\n+\r\n+    public void setSomeInt(Integer someInt) {\r\n+        this.someInt = someInt;\r\n+        \r\n+    }\r\n+\r\n+    public Integer getSomeInt() {\r\n+        return someInt;\r\n+    }\r\n+}\r"},{"sha":"c6263b80980ed6919dc2bbb84471b7e3923f74cb","filename":"openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","status":"modified","additions":30,"deletions":3,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","raw_url":"https://github.com/apache/openjpa/raw/3f33d76a34d24dee9cc16e68c1d12441ca5631c8/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml?ref=3f33d76a34d24dee9cc16e68c1d12441ca5631c8","patch":"@@ -1405,9 +1405,36 @@ This value is usually one million, meaning that the database is able\n to store time values with a precision of one millisecond.  Particular\n databases may have more or less precision.\n OpenJPA will round all time values to this degree of precision\n-before storing them in the database.\n-Defaults to 1000000.\n-                    </para>\n+before storing them in the database.  This property can be set to one \n+of the following precisions:\n+                </para>\n+                <itemizedlist>\n+                    <listitem>\n+                        <para>\n+<literal>DECI</literal>: 100000000\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>CENIT</literal>: 10000000\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>MILLI (default precision)</literal>: 1000000\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>MICRO</literal>: 1000\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>NANO (max precision)</literal>: 1\n+                        </para>\n+                    </listitem>\n+                </itemizedlist>\n                 </listitem>\n                 <listitem id=\"DBDictionary.DateMillisecondBehavior\">\n                     <para>"}]}

